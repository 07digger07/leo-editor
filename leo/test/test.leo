<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="97" left="13" height="643" width="1008"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070416075121"><vh>Startup</vh>
<v t="ekr.20070529172620"><vh>@chapters</vh>
<v t="ekr.20090605083941.1804"><vh>@chapter foo</vh>
<v t="ekr.20090605083941.1805"><vh>foo node 1</vh></v>
</v>
<v t="ekr.20070529173219"><vh>@chapter abc</vh>
<v t="ekr.20070529173219.1"><vh>abc node 1</vh></v>
<v t="ekr.20071206070207"><vh>cross-chapter-clone-test</vh></v>
</v>
<v t="ekr.20070603190944"><vh>@chapter xyz</vh>
<v t="ekr.20070603190944.1"><vh>xyz node 1</vh></v>
<v t="ekr.20071206070207"></v>
</v>
</v>
<v t="ekr.20070224123943"><vh>@settings</vh>
<v t="ekr.20091230064146.1911"><vh>@data import_xml_tags</vh></v>
<v t="ekr.20090815161520.1815"><vh>@string vim_trigger_event = select2</vh></v>
<v t="ekr.20080922164255.1"><vh>@string test = c:\leo.repo\trunk\leo\test</vh></v>
<v t="ekr.20090629105832.1790"><vh>@@bool big_outline_pane = True</vh></v>
<v t="ekr.20080412082246.1"><vh>@bool fixedWindow = False</vh></v>
<v t="ekr.20070604100125"><vh>@bool use_chapter_tabs = True</vh></v>
<v t="ekr.20070503085527"><vh>@bool use_chapters = True</vh></v>
<v t="ekr.20071025193940"><vh>@enabled-plugins</vh></v>
<v t="ekr.20080529111617.1"><vh>plugins</vh>
<v t="ekr.20070723091227"><vh>http plugin</vh>
<v t="ekr.20070723091227.1"><vh>@bool http_active = True</vh></v>
<v t="ekr.20070723091227.2"><vh>@int</vh>
<v t="ekr.20090316115500.1"><vh>port = 8080</vh></v>
</v>
<v t="ekr.20070723091227.3"><vh>@string rst_http_attributename = 'rst_http_attribute'</vh></v>
</v>
<v t="ekr.20080529111617.2"><vh>cleo</vh>
<v t="ekr.20080529111617.3"><vh>@color cleo_color_prog_green =</vh></v>
<v t="ekr.20080529111617.4"><vh>@color cleo_color_prog_red =</vh></v>
<v t="ekr.20080529111617.5"><vh>@data cleo_color_file_node_list</vh></v>
<v t="ekr.20080529111617.6"><vh>@int cleo_prog_width = 18</vh></v>
<v t="ekr.20080529111617.7"><vh>@float cleo_time_init = 1.0</vh></v>
<v t="ekr.20080529111617.8"><vh>@int cleo_prog_scale = 1</vh></v>
<v t="ekr.20080529111617.9"><vh>@float cleo_prog_extra = 4</vh></v>
<v t="ekr.20080529111617.10"><vh>@string cleo_time_name = 'days'</vh></v>
</v>
</v>
<v t="ekr.20080604104453.5"><vh>@strings [command,insert, overwrite] top_level_unbound_key_action = insert</vh></v>
<v t="ekr.20080729153237.1"><vh>Gc settings</vh>
<v t="ekr.20080729153237.2"><vh>@bool trace_gc = False</vh></v>
<v t="ekr.20080729153237.3"><vh>@bool trace_gc_calls = False</vh></v>
<v t="ekr.20080729153237.4"><vh>@bool trace_gc_verbose = False</vh></v>
</v>
<v t="ekr.20080822153619.1"><vh>@string shadow_subdir = .leo/shadow</vh></v>
</v>
<v t="ekr.20041001211817"><vh>Buttons</vh>
<v t="ekr.20090819085532.4265"><vh>@button detach-body</vh></v>
<v t="ekr.20080915095329.1"><vh>@@button rst3</vh></v>
<v t="ekr.20090718072135.1786"><vh>@button print sep</vh></v>
<v t="ekr.20090521070342.1907"><vh>@button show-rst</vh></v>
<v t="ekr.20070531102813"><vh>Disabled buttons</vh>
<v t="ekr.20060814111542"><vh>@@button add-e</vh></v>
<v t="ekr.20080813100905.1"><vh>@@button args-test @args = a,b,c</vh></v>
<v t="ekr.20060918083159"><vh>@@button Clear uAs</vh></v>
<v t="ekr.20071002150320"><vh>@@button create-canvas</vh></v>
<v t="ekr.20060809084033"><vh>@@button cvt to g.et</vh>
<v t="ekr.20060809104405"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20060809092023"><vh>test</vh>
<v t="ekr.20060809103738"><vh>test1</vh></v>
<v t="ekr.20060809103738.1"><vh>test2</vh></v>
</v>
<v t="ekr.20060809090508"><vh>replace</vh>
<v t="ekr.20060809091749.72"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="ekr.20060809091749.73"><vh>&lt;&lt; handle g.es &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070531104646"><vh>@@button da-comp</vh></v>
<v t="ekr.20070531103315"><vh>@@button da-expand</vh></v>
<v t="ekr.20081025105942.1"><vh>@@button dir</vh></v>
<v t="ekr.20070530072113"><vh>@@button hide-ch</vh></v>
<v t="ekr.20061030041200"><vh>@@button iron-py @key=Alt-5</vh></v>
<v t="ekr.20071025192258"><vh>@@button local-tests @key=Alt+4</vh></v>
<v t="ekr.20071006084354"><vh>@@button print tk line number</vh></v>
<v t="ekr.20080105115712"><vh>@@button pylint</vh>
<v t="ekr.20080115085447"><vh>harmless warnings, errors</vh></v>
<v t="ekr.20080105130903"><vh>warnings</vh></v>
<v t="ekr.20080105120559"><vh>&lt;&lt; define data &gt;&gt;</vh></v>
</v>
<v t="ekr.20070515073111"><vh>@@button sep</vh></v>
<v t="ekr.20060427103457"><vh>@@button settings.leo</vh></v>
<v t="ekr.20080310111916.1"><vh>@@button Translate "can not" to "can't"</vh></v>
<v t="ekr.20070115092430"><vh>@@button winpdb</vh></v>
<v t="ekr.20080815073750.1"><vh>@@button write-nosent-files</vh></v>
<v t="ekr.20071128122043"><vh>@@command create-shell-tab @key = Alt+5</vh></v>
<v t="ekr.20070604095313"><vh>Chapter buttons</vh>
<v t="ekr.20070530072113.1"><vh>@@button show-ch</vh></v>
<v t="ekr.20070603175054.1"><vh>@@button ch-main</vh></v>
<v t="ekr.20070603175054"><vh>@@button ch-abc</vh></v>
<v t="ekr.20070603190713.1"><vh>@@button ch-xyz</vh></v>
<v t="ekr.20070603190713"><vh>@@button ch-add-xyz</vh></v>
</v>
<v t="ekr.20060904110922"><vh>OPML buttons</vh>
<v t="ekr.20060904111037.1"><vh>@@button opml-write</vh></v>
<v t="ekr.20060904111037"><vh>@@button opml-read</vh></v>
</v>
</v>
<v t="ekr.20061030041450"><vh>Run Iron Python scripts</vh>
<v t="ekr.20061030041356"><vh>@url c:\prog\IronPython-1.0.1\Doc\IronPythonApiReference.chm</vh></v>
</v>
</v>
<v t="ekr.20070410063214"><vh>Commands</vh>
<v t="ekr.20060924180049"><vh>@@command clones-tab</vh>
<v t="ekr.20060924180049.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060924180049.2"><vh>init</vh></v>
<v t="ekr.20060924180049.3"><vh>getAllClones</vh></v>
<v t="ekr.20060924180049.4"><vh>displayClones</vh>
<v t="ekr.20060924180049.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060924180049.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20080214091706.2"><vh>@@command ekr-command</vh></v>
<v t="ekr.20080823154546.1"><vh>@@command parse-python @key = Alt-5</vh></v>
<v t="edward.20081127113749.2"><vh>@@command complete-previous</vh>
<v t="edward.20081127113749.3"><vh>WordCompleter</vh>
<v t="edward.20081127113749.4"><vh>complete_word</vh>
<v t="edward.20081127113749.5"><vh>&lt;&lt;backward search&gt;&gt;</vh>
<v t="edward.20081127113749.6"><vh>&lt;&lt;counter check&gt;&gt;</vh></v>
</v>
<v t="edward.20081127113749.7"><vh>&lt;&lt;forward search&gt;&gt;</vh>
<v t="edward.20081127113749.6"></v>
</v>
<v t="edward.20081127113749.8"><vh>&lt;&lt;clean up and exit&gt;&gt;</vh></v>
</v>
<v t="edward.20081127113749.9"><vh>acceptable_word</vh></v>
<v t="edward.20081127113749.10"><vh>undo_replacement</vh></v>
<v t="edward.20081127113749.11"><vh>redo_replacement</vh></v>
<v t="edward.20081127113749.12"><vh>exit</vh></v>
<v t="edward.20081127113749.13"><vh>run</vh></v>
<v t="edward.20081127113749.14"><vh>adjust</vh></v>
</v>
<v t="edward.20081127113749.15"><vh>getCurrentWord</vh></v>
</v>
<v t="edward.20081127113749.16"><vh>@@command complete-next</vh>
<v t="edward.20081127113749.3"></v>
<v t="edward.20081127113749.15"></v>
</v>
</v>
<v t="ekr.20071026102420.3"><vh>Scripts</vh>
<v t="ekr.20071129103842"><vh>create-at-auto-nodes</vh></v>
<v t="ekr.20070517070854"><vh>run script in nullGui</vh></v>
<v t="ekr.20070517071510"><vh>run script with leoBridge</vh></v>
<v t="ekr.20080206055658"><vh>Script to print font settings</vh></v>
<v t="ekr.20090428081009.1"><vh>patching auto-completion table</vh></v>
<v t="ekr.20090728090618.2832"><vh>Recursive import script</vh>
<v t="ekr.20090728090618.2833"><vh>importFiles</vh></v>
<v t="ekr.20090728090618.2834"><vh>importDir</vh></v>
<v t="ekr.20090728090618.2835"><vh>createLastChildOf</vh></v>
</v>
</v>
</v>
<v t="ekr.20071025193940"></v>
<v t="ekr.20070517160058.1"><vh>Prototypes</vh>
<v t="ekr.20070929062147"><vh>Prototype of networkx graph tools</vh>
<v t="ekr.20070929122956"><vh>Data trees</vh>
<v t="ekr.20070929114617"><vh>@graph-target</vh></v>
<v t="ekr.20070929072043"><vh>@networkx</vh>
<v t="ekr.20070929072506.1"><vh>@nodes</vh></v>
<v t="ekr.20070929072506"><vh>@edges</vh></v>
</v>
<v t="ekr.20070929070257"><vh>@graph</vh>
<v t="ekr.20070929070257.1"><vh>@node child1</vh>
<v t="ekr.20070929070632"><vh>@link ('ekr', '20070929070257', 2): @node child2</vh></v>
</v>
<v t="ekr.20070929070257.2"><vh>@node child2</vh>
<v t="ekr.20070929070632.1"><vh>@link ('ekr', '20070929070257', 1): @node child1</vh></v>
</v>
</v>
<v t="ekr.20070928095102"><vh>root-node</vh>
<v t="ekr.20070928095102.1"><vh>child1</vh></v>
<v t="ekr.20070928095102.2"><vh>child2</vh></v>
</v>
</v>
<v t="ekr.20070929122956.1"><vh>buttons</vh>
<v t="ekr.20070929070426"><vh>@@button print link</vh></v>
<v t="ekr.20070927175908"><vh>@@button leo2graph</vh></v>
<v t="ekr.20070929062147.1"><vh>@@button at-graph2graph</vh></v>
<v t="ekr.20070929062147.2"><vh>@@button at-networkx2graph</vh>
<v t="ekr.20070929081505"><vh>error</vh></v>
<v t="ekr.20070929074830"><vh>parse</vh></v>
<v t="ekr.20070929072506.2"><vh>parseNodes</vh></v>
<v t="ekr.20070929074830.1"><vh>parseEdges</vh></v>
</v>
<v t="ekr.20070929082546"><vh>@@button at-networkx2at-graph</vh>
<v t="ekr.20070929120541"><vh>createEdges</vh></v>
<v t="ekr.20070929120541.1"><vh>createNodes</vh></v>
<v t="ekr.20070929115302"><vh>createTree</vh></v>
<v t="ekr.20070929114410.2"><vh>error</vh></v>
<v t="ekr.20070929114410.3"><vh>parse</vh></v>
<v t="ekr.20070929114410.5"><vh>parseEdges</vh></v>
<v t="ekr.20070929114410.4"><vh>parseNodes</vh></v>
</v>
</v>
</v>
<v t="ekr.20070630142904"><vh>Prototype of pyrex</vh>
<v t="ekr.20070630142904.2"><vh>gcc build docs</vh></v>
<v t="ekr.20070630142904.3"><vh>pyrexc command-line options</vh></v>
<v t="ekr.20070630142904.4"><vh>@@file myModule.pyx</vh></v>
<v t="ekr.20070630142904.5"><vh>Make myModule.c</vh></v>
</v>
<v t="ekr.20071026102420.2"><vh>Screen capture with Wink</vh>
<v t="ekr.20070528111805"><vh>FrontWindowCapture.pyw</vh></v>
<v t="ekr.20070609085533"><vh>@@url c:\prog\wink\ChangeViewMenu.htm</vh></v>
</v>
<v t="ekr.20080503202744.3"><vh>Rope</vh></v>
<v t="ekr.20080531131542.1"><vh>mxTextTools proto</vh>
<v t="ekr.20080531141227.1"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
<v t="ekr.20080531131542.2"><vh>&lt;&lt; define scan4 tables &gt;&gt;</vh></v>
<v t="ekr.20080531131542.4"><vh>printItem</vh></v>
</v>
<v t="ekr.20080806145258.12"><vh>Prototype of Leo in Ajax</vh>
<v t="ekr.20080806145258.13"><vh>To do</vh></v>
<v t="ekr.20080806145258.14"><vh>@@button Leo2DHTML</vh>
<v t="ekr.20080806145258.15"><vh>&lt;&lt; about LeoToHTML &gt;&gt;</vh></v>
<v t="ekr.20080806145258.16"><vh>&lt;&lt; define dhtml stuff &gt;&gt;</vh></v>
<v t="ekr.20080806145258.17"><vh>escape</vh></v>
<v t="ekr.20080806145258.18"><vh>writeAll</vh></v>
<v t="ekr.20080806145258.19"><vh>writeBody</vh></v>
<v t="ekr.20080806145258.20"><vh>writeHead</vh></v>
<v t="ekr.20080806145258.21"><vh>writeContents</vh></v>
<v t="ekr.20080806145258.22"><vh>writePreamble</vh></v>
<v t="ekr.20080806145258.23"><vh>writePostamble</vh></v>
</v>
<v t="ekr.20080806145258.24"><vh>@@file server.py</vh></v>
<v t="ekr.20080806145258.25"><vh>@@file hello.html</vh></v>
<v t="ekr.20080806145258.26"><vh>@@file cgi-bin/edward.py</vh>
<v t="ekr.20080806145702.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20080806145258.27"><vh>&lt;&lt; define dhtml stuff &gt;&gt;</vh></v>
<v t="ekr.20080806145258.28"><vh>escape</vh></v>
<v t="ekr.20080806145258.29"><vh>print_all</vh></v>
<v t="ekr.20080806145258.30"><vh>print_body</vh></v>
<v t="ekr.20080806145258.31"><vh>print_head</vh></v>
<v t="ekr.20080806145258.32"><vh>print_leo_dot_js</vh></v>
<v t="ekr.20080806145258.33"><vh>print_tree</vh></v>
</v>
<v t="ekr.20080806145258.1"><vh>@@thin cgi-bin/leo.js</vh></v>
<v t="ekr.20080806145258.34"><vh>@@thin jqueryTest.html</vh></v>
</v>
<v t="ekr.20080811113441.2"><vh>Running body text as a windows script</vh>
<v t="ekr.20080807115344.1"><vh>Windows script</vh></v>
<v t="ekr.20080807114145.2"><vh>@@button run-windows-script</vh>
<v t="ekr.20080807115344.5"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20080807115344.2"><vh>class MySite</vh></v>
<v t="ekr.20080807115344.3"><vh>class Application</vh></v>
<v t="ekr.20080807115344.4"><vh>RunCode</vh></v>
</v>
</v>
<v t="ekr.20090507082535.1906"><vh>Get my email</vh></v>
<v t="ekr.20090620063706.1826"><vh>Prototype of rendering commands</vh>
<v t="ekr.20090619103402.1818"><vh>@@button render-as-html</vh></v>
<v t="ekr.20090619103402.1821"><vh>@@button render-as-text</vh></v>
</v>
<v t="ekr.20090630141519.1793"><vh>rClick proto script</vh></v>
<v t="ekr.20090715064044.1782"><vh>@button render-as-sphinx</vh></v>
<v t="ekr.20090728090618.2837"><vh>pydiction-1.0</vh>
<v t="ekr.20090728090618.2846"><vh>pydiction.vim</vh></v>
<v t="ekr.20090728090618.2847"><vh>README.txt</vh></v>
<v t="ekr.20090728090618.2838"><vh>pydiction.py</vh>
<v t="ekr.20090728090618.2849"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20090728090618.2839"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="ekr.20090728090618.2848"><vh>&lt;&lt; process command line &gt;&gt;</vh></v>
<v t="ekr.20090728090618.2840"><vh>get_submodules</vh></v>
<v t="ekr.20090728090618.2841"><vh>write_dictionary</vh></v>
<v t="ekr.20090728090618.2842"><vh>my_import</vh></v>
<v t="ekr.20090728090618.2843"><vh>remove_duplicates</vh></v>
<v t="ekr.20090728090618.2844"><vh>get_yesno</vh></v>
<v t="ekr.20090728090618.2845"><vh>main</vh></v>
</v>
</v>
<v t="ekr.20091013153026.2721"><vh>prototype of using patternmatch library</vh>
<v t="ekr.20091011110344.1853"><vh>@@button find script a</vh></v>
<v t="ekr.20091010091628.1836"><vh>@@button create find button</vh>
<v t="ekr.20091010104145.1840"><vh>class patController</vh>
<v t="ekr.20091010104145.1842"><vh>ctor</vh></v>
<v t="ekr.20091010104145.1843"><vh>setup</vh></v>
<v t="ekr.20091010104145.1844"><vh>driver</vh></v>
<v t="ekr.20091010104145.1845"><vh>find</vh></v>
<v t="ekr.20091010104145.1846"><vh>findr</vh></v>
</v>
</v>
<v t="ekr.20091010091628.1837"><vh>find pat a</vh></v>
</v>
</v>
<v t="ekr.20071105085941"><vh>Tests</vh>
<v t="ekr.20090309064612.1"><vh> Future features/bug fixes (do not delete)</vh>
<v t="ekr.20081216091605.2"><vh>@@auto under_indent.py</vh>
<v t="ekr.20090122211549.1"><vh>class test</vh>
<v t="ekr.20090122211549.2"><vh>spam</vh></v>
</v>
</v>
<v t="ekr.20080924081821.1"><vh>test of autoCompleter.getExternalCompletions</vh></v>
<v t="ekr.20080610144233.1"><vh>Wrap test</vh></v>
</v>
<v t="ekr.20090309064612.2"><vh>Example scripts</vh>
<v t="ekr.20080701130406.1"><vh>Run pylint on plugins</vh></v>
<v t="ekr.20080617170334.1"><vh>Determining key values</vh></v>
<v t="ekr.20080920101658.1"><vh>getInput</vh></v>
<v t="ekr.20080917063615.1"><vh>getSettingSource</vh></v>
<v t="ekr.20081205104320.1"><vh>run bash script</vh></v>
</v>
<v t="ekr.20080930114036.1"><vh>Icon stuff</vh>
<v t="ekr.20090701133940.1767"><vh>print icons</vh></v>
<v t="ekr.20090701125834.1765"><vh>@@button insert-inst-icon</vh></v>
<v t="ekr.20080930080501.1"><vh>Add icon row</vh></v>
<v t="ekr.20080930083052.1"><vh>hide icon rows</vh></v>
<v t="ekr.20080930083052.2"><vh>show icon rows</vh></v>
<v t="ekr.20080930085514.1"><vh>clear icon bar</vh></v>
</v>
<v t="ekr.20090205070715.1"><vh>print colorer stats</vh></v>
<v t="ekr.20090614142400.1806"><vh>syntax tests</vh></v>
<v t="ekr.20090309064612.3"><vh>Tests of new features</vh>
<v t="ekr.20090309064612.4"><vh>Decorator tests</vh>
<v t="ekr.20080628094340.1"><vh>Decorator test</vh></v>
<v t="edward.20081221145716.1"><vh>decorator test 2</vh></v>
</v>
<v t="ekr.20090201162523.1"><vh>Macro test</vh>
<v t="ekr.20090201192257.1"><vh>@@test macro ab</vh></v>
</v>
<v t="ekr.20090128131130.1"><vh>posList tests</vh></v>
<v t="ekr.20090128112453.1"><vh>Property tests</vh></v>
<v t="ekr.20090507082111.1904"><vh>test creation of gnx's</vh></v>
<v t="ekr.20090601093755.1802"><vh>Test of @g.command decorator</vh></v>
<v t="ekr.20080922164656.1"><vh>Tests of path expressions</vh>
<v t="ekr.20080921144924.1"><vh>Tests of g.os_path_finalize</vh></v>
<v t="ekr.20080922142953.1"><vh>test os_pathExpression</vh></v>
<v t="ekr.20080922164255.1"></v>
<v t="ekr.20080922164255.2"><vh>@@shadow {{c.config.getString('test')}}/eval-shadow-test.txt</vh></v>
<v t="ekr.20080923073240.2"><vh>@path {{c.config.getString('test')}}</vh>
<v t="ekr.20080923073240.1"><vh>@@thin eval-thin-test.txt</vh></v>
</v>
</v>
<v t="ekr.20080531080812.1"><vh>tracer tests</vh></v>
</v>
<v t="ekr.20081003094737.1"><vh>Unicode tests</vh>
<v t="ekr.20080701101740.1"><vh>locale tests</vh></v>
<v t="ekr.20080821111715.1"><vh>Standard print test (only works for Latin-1 and ascii)</vh></v>
<v t="ekr.20090525090210.1940"><vh>Unicode characters: La Peña</vh></v>
<v t="ekr.20090617083033.1814"><vh>Test of copy/paste of unicode</vh>
<v t="ekr.20090617083033.1813"><vh>Unicode characters: La Peña תּ</vh></v>
</v>
<v t="ekr.20090618102458.1816"><vh>Converting QString to unicode</vh></v>
</v>
<v t="ekr.20090705063023.1780"><vh>@@root at-root-test.py</vh>
<v t="ekr.20090705063023.1781"><vh>abc</vh></v>
</v>
<v t="ekr.20090712081157.1790"><vh>@@file prompt-for-dangerous-writes.py</vh>
<v t="ekr.20090712081157.1791"><vh>spam</vh></v>
</v>
<v t="ekr.20090706044257.1784"><vh>@@auto ../../install</vh></v>
<v t="ekr.20090701062041.1798"><vh>PHP test</vh>
<v t="ekr.20090704133634.1780"><vh>Inner php</vh></v>
</v>
<v t="ekr.20090514103332.1929"><vh>Unit tests</vh>
<v t="ekr.20090514073218.1923"><vh>@button run test.leo tests @key = alt-7</vh></v>
<v t="ekr.20090218112656.1"><vh>@test self.assertEqual</vh></v>
<v t="ekr.20090514101216.1927"><vh>@test self.assertNotEqual</vh></v>
</v>
<v t="ekr.20090831145049.1819"><vh>Unicode test</vh></v>
<v t="ekr.20091001161528.1828"><vh>@test c.allPositions &amp; c.allUniquePositions</vh></v>
<v t="ekr.20091007113250.1828"><vh>@@nosent orphan-test.py</vh>
<v t="ekr.20091007113250.1829"><vh>spam</vh></v>
<v t="ekr.20091007113347.1832"><vh>eggs</vh></v>
</v>
<v t="ekr.20091016060748.1861"><vh>Test of expanded lookup in @root trees</vh>
<v t="ekr.20091016060748.1858"><vh>@@root root-coloring.py</vh>
<v t="ekr.20091016060748.1859"><vh>&lt;&lt; section &gt;&gt;</vh></v>
<v t="ekr.20091016060748.1860"><vh>&lt;&lt; common section &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20091015191345.1856"><vh>ctags completion</vh></v>
<v t="ekr.20091217210235.1866"><vh>@auto-rst at-auto-rst-test.txt</vh></v>
<v t="ekr.20091229092257.1930"><vh>@auto-rst ../doc/html/intro.html.txt</vh></v>
<v t="ekr.20091229101227.1902"><vh>@auto-rst quickstart.txt</vh></v>
<v t="ekr.20091230064146.1912"><vh>@auto xml-tags-test.xml</vh>
<v t="ekr.20091230081322.1915"><vh>xml-tags-test declarations</vh></v>
<v t="ekr.20091230081322.1916"><vh>xml</vh></v>
<v t="ekr.20091230081322.1917"><vh>test.a</vh></v>
<v t="ekr.20091230081322.1918"><vh>test-b</vh></v>
</v>
<v t="ekr.20091229092150.1939"><vh>@language rest</vh>
<v t="ekr.20091228143431.1895"><vh>@@auto quickstart.txt</vh></v>
</v>
<v t="ekr.20091221113040.1868"><vh>keys</vh></v>
<v t="ekr.20091222114015.1901"><vh>Example</vh></v>
<v t="ekr.20091223061318.1873"><vh>Simple example</vh></v>
<v t="ekr.20091230081322.1919"><vh>unicode categories</vh></v>
</vnodes>
<tnodes>
<t tx="edward.20081127113749.10">def undo_replacement(self):
    u = self.c.undoer; c=self.c; p=u.p
    bunch = u.getBead(u.bead)
    c.setBodyString(p, bunch.oldBody)
    c.frame.body.setInsertPoint(bunch.insertPos)</t>
<t tx="edward.20081127113749.11">def redo_replacement(self):
    c = self.c; u=c.undoer; bunch=u.getBead(u.bead+1)
    c.setBodyString(bunch.p, bunch.newBody)
    c.frame.body.setInsertPoint(bunch.insertPos)</t>
<t tx="edward.20081127113749.12">def exit(self):
    #g.app.config.set(c,word_completer_key,'WordCompleter',None)
    #g.app.config.set(c,'next_word_completer','WordCompleter',None)
    self.pos = -1</t>
<t tx="edward.20081127113749.13">def run(self):
    self.adjust(self.p, c.frame.body.getInsertPoint())
    self.complete_word()
</t>
<t tx="edward.20081127113749.14">def adjust(self, p, pos):
    if p != self.p or pos != self.pos:
        self.p = p.copy()
        self.pos = pos
        bs = p.bodyString()
        word = getCurrentWord(bs, pos)
        self.word = word
        self.before = bs[:pos-len(word)]
        self.after = bs[pos:]
        self.search_pos = p.copy()
        if self.back:
            self.chunk = self.before
        else:
            self.chunk = self.after
        self.tried = {word:1}</t>
<t tx="edward.20081127113749.15">def getCurrentWord(s, pos):
    i = pos-1
    while i&gt;=0 and wordsep.find(s[i]) &lt; 0:
         i -= 1
    return s[i+1:pos]</t>
<t tx="edward.20081127113749.16">wordsep = u'., -+\n\r[]{}&lt;&gt;=-+*&amp;%$#@!"\'?/\\|^()~`:;'
word_completer_key = 'next_word_completer'
@others
completer = g.app.config.get(c,word_completer_key,'WordCompleter')
if completer is None:
    completer = WordCompleter(p, c, back=False)
    g.app.config.set(c, word_completer_key, 'WordCompleter', completer)
    completer.run()
else:
    completer.adjust(p, c.frame.body.getInsertPoint())
    completer.complete_word()

</t>
<t tx="edward.20081127113749.2">wordsep = u'., -+\n\r[]{}&lt;&gt;=-+*&amp;%$#@!"\'?/\\|^()~`:;'
word_completer_key = 'back_word_completer'
@others
completer = g.app.config.get(c,word_completer_key,'WordCompleter')
if completer is None:
    completer = WordCompleter(p,c,back=True)
    g.app.config.set(c,word_completer_key,'WordCompleter',completer)
    completer.run()
else:
    completer.adjust(p, c.frame.body.getInsertPoint())
    completer.complete_word()
</t>
<t tx="edward.20081127113749.3">class WordCompleter:
    def __init__(self, p, c, back=True):
        self.p = p.copy()
        self.c = c
        self.back = back
        self.pos = -1
    @others
</t>
<t tx="edward.20081127113749.4">def complete_word(self):
    txt = self.chunk
    word = self.word
    try:
        if self.back:
            &lt;&lt;backward search&gt;&gt;
        else:
            &lt;&lt;forward search&gt;&gt;
        &lt;&lt;clean up and exit&gt;&gt;
    except:
        self.exit()
        g.es_exception()</t>
<t tx="edward.20081127113749.5">p = self.search_pos
start = -1
counter = 0
while p:
    &lt;&lt;counter check&gt;&gt;
    i = txt.rfind(word, 0, start)
    if i == -1:
        p.moveToThreadBack()
        if p:self.chunk = txt = p.bodyString()
        start = -1
    else:
        if self.acceptable_word(i, txt, word):
            self.chunk = txt[:i+len(word)-1]
            return
        start = i+len(word)-1</t>
<t tx="edward.20081127113749.6">counter+=1
if counter &gt; 10000:
    g.es_trace("counter max")
    break</t>
<t tx="edward.20081127113749.7">p = self.search_pos
start = 0
counter = 0
while p:
    &lt;&lt;counter check&gt;&gt;
    i = txt.find(word, start)
    if i == -1:
        p.moveToThreadNext()
        if p:self.chunk = txt = p.bodyString()
        start = 0
    else:
        if self.acceptable_word(i, txt, word):
            self.chunk = txt[i+1:]
            return
        start = i+1</t>
<t tx="edward.20081127113749.8">if len(self.tried) &gt; 1:
    # there was some tries so we need to restore
    self.c.setBodyString(self.p, self.before+self.word+self.after)
    self.c.frame.body.setInsertPoint(self.pos)
return self.exit()</t>
<t tx="edward.20081127113749.9">@ if found word for the first time then try it
@c
def acceptable_word(self, i, txt, word):
    if i == 0 or wordsep.find(txt[i-1]) != -1:
        j = i+len(word)
        while j &lt; len(txt) and wordsep.find(txt[j]) &lt; 0:
            j += 1
        nword = txt[i:j]
        if nword not in self.tried:
            self.tried[nword] = 1
            u = self.c.undoer
            bunch = u.createCommonBunch(p)
            bunch.oldBody = p.bodyString()
            bunch.insertPos = self.pos
            # Set the type &amp; helpers.
            bunch.kind = 'node'
            bunch.undoType = 'complete word'
            bunch.undoHelper = self.undo_replacement
            bunch.redoHelper = self.redo_replacement
            bunch.newBody = newBody = self.before+nword+self.after

            self.c.setBodyString(self.p, newBody)
            self.c.frame.body.setInsertPoint(self.pos)

            bunch.dirtyVnodeList = [p.v]
            bunch.newChanged = u.c.isChanged()
            bunch.newDirty = p.isDirty()
            bunch.newMarked = p.isMarked()

            u.pushBead(bunch)

            return True
    return False
</t>
<t tx="edward.20081221145716.1">def debug(f,*args,**keys):
    if 1:
        def debugCallback(*args,**keys):
            print f.__name__,args,keys
            f(*args,**keys)
            print 'after',f.__name__
        return debugCallback
    else:
        print 'in debug'
        return f
@debug
def spam(a=5):
    g.trace(a,g.callers(4))

spam(3)
spam(a=4)
</t>
<t tx="ekr.20041001211817">import os

g.pr(os.path.exists(os.path.normpath("C:\\Progra~1\\Eclipse")))</t>
<t tx="ekr.20060427103457"># Open leoSettings.leo
c.openLeoSettings()</t>
<t tx="ekr.20060809084033">'''A script to convert calls to g.es to g.et, and raw strings s to g._(s)'''

__version__ = 0.2
&lt;&lt; version history &gt;&gt;

@others

trace = False # For debugging.
doReplace = True # True: actually replace the body text.

if not doReplace: g.es_print('-' * 40)
c.beginUpdate()
try:
    u = c.undoer
    undoType = 'Convert g.es'
    u.beforeChangeGroup (p,undoType)
    for p in c.currentPosition().self_and_subtree_iter():
        replace(p)
    u.afterChangeGroup(p,undoType,reportFlag=True)
finally:
    c.endUpdate()</t>
<t tx="ekr.20060809090508"># Based on leoImport.scanPythonText.
def replace(p):
    '''Replace g.es by g.et and strings s by g._(s)'''
    s = p.bodyString()
    if not s.strip(): return
    result = [] ;  i = 0 ; count = 0
    while i &lt; len(s):
        progress = j = i
        ch = s[i]
        if ch == '\n' or ch == '\r':
            i = g.skip_nl(s,i)
            result.append(s[j:i])
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
            result.append(s[j:i])
        elif ch == '"' or ch == "'":
            &lt;&lt; handle string &gt;&gt;
        elif g.is_c_id(ch):
            if g.match_word(s,i,'g.es'):
                &lt;&lt; handle g.es &gt;&gt;
            else:
                i = g.skip_c_id(s,i)
                result.append(s[j:i])
        else:
            i += 1
            result.append(s[j:i])
        assert(progress &lt; i)
    if count:
        result = ''.join(result)
        if doReplace:
            undoData = u.beforeChangeNodeContents(p)
            p.setBodyStringOrPane(result)
            p.v.t.setDirty()
            u.afterChangeNodeContents(p,'Change Body',undoData)
        else:
            g.trace('result...\n',result)</t>
<t tx="ekr.20060809091749.72">i = g.skip_python_string(s,i)
s2 = s[j:i].strip()
result.append('g._(%s)' % s2)
if trace: g.trace('string:',s2)
count += 1</t>
<t tx="ekr.20060809091749.73">i += 4 ; k1 = i
i = g.skip_ws(s,i)
found = False
if g.match(s,i,'('):
    k2 = i
    k3 = g.skip_parens(s,i)
    if g.match(s,k3,')'):
        # Only translate if there are exactly one string in the parens.
        s2 = s[k2+1:k3]
        if (
            s2 and s2.count(',') == 0 and
            (s2.count('"') == 2 or s2.count("'") == 2)
        ):
            i = k3
            if trace: g.trace('call g.es:',g.get_line(s,i))
            result.append('g.et')
            result.append(s[k1:i])
            count += 1 ; found = True
if not found:
    result.append(s[j:i])</t>
<t tx="ekr.20060809092023"></t>
<t tx="ekr.20060809103738">def test1():
    
    g.es('abc')
    g.es('abc',xyz)
    g.es(xyz)</t>
<t tx="ekr.20060809103738.1">def test2():

    x = 'abc' + 'xyz'
    y = abc</t>
<t tx="ekr.20060809104405">@nocolor
@
0.1 EKR: Initial version.
0.2 EKR: Support doReplace and made script fully undoable.</t>
<t tx="ekr.20060814111542"># Add an editor to the body pane.
c.frame.body.addEditor()</t>
<t tx="ekr.20060904110922"></t>
<t tx="ekr.20060904111037">if hasattr(c,'opmlCommands'):
    c.opmlCommands.readOpmlCommand()
else:
    g.es_print('opml plugin not loaded')</t>
<t tx="ekr.20060904111037.1">if hasattr(c,'opmlCommands'):
    c.opmlCommands.writeOpmlCommand()
else:
    g.es_print('opml plugin not loaded')</t>
<t tx="ekr.20060918083159">put = g.es_print

for p in c.allNodes_iter():

    if hasattr(p.v,"unknownAttributes"):
        put("deleting v.unknownAttributes:",
            p.headString(),
            g.listToString(p.v.unknownAttributes.keys()))
        delattr(p.v,"unknownAttributes")

    if hasattr(p.v.t,"unknownAttributes"):
        put("deleting t.unknownAttributes:",
            p.headString(),
            g.listToString(p.v.t.unknownAttributes.keys()))
        delattr(p.v.t,"unknownAttributes")
           
put('done') 
c.redraw()</t>
<t tx="ekr.20060924180049">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060924180049.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others</t>
<t tx="ekr.20060924180049.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")</t>
<t tx="ekr.20060924180049.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060924180049.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.currentPosition()
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.headString())
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060924180049.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().headString()
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)</t>
<t tx="ekr.20060924180049.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20061030041200">import os, sys

if 1: # Executes Iron Python in the console. (But not from the tutorials directory).
    path = r'c:\prog\IronPython-1.0.1\ipy.exe'
    args = ['-i']
        
    if 1: # Use present environment.
        os.spawnv(os.P_NOWAIT, path, args)
    else: # Use a pristine environment.
        os.spawnve(os.P_NOWAIT, path, args, os.environ)</t>
<t tx="ekr.20061030041356"></t>
<t tx="ekr.20061030041450"></t>
<t tx="ekr.20070115092430"># Invoke winpdb for general scripts **not** containing the predefined g, p or d constants.

# This is essentially the same as using the debug command.

import os,subprocess,sys

# Important: scriptFile2 must be different from scriptFile.
filename = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','scriptFile2'))
f = open(filename,'w') 
f.write(p.bodyString()) 
f.close() 
python = sys.executable
pythonDir = g.os_path_dirname(python) 
#winpdb = g.os_path_join(pythonDir,'Scripts','_winpdb.py') # For older versions of winpdb.
winpdb = g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py') # For version 1.1.2 and newer.
os.chdir(g.app.loadDir)
cmdline = '%s %s -t %s' % (python,winpdb,filename) 
subprocess.Popen(cmdline)
</t>
<t tx="ekr.20070224123943"></t>
<t tx="ekr.20070410063214"></t>
<t tx="ekr.20070416075121" str_leo_pos="13"></t>
<t tx="ekr.20070503085527"></t>
<t tx="ekr.20070515073111">g.pr('=' * 50)</t>
<t tx="ekr.20070517070854">import leoGui
oldGui = g.app.gui
g.app.gui = leoGui.nullGui(guiName='testGui')
try:
    fileName = g.os_path_abspath(g.os_path_join(
        g.app.loadDir,'..','doc','LeoDocs.leo'))
    ok,frame = g.openWithFileName(fileName,old_c=c)
    if ok:
        c2 = frame.c
        for p in c2.allNodes_iter():
            g.pr('.'*p.level(),p.headString())
        g.app.closeLeoWindow(frame)
finally:
    g.app.gui = oldGui</t>
<t tx="ekr.20070517071510">import leoBridge

path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','doc','LeoDocs.leo'))

if 0: # This can not be run locally: leoBridge.controller starts a Tk event loop.

    controller = leoBridge.controller(gui='nullGui')
    g = controller.globals()
    c = controller.openLeoFile(path)
    n = 0
    for p in c.allNodes_iter():
        n += 1
    g.pr('%d nodes in %s' % (n,path))
    # g.app.closeLeoWindow(c.frame)</t>
<t tx="ekr.20070517160058.1"></t>
<t tx="ekr.20070528111805"># FrontWindowCapture.pyw
# Version 0.1
# Date    20070526
# Author  Roger Erens (roger AT erens-krekels.net)
"""
        Purpose:
        Capture the image of the front-most window into a fixed-name
        (_front_window), max-size (default MAX_WIDTH is 640 pixels), and
        fixed-format (PNG) file that can easily be used when creating
        documentation for an application on a wiki or in some HTML-docs.
        This script does _not_ copy the captured image to the clipboard (handy
        when creating MS Word or OpenOffice documents) since MS Windows already
        has ALT-PRTSCR to do so.

        Dependencies:
        Fairly recent versions of Python, wxPython, and PIL should be installed

        Start:
        Double click FrontWindowCapture.pyw; an icon appears in the Task Bar (lower right of
        the screen).

        Use:
        Bring a window to the front and then left-click on the
        icon in the Task Bar. A file named '_front_window.png' will be saved
        in the current directory.
        A pictures wider than MAXWIDTH is scaled down in order to make it easily
        used in wikis or HTML-documentation.
        Usually, human intelligence is needed to rename that file; this is also
        why this script does not copy the image to the clipboard.

        End:
        Close the application by right-clicking the icon in the Task Bar.

        Note:
        Make sure that your system is fast enough to find the frontmost
        window. That is, when a virusscanner is running or virtual memory is
        low, this script will choke. You can see what happens by enabling the
        print statements and running this script from a console (change the
        extension from .pyw to .py).
"""
import wx
import sys
import win32ui
import win32gui
import win32con
import time
from PIL import Image, ImageGrab

Image.init()

MAX_WIDTH = 640
BLINK_STATE = 0

class TaskBarApp(wx.Frame):
    def __init__(self, parent, id, title):
        wx.Frame.__init__(self, parent, -1, title, size = (1, 1),
            style=wx.FRAME_NO_TASKBAR| wx.NO_FULL_REPAINT_ON_RESIZE)
        self.tbicon = wx.TaskBarIcon()
        icon = wx.Icon('LeoApp16.ico', wx.BITMAP_TYPE_ICO)
        self.tbicon.SetIcon(icon, 'Click to capture the foremost window')
        self.tbicon.Bind(wx.EVT_TASKBAR_LEFT_UP, self.OnTaskBarLeftClick)
        self.tbicon.Bind(wx.EVT_TASKBAR_RIGHT_UP, self.OnTaskBarRightClick)
        self.Show(True)

    def OnTaskBarLeftClick(self, evt):

        self.FlashIcon(evt)

        def _MyCallback(hwnd, extra ):
            extra.append(hwnd)

        windows = []
        win32gui.EnumWindows(_MyCallback, windows)

        winList = []
        for i in windows:
            if win32gui.IsWindowVisible(i):
                winList.append(i)
                #g.pr(i)

        win32gui.SetForegroundWindow(winList[1])    # found by trial and error
                                                    # that I need the second
                                                    # window from the list
        time.sleep(0.1)  # give the previous command some time to finish

        fgwindow = win32ui.GetForegroundWindow()
        #g.pr("(C)lick!")

        bbox = fgwindow.GetWindowRect()
        img = ImageGrab.grab( bbox)
        width = bbox[2] - bbox[0]
        if width &gt; MAX_WIDTH:
            coeff = MAX_WIDTH * 1. / width
            height = bbox[3] - bbox[1]
            newHeight = int( coeff * height)
            #g.pr(width, height, "scaled down to", MAX_WIDTH, newHeight)
            img = img.resize((MAX_WIDTH,newHeight), Image.ANTIALIAS)
        img = img.convert("P", dither=Image.NONE,
                              palette=Image.ADAPTIVE, colors=256)
        img.save("_front_window.png", "PNG", optimize=1)
        #img.show() # show the image in an image viewer

        self.FlashIcon(evt)

    def OnTaskBarRightClick(self, evt):
        #g.pr("Auta..." # that's about it...)
        self.tbicon.Destroy()
        self.Close(True)
        wx.GetApp().ProcessIdle()

    def FlashIcon(self, evt):
        global BLINK_STATE
        if BLINK_STATE == 0:
            icon = wx.Icon('LeoApp16lick.ico', wx.BITMAP_TYPE_ICO)
            self.tbicon.SetIcon(icon, 'Window is being captured...')
            BLINK_STATE = 1
            return
        else:
            icon = wx.Icon('LeoApp16.ico', wx.BITMAP_TYPE_ICO)
            self.tbicon.SetIcon(icon, 'Click to capture the foremost window')
            BLINK_STATE = 0
            return

class MyApp(wx.App):
    def OnInit(self):
        frame = TaskBarApp(None, -1, ' ')
        frame.Center(wx.BOTH)
        frame.Show(False)
        return True

def main():
    app = MyApp(0)
    app.MainLoop()

if __name__ == '__main__':
    main()

""" CREDITS

    Thanks to
    Roger Upole:
    http://groups.google.com/group/comp.lang.python/
    browse_thread/thread/ff39ec79f7c3248a/
    e600c892772bf52a?lnk=gst&amp;q=screen+capture&amp;rnum=6#e600c892772bf52a
    for his time.sleep() Aha (This took me a year and a half to note!)

    Christian Wyglendowski, Werner Bruhin, and Xavier Morel for the
    http://wiki.wxpython.org/index.cgi/FlashingTaskbarIcon
    discussion

    'Rob aspn at msolutionsinc.com '
    http://mail.python.org/pipermail/python-win32/2003-June/001129.html
    for his suggestion to find out the foremost window

    and of course the usual suspects that created/maintain
    wxPython,
    PIL,
    pywin32,
    LEO,
    gvim,
    and Python itself.
"""</t>
<t tx="ekr.20070529172620"></t>
<t tx="ekr.20070529173219"></t>
<t tx="ekr.20070529173219.1"></t>
<t tx="ekr.20070530072113">c.chapterController.hideChapters()</t>
<t tx="ekr.20070530072113.1">c.chapterController.showChapters()</t>
<t tx="ekr.20070531102813"></t>
<t tx="ekr.20070531103315">c.abbrevCommands.dynamicExpansion(event=None)</t>
<t tx="ekr.20070531104646">c.abbrevCommands.dynamicCompletion()</t>
<t tx="ekr.20070603175054">cc = c.chapterController
cc.selectChapterByName('abc')</t>
<t tx="ekr.20070603175054.1">cc = c.chapterController
cc.selectChapterByName('main')</t>
<t tx="ekr.20070603190713">cc = c.chapterController
cc.createChapterByName('xyz')</t>
<t tx="ekr.20070603190713.1">cc = c.chapterController
cc.selectChapterByName('xyz')</t>
<t tx="ekr.20070603190944"></t>
<t tx="ekr.20070603190944.1"></t>
<t tx="ekr.20070604095313"></t>
<t tx="ekr.20070604100125"></t>
<t tx="ekr.20070609085533"></t>
<t tx="ekr.20070630142904"></t>
<t tx="ekr.20070630142904.2">@nocolor

To build your module using GCC is a three step process on Unix:

1. Use Pyrex to translate mymodule.pyx to mymodule.c::

    python pyrexc mymodule.pyx

mymodule.pyx is the name of the Pyrex module you are writing.

2. Compile mymodule.c to mymodule.o::

    gcc -c -fPIC -I/usr/include/python2.2/ mymodule.c

-c  Produces a .o file instead of an executable. 
-fPIC Produces position independent code, so we can dynamically link against it later. 
-I/usr/include/python2.2/ is the location of the Python 2.2 include file.
 The location of your Python include file may differ from /usr/include/python2.2/. 

3 Link the mymodule.o into a mymodule.so::
    
    gcc -shared mymodule.o -lxosd -o mymodule.so

-shared produces a shared-object file, instead of an executable. 
-lxosd links against a C-library, with the name of the library given as the argument. 
</t>
<t tx="ekr.20070630142904.3">@nocolor

The pyrexc command supports the following options:

  Short Long              Argument    Description
  ----- ----              --------    -----------
  -v    --version                     Display version number of pyrex compiler
  -l    --create-listing              Write error messages to a .lis file
  -I    --include-dir     &lt;directory&gt; Search for include files in named 
                                      directory (may be repeated)
  -o    --output-file     &lt;filename&gt;  Specify name of generated C file (only
                                      one source file allowed if this is used)

Anything else is taken as the name of a Pyrex source file and compiled
to a C source file. Multiple Pyrex source files can be specified
(unless -o is used), in which case each source file is treated as the
source of a distinct extension module and compiled separately to
produce its own C file.
</t>
<t tx="ekr.20070630142904.4">def spam(int i, char *s):
    if 1:
        g.pr(i,s)</t>
<t tx="ekr.20070630142904.5"># Use pyrexc to create myModule.c from myModule.pyx.

import os,sys
python = sys.executable
theFile = r'C:\prog\tigris-cvs\leo\test\myModule.pyx'
pyrexc = r'c:\prog\Pyrex-0.9.6.4\pyrexc.py'
os.system(r'%s %s %s' % (python,pyrexc,theFile))

# Use pyrex/Demos/setup.py to create module on Linux.</t>
<t tx="ekr.20070723091227">
        
        
        </t>
<t tx="ekr.20070723091227.1"></t>
<t tx="ekr.20070723091227.2"></t>
<t tx="ekr.20070723091227.3"></t>
<t tx="ekr.20070927175908">'''Convert a normal Leo tree to a networkx graph'''
import networkx as nx
import sys

x = nx.Graph()

def node_id(p):
    return '%s: %s' % (id(p.v.t),p.headString())

def addTree(p):
    x.add_node(node_id(p))
    for child in p.children_iter():
        addTree(child)
        x.add_edge(node_id(p),node_id(child))

addTree(p)

g.pr('nodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('edges...\n', g.listToString(x.edges(),sort=True))
g.pr('yaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')
</t>
<t tx="ekr.20070928095102">@ This is a plain Leo tree.

You can convert it to a networkx graph using the leo2graph button.
</t>
<t tx="ekr.20070928095102.1"></t>
<t tx="ekr.20070928095102.2"></t>
<t tx="ekr.20070929062147">@nocolor

The following scripts convert between Leo trees and NetworkX graphs.

- leo2graph:            convert a normal Leo tree to a NetworkX graph.
- at-graph2graph:       convert an @graph tree to a Networkx graph.
- at-networkx2graph:    convert an @networkx tree to a Networkx graph
- at-networkx2at-graph: create an @graph tree from an @networkx tree.

Not ready yet:

- tree2pict: convert a Leo @graph tree to a picture of the corresponding graph.

@color</t>
<t tx="ekr.20070929062147.1">'''Convert an @graph tree to a networkx graph.'''
import networkx as nx
import sys

x = nx.Graph()

def node_id(p):
    return '%s: %s' % (str(p.v.t.fileIndex),p.headString())

def addTree(p):
    tag = '@link'
    h = p.headString()
    if h.startswith('@graph'):
        for child in p.children_iter():
            addTree(child)
    elif h.startswith('@node'):
        x.add_node(node_id(p))
        for child in p.children_iter():
            h = child.headString()
            if h.startswith(tag):
                link = h[len(tag):].strip()
                if link: x.add_edge(node_id(p),link)
            elif child.headString().startswith('@node'):
                addTree(child)
                x.add_edge(node_id(p),node_id(child))

addTree(p)

g.pr('nodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('edges...\n', g.listToString(x.edges(),sort=True))
g.pr('yaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')</t>
<t tx="ekr.20070929062147.2">'''Convert an @networkx node to a networkx graph.'''
import networkx as nx
import sys

@others

x = nx.Graph()

edges,nodes = parse(p)

for z in nodes:
    x.add_node(z)

for z in edges:
    a,b = z
    x.add_edge(a,b)

g.pr('\nnodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('\nedges...\n', g.listToString(x.edges(),sort=True))
g.pr('\nyaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')
</t>
<t tx="ekr.20070929070257">@ This is an @graph tree.

You can convert it to a networkx graph using the at-graph2graph button.</t>
<t tx="ekr.20070929070257.1"></t>
<t tx="ekr.20070929070257.2"></t>
<t tx="ekr.20070929070426">g.es('@link %s: %s' % (str(p.v.t.fileIndex),p.headString()))</t>
<t tx="ekr.20070929070632"></t>
<t tx="ekr.20070929070632.1"></t>
<t tx="ekr.20070929072043">@ This node defines a networkx graph using nodes and edges.

You can create an @graph tree from this node using the graph2at-graph button.
</t>
<t tx="ekr.20070929072506"># Each edge is represented as two lines.

# child1 --&gt; child2
('ekr', '20070929070257', 1): @node child1
('ekr', '20070929070257', 2): @node child2

# child2 --&gt; child1
('ekr', '20070929070257', 2): @node child2
('ekr', '20070929070257', 1): @node child1

</t>
<t tx="ekr.20070929072506.1"># Each node is on a separate line.

('ekr', '20070929070257', 1): @node child1
('ekr', '20070929070257', 2): @node child2
</t>
<t tx="ekr.20070929072506.2">def parseNodes (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(g.listToString(lines))
    return lines
</t>
<t tx="ekr.20070929074830">def parse (p):

    tag = '@networkx'
    if not p.headString().startswith(tag):
        p = g.findNodeAnywhere(c,tag)
        if not p.headString().startswith(tag):
            error('No %s node in the outline' % tag)
            return [],[]

    nodes = []
    for tag in ('@edges','@nodes'):
        node = g.findNodeInTree(c,p,tag)
        if node:
            nodes.append(node)
        else:
            error('No %s node in @networkx tree' % tag)
            return [],[]
    edgesNode,nodesNode = nodes
    edges = parseEdges(edgesNode)
    nodes = parseNodes(nodesNode)
    return edges,nodes
</t>
<t tx="ekr.20070929074830.1">def parseEdges (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(len(lines),lines)
    if (len(lines) % 2) == 0:
        i = 0 ; edges = []
        while i &lt; len(lines):
            data = lines[i],lines[i+1]
            edges.append(data)
            i += 2
        # g.trace(g.listToString(edges))
        return edges
    else:
        error('edges node must have even number of lines')
        return []

</t>
<t tx="ekr.20070929081505">def error (s):

    g.es_print(s,color='red')
</t>
<t tx="ekr.20070929082546">'''Convert an @networkx node to an @graph tree.
Create the tree as the child of the @graph-target node,
or the current position if no such node.'''

import networkx as nx
import sys

@others

g.pr('=' * 10)

p,edges,nodes = parse(p)

createTree(p,edges,nodes)
</t>
<t tx="ekr.20070929114410.2">def error (s):

    g.es_print(s,color='red')
</t>
<t tx="ekr.20070929114410.3">def parse (p):

    tag = '@graph-target'
    if not p.headString().startswith(tag):
        p = g.findNodeAnywhere(c,tag)
    if not (p and p.headString().startswith(tag)):
        p = c.currentPosition() # Use the presently selected node.

    nodes = [] ; tag = '@networkx'
    data = g.findNodeAnywhere(c,tag)
    if not data:
        error('No %s tree' % tag)
        return None,[],[]
    for tag in ('@edges','@nodes'):
        node = g.findNodeInTree(c,data,tag)
        if node:
            nodes.append(node)
        else:
            error('No %s node in @networkx tree' % tag)
            return None,[],[]
    edgesNode,nodesNode = nodes
    edges = parseEdges(edgesNode)
    nodes = parseNodes(nodesNode)
    return p,edges,nodes
</t>
<t tx="ekr.20070929114410.4">def parseNodes (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(g.listToString(lines))
    return lines
</t>
<t tx="ekr.20070929114410.5">def parseEdges (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(len(lines),lines)
    if (len(lines) % 2) == 0:
        i = 0 ; edges = []
        while i &lt; len(lines):
            data = lines[i],lines[i+1]
            edges.append(data)
            i += 2
        # g.trace(g.listToString(edges))
        return edges
    else:
        error('edges node must have even number of lines')
        return []

</t>
<t tx="ekr.20070929114617">@ This will be the root node for the @graph tree produced by the at-networkx2at-graph button.</t>
<t tx="ekr.20070929115302">def createTree (parent,edges,nodes):

    if 0:
        g.trace('nodes...\n', g.listToString(nodes,sort=True))
        g.trace('edges...\n', g.listToString(edges,sort=True))

    c.beginUpdate()
    try:
        p = parent.insertAsLastChild()
        p.setHeadString('@graph')
        d = createNodes(p,nodes)
        createEdges(d,edges)
        c.selectPosition(p)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070929120541">def createEdges (d,edges):

    for edge in edges:
        a,b = edge
        g.trace('\n%s --&gt; %s' % (a,b))
        p = d.get(a)
        if p:
            p2 = p.insertAsLastChild()
            p2.setHeadString('@link %s' % (b))
        else:
            error('@node not found: %s' % (a))
</t>
<t tx="ekr.20070929120541.1">def createNodes (parent,nodes):

    d = {}

    for node in nodes:
        # g.trace(node)
        p = parent.insertAsLastChild()
        p.setHeadString('@node %s' % (node))
        d[node] = p.copy()

    return d
</t>
<t tx="ekr.20070929122956"></t>
<t tx="ekr.20070929122956.1"></t>
<t tx="ekr.20071002150320">log = c.frame.log
tag = 'my-canvas'

w = log.canvasDict.get(tag)
if not w:
    w = log.createCanvas(tag)
    w.configure(bg='yellow')

log.selectTab(tag)
</t>
<t tx="ekr.20071006084354">w = c.frame.body.bodyCtrl
s = w.getAllText()
ins = w.getInsertPoint()
row,col = g.convertPythonIndexToRowCol(s,ins)
g.pr('row',row,'col',col)</t>
<t tx="ekr.20071025192258">import leoTest
leoTest.doTests (c,all=False)</t>
<t tx="ekr.20071025193940"># Caution: you will have to disable cursesGui in an external editor
# if you enable the cursesGui plugin here

# Important: if you want to specify a gui plugin here,
# enable that plugin first.

# qtGui.py
# tkGui.py

# attrib_edit.py
# ctagscompleter.py
codewisecompleter.py
contextmenu.py

plugins_menu.py
#open_with.py
quicksearch.py
# ipython.py
scrolledmessage.py
UNL.py
mod_scripting.py
# pydeeshell.py
# nodenavigator.py
# vim.py
# xemacs.py

# test of @bool warn_when_plugins_fail_to_load
# xyzzy.py 

# Other interesting plugins
# leo_to_html.py
# leoOPML.py
# nav_qt.py
# graphed.py

# Tk plugins...
# cleo.py
# color_markup.py # Does not work with threading colorizer.
# image.py
# nav_buttons.py
# rClick.py
# threading_colorizer.py
# toolbar.py
</t>
<t tx="ekr.20071026102420.2"></t>
<t tx="ekr.20071026102420.3"></t>
<t tx="ekr.20071105085941"></t>
<t tx="ekr.20071128122043">log = c.frame.log ; tag = 'Shell'
frame1 = log.frameDict.get(tag)
shellKind = 'text' # in ('plain','text','canvas')

if frame1:
    log.selectTab(tag)
elif shellKind == 'plain':
    log.selectTab (tag,createText=False)
    frame = log.frameDict.get(tag)
elif shellKind == 'text':
    log.selectTab (tag,createText=True)
    frame = log.textDict.get(tag)
elif shellKind == 'canvas':
    log.createCanvas(tag)
    log.selectTab(tag)
    frame = log.canvasDict.get(tag)
else:
    frame = None
    g.es('bad shellKind',shellKind)

if frame and not frame1:
    frame.configure(bg='white')
    g.pr('logFrame',log.frameDict.get(tag))
</t>
<t tx="ekr.20071129103842"># A script to create @auto nodes from all .py files in a directory.

import glob,os

reallyCreate = True
baseDir = r'c:\leo.repo\pythoscope\lib2to3\pgen2'
dirs = (r'',)
g.pr('-----')

for theDir in dirs:
    pattern = g.os_path_join(baseDir,theDir,'*.py')
    files = glob.glob(pattern)
    g.pr(pattern)
    # g.pr(g.listToString(files))
    for name in files:
        h = '@auto %s' % (name[len(baseDir) + 1:].strip())
        g.pr('creating',h)
        if reallyCreate:
            child = p.insertAsLastChild()
            child.initHeadString(h)</t>
<t tx="ekr.20071206070207"></t>
<t tx="ekr.20080105115712"># This hangs Leo while pylint is running.
import pylint.lint as lint
import sys

rcFile = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','pylint-leo-rc.txt'))
rcArg = '--rcfile=%s' % rcFile
&lt;&lt; define data &gt;&gt;

# We expect only one W104 error, in leoGlobals.py
g.pr('\n','=' * 40)
for name,s in data:
    name2 = g.os_path_abspath(g.os_path_join(g.app.loadDir,name))
    args = [name2,rcArg]
    if s.strip():
        args.append('--disable-msg=%s' % s)
    g.pr(name,s)
    lint.Run(args)
g.pr('\n' + 'End of pylint run')</t>
<t tx="ekr.20080105120559">data = (
    ('leoAtFile.py',''), 
    ('leoChapters.py',''),
    ('leoCommands.py',''), 
    ('leoEditCommands.py','E1101'),
    ('leoFileCommands.py',''), 
    ('leoFind.py',''),
    ('leoFrame.py',''),
    ('leoGlobals.py','E0602,E1101'),
    ('leoGui.py',''),
    ('leoImport.py',''),
    ('leoMenu.py',''),
    ('leoNodes.py',''),
    ('leoPlugins.py',''),
    ('leoTangle.py',''),
    ('leoUndo.py','W0102'),
    ('leoTkinterDialog.py',''),
    ('leoTkinterFind.py',''),
    ('leoTkinterGui.py',''),
    ('leoTkinterFrame.py','W0221'),
    ('leoTkinterKeys.py',''), 
    ('leoTkinterMenu.py',''), 
    ('leoTkinterTree.py',''),
)
</t>
<t tx="ekr.20080105130903">@nocolor
@
C0111 Missing docstring
C0301 Line too long
C0311 Bad indentation
C0321 More than one statement on a single line
C0322 Operator not preceded by a space
C0323 Operator not followed by a space
C0324 Comma not followed by a space

R0201 Method could be a function.
R0903 Too few public methods (0/1)

W0102 Dangerous default value [] as argument
W0104 Statement seems to have no effect
W0106 Unnecessary semicolon
W0107 Unnecessary pass statement
W0122 Use of the exec statement
W0141 Used builtin function 'map'
W0142 Used * or * magic*
W0201 Attribute defined outside __init__
W0212 Access to a protected member of a client class
W0231 __init__ method from base class is not called
W0232 Class has no __init__ method
W0401 Wildcard import (pychecker)
W0402 Uses of a deprecated module (like string)
W0404 Reimport &lt;module&gt;: let pychecker do this.
W0406 Module import itself
W0602 Using global for x but no assigment is done (leoEditCommands defines classList after all classes).
W0603 Using the global statement
W0612 Unused variable
W0613 Unused argument (sometimes used for debugging)
W0621 Redefining &lt;name&gt; from outer scope: especially __pychecker__
W0622 Redefining built-in
W0631 Using possibly undefined loop variable
W0702 No exception type specified
W0703 Catch "Exception"
W0704 Except doesn't do anything (Except: pass)
W1111 Assigning to a function call that only returns None</t>
<t tx="ekr.20080115085447">@nocolor
@

************* Module leoGlobals
W0104:3871: Statement seems to have no effect
</t>
<t tx="ekr.20080206055658">g.pr('settings...')
for z in ('body','button','headline','log','menu','outline'):
    for z2 in ('family','size','slant','weight',):
        setting = '%s_text_font_%s' % (z,z2)
        g.pr(setting,c.config.get(setting,z2))

g.pr('default sizes...')
for z in ('Body','Log','Menu','Tree'):
    setting = 'default%sFontSize' % z
    g.pr(setting,getattr(c.config,setting))

g.pr('actual fonts...')
for z in ('body','button','headline','log','menu','outline'):
    kind = ('family','size','slant','weight')
    arg0,arg1,arg2,arg3 = args = ['%s_text_font_%s' % (z,z2) for z2 in kind]
    setting = '%s_text_font' % (z)
    g.pr('%20s' % (setting),c.config.getFontFromParams(arg0,arg1,arg2,arg3,defaultSize=12))
</t>
<t tx="ekr.20080214091706.2">g.pr('hello from ekr')</t>
<t tx="ekr.20080310111916.1">def myTranslateString (s):

    i = s.lower().find('can not')
    if i == -1:
        return s
    else:
        return s[:i+1] + "an't" + s[i+7:]

g.translateString = myTranslateString

</t>
<t tx="ekr.20080412082246.1"></t>
<t tx="ekr.20080503202744.3">import rope.base.project
import rope.contrib.codeassist as codeassist
import leo.core.leoGlobals as g
import leo.core.leoCommands as leoCommands
c2 = leoCommands.Commands(frame=c.frame,fileName='xyz-file')

class leoFSCommands (object):
    def create_file(self,path):         g.trace(path)
    def create_folder(self,path):       g.trace(path)
    def move (self,path,new_location):  g.trace(path,new_location)
    def remove (self,path):             g.trace(path)
    def write (self,path,data):         g.trace(path,data)

path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','..'))
    # Make the trunk folder a project
project = rope.base.project.Project(path,fscommands=leoFSCommands)
s = p.bodyString() # Could simulate a write to allow @others.

g.pr('*' * 40)
for pattern in (
    # 'g.', # works.
    # 'g.trace(', # weird.
    # 'rope.base.', # works.
    'g.list', # works: gives g.listToString
    'c2.de', # works.
):
    i = s.find(pattern)
    if i &gt; -1:
        proposals = codeassist.code_assist(project,s,i+len(pattern))
        g.pr('-' * 20)
        g.pr('pattern:',pattern)
        g.pr(g.listToString(proposals))</t>
<t tx="ekr.20080529111617.1"></t>
<t tx="ekr.20080529111617.10">The name of time unit (e.g. days, weeks, hours)</t>
<t tx="ekr.20080529111617.2"></t>
<t tx="ekr.20080529111617.3">The colour used instead of green in progress bars</t>
<t tx="ekr.20080529111617.4">The colour used instead of red in progress bars</t>
<t tx="ekr.20080529111617.5"># list of @file node types to color.
# Uncomment these to enable coloring for these kinds of nodes.
# @asis
# @file
# @auto
# @thin
@auto</t>
<t tx="ekr.20080529111617.6">The base width of progress bars, in pixels.</t>
<t tx="ekr.20080529111617.7">The default number of time units.</t>
<t tx="ekr.20080529111617.8">0: no progress bars
1: unscaled progress bars
2: scaled progress bars</t>
<t tx="ekr.20080529111617.9">pixels per time unit to add to width of scaled progress bars</t>
<t tx="ekr.20080531080812.1">def eggs():
    g.trace()

def spam():
    g.trace()
    eggs()

t = g.startTracer()
spam()
t.stop()
</t>
<t tx="ekr.20080531131542.1">import mx.TextTools as tt

&lt;&lt; define scan4 tables &gt;&gt;
&lt;&lt; define s &gt;&gt;

@others

g.pr('*' * 60)
ok,taglist,nextindex = tt.tag(s,lineTable)
# g.pr(g.listToString(taglist))
for z in taglist:
    printItem(z,level=0)
g.pr('ok:',ok)
</t>
<t tx="ekr.20080531131542.2">from mx.TextTools import * # Required for tags.

ws_charset   = CharSet(' \t')
name_charset = CharSet(alpha)

gnxTable = (
    (None,Is,':',MatchFail),
    (None,AllNotIn,':',MatchFail),
    (None,Is,':',MatchFail,MatchOk),
)

sentinelNameTable = (
    (None,Is,'@',+1,+3),
    (None,Is,'+',+1,+2),
    (None,Is,'-',+1),
    (None,AllInCharSet,name_charset,MatchFail,MatchOk),
)

sentinelTable = (
    # Start of another line.
    # Skip ws.
    (None,AllInCharSet,ws_charset,+1),
    # Require sentinel comment.
    (None,Word,'#@',MatchFail),
    ('kind',Table,sentinelNameTable,MatchFail),
    ('gnx',Table,gnxTable,+1),
    # Everything else is the sentinel value
    ('extra',AllNotIn,'\n',+1),
    (None,Is,'\n',MatchOk,MatchOk),
)

normalLineTable = (
    (None,AllNotIn,'\n',+1),
    (None,Is,'\n',MatchOk,MatchOk),
)

lineTable = (
    ('sent',Table,sentinelTable,+1,+2),
    ('line',Table,normalLineTable,+1,+1),
    ('eof',EOF,Here,-2),
)</t>
<t tx="ekr.20080531131542.4">def printItem(aList,level):

    obj,lt_index,rt_index,subtag = aList
    g.pr('  '*level,obj,repr(s[lt_index:rt_index]))
    if subtag:
        for z in subtag:
            printItem(z,level+1)
</t>
<t tx="ekr.20080531141227.1">path = r'c:\leo.repo\trunk\leo\core\runLeo.py'
f = file(path)
s = f.read()
f.close()</t>
<t tx="ekr.20080604104453.5">@nocolor

This setting determines the initial binding for otherwise-unbound keystrokes
when no mode is in effect.  Note: the keyboard-quit command exits all modes.

The valid values are::

command:  Leo ignores the key (like Vim).
insert:  Leo inserts the key at the cursor (like Emacs)
overwrite: Leo replaces the character at the cursor.</t>
<t tx="ekr.20080610144233.1">aaaaaaaaaaaa bbbbbbbbbbbbbbbbbb cccccccccccccccc ddddddddddddddddddd eeeeeeeeeeeeeee ffffffffffffffffff ggggggggggggggggggggg hhhhhhhhhhhhhhhh iiiiiiiiiiiii jjjjjjjjjjjjjjjj kkkkkkkkkkkkkk llllllllllllll mmmmmmmmmmmmmmmmm nnnnnnnnnnnn ooooooooo</t>
<t tx="ekr.20080617170334.1">@first # -*- coding: utf-8 -*-

import Tkinter as Tk

top = Tk.Toplevel()
w = Tk.Text(top)
w.pack()

def key(event):
    if event.char: g.pr('state',event.state,'char', repr(event.char), repr(event.keysym))

def after():
    g.trace()
    w.event_generate('&lt;Key&gt;',keysym='a')
    w.event_generate('A')
    w.event_generate(g.toEncodedString('Á',encoding='utf8'))
    # w.event_generate('&lt;Key-Control_L&gt;')
    # w.event_generate('c')
    # w.event_generate('Shift-Control-a')

w.bind('&lt;Key&gt;',key)
w.focus_set()
w.update()
# top.after_idle(after)
top.mainloop()
</t>
<t tx="ekr.20080628094340.1">if 0:
    # Called when func is **defined**
    def leo_command(func):
        g.trace(func.__name__)
        return func
else:
    class leo_command:
        def __init__(self,func,c=c):
            self.c = c
            self.func = func
            self.name = func.__name__
            g.pr("registering",self.name)

        def __call__(__self,*__args,**__kw):
            g.pr("before", __self.name)
            try:
                return __self.func(*__args,**__kw)
            finally:
                g.pr("after ", __self.name)
                g.pr('c',c)
                c.outerUpdate()


@leo_command
def hello():
    g.pr("Hello, world!")

hello()
</t>
<t tx="ekr.20080701101740.1">import locale
aList = dir(locale)
# g.pr(g.listToString(aList))

g.pr(g.getpreferredencoding())
# import os
# g.pr(dir(os))
</t>
<t tx="ekr.20080701130406.1">import glob

aList = glob.glob(r'c:\leo.repo\trunk\leo\plugins\*.py')
for z in aList:
    name = g.shortFileName(z)
    if not name.startswith('_'):
        g.pr('echo .')
        g.pr('echo',name)
        g.pr('call pylint.bat core\%s' % name)</t>
<t tx="ekr.20080729153237.1"></t>
<t tx="ekr.20080729153237.2"># True: calls to the garbage collector.</t>
<t tx="ekr.20080729153237.3"># True (recommended): print a message when Leo calls gc.collect explicitly.</t>
<t tx="ekr.20080729153237.4"># True: verbose trace the garbage collector.</t>
<t tx="ekr.20080806145258.1"></t>
<t tx="ekr.20080806145258.12">@nocolor

Notes:
    
- button Leo2dHTML creates leo\test\x.htm, where x is the name of the .leo file
  containing the script. The file contains javascript that allows a browser to
  expand and contract headlines.  Leo2DHTML is *unrelated* to the other files.
    
- leo\test\server.py is a minimal Python server.  Invoke from a console with::
    
    python server.py

To use this server, type this url in a web browser: http://localhost:8080/
The server will print the contents of the directory from which it was invoked.
Choose hello.html to see the 'Hello World' test page.

- leo\test\hello.html is a test page.  It uses leo\test\cgi-bin\edward.py

- leo\test\cgi-bin\edward.py is the script called from hello.leo when the user
  hits the 'Submit Query button.
  This is recompiled (as needed) for every query, which makes testing it easier.
  
  **Important** edward.py returns its result by printing (in a special format):
  Thus, everything you print will be part of the returned form(!). You **can**
  print debug info: just make sure you don't mess up the special conventions:
  the best place to print debugging info is in print_all.

@color</t>
<t tx="ekr.20080806145258.13">@

edward.py:
    
How can we get the content of an input form?</t>
<t tx="ekr.20080806145258.14">@first # -*- coding: utf-8 -*-
@language python
@tabwidth -4

&lt;&lt; about LeoToHTML &gt;&gt;
import leo.core.leoGlobals as g
&lt;&lt; define dhtml stuff &gt;&gt;
@others

fileName = c.frame.shortFileName() # Get current outline file name
if fileName.endswith('.leo'): fileName = fileName[:-4] # Remove .leo suffix
path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test',fileName)) + '.htm'

# Write the file.
f=open(path, 'w')
writeAll(f)
f.close() 
g.es('wrote: %s' % (path),color="turquoise4") 
</t>
<t tx="ekr.20080806145258.15">@

LeoToHTML by Dan Rahmel, modified by EKR.

This @button script creates an .htm file containing the contents of the selected tree.
The file is called x.htm, where x is the name of the .leo file containing the script.
This file is written to the leo/test folder.

The script inserts javascript into the page so that nodes can be expanded and contracted.

The script presently works well.  This script may become the basis for a facebook app.

The generated html passes html-tidy: http://www.w3.org/People/Raggett/tidy/
</t>
<t tx="ekr.20080806145258.16">division = """
&lt;div STYLE="margin-left:3em;text-indent:0em;margin-top:0em; margin-bottom:0em;"&gt;
&lt;h3 onClick="expandcontent('sc%d')" style="cursor:hand; cursor:pointer; margin-top:0em; margin-bottom:0em"&gt;+ %s&lt;/h3&gt;
    &lt;div id="sc%d" class="switchcontent" style="margin-top:0em; margin-bottom:0em;"&gt;
"""

javascript  = """
&lt;script src="cgi-bin/leo.js" type="text/javascript"&gt;&lt;/script&gt;
"""

style = '''
&lt;STYLE type="text/css"&gt;
    BODY {font:x-medium 'Verdana'; margin-right:1.5em}
    PRE {margin:0px; display:inline}
&lt;/STYLE&gt;
'''
</t>
<t tx="ekr.20080806145258.17">def escape (s):

    return s.replace('&amp;','&amp;amp;').replace('&lt;','&amp;lt;').replace('&gt;','&amp;gt;')
</t>
<t tx="ekr.20080806145258.18">def writeAll(f):

    f.write('&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;')
    f.write('&lt;html&gt;')
    writeHead(f)
    writeBody(f)
    f.write("&lt;/html&gt;")
</t>
<t tx="ekr.20080806145258.19">def writeBody(f):

    f.write('&lt;body class="st" onload="format()"&gt;')
    writeContents(f)
    f.write("&lt;/body&gt;")
</t>
<t tx="ekr.20080806145258.20">def writeHead(f):

    f.write('&lt;head&gt;')
    f.write(style)
    f.write(javascript)
    f.write('&lt;title&gt;%s&lt;/title&gt;' % c.shortFileName())
    f.write('&lt;/head&gt;')
</t>
<t tx="ekr.20080806145258.21">def writeContents(f):

    div = "&lt;div class='c' STYLE='margin-left:4em;margin-top:0em; margin-bottom:0em;'&gt;\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n&lt;/div&gt;"
    end_div = "&lt;/div&gt;\n&lt;/div&gt;\n"
    n = 1 # The node number
    current = c.currentPosition()
    prev_level = current.level()
    open_divs = 0
    for p in current.self_and_subtree_iter():
        h = p.headString()
        while prev_level &gt;= p.level() and open_divs &gt; 0:
            f.write(end_div)
            prev_level -= 1
            open_divs -= 1
        body = p.bodyString().encode( "utf-8" )
        body = body.rstrip().rstrip("\n")
        f.write(division % (n,escape(h),n))
        open_divs += 1
        if body:
            f.write(div % escape(body))
        prev_level = p.level()
        n += 1

    # Close all divisions.
    while open_divs &gt; 0:
        f.write(end_div)
        open_divs -= 1
</t>
<t tx="ekr.20080806145258.22"># def writePreamble(f):

    # '''Write HTML header information.'''

    # header_start = '''\


# &lt;body class="st" onload="format()"&gt;
# '''

    # for s in (header_start,style,javascript,header_end):
        # # f.write(g.adjustTripleString(s,c.tab_width))
        # f.write(s)
</t>
<t tx="ekr.20080806145258.23"># def writePostamble (f):

    # pass

</t>
<t tx="ekr.20080806145258.24"># A minimal python server for testing.
# To access this server, type this url in a web browser: http://localhost:8080/
# The server will print the contents of the directory from which it was invoked.
# Choose hello.html to see the 'Hello World' test page.

import CGIHTTPServer
import SocketServer

port = 8080

Handler = CGIHTTPServer.CGIHTTPRequestHandler
s = SocketServer.TCPServer(("", port), Handler)

s.server_name = '127.0.0.1' # represents local host.
s.server_port = port

# import os ; print 'cwd', os.getcwd()

print "server.py: serving at port", port
s.serve_forever()
</t>
<t tx="ekr.20080806145258.25">@language html

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;/title&gt;

&lt;!-- Used by edward.old.py
&lt;script language="JavaScript" type="text/javascript"&gt;
   var openImg = new Image();
   openImg.src = "open.gif";
   var closedImg = new Image();
   closedImg.src = "closed.gif";

   function showNode(node) {
      var objBranch = 
         document.getElementById(node).style;
      if(objBranch.display=="block")
         objBranch.display="none";
      else
         objBranch.display="block";
   }

   function swapFolder(img) {
      objImg = document.getElementById(img);
      if(objImg.src.indexOf('closed.gif')&gt;-1)
         objImg.src = openImg.src;
      else
         objImg.src = closedImg.src;
   }
&lt;/script&gt;
--&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;form action="cgi-bin/edward.py" method="GET"&gt;
&lt;input type="submit" name="George"&gt;
&lt;/form&gt;

&lt;p&gt;This is the hello world test page.
The server in server.py should be running when using this page.

&lt;p&gt;The button (form) above should cause the server to send a "GET" request
to the edward.py script, which will respond with a new page.

&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20080806145258.26">@first #! c:\python25\python.exe
@first # -*- coding: utf-8 -*-

'''This is the cgi script called from hello.html when the user hits the button.'''

### Print statements are used to return results (return the form).
### You *can* use print statement for tracing, but only in print_all.
# To do: use cgi.FieldStorage.

@language python
@tabwidth -4
&lt;&lt; imports &gt;&gt;
&lt;&lt; define dhtml stuff &gt;&gt;
@others

if 1: # Open the bridge.
    path = os.path.abspath(os.path.join(leoParentDir,'leo','test','test.leo')) # c does not exist!
    b = leoBridge.controller(gui='nullGui',loadPlugins=False,readSettings=False,verbose=False)
    g = b.globals()
    c = b.openLeoFile(path)
    p = c.rootPosition()
else:
    c = None

# import pdb ; pdb.Pdb() # Doesn't work.
print_all(c)</t>
<t tx="ekr.20080806145258.27">division = """
&lt;div STYLE="margin-left:3em;text-indent:0em;margin-top:0em; margin-bottom:0em;"&gt;
&lt;h3 onClick="expandcontent('sc%d')" style="cursor:hand; cursor:pointer; margin-top:0em; margin-bottom:0em"&gt;+ %s&lt;/h3&gt;
    &lt;div id="sc%d" class="switchcontent" style="margin-top:0em; margin-bottom:0em;"&gt;
"""

style = """
&lt;STYLE type="text/css"&gt;
    BODY {font:x-medium 'Verdana'; margin-right:1.5em}
    PRE {margin:0px; display:inline}
&lt;/STYLE&gt;
"""</t>
<t tx="ekr.20080806145258.28">def escape (s):

    return s.replace('&amp;','&amp;amp;').replace('&lt;','&amp;lt;').replace('&gt;','&amp;gt;')
</t>
<t tx="ekr.20080806145258.29">def print_all(c):

    # This line is required (with extra newline), but does not show on the page.
    print "Content-type:text/html\n"

    print '&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;'
    print '&lt;html&gt;'
    if c:
        # Print the page.
        print_head(c)
        print_body(c)
    else:
        # Print the debugging info.
        print '__file__',__file__
        print 'os.getcwd()',os.getcwd()

    print '&lt;/html&gt;'
</t>
<t tx="ekr.20080806145258.30">def print_body(c):

    print '&lt;body class="st" onload="format()"&gt;'

    if 0:
        # Debugging info.
        form = cgi.FieldStorage()
        print repr(form)
        # if form.has_key('name'):
            # print 'name',form['name'].value
        # else:
            # print 'no name'
    print_tree(c)
    print '&lt;/body&gt;'
</t>
<t tx="ekr.20080806145258.31">def print_head(c):

    print '&lt;head&gt;'

    if 1: # Copy the entire leo.js file into the page.
        print '&lt;script type="text/javascript"&gt;'
        print_leo_dot_js(c)
        print '&lt;/script&gt;'

    else: # Possible bug in the python server??
        # The Python says leo.js is not executable(!)
        print '&lt;script src="leo.js" type="text/javascript"&gt;&lt;/script&gt;'

    print '&lt;title&gt;%s&lt;/title&gt;' % (c.shortFileName())
    print '&lt;/head&gt;'
</t>
<t tx="ekr.20080806145258.32">def print_leo_dot_js(c):

    path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','cgi-bin','leo.js'))

    try:
        f = file(path)
    except IOError:
        print 'can not open',path
        return

    for line in f.readlines():
        print line,

    f.close()
</t>
<t tx="ekr.20080806145258.33">def print_tree(c):

    div = "&lt;div class='c' STYLE='margin-left:4em;margin-top:0em; margin-bottom:0em;'&gt;\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n&lt;/div&gt;"
    end_div = "&lt;/div&gt;\n&lt;/div&gt;\n"
    n = 1 # The node number
    prev_level = 0
    open_divs = 0
    for p in c.allNodes_iter():
        h = p.headString()
        while prev_level &gt;= p.level() and open_divs &gt; 0:
            print end_div
            prev_level -= 1
            open_divs -= 1
        body = p.bodyString().encode( "utf-8" )
        body = body.rstrip().rstrip("\n")
        print division % (n,escape(h),n)
        open_divs += 1
        if body: print div % escape(body)
        prev_level = p.level()
        n += 1

    # Close all divisions.
    while open_divs &gt; 0:
        print end_div
        open_divs -= 1
</t>
<t tx="ekr.20080806145258.34"></t>
<t tx="ekr.20080806145702.1">import os
import sys

# Add the *parent* of the leo directory to sys.path.
leoParentDir = os.path.abspath(os.path.join(os.path.dirname(__file__),'..','..','..'))

if leoParentDir not in sys.path:
    sys.path.append(leoParentDir)

import leo.core.leoBridge as leoBridge

import cgi
import cgitb ; cgitb.enable()
</t>
<t tx="ekr.20080807114145.2">@
A script button to run any body text as a Windows Script.
See: http://en.wikipedia.org/wiki/Windows_Script_Host

You need the win32 extensions and you must enable the script engine.
Adapted from Active State examples:ch21_active_scripting:ActiveApp.py
http://python.net/crew/mhammond/win32/
@c

&lt;&lt; imports &gt;&gt;

@others

RunCode("python",p.bodyString())
</t>
<t tx="ekr.20080807115344.1">Application.Echo("Hello from Python")
</t>
<t tx="ekr.20080807115344.2">class MySite(axsite.AXSite):
    # Our error handler will simply print to the console.
    def OnScriptError(self, activeScriptError):
        exc = activeScriptError.GetExceptionInfo()
        print "Exception:", exc[1]
        try:
            sourceText = activeScriptError.GetSourceLineText()
        except pythoncom.com_error:
            sourceText = None
        if sourceText is not None: 
            context, lineNo, charNo = activeScriptError.GetSourcePosition()
            print sourceText
            indent = " " * (charNo-1)
            print indent + "^"
        return winerror.S_OK
</t>
<t tx="ekr.20080807115344.3"># A named object for our namespace
# A normal Python COM object (minus registration info)
class Application:
    _public_methods_ = [ 'Echo' ]
    def Echo(self, *args):
        print string.join(map(str, args))

</t>
<t tx="ekr.20080807115344.4"># Create the site and the engine and runs the code.
def RunCode(engineName, code):

    app = win32com.server.util.wrap( Application() )

    # Create a dictionary holding our object model.
    model = {'Application' : app,}

    # Create the scripting site.
    site = MySite(model)
    # Create the engine and add the code.
    engine = site.AddEngine(engineName)
    engine.AddCode(code)

    # Run the code.
    engine.Start()
</t>
<t tx="ekr.20080807115344.5">import string
import sys
from win32com.axscript import axscript
from win32com.axscript.server import axsite
import pythoncom
import win32com.server.util</t>
<t tx="ekr.20080811113441.2"></t>
<t tx="ekr.20080813100905.1">import sys
print sys.argv</t>
<t tx="ekr.20080815073750.1">n = 0
for p in c.allNodes_iter():
    if p.isAtNoSentFileNode():
        c.atFileCommands.write(p,nosentinels=True)
        n += 1
g.es('done: %s files written' %(n))</t>
<t tx="ekr.20080821111715.1">@first # -*- coding: utf-8 -*-

# Important: see http://webpages.charter.net/edreamleo/FAQ.html#unicode-issues

import sys

print '=' * 40

e = sys.getdefaultencoding()
assert e.lower() == 'utf-8'
print 'encoding',e

table = (
    'La Peña',
    unicode('La Peña','utf-8'),
    u'La Peña',
    u'La Pe\xf1a',
    # u'AA \u0102 BB',
)

for s in table:
    print type(s)
    g.es_print('g.es_print',s)
    if type(s) != type(u'a'):
        s = unicode(s,e)
    print      'print     ',s
    print      'repr(s)   ',repr(s)
</t>
<t tx="ekr.20080822153619.1"></t>
<t tx="ekr.20080823154546.1">p2 = p.insertAfter()
p2.setHeadString('inserted node')
s = p.bodyString()

# Remove Leo directives.
directives = ['@'+z for z in g.globalDirectiveList]
def isDirective(s):
    for z in directives:
        if s.startswith(z):
            return True
    else: return False
aList = [z for z in g.splitLines(s) if not isDirective(z)]
s = ''.join(aList)
if not s.endswith('\n'): s = s + '\n'

c.importCommands.scanPythonText(s,p2.copy(),atAuto=True)
c.redraw_now()
g.pr('done')</t>
<t tx="ekr.20080915095329.1">import leo.core.leoPlugins as leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    controller = rst3.controllers.get(c)
    if controller:
        controller.processTopTree(p)
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True

# print 'done'
</t>
<t tx="ekr.20080917063615.1">aList = (
'aspellbindir',
'wholeword',
'Whole-Word',
'vimcmd',
'huh',
)

for name in aList:
    kind, val = c.config.getSettingSource(name)
    print '%-20s %-20s %s' % (name,repr(val),kind)
</t>
<t tx="ekr.20080920101658.1">def getInput (event=None):

    '''Evaluate a Python Expression entered in the minibuffer.'''

    stateName = 'get-input'
    k = c.k ; state = k.getState(stateName)

    if state == 0:
        k.setLabelBlue('Input: ',protect=True)
        k.getArg(event,stateName,1,getInput)
    else:
        k.clearState()
        g.es_print('input:',k.arg)

getInput()
</t>
<t tx="ekr.20080921144924.1">print(g.os_path_finalize(r'~/.leo/notebook.leo'))
print(g.os_path_finalize(g.os_path_join(g.app.loadDir,r'~/.leo/notebook.leo')))
print(g.os_path_finalize_join(g.app.loadDir,r'~/.leo/notebook.leo'))</t>
<t tx="ekr.20080922142953.1"># @string default_leo_file = ~/.leo/workbook.leo
path = "{{c.config.getString('default_leo_file')}}"
# print g.os_path_expandExpression(path,c=c)
print g.os_path_finalize(path,c=c)</t>
<t tx="ekr.20080922164255.1"></t>
<t tx="ekr.20080922164255.2"></t>
<t tx="ekr.20080922164656.1"></t>
<t tx="ekr.20080923073240.1">{{c.config.getString('test')}}/eval-test.txt
=
c:\leo.repo\trunk\leo\test\eval-test.txt</t>
<t tx="ekr.20080923073240.2"></t>
<t tx="ekr.20080924081821.1"># c.k.ab

# Test this code using the execute-script command.

s = p.bodyString()
lines = g.splitLines(s)
s = lines[0]

theObject,aList = c.k.autoCompleter.getExternalCompletions(s)

print '='*20
print 'theObject',theObject and theObject.__class__
print 'len(completions)',len(aList)
print g.listToString(aList, tag='completion list', sort=True, indent='')
</t>
<t tx="ekr.20080930080501.1">c.frame.iconBar.addRow()
c.frame.addIconButton(text="New")</t>
<t tx="ekr.20080930083052.1">c.frame.hideIconBar()</t>
<t tx="ekr.20080930083052.2">c.frame.showIconBar()</t>
<t tx="ekr.20080930085514.1">c.frame.clearIconBar()</t>
<t tx="ekr.20080930114036.1"></t>
<t tx="ekr.20081003094737.1"></t>
<t tx="ekr.20081025105942.1">import os
os.system("dir")</t>
<t tx="ekr.20081205104320.1"># import os
tag = '#!/bin/bash\n'
s = g.getScript(c,p,
    useSelectedText=False,
    forcePythonSentinels=False,
    useSentinels=True)
if not s.startswith(tag):
    s = tag + s
print s
os.system(s)
</t>
<t tx="ekr.20081216091605.2">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20090122211549.1">
class test:
    
    '''Class docstring
test line 2'''
    @others
</t>
<t tx="ekr.20090122211549.2">
def spam (self):

    '''Spam docstring.
\\-4spam line 2'''

    pass
</t>
<t tx="ekr.20090128112453.1"># print p.b
# p.b = p.b + '\n# new'
# p.h = p.h + 'z'

print c.p

if 0:
    print p.v.u
    print p.v.u.get('key')
    p.v.u['key'] = 'abc'
    print p.v.u.get('key')
    p.v.u = {'key':'xyz'}
    # p.v.u = 'abc'
    print p.v.u

if 0:
    print p.v.t.u
    print p.v.t.u.get('t-key')
    p.v.t.u['t-key'] = 'pdq'
    print p.v.t.u.get('t-key')
    # p.v.t.u = {'key':'pdq'}
    # # p.v.t.u = 'pdq'
    # print p.v.t.u</t>
<t tx="ekr.20090128131130.1">aList = g.posList(c) # Start with all positions
print len(aList)
aList2 = aList.select('plugin',regex=False,removeClones=True)
print aList2.dump(sort=True)
aList3 = aList2.select('http')
print aList3.dump()

# To see the docstring, enable auto-completion and type g.posList?
# g.posList</t>
<t tx="ekr.20090201162523.1"># define a macro: ctrl-f ab ctrl-r AB
pass</t>
<t tx="ekr.20090201192257.1">b = p.b
try:
    w = c.frame.body.bodyCtrl
    w.setInsertPoint(0)
    m = c.macroCommands
    fn = g.os_path_finalize_join(g.app.loadDir,'..','..','ekr-macros.txt')
    f = open(fn)
    m.loadMacros(f)
    macro = m.namedMacros.get('ab')
    assert macro
    m.executeMacro(macro)
finally:
    assert p.b =='ab' + b,p.b
    p.b = b
</t>
<t tx="ekr.20090205070715.1">#colorer = c.frame.body.colorizer.highlighter.colorer
g.es ('total characters: %s, keywords: %s, leo_keywords: %s' % (
    colorer.totalChars,
    colorer.totalKeywordsCalls,
    colorer.totalLeoKeywordsCalls))</t>
<t tx="ekr.20090218112656.1"># 'self' is now defined in @test and @suite nodes.
self.assertEqual(1,1)</t>
<t tx="ekr.20090309064612.1"></t>
<t tx="ekr.20090309064612.2"></t>
<t tx="ekr.20090309064612.3"></t>
<t tx="ekr.20090309064612.4"></t>
<t tx="ekr.20090316115500.1"></t>
<t tx="ekr.20090428081009.1">import PyQt4.QtCore as QtCore
import PyQt4.QtGui as QtGui
from PyQt4 import uic

table = (
    (['QtGui'],'object',QtGui),
    (['QtCore'],'object',QtCore),
)

c.k.autoCompleter.defineObjectDict(table)
print c.k.autoCompleter.objectDict.keys()

# print c.k.autoCompleter.objectDict.get('QtCore')</t>
<t tx="ekr.20090507082111.1904">print "---- inserting ----"
p2 = p.insertAsLastChild().copy()
p3 = p.insertAsLastChild().copy()

print [p2.gnx, p3.gnx]

children = p.children_iter()
print [p.gnx for p in children]

c.redraw()</t>
<t tx="ekr.20090507082535.1906">import email,getpass,imaplib,os

username = 'edreamleo@gmail.com'
passfile = os.path.expanduser('~/gmailpass.txt')
M = imaplib.IMAP4_SSL('imap.gmail.com',993)
try:
    f = open(passfile)
    password = f.read()
    M.login(username,password)
except IOError:
    g.es_print('file not found: %s' % (passfile),color='red')
    # M.login(username, getpass.getpass())

M.select()
typ, data = M.search(None, 'ALL')
for num in data[0].split():
    typ, data = M.fetch(num,'(RFC822)')
    s = data[0][1]
    m = email.message_from_string(s)
    # for z in m.keys(): print z
    payload = m.get_payload()
    p2 = p.insertAsLastChild()
    date,from_s,subject = m['date'],m['from'],m['subject']
    p2.setHeadString(subject)
    body = '@nocolor\n\nDate: %s\nFrom: %s\nSubject: %s\n\n%s' % (
        date,from_s,subject,payload)
    p2.setBodyString(body)
print 'done'
M.close()
M.logout()
c.redraw()</t>
<t tx="ekr.20090514073218.1923">import leo.core.leoTest as leoTest

if False:
    # Run tests locally.
    leoTest.doTests(c,all=True)
else:
    # Run tests externally.
    path = 'test.leo' # path is relative to leo\test directory
    leoTest.runUnitTestLeoFile(gui='nullGui',path=path,silent=False)
</t>
<t tx="ekr.20090514101216.1927"># 'self' is now defined in @test and @suite nodes.
self.assertNotEqual(1,2)</t>
<t tx="ekr.20090514103332.1929">@language python</t>
<t tx="ekr.20090521070342.1907">g.app.gui.runScrolledMessageDialog(c=c,msg=u'rst:'+p.b)</t>
<t tx="ekr.20090525090210.1940">La Peña</t>
<t tx="ekr.20090601093755.1802">bookmarks = []

@g.command('bookmark')
def bookmark(event):
    c = event.get('c')
    p = c.currentPosition()
    bookmarks.append(p.gnx)
    g.es('bookmarked') </t>
<t tx="ekr.20090605083941.1804"></t>
<t tx="ekr.20090605083941.1805"></t>
<t tx="ekr.20090614142400.1806">@ first line.
line 1.
@c

# This is a test.

'''docstring
continued.
'''

if a: pass
    </t>
<t tx="ekr.20090617083033.1813">La Peña תּ
</t>
<t tx="ekr.20090617083033.1814"></t>
<t tx="ekr.20090618102458.1816">@first # -*- coding: utf-8 -*-

import PyQt4.QtCore as QtCore

s0 = unicode('La Peña','utf-8')
print s0
e = s0.encode('utf-8',"strict")
print e,repr(e)
s2 = QtCore.QString(s0)
print s2,repr(s2)
s3 = unicode(s2,'utf-8')
print s3
# s4 = QtCore.QString(e)
# print s4</t>
<t tx="ekr.20090619103402.1818"># Warning: this *replaces* the text.

bodyCtrl = c.frame.body.bodyCtrl
w = bodyCtrl.widget # A QTextEdit
s = bodyCtrl.getAllText()
w.setHtml(s)

try:
    # Lock out onTextChanged
    w.changingText = True
    w.setHtml(s)
finally:
    w.changingText = False</t>
<t tx="ekr.20090619103402.1821">bodyCtrl = c.frame.body.bodyCtrl
w = bodyCtrl.widget # A QTextEdit
s = bodyCtrl.getAllText()
w.setPlainText(s)</t>
<t tx="ekr.20090620063706.1826"></t>
<t tx="ekr.20090629105832.1790"></t>
<t tx="ekr.20090630141519.1793">#Example popup handler
from PyQt4 import QtCore

def test_acts(c,p,menu):

   # 'menu' is QMenu instance that was jsut created
   a1 = menu.addAction("Display " + p.h)
   a2 = menu.addAction("Es " + p.h)

   def a1_func():
       g.es("a1 from " + p.h)

   def a2_func():
       g.es("a2 from " + p.h)

   a1.connect(a1, QtCore.SIGNAL("triggered()"), a1_func)
   a2.connect(a2, QtCore.SIGNAL("triggered()"), a2_func)

def test_acts_handler2(c, p, menu):
   a = menu.addAction("Hello from handler 2")
   def f():
       g.es("Hello: " + p.h)

   a.connect(a, QtCore.SIGNAL("triggered()"), f)

def register():
   # the idea is just to append to the normal list g.tree_popup_handlers
   g.tree_popup_handlers.append(test_acts)
   g.tree_popup_handlers.append(test_acts_handler2)

register()</t>
<t tx="ekr.20090701062041.1798">@language php
@ doc
This is a doc part.
@c

@language php
&lt;?php
@others
?&gt;
</t>
<t tx="ekr.20090701125834.1765">fn = g.os_path_finalize_join(g.app.loadDir,'..','Icons','leo_inst.ico')
assert g.os_path_exists(fn)
c.editCommands.insertIconFromFile(path=fn)
c.bodyWantsFocusNow()</t>
<t tx="ekr.20090701133940.1767" lineYOffset="4b032e" icons="5d7100287d71012858020000006f6e71025805000000746e6f64657103580500000077686572657104580e0000006265666f7265486561646c696e6571055807000000796f666673657471064b00580400000066696c6571075837000000433a5c6c656f2e7265706f5c7472756e6b5c6c656f5c49636f6e735c54616e676f5c31367831365c616374696f6e735c6164642e706e67710858040000007870616471094b01580400000074797065710a68075807000000786f6666736574710b4b02580700000072656c50617468710c581b00000054616e676f5c31367831365c616374696f6e735c6164642e706e67710d757d710e2858020000006f6e710f6803580500000077686572657110580e0000006265666f7265486561646c696e6571115807000000796f666673657471124b00580400000066696c657113583a000000433a5c6c656f2e7265706f5c7472756e6b5c6c656f5c49636f6e735c54616e676f5c31367831365c616374696f6e735c626f74746f6d2e706e67711458040000007870616471154b01580400000074797065711668135807000000786f666673657471174b02580700000072656c506174687118581e00000054616e676f5c31367831365c616374696f6e735c626f74746f6d2e706e67711975652e">for p in c.allNodes_iter():
    v = p.v ; t = p.v.t
    # if v.u: print(v,v.u)
    # if t.u: print(t,t.u)
    icons = t.u and t.u.get('icons')
    if icons:
        for d in icons:
            fn = d.get('file')
            icon = g.app.gui.getIconImage(fn)
            print('t %s icon %s %s' % (id(t),id(icon),fn))
print('done')</t>
<t tx="ekr.20090704133634.1780">@language phpsection

&lt;body&gt;
&lt;/body&gt;
</t>
<t tx="ekr.20090705063023.1780">@root at-root-test.py
@others</t>
<t tx="ekr.20090705063023.1781"># abc line 1</t>
<t tx="ekr.20090706044257.1784">@language unknown_language
#!/bin/sh
#@+leo-ver=4-thin
#@+node:EKR.20040519082027.33:@file-thin ../../install
#@@first

# This script installs Leo on *nix.
# Initial version by by Frank Merenda (fmerenda@yahoo.com)

# Variables...
LEO_PREFIX=${LEO_PREFIX:-/usr/local}
LEO_RUN_SCRIPT_OUTPUT="${LEO_PREFIX}/bin/leo"

# Bug fix: 2008/4/8: replace /lib/leo by /lib.
LEO_LIB_DIR="${LEO_PREFIX}/lib"

echo ""
echo "Prefix directory set to \"$LEO_PREFIX\""

# Make the directory structure
if [ ! -d $LEO_LIB_DIR ] ; then
    echo ""
    echo Making directory structure $LEO_LIB_DIR

    RESULTS=`mkdir -p -m755 $LEO_LIB_DIR 2&gt;&amp;1`
    if [ $? -ne 0 ]; then
        echo Failure making directory $LEO_LIB_DIR!
        exit 1;
    fi
fi

if [ ! -d $LEO_PREFIX/bin ] ; then
    echo ""
    echo Making directory structure $LEO_PREFIX/bin
    RESULTS=`mkdir -p -m755 $LEO_PREFIX/bin 2&gt;&amp;1`
    if [ $? -ne 0 ]; then
        echo Failure making directory $LEO_PREFIX/bin!
        exit 1;
    fi
fi

# Copy the files
cp -rp leo $LEO_LIB_DIR
chown -R root:root $LEO_LIB_DIR

echo "PYTHONPATH=${LEO_PREFIX}/lib python ${LEO_PREFIX}/lib/leo/core/runLeo.py \"\$@\"" &gt; $LEO_RUN_SCRIPT_OUTPUT

RESULTS=`chmod 755 $LEO_RUN_SCRIPT_OUTPUT`   

echo ""
echo "Leo installed successfully"
echo "Make sure ${LEO_PREFIX}/bin is in your path then"
echo "type 'leo filename.leo' to use it."   
echo ""

exit 0;
#@-node:EKR.20040519082027.33:@file-thin ../../install
#@-leo
</t>
<t tx="ekr.20090712081157.1790">@language python

@others</t>
<t tx="ekr.20090712081157.1791">def spam():
    pass</t>
<t tx="ekr.20090715064044.1782">@language python

b = p.b
p2 = g.findNodeAnywhere(c,'@sphinx')
if p2:
    c.selectPosition(p2)
else:
    c.insertHeadline(op_name='Create @sphinx node')
    p2 = c.p
    p2.h = '@sphinx'
    c.redraw()

w = c.frame.body.bodyCtrl.widget
w.setHtml(b)
</t>
<t tx="ekr.20090718072135.1786">print '=' * 40</t>
<t tx="ekr.20090728090618.2832"># An example of running this script:

import os

@others

types = (".py",".vim",".txt") #,".c",".html",".txt")

dir = r"C:\prog\pydiction-1.0"

importFiles(dir,types,recursive=True)
c.redraw()

g.es("done",color="blue")
</t>
<t tx="ekr.20090728090618.2833">def importFiles (dir,type=None,kind="@file",recursive=False):

    v = c.currentVnode()

    # Check the params.
    if kind != "@file" and kind != "@root":
        g.es("kind must be @file or @root: " + kind)
        return

    if not g.os_path_exists(dir):
        g.es("directory does not exist: " + dir)
        return

    root = createLastChildOf(v,"imported files")
    try:
        importDir (dir,type,kind,recursive,root)
        root.contract()
    except:
        g.es_exception()
    c.redraw()</t>
<t tx="ekr.20090728090618.2834">def importDir (dir,types,kind,recursive,root):

    g.es("dir: " + dir,color="blue")

    try:
        files = os.listdir(dir)
        files2 = [] ; dirs =[]
        for f in files:
            path = g.os_path_join(dir,f)
            if g.os_path_isfile(path):
                name, ext = g.os_path_splitext(f)
                if not types or ext in types:
                    files2.append(path)
            elif recursive:
                dirs.append(path)
        if len(files2) &gt; 0 or len(dirs) &gt; 0:
            child = createLastChildOf(root,dir)
            c.selectVnode(child)
        if len(files2) &gt; 0:
            c.importCommands.importFilesCommand(files2,kind)
        if len(dirs) &gt; 0:
            dirs.sort()
            for dir in dirs:
                importDir(dir,types,kind,recursive,child)
    except:
        g.es("exception in importFiles script")
        g.es_exception()
</t>
<t tx="ekr.20090728090618.2835">def createLastChildOf (v,headline):

    child = v.insertAsLastChild()
    child.initHeadString(headline)
    return child
</t>
<t tx="ekr.20090728090618.2837"></t>
<t tx="ekr.20090728090618.2838">@first #!/usr/bin/env python

# Last modified: July 15th, 2009

@language python
@tabwidth -4

&lt;&lt; docstring &gt;&gt;
&lt;&lt; declarations &gt;&gt;

# Path/filename of the vim dictionary file to write to:
PYDICTION_DICT = r'complete-dict'
# Path/filename of the vim dictionary backup file:
PYDICTION_DICT_BACKUP = r'complete-dict.last'

@others

if __name__ == '__main__':
    &lt;&lt; process command line &gt;&gt;
</t>
<t tx="ekr.20090728090618.2839">__author__ = "Ryan Kulla (rkulla AT gmail DOT com)"
__version__ = "1.0"
__copyright__ = "Copyright (c) 2003-2009 Ryan Kulla"

import os
import sys
import types
import shutil
</t>
<t tx="ekr.20090728090618.2840">def get_submodules(module_name, submodules):
    """Build a list of all the submodules of modules."""

    # Try to import a given module, so we can dir() it:
    try:
        imported_module = my_import(module_name)
    except ImportError, err:
        return submodules

    mod_attrs = dir(imported_module)

    for mod_attr in mod_attrs:
        if type(getattr(imported_module, mod_attr)) is types.ModuleType:
            submodules.append(module_name + '.' + mod_attr)

    return submodules


</t>
<t tx="ekr.20090728090618.2841">def write_dictionary(module_name):
    """Write to module attributes to the vim dictionary file."""

    try:
        imported_module = my_import(module_name)
    except ImportError, err:
        return

    mod_attrs = dir(imported_module)

    # Generate fully-qualified module names: 
    write_to.write('\n--- %(x)s module with "%(x)s." prefix ---\n' % 
                   {'x': module_name})
    for mod_attr in mod_attrs:
        if callable(getattr(imported_module, mod_attr)):
            # If an attribute is callable, show an opening parentheses:
            prefix_on = '%s.%s('
        else:
            prefix_on = '%s.%s'
        write_to.write(prefix_on % (module_name, mod_attr) + '\n')

    # Generate non-fully-qualified module names: 
    write_to.write('\n--- %(x)s module without "%(x)s." prefix ---\n' % 
                   {'x': module_name})
    for mod_attr in mod_attrs:
        if callable(getattr(imported_module, mod_attr)):
            prefix_off = '%s('
        else:
            prefix_off = '%s'
        write_to.write(prefix_off % mod_attr + '\n')
</t>
<t tx="ekr.20090728090618.2842">def my_import(name):
    """Make __import__ import "package.module" formatted names."""
    mod = __import__(name)
    components = name.split('.')
    for comp in components[1:]:
        mod = getattr(mod, comp)
    return mod


</t>
<t tx="ekr.20090728090618.2843">def remove_duplicates(seq, keep=()):
    """

    Remove duplicates from a sequence while perserving order.

    The optional tuple argument "keep" can be given to specificy 
    each string you don't want to be removed as a duplicate.
    """
    seq2 = []
    seen = set();
    for i in seq:
        if i in (keep):
            seq2.append(i)
            continue
        elif i not in seen:
            seq2.append(i)
        seen.add(i)
    return seq2


</t>
<t tx="ekr.20090728090618.2844">def get_yesno(msg="[Y/n]?"):
    """

    Returns True if user inputs 'n', 'Y', "yes", "Yes"...
    Returns False if user inputs 'n', 'N', "no", "No"...
    If they enter an invalid option it tells them so and asks again.
    Hitting Enter is equivalent to answering Yes.
    Takes an optional message to display, defaults to "[Y/n]?".

    """
    while True:
        answer = raw_input(msg)
        if answer == '':
            return True
        elif len(answer):
            answer = answer.lower()[0]
            if answer == 'y':
                return True
                break
            elif answer == 'n':
                return False
                break
            else:
                print "Invalid option. Please try again."
                continue


</t>
<t tx="ekr.20090728090618.2845">def main(write_to):
    """Generate a dictionary for Vim of python module attributes."""
    submodules = []

    for module_name in sys.argv[1:]:
        try:
            imported_module = my_import(module_name)
        except ImportError, err:
            print "Couldn't import: %s. %s" % (module_name, err)
            sys.argv.remove(module_name)

    cli_modules = sys.argv[1:]

    # Step through each command line argument:
    for module_name in cli_modules:
        print "Trying module: %s" % module_name
        submodules = get_submodules(module_name, submodules)

        # Step through the current module's submodules:
        for submodule_name in submodules:
            submodules = get_submodules(submodule_name, submodules)

    # Add the top-level modules to the list too:
    for module_name in cli_modules:
        submodules.append(module_name)

    submodules.sort()

    # Step through all of the modules and submodules to create the dict file:
    for submodule_name in submodules:
        write_dictionary(submodule_name)

    # Close and Reopen the file for reading and remove all duplicate lines:
    write_to.close()
    print "Removing duplicates..."
    f = open(PYDICTION_DICT, 'r')
    file_lines = f.readlines()
    file_lines = remove_duplicates(file_lines, ('\n'))
    f.close()

    # Delete the original file:
    os.unlink(PYDICTION_DICT)

    # Recreate the file, this time it won't have any duplicates lines:
    f = open(PYDICTION_DICT, 'w')
    for attr in file_lines:
        f.write(attr)
    f.close()
    print "Done."
</t>
<t tx="ekr.20090728090618.2846">@language vim
" ============================================================================
" python_pydiction.vim - Module and Keyword completion for Python
" ============================================================================
"
" Author: Ryan Kulla (rkulla AT gmail DOT com)
" Version: 1.0, for Vim 7
" URL: http://www.vim.org/scripts/script.php?script_id=850
" Last Modified: July 18th, 2009
" Installation: On Linux, put this file in ~/.vim/after/ftplugin/
"               On Windows, put this file in C:\vim\vimfiles\ftplugin\
"                        (assuming you installed vim in C:\vim\).
"               You may install the other files anywhere. 
"               In .vimrc, add the following:
"                   filetype plugin on
"                   let g:pydiction_location = 'path/to/complete-dict'
"               Optionally, you set the completion menu height like:
"                   let g:pydiction_menu_height = 20
"               The default menu height is 15
"               To do case-sensitive searches, set noignorecase (:set noic).
" License: BSD
" Copyright: Copyright (c) 2003-2009 Ryan Kulla
"            All rights reserved.
"
"            Redistribution and use in source and binary forms, with or without
"            modification, are permitted provided that the following conditions
"            are met:
"            1. Redistributions of source code must retain the above copyright
"               notice, this list of conditions and the following disclaimer.
"            2. Redistributions in binary form must reproduce the above
"               copyright notice, this list of conditions and the following
"               disclaimer in the documentation and/or other materials provided
"               with the distribution.
"            3. The name of the author may not be used to endorse or promote 
"               products derived from this software without specific prior 
"               written permission.
"
"            THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
"            OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
"            WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
"            ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
"            DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
"            DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
"            GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
"            INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
"            WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
"            NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
"            THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"
"

if v:version &lt; 700
    echoerr "Pydiction requires vim version 7 or greater."
    finish
endif


" Make the Tab key do python code completion:
inoremap &lt;silent&gt; &lt;buffer&gt; &lt;Tab&gt; 
         \&lt;C-R&gt;=&lt;SID&gt;SetVals()&lt;CR&gt;
         \&lt;C-R&gt;=&lt;SID&gt;TabComplete()&lt;CR&gt;
         \&lt;C-R&gt;=&lt;SID&gt;RestoreVals()&lt;CR&gt;


if !exists("*s:TabComplete")
    function! s:TabComplete()
        " Check if the char before the char under the cursor is an 
        " underscore, letter, number, dot or opening parentheses.
        " If it is, and if the popup menu is not visible, use 
        " I_CTRL-X_CTRL-K ('dictionary' only completion)--otherwise, 
        " use I_CTRL-N to scroll downward through the popup menu.
        " If the char is some other character, insert a normal Tab:
        if searchpos('[_a-zA-Z0-9.(]\%#', 'nb') != [0, 0] 
            if !pumvisible()
                return "\&lt;C-X&gt;\&lt;C-K&gt;"
            else
                return "\&lt;C-N&gt;"
            endif
        else
            return "\&lt;Tab&gt;"
        endif
    endfunction
endif


if !exists("*s:SetVals") 
    function! s:SetVals()
        " Save and change any config values we need.

        " Temporarily change isk to treat periods and opening 
        " parenthesis as part of a keyword -- so we can complete
        " python modules and functions:
        let s:pydiction_save_isk = &amp;iskeyword
        setlocal iskeyword +=.,(

        " Save any current dictionaries the user has set:
        let s:pydiction_save_dictions = &amp;dictionary
        " Temporarily use only pydiction's dictionary:
        let &amp;dictionary = g:pydiction_location

        " Save the ins-completion options the user has set:
        let s:pydiction_save_cot = &amp;completeopt
        " Have the completion menu show up for one or more matches:
        let &amp;completeopt = "menu,menuone"

        " Set the popup menu height:
        let s:pydiction_save_pumheight = &amp;pumheight
        if !exists('g:pydiction_menu_height')
            let g:pydiction_menu_height = 15
        endif
        let &amp;pumheight = g:pydiction_menu_height

        return ''
    endfunction
endif


if !exists("*s:RestoreVals")
    function! s:RestoreVals()
        " Restore the user's initial values.

        let &amp;dictionary = s:pydiction_save_dictions
        let &amp;completeopt = s:pydiction_save_cot
        let &amp;pumheight = s:pydiction_save_pumheight
        let &amp;iskeyword = s:pydiction_save_isk

        return ''
    endfunction
endif
</t>
<t tx="ekr.20090728090618.2847">@nocolor
Pydiction 1.0 by Ryan Kulla (http://www.vim.org/scripts/script.php?script_id=850)
-------------

Pydiction is a filetype plugin for python files to be able to tab-complete Python code, including Python's keywords, standard library and even third-party libraries.  

It consists of three main files: 
    python_pydiction.vim -- This is the ftplugin you put in your non-system ftplugin directory. (i.e., ~/.vim/after/ftplugin/, on Unix or C:\vim\vimfiles\ftplugin\, on Windows)
    complete-dict -- This is a vim dictionary file that consists of Python keywords and modules. This is what python_pydiction.vim looks at to know which things are completeable.
    pydiction.py -- This is a Python script that was used to generate complete-dict. You can optionally run this script to add more modules to complete-dict to be able to complete them.


Installing
----------
Unix/Linux: Put python_pydiction.vim in ~/.vim/after/ftplugin/   (if that directory doesn't exist, create it. Vim will know to look there automatically.)
Windows: Put python_pydiction.vim in C:\vim\vimfiles\ftplugin  (assuming you installed vim in C:\vim\).

You may install the other files (complete-dict and pydiction.py) anywhere you want. For this example, we'll assume you put them in "C:\vim\vimfiles\ftplugin\pydiction\" (Do not put any file but python_pydiction.vim in the ftplugin\ directory, only .vim files should go there. It's ok to make a subdirectory in it though, like I just did.)

In your .vimrc file, first add the following line to enable filetype plugins:

    filetype plugin on

then make sure you set "g:pydiction_location" to the full path of where yo uinstalled complete-dict. Ie:

    let g:pydiction_location = 'C:/vim/vimfiles/ftplugin/pydiction/complete-dict'

You can optionally set the height of the completion menu by setting "g:pydiction_menu_height" in your vimrc. The default height is 15:

    let g:pydiction_menu_height = 20

By default, pydiction ignores case while doing Tab-completion. If you want it to do case-sensitive searches, then set noignorecase (:set noic).


Pydiction versus other forms of completion 
------------------------------------------
Pydiction can complete Python Keywords, as well as Python module names, and their attributes and methods. It can also complete both the fully-qualified module names such as "module.method(", as well as non-fully qualified names such as "method(".

Pydiction only uses the Tab-key to complete, uses a special dictionary file to complete from, and only attempts to do it on python files. This has the advantages of only requiring one keystroke to do completion and of not polluting all of your completion menus that you may be using for other types of completion, such as Vim's regular omni-completion, or other completion scripts that you may be running.

Since pydiction uses a dictionary file of possible completion items, it can complete 3rd party modules much more accurately than other ways. You have full control over what it can and can't complete. If it's unable to complete anything you can either use pydiction.py to automatically add a new module's contents to the dictionary or you can even manually add them using a text editor. The dictionary is just a normal text file, which also makes it portable across all platforms.  For example, if you're a PyQT user, you can add all the PyQT related modules to the dictionary file (complete-dict) by using pydiction.py.

Also, because pydiction uses a dictionary file, You don't have to import a module before you can complete it. Nor do you even have to have the module installed. This frees you up to use pydiction as a way of looking up what a module attribute is called without having to install it first.

Pydiction is smart enough to know when you're completing callable method or not and if you are, it will automatically insert an opening parentheses for you.

The Tab key will work as normally expected for everything else. Pydiction will only try to use it to complete python code if you're editing a python file and you first type part of some python code, as specified in complete-dict.

Pydiction doesn't even require that python support be compiled into your version of vim!

python_pydiction.vim
--------------------
Pydiction will make it so your the Tab key on your keyboard is able to complete python code (as long as the functionality has been added to complete-dict).

Version 1.0 of pydiction uses a new file called python_pydiction.vim, which is an ftplugin that only activates when you're editing a python file (e.g., you're editing a file with a ".py" extension or you've manually typed ":set filetype=python").  Past versions of pydiction didn't use a plugin and instead just required you to change the value of "isk" in your .vimrc, which was not desirable. Version 1.0 and greater do not require you to manually change the value of isk, it changes it for you safely by only setting it while you're doing tab completion (of python code only), and automatically changes isk back to its original value whenever tab completion isn't being activated.

Pydiction works by using Vim's omni-completion functionality by temporarily remapping the Tab key to do the same thing as I_CTRL-X_CTRL_K (dictionary only completion). This means, whenever you're editing a Python file and you start typing the name of a python keyword or module, you can press the Tab key to complete it. For example, if you type "os.pa" and then press Tab, pydiction will pop up a completion menu in vim that will look like:
    os.pardir
    os.path
    os.pathconf(
    os.pathconf_names
    os.path.
    os.path.__all__
    os.path.__builtins__
    os.path.__doc__
    ...
Pressing Tab again while the menu is open will scroll down the menu so you can choose whatever item you want to go with, using the normal omni-completion keys:
    &lt;Ctrl-y&gt; will accept the current word.
    &lt;Space&gt; will accept the current word and insert a space.
    &lt;Ctrl-e&gt; will close the menu and not accept any word.

pydiction.py
------------
This is the Python script used to create the "complete-dict" vim dictionary file.  I have created and bundled a default complete-dict for your use. I created it in Ubuntu 9.04 Linux, so there won't be any win32 specific support in it. You're free to run pydiction.py to add as many more modules as you want.  The dictionary file will still work if you're using windows, but it won't complete win32 related modules unless you tell it to.      

Usage: In a command prompt, run: 
    $ python pydiction.py &lt;module&gt; ... [-v]
You have to have python 2.x installed.


Say you wanted to add a module called "mymodule" to complete-dict, do the following:
    $ python pydiction.py mymodule

You can input more than one module name on the command-line, just separate them by spaces:
    $ python pydiction.py mymodule1 mymodule2 mymodule3

The -v option will just write the results to stdout (standard output) instead of the complete-dict file.

If the backfup file "complete-dict.last" doesn't exist in the current directory, pydiction.py will create it for you. You should always keep a backup of your last working dictionary in case anything goes wrong, as it can get tedious having to recreate the file from scratch.

If complete-dict.last already exists, pydiction will ask you if you want to overwrite your old backup with the new backup.

If you try to add a module that already exists in complete-dict, pydiction will tell you it already exists, so don't worry about adding duplicates. In fact, you can't add duplicates, everytime pydiction.py runs it looks for and removes any duplicates in the file.

When pydiction adds new modules to complete-dict, it does so in two phases. First, it adds the fully-qualified name of the module. For example:
    module.attribute
    module.method(

then it adds the non-fully qualified name:
    attribute
    method(

this allows you to complete your python code the way that you imported it in the first place. E.g.:
    import module
or:
    from module import method

Say you want to complete "pygame.display.set_mode". If you imported Pygame using "import pygame", then you can Tab-complete using:
    pygame.di&lt;Tab&gt;
to expand to "pygame.display.". Then type:
    se&lt;Tab&gt; 
to expand to "pygame.display.set_mode("

Now say you imported using "from pygame import display". To expand to "display.set_mode(" just type:
    display.se&lt;Tab&gt;

And if you imported using "from pygame.display import set_mode" just type:
    se&lt;Tab&gt;

Keep in mind that if you don't use fully-qualified module names that you may get a lot of possible menu options popping up and so you may want to use more than just two letters to try to narrow it down. 


complete-dict
-------------
Again, this is the vim dictionary file that python_pydiction.vim reads from and pydiction.py writes to. Without this file, pydiction wouldn't know what python keywords and modules it can Tab-complete.

complete-dict is only an optional file in the sense that you can create your own if you don't want to use the default one that is bundled with pydiction.  The default complete-dict gives you a major headstart as far as what you can Tab-complete because I did my best to put all of the Python keywords, standard library and some popular third party modules in it for you. 

It currently contains:

    Python keywords:

        and       del       for       is        raise    
        assert    elif      from      lambda    return   
        break     else      global    not       try      
        class     except    if        or        while    
        continue  exec      import    pass      yield    
        def       finally   in        print
    
    Most of the standard library and builtins:  __builtin__, __future__, os, sys, time, re, sets, string, math, Tkinter, hashlib, urllib, etc... 

    It also contains some popular third-party libraries: pygame, wxPython, twisted, numarray and OpenGL.

If you open complete-dict in your text editor you'll see sections in it for each module, such as:
 
    --- os module with "os." prefix ---
    os.EX_CANTCREAT
    os.EX_CONFIG
    os.EX_DATAERR
    ...

    --- os module without "os." prefix ---
    EX_CANTCREAT
    EX_CONFIG
    EX_DATAERR
    ...

if certain attributes seem to be missing, it's probably because pydiction removed them because they were duplicates. This mainly happens with the non-fully qualified module sections. So first try searching the entire file for whatever string you assume is missing before you try adding it. For example, if you don't see "__doc__" under "--- sys module without "sys." prefix ---", it's because a previous module, such as "os" already has it.
    
If you try to recreate complete-dict from scratch, you'll need to manually add the Python keywords back to it, as those aren't generated with pydiction.py.

</t>
<t tx="ekr.20090728090618.2848">"""Process the command line."""

if sys.version_info[0:2] &lt; (2, 3):
    sys.exit("You need a Python 2.x version of at least Python 2.3")

if len(sys.argv) &lt;= 1:
    sys.exit("%s requires at least one argument. None given." % 
              sys.argv[0])

if '-v' in sys.argv:
    write_to = sys.stdout
    sys.argv.remove('-v')
elif os.path.exists(PYDICTION_DICT):
        # See if any of the given modules have already been pydiction'd:
        f = open(PYDICTION_DICT, 'r')
        file_lines = f.readlines()
        for module_name in sys.argv[1:]:
            for line in file_lines:
                if line.find('--- %s module with' % module_name) != -1:
                    print '"%s" already exists in %s. Skipping...' % \
                           (module_name, PYDICTION_DICT)
                    sys.argv.remove(module_name)
                    break
        f.close()

        if len(sys.argv) &lt; 2:
            # Check if there's still enough command-line arguments:
            sys.exit("Nothing new to do. Aborting.")

        if os.path.exists(PYDICTION_DICT_BACKUP):
            answer = get_yesno('Overwrite existing backup "%s" [Y/n]? ' % \
                                PYDICTION_DICT_BACKUP)
            if (answer):
                print "Backing up old dictionary to: %s" % \
                       PYDICTION_DICT_BACKUP
                try:
                    shutil.copyfile(PYDICTION_DICT, PYDICTION_DICT_BACKUP)
                except IOError, err:
                    print "Couldn't back up %s. %s" % (PYDICTION_DICT, err)
            else:
                print "Skipping backup..."

            print 'Appending to: "%s"' % PYDICTION_DICT
        else:
            print "Backing up current %s to %s" % \
                   (PYDICTION_DICT, PYDICTION_DICT_BACKUP)
            try:
                shutil.copyfile(PYDICTION_DICT, PYDICTION_DICT_BACKUP)
            except IOError, err:
                print "Couldn't back up %s. %s" % (PYDICTION_DICT, err)
else:
    print 'Creating file: "%s"' % PYDICTION_DICT

write_to = open(PYDICTION_DICT, 'a')

main(write_to)</t>
<t tx="ekr.20090728090618.2849">"""

pydiction.py 1.0 by Ryan Kulla (rkulla AT gmail DOT com).

Description: Creates a Vim dictionary of Python module attributes for Vim's 
             completion feature.  The created dictionary file is used by
             the Vim ftplugin "python_pydiction.vim".

Usage: pydiction.py &lt;module&gt; ... [-v]
Example: The following will append all the "time" and "math" modules'
         attributes to a file, in the current directory, called "pydiction"
         with and without the "time." and "math." prefix:
             $ python pydiction.py time math
         To print the output just to stdout, instead of appending to the file, 
         supply the -v option: 
             $ python pydiction.py -v time math

License: BSD.
"""
</t>
<t tx="ekr.20090815161520.1815">Reasonable values are iconclick2, icondclick2 and select2.

When using select2, you may want to use the detach-editor-toggle command.
</t>
<t tx="ekr.20090819085532.4265">w = c.frame.body.bodyCtrl.widget
w.setParent(None)
w.show()
</t>
<t tx="ekr.20090831145049.1819">@first # -*- coding: utf-8 -*- 
print u'ä' </t>
<t tx="ekr.20091001161528.1828">vList1 = [p.v for p in c.allPositions()]
vList2 = [p.v for p in c.allNodes_iter()]
assert vList1 == vList2
print 'pass 1'

vList1 = [p.v for p in c.allUniquePositions()]
vList2 = [v for v in c.all_unique_vnodes_iter()]
assert vList1 == vList2
print 'pass 2'
</t>
<t tx="ekr.20091007113250.1828">@language python</t>
<t tx="ekr.20091007113250.1829">def spam():
    pass</t>
<t tx="ekr.20091007113347.1832">def eggs():
    pass</t>
<t tx="ekr.20091010091628.1836">@language python

'''Create a script button that will search for the icon-like
pattern in the selected node'''

from leo.plugins import mod_scripting as scripting

script = p.b + '\n'

sc = g.app.gui.ScriptingControllerClass(c)

shortcut = sc.getShortcut(p.h)
statusLine = 'pattern find button'
if shortcut: statusLine = '%s = %s' % (statusLine,shortcut)

patC = patController(c,script)
script = patC.setup() # Modify the script

sc.createAtButtonHelper(p,p.h,statusLine,shortcut,verbose=False)
</t>
<t tx="ekr.20091010091628.1837"># This will be done automatically.
import sys
import string
path = r'c:\python25\lib\site-customize\matching'
if path not in sys.path: sys.path.append(path)
from matching.patterns_b import *
from matching.textpatterns_b import *
from matching.MatchingInput import *

print '*' * 20
subject = MatchingInput (p.b) #"abcdefgh23;ijklmn")
while True:
    if subject ^ AnyOfP (string.letters) [4] &gt;&gt; "four letters":
       print "found four letters: \"" + subject ["four letters"] + "\""
    elif subject ^ AnyOfP (string.digits) [2:] &gt;&gt; "the digits" &amp; IsP (";"):
       print "found two or more digits followed by a semicolon: \"" + \
             subject ["the digits"] + "\""
    elif subject ^ AnyOfP (string.letters) [1:3] &gt;&gt; "1 2 3 letters":
       print "found less than four letters: \"" + \
             subject ["1 2 3 letters"] + "\""
    else: break
</t>
<t tx="ekr.20091010104145.1840">class patController:
    
    '''A class supporting icon-like find scripts using
    a very-slightly modified version of library at
    http://www.wilmott.ca/python/patternmatching.html'''
    
    @others</t>
<t tx="ekr.20091010104145.1842">def __init__ (c,script,forward=True):
    
    self.c = c
    self.v = c.p.v # The node containing the find-script to be applied.
    self.script = script # Will be modified in setup.</t>
<t tx="ekr.20091010104145.1843">def setup(self):
    
    pass</t>
<t tx="ekr.20091010104145.1844">def driver (self,forward=True):
    
    '''Search for the pattern in p and all following nodes
    until a match is found.'''
    
    if forward:
        while p:
            i = self.find(p)
            if i == -1:
                p.moveToThreadNext()
            else:
                self.select(p,i) ; break
    else:
        while p:
            i = self.findr(p)
            if i == -1:
                p.moveToThreadBack()
            else:
                self.select(p,i) ; break</t>
<t tx="ekr.20091010104145.1845">def find (self,p):
    
    '''Search for self.pattern in p.
    If p is the presently selected node, start at the cursor position.
    Otherwise, start at the start of the node.
    '''</t>
<t tx="ekr.20091010104145.1846"></t>
<t tx="ekr.20091011110344.1853">import string
import sys
path = r'c:\python25\lib\site-customize\matching'
if path not in sys.path: sys.path.append(path)
from matching.patterns_b import *
from matching.textpatterns_b import *
from matching.MatchingInput import *

def find(p):
    s = MatchingInput (p.b)
    while True:
        g.trace(s.Pos)
        if s ^ AnyOfP (string.letters) [4] &gt;&gt; 'pat':
            found = 'AnyOfP (letters) [4]'
        elif s ^ AnyOfP (string.digits) [2:] &gt;&gt; 'pat' &amp; IsP (';'):
            found = 'AnyOfP(digits)[2:]'
        elif s ^ AnyOfP (string.letters) [1:3] &gt;&gt; 'pat':
            found = 'AnyOfP (letters) [1:3]'
        else:
            found = False
        if found:
            pat = s['pat']
            print ('found: %s --&gt; %s' % (found,pat))
            yield s.Pos,pat
        else:
            raise StopIteration

print '*'*20
while p:
    print '----- searching',p.h
    for pos,pat in find(p):
        print pos,pat
    p.moveToThreadNext()
print('done')
</t>
<t tx="ekr.20091013153026.2721">@
This work has been mostly abandoned.

The idea was to use icon-like patterns, based on
http://www.wilmott.ca/python/patternmatching.html

There are several problems with this approach:
    
1. This library, while elegant, isn't necessarily so useful.
   Indeed, the typical "find script" in scripts.leo uses
   either the string method s.find (or s.findr) or similar
   g.match methods.
   
2. Unlike the python regex module, there do not appear to
   be the equivalent of search or findall methods.  This
   means that the search code must either
   a) step through the search string explicitly or 
   b) use more complicated search patterns that match anywhere.
   
3. Search scripts are typically more complex than other @button scripts.
   The search scripts in scripts.leo avoid this problem by doing all
   the replacements at once, without prompts.
   
State of the prototype code:
    
- @@button find script a kinda works, but it only finds patterns at
  the start of body text.  It does shows that generators are useful.
  
- @@button create find button doesn't do anything, and it's not clear
  that is can ever be extended to be useful.
  
  The idea of this button was that clicking on a node, say "pat a",
  containing an icon-like script, would create *another* @button node,
  say "@button pat-find pat a" that would (interactively?) find all
  nodes matched by the script in "pat a".  This isn't going to be easy.</t>
<t tx="ekr.20091015191345.1856"># should show c.frame.tree

os.path.jo

c.frame.body.bodyCtrl.setBackgroundColor(color)

http://webpages.charter.net/edreamleo/front.html</t>
<t tx="ekr.20091016060748.1858">&lt;&lt; section &gt;&gt;</t>
<t tx="ekr.20091016060748.1859">if 1:
    &lt;&lt; common section &gt;&gt;</t>
<t tx="ekr.20091016060748.1860"># This is the common section</t>
<t tx="ekr.20091016060748.1861"></t>
<t tx="ekr.20091221113040.1868">@nocolor-node

1234567890-=
!@#$%^&amp;*()_+

[]\;',./
{}|:"&lt;&gt;?</t>
<t tx="ekr.20091222114015.1901">@nocolor-node

so, I guess that particular kind of editing isn't interacting with the undo
system the same way other editing does.

But undo is working, its just its recreation of the selection / insert point
that's missing. So it's picking up the changes, but perhaps only as whole text
changes?

Maybe, and I'm trying to be as helpful as possible here because I'm sure you'll
want to curse all mouse users and leave it as is :-), maybe, if I'm right that
this style of editing looks like atomic whole text changes to the undo system,
and that can't be addressed directly, and the situation can be detected (one way
would be that the selection is the whole text and the cursor position is the
beginning of the body), a best attempt at not confusing the user would be to (a)
not select the whole text, because it never was wholly selected, and (b), move
the insert point to the first difference between the new and old text.</t>
<t tx="ekr.20091223061318.1873">a line 1
b line 2
c line 3
d line 4


- double click select a word
- middle click paste it somewhere else
- undo -&gt; whole text is selected, insertion's at start
</t>
<t tx="ekr.20091228143431.1895">@nocolor
A ReStructuredText Primer
=========================

:Author: Richard Jones
:Version: $Revision: 5801 $
:Copyright: This document has been placed in the public domain.

.. contents::


The text below contains links that look like "(quickref__)".  These
are relative links that point to the `Quick reStructuredText`_ user
reference.  If these links don't work, please refer to the `master
quick reference`_ document.

__
.. _Quick reStructuredText: quickref.html
.. _master quick reference:
   http://docutils.sourceforge.net/docs/user/rst/quickref.html

.. Note:: This document is an informal introduction to
   reStructuredText.  The `What Next?`_ section below has links to
   further resources, including a formal reference.


Structure
---------

From the outset, let me say that "Structured Text" is probably a bit
of a misnomer.  It's more like "Relaxed Text" that uses certain
consistent patterns.  These patterns are interpreted by a HTML
converter to produce "Very Structured Text" that can be used by a web
browser.

The most basic pattern recognised is a **paragraph** (quickref__).
That's a chunk of text that is separated by blank lines (one is
enough).  Paragraphs must have the same indentation -- that is, line
up at their left edge.  Paragraphs that start indented will result in
indented quote paragraphs. For example::

  This is a paragraph.  It's quite
  short.

     This paragraph will result in an indented block of
     text, typically used for quoting other text.

  This is another one.

Results in:

  This is a paragraph.  It's quite
  short.

     This paragraph will result in an indented block of
     text, typically used for quoting other text.

  This is another one.

__ quickref.html#paragraphs


Text styles
-----------

(quickref__)

__ quickref.html#inline-markup

Inside paragraphs and other bodies of text, you may additionally mark
text for *italics* with "``*italics*``" or **bold** with
"``**bold**``".  This is called "inline markup".

If you want something to appear as a fixed-space literal, use
"````double back-quotes````".  Note that no further fiddling is done
inside the double back-quotes -- so asterisks "``*``" etc. are left
alone.

If you find that you want to use one of the "special" characters in
text, it will generally be OK -- reStructuredText is pretty smart.
For example, this lone asterisk * is handled just fine, as is the
asterisk in this equation: 5*6=30.  If you actually
want text \*surrounded by asterisks* to **not** be italicised, then
you need to indicate that the asterisk is not special.  You do this by
placing a backslash just before it, like so "``\*``" (quickref__), or
by enclosing it in double back-quotes (inline literals), like this::

    ``*``

__ quickref.html#escaping

.. Tip:: Think of inline markup as a form of (parentheses) and use it
   the same way: immediately before and after the text being marked
   up.  Inline markup by itself (surrounded by whitespace) or in the
   middle of a word won't be recognized.  See the `markup spec`__ for
   full details.

__ ../../ref/rst/restructuredtext.html#inline-markup


Lists
-----

Lists of items come in three main flavours: **enumerated**,
**bulleted** and **definitions**.  In all list cases, you may have as
many paragraphs, sublists, etc. as you want, as long as the left-hand
side of the paragraph or whatever aligns with the first line of text
in the list item.

Lists must always start a new paragraph -- that is, they must appear
after a blank line.

**enumerated** lists (numbers, letters or roman numerals; quickref__)
  __ quickref.html#enumerated-lists

  Start a line off with a number or letter followed by a period ".",
  right bracket ")" or surrounded by brackets "( )" -- whatever you're
  comfortable with.  All of the following forms are recognised::

    1. numbers

    A. upper-case letters
       and it goes over many lines

       with two paragraphs and all!

    a. lower-case letters

       3. with a sub-list starting at a different number
       4. make sure the numbers are in the correct sequence though!

    I. upper-case roman numerals

    i. lower-case roman numerals

    (1) numbers again

    1) and again

  Results in (note: the different enumerated list styles are not
  always supported by every web browser, so you may not get the full
  effect here):

  1. numbers

  A. upper-case letters
     and it goes over many lines

     with two paragraphs and all!

  a. lower-case letters

     3. with a sub-list starting at a different number
     4. make sure the numbers are in the correct sequence though!

  I. upper-case roman numerals

  i. lower-case roman numerals

  (1) numbers again

  1) and again

**bulleted** lists (quickref__)
  __ quickref.html#bullet-lists

  Just like enumerated lists, start the line off with a bullet point
  character - either "-", "+" or "*"::

    * a bullet point using "*"

      - a sub-list using "-"

        + yet another sub-list

      - another item

  Results in:

  * a bullet point using "*"

    - a sub-list using "-"

      + yet another sub-list

    - another item

**definition** lists (quickref__)
  __ quickref.html#definition-lists

  Unlike the other two, the definition lists consist of a term, and
  the definition of that term.  The format of a definition list is::

    what
      Definition lists associate a term with a definition.

    *how*
      The term is a one-line phrase, and the definition is one or more
      paragraphs or body elements, indented relative to the term.
      Blank lines are not allowed between term and definition.

  Results in:

  what
    Definition lists associate a term with a definition.

  *how*
    The term is a one-line phrase, and the definition is one or more
    paragraphs or body elements, indented relative to the term.
    Blank lines are not allowed between term and definition.


Preformatting (code samples)
----------------------------
(quickref__)

__ quickref.html#literal-blocks

To just include a chunk of preformatted, never-to-be-fiddled-with
text, finish the prior paragraph with "``::``".  The preformatted
block is finished when the text falls back to the same indentation
level as a paragraph prior to the preformatted block.  For example::

  An example::

      Whitespace, newlines, blank lines, and all kinds of markup
        (like *this* or \this) is preserved by literal blocks.
    Lookie here, I've dropped an indentation level
    (but not far enough)

  no more example

Results in:

  An example::

      Whitespace, newlines, blank lines, and all kinds of markup
        (like *this* or \this) is preserved by literal blocks.
    Lookie here, I've dropped an indentation level
    (but not far enough)

  no more example

Note that if a paragraph consists only of "``::``", then it's removed
from the output::

  ::

      This is preformatted text, and the
      last "::" paragraph is removed

Results in:

::

    This is preformatted text, and the
    last "::" paragraph is removed


Sections
--------

(quickref__)

__ quickref.html#section-structure

To break longer text up into sections, you use **section headers**.
These are a single line of text (one or more words) with adornment: an
underline alone, or an underline and an overline together, in dashes
"``-----``", equals "``======``", tildes "``~~~~~~``" or any of the
non-alphanumeric characters ``= - ` : ' " ~ ^ _ * + # &lt; &gt;`` that you
feel comfortable with.  An underline-only adornment is distinct from
an overline-and-underline adornment using the same character.  The
underline/overline must be at least as long as the title text.  Be
consistent, since all sections marked with the same adornment style
are deemed to be at the same level::

  Chapter 1 Title
  ===============

  Section 1.1 Title
  -----------------

  Subsection 1.1.1 Title
  ~~~~~~~~~~~~~~~~~~~~~~

  Section 1.2 Title
  -----------------

  Chapter 2 Title
  ===============

This results in the following structure, illustrated by simplified
pseudo-XML::

    &lt;section&gt;
        &lt;title&gt;
            Chapter 1 Title
        &lt;section&gt;
            &lt;title&gt;
                Section 1.1 Title
            &lt;section&gt;
                &lt;title&gt;
                    Subsection 1.1.1 Title
        &lt;section&gt;
            &lt;title&gt;
                Section 1.2 Title
    &lt;section&gt;
        &lt;title&gt;
            Chapter 2 Title

(Pseudo-XML uses indentation for nesting and has no end-tags.  It's
not possible to show actual processed output, as in the other
examples, because sections cannot exist inside block quotes.  For a
concrete example, compare the section structure of this document's
source text and processed output.)

Note that section headers are available as link targets, just using
their name.  To link to the Lists_ heading, I write "``Lists_``".  If
the heading has a space in it like `text styles`_, we need to quote
the heading "```text styles`_``".


Document Title / Subtitle
`````````````````````````

The title of the whole document is distinct from section titles and
may be formatted somewhat differently (e.g. the HTML writer by default
shows it as a centered heading).

To indicate the document title in reStructuredText, use a unique adornment
style at the beginning of the document.  To indicate the document subtitle,
use another unique adornment style immediately after the document title.  For
example::

    ================
     Document Title
    ================
    ----------
     Subtitle
    ----------

    Section Title
    =============

    ...

Note that "Document Title" and "Section Title" above both use equals
signs, but are distict and unrelated styles.  The text of
overline-and-underlined titles (but not underlined-only) may be inset
for aesthetics.


Images
------

(quickref__)

__ quickref.html#directives

To include an image in your document, you use the the ``image`` directive__.
For example::

  .. image:: images/biohazard.png

results in:

.. image:: images/biohazard.png

The ``images/biohazard.png`` part indicates the filename of the image
you wish to appear in the document. There's no restriction placed on
the image (format, size etc).  If the image is to appear in HTML and
you wish to supply additional information, you may::

  .. image:: images/biohazard.png
     :height: 100
     :width: 200
     :scale: 50
     :alt: alternate text

See the full `image directive documentation`__ for more info.

__ ../../ref/rst/directives.html
__ ../../ref/rst/directives.html#images


What Next?
----------

This primer introduces the most common features of reStructuredText,
but there are a lot more to explore.  The `Quick reStructuredText`_
user reference is a good place to go next.  For complete details, the
`reStructuredText Markup Specification`_ is the place to go [#]_.

Users who have questions or need assistance with Docutils or
reStructuredText should post a message to the Docutils-users_ mailing
list.

.. [#] If that relative link doesn't work, try the master document:
   http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html.

.. _reStructuredText Markup Specification:
   ../../ref/rst/restructuredtext.html
.. _Docutils-users: ../mailing-lists.html#docutils-users
.. _Docutils project web site: http://docutils.sourceforge.net/
</t>
<t tx="ekr.20091229092150.1939"></t>
<t tx="ekr.20091230064146.1911">xml
test.a
test-b</t>
<t tx="ekr.20091230064146.1912">@language xml
@tabwidth -4
@others

@ignore</t>
<t tx="ekr.20091230081322.1915">xml
====

</t>
<t tx="ekr.20091230081322.1916">&lt;xml&gt;
changed
@others
&lt;/xml&gt;
</t>
<t tx="ekr.20091230081322.1917">
test.a
++++++

&lt;test.a&gt;&lt;/test.a&gt;
</t>
<t tx="ekr.20091230081322.1918">
test-b
++++++

&lt;test-b&gt;&lt;/test-b&gt;
</t>
<t tx="ekr.20091230081322.1919">import unicodedata as u
table = ('a','9','_',':','.',)
table2 = (
    (0xc0,0xd6),
)
    # [#xC0-#xD6]     | [#xD8-#xF6]     | [#xF8-#x2FF]    |
    # [#x370-#x37D]   | [#x37F-#x1FFF]  | [#x200C-#x200D] |
    # [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] |
    # [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
    # | #xB7          | [#x0300-#x036F] | [#x203F-#x2040]
for ch in table:
    g.es(ch,u.category(ch))
for data in table2:
    i,j = data
    for n in range(i,j):
        if g.isPython3:
            ch = chr(n)
        else:
            ch = unichr(n)
        g.es(ch,u.category(ch))
        break # Easier</t>
</tnodes>
</leo_file>
