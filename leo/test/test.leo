<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="15" left="289" height="912" width="897"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070416075121" str_leo_pos="7"><vh>Startup</vh>
<v t="ekr.20070529172620"><vh>@chapters</vh>
<v t="ekr.20070529173219"><vh>@chapter abc</vh>
<v t="ekr.20070529173219.1"><vh>abc node 1</vh></v>
<v t="ekr.20071206070207"><vh>cross-chapter-clone-test</vh></v>
</v>
<v t="ekr.20070603190944"><vh>@chapter xyz</vh>
<v t="ekr.20070603190944.1"><vh>xyz node 1</vh></v>
<v t="ekr.20071206070207"></v>
</v>
</v>
<v t="ekr.20070224123943"><vh>@settings</vh>
<v t="ekr.20080922164255.1"><vh>@string test = c:\leo.repo\trunk\leo\test</vh></v>
<v t="ekr.20070504080933"><vh>@bool create_nonexistent_directories = True</vh></v>
<v t="ekr.20080412082246.1"><vh>@bool fixedWindow = False</vh></v>
<v t="ekr.20070604100125"><vh>@bool use_chapter_tabs = True</vh></v>
<v t="ekr.20070503085527"><vh>@bool use_chapters = True</vh></v>
<v t="ekr.20071025193940"><vh>@enabled-plugins</vh></v>
<v t="ekr.20080529111617.1"><vh>plugins</vh>
<v t="ekr.20070723091227"><vh>http plugin</vh>
<v t="ekr.20070723091227.1"><vh>@bool http_active = True</vh></v>
<v t="ekr.20070723091227.2"><vh>@int</vh>
<v t="ekr.20090316115500.1"><vh>port = 8080</vh></v>
</v>
<v t="ekr.20070723091227.3"><vh>@string rst_http_attributename = 'rst_http_attribute'</vh></v>
</v>
<v t="ekr.20080529111617.2"><vh>cleo</vh>
<v t="ekr.20080529111617.3"><vh>@color cleo_color_prog_green =</vh></v>
<v t="ekr.20080529111617.4"><vh>@color cleo_color_prog_red =</vh></v>
<v t="ekr.20080529111617.5"><vh>@data cleo_color_file_node_list</vh></v>
<v t="ekr.20080529111617.6"><vh>@int cleo_prog_width = 18</vh></v>
<v t="ekr.20080529111617.7"><vh>@float cleo_time_init = 1.0</vh></v>
<v t="ekr.20080529111617.8"><vh>@int cleo_prog_scale = 1</vh></v>
<v t="ekr.20080529111617.9"><vh>@float cleo_prog_extra = 4</vh></v>
<v t="ekr.20080529111617.10"><vh>@string cleo_time_name = 'days'</vh></v>
</v>
</v>
<v t="ekr.20080604104453.5"><vh>@strings [command,insert, overwrite] top_level_unbound_key_action = insert</vh></v>
<v t="ekr.20080729153237.1"><vh>Gc settings</vh>
<v t="ekr.20080729153237.2"><vh>@bool trace_gc = False</vh></v>
<v t="ekr.20080729153237.3"><vh>@bool trace_gc_calls = False</vh></v>
<v t="ekr.20080729153237.4"><vh>@bool trace_gc_verbose = False</vh></v>
</v>
<v t="ekr.20080822153619.1"><vh>@string shadow_subdir = .leo/shadow</vh></v>
</v>
<v t="ekr.20041001211817"><vh>Buttons</vh>
<v t="ekr.20061030041450"><vh>Run Iron Python scripts</vh>
<v t="ekr.20061030041356"><vh>@url c:\prog\IronPython-1.0.1\Doc\IronPythonApiReference.chm</vh></v>
</v>
<v t="ekr.20070531102813"><vh>Disabled buttons</vh>
<v t="ekr.20060814111542"><vh>@@button add-e</vh></v>
<v t="ekr.20080813100905.1"><vh>@@button args-test @args = a,b,c</vh></v>
<v t="ekr.20060918083159"><vh>@@button Clear uAs</vh></v>
<v t="ekr.20071002150320"><vh>@@button create-canvas</vh></v>
<v t="ekr.20060809084033"><vh>@@button cvt to g.et</vh>
<v t="ekr.20060809104405"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20060809092023"><vh>test</vh>
<v t="ekr.20060809103738"><vh>test1</vh></v>
<v t="ekr.20060809103738.1"><vh>test2</vh></v>
</v>
<v t="ekr.20060809090508"><vh>replace</vh>
<v t="ekr.20060809091749.72"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="ekr.20060809091749.73"><vh>&lt;&lt; handle g.es &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070531104646"><vh>@@button da-comp</vh></v>
<v t="ekr.20070531103315"><vh>@@button da-expand</vh></v>
<v t="ekr.20081025105942.1"><vh>@@button dir</vh></v>
<v t="ekr.20070530072113"><vh>@@button hide-ch</vh></v>
<v t="ekr.20061030041200"><vh>@@button iron-py @key=Alt-5</vh></v>
<v t="ekr.20071025192258"><vh>@@button local-tests @key=Alt+4</vh></v>
<v t="ekr.20071006084354"><vh>@@button print tk line number</vh></v>
<v t="ekr.20080105115712"><vh>@@button pylint</vh>
<v t="ekr.20080115085447"><vh>harmless warnings, errors</vh></v>
<v t="ekr.20080105130903"><vh>warnings</vh></v>
<v t="ekr.20080105120559"><vh>&lt;&lt; define data &gt;&gt;</vh></v>
</v>
<v t="ekr.20070515073111"><vh>@@button sep</vh></v>
<v t="ekr.20060427103457"><vh>@@button settings.leo</vh></v>
<v t="ekr.20080310111916.1"><vh>@@button Translate "can not" to "can't"</vh></v>
<v t="ekr.20070115092430"><vh>@@button winpdb</vh></v>
<v t="ekr.20080815073750.1"><vh>@@button write-nosent-files</vh></v>
<v t="ekr.20071128122043"><vh>@@command create-shell-tab @key = Alt+5</vh></v>
<v t="ekr.20070604095313"><vh>Chapter buttons</vh>
<v t="ekr.20070530072113.1"><vh>@@button show-ch</vh></v>
<v t="ekr.20070603175054.1"><vh>@@button ch-main</vh></v>
<v t="ekr.20070603175054"><vh>@@button ch-abc</vh></v>
<v t="ekr.20070603190713.1"><vh>@@button ch-xyz</vh></v>
<v t="ekr.20070603190713"><vh>@@button ch-add-xyz</vh></v>
</v>
<v t="ekr.20060904110922"><vh>OPML buttons</vh>
<v t="ekr.20060904111037.1"><vh>@@button opml-write</vh></v>
<v t="ekr.20060904111037"><vh>@@button opml-read</vh></v>
</v>
</v>
<v t="ekr.20080915095329.1"><vh>@@button rst3</vh></v>
</v>
<v t="ekr.20070410063214"><vh>Commands</vh>
<v t="ekr.20060924180049"><vh>@@command clones-tab</vh>
<v t="ekr.20060924180049.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060924180049.2"><vh>init</vh></v>
<v t="ekr.20060924180049.3"><vh>getAllClones</vh></v>
<v t="ekr.20060924180049.4"><vh>displayClones</vh>
<v t="ekr.20060924180049.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060924180049.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20080214091706.2"><vh>@@command ekr-command</vh></v>
<v t="ekr.20080823154546.1"><vh>@@command parse-python @key = Alt-5</vh></v>
<v t="edward.20081127113749.2"><vh>@@command complete-previous</vh>
<v t="edward.20081127113749.3"><vh>WordCompleter</vh>
<v t="edward.20081127113749.4"><vh>complete_word</vh>
<v t="edward.20081127113749.5"><vh>&lt;&lt;backward search&gt;&gt;</vh>
<v t="edward.20081127113749.6"><vh>&lt;&lt;counter check&gt;&gt;</vh></v>
</v>
<v t="edward.20081127113749.7"><vh>&lt;&lt;forward search&gt;&gt;</vh>
<v t="edward.20081127113749.6"></v>
</v>
<v t="edward.20081127113749.8"><vh>&lt;&lt;clean up and exit&gt;&gt;</vh></v>
</v>
<v t="edward.20081127113749.9"><vh>acceptable_word</vh></v>
<v t="edward.20081127113749.10"><vh>undo_replacement</vh></v>
<v t="edward.20081127113749.11"><vh>redo_replacement</vh></v>
<v t="edward.20081127113749.12"><vh>exit</vh></v>
<v t="edward.20081127113749.13"><vh>run</vh></v>
<v t="edward.20081127113749.14"><vh>adjust</vh></v>
</v>
<v t="edward.20081127113749.15"><vh>getCurrentWord</vh></v>
</v>
<v t="edward.20081127113749.16"><vh>@@command complete-next</vh>
<v t="edward.20081127113749.3"></v>
<v t="edward.20081127113749.15"></v>
</v>
</v>
<v t="ekr.20071026102420.3"><vh>Scripts</vh>
<v t="ekr.20071129103842"><vh>create-at-auto-nodes</vh></v>
<v t="ekr.20070223164126"><vh>Recursive import script</vh>
<v t="ekr.20070223164126.1"><vh>importFiles</vh></v>
<v t="ekr.20070223164126.2"><vh>importDir</vh></v>
<v t="ekr.20070223164126.3"><vh>createLastChildOf</vh></v>
</v>
<v t="ekr.20070517070854"><vh>run script in nullGui</vh></v>
<v t="ekr.20070517071510"><vh>run script with leoBridge</vh></v>
<v t="ekr.20080206055658"><vh>Script to print font settings</vh></v>
<v t="ekr.20090428081009.1"><vh>patching auto-completion table</vh></v>
</v>
</v>
<v t="ekr.20071025193940" annotate="7d71002855087072696f7269747971015504393939397102550870726f67726573737103550071045509617263686574797065710568045502666771066804752e"></v>
<v t="ekr.20070517160058.1"><vh>Prototypes</vh>
<v t="ekr.20070929062147"><vh>Prototype of networkx graph tools</vh>
<v t="ekr.20070929122956"><vh>Data trees</vh>
<v t="ekr.20070929114617"><vh>@graph-target</vh></v>
<v t="ekr.20070929072043"><vh>@networkx</vh>
<v t="ekr.20070929072506.1"><vh>@nodes</vh></v>
<v t="ekr.20070929072506"><vh>@edges</vh></v>
</v>
<v t="ekr.20070929070257"><vh>@graph</vh>
<v t="ekr.20070929070257.1"><vh>@node child1</vh>
<v t="ekr.20070929070632"><vh>@link ('ekr', '20070929070257', 2): @node child2</vh></v>
</v>
<v t="ekr.20070929070257.2"><vh>@node child2</vh>
<v t="ekr.20070929070632.1"><vh>@link ('ekr', '20070929070257', 1): @node child1</vh></v>
</v>
</v>
<v t="ekr.20070928095102"><vh>root-node</vh>
<v t="ekr.20070928095102.1"><vh>child1</vh></v>
<v t="ekr.20070928095102.2"><vh>child2</vh></v>
</v>
</v>
<v t="ekr.20070929122956.1"><vh>buttons</vh>
<v t="ekr.20070929070426"><vh>@@button print link</vh></v>
<v t="ekr.20070927175908"><vh>@@button leo2graph</vh></v>
<v t="ekr.20070929062147.1"><vh>@@button at-graph2graph</vh></v>
<v t="ekr.20070929062147.2"><vh>@@button at-networkx2graph</vh>
<v t="ekr.20070929081505"><vh>error</vh></v>
<v t="ekr.20070929074830"><vh>parse</vh></v>
<v t="ekr.20070929072506.2"><vh>parseNodes</vh></v>
<v t="ekr.20070929074830.1"><vh>parseEdges</vh></v>
</v>
<v t="ekr.20070929082546"><vh>@@button at-networkx2at-graph</vh>
<v t="ekr.20070929120541"><vh>createEdges</vh></v>
<v t="ekr.20070929120541.1"><vh>createNodes</vh></v>
<v t="ekr.20070929115302"><vh>createTree</vh></v>
<v t="ekr.20070929114410.2"><vh>error</vh></v>
<v t="ekr.20070929114410.3"><vh>parse</vh></v>
<v t="ekr.20070929114410.5"><vh>parseEdges</vh></v>
<v t="ekr.20070929114410.4"><vh>parseNodes</vh></v>
</v>
</v>
</v>
<v t="ekr.20070630142904"><vh>Prototype of pyrex</vh>
<v t="ekr.20070630142904.2"><vh>gcc build docs</vh></v>
<v t="ekr.20070630142904.3"><vh>pyrexc command-line options</vh></v>
<v t="ekr.20070630142904.4"><vh>@@file myModule.pyx</vh></v>
<v t="ekr.20070630142904.5"><vh>Make myModule.c</vh></v>
</v>
<v t="ekr.20071026102420.2"><vh>Screen capture with Wink</vh>
<v t="ekr.20070528111805"><vh>FrontWindowCapture.pyw</vh></v>
<v t="ekr.20070609085533"><vh>@@url c:\prog\wink\ChangeViewMenu.htm</vh></v>
</v>
<v t="ekr.20080503202744.3"><vh>Rope</vh></v>
<v t="ekr.20080531131542.1"><vh>mxTextTools proto</vh>
<v t="ekr.20080531141227.1"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
<v t="ekr.20080531131542.2"><vh>&lt;&lt; define scan4 tables &gt;&gt;</vh></v>
<v t="ekr.20080531131542.4"><vh>printItem</vh></v>
</v>
<v t="ekr.20080806145258.12"><vh>Prototype of Leo in Ajax</vh>
<v t="ekr.20080806145258.13"><vh>To do</vh></v>
<v t="ekr.20080806145258.14"><vh>@@button Leo2DHTML</vh>
<v t="ekr.20080806145258.15"><vh>&lt;&lt; about LeoToHTML &gt;&gt;</vh></v>
<v t="ekr.20080806145258.16"><vh>&lt;&lt; define dhtml stuff &gt;&gt;</vh></v>
<v t="ekr.20080806145258.17"><vh>escape</vh></v>
<v t="ekr.20080806145258.18"><vh>writeAll</vh></v>
<v t="ekr.20080806145258.19"><vh>writeBody</vh></v>
<v t="ekr.20080806145258.20"><vh>writeHead</vh></v>
<v t="ekr.20080806145258.21"><vh>writeContents</vh></v>
<v t="ekr.20080806145258.22"><vh>writePreamble</vh></v>
<v t="ekr.20080806145258.23"><vh>writePostamble</vh></v>
</v>
<v t="ekr.20080806145258.24"><vh>@@file server.py</vh></v>
<v t="ekr.20080806145258.25"><vh>@@file hello.html</vh></v>
<v t="ekr.20080806145258.26"><vh>@@file cgi-bin/edward.py</vh>
<v t="ekr.20080806145702.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20080806145258.27"><vh>&lt;&lt; define dhtml stuff &gt;&gt;</vh></v>
<v t="ekr.20080806145258.28"><vh>escape</vh></v>
<v t="ekr.20080806145258.29"><vh>print_all</vh></v>
<v t="ekr.20080806145258.30"><vh>print_body</vh></v>
<v t="ekr.20080806145258.31"><vh>print_head</vh></v>
<v t="ekr.20080806145258.32"><vh>print_leo_dot_js</vh></v>
<v t="ekr.20080806145258.33"><vh>print_tree</vh></v>
</v>
<v t="ekr.20080806145258.1"><vh>@@thin cgi-bin/leo.js</vh>
<v t="ekr.20080806145258.2"><vh>getElementbyClass</vh></v>
<v t="ekr.20080806145258.3"><vh>contractcontent</vh></v>
<v t="ekr.20080806145258.4"><vh>expandcontent</vh></v>
<v t="ekr.20080806145258.5"><vh>revivecontent</vh></v>
<v t="ekr.20080806145258.6"><vh>get_cookie</vh></v>
<v t="ekr.20080806145258.7"><vh>getselectedItem</vh></v>
<v t="ekr.20080806145258.8"><vh>saveswitchstate</vh></v>
<v t="ekr.20080806145258.9"><vh>do_onload</vh></v>
<v t="ekr.20080806145258.10"><vh>format</vh></v>
<v t="ekr.20080806145258.11"><vh>formatText</vh></v>
</v>
<v t="ekr.20080806145258.34"><vh>@@thin jqueryTest.html</vh></v>
</v>
<v t="ekr.20080811113441.2"><vh>Running body text as a windows script</vh>
<v t="ekr.20080807115344.1"><vh>Windows script</vh></v>
<v t="ekr.20080807114145.2"><vh>@@button run-windows-script</vh>
<v t="ekr.20080807115344.5"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20080807115344.2"><vh>class MySite</vh></v>
<v t="ekr.20080807115344.3"><vh>class Application</vh></v>
<v t="ekr.20080807115344.4"><vh>RunCode</vh></v>
</v>
</v>
<v t="ekr.20090507082535.1906"><vh>Get my email</vh></v>
</v>
<v t="ekr.20071105085941"><vh>Tests</vh>
<v t="ekr.20090309064612.1"><vh> Future features/bug fixes (do not delete)</vh>
<v t="ekr.20081216091605.2"><vh>@@auto under_indent.py</vh>
<v t="ekr.20090122211549.1"><vh>class test</vh>
<v t="ekr.20090122211549.2"><vh>spam</vh></v>
</v>
</v>
<v t="ekr.20080924081821.1"><vh>test of autoCompleter.getExternalCompletions</vh></v>
<v t="ekr.20080610144233.1"><vh>Wrap test</vh></v>
</v>
<v t="ekr.20090309064612.2"><vh>Example scripts</vh>
<v t="ekr.20080701130406.1"><vh>Run pylint on plugins</vh></v>
<v t="ekr.20080617170334.1"><vh>Determining key values</vh></v>
<v t="ekr.20080920101658.1"><vh>getInput</vh></v>
<v t="ekr.20080917063615.1"><vh>getSettingSource</vh></v>
<v t="ekr.20081205104320.1"><vh>run bash script</vh></v>
</v>
<v t="ekr.20080930114036.1"><vh>Icon stuff</vh>
<v t="ekr.20080930080501.1"><vh>Add icon row</vh></v>
<v t="ekr.20080930083052.1"><vh>hide icon rows</vh></v>
<v t="ekr.20080930083052.2"><vh>show icon rows</vh></v>
<v t="ekr.20080930085514.1"><vh>clear icon bar</vh></v>
</v>
<v t="ekr.20090309065826.1"><vh>Print stats</vh>
<v t="ekr.20090205070715.1"><vh>print colorer stats</vh></v>
</v>
<v t="ekr.20080813080809.1"><vh>Tests for @shadow</vh>
<v t="ekr.20080807091001.1"><vh>@@shadow python-import-test.py</vh>
<v t="ekr.20080807091201.7"><vh>python-import-test declarations</vh></v>
<v t="ekr.20080807091201.8"><vh>class Person</vh>
<v t="ekr.20080807091201.9"><vh>talk</vh></v>
<v t="ekr.20080807091201.10"><vh>class Meta</vh></v>
</v>
</v>
<v t="ekr.20080812112440.1"><vh>@@shadow at-shadow-test.ini</vh></v>
<v t="ekr.20080812135254.1"><vh>@@shadow at-unknown-shadow-test.xyzzy</vh></v>
<v t="ekr.20080801160915.1"><vh>@@shadow TerryBrownTest.py</vh>
<v t="ekr.20080803120643.1"><vh>spam</vh></v>
</v>
<v t="ekr.20080812102914.1"><vh>@@nosent at-nosent-test.py</vh>
<v t="ekr.20080812102914.2"><vh>child</vh></v>
</v>
<v t="ekr.20080813080627.1"><vh>@@shadow at-shadow-attributes-test.py</vh>
<v t="ekr.20080813080627.2"><vh>spam</vh>
<v t="ekr.20080813080729.1"><vh>child</vh></v>
</v>
<v t="ekr.20080813080627.3"><vh>eggs</vh></v>
</v>
<v t="ekr.20080819095720.1"><vh>@@shadow huh_extension_test.huh</vh></v>
<v t="ekr.20080909075224.1"><vh>@@shadow ekr-shadow-test.html</vh></v>
<v t="ekr.20080911080311.1"><vh>@@shadow dummy.conf</vh></v>
<v t="ekr.20080924033317.1"><vh>@@shadow weird-extension.C</vh>
<v t="ekr.20080924033317.2"><vh>spam</vh></v>
</v>
<v t="ekr.20081001110047.1"><vh>@@shadow mark-changed-nodes-test.py</vh>
<v t="ekr.20081001110047.2"><vh>spam</vh></v>
<v t="ekr.20081001110047.3"><vh>eggs</vh></v>
</v>
</v>
<v t="ekr.20081003094737.1"><vh>Unicode tests</vh>
<v t="ekr.20080701101740.1"><vh>locale tests</vh></v>
<v t="ekr.20080821111715.1"><vh>Standard print test (only works for Latin-1 and ascii)</vh></v>
</v>
<v t="ekr.20090507082111.1904"><vh>test creation of gnx's</vh></v>
<v t="ekr.20090430080001.1"><vh>@path c:\prog\test</vh>
<v t="ekr.20090430080001.2"><vh>@rst test.html</vh>
<v t="ekr.20090430124352.10"><vh>@rst-code</vh>
<v t="ekr.20090430124352.9" a="E"><vh>&lt;&lt; section a &gt;&gt;</vh>
<v t="ekr.20090430124352.11"><vh>&lt;&lt; section c &gt;&gt;</vh></v>
</v>
<v t="ekr.20090430124352.5"><vh>&lt;&lt; section b&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20090309064612.3"><vh>Tests of new features</vh>
<v t="ekr.20090309064612.4"><vh>Decorator tests</vh>
<v t="ekr.20080628094340.1"><vh>Decorator test</vh></v>
<v t="edward.20081221145716.1"><vh>decorator test 2</vh></v>
</v>
<v t="ekr.20090201162523.1"><vh>Macro test</vh>
<v t="ekr.20090201192257.1"><vh>@@test macro ab</vh></v>
</v>
<v t="ekr.20090128131130.1"><vh>posList tests</vh></v>
<v t="ekr.20090128112453.1" key="550378797a71002e"><vh>Property tests</vh></v>
<v t="ekr.20080922164656.1"><vh>Tests of path expressions</vh>
<v t="ekr.20080921144924.1"><vh>Tests of g.os_path_finalize</vh></v>
<v t="ekr.20080922142953.1"><vh>test os_pathExpression</vh></v>
<v t="ekr.20080922164255.1"></v>
<v t="ekr.20080922164255.2"><vh>@@shadow {{c.config.getString('test')}}/eval-shadow-test.txt</vh></v>
<v t="ekr.20080923073240.2"><vh>@path {{c.config.getString('test')}}</vh>
<v t="ekr.20080923073240.1"><vh>@@thin eval-thin-test.txt</vh></v>
</v>
</v>
<v t="ekr.20080531080812.1"><vh>tracer tests</vh></v>
</v>
</v>
<v t="ekr.20090514103332.1929"><vh>Unit tests</vh>
<v t="ekr.20090514073218.1923"><vh>@button run test.leo tests @key = alt-7</vh></v>
<v t="ekr.20090218112656.1"><vh>@test self.assertEqual</vh></v>
<v t="ekr.20090514101216.1927"><vh>@test self.assertNotEqual</vh></v>
</v>
<v t="ekr.20090521070342.1907"><vh>@button show-rst</vh></v>
<v t="ekr.20090521070342.1908"><vh>Sample rst</vh></v>
<v t="ekr.20090521100748.1911" rst-import="7d710028550b756e6465726c696e65733271015501237102550b756e6465726c696e657331710355022d3d7104752e"><vh>@@auto-rst c:\prog\test\readme-new.rst</vh>
<v t="ekr.20090521114145.1913"><vh>Staging</vh>
<v t="ekr.20090521114145.1914"><vh>Installing PIL</vh></v>
<v t="ekr.20090521114145.1915"><vh>screen-profiles</vh></v>
<v t="ekr.20090521114145.1916"><vh>Useful bits</vh></v>
<v t="ekr.20090521114145.1917"><vh>The top family</vh></v>
<v t="ekr.20090521114145.1918"><vh>super syntax</vh></v>
<v t="ekr.20090521114145.1919"><vh>Redirecting stdout and stderr in bash</vh></v>
<v t="ekr.20090521114145.1920"><vh>Write a tool to explain Python's import syntax</vh>
<v t="ekr.20090521114145.1921"><vh>BackupPc</vh></v>
<v t="ekr.20090521114145.1922"><vh>Python function signatures</vh></v>
<v t="ekr.20090521114145.1923"><vh>BackupPC errors</vh></v>
<v t="ekr.20090521114145.1924"><vh>How to look at the set of files containg this string</vh></v>
<v t="ekr.20090521114145.1925"><vh>VNC</vh></v>
<v t="ekr.20090521114145.1926"><vh>Pydoctor</vh></v>
<v t="ekr.20090521114145.1927"><vh>Linux Audio</vh></v>
<v t="ekr.20090521114145.1928"><vh>Fivews</vh></v>
<v t="ekr.20090521114145.1929"><vh>Accumulative doctests in Leo</vh></v>
<v t="ekr.20090521114145.1930"><vh>IPCop backup script</vh></v>
<v t="ekr.20090521114145.1931"><vh>Partition UUIDs</vh></v>
<v t="ekr.20090521114145.1932"><vh>Patch to ImportError</vh></v>
<v t="ekr.20090521114145.1933"><vh>Normalizing a string for use as a URL</vh></v>
<v t="ekr.20090521114145.1934"><vh>Deleting all LeoShadow directories</vh></v>
<v t="ekr.20090521114145.1935"><vh>Database of options</vh></v>
<v t="ekr.20090521114145.1936"><vh>mkdir -p</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="edward.20081127113749.2">wordsep = u'., -+\n\r[]{}&lt;&gt;=-+*&amp;%$#@!"\'?/\\|^()~`:;'
word_completer_key = 'back_word_completer'
@others
completer = g.app.config.get(c,word_completer_key,'WordCompleter')
if completer is None:
    completer = WordCompleter(p,c,back=True)
    g.app.config.set(c,word_completer_key,'WordCompleter',completer)
    completer.run()
else:
    completer.adjust(p, c.frame.body.getInsertPoint())
    completer.complete_word()
</t>
<t tx="edward.20081127113749.3">class WordCompleter:
    def __init__(self, p, c, back=True):
        self.p = p.copy()
        self.c = c
        self.back = back
        self.pos = -1
    @others
</t>
<t tx="edward.20081127113749.4">def complete_word(self):
    txt = self.chunk
    word = self.word
    try:
        if self.back:
            &lt;&lt;backward search&gt;&gt;
        else:
            &lt;&lt;forward search&gt;&gt;
        &lt;&lt;clean up and exit&gt;&gt;
    except:
        self.exit()
        g.es_exception()</t>
<t tx="edward.20081127113749.5">p = self.search_pos
start = -1
counter = 0
while p:
    &lt;&lt;counter check&gt;&gt;
    i = txt.rfind(word, 0, start)
    if i == -1:
        p.moveToThreadBack()
        if p:self.chunk = txt = p.bodyString()
        start = -1
    else:
        if self.acceptable_word(i, txt, word):
            self.chunk = txt[:i+len(word)-1]
            return
        start = i+len(word)-1</t>
<t tx="edward.20081127113749.6">counter+=1
if counter &gt; 10000:
    g.es_trace("counter max")
    break</t>
<t tx="edward.20081127113749.7">p = self.search_pos
start = 0
counter = 0
while p:
    &lt;&lt;counter check&gt;&gt;
    i = txt.find(word, start)
    if i == -1:
        p.moveToThreadNext()
        if p:self.chunk = txt = p.bodyString()
        start = 0
    else:
        if self.acceptable_word(i, txt, word):
            self.chunk = txt[i+1:]
            return
        start = i+1</t>
<t tx="edward.20081127113749.8">if len(self.tried) &gt; 1:
    # there was some tries so we need to restore
    self.c.setBodyString(self.p, self.before+self.word+self.after)
    self.c.frame.body.setInsertPoint(self.pos)
return self.exit()</t>
<t tx="edward.20081127113749.9">@ if found word for the first time then try it
@c
def acceptable_word(self, i, txt, word):
    if i == 0 or wordsep.find(txt[i-1]) != -1:
        j = i+len(word)
        while j &lt; len(txt) and wordsep.find(txt[j]) &lt; 0:
            j += 1
        nword = txt[i:j]
        if nword not in self.tried:
            self.tried[nword] = 1
            u = self.c.undoer
            bunch = u.createCommonBunch(p)
            bunch.oldBody = p.bodyString()
            bunch.insertPos = self.pos
            # Set the type &amp; helpers.
            bunch.kind = 'node'
            bunch.undoType = 'complete word'
            bunch.undoHelper = self.undo_replacement
            bunch.redoHelper = self.redo_replacement
            bunch.newBody = newBody = self.before+nword+self.after

            self.c.setBodyString(self.p, newBody)
            self.c.frame.body.setInsertPoint(self.pos)

            bunch.dirtyVnodeList = [p.v]
            bunch.newChanged = u.c.isChanged()
            bunch.newDirty = p.isDirty()
            bunch.newMarked = p.isMarked()

            u.pushBead(bunch)

            return True
    return False
</t>
<t tx="edward.20081127113749.10">def undo_replacement(self):
    u = self.c.undoer; c=self.c; p=u.p
    bunch = u.getBead(u.bead)
    c.setBodyString(p, bunch.oldBody)
    c.frame.body.setInsertPoint(bunch.insertPos)</t>
<t tx="edward.20081127113749.11">def redo_replacement(self):
    c = self.c; u=c.undoer; bunch=u.getBead(u.bead+1)
    c.setBodyString(bunch.p, bunch.newBody)
    c.frame.body.setInsertPoint(bunch.insertPos)</t>
<t tx="edward.20081127113749.12">def exit(self):
    #g.app.config.set(c,word_completer_key,'WordCompleter',None)
    #g.app.config.set(c,'next_word_completer','WordCompleter',None)
    self.pos = -1</t>
<t tx="edward.20081127113749.13">def run(self):
    self.adjust(self.p, c.frame.body.getInsertPoint())
    self.complete_word()
</t>
<t tx="edward.20081127113749.14">def adjust(self, p, pos):
    if p != self.p or pos != self.pos:
        self.p = p.copy()
        self.pos = pos
        bs = p.bodyString()
        word = getCurrentWord(bs, pos)
        self.word = word
        self.before = bs[:pos-len(word)]
        self.after = bs[pos:]
        self.search_pos = p.copy()
        if self.back:
            self.chunk = self.before
        else:
            self.chunk = self.after
        self.tried = {word:1}</t>
<t tx="edward.20081127113749.15">def getCurrentWord(s, pos):
    i = pos-1
    while i&gt;=0 and wordsep.find(s[i]) &lt; 0:
         i -= 1
    return s[i+1:pos]</t>
<t tx="edward.20081127113749.16">wordsep = u'., -+\n\r[]{}&lt;&gt;=-+*&amp;%$#@!"\'?/\\|^()~`:;'
word_completer_key = 'next_word_completer'
@others
completer = g.app.config.get(c,word_completer_key,'WordCompleter')
if completer is None:
    completer = WordCompleter(p, c, back=False)
    g.app.config.set(c, word_completer_key, 'WordCompleter', completer)
    completer.run()
else:
    completer.adjust(p, c.frame.body.getInsertPoint())
    completer.complete_word()

</t>
<t tx="edward.20081221145716.1">def debug(f,*args,**keys):
    if 1:
        def debugCallback(*args,**keys):
            print f.__name__,args,keys
            f(*args,**keys)
            print 'after',f.__name__
        return debugCallback
    else:
        print 'in debug'
        return f
@debug
def spam(a=5):
    g.trace(a,g.callers(4))

spam(3)
spam(a=4)
</t>
<t tx="ekr.20041001211817">import os

g.pr(os.path.exists(os.path.normpath("C:\\Progra~1\\Eclipse")))</t>
<t tx="ekr.20060427103457"># Open leoSettings.leo
c.openLeoSettings()</t>
<t tx="ekr.20060809084033">'''A script to convert calls to g.es to g.et, and raw strings s to g._(s)'''

__version__ = 0.2
&lt;&lt; version history &gt;&gt;

@others

trace = False # For debugging.
doReplace = True # True: actually replace the body text.

if not doReplace: g.es_print('-' * 40)
c.beginUpdate()
try:
    u = c.undoer
    undoType = 'Convert g.es'
    u.beforeChangeGroup (p,undoType)
    for p in c.currentPosition().self_and_subtree_iter():
        replace(p)
    u.afterChangeGroup(p,undoType,reportFlag=True)
finally:
    c.endUpdate()</t>
<t tx="ekr.20060809090508"># Based on leoImport.scanPythonText.
def replace(p):
    '''Replace g.es by g.et and strings s by g._(s)'''
    s = p.bodyString()
    if not s.strip(): return
    result = [] ;  i = 0 ; count = 0
    while i &lt; len(s):
        progress = j = i
        ch = s[i]
        if ch == '\n' or ch == '\r':
            i = g.skip_nl(s,i)
            result.append(s[j:i])
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
            result.append(s[j:i])
        elif ch == '"' or ch == "'":
            &lt;&lt; handle string &gt;&gt;
        elif g.is_c_id(ch):
            if g.match_word(s,i,'g.es'):
                &lt;&lt; handle g.es &gt;&gt;
            else:
                i = g.skip_c_id(s,i)
                result.append(s[j:i])
        else:
            i += 1
            result.append(s[j:i])
        assert(progress &lt; i)
    if count:
        result = ''.join(result)
        if doReplace:
            undoData = u.beforeChangeNodeContents(p)
            p.setBodyStringOrPane(result)
            p.v.t.setDirty()
            u.afterChangeNodeContents(p,'Change Body',undoData)
        else:
            g.trace('result...\n',result)</t>
<t tx="ekr.20060809091749.72">i = g.skip_python_string(s,i)
s2 = s[j:i].strip()
result.append('g._(%s)' % s2)
if trace: g.trace('string:',s2)
count += 1</t>
<t tx="ekr.20060809091749.73">i += 4 ; k1 = i
i = g.skip_ws(s,i)
found = False
if g.match(s,i,'('):
    k2 = i
    k3 = g.skip_parens(s,i)
    if g.match(s,k3,')'):
        # Only translate if there are exactly one string in the parens.
        s2 = s[k2+1:k3]
        if (
            s2 and s2.count(',') == 0 and
            (s2.count('"') == 2 or s2.count("'") == 2)
        ):
            i = k3
            if trace: g.trace('call g.es:',g.get_line(s,i))
            result.append('g.et')
            result.append(s[k1:i])
            count += 1 ; found = True
if not found:
    result.append(s[j:i])</t>
<t tx="ekr.20060809092023"></t>
<t tx="ekr.20060809103738">def test1():
    
    g.es('abc')
    g.es('abc',xyz)
    g.es(xyz)</t>
<t tx="ekr.20060809103738.1">def test2():

    x = 'abc' + 'xyz'
    y = abc</t>
<t tx="ekr.20060809104405">@nocolor
@
0.1 EKR: Initial version.
0.2 EKR: Support doReplace and made script fully undoable.</t>
<t tx="ekr.20060814111542"># Add an editor to the body pane.
c.frame.body.addEditor()</t>
<t tx="ekr.20060904110922"></t>
<t tx="ekr.20060904111037">if hasattr(c,'opmlCommands'):
    c.opmlCommands.readOpmlCommand()
else:
    g.es_print('opml plugin not loaded')</t>
<t tx="ekr.20060904111037.1">if hasattr(c,'opmlCommands'):
    c.opmlCommands.writeOpmlCommand()
else:
    g.es_print('opml plugin not loaded')</t>
<t tx="ekr.20060918083159">put = g.es_print

for p in c.allNodes_iter():

    if hasattr(p.v,"unknownAttributes"):
        put("deleting v.unknownAttributes:",
            p.headString(),
            g.listToString(p.v.unknownAttributes.keys()))
        delattr(p.v,"unknownAttributes")

    if hasattr(p.v.t,"unknownAttributes"):
        put("deleting t.unknownAttributes:",
            p.headString(),
            g.listToString(p.v.t.unknownAttributes.keys()))
        delattr(p.v.t,"unknownAttributes")
           
put('done') 
c.redraw()</t>
<t tx="ekr.20060924180049">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060924180049.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others</t>
<t tx="ekr.20060924180049.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")</t>
<t tx="ekr.20060924180049.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060924180049.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.currentPosition()
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.headString())
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060924180049.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().headString()
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)</t>
<t tx="ekr.20060924180049.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20061030041200">import os, sys

if 1: # Executes Iron Python in the console. (But not from the tutorials directory).
    path = r'c:\prog\IronPython-1.0.1\ipy.exe'
    args = ['-i']
        
    if 1: # Use present environment.
        os.spawnv(os.P_NOWAIT, path, args)
    else: # Use a pristine environment.
        os.spawnve(os.P_NOWAIT, path, args, os.environ)</t>
<t tx="ekr.20061030041356"></t>
<t tx="ekr.20061030041450"></t>
<t tx="ekr.20070115092430"># Invoke winpdb for general scripts **not** containing the predefined g, p or d constants.

# This is essentially the same as using the debug command.

import os,subprocess,sys

# Important: scriptFile2 must be different from scriptFile.
filename = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','scriptFile2'))
f = open(filename,'w') 
f.write(p.bodyString()) 
f.close() 
python = sys.executable
pythonDir = g.os_path_dirname(python) 
#winpdb = g.os_path_join(pythonDir,'Scripts','_winpdb.py') # For older versions of winpdb.
winpdb = g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py') # For version 1.1.2 and newer.
os.chdir(g.app.loadDir)
cmdline = '%s %s -t %s' % (python,winpdb,filename) 
subprocess.Popen(cmdline)
</t>
<t tx="ekr.20070223164126"># An example of running this script:
    
import os

@others

types = (".py",) #,".c",".html",".txt")

dir = r'C:\prog\Notabene'

c.beginUpdate()
try:
    importFiles(dir,types,recursive=True)
finally:
    c.endUpdate()

g.es("done",color="blue")
</t>
<t tx="ekr.20070223164126.1">def importFiles (dir,type=None,kind="@file",recursive=False):
    
    v = c.currentVnode()

    # Check the params.
    if kind != "@file" and kind != "@root":
        g.es("kind must be @file or @root: " + kind)
        return

    if not g.os_path_exists(dir):
        g.es("directory does not exist: " + dir)
        return
    
    c.beginUpdate()
    try:
        root = createLastChildOf(v,"imported files")
        try:
            importDir (dir,type,kind,recursive,root)
            root.contract()
        except:
            g.es_exception()
    finally:
        c.endUpdate()</t>
<t tx="ekr.20070223164126.2">def importDir (dir,types,kind,recursive,root):

    g.es("dir: " + dir,color="blue")
    
    try:
        files = os.listdir(dir)
        files2 = [] ; dirs =[]
        for f in files:
            path = g.os_path_join(dir,f)
            if g.os_path_isfile(path):
                name, ext = g.os_path_splitext(f)
                if not types or ext in types:
                    files2.append(path)
            elif recursive:
                dirs.append(path)
        if len(files2) &gt; 0 or len(dirs) &gt; 0:
            child = createLastChildOf(root,dir)
            c.selectVnode(child)
        if len(files2) &gt; 0:
            c.importCommands.importFilesCommand(files2,kind)
        if len(dirs) &gt; 0:
            dirs.sort()
            for dir in dirs:
                importDir(dir,types,kind,recursive,child)
    except:
        g.es("exception in importFiles script")
        g.es_exception()
</t>
<t tx="ekr.20070223164126.3">def createLastChildOf (v,headline):
    
    child = v.insertAsLastChild()
    child.initHeadString(headline)
    return child
</t>
<t tx="ekr.20070224123943"></t>
<t tx="ekr.20070410063214"></t>
<t tx="ekr.20070416075121"></t>
<t tx="ekr.20070503085527"></t>
<t tx="ekr.20070504080933">This option applies to directories specified in filenames in all kinds of @file trees, and to filenames specified in the @path directive.

True:  Leo attempts to create directories if they do not exist.
False: Leo never attempts to create directories.</t>
<t tx="ekr.20070515073111">g.pr('=' * 50)</t>
<t tx="ekr.20070517070854">import leoGui
oldGui = g.app.gui
g.app.gui = leoGui.nullGui(guiName='testGui')
try:
    fileName = g.os_path_abspath(g.os_path_join(
        g.app.loadDir,'..','doc','LeoDocs.leo'))
    ok,frame = g.openWithFileName(fileName,old_c=c)
    if ok:
        c2 = frame.c
        for p in c2.allNodes_iter():
            g.pr('.'*p.level(),p.headString())
        g.app.closeLeoWindow(frame)
finally:
    g.app.gui = oldGui</t>
<t tx="ekr.20070517071510">import leoBridge

path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','doc','LeoDocs.leo'))

if 0: # This can not be run locally: leoBridge.controller starts a Tk event loop.

    controller = leoBridge.controller(gui='nullGui')
    g = controller.globals()
    c = controller.openLeoFile(path)
    n = 0
    for p in c.allNodes_iter():
        n += 1
    g.pr('%d nodes in %s' % (n,path))
    # g.app.closeLeoWindow(c.frame)</t>
<t tx="ekr.20070517160058.1"></t>
<t tx="ekr.20070528111805"># FrontWindowCapture.pyw
# Version 0.1
# Date    20070526
# Author  Roger Erens (roger AT erens-krekels.net)
"""
        Purpose:
        Capture the image of the front-most window into a fixed-name
        (_front_window), max-size (default MAX_WIDTH is 640 pixels), and
        fixed-format (PNG) file that can easily be used when creating
        documentation for an application on a wiki or in some HTML-docs.
        This script does _not_ copy the captured image to the clipboard (handy
        when creating MS Word or OpenOffice documents) since MS Windows already
        has ALT-PRTSCR to do so.

        Dependencies:
        Fairly recent versions of Python, wxPython, and PIL should be installed

        Start:
        Double click FrontWindowCapture.pyw; an icon appears in the Task Bar (lower right of
        the screen).

        Use:
        Bring a window to the front and then left-click on the
        icon in the Task Bar. A file named '_front_window.png' will be saved
        in the current directory.
        A pictures wider than MAXWIDTH is scaled down in order to make it easily
        used in wikis or HTML-documentation.
        Usually, human intelligence is needed to rename that file; this is also
        why this script does not copy the image to the clipboard.

        End:
        Close the application by right-clicking the icon in the Task Bar.

        Note:
        Make sure that your system is fast enough to find the frontmost
        window. That is, when a virusscanner is running or virtual memory is
        low, this script will choke. You can see what happens by enabling the
        print statements and running this script from a console (change the
        extension from .pyw to .py).
"""
import wx
import sys
import win32ui
import win32gui
import win32con
import time
from PIL import Image, ImageGrab

Image.init()

MAX_WIDTH = 640
BLINK_STATE = 0

class TaskBarApp(wx.Frame):
    def __init__(self, parent, id, title):
        wx.Frame.__init__(self, parent, -1, title, size = (1, 1),
            style=wx.FRAME_NO_TASKBAR| wx.NO_FULL_REPAINT_ON_RESIZE)
        self.tbicon = wx.TaskBarIcon()
        icon = wx.Icon('LeoApp16.ico', wx.BITMAP_TYPE_ICO)
        self.tbicon.SetIcon(icon, 'Click to capture the foremost window')
        self.tbicon.Bind(wx.EVT_TASKBAR_LEFT_UP, self.OnTaskBarLeftClick)
        self.tbicon.Bind(wx.EVT_TASKBAR_RIGHT_UP, self.OnTaskBarRightClick)
        self.Show(True)

    def OnTaskBarLeftClick(self, evt):

        self.FlashIcon(evt)

        def _MyCallback(hwnd, extra ):
            extra.append(hwnd)

        windows = []
        win32gui.EnumWindows(_MyCallback, windows)

        winList = []
        for i in windows:
            if win32gui.IsWindowVisible(i):
                winList.append(i)
                #g.pr(i)

        win32gui.SetForegroundWindow(winList[1])    # found by trial and error
                                                    # that I need the second
                                                    # window from the list
        time.sleep(0.1)  # give the previous command some time to finish

        fgwindow = win32ui.GetForegroundWindow()
        #g.pr("(C)lick!")

        bbox = fgwindow.GetWindowRect()
        img = ImageGrab.grab( bbox)
        width = bbox[2] - bbox[0]
        if width &gt; MAX_WIDTH:
            coeff = MAX_WIDTH * 1. / width
            height = bbox[3] - bbox[1]
            newHeight = int( coeff * height)
            #g.pr(width, height, "scaled down to", MAX_WIDTH, newHeight)
            img = img.resize((MAX_WIDTH,newHeight), Image.ANTIALIAS)
        img = img.convert("P", dither=Image.NONE,
                              palette=Image.ADAPTIVE, colors=256)
        img.save("_front_window.png", "PNG", optimize=1)
        #img.show() # show the image in an image viewer

        self.FlashIcon(evt)

    def OnTaskBarRightClick(self, evt):
        #g.pr("Auta..." # that's about it...)
        self.tbicon.Destroy()
        self.Close(True)
        wx.GetApp().ProcessIdle()

    def FlashIcon(self, evt):
        global BLINK_STATE
        if BLINK_STATE == 0:
            icon = wx.Icon('LeoApp16lick.ico', wx.BITMAP_TYPE_ICO)
            self.tbicon.SetIcon(icon, 'Window is being captured...')
            BLINK_STATE = 1
            return
        else:
            icon = wx.Icon('LeoApp16.ico', wx.BITMAP_TYPE_ICO)
            self.tbicon.SetIcon(icon, 'Click to capture the foremost window')
            BLINK_STATE = 0
            return

class MyApp(wx.App):
    def OnInit(self):
        frame = TaskBarApp(None, -1, ' ')
        frame.Center(wx.BOTH)
        frame.Show(False)
        return True

def main():
    app = MyApp(0)
    app.MainLoop()

if __name__ == '__main__':
    main()

""" CREDITS

    Thanks to
    Roger Upole:
    http://groups.google.com/group/comp.lang.python/
    browse_thread/thread/ff39ec79f7c3248a/
    e600c892772bf52a?lnk=gst&amp;q=screen+capture&amp;rnum=6#e600c892772bf52a
    for his time.sleep() Aha (This took me a year and a half to note!)

    Christian Wyglendowski, Werner Bruhin, and Xavier Morel for the
    http://wiki.wxpython.org/index.cgi/FlashingTaskbarIcon
    discussion

    'Rob aspn at msolutionsinc.com '
    http://mail.python.org/pipermail/python-win32/2003-June/001129.html
    for his suggestion to find out the foremost window

    and of course the usual suspects that created/maintain
    wxPython,
    PIL,
    pywin32,
    LEO,
    gvim,
    and Python itself.
"""</t>
<t tx="ekr.20070529172620"></t>
<t tx="ekr.20070529173219"></t>
<t tx="ekr.20070529173219.1"></t>
<t tx="ekr.20070530072113">c.chapterController.hideChapters()</t>
<t tx="ekr.20070530072113.1">c.chapterController.showChapters()</t>
<t tx="ekr.20070531102813"></t>
<t tx="ekr.20070531103315">c.abbrevCommands.dynamicExpansion(event=None)</t>
<t tx="ekr.20070531104646">c.abbrevCommands.dynamicCompletion()</t>
<t tx="ekr.20070603175054">cc = c.chapterController
cc.selectChapterByName('abc')</t>
<t tx="ekr.20070603175054.1">cc = c.chapterController
cc.selectChapterByName('main')</t>
<t tx="ekr.20070603190713">cc = c.chapterController
cc.createChapterByName('xyz')</t>
<t tx="ekr.20070603190713.1">cc = c.chapterController
cc.selectChapterByName('xyz')</t>
<t tx="ekr.20070603190944"></t>
<t tx="ekr.20070603190944.1"></t>
<t tx="ekr.20070604095313"></t>
<t tx="ekr.20070604100125"></t>
<t tx="ekr.20070609085533"></t>
<t tx="ekr.20070630142904"></t>
<t tx="ekr.20070630142904.2">@nocolor

To build your module using GCC is a three step process on Unix:

1. Use Pyrex to translate mymodule.pyx to mymodule.c::

    python pyrexc mymodule.pyx

mymodule.pyx is the name of the Pyrex module you are writing.

2. Compile mymodule.c to mymodule.o::

    gcc -c -fPIC -I/usr/include/python2.2/ mymodule.c

-c  Produces a .o file instead of an executable. 
-fPIC Produces position independent code, so we can dynamically link against it later. 
-I/usr/include/python2.2/ is the location of the Python 2.2 include file.
 The location of your Python include file may differ from /usr/include/python2.2/. 

3 Link the mymodule.o into a mymodule.so::
    
    gcc -shared mymodule.o -lxosd -o mymodule.so

-shared produces a shared-object file, instead of an executable. 
-lxosd links against a C-library, with the name of the library given as the argument. 
</t>
<t tx="ekr.20070630142904.3">@nocolor

The pyrexc command supports the following options:

  Short Long              Argument    Description
  ----- ----              --------    -----------
  -v    --version                     Display version number of pyrex compiler
  -l    --create-listing              Write error messages to a .lis file
  -I    --include-dir     &lt;directory&gt; Search for include files in named 
                                      directory (may be repeated)
  -o    --output-file     &lt;filename&gt;  Specify name of generated C file (only
                                      one source file allowed if this is used)

Anything else is taken as the name of a Pyrex source file and compiled
to a C source file. Multiple Pyrex source files can be specified
(unless -o is used), in which case each source file is treated as the
source of a distinct extension module and compiled separately to
produce its own C file.
</t>
<t tx="ekr.20070630142904.4">def spam(int i, char *s):
    if 1:
        g.pr(i,s)</t>
<t tx="ekr.20070630142904.5"># Use pyrexc to create myModule.c from myModule.pyx.

import os,sys
python = sys.executable
theFile = r'C:\prog\tigris-cvs\leo\test\myModule.pyx'
pyrexc = r'c:\prog\Pyrex-0.9.6.4\pyrexc.py'
os.system(r'%s %s %s' % (python,pyrexc,theFile))

# Use pyrex/Demos/setup.py to create module on Linux.</t>
<t tx="ekr.20070723091227">
        
        
        </t>
<t tx="ekr.20070723091227.1"></t>
<t tx="ekr.20070723091227.2"></t>
<t tx="ekr.20070723091227.3"></t>
<t tx="ekr.20070927175908">'''Convert a normal Leo tree to a networkx graph'''
import networkx as nx
import sys

x = nx.Graph()

def node_id(p):
    return '%s: %s' % (id(p.v.t),p.headString())

def addTree(p):
    x.add_node(node_id(p))
    for child in p.children_iter():
        addTree(child)
        x.add_edge(node_id(p),node_id(child))

addTree(p)

g.pr('nodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('edges...\n', g.listToString(x.edges(),sort=True))
g.pr('yaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')
</t>
<t tx="ekr.20070928095102">@ This is a plain Leo tree.

You can convert it to a networkx graph using the leo2graph button.
</t>
<t tx="ekr.20070928095102.1"></t>
<t tx="ekr.20070928095102.2"></t>
<t tx="ekr.20070929062147">@nocolor

The following scripts convert between Leo trees and NetworkX graphs.

- leo2graph:            convert a normal Leo tree to a NetworkX graph.
- at-graph2graph:       convert an @graph tree to a Networkx graph.
- at-networkx2graph:    convert an @networkx tree to a Networkx graph
- at-networkx2at-graph: create an @graph tree from an @networkx tree.

Not ready yet:

- tree2pict: convert a Leo @graph tree to a picture of the corresponding graph.

@color</t>
<t tx="ekr.20070929062147.1">'''Convert an @graph tree to a networkx graph.'''
import networkx as nx
import sys

x = nx.Graph()

def node_id(p):
    return '%s: %s' % (str(p.v.t.fileIndex),p.headString())

def addTree(p):
    tag = '@link'
    h = p.headString()
    if h.startswith('@graph'):
        for child in p.children_iter():
            addTree(child)
    elif h.startswith('@node'):
        x.add_node(node_id(p))
        for child in p.children_iter():
            h = child.headString()
            if h.startswith(tag):
                link = h[len(tag):].strip()
                if link: x.add_edge(node_id(p),link)
            elif child.headString().startswith('@node'):
                addTree(child)
                x.add_edge(node_id(p),node_id(child))

addTree(p)

g.pr('nodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('edges...\n', g.listToString(x.edges(),sort=True))
g.pr('yaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')</t>
<t tx="ekr.20070929062147.2">'''Convert an @networkx node to a networkx graph.'''
import networkx as nx
import sys

@others

x = nx.Graph()

edges,nodes = parse(p)

for z in nodes:
    x.add_node(z)

for z in edges:
    a,b = z
    x.add_edge(a,b)

g.pr('\nnodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('\nedges...\n', g.listToString(x.edges(),sort=True))
g.pr('\nyaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')
</t>
<t tx="ekr.20070929070257">@ This is an @graph tree.

You can convert it to a networkx graph using the at-graph2graph button.</t>
<t tx="ekr.20070929070257.1"></t>
<t tx="ekr.20070929070257.2"></t>
<t tx="ekr.20070929070426">g.es('@link %s: %s' % (str(p.v.t.fileIndex),p.headString()))</t>
<t tx="ekr.20070929070632"></t>
<t tx="ekr.20070929070632.1"></t>
<t tx="ekr.20070929072043">@ This node defines a networkx graph using nodes and edges.

You can create an @graph tree from this node using the graph2at-graph button.
</t>
<t tx="ekr.20070929072506"># Each edge is represented as two lines.

# child1 --&gt; child2
('ekr', '20070929070257', 1): @node child1
('ekr', '20070929070257', 2): @node child2

# child2 --&gt; child1
('ekr', '20070929070257', 2): @node child2
('ekr', '20070929070257', 1): @node child1

</t>
<t tx="ekr.20070929072506.1"># Each node is on a separate line.

('ekr', '20070929070257', 1): @node child1
('ekr', '20070929070257', 2): @node child2
</t>
<t tx="ekr.20070929072506.2">def parseNodes (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(g.listToString(lines))
    return lines
</t>
<t tx="ekr.20070929074830">def parse (p):

    tag = '@networkx'
    if not p.headString().startswith(tag):
        p = g.findNodeAnywhere(c,tag)
        if not p.headString().startswith(tag):
            error('No %s node in the outline' % tag)
            return [],[]

    nodes = []
    for tag in ('@edges','@nodes'):
        node = g.findNodeInTree(c,p,tag)
        if node:
            nodes.append(node)
        else:
            error('No %s node in @networkx tree' % tag)
            return [],[]
    edgesNode,nodesNode = nodes
    edges = parseEdges(edgesNode)
    nodes = parseNodes(nodesNode)
    return edges,nodes
</t>
<t tx="ekr.20070929074830.1">def parseEdges (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(len(lines),lines)
    if (len(lines) % 2) == 0:
        i = 0 ; edges = []
        while i &lt; len(lines):
            data = lines[i],lines[i+1]
            edges.append(data)
            i += 2
        # g.trace(g.listToString(edges))
        return edges
    else:
        error('edges node must have even number of lines')
        return []

</t>
<t tx="ekr.20070929081505">def error (s):

    g.es_print(s,color='red')
</t>
<t tx="ekr.20070929082546">'''Convert an @networkx node to an @graph tree.
Create the tree as the child of the @graph-target node,
or the current position if no such node.'''

import networkx as nx
import sys

@others

g.pr('=' * 10)

p,edges,nodes = parse(p)

createTree(p,edges,nodes)
</t>
<t tx="ekr.20070929114410.2">def error (s):

    g.es_print(s,color='red')
</t>
<t tx="ekr.20070929114410.3">def parse (p):

    tag = '@graph-target'
    if not p.headString().startswith(tag):
        p = g.findNodeAnywhere(c,tag)
    if not (p and p.headString().startswith(tag)):
        p = c.currentPosition() # Use the presently selected node.

    nodes = [] ; tag = '@networkx'
    data = g.findNodeAnywhere(c,tag)
    if not data:
        error('No %s tree' % tag)
        return None,[],[]
    for tag in ('@edges','@nodes'):
        node = g.findNodeInTree(c,data,tag)
        if node:
            nodes.append(node)
        else:
            error('No %s node in @networkx tree' % tag)
            return None,[],[]
    edgesNode,nodesNode = nodes
    edges = parseEdges(edgesNode)
    nodes = parseNodes(nodesNode)
    return p,edges,nodes
</t>
<t tx="ekr.20070929114410.4">def parseNodes (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(g.listToString(lines))
    return lines
</t>
<t tx="ekr.20070929114410.5">def parseEdges (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(len(lines),lines)
    if (len(lines) % 2) == 0:
        i = 0 ; edges = []
        while i &lt; len(lines):
            data = lines[i],lines[i+1]
            edges.append(data)
            i += 2
        # g.trace(g.listToString(edges))
        return edges
    else:
        error('edges node must have even number of lines')
        return []

</t>
<t tx="ekr.20070929114617">@ This will be the root node for the @graph tree produced by the at-networkx2at-graph button.</t>
<t tx="ekr.20070929115302">def createTree (parent,edges,nodes):

    if 0:
        g.trace('nodes...\n', g.listToString(nodes,sort=True))
        g.trace('edges...\n', g.listToString(edges,sort=True))

    c.beginUpdate()
    try:
        p = parent.insertAsLastChild()
        p.setHeadString('@graph')
        d = createNodes(p,nodes)
        createEdges(d,edges)
        c.selectPosition(p)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070929120541">def createEdges (d,edges):

    for edge in edges:
        a,b = edge
        g.trace('\n%s --&gt; %s' % (a,b))
        p = d.get(a)
        if p:
            p2 = p.insertAsLastChild()
            p2.setHeadString('@link %s' % (b))
        else:
            error('@node not found: %s' % (a))
</t>
<t tx="ekr.20070929120541.1">def createNodes (parent,nodes):

    d = {}

    for node in nodes:
        # g.trace(node)
        p = parent.insertAsLastChild()
        p.setHeadString('@node %s' % (node))
        d[node] = p.copy()

    return d
</t>
<t tx="ekr.20070929122956"></t>
<t tx="ekr.20070929122956.1"></t>
<t tx="ekr.20071002150320">log = c.frame.log
tag = 'my-canvas'

w = log.canvasDict.get(tag)
if not w:
    w = log.createCanvas(tag)
    w.configure(bg='yellow')

log.selectTab(tag)
</t>
<t tx="ekr.20071006084354">w = c.frame.body.bodyCtrl
s = w.getAllText()
ins = w.getInsertPoint()
row,col = g.convertPythonIndexToRowCol(s,ins)
g.pr('row',row,'col',col)</t>
<t tx="ekr.20071025192258">import leoTest
leoTest.doTests (c,all=False)</t>
<t tx="ekr.20071025193940"># Caution: you will have to disable cursesGui in an external editor
# if you enable the cursesGui plugin here

# Important: if you want to specify a gui plugin here,
# enable that plugin first.

# qtGui.py
# tkGui.py

plugins_menu.py

# leoOPML.py
# graphed.py

# not normally enabled by default.  Recently changed.
# EditAttributes.py
# UASearch.py
# active_path.py
# cleo.py
# datenodes.py
# mod_labels.py
# newButtons.py
# searchbox.py

# This works only with tk.  It is not needed for qt.
# threading_colorizer.py

# open_shell.py
# dtest.py
quicksearch.py
ipython.py
open_with.py
rClick.py
toolbar.py
scrolledmessage.py

# add_directives.py # scan-directives hook not ready.
# color_markup.py # Does not work with threading colorizer.
#### rst3.py
UNL.py

mod_scripting.py
nav_buttons.py
nodenavigator.py
image.py
#### leo_to_html.py
vim.py
#### xemacs.py
</t>
<t tx="ekr.20071026102420.2"></t>
<t tx="ekr.20071026102420.3"></t>
<t tx="ekr.20071105085941"></t>
<t tx="ekr.20071128122043">log = c.frame.log ; tag = 'Shell'
frame1 = log.frameDict.get(tag)
shellKind = 'text' # in ('plain','text','canvas')

if frame1:
    log.selectTab(tag)
elif shellKind == 'plain':
    log.selectTab (tag,createText=False)
    frame = log.frameDict.get(tag)
elif shellKind == 'text':
    log.selectTab (tag,createText=True)
    frame = log.textDict.get(tag)
elif shellKind == 'canvas':
    log.createCanvas(tag)
    log.selectTab(tag)
    frame = log.canvasDict.get(tag)
else:
    frame = None
    g.es('bad shellKind',shellKind)

if frame and not frame1:
    frame.configure(bg='white')
    g.pr('logFrame',log.frameDict.get(tag))
</t>
<t tx="ekr.20071129103842"># A script to create @auto nodes from all .py files in a directory.

import glob,os

reallyCreate = True
baseDir = r'c:\leo.repo\pythoscope\lib2to3\pgen2'
dirs = (r'',)
g.pr('-----')

for theDir in dirs:
    pattern = g.os_path_join(baseDir,theDir,'*.py')
    files = glob.glob(pattern)
    g.pr(pattern)
    # g.pr(g.listToString(files))
    for name in files:
        h = '@auto %s' % (name[len(baseDir) + 1:].strip())
        g.pr('creating',h)
        if reallyCreate:
            child = p.insertAsLastChild()
            child.initHeadString(h)</t>
<t tx="ekr.20071206070207"></t>
<t tx="ekr.20080105115712"># This hangs Leo while pylint is running.
import pylint.lint as lint
import sys

rcFile = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','pylint-leo-rc.txt'))
rcArg = '--rcfile=%s' % rcFile
&lt;&lt; define data &gt;&gt;

# We expect only one W104 error, in leoGlobals.py
g.pr('\n','=' * 40)
for name,s in data:
    name2 = g.os_path_abspath(g.os_path_join(g.app.loadDir,name))
    args = [name2,rcArg]
    if s.strip():
        args.append('--disable-msg=%s' % s)
    g.pr(name,s)
    lint.Run(args)
g.pr('\n' + 'End of pylint run')</t>
<t tx="ekr.20080105120559">data = (
    ('leoAtFile.py',''), 
    ('leoChapters.py',''),
    ('leoCommands.py',''), 
    ('leoEditCommands.py','E1101'),
    ('leoFileCommands.py',''), 
    ('leoFind.py',''),
    ('leoFrame.py',''),
    ('leoGlobals.py','E0602,E1101'),
    ('leoGui.py',''),
    ('leoImport.py',''),
    ('leoMenu.py',''),
    ('leoNodes.py',''),
    ('leoPlugins.py',''),
    ('leoTangle.py',''),
    ('leoUndo.py','W0102'),
    ('leoTkinterDialog.py',''),
    ('leoTkinterFind.py',''),
    ('leoTkinterGui.py',''),
    ('leoTkinterFrame.py','W0221'),
    ('leoTkinterKeys.py',''), 
    ('leoTkinterMenu.py',''), 
    ('leoTkinterTree.py',''),
)
</t>
<t tx="ekr.20080105130903">@nocolor
@
C0111 Missing docstring
C0301 Line too long
C0311 Bad indentation
C0321 More than one statement on a single line
C0322 Operator not preceded by a space
C0323 Operator not followed by a space
C0324 Comma not followed by a space

R0201 Method could be a function.
R0903 Too few public methods (0/1)

W0102 Dangerous default value [] as argument
W0104 Statement seems to have no effect
W0106 Unnecessary semicolon
W0107 Unnecessary pass statement
W0122 Use of the exec statement
W0141 Used builtin function 'map'
W0142 Used * or * magic*
W0201 Attribute defined outside __init__
W0212 Access to a protected member of a client class
W0231 __init__ method from base class is not called
W0232 Class has no __init__ method
W0401 Wildcard import (pychecker)
W0402 Uses of a deprecated module (like string)
W0404 Reimport &lt;module&gt;: let pychecker do this.
W0406 Module import itself
W0602 Using global for x but no assigment is done (leoEditCommands defines classList after all classes).
W0603 Using the global statement
W0612 Unused variable
W0613 Unused argument (sometimes used for debugging)
W0621 Redefining &lt;name&gt; from outer scope: especially __pychecker__
W0622 Redefining built-in
W0631 Using possibly undefined loop variable
W0702 No exception type specified
W0703 Catch "Exception"
W0704 Except doesn't do anything (Except: pass)
W1111 Assigning to a function call that only returns None</t>
<t tx="ekr.20080115085447">@nocolor
@

************* Module leoGlobals
W0104:3871: Statement seems to have no effect
</t>
<t tx="ekr.20080206055658">g.pr('settings...')
for z in ('body','button','headline','log','menu','outline'):
    for z2 in ('family','size','slant','weight',):
        setting = '%s_text_font_%s' % (z,z2)
        g.pr(setting,c.config.get(setting,z2))

g.pr('default sizes...')
for z in ('Body','Log','Menu','Tree'):
    setting = 'default%sFontSize' % z
    g.pr(setting,getattr(c.config,setting))

g.pr('actual fonts...')
for z in ('body','button','headline','log','menu','outline'):
    kind = ('family','size','slant','weight')
    arg0,arg1,arg2,arg3 = args = ['%s_text_font_%s' % (z,z2) for z2 in kind]
    setting = '%s_text_font' % (z)
    g.pr('%20s' % (setting),c.config.getFontFromParams(arg0,arg1,arg2,arg3,defaultSize=12))
</t>
<t tx="ekr.20080214091706.2">g.pr('hello from ekr')</t>
<t tx="ekr.20080310111916.1">def myTranslateString (s):

    i = s.lower().find('can not')
    if i == -1:
        return s
    else:
        return s[:i+1] + "an't" + s[i+7:]

g.translateString = myTranslateString

</t>
<t tx="ekr.20080412082246.1"></t>
<t tx="ekr.20080503202744.3">import rope.base.project
import rope.contrib.codeassist as codeassist
import leo.core.leoGlobals as g
import leo.core.leoCommands as leoCommands
c2 = leoCommands.Commands(frame=c.frame,fileName='xyz-file')

class leoFSCommands (object):
    def create_file(self,path):         g.trace(path)
    def create_folder(self,path):       g.trace(path)
    def move (self,path,new_location):  g.trace(path,new_location)
    def remove (self,path):             g.trace(path)
    def write (self,path,data):         g.trace(path,data)

path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','..'))
    # Make the trunk folder a project
project = rope.base.project.Project(path,fscommands=leoFSCommands)
s = p.bodyString() # Could simulate a write to allow @others.

g.pr('*' * 40)
for pattern in (
    # 'g.', # works.
    # 'g.trace(', # weird.
    # 'rope.base.', # works.
    'g.list', # works: gives g.listToString
    'c2.de', # works.
):
    i = s.find(pattern)
    if i &gt; -1:
        proposals = codeassist.code_assist(project,s,i+len(pattern))
        g.pr('-' * 20)
        g.pr('pattern:',pattern)
        g.pr(g.listToString(proposals))</t>
<t tx="ekr.20080529111617.1"></t>
<t tx="ekr.20080529111617.2"></t>
<t tx="ekr.20080529111617.3">The colour used instead of green in progress bars</t>
<t tx="ekr.20080529111617.4">The colour used instead of red in progress bars</t>
<t tx="ekr.20080529111617.5"># list of @file node types to color.
# Uncomment these to enable coloring for these kinds of nodes.
# @asis
# @file
# @auto
# @thin
@auto</t>
<t tx="ekr.20080529111617.6">The base width of progress bars, in pixels.</t>
<t tx="ekr.20080529111617.7">The default number of time units.</t>
<t tx="ekr.20080529111617.8">0: no progress bars
1: unscaled progress bars
2: scaled progress bars</t>
<t tx="ekr.20080529111617.9">pixels per time unit to add to width of scaled progress bars</t>
<t tx="ekr.20080529111617.10">The name of time unit (e.g. days, weeks, hours)</t>
<t tx="ekr.20080531080812.1">def eggs():
    g.trace()

def spam():
    g.trace()
    eggs()

t = g.startTracer()
spam()
t.stop()
</t>
<t tx="ekr.20080531131542.1">import mx.TextTools as tt

&lt;&lt; define scan4 tables &gt;&gt;
&lt;&lt; define s &gt;&gt;

@others

g.pr('*' * 60)
ok,taglist,nextindex = tt.tag(s,lineTable)
# g.pr(g.listToString(taglist))
for z in taglist:
    printItem(z,level=0)
g.pr('ok:',ok)
</t>
<t tx="ekr.20080531131542.2">from mx.TextTools import * # Required for tags.

ws_charset   = CharSet(' \t')
name_charset = CharSet(alpha)

gnxTable = (
    (None,Is,':',MatchFail),
    (None,AllNotIn,':',MatchFail),
    (None,Is,':',MatchFail,MatchOk),
)

sentinelNameTable = (
    (None,Is,'@',+1,+3),
    (None,Is,'+',+1,+2),
    (None,Is,'-',+1),
    (None,AllInCharSet,name_charset,MatchFail,MatchOk),
)

sentinelTable = (
    # Start of another line.
    # Skip ws.
    (None,AllInCharSet,ws_charset,+1),
    # Require sentinel comment.
    (None,Word,'#@',MatchFail),
    ('kind',Table,sentinelNameTable,MatchFail),
    ('gnx',Table,gnxTable,+1),
    # Everything else is the sentinel value
    ('extra',AllNotIn,'\n',+1),
    (None,Is,'\n',MatchOk,MatchOk),
)

normalLineTable = (
    (None,AllNotIn,'\n',+1),
    (None,Is,'\n',MatchOk,MatchOk),
)

lineTable = (
    ('sent',Table,sentinelTable,+1,+2),
    ('line',Table,normalLineTable,+1,+1),
    ('eof',EOF,Here,-2),
)</t>
<t tx="ekr.20080531131542.4">def printItem(aList,level):

    obj,lt_index,rt_index,subtag = aList
    g.pr('  '*level,obj,repr(s[lt_index:rt_index]))
    if subtag:
        for z in subtag:
            printItem(z,level+1)
</t>
<t tx="ekr.20080531141227.1">path = r'c:\leo.repo\trunk\leo\core\runLeo.py'
f = file(path)
s = f.read()
f.close()</t>
<t tx="ekr.20080604104453.5">@nocolor

This setting determines the initial binding for otherwise-unbound keystrokes
when no mode is in effect.  Note: the keyboard-quit command exits all modes.

The valid values are::

command:  Leo ignores the key (like Vim).
insert:  Leo inserts the key at the cursor (like Emacs)
overwrite: Leo replaces the character at the cursor.</t>
<t tx="ekr.20080610144233.1">aaaaaaaaaaaa bbbbbbbbbbbbbbbbbb cccccccccccccccc ddddddddddddddddddd eeeeeeeeeeeeeee ffffffffffffffffff ggggggggggggggggggggg hhhhhhhhhhhhhhhh iiiiiiiiiiiii jjjjjjjjjjjjjjjj kkkkkkkkkkkkkk llllllllllllll mmmmmmmmmmmmmmmmm nnnnnnnnnnnn ooooooooo</t>
<t tx="ekr.20080617170334.1">@first # -*- coding: utf-8 -*-

import Tkinter as Tk

top = Tk.Toplevel()
w = Tk.Text(top)
w.pack()

def key(event):
    if event.char: g.pr('state',event.state,'char', repr(event.char), repr(event.keysym))

def after():
    g.trace()
    w.event_generate('&lt;Key&gt;',keysym='a')
    w.event_generate('A')
    w.event_generate(g.toEncodedString('Á',encoding='utf8'))
    # w.event_generate('&lt;Key-Control_L&gt;')
    # w.event_generate('c')
    # w.event_generate('Shift-Control-a')

w.bind('&lt;Key&gt;',key)
w.focus_set()
w.update()
# top.after_idle(after)
top.mainloop()
</t>
<t tx="ekr.20080628094340.1">if 0:
    # Called when func is **defined**
    def leo_command(func):
        g.trace(func.__name__)
        return func
else:
    class leo_command:
        def __init__(self,func,c=c):
            self.c = c
            self.func = func
            self.name = func.__name__
            g.pr("registering",self.name)

        def __call__(__self,*__args,**__kw):
            g.pr("before", __self.name)
            try:
                return __self.func(*__args,**__kw)
            finally:
                g.pr("after ", __self.name)
                g.pr('c',c)
                c.outerUpdate()


@leo_command
def hello():
    g.pr("Hello, world!")

hello()
</t>
<t tx="ekr.20080701101740.1">import locale
aList = dir(locale)
# g.pr(g.listToString(aList))

g.pr(g.getpreferredencoding())
# import os
# g.pr(dir(os))
</t>
<t tx="ekr.20080701130406.1">import glob

aList = glob.glob(r'c:\leo.repo\trunk\leo\plugins\*.py')
for z in aList:
    name = g.shortFileName(z)
    if not name.startswith('_'):
        g.pr('echo .')
        g.pr('echo',name)
        g.pr('call pylint.bat core\%s' % name)</t>
<t tx="ekr.20080729153237.1"></t>
<t tx="ekr.20080729153237.2"># True: calls to the garbage collector.</t>
<t tx="ekr.20080729153237.3"># True (recommended): print a message when Leo calls gc.collect explicitly.</t>
<t tx="ekr.20080729153237.4"># True: verbose trace the garbage collector.</t>
<t tx="ekr.20080801160915.1">@others
</t>
<t tx="ekr.20080803120643.1">def spam():
    pass</t>
<t tx="ekr.20080806145258.1">@language javascript

/**********************************************
* Contractible Headers script- © Dynamic Drive (www.dynamicdrive.com)
* This notice must stay intact for legal use. Last updated Mar 23rd, 2004.
* Visit http://www.dynamicdrive.com/ for full source code
***********************************************/

// alert("start");

var enablepersist="on" //Enable saving state of content structure using session cookies? (on/off)
var collapseprevious="no" //Collapse previously open content when opening present? (yes/no)

if (document.getElementById){
    document.write('&lt;style type="text/css"&gt;')
    document.write('.switchcontent{display:none;}')
    document.write('&lt;\/style&gt;')
}

@others</t>
<t tx="ekr.20080806145258.2">function getElementbyClass(classname){
    ccollect=new Array()
    var inc=0
    var alltags=document.all? document.all : document.getElementsByTagName("*")
    for (i=0; i&lt;alltags.length; i++){
        if (alltags[i].className==classname)
            ccollect[inc++]=alltags[i]
    }
}

</t>
<t tx="ekr.20080806145258.3">function contractcontent(omit){
    var inc=0
    while (ccollect[inc]){
        if (ccollect[inc].id!=omit)
        ccollect[inc].style.display="none"
        inc++
    }
}
</t>
<t tx="ekr.20080806145258.4">function expandcontent(cid){
    if (typeof ccollect!="undefined"){
        if (collapseprevious=="yes")
            contractcontent(cid)
        document.getElementById(cid).style.display=(document.getElementById(cid).style.display!="block")? "block" : "none"
    }
}
</t>
<t tx="ekr.20080806145258.5">function revivecontent(){
    contractcontent("omitnothing")
    selectedItem=getselectedItem()
    selectedComponents=selectedItem.split("|")
    for (i=0; i&lt;selectedComponents.length-1; i++)
        document.getElementById(selectedComponents[i]).style.display="block"
}

</t>
<t tx="ekr.20080806145258.6">function get_cookie(Name) { 
    var search = Name + "="
    var returnvalue = "";
    if (document.cookie.length &gt; 0) {
        offset = document.cookie.indexOf(search)
        if (offset != -1) { 
            offset += search.length
            end = document.cookie.indexOf(";", offset);
            if (end == -1) end = document.cookie.length;
            returnvalue=unescape(document.cookie.substring(offset, end))
        }
    }
    return returnvalue;
}

</t>
<t tx="ekr.20080806145258.7">function getselectedItem(){
    if (get_cookie(window.location.pathname) != ""){
        selectedItem=get_cookie(window.location.pathname)
        return selectedItem
    }
    else
        return ""
}

</t>
<t tx="ekr.20080806145258.8">function saveswitchstate(){
    var inc=0, selectedItem=""
    while (ccollect[inc]){
        if (ccollect[inc].style.display=="block")
            selectedItem+=ccollect[inc].id+"|"
        inc++
    }
    document.cookie=window.location.pathname+"="+selectedItem
}

</t>
<t tx="ekr.20080806145258.9">function do_onload(){
    // alert("do_onload");
    uniqueidn=window.location.pathname+"firsttimeload"
    getElementbyClass("switchcontent")
    if (enablepersist=="on" &amp;&amp; typeof ccollect!="undefined"){
        document.cookie=(get_cookie(uniqueidn)=="")? uniqueidn+"=1" : uniqueidn+"=0" 
        firsttimeload=(get_cookie(uniqueidn)==1)? 1 : 0 //check if this is 1st page load
        if (!firsttimeload)
        revivecontent()
    }
}

if (window.addEventListener)
    window.addEventListener("load", do_onload, false)
else if (window.attachEvent)
    window.attachEvent("onload", do_onload)
else if (document.getElementById)
    window.onload=do_onload

if (enablepersist=="on" &amp;&amp; document.getElementById)
    window.onunload=saveswitchstate

</t>
<t tx="ekr.20080806145258.10">function format() {

    return;

    // var sections = document.getElementsByTagName("pre");  // EKR: was span.
    // //alert("format:" + sections.length + "sections")
    // for(i=0; i &lt; sections.length; i++) {
        // formatText(sections[i]);
    // }
}
</t>
<t tx="ekr.20080806145258.11">function formatText(item) {

    ;
    // alert(item);
}
</t>
<t tx="ekr.20080806145258.12">@nocolor

Notes:
    
- button Leo2dHTML creates leo\test\x.htm, where x is the name of the .leo file
  containing the script. The file contains javascript that allows a browser to
  expand and contract headlines.  Leo2DHTML is *unrelated* to the other files.
    
- leo\test\server.py is a minimal Python server.  Invoke from a console with::
    
    python server.py

To use this server, type this url in a web browser: http://localhost:8080/
The server will print the contents of the directory from which it was invoked.
Choose hello.html to see the 'Hello World' test page.

- leo\test\hello.html is a test page.  It uses leo\test\cgi-bin\edward.py

- leo\test\cgi-bin\edward.py is the script called from hello.leo when the user
  hits the 'Submit Query button.
  This is recompiled (as needed) for every query, which makes testing it easier.
  
  **Important** edward.py returns its result by printing (in a special format):
  Thus, everything you print will be part of the returned form(!). You **can**
  print debug info: just make sure you don't mess up the special conventions:
  the best place to print debugging info is in print_all.

@color</t>
<t tx="ekr.20080806145258.13">@

edward.py:
    
How can we get the content of an input form?</t>
<t tx="ekr.20080806145258.14">@first # -*- coding: utf-8 -*-
@language python
@tabwidth -4

&lt;&lt; about LeoToHTML &gt;&gt;
import leo.core.leoGlobals as g
&lt;&lt; define dhtml stuff &gt;&gt;
@others

fileName = c.frame.shortFileName() # Get current outline file name
if fileName.endswith('.leo'): fileName = fileName[:-4] # Remove .leo suffix
path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test',fileName)) + '.htm'

# Write the file.
f=open(path, 'w')
writeAll(f)
f.close() 
g.es('wrote: %s' % (path),color="turquoise4") 
</t>
<t tx="ekr.20080806145258.15">@

LeoToHTML by Dan Rahmel, modified by EKR.

This @button script creates an .htm file containing the contents of the selected tree.
The file is called x.htm, where x is the name of the .leo file containing the script.
This file is written to the leo/test folder.

The script inserts javascript into the page so that nodes can be expanded and contracted.

The script presently works well.  This script may become the basis for a facebook app.

The generated html passes html-tidy: http://www.w3.org/People/Raggett/tidy/
</t>
<t tx="ekr.20080806145258.16">division = """
&lt;div STYLE="margin-left:3em;text-indent:0em;margin-top:0em; margin-bottom:0em;"&gt;
&lt;h3 onClick="expandcontent('sc%d')" style="cursor:hand; cursor:pointer; margin-top:0em; margin-bottom:0em"&gt;+ %s&lt;/h3&gt;
    &lt;div id="sc%d" class="switchcontent" style="margin-top:0em; margin-bottom:0em;"&gt;
"""

javascript  = """
&lt;script src="cgi-bin/leo.js" type="text/javascript"&gt;&lt;/script&gt;
"""

style = '''
&lt;STYLE type="text/css"&gt;
    BODY {font:x-medium 'Verdana'; margin-right:1.5em}
    PRE {margin:0px; display:inline}
&lt;/STYLE&gt;
'''
</t>
<t tx="ekr.20080806145258.17">def escape (s):

    return s.replace('&amp;','&amp;amp;').replace('&lt;','&amp;lt;').replace('&gt;','&amp;gt;')
</t>
<t tx="ekr.20080806145258.18">def writeAll(f):

    f.write('&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;')
    f.write('&lt;html&gt;')
    writeHead(f)
    writeBody(f)
    f.write("&lt;/html&gt;")
</t>
<t tx="ekr.20080806145258.19">def writeBody(f):

    f.write('&lt;body class="st" onload="format()"&gt;')
    writeContents(f)
    f.write("&lt;/body&gt;")
</t>
<t tx="ekr.20080806145258.20">def writeHead(f):

    f.write('&lt;head&gt;')
    f.write(style)
    f.write(javascript)
    f.write('&lt;title&gt;%s&lt;/title&gt;' % c.shortFileName())
    f.write('&lt;/head&gt;')
</t>
<t tx="ekr.20080806145258.21">def writeContents(f):

    div = "&lt;div class='c' STYLE='margin-left:4em;margin-top:0em; margin-bottom:0em;'&gt;\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n&lt;/div&gt;"
    end_div = "&lt;/div&gt;\n&lt;/div&gt;\n"
    n = 1 # The node number
    current = c.currentPosition()
    prev_level = current.level()
    open_divs = 0
    for p in current.self_and_subtree_iter():
        h = p.headString()
        while prev_level &gt;= p.level() and open_divs &gt; 0:
            f.write(end_div)
            prev_level -= 1
            open_divs -= 1
        body = p.bodyString().encode( "utf-8" )
        body = body.rstrip().rstrip("\n")
        f.write(division % (n,escape(h),n))
        open_divs += 1
        if body:
            f.write(div % escape(body))
        prev_level = p.level()
        n += 1

    # Close all divisions.
    while open_divs &gt; 0:
        f.write(end_div)
        open_divs -= 1
</t>
<t tx="ekr.20080806145258.22"># def writePreamble(f):

    # '''Write HTML header information.'''

    # header_start = '''\


# &lt;body class="st" onload="format()"&gt;
# '''

    # for s in (header_start,style,javascript,header_end):
        # # f.write(g.adjustTripleString(s,c.tab_width))
        # f.write(s)
</t>
<t tx="ekr.20080806145258.23"># def writePostamble (f):

    # pass

</t>
<t tx="ekr.20080806145258.24"># A minimal python server for testing.
# To access this server, type this url in a web browser: http://localhost:8080/
# The server will print the contents of the directory from which it was invoked.
# Choose hello.html to see the 'Hello World' test page.

import CGIHTTPServer
import SocketServer

port = 8080

Handler = CGIHTTPServer.CGIHTTPRequestHandler
s = SocketServer.TCPServer(("", port), Handler)

s.server_name = '127.0.0.1' # represents local host.
s.server_port = port

# import os ; print 'cwd', os.getcwd()

print "server.py: serving at port", port
s.serve_forever()
</t>
<t tx="ekr.20080806145258.25">@language html

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;/title&gt;

&lt;!-- Used by edward.old.py
&lt;script language="JavaScript" type="text/javascript"&gt;
   var openImg = new Image();
   openImg.src = "open.gif";
   var closedImg = new Image();
   closedImg.src = "closed.gif";

   function showNode(node) {
      var objBranch = 
         document.getElementById(node).style;
      if(objBranch.display=="block")
         objBranch.display="none";
      else
         objBranch.display="block";
   }

   function swapFolder(img) {
      objImg = document.getElementById(img);
      if(objImg.src.indexOf('closed.gif')&gt;-1)
         objImg.src = openImg.src;
      else
         objImg.src = closedImg.src;
   }
&lt;/script&gt;
--&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;form action="cgi-bin/edward.py" method="GET"&gt;
&lt;input type="submit" name="George"&gt;
&lt;/form&gt;

&lt;p&gt;This is the hello world test page.
The server in server.py should be running when using this page.

&lt;p&gt;The button (form) above should cause the server to send a "GET" request
to the edward.py script, which will respond with a new page.

&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20080806145258.26">@first #! c:\python25\python.exe
@first # -*- coding: utf-8 -*-

'''This is the cgi script called from hello.html when the user hits the button.'''

### Print statements are used to return results (return the form).
### You *can* use print statement for tracing, but only in print_all.
# To do: use cgi.FieldStorage.

@language python
@tabwidth -4
&lt;&lt; imports &gt;&gt;
&lt;&lt; define dhtml stuff &gt;&gt;
@others

if 1: # Open the bridge.
    path = os.path.abspath(os.path.join(leoParentDir,'leo','test','test.leo')) # c does not exist!
    b = leoBridge.controller(gui='nullGui',loadPlugins=False,readSettings=False,verbose=False)
    g = b.globals()
    c = b.openLeoFile(path)
    p = c.rootPosition()
else:
    c = None

# import pdb ; pdb.Pdb() # Doesn't work.
print_all(c)</t>
<t tx="ekr.20080806145258.27">division = """
&lt;div STYLE="margin-left:3em;text-indent:0em;margin-top:0em; margin-bottom:0em;"&gt;
&lt;h3 onClick="expandcontent('sc%d')" style="cursor:hand; cursor:pointer; margin-top:0em; margin-bottom:0em"&gt;+ %s&lt;/h3&gt;
    &lt;div id="sc%d" class="switchcontent" style="margin-top:0em; margin-bottom:0em;"&gt;
"""

style = """
&lt;STYLE type="text/css"&gt;
    BODY {font:x-medium 'Verdana'; margin-right:1.5em}
    PRE {margin:0px; display:inline}
&lt;/STYLE&gt;
"""</t>
<t tx="ekr.20080806145258.28">def escape (s):

    return s.replace('&amp;','&amp;amp;').replace('&lt;','&amp;lt;').replace('&gt;','&amp;gt;')
</t>
<t tx="ekr.20080806145258.29">def print_all(c):

    # This line is required (with extra newline), but does not show on the page.
    print "Content-type:text/html\n"

    print '&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;'
    print '&lt;html&gt;'
    if c:
        # Print the page.
        print_head(c)
        print_body(c)
    else:
        # Print the debugging info.
        print '__file__',__file__
        print 'os.getcwd()',os.getcwd()

    print '&lt;/html&gt;'
</t>
<t tx="ekr.20080806145258.30">def print_body(c):

    print '&lt;body class="st" onload="format()"&gt;'

    if 0:
        # Debugging info.
        form = cgi.FieldStorage()
        print repr(form)
        # if form.has_key('name'):
            # print 'name',form['name'].value
        # else:
            # print 'no name'
    print_tree(c)
    print '&lt;/body&gt;'
</t>
<t tx="ekr.20080806145258.31">def print_head(c):

    print '&lt;head&gt;'

    if 1: # Copy the entire leo.js file into the page.
        print '&lt;script type="text/javascript"&gt;'
        print_leo_dot_js(c)
        print '&lt;/script&gt;'

    else: # Possible bug in the python server??
        # The Python says leo.js is not executable(!)
        print '&lt;script src="leo.js" type="text/javascript"&gt;&lt;/script&gt;'

    print '&lt;title&gt;%s&lt;/title&gt;' % (c.shortFileName())
    print '&lt;/head&gt;'
</t>
<t tx="ekr.20080806145258.32">def print_leo_dot_js(c):

    path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','cgi-bin','leo.js'))

    try:
        f = file(path)
    except IOError:
        print 'can not open',path
        return

    for line in f.readlines():
        print line,

    f.close()
</t>
<t tx="ekr.20080806145258.33">def print_tree(c):

    div = "&lt;div class='c' STYLE='margin-left:4em;margin-top:0em; margin-bottom:0em;'&gt;\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n&lt;/div&gt;"
    end_div = "&lt;/div&gt;\n&lt;/div&gt;\n"
    n = 1 # The node number
    prev_level = 0
    open_divs = 0
    for p in c.allNodes_iter():
        h = p.headString()
        while prev_level &gt;= p.level() and open_divs &gt; 0:
            print end_div
            prev_level -= 1
            open_divs -= 1
        body = p.bodyString().encode( "utf-8" )
        body = body.rstrip().rstrip("\n")
        print division % (n,escape(h),n)
        open_divs += 1
        if body: print div % escape(body)
        prev_level = p.level()
        n += 1

    # Close all divisions.
    while open_divs &gt; 0:
        print end_div
        open_divs -= 1
</t>
<t tx="ekr.20080806145258.34"></t>
<t tx="ekr.20080806145702.1">import os
import sys

# Add the *parent* of the leo directory to sys.path.
leoParentDir = os.path.abspath(os.path.join(os.path.dirname(__file__),'..','..','..'))

if leoParentDir not in sys.path:
    sys.path.append(leoParentDir)

import leo.core.leoBridge as leoBridge

import cgi
import cgitb ; cgitb.enable()
</t>
<t tx="ekr.20080807091001.1">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080807091201.7">#!/usr/local/bin/python
# -*- coding: utf-8 -*-
"""
module docs
"""

</t>
<t tx="ekr.20080807091201.8">class Person(object):
   '''class docs
   '''
   field1 = 10
   field2 = 20

   @others
</t>
<t tx="ekr.20080807091201.9">def talk(self):
    ''' this is the func doc
    '''
    print 'hello world'

</t>
<t tx="ekr.20080807091201.10">class Meta:
    age = 10</t>
<t tx="ekr.20080807114145.2">@
A script button to run any body text as a Windows Script.
See: http://en.wikipedia.org/wiki/Windows_Script_Host

You need the win32 extensions and you must enable the script engine.
Adapted from Active State examples:ch21_active_scripting:ActiveApp.py
http://python.net/crew/mhammond/win32/
@c

&lt;&lt; imports &gt;&gt;

@others

RunCode("python",p.bodyString())
</t>
<t tx="ekr.20080807115344.1">Application.Echo("Hello from Python")
</t>
<t tx="ekr.20080807115344.2">class MySite(axsite.AXSite):
    # Our error handler will simply print to the console.
    def OnScriptError(self, activeScriptError):
        exc = activeScriptError.GetExceptionInfo()
        print "Exception:", exc[1]
        try:
            sourceText = activeScriptError.GetSourceLineText()
        except pythoncom.com_error:
            sourceText = None
        if sourceText is not None: 
            context, lineNo, charNo = activeScriptError.GetSourcePosition()
            print sourceText
            indent = " " * (charNo-1)
            print indent + "^"
        return winerror.S_OK
</t>
<t tx="ekr.20080807115344.3"># A named object for our namespace
# A normal Python COM object (minus registration info)
class Application:
    _public_methods_ = [ 'Echo' ]
    def Echo(self, *args):
        print string.join(map(str, args))

</t>
<t tx="ekr.20080807115344.4"># Create the site and the engine and runs the code.
def RunCode(engineName, code):

    app = win32com.server.util.wrap( Application() )

    # Create a dictionary holding our object model.
    model = {'Application' : app,}

    # Create the scripting site.
    site = MySite(model)
    # Create the engine and add the code.
    engine = site.AddEngine(engineName)
    engine.AddCode(code)

    # Run the code.
    engine.Start()
</t>
<t tx="ekr.20080807115344.5">import string
import sys
from win32com.axscript import axscript
from win32com.axscript.server import axsite
import pythoncom
import win32com.server.util</t>
<t tx="ekr.20080811113441.2"></t>
<t tx="ekr.20080812102914.1">root first line
@others
root last line</t>
<t tx="ekr.20080812102914.2">child line 1
child line 2</t>
<t tx="ekr.20080812112440.1">@language ini
[section]
blah blah
changed
changed2
changed3
changed4
change5</t>
<t tx="ekr.20080812135254.1"># Line one
# line two</t>
<t tx="ekr.20080813080627.1">@others</t>
<t tx="ekr.20080813080627.2">def spam():
    pass</t>
<t tx="ekr.20080813080627.3">def eggs():
    pass</t>
<t tx="ekr.20080813080729.1"></t>
<t tx="ekr.20080813080809.1"></t>
<t tx="ekr.20080813100905.1">import sys
print sys.argv</t>
<t tx="ekr.20080815073750.1">n = 0
for p in c.allNodes_iter():
    if p.isAtNoSentFileNode():
        c.atFileCommands.write(p,nosentinels=True)
        n += 1
g.es('done: %s files written' %(n))</t>
<t tx="ekr.20080819095720.1">@language unknown_language
# huh language .................
changed 7
</t>
<t tx="ekr.20080821111715.1">@first # -*- coding: utf-8 -*-

# Important: see http://webpages.charter.net/edreamleo/FAQ.html#unicode-issues

import sys
        
print '=' * 40

e = sys.getdefaultencoding()
assert e.lower() == 'utf-8'
print 'encoding',e

table = (
    'La Peña',
    unicode('La Peña','utf-8'),
    u'La Peña',
    u'La Pe\xf1a',
    # u'AA \u0102 BB',
)

for s in table:
    print type(s)
    g.es_print('g.es_print',s)
    if type(s) != type(u'a'):
        s = unicode(s,e)
    print      'print     ',s
    print      'repr(s)   ',repr(s)</t>
<t tx="ekr.20080822153619.1"></t>
<t tx="ekr.20080823154546.1">p2 = p.insertAfter()
p2.setHeadString('inserted node')
s = p.bodyString()

# Remove Leo directives.
directives = ['@'+z for z in g.globalDirectiveList]
def isDirective(s):
    for z in directives:
        if s.startswith(z):
            return True
    else: return False
aList = [z for z in g.splitLines(s) if not isDirective(z)]
s = ''.join(aList)
if not s.endswith('\n'): s = s + '\n'

c.importCommands.scanPythonText(s,p2.copy(),atAuto=True)
c.redraw_now()
g.pr('done')</t>
<t tx="ekr.20080909075224.1">@language html
../hex6x -
changed</t>
<t tx="ekr.20080911080311.1">@language conf
; This is a comment
P1 = 0
</t>
<t tx="ekr.20080915095329.1">import leo.core.leoPlugins as leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    controller = rst3.controllers.get(c)
    if controller:
        controller.processTopTree(p)
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True

# print 'done'
</t>
<t tx="ekr.20080917063615.1">aList = (
'aspellbindir',
'wholeword',
'Whole-Word',
'vimcmd',
'huh',
)

for name in aList:
    kind, val = c.config.getSettingSource(name)
    print '%-20s %-20s %s' % (name,repr(val),kind)
</t>
<t tx="ekr.20080920101658.1">def getInput (event=None):

    '''Evaluate a Python Expression entered in the minibuffer.'''

    stateName = 'get-input'
    k = c.k ; state = k.getState(stateName)

    if state == 0:
        k.setLabelBlue('Input: ',protect=True)
        k.getArg(event,stateName,1,getInput)
    else:
        k.clearState()
        g.es_print('input:',k.arg)

getInput()
</t>
<t tx="ekr.20080921144924.1">print(g.os_path_finalize(r'~/.leo/notebook.leo'))
print(g.os_path_finalize(g.os_path_join(g.app.loadDir,r'~/.leo/notebook.leo')))
print(g.os_path_finalize_join(g.app.loadDir,r'~/.leo/notebook.leo'))</t>
<t tx="ekr.20080922142953.1"># @string default_leo_file = ~/.leo/workbook.leo
path = "{{c.config.getString('default_leo_file')}}"
# print g.os_path_expandExpression(path,c=c)
print g.os_path_finalize(path,c=c)</t>
<t tx="ekr.20080922164255.1"></t>
<t tx="ekr.20080922164255.2"></t>
<t tx="ekr.20080922164656.1"></t>
<t tx="ekr.20080923073240.1">{{c.config.getString('test')}}/eval-test.txt
=
c:\leo.repo\trunk\leo\test\eval-test.txt</t>
<t tx="ekr.20080923073240.2"></t>
<t tx="ekr.20080924033317.1">@language c

@others</t>
<t tx="ekr.20080924033317.2">int spam():
    ;</t>
<t tx="ekr.20080924081821.1"># c.k.ab

# Test this code using the execute-script command.

s = p.bodyString()
lines = g.splitLines(s)
s = lines[0]

theObject,aList = c.k.autoCompleter.getExternalCompletions(s)

print '='*20
print 'theObject',theObject and theObject.__class__
print 'len(completions)',len(aList)
print g.listToString(aList, tag='completion list', sort=True, indent='')
</t>
<t tx="ekr.20080930080501.1">c.frame.iconBar.addRow()
c.frame.addIconButton(text="New")</t>
<t tx="ekr.20080930083052.1">c.frame.hideIconBar()</t>
<t tx="ekr.20080930083052.2">c.frame.showIconBar()</t>
<t tx="ekr.20080930085514.1">c.frame.clearIconBar()</t>
<t tx="ekr.20080930114036.1"></t>
<t tx="ekr.20081001110047.1">@others</t>
<t tx="ekr.20081001110047.2">def spam():
    
    pass # changed</t>
<t tx="ekr.20081001110047.3">def eggs():
    
    pass</t>
<t tx="ekr.20081003094737.1"></t>
<t tx="ekr.20081025105942.1">import os
os.system("dir")</t>
<t tx="ekr.20081205104320.1"># import os
tag = '#!/bin/bash\n'
s = g.getScript(c,p,
    useSelectedText=False,
    forcePythonSentinels=False,
    useSentinels=True)
if not s.startswith(tag):
    s = tag + s
print s
os.system(s)
</t>
<t tx="ekr.20081216091605.2">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20090122211549.1">
class test:
    
    '''Class docstring
test line 2'''
    @others
</t>
<t tx="ekr.20090122211549.2">
def spam (self):

    '''Spam docstring.
\\-4spam line 2'''

    pass
</t>
<t tx="ekr.20090128112453.1"># print p.b
# p.b = p.b + '\n# new'
# p.h = p.h + 'z'

print c.p

if 0:
    print p.v.u
    print p.v.u.get('key')
    p.v.u['key'] = 'abc'
    print p.v.u.get('key')
    p.v.u = {'key':'xyz'}
    # p.v.u = 'abc'
    print p.v.u

if 0:
    print p.v.t.u
    print p.v.t.u.get('t-key')
    p.v.t.u['t-key'] = 'pdq'
    print p.v.t.u.get('t-key')
    # p.v.t.u = {'key':'pdq'}
    # # p.v.t.u = 'pdq'
    # print p.v.t.u</t>
<t tx="ekr.20090128131130.1">aList = g.posList(c) # Start with all positions
print len(aList)
aList2 = aList.select('plugin',regex=False,removeClones=True)
print aList2.dump(sort=True)
aList3 = aList2.select('http')
print aList3.dump()

# To see the docstring, enable auto-completion and type g.posList?
# g.posList</t>
<t tx="ekr.20090201162523.1"># define a macro: ctrl-f ab ctrl-r AB
pass</t>
<t tx="ekr.20090201192257.1">b = p.b
try:
    w = c.frame.body.bodyCtrl
    w.setInsertPoint(0)
    m = c.macroCommands
    fn = g.os_path_finalize_join(g.app.loadDir,'..','..','ekr-macros.txt')
    f = open(fn)
    m.loadMacros(f)
    macro = m.namedMacros.get('ab')
    assert macro
    m.executeMacro(macro)
finally:
    assert p.b =='ab' + b,p.b
    p.b = b
</t>
<t tx="ekr.20090205070715.1">#colorer = c.frame.body.colorizer.highlighter.colorer
g.es ('total characters: %s, keywords: %s, leo_keywords: %s' % (
    colorer.totalChars,
    colorer.totalKeywordsCalls,
    colorer.totalLeoKeywordsCalls))</t>
<t tx="ekr.20090218112656.1"># 'self' is now defined in @test and @suite nodes.
self.assertEqual(1,1)</t>
<t tx="ekr.20090309064612.1"></t>
<t tx="ekr.20090309064612.2"></t>
<t tx="ekr.20090309064612.3"></t>
<t tx="ekr.20090309064612.4"></t>
<t tx="ekr.20090309065826.1"></t>
<t tx="ekr.20090316115500.1"></t>
<t tx="ekr.20090428081009.1">import PyQt4.QtCore as QtCore
import PyQt4.QtGui as QtGui
from PyQt4 import uic

table = (
    (['QtGui'],'object',QtGui),
    (['QtCore'],'object',QtCore),
)

c.k.autoCompleter.defineObjectDict(table)
print c.k.autoCompleter.objectDict.keys()

# print c.k.autoCompleter.objectDict.get('QtCore')</t>
<t tx="ekr.20090430080001.1">@language rest
</t>
<t tx="ekr.20090430080001.2">.. test of sections references

@ @rst-options
code_mode=False
generate_rst=True
generate_rst_header_comment = True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=c:\leo.repo\trunk\leo\doc
stylesheet_name=noweb.css
write_intermediate_file = True
verbose=True
@c

#####################
About the foo module
#####################


</t>
<t tx="ekr.20090430124352.5">This is a doc part::

    section b, line 1
    section b, line 2</t>
<t tx="ekr.20090430124352.9">@ This is a doc part
@c

section a, line 1
section a, line 2
&lt;&lt; section c &gt;&gt;
section a, last line</t>
<t tx="ekr.20090430124352.10">@ @rst-options
number_code_lines = False
show_doc_parts_as_paragraphs = True
code_block_string =\n.. class:: code\n..\n\n::\n
</t>
<t tx="ekr.20090430124352.11">@ This is section c.
@c

section c, line 1
section c, line 2
    section c, line 3</t>
<t tx="ekr.20090507082111.1904">print "---- inserting ----"
p2 = p.insertAsLastChild().copy()
p3 = p.insertAsLastChild().copy()

print [p2.gnx, p3.gnx]

children = p.children_iter()
print [p.gnx for p in children]

c.redraw()</t>
<t tx="ekr.20090507082535.1906">import email,getpass,imaplib,os

username = 'edreamleo@gmail.com'
passfile = os.path.expanduser('~/gmailpass.txt')
M = imaplib.IMAP4_SSL('imap.gmail.com',993)
try:
    f = open(passfile)
    password = f.read()
    M.login(username,password)
except IOError:
    g.es_print('file not found: %s' % (passfile),color='red')
    # M.login(username, getpass.getpass())

M.select()
typ, data = M.search(None, 'ALL')
for num in data[0].split():
    typ, data = M.fetch(num,'(RFC822)')
    s = data[0][1]
    m = email.message_from_string(s)
    # for z in m.keys(): print z
    payload = m.get_payload()
    p2 = p.insertAsLastChild()
    date,from_s,subject = m['date'],m['from'],m['subject']
    p2.setHeadString(subject)
    body = '@nocolor\n\nDate: %s\nFrom: %s\nSubject: %s\n\n%s' % (
        date,from_s,subject,payload)
    p2.setBodyString(body)
print 'done'
M.close()
M.logout()
c.redraw()</t>
<t tx="ekr.20090514073218.1923">import leo.core.leoTest as leoTest

if False:
    # Run tests locally.
    leoTest.doTests(c,all=True)
else:
    # Run tests externally.
    path = 'test.leo' # path is relative to leo\test directory
    leoTest.runUnitTestLeoFile(gui='nullGui',path=path,silent=False)
</t>
<t tx="ekr.20090514101216.1927"># 'self' is now defined in @test and @suite nodes.
self.assertNotEqual(1,2)</t>
<t tx="ekr.20090514103332.1929"></t>
<t tx="ekr.20090521070342.1907">g.app.gui.runScrolledMessageDialog(c=c,msg=u'rst:'+p.b)</t>
<t tx="ekr.20090521070342.1908">####
top
####

- one
- two
- three
- four</t>
<t tx="ekr.20090521100748.1911">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20090521114145.1913">..changed ekr

A home for items without a home.

.. contents::
   :depth: 2

</t>
<t tx="ekr.20090521114145.1914">
`Answer &lt;http://www.martin-geber.com/thought/2007/08/22/problems-installing-easy_install-pil/&gt;`_ to problems with::

 ~$ sudo easy_install pil

#~: easy_install --find-links http://www.pythonware.com/products/pil/ Imaging


</t>
<t tx="ekr.20090521114145.1915">
ppa::

	deb http://ppa.launchpad.net/screen-profiles/ppa/ubuntu jaunty main
	deb-source http://ppa.launchpad.net/screen-profiles/ppa/ubuntu jaunty main

</t>
<t tx="ekr.20090521114145.1916">
``useful bits`` would be an anotation applied to a device
which indicated potential for re-use, re-purposing.

example::

 a power supply circuit board would contain ``useful bits`` such as

  - transformer
  - ac cord socket
  - power transistors with heat sinks
  - ...

</t>
<t tx="ekr.20090521114145.1917">
the `top` program displays Linux task activity. There are several variations
on `top`

- iotop
- htop
- atop
- ntop
- powertop
- dnstop
- iftop
- itop
- jnettop
- kerneltop
- latencytop
- mtop
- mytop
- pktstat - top-like utility for network connections usage
- ptop
- wmtop

</t>
<t tx="ekr.20090521114145.1918">
http://mail.python.org/pipermail/python-list/2006-February/366462.html

::

 Are there any best practice guidelines for when to use
    super(Class, self).__init__()
 vs
    Base.__init__(self)
 to call a base class __init__()?
 
**Class must be a new-type class** 



</t>
<t tx="ekr.20090521114145.1919">
http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-3.html

1 = stdout, 2 = stderr

redirect stdout to a file
    ls -l &gt; ls-l.txt

redirect stderr to a file
    grep da * 2&gt; grep-errors.txt

redirect stdout to a stderr
    grep da * 1&gt;&amp;2

redirect stderr to a stdout
    grep * 2&gt;&amp;1

redirect stderr and stdout to a file
    rm -f $(find / -name core) &amp;&gt; /dev/null

redirect stderr and stdout to stdout
    

redirect stderr and stdout to stderr


</t>
<t tx="ekr.20090521114145.1920">
- generate a directory tree with files.
- run Python code against this tree to demonstrate
 
  - importing packages
  - importing modules
  - importing names
  - import ... as ...
  - from ... import ...
  - from ... import ... as ...
  - operation of __all__
  - .pth operation


</t>
<t tx="ekr.20090521114145.1921">
 Backup aborted (No files dumped for share C$)

  smbclient \\\\192.168.0.90\\C\$ -U backupuser backupuser
  smbclient \\\\hpdjcc\\C\$ -U backupuser backupuser


</t>
<t tx="ekr.20090521114145.1922">
::

    foo (*args, *kwargs)

kwargs = key word args                            

</t>
<t tx="ekr.20090521114145.1923">
| Got fatal error during xfer (No files dumped for share C$)
| Backup aborted (No files dumped for share C$)

XP host not a domain member

File Explorer -&gt; select C: -&gt; Tools -&gt; Folder Options -&gt; View
-&gt; uncheck ``Use simple file sharing``

</t>
<t tx="ekr.20090521114145.1924">
::
 
 $ grep -lR "this string" *.ext | xargs less

search for "this string" recursively (-R) list filename only (-l)
the filenames become arguments (xarg) to (less)
when in less, ``:n`` opens the next file


</t>
<t tx="ekr.20090521114145.1925">
UltraVNC automatic installation::

 /dir="Dirname"
    Sets installation directory to Dirname 
     
 /no restart
    Suppresses a reboot at the end of the installation.
    Not required since the installation no longer requires a reboot.
    
 /silent or /very silent
    Suppresses either pop-up of dialog boxes or any GUI at all.
    
 /loadinf="Filename"
    Loads the configuration file Filename for the installation.
    This configuration file can be generated by going through setup with UltraVNC-xxxx-Setup.exe /saveinf="Filename".
    Filename should be fully qualified.
    
 /log
    Writes a log file to the Temp directory.
    Could be used for debugging.  

</t>
<t tx="ekr.20090521114145.1926">
bzr branch lp:pydoctor

if in a grokproject virtualenv when fetching and installing,
the requirements seem fulfilled.

$ pydoctor --add-module /home/ktenney/work/docubi --make-html --project-base-dir=/tmp/pydoctor

pydoctor --help::

    Usage: pydoctor [options]

    Options:
      -h, --help            show this help message and exit
      -c CONFIGFILE, --config=CONFIGFILE
                            Use config from this file (any command lineoptions
                            override settings from the file).
      -p INPUTPICKLE, --input-pickle=INPUTPICKLE
                            Load the system from this pickle file (default: none,
                            a blank system is created).
      -o OUTPUTPICKLE, --output-pickle=OUTPUTPICKLE
                            Save the system to this pickle file (default: none,
                            the system is not saved by default).
      --extra-system=SYS:URLPREFIX
                            Look for objects in this system to.  Links to these
                            objects will have URLPREFIX prepended to them.
      --system-class=SYSTEMCLASS
                            A dotted name of the class to use to make a system.
      --project-name=PROJECTNAME
                            The project name, appears in the html.
      --project-url=PROJECTURL
                            The project url, appears in the html if given.
      --project-base-dir=PROJECTBASEDIRECTORY
                            Absolute path to the base directory of the project.
                            Source links will be computed based on this value.
      --testing             Don't complain if the run doesn't have any effects.
      --pdb                 Like py.test's --pdb.
      --make-html           Produce html output.
      --server              Serve HTML on a local server.
      --server-port=SERVER_PORT
                            The port for --server to use.
      --local-only          Bind the server to localhost only.
      --facing-path=FACING_PATH
                            Set up a VHostMonster, with all the confusion that
                            implies.
      --edit                When serving HTML, allow editing.
      --no-check            When serving HTML and allow editing, don't check all
                            docstrings first.
      --add-package=PACKAGEDIR
                            Add a package to the system.  Can be repeated to add
                            more than one package.
      --add-module=MODULE   Add a module to the system.  Can be repeated.
      --prepend-package=PREPENDEDPACKAGE
                            Pretend that all packages are within this one.  Can be
                            used to document part of a package.
      --resolve-aliases     This updates references to classes imported from a
                            module into which they were imported to references to
                            where they are defined.
      --abbreviate-specialcase=ABBREVMAPPING
                            This is a comma seperated list of key=value pairs.
                            Where any key corresponds to a module name and value
                            is the desired abbreviation.  This can be used to
                            resolve conflicts with abbreviation where you have two
                            or more modules that start with the same letter.
                            Example: twistedcaldav=tcd.
      --docformat=DOCFORMAT
                            Which epydoc-supported format docstrings are assumed
                            to be in.
      --html-subject=HTMLSUBJECTS
                            The fullName of object to generate API docs for
                            (default: everything).
      --html-summary-pages  Only generate the summary pages.
      --html-write-function-pages
                            Make individual HTML files for every function and
                            method. They're not linked to in any pydoctor-
                            generated HTML, but they can be useful for third-party
                            linking.
      --html-output=HTMLOUTPUT
                            Directory to save HTML files to (default 'apidocs')
      --html-writer=HTMLWRITER
                            Dotted name of html writer class to use (default
                            'pydoctor.nevowhtml.NevowWriter', requires Divmod
                            Nevow to be installed).
      --html-viewsource-base=HTMLSOURCEBASE
                            This should be the path to the trac browser for the
                            top of the svn checkout we are documenting part of.
      --html-use-sorttable  Use the sorttable JS library to make tables of
                            package, module and class contents sortable
      --html-use-splitlinks
                            Generate (unobstrusive) JavaScript to allow class
                            methods to be shown either in one table per base class
                            or in one big table.
      --html-shorten-lists  Generate (unobstrusive) JavaScript to hide some of the
                            entries in long lists of e.g. subclasses.
      --livecheck           Import and examine the modules too.  XXX not working
                            right now
      -v, --verbose         Be noisier.  Can be repeated for more noise.
      -q, --quiet           Be quieter.
      --auto                Automagic mode: analyze all modules and packages in
                            the current working directory and run a local server
                            that allows examination and editing of the docstrings.
      --verbose-about=stage
                            Be noiser during a particular stage of generation.


</t>
<t tx="ekr.20090521114145.1927">
Good gstreamer info on the `Songbird &lt;http://wiki.songbirdnest.com/Developer/Articles/Media_Cores/GStreamer_Setup&gt;`_ site
    
</t>
<t tx="ekr.20090521114145.1928">
fivews.py
"""The 5 W's, who, what, where, why, when

Use for filtering, searching. Use Zope interfaces, customize for application.

&gt;&gt;&gt; from fivews import Where, what
&gt;&gt;&gt; location = Where('/home/ktenney/work/docubi/chunks/images/*.png')
&gt;&gt;&gt; for fname in location:
&gt;&gt;&gt;     dostuff(fname)
&gt;&gt;&gt;    

""" 
 
 
</t>
<t tx="ekr.20090521114145.1929">
Tutorials like the SQLAlchemy one consist of doctests in 
ReST, each section explains a different topic, but the 
doctests build upon each other. This means that each section
requires all the previous sections in order to be valid Python. 

What is needed is the capability for a node to hold a part
of the page, but when summoning doctest or winpdb, the node
tree is ascended building the complete document up to that point.

</t>
<t tx="ekr.20090521114145.1930">
backup IPCop box::

    !/bin/sh

    DATETMP=`date +%Y-%m-%d-%H-%M-%S`
    rm -rf /tmp/IPCop-Backup/IPCop-Backup-*
    tar zcvf /tmp/IPCop-Backup/IPCop-Backup-$DATETMP.tgz / -X /tmp/IPCop-Backup/ignore.txt
    
ignore.txt::
    
    /tmp/IPCop-Backup/IPCop-Backup-*
    /var/log/cache/*
    /proc/*
    /dev/*
    /mnt/*    

</t>
<t tx="ekr.20090521114145.1931">
get UUIDs
 $ sudo blkid
 $ ls -l /dev/disk/by-uuid
 $ sudo vol_id /dev/sda1

put UUIDs
 $ sudo tune2fs -U `uuidgen -t` /dev/sdb1
 
http://www.arsgeek.com/2008/01/02/how-to-find-your-uuids-for-devices-in-ubuntu-and-other-debian-based-distros/

For a little more trivia: A UUID is a 16-byte (128-bit) number. The number of
theoretically possible UUIDs is therefore 216*8 = 2128 = 25616 or about 3.4 x
1038. This means that 1 trillion UUIDs would have to be created every
nanosecond for 10 billion years to exhaust the number of UUIDs. That's a lot of
UUIDs.


</t>
<t tx="ekr.20090521114145.1932">
http://www.stud.umk.pl/~wojtekwa/patches/from-import-py2.5.1.patch::

    --- stary-py-2.5.1/Python/ceval.c	2007-04-16 06:19:52.000000000 +0000
    +++ Python-2.5.1/Python/ceval.c	2008-08-14 00:07:58.000000000 +0000
    @@ -3991,9 +3991,15 @@
     
        x = PyObject_GetAttr(v, name);
        if (x == NULL &amp;&amp; PyErr_ExceptionMatches(PyExc_AttributeError)) {
    +                PyObject *fn;
    +                if((fn = PyObject_GetAttrString(v, "__file__")) == NULL) {
    +                   fn = PyString_FromString("?");
    +                }
    +
            PyErr_Format(PyExc_ImportError,
    -			     "cannot import name %.230s",
    -			     PyString_AsString(name));
    +			     "cannot import name %.230s (%s)",
    +			     PyString_AsString(name),
    +                             PyString_AsString(fn));
        }
        return x;
     }



</t>
<t tx="ekr.20090521114145.1933">
From a catalog-sig post by Ian Bicking

Can't they be normalized?  I.e.::

 re.sub('--+', '-', re.sub('[^a-z0-9]', '-', package.lower()))


</t>
<t tx="ekr.20090521114145.1934">
::

 1) $ find -path "*/.leo_shadow/*" -delete
 2) $ find -name LeoShadow -delete

1- the quotes prevent the shell from expanding, the leading "\*/" allows
subdirectories. This will delete the files in the LeoShadow directories

2- This removes the directories, since they are now empty


</t>
<t tx="ekr.20090521114145.1935">
Run against all +x files found::

 &lt;executable&gt; --help

Harvest the result and put the results into a database, use to discover
consistencies, inconsistencies in option usage. Use to create option reference
source. Use as a backend for a tool which explains command lines.

</t>
<t tx="ekr.20090521114145.1936">
the shell command mkdir -p creates directory trees::

 mkdir -p project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a}

results in::


	/tmp/project/
	|-- bin
	|-- demo
	|   `-- stat
	|       `-- a
	|-- doc
	|   |-- html
	|   |-- info
	|   `-- pdf
	|-- lib
	|   `-- ext
	`-- src

	11 directories, 0 files

- can the -p syntax create arbitrary tree structures?
- could that syntax represent existing arbitrary tree structures?

If yes and yes, code which understands the -p syntax might be useful.
</t>
</tnodes>
</leo_file>
