<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="10" left="412" height="961" width="838"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070416075121" str_leo_pos="6"><vh>Startup</vh>
<v t="ekr.20070529172620"><vh>@chapters</vh>
<v t="ekr.20070529173219"><vh>@chapter abc</vh>
<v t="ekr.20070529173219.1"><vh>abc node 1</vh></v>
<v t="ekr.20071206070207"><vh>cross-chapter-clone-test</vh></v>
</v>
<v t="ekr.20070603190944"><vh>@chapter xyz</vh>
<v t="ekr.20070603190944.1"><vh>xyz node 1</vh></v>
<v t="ekr.20071206070207"></v>
</v>
</v>
<v t="ekr.20070224123943"><vh>@settings</vh>
<v t="ekr.20080922164255.1"><vh>@string test = c:\leo.repo\trunk\leo\test</vh></v>
<v t="ekr.20070701090143"><vh>@@bool force_newlines_in_at_nosent_bodies = False</vh></v>
<v t="ekr.20070504080933"><vh>@bool create_nonexistent_directories = True</vh></v>
<v t="ekr.20080412082246.1"><vh>@bool fixedWindow = False</vh></v>
<v t="ekr.20070604100125"><vh>@bool use_chapter_tabs = True</vh></v>
<v t="ekr.20070503085527"><vh>@bool use_chapters = True</vh></v>
<v t="ekr.20071025193940"><vh>@enabled-plugins</vh></v>
<v t="ekr.20090114100446.1"><vh>@@enabled-plugins (minimal)</vh></v>
<v t="ekr.20080811112727.1"><vh>@@@bool suppress_import_parsing = True</vh></v>
<v t="ekr.20080529111617.1"><vh>plugins</vh>
<v t="ekr.20070723091227"><vh>http plugin</vh>
<v t="ekr.20070723091227.1"><vh>@bool http_active = True</vh></v>
<v t="ekr.20070723091227.2"><vh>@int  port = 8080</vh></v>
<v t="ekr.20070723091227.3"><vh>@string rst_http_attributename = 'rst_http_attribute'</vh></v>
</v>
<v t="ekr.20070305085403"><vh>vim plugin</vh>
<v t="ekr.20070305085403.1"><vh>@string vim_cmd = c:\vim\vim63\gvim --servername LEO</vh></v>
<v t="ekr.20070305085403.2"><vh>@string vim_exe = c:\vim\vim63\gvim</vh></v>
</v>
<v t="ekr.20080529111617.2"><vh>cleo</vh>
<v t="ekr.20080529111617.3"><vh>@color cleo_color_prog_green =</vh></v>
<v t="ekr.20080529111617.4"><vh>@color cleo_color_prog_red =</vh></v>
<v t="ekr.20080529111617.5"><vh>@data cleo_color_file_node_list</vh></v>
<v t="ekr.20080529111617.6"><vh>@int cleo_prog_width = 18</vh></v>
<v t="ekr.20080529111617.7"><vh>@float cleo_time_init = 1.0</vh></v>
<v t="ekr.20080529111617.8"><vh>@int cleo_prog_scale = 1</vh></v>
<v t="ekr.20080529111617.9"><vh>@float cleo_prog_extra = 4</vh></v>
<v t="ekr.20080529111617.10"><vh>@string cleo_time_name = 'days'</vh></v>
</v>
</v>
<v t="ekr.20080604104453.5"><vh>@strings [command,insert, overwrite] top_level_unbound_key_action = insert</vh></v>
<v t="ekr.20080729153237.1"><vh>Gc settings</vh>
<v t="ekr.20080729153237.2"><vh>@bool trace_gc = False</vh></v>
<v t="ekr.20080729153237.3"><vh>@bool trace_gc_calls = False</vh></v>
<v t="ekr.20080729153237.4"><vh>@bool trace_gc_verbose = False</vh></v>
</v>
<v t="ekr.20080822153619.1"><vh>@string shadow_subdir = .leo/shadow</vh></v>
</v>
<v t="ekr.20041001211817"><vh>Buttons</vh>
<v t="ekr.20061030041450"><vh>Run Iron Python scripts</vh>
<v t="ekr.20061030041356"><vh>@url c:\prog\IronPython-1.0.1\Doc\IronPythonApiReference.chm</vh></v>
</v>
<v t="ekr.20070531102813"><vh>Disabled buttons</vh>
<v t="ekr.20060814111542"><vh>@@button add-e</vh></v>
<v t="ekr.20080813100905.1"><vh>@@button args-test @args = a,b,c</vh></v>
<v t="ekr.20060918083159"><vh>@@button Clear uAs</vh></v>
<v t="ekr.20071002150320"><vh>@@button create-canvas</vh></v>
<v t="ekr.20060809084033"><vh>@@button cvt to g.et</vh>
<v t="ekr.20060809104405"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20060809092023"><vh>test</vh>
<v t="ekr.20060809103738"><vh>test1</vh></v>
<v t="ekr.20060809103738.1"><vh>test2</vh></v>
</v>
<v t="ekr.20060809090508"><vh>replace</vh>
<v t="ekr.20060809091749.72"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="ekr.20060809091749.73"><vh>&lt;&lt; handle g.es &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070531104646"><vh>@@button da-comp</vh></v>
<v t="ekr.20070531103315"><vh>@@button da-expand</vh></v>
<v t="ekr.20081025105942.1"><vh>@@button dir</vh></v>
<v t="ekr.20070530072113"><vh>@@button hide-ch</vh></v>
<v t="ekr.20061030041200"><vh>@@button iron-py @key=Alt-5</vh></v>
<v t="ekr.20071025192258"><vh>@@button local-tests @key=Alt+4</vh></v>
<v t="ekr.20071006084354"><vh>@@button print tk line number</vh></v>
<v t="ekr.20080105115712"><vh>@@button pylint</vh>
<v t="ekr.20080115085447"><vh>harmless warnings, errors</vh></v>
<v t="ekr.20080105130903"><vh>warnings</vh></v>
<v t="ekr.20080105120559"><vh>&lt;&lt; define data &gt;&gt;</vh></v>
</v>
<v t="ekr.20070515073111"><vh>@@button sep</vh></v>
<v t="ekr.20060427103457"><vh>@@button settings.leo</vh></v>
<v t="ekr.20080310111916.1"><vh>@@button Translate "can not" to "can't"</vh></v>
<v t="ekr.20070115092430"><vh>@@button winpdb</vh></v>
<v t="ekr.20080815073750.1"><vh>@@button write-nosent-files</vh></v>
<v t="ekr.20071128122043"><vh>@@command create-shell-tab @key = Alt+5</vh></v>
<v t="ekr.20070604095313"><vh>Chapter buttons</vh>
<v t="ekr.20070530072113.1"><vh>@@button show-ch</vh></v>
<v t="ekr.20070603175054.1"><vh>@@button ch-main</vh></v>
<v t="ekr.20070603175054"><vh>@@button ch-abc</vh></v>
<v t="ekr.20070603190713.1"><vh>@@button ch-xyz</vh></v>
<v t="ekr.20070603190713"><vh>@@button ch-add-xyz</vh></v>
</v>
<v t="ekr.20060904110922"><vh>OPML buttons</vh>
<v t="ekr.20060904111037.1"><vh>@@button opml-write</vh></v>
<v t="ekr.20060904111037"><vh>@@button opml-read</vh></v>
</v>
</v>
<v t="ekr.20080915095329.1"><vh>@button rst3</vh></v>
</v>
<v t="ekr.20070410063214"><vh>Commands</vh>
<v t="ekr.20060924180049"><vh>@@command clones-tab</vh>
<v t="ekr.20060924180049.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060924180049.2"><vh>init</vh></v>
<v t="ekr.20060924180049.3"><vh>getAllClones</vh></v>
<v t="ekr.20060924180049.4"><vh>displayClones</vh>
<v t="ekr.20060924180049.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060924180049.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20080214091706.2"><vh>@@command ekr-command</vh></v>
<v t="ekr.20080823154546.1"><vh>@@command parse-python @key = Alt-5</vh></v>
</v>
<v t="ekr.20071026102420.3"><vh>Scripts</vh>
<v t="ekr.20071129103842"><vh>create-at-auto-nodes</vh></v>
<v t="ekr.20070223164126"><vh>Recursive import script</vh>
<v t="ekr.20070223164126.1"><vh>importFiles</vh></v>
<v t="ekr.20070223164126.2"><vh>importDir</vh></v>
<v t="ekr.20070223164126.3"><vh>createLastChildOf</vh></v>
</v>
<v t="ekr.20070517070854"><vh>run script in nullGui</vh></v>
<v t="ekr.20070517071510"><vh>run script with leoBridge</vh></v>
<v t="ekr.20080206055658"><vh>Script to print font settings</vh></v>
</v>
</v>
<v t="ekr.20071025193940" annotate="7d71002855087072696f7269747971015504393939397102550870726f67726573737103550071045509617263686574797065710568045502666771066804752e"></v>
<v t="ekr.20070305085403"></v>
<v t="ekr.20070517160058.1"><vh>Prototypes</vh>
<v t="ekr.20070929062147"><vh>Prototype of networkx graph tools</vh>
<v t="ekr.20070929122956"><vh>Data trees</vh>
<v t="ekr.20070929114617"><vh>@graph-target</vh></v>
<v t="ekr.20070929072043"><vh>@networkx</vh>
<v t="ekr.20070929072506.1"><vh>@nodes</vh></v>
<v t="ekr.20070929072506"><vh>@edges</vh></v>
</v>
<v t="ekr.20070929070257"><vh>@graph</vh>
<v t="ekr.20070929070257.1"><vh>@node child1</vh>
<v t="ekr.20070929070632"><vh>@link ('ekr', '20070929070257', 2): @node child2</vh></v>
</v>
<v t="ekr.20070929070257.2"><vh>@node child2</vh>
<v t="ekr.20070929070632.1"><vh>@link ('ekr', '20070929070257', 1): @node child1</vh></v>
</v>
</v>
<v t="ekr.20070928095102"><vh>root-node</vh>
<v t="ekr.20070928095102.1"><vh>child1</vh></v>
<v t="ekr.20070928095102.2"><vh>child2</vh></v>
</v>
</v>
<v t="ekr.20070929122956.1"><vh>buttons</vh>
<v t="ekr.20070929070426"><vh>@@button print link</vh></v>
<v t="ekr.20070927175908"><vh>@@button leo2graph</vh></v>
<v t="ekr.20070929062147.1"><vh>@@button at-graph2graph</vh></v>
<v t="ekr.20070929062147.2"><vh>@@button at-networkx2graph</vh>
<v t="ekr.20070929081505"><vh>error</vh></v>
<v t="ekr.20070929074830"><vh>parse</vh></v>
<v t="ekr.20070929072506.2"><vh>parseNodes</vh></v>
<v t="ekr.20070929074830.1"><vh>parseEdges</vh></v>
</v>
<v t="ekr.20070929082546"><vh>@@button at-networkx2at-graph</vh>
<v t="ekr.20070929120541"><vh>createEdges</vh></v>
<v t="ekr.20070929120541.1"><vh>createNodes</vh></v>
<v t="ekr.20070929115302"><vh>createTree</vh></v>
<v t="ekr.20070929114410.2"><vh>error</vh></v>
<v t="ekr.20070929114410.3"><vh>parse</vh></v>
<v t="ekr.20070929114410.5"><vh>parseEdges</vh></v>
<v t="ekr.20070929114410.4"><vh>parseNodes</vh></v>
</v>
</v>
</v>
<v t="ekr.20070630142904"><vh>Prototype of pyrex</vh>
<v t="ekr.20070630142904.2"><vh>gcc build docs</vh></v>
<v t="ekr.20070630142904.3"><vh>pyrexc command-line options</vh></v>
<v t="ekr.20070630142904.4"><vh>@@file myModule.pyx</vh></v>
<v t="ekr.20070630142904.5"><vh>Make myModule.c</vh></v>
</v>
<v t="ekr.20071026102420.2"><vh>Screen capture with Wink</vh>
<v t="ekr.20070528111805"><vh>FrontWindowCapture.pyw</vh></v>
<v t="ekr.20070609085533"><vh>@@url c:\prog\wink\ChangeViewMenu.htm</vh></v>
</v>
<v t="edreamleo.20080110083531"><vh>gtk stuff</vh>
<v t="edreamleo.20080110130828"><vh>createWindow</vh></v>
<v t="bob.20080111200056"><vh>@@thin gtkOutlineDemo.py</vh>
<v t="bob.20080111194559"><vh>GtkLeoTreeDemo</vh>
<v t="bob.20080113184034"><vh>__init__</vh></v>
<v t="bob.20080113183321"><vh>onButtonPress</vh></v>
<v t="bob.20080113183321.1"><vh>onButtonRelease</vh></v>
</v>
<v t="bob.20080113170657"><vh>loadIcon</vh></v>
<v t="bob.20080113133525"><vh>loadIcons</vh></v>
<v t="bob.20080113141134"><vh>name2Color</vh></v>
<v t="bob.20080113170041"><vh>getImage</vh></v>
<v t="bob.20080114060133"><vh>getHeadlineFont</vh></v>
<v t="bob.20080111201957.77"><vh>class OutlineCanvasPanel</vh>
<v t="bob.20080111201957.78"><vh>__init__</vh></v>
<v t="bob.20080111201957.79"><vh>showEntry</vh></v>
<v t="bob.20080111201957.80"><vh>hideEntry</vh></v>
<v t="bob.20080111201957.81"><vh>getPositions</vh></v>
<v t="bob.20080111201957.87"><vh>onScrollVertical</vh></v>
<v t="bob.20080113090336"><vh>onScrollHorizontal</vh></v>
<v t="bob.20080111201957.88"><vh>onScrollRelative</vh></v>
<v t="bob.20080111201957.90"><vh>vscrollUpdate</vh></v>
<v t="bob.20080111201957.91"><vh>hscrollUpdate</vh></v>
<v t="bob.20080111201957.92"><vh>update</vh></v>
<v t="bob.20080111201957.93"><vh>redraw</vh></v>
<v t="bob.20080111201957.94"><vh>refresh</vh></v>
<v t="bob.20080111201957.95"><vh>GetName</vh></v>
</v>
<v t="bob.20080111201957.96"><vh>class OutlineCanvas</vh>
<v t="bob.20080111201957.97"><vh>__init__</vh>
<v t="bob.20080111201957.98"><vh>&lt;&lt; define ivars &gt;&gt;</vh></v>
<v t="bob.20080111201957.99"><vh>&lt;&lt; create bindings &gt;&gt;</vh></v>
</v>
<v t="bob.20080111201957.101"><vh>hitTest</vh></v>
<v t="bob.20080111201957.102"><vh>_createNewBuffer</vh></v>
<v t="bob.20080111201957.103"><vh>vscrollTo</vh></v>
<v t="bob.20080113073006"><vh>hscrollTo</vh></v>
<v t="bob.20080111201957.104"><vh>resize</vh></v>
<v t="bob.20080112173505"><vh>redraw</vh></v>
<v t="bob.20080111201957.106"><vh>update</vh>
<v t="bob.20080111201957.107"><vh>&lt;&lt; find height of tree and position of currentNode &gt;&gt;</vh></v>
</v>
<v t="bob.20080111201957.109"><vh>onPaint</vh></v>
<v t="bob.20080112090335"><vh>onMap</vh></v>
<v t="bob.20080112224841"><vh>onSize</vh></v>
<v t="bob.20080111201957.105"><vh>refresh</vh></v>
<v t="bob.20080111201957.110"><vh>contextChanged</vh></v>
<v t="bob.20080111201957.111"><vh>requestLineHeight</vh></v>
<v t="bob.20080111201957.112"><vh>def draw</vh>
<v t="bob.20080111201957.113"><vh>&lt;&lt; draw tree &gt;&gt;</vh>
<v t="bob.20080111201957.114"><vh>&lt;&lt; set up object &gt;&gt;</vh></v>
<v t="bob.20080111201957.115"><vh>&lt;&lt; draw text &gt;&gt;</vh>
<v t="bob.20080111201957.116"><vh>&lt;&lt; draw user icons &gt;&gt;</vh></v>
</v>
<v t="bob.20080111201957.117"><vh>&lt;&lt; draw lines &gt;&gt;</vh></v>
<v t="bob.20080111201957.118"><vh>&lt;&lt; draw bitmaps &gt;&gt;</vh></v>
<v t="bob.20080111201957.119"><vh>&lt;&lt; draw focus &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20080503202744.3"><vh>Rope</vh></v>
<v t="ekr.20080531131542.1"><vh>mxTextTools proto</vh>
<v t="ekr.20080531141227.1"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
<v t="ekr.20080531131542.2"><vh>&lt;&lt; define scan4 tables &gt;&gt;</vh></v>
<v t="ekr.20080531131542.4"><vh>printItem</vh></v>
</v>
<v t="ekr.20080806145258.12"><vh>Prototype of Leo in Ajax</vh>
<v t="ekr.20080806145258.13"><vh>To do</vh></v>
<v t="ekr.20080806145258.14"><vh>@@button Leo2DHTML</vh>
<v t="ekr.20080806145258.15"><vh>&lt;&lt; about LeoToHTML &gt;&gt;</vh></v>
<v t="ekr.20080806145258.16"><vh>&lt;&lt; define dhtml stuff &gt;&gt;</vh></v>
<v t="ekr.20080806145258.17"><vh>escape</vh></v>
<v t="ekr.20080806145258.18"><vh>writeAll</vh></v>
<v t="ekr.20080806145258.19"><vh>writeBody</vh></v>
<v t="ekr.20080806145258.20"><vh>writeHead</vh></v>
<v t="ekr.20080806145258.21"><vh>writeContents</vh></v>
<v t="ekr.20080806145258.22"><vh>writePreamble</vh></v>
<v t="ekr.20080806145258.23"><vh>writePostamble</vh></v>
</v>
<v t="ekr.20080806145258.24"><vh>@@file server.py</vh></v>
<v t="ekr.20080806145258.25"><vh>@@file hello.html</vh></v>
<v t="ekr.20080806145258.26"><vh>@@file cgi-bin/edward.py</vh>
<v t="ekr.20080806145702.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20080806145258.27"><vh>&lt;&lt; define dhtml stuff &gt;&gt;</vh></v>
<v t="ekr.20080806145258.28"><vh>escape</vh></v>
<v t="ekr.20080806145258.29"><vh>print_all</vh></v>
<v t="ekr.20080806145258.30"><vh>print_body</vh></v>
<v t="ekr.20080806145258.31"><vh>print_head</vh></v>
<v t="ekr.20080806145258.32"><vh>print_leo_dot_js</vh></v>
<v t="ekr.20080806145258.33"><vh>print_tree</vh></v>
</v>
<v t="ekr.20080806145258.1"><vh>@@thin cgi-bin/leo.js</vh>
<v t="ekr.20080806145258.2"><vh>getElementbyClass</vh></v>
<v t="ekr.20080806145258.3"><vh>contractcontent</vh></v>
<v t="ekr.20080806145258.4"><vh>expandcontent</vh></v>
<v t="ekr.20080806145258.5"><vh>revivecontent</vh></v>
<v t="ekr.20080806145258.6"><vh>get_cookie</vh></v>
<v t="ekr.20080806145258.7"><vh>getselectedItem</vh></v>
<v t="ekr.20080806145258.8"><vh>saveswitchstate</vh></v>
<v t="ekr.20080806145258.9"><vh>do_onload</vh></v>
<v t="ekr.20080806145258.10"><vh>format</vh></v>
<v t="ekr.20080806145258.11"><vh>formatText</vh></v>
</v>
<v t="ekr.20080806145258.34"><vh>@@thin jqueryTest.html</vh></v>
</v>
<v t="ekr.20080811113441.2"><vh>Running body text as a windows script</vh>
<v t="ekr.20080807115344.1"><vh>Windows script</vh></v>
<v t="ekr.20080807114145.2"><vh>@@button run-windows-script</vh>
<v t="ekr.20080807115344.5"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20080807115344.2"><vh>class MySite</vh></v>
<v t="ekr.20080807115344.3"><vh>class Application</vh></v>
<v t="ekr.20080807115344.4"><vh>RunCode</vh></v>
</v>
</v>
<v t="ekr.20080929112400.1"><vh>qt proto</vh></v>
<v t="ekr.20081202095209.1"><vh>Put minibuffer in a toolbar</vh></v>
<v t="ekr.20090107082739.1"><vh>replace redirectScriptOutput</vh></v>
<v t="ekr.20090102095951.1"><vh>posList</vh>
<v t="ekr.20090102095951.2"><vh>node a</vh></v>
<v t="ekr.20090102095951.3"><vh>node b</vh></v>
</v>
</v>
<v t="ekr.20071105085941"><vh>Tests</vh>
<v t="ekr.20081216091605.2"><vh>@@auto under_indent.py</vh>
<v t="ekr.20090122211549.1"><vh>class test</vh>
<v t="ekr.20090122211549.2"><vh>spam</vh></v>
</v>
</v>
<v t="edward.20081127113749.1"><vh>@commands</vh>
<v t="edward.20081127113749.2"><vh>@command complete-previous</vh>
<v t="edward.20081127113749.3"><vh>WordCompleter</vh>
<v t="edward.20081127113749.4"><vh>complete_word</vh>
<v t="edward.20081127113749.5"><vh>&lt;&lt;backward search&gt;&gt;</vh>
<v t="edward.20081127113749.6"><vh>&lt;&lt;counter check&gt;&gt;</vh></v>
</v>
<v t="edward.20081127113749.7"><vh>&lt;&lt;forward search&gt;&gt;</vh>
<v t="edward.20081127113749.6"></v>
</v>
<v t="edward.20081127113749.8"><vh>&lt;&lt;clean up and exit&gt;&gt;</vh></v>
</v>
<v t="edward.20081127113749.9"><vh>acceptable_word</vh></v>
<v t="edward.20081127113749.10"><vh>undo_replacement</vh></v>
<v t="edward.20081127113749.11"><vh>redo_replacement</vh></v>
<v t="edward.20081127113749.12"><vh>exit</vh></v>
<v t="edward.20081127113749.13"><vh>run</vh></v>
<v t="edward.20081127113749.14"><vh>adjust</vh></v>
</v>
<v t="edward.20081127113749.15"><vh>getCurrentWord</vh></v>
</v>
<v t="edward.20081127113749.16"><vh>@command complete-next</vh>
<v t="edward.20081127113749.3"></v>
<v t="edward.20081127113749.15"></v>
</v>
</v>
<v t="ekr.20081124102740.1"><vh>Accented characters</vh></v>
<v t="ekr.20081020082611.1"><vh>Calling a base class method</vh></v>
<v t="ekr.20080628094340.1"><vh>Decorator test</vh></v>
<v t="edward.20081221145716.1"><vh>decorator test 2</vh></v>
<v t="ekr.20080617170334.1"><vh>Determining key values</vh></v>
<v t="ekr.20080920101658.1"><vh>getInput</vh></v>
<v t="ekr.20080917063615.1"><vh>getSettingSource</vh></v>
<v t="ekr.20080930114036.1"><vh>icon stuff</vh>
<v t="ekr.20080930080501.1"><vh>Add icon row</vh></v>
<v t="ekr.20080930083052.1"><vh>hide icon rows</vh></v>
<v t="ekr.20080930083052.2"><vh>show icon rows</vh></v>
<v t="ekr.20080930085514.1"><vh>clear icon bar</vh></v>
</v>
<v t="ekr.20081006070847.2"><vh>path convenience methods</vh></v>
<v t="ekr.20080701130406.1"><vh>plugins</vh></v>
<v t="ekr.20081205104320.1"><vh>run bash script</vh></v>
<v t="ekr.20080923173133.1"><vh>scan-directives hook</vh></v>
<v t="ekr.20080604101239.1"><vh>Test misspelled word at index 0</vh></v>
<v t="ekr.20080924081821.1"><vh>test of autoCompleter.getExternalCompletions</vh></v>
<v t="ekr.20080813080809.1"><vh>Tests for @shadow</vh>
<v t="ekr.20080807091001.1"><vh>@@shadow python-import-test.py</vh>
<v t="ekr.20080807091201.7"><vh>python-import-test declarations</vh></v>
<v t="ekr.20080807091201.8"><vh>class Person</vh>
<v t="ekr.20080807091201.9"><vh>talk</vh></v>
<v t="ekr.20080807091201.10"><vh>class Meta</vh></v>
</v>
</v>
<v t="ekr.20080812112440.1"><vh>@@shadow at-shadow-test.ini</vh></v>
<v t="ekr.20080812135254.1"><vh>@@shadow at-unknown-shadow-test.xyzzy</vh></v>
<v t="ekr.20080801160915.1"><vh>@@shadow TerryBrownTest.py</vh>
<v t="ekr.20080803120643.1"><vh>spam</vh></v>
</v>
<v t="ekr.20080812102914.1"><vh>@@nosent at-nosent-test.py</vh>
<v t="ekr.20080812102914.2"><vh>child</vh></v>
</v>
<v t="ekr.20080813080627.1"><vh>@@shadow at-shadow-attributes-test.py</vh>
<v t="ekr.20080813080627.2"><vh>spam</vh>
<v t="ekr.20080813080729.1"><vh>child</vh></v>
</v>
<v t="ekr.20080813080627.3"><vh>eggs</vh></v>
</v>
<v t="ekr.20080819095720.1"><vh>@@shadow huh_extension_test.huh</vh></v>
<v t="ekr.20080909075224.1"><vh>@@shadow ekr-shadow-test.html</vh></v>
<v t="ekr.20080911080311.1"><vh>@@shadow dummy.conf</vh></v>
<v t="ekr.20080924033317.1"><vh>@@shadow weird-extension.C</vh>
<v t="ekr.20080924033317.2"><vh>spam</vh></v>
</v>
<v t="ekr.20081001110047.1"><vh>@@shadow mark-changed-nodes-test.py</vh>
<v t="ekr.20081001110047.2"><vh>spam</vh></v>
<v t="ekr.20081001110047.3"><vh>eggs</vh></v>
</v>
</v>
<v t="ekr.20080922164656.1"><vh>Tests of path expressions</vh>
<v t="ekr.20080921144924.1"><vh>Tests of g.os_path_finalize</vh></v>
<v t="ekr.20080922142953.1"><vh>test os_pathExpression</vh></v>
<v t="ekr.20080922164255.1"></v>
<v t="ekr.20080922164255.2"><vh>@@shadow {{c.config.getString('test')}}/eval-shadow-test.txt</vh></v>
<v t="ekr.20080923073240.2"><vh>@path {{c.config.getString('test')}}</vh>
<v t="ekr.20080923073240.1"><vh>@@thin eval-thin-test.txt</vh></v>
</v>
</v>
<v t="ekr.20080531080812.1"><vh>tracer test</vh></v>
<v t="ekr.20081003094737.1"><vh>Unicode tests</vh>
<v t="ekr.20080701101740.1"><vh>locale tests</vh></v>
<v t="ekr.20080821111715.1"><vh>Standard print test (only works for Latin-1 and ascii)</vh></v>
</v>
<v t="ekr.20080610144233.1"><vh>Wrap test</vh></v>
<v t="ekr.20090128112453.1" key="550378797a71002e"><vh>Property tests</vh></v>
<v t="ekr.20090128131130.1"><vh>posList tests</vh></v>
<v t="ekr.20090212084402.1"><vh>qtGui.py (big)</vh></v>
<v t="ekr.20090201162523.1"><vh>Macro test</vh></v>
<v t="ekr.20090201192257.1"><vh>@test macro ab</vh></v>
<v t="ekr.20090211123924.1"><vh>String test</vh></v>
<v t="ekr.20090205070715.1"><vh>print colorer stats</vh></v>
<v t="ekr.20090206065021.1"><vh>test string flipping</vh></v>
<v t="ekr.20090217151906.1"><vh>@@thin test.py</vh>
<v t="ekr.20090218121844.1"><vh>child</vh></v>
</v>
<v t="ekr.20090218112656.1"><vh>@test self.assertEqual</vh></v>
</v>
<v t="ekr.20090304073837.1"><vh>Undo editing</vh></v>
<v t="ekr.20090304173642.1"><vh>@button moveAfterRoot</vh></v>
</vnodes>
<tnodes>
<t tx="bob.20080111194559">@first


class GtkLeoTreeDemo(object):


    @others</t>
<t tx="bob.20080111200056">@first #!/usr/bin/python
import sys, os



import pygtk
pygtk.require('2.0')
import gtk

import pango
import cairo

@others

def abspath(*args):
    return os.path.abspath(os.path.join(*args))



if __name__ == "__main__": 

    leoDir = abspath(sys.path[0],'..')
    sys.path[1:1] = [abspath(leoDir, '..')]

    import leo.core.leoGlobals as g
    g.g = g

    import leo.core.leoBridge as leoBridge

    controller = leoBridge.controller(gui='nullGui')
    c = controller.openLeoFile(abspath(leoDir, 'test', 'unitTest.leo'))

    outlineFont = ''

    colors = g.importExtension('colors')

    GtkLeoTreeDemo()

    gtk.main()


</t>
<t tx="bob.20080111201957.77">
class OutlineCanvasPanel(object):
    """A class to mimic a scrolled window to contain an OutlineCanvas."""

    @others
</t>
<t tx="bob.20080111201957.78">
def __init__(self, parent, leoTree, name):
    """Create an OutlineCanvasPanel instance."""

    #g.trace('OutlineCanvasPanel')

    #self._leoTree = leoTree
    #self.c = leoTree.c
    self.c = c

    self._x = 0
    self._y = 0

    self._canvas = canvas = OutlineCanvas(self)
    #canvas.resize(400, 300)

    self._table = gtk.Table(2,2)

    self._hscrollbar = gtk.HScrollbar()
    self._vscrollbar = gtk.VScrollbar()

    self._hadj = h = self._hscrollbar.get_adjustment()
    self._vadj = v = self._vscrollbar.get_adjustment()

    self._hscrollbar.set_range(0, 10)
    self._vscrollbar.set_range(0, 20)


    v.connect('value-changed', self.onScrollVertical)
    h.connect('value-changed', self.onScrollHorizontal)

    self._table.attach(self._hscrollbar, 0, 1, 1, 2, yoptions=0)
    self._table.attach(self._vscrollbar, 1, 2, 0, 1, xoptions=0)


    options = gtk.SHRINK | gtk.FILL | gtk.EXPAND
    self._table.attach(self._canvas, 0, 1, 0, 1, options, options)

    parent.add(self._table)

    self._canvas.set_events(
        gtk.gdk.POINTER_MOTION_MASK |
                gtk.gdk.POINTER_MOTION_HINT_MASK
    )


    #self._entry = wx.TextCtrl(self._canvas,
    #    style = wx.SIMPLE_BORDER | wx.WANTS_CHARS
    #)

    #self._entry._virtualTop = -1000
    #self._entry.Hide()
    #self._canvas._widgets.append(self._entry)

    #self._canvas.update()


    # self.Bind(wx.EVT_SIZE, self.onSize)


    #self.SetBackgroundColour(self._leoTree.outline_pane_background_color)

    #self.Bind(wx.EVT_CHAR,
    #    lambda event, self=self._leoTree: onGlobalChar(self, event)
    #)

    #self.onScroll(wx.HORIZONTAL, 0)

</t>
<t tx="bob.20080111201957.79">showcount = 0
def showEntry(self):

    # self.showcount +=1

    # print
    # g.trace(self.showcount, g.callers(20))
    # print

    entry = self._entry
    canvas = self._canvas

    ep = self._leoTree.editPosition()

    if not ep:
        return self.hideEntry()


    for sp in canvas._positions:
        if ep == sp:
            break
    else:
        return self.hideEntry()

    x, y, width, height = sp._textBoxRect
    #g.pr('	', x, y, width , height)

    entry._virtualTop = canvas._virtualTop + y -2

    entry.MoveXY(x - 2, y -2)
    entry.SetSize((max(width + 4, 100), -1))

    tw = self._leoTree.headlineTextWidget

    range = tw.getSelectionRange()
    tw.setInsertPoint(0)
    #tw.setInsertPoint(len(sp.headString()))
    tw.setSelectionRange(*range)
    entry.Show()
</t>
<t tx="bob.20080111201957.80">
def hideEntry(self):

    entry = self._entry
    entry._virtualTop = -1000
    entry.MoveXY(0, -1000)

    entry.Hide()
</t>
<t tx="bob.20080111201957.81">
def getPositions(self):
    return self._canvas._positions</t>
<t tx="bob.20080111201957.87">def onScrollVertical(self, adjustment):
    """Scroll the outline vertically to a new position."""

    self._canvas.vscrollTo(int(adjustment.value))</t>
<t tx="bob.20080111201957.88">
def onScrollRelative(self, orient, value):

    return self.onScroll(orient, self.GetScrollPos(orient) + value)
</t>
<t tx="bob.20080111201957.90">
def vscrollUpdate(self):
    """Set the vertical scroll bar to match current conditions."""

    canvas = self._canvas

    oldtop = top = canvas._virtualTop
    canvasHeight = canvas.get_allocation().height
    treeHeight = canvas._treeHeight

    if (treeHeight - top) &lt; canvasHeight:
        top = treeHeight - canvasHeight

    if top &lt; 0 :
        top = 0

    if oldtop != top:
        canvas._virtualTop = top
        canvas.redraw()
        top = canvas._virtualTop

    #self.showEntry()

    self._vadj.set_all(
        top, #value
        0, #lower
        treeHeight, #upper
        canvasHeight * 0.1, #step_increment
        canvasHeight * 0.9, #page_increment
        canvasHeight #page-size
    )


</t>
<t tx="bob.20080111201957.91">
def hscrollUpdate(self):
    """Set the vertical scroll bar to match current conditions."""

    canvas = self._canvas

    oldleft = left = canvas._virtualLeft
    canvasWidth = canvas.get_allocation().width
    treeWidth = canvas._treeWidth

    if (treeWidth - left) &lt; canvasWidth:
        left = treeWidth - canvasWidth

    if left &lt; 0 :
        left = 0

    if oldleft != left:
        canvas._virtualLeft = left
        canvas.redraw()
        left = canvas._virtualLeft

    #self.showEntry()

    self._hadj.set_all(
        left, #value
        0, #lower
        treeWidth, #upper
        canvasWidth * 0.1, #step_increment
        canvasWidth * 0.9, #page_increment
        canvasWidth #page-size
    )

</t>
<t tx="bob.20080111201957.92">
def update(self):
    self._canvas.update()


</t>
<t tx="bob.20080111201957.93">
def redraw(self):
    self._canvas.redraw()</t>
<t tx="bob.20080111201957.94">def refresh(self):
    self._canvas.refresh()</t>
<t tx="bob.20080111201957.95">def GetName(self):
    return 'canvas'

getName = GetName</t>
<t tx="bob.20080111201957.96">class OutlineCanvas(gtk.DrawingArea):
    """Implements a virtual view of a leo outline tree.

    The class uses an off-screen buffer for drawing which it
    blits to the window during paint calls for expose events, etc,

    A redraw is only required when the size of the canvas changes,
    a scroll event occurs, or if the outline changes.

    """
    @others
</t>
<t tx="bob.20080111201957.97">def __init__(self, parent):
    """Create an OutlineCanvas instance."""

    #g.trace('OutlineCanvas')

    self.c = c = parent.c

    self._parent = parent
    #self.leoTree = parent.leoTree


    &lt;&lt; define ivars &gt;&gt;

    gtk.DrawingArea.__init__(self)
    self._pangoLayout = self.create_pango_layout("Wq")


    # g.trace()


    self._font = pango.FontDescription(outlineFont)

    self._pangoLayout.set_font_description(self._font)


    self._buffer = None

    self.contextChanged()

    #self.Bind(wx.EVT_PAINT, self.onPaint)

    self.connect('map-event', self.onMap)


    #for o in (self, parent):
    #    &lt;&lt; create  bindings &gt;&gt;

@
self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height

</t>
<t tx="bob.20080111201957.98">#self._icons = icons

self._widgets = []

self.drag_p = None

self._size =  [1000, 1000]

self._virtualTop = 0
self._virtualLeft = 0

self._textIndent = 30

self._xPad = 30
self._yPad = 2

self._treeHeight = 500
self._treeWidth = 500

self._positions = []

self._fontHeight = None
self._iconSize = [20, 11]

self._clickBoxSize = None
self._lineHeight =  10
self._requestedLineHeight = 10

self._yTextOffset = None
self._yIconOffset = None

self._clickBoxCenterOffset = None

self._clickBoxOffset = None


</t>
<t tx="bob.20080111201957.99"># onmouse = self._leoTree.onMouse

# for e, s in (
   # ( wx.EVT_LEFT_DOWN,     'LeftDown'),
   # ( wx.EVT_LEFT_UP,       'LeftUp'),
   # ( wx.EVT_LEFT_DCLICK,   'LeftDoubleClick'),
   # ( wx.EVT_MIDDLE_DOWN,   'MiddleDown'),
   # ( wx.EVT_MIDDLE_UP,     'MiddleUp'),
   # ( wx.EVT_MIDDLE_DCLICK, 'MiddleDoubleClick'),
   # ( wx.EVT_RIGHT_DOWN,    'RightDown'),
   # ( wx.EVT_RIGHT_UP,      'RightUp'),
   # ( wx.EVT_RIGHT_DCLICK,  'RightDoubleClick'),
   # ( wx.EVT_MOTION,        'Motion')
# ):
    # o.Bind(e, lambda event, type=s: onmouse(event, type))



# #self.Bind(wx.EVT_KEY_UP, self._leoTree.onChar)
# #self.Bind(wx.EVT_KEY_DOWN, lambda event: self._leoTree.onKeyDown(event))

# self.Bind(wx.EVT_CHAR,
    # lambda event, self=self._leoTree: onGlobalChar(self, event)
# )

</t>
<t tx="bob.20080111201957.101">def hitTest(self, x, y):
    result = self._hitTest(point)
    g.trace(result)
    return result

def hitTest(self, xx, yy):

    for sp in self._positions:

        if yy &lt; (sp._top + self._lineHeight):

            x, y, w, h = sp._clickBoxRect
            if xx &gt; x  and xx &lt; (x + w) and yy &gt; y and yy &lt; (y + h):
                return sp, 'ClickBox'

            x, y, w, h = sp._iconBoxRect
            if xx &gt; x  and xx &lt; (x + w) and yy &gt; y and yy &lt; (y + h):
                return sp, 'IconBox'

            x, y, w, h = sp._textBoxRect
            if xx &gt; x  and xx &lt; (x + w) and yy &gt; y and yy &lt; (y + h): 
                return sp, 'TextBox'

            i = -1  
            for x, y, w, h in sp._headStringIcons:
                i += 1
                if xx &gt; x  and xx &lt; (x + w) and yy &gt; y and yy &lt;(y + h):
                   return sp, i

            return sp, 'Headline'

    return None, 'Canvas'

</t>
<t tx="bob.20080111201957.102">def _createNewBuffer(self):
    """Create a new buffer for drawing."""


    if not self.window:
        g.trace('no window !!!!!!!!!!!!!!!!')
        g.trace(g.callers())
        return


    w, h = self.window.get_size()
    #g.trace(g.callers())


    if self._buffer:
        bw, bh = self._buffer.get_size()
        if bw &gt;= w and bh &gt;= h:
            return

    self._buffer = gtk.gdk.Pixmap(self.window, w, h)





</t>
<t tx="bob.20080111201957.103">
def vscrollTo(self, pos):
    """Scroll the canvas vertically to the specified position."""

    canvasHeight = self.get_allocation().height
    if (self._treeHeight - canvasHeight) &lt; pos :
        pos = self._treeHeight - canvasHeight

    pos = max(0, pos)

    self._virtualTop = pos

    self.redraw()
</t>
<t tx="bob.20080111201957.104">
def resize(self):
    """Resize the outline canvas and, if required, create and draw on a new buffer."""

    c = self.c

    #c.beginUpdate()     #lock out events
    if 1: #try:

        self._createNewBuffer()

        #self._parent.hscrollUpdate()


        self.draw()
        self.refresh()


    #finally:
    #    c.endUpdate(False)


    return True





</t>
<t tx="bob.20080111201957.105">
#def refresh(self):
    # """Renders the offscreen buffer to the outline canvas."""
    # return

    # #g.pr('refresh')
    # wx.ClientDC(self).BlitPointSize((0,0), self._size, self._buffer, (0, 0))

refresh = onPaint</t>
<t tx="bob.20080111201957.106">
def update(self):
    """Do a full update assuming the tree has been changed."""

    c = self.c

    canvasHeight = self.get_allocation().height

    hoistFlag = bool(self.c.hoistStack)

    if hoistFlag:
        stk = [self.c.hoistStack[-1].p]
    else:
        stk = [self.c.rootPosition()]

    &lt;&lt; find height of tree and position of currentNode &gt;&gt;

    if (self._treeHeight - self._virtualTop) &lt; canvasHeight:
        self._virtualTop = self._treeHeight - canvasHeight

    # if (self._treeHeight - self._virtualTop) &lt; canvasHeight:
        # self._virtualTop = self._treeHeight - canvasHeight

    self.contextChanged()

    self.redraw()
    self._parent.vscrollUpdate()
    self._parent.hscrollUpdate()


</t>
<t tx="bob.20080111201957.107">
# Find the number of visible nodes in the outline.

cp = c.currentPosition().copy()
cpCount = None

count = 0
while stk:

    p = stk.pop()

    while p:


        if stk or not hoistFlag:
            newp = p.next()
        else:
            newp = None

        if cp and cp == p:
            cpCount = count
            cp = False

        count += 1

        if p.isExpanded() and p.hasFirstChild():
            stk.append(newp)
            p = p.firstChild()
            continue

        p = newp

lineHeight = self._lineHeight

self._treeHeight = count * lineHeight
g.trace( 'treeheight ', self._treeHeight)

if cpCount is not None:
    cpTop = cpCount * lineHeight

    if cpTop &lt; self._virtualTop:
        self._virtualTop = cpTop

    elif cpTop + lineHeight &gt; self._virtualTop + canvasHeight:
        self._virtualTop += (cpTop + lineHeight) - (self._virtualTop + canvasHeight)



</t>
<t tx="bob.20080111201957.109">
def onPaint(self, *args):
    """Renders the off-screen buffer to the outline canvas."""

    # w, h are needed because the buffer may be bigger than the window.

    w, h = self.window.get_size()

    # We use self.style.black_gc only because we need a gc, it has no relavence.

    self.window.draw_drawable(self.style.black_gc ,self._buffer, 0, 0, 0, 0, w, h)
</t>
<t tx="bob.20080111201957.110">def contextChanged(self):
    """Adjust canvas attributes after a change in context.

    This should be called after setting or changing fonts or icon size or
    anything that effects the tree display.

    """

    self._pangoLayout.set_text('Wy')
    self._fontHeight = self._pangoLayout.get_pixel_size()[1]
    self._iconSize = (20, 11) #(icons[0].GetWidth(), icons[0].GetHeight())

    self._clickBoxSize = (9, 9) #(plusBoxIcon.GetWidth(), plusBoxIcon.GetHeight())

    self._lineHeight = max(
        self._fontHeight,
        self._iconSize[1],
        self._requestedLineHeight
    ) + 2 * self._yPad

    # y offsets

    self._yTextOffset = (self._lineHeight - self._fontHeight)//2

    self._yIconOffset = (self._lineHeight - self._iconSize[1])//2

    self._clickBoxCenterOffset = (
        -self._textIndent*2 + self._iconSize[0]//2,
        self._lineHeight//2
    )

    self._clickBoxOffset = (
        self._clickBoxCenterOffset[0] - self._clickBoxSize[0]//2,
        (self._lineHeight  - self._clickBoxSize[1])//2
    )


</t>
<t tx="bob.20080111201957.111">def requestLineHeight(height):
    """Request a minimum height for lines."""

    assert int(height) and height &lt; 200
    self.requestedHeight = height
    self.beginUpdate()
    self.endUpdate()
</t>
<t tx="bob.20080111201957.112">
def draw(self, *args):
    """Draw the outline on the off-screen buffer."""

    r, g, b = colors.getColorRGB('leoyellow')
    r, g, b = r/255.0, g/255.0, b/255.0

    x, y, canvasWidth, canvasHeight = self.get_allocation()


    pangoLayout = self._pangoLayout


    cr = self._buffer.cairo_create()


    cr.set_source_rgb(r, g, b)
    cr.rectangle(x, y, canvasWidth, canvasHeight)
    cr.fill()

    c = self.c


    top = self._virtualTop
    if top &lt; 0:
        self._virtualTop = top = 0

    left = self._virtualLeft
    if left &lt; 0:
        self._virtualLeft = left = 0   


    bottom = top + canvasHeight


    textIndent = self._textIndent
    treeWidth = self._treeWidth

    yPad = self._yPad
    xPad = self._xPad - left

    yIconOffset = self._yIconOffset

    yTextOffset = self._yTextOffset

    clickBoxOffset_x, clickBoxOffset_y = self._clickBoxOffset

    clickBoxCenterOffset_x, clickBoxCenterOffset_y = \
        self._clickBoxCenterOffset

    clickBoxSize_w, clickBoxSize_h = self._clickBoxSize

    iconSize_w, iconSize_h = self._iconSize

    lineHeight = self._lineHeight
    halfLineHeight = lineHeight//2

    &lt;&lt; draw tree &gt;&gt;

    #self._parent.showEntry()

    return True






</t>
<t tx="bob.20080111201957.113">y = 0

hoistFlag = bool(c.hoistStack)

if hoistFlag:
    stk = [c.hoistStack[-1].p]
else:
    stk = [c.rootPosition()]

self._positions = positions = []

@
My original reason for writing the loop this way was to make it as fast as
possible. Perhaps I was being a bit too paranoid and we should change back to
more conventional iterations, on the other hand if it ain't broke don't fix it.
@c


while stk:

    p = stk.pop()

    while p:

        if stk or not hoistFlag:
            newp = p.next()
        else:
            newp = None

        mytop = y
        y = y + lineHeight

        if mytop &gt; bottom:
            stk = []
            p = None
            break

        if y &gt; top:

            sp = p.copy()

            &lt;&lt; setup object &gt;&gt;

            positions.append(sp)

            treeWidth = max(
                treeWidth,
                textSize_w + xTextOffset + left
            )

        if p.isExpanded() and p.hasFirstChild():
            stk.append(newp)
            p = p.firstChild()
            continue

        p = newp

if treeWidth &gt; self._treeWidth:
    # theoretically this could be recursive
    # but its unlikely ...
    self._treeWidth = treeWidth
    self._parent.hscrollUpdate()

if not positions:
    #g.trace('No positions!')
    return

self._virtualTop =  positions[0]._virtualTop


# try:
    # result = self._leoTree.drawTreeHook(self)
    # g.pr('result =', result)
# except:
    # result = False
    # g.pr('result is False')

# if hasattr(self._leoTree, 'drawTreeHook'):
    # try:
        # result = self._leoTree.drawTreeHook(self)
    # except:
        # result = False
# else:
    # #g.pr('drawTreeHook not known')
    # result = None

# if not result:
if 1:
    &lt;&lt; draw text &gt;&gt;
    &lt;&lt; draw lines &gt;&gt;
    &lt;&lt; draw bitmaps &gt;&gt;

    &lt;&lt; draw focus &gt;&gt;




</t>
<t tx="bob.20080111201957.114"># depth: the depth of indentation relative to the current hoist.
sp._depth = len(stk)

# virtualTop: top of the line in virtual canvas coordinates
sp._virtualTop =  mytop

# top: top of the line in real canvas coordinates
sp._top = mytop - top


pangoLayout.set_text(sp.headString())

textSize_w, textSize_h = pangoLayout.get_pixel_size()

xTextOffset = ((sp._depth +1) * textIndent) + xPad

textPos_x = xTextOffset # - self._hadj.value
textPos_y =  sp._top + yTextOffset

iconPos_x = textPos_x - textIndent
iconPos_y = textPos_y + yIconOffset

clickBoxPos_x = textPos_x + clickBoxOffset_x
clickBoxPos_y = textPos_y + clickBoxOffset_y

sp._clickBoxCenter_x = clickBoxPos_x + clickBoxCenterOffset_x
sp._clickBoxCenter_y = clickBoxPos_y + clickBoxCenterOffset_y

sp._textBoxRect = [textPos_x, textPos_y, textSize_w, textSize_h]
sp._iconBoxRect = [iconPos_x, iconPos_y, iconSize_w, iconSize_h]
sp._clickBoxRect = [clickBoxPos_x, clickBoxPos_y, clickBoxSize_w, clickBoxSize_h]

sp._icon = icons[p.v.computeIcon()]


if sp.hasFirstChild():
    sp._clickBoxIcon = plusBoxIcon
    if sp.isExpanded():
        sp._clickBoxIcon = minusBoxIcon
else:
    sp._clickBoxIcon = None

sp._clickRegions = []

</t>
<t tx="bob.20080111201957.115">
current = c.currentPosition()



for sp in positions:

    &lt;&lt; draw user icons &gt;&gt;

    # if current and current == sp:
        # dc.SetBrush(wx.LIGHT_GREY_BRUSH)
        # dc.SetPen(wx.LIGHT_GREY_PEN)
        # dc.DrawRectangleRect(
            # wx.Rect(*sp._textBoxRect).Inflate(3, 3)
        # )
        # current = False
        # #dc.SetBrush(wx.TRANSPARENT_BRUSH)
        # #dc.SetPen(wx.BLACK_PEN)


    pangoLayout.set_text(sp.headString())
    x, y, w, h = sp._textBoxRect
    cr.set_source_rgb(0, 0, 0)
    cr.move_to(x, y)
    #cr.update_layout(pangoLayout)
    cr.show_layout(pangoLayout)


</t>
<t tx="bob.20080111201957.116">

try:
    headStringIcons = sp.v.t.unknownAttributes.get('icons', [])
except:
    headStringIcons = None

sp._headStringIcons = hsi = []

if headStringIcons:

    for headStringIcon in headStringIcons:
        try:
            image = globalImages[headStringIcon['relPath']]
        except KeyError:
            path = headStringIcon['relPath']
            image = getImage(path)
            if image is None:
                return


        x, y, w, h = sp._textBoxRect

        hsi.append((x, y, image.get_width(), image.get_height()))       

        cr.set_source_pixbuf(image, x, y)
        cr.paint()

        sp._textBoxRect[0] = x + image.get_width() + 5

</t>
<t tx="bob.20080111201957.117"></t>
<t tx="bob.20080111201957.118">
for sp in positions:

    x, y, w, h = sp._iconBoxRect

    cr.set_source_pixbuf(sp._icon,x,y)
    cr.paint()
    #cr.stroke()

    if sp._clickBoxIcon:
        x, y, w, h = sp._clickBoxRect
        cr.set_source_pixbuf(sp._clickBoxIcon, x, y)
        cr.paint()

@
  ctx = da.window.cairo_create()
  # You can put ctx.scale(..) or ctx.rotate(..) here, if you need some
  ct = gtk.gdk.CairoContext(ctx)
  ct.set_source_pixbuf(pixbuf,0,0)
  ctx.paint()
  ctx.stroke()




</t>
<t tx="bob.20080111201957.119">if 0:
    dc.SetBrush(wx.TRANSPARENT_BRUSH)
    if self._leoTree.hasFocus():
        dc.SetPen(wx.BLACK_PEN)
    #else:
    #    dc.SetPen(wx.GREEN_PEN)
        dc.DrawRectanglePointSize( (0,0), self.GetSize())</t>
<t tx="bob.20080112090335">def onMap(self, *args):
    self._createNewBuffer()
    self.update()
    self.connect('expose-event', self.onPaint)
    self.connect("size-allocate", self.onSize)
</t>
<t tx="bob.20080112173505">def redraw(self):
    self.draw()
    self.refresh()
</t>
<t tx="bob.20080112224841">def onSize(self, *args):
    """React to changes in the size of the outlines display area."""


    c = self.c
    c.beginUpdate()
    try:
        self.resize()
        self._parent.vscrollUpdate()
        self._parent.hscrollUpdate()
    finally:
        c.endUpdate(False)


</t>
<t tx="bob.20080113073006">def hscrollTo(self, pos):
    """Scroll the canvas vertically to the specified position."""

    canvasWidth = self.get_allocation().width

    #g.trace(pos)

    if (self._treeWidth - canvasWidth) &lt; pos :
        pos = min(0, self._treeWidth - canvasWidth)

    pos = max( 0, pos)

    self._virtualLeft = pos

    self.redraw()
</t>
<t tx="bob.20080113090336">def onScrollHorizontal(self, adjustment):
    """Scroll the outline horizontally to a new position.

    """
    self._canvas.hscrollTo(int(adjustment.value))
</t>
<t tx="bob.20080113133525">def loadIcons():

    global icons, plusBoxIcon, minusBoxIcon, appIcon, namedIcons, globalImages

    import cStringIO



    icons = []
    namedIcons = {}


    path = g.os_path_abspath(g.os_path_join(g.app.loadDir, '..', 'Icons'))
    if g.os_path_exists(g.os_path_join(path, 'box01.GIF')):
        ext = '.GIF'
    else:
        ext = '.gif'

    for i in range(16):
        icon = loadIcon(g.os_path_join(path, 'box%02d'%i + ext))
        icons.append(icon)



    for name in (
        'lt_arrow_enabled',
        'rt_arrow_enabled',
        'lt_arrow_disabled',
        'rt_arrow_disabled',
        'plusnode',
        'minusnode'
    ):
        icon = loadIcon(g.os_path_join(path, name + '.gif'))
        if icon:
            namedIcons[name] = icon

    plusBoxIcon = namedIcons['plusnode']
    minusBoxIcon = namedIcons['minusnode']

    globalImages = {}

</t>
<t tx="bob.20080113141134">

def name2color(name, default=None, cairo=False):




    if isinstance(name, cls ):
        return name

    color = colors.getColorRGB(name)

    if color is None:
        if default:
            return name2color(default)
        else:
            return None

    r, g, b = color

    if cairo:
        return r/255.0, g/255.0, b/255.0 

    return gtk.gdk.Color(r,g,b)
</t>
<t tx="bob.20080113170041">def getImage (relPath, force=False):


    if not force and relPath in globalImages:
        image = globalImages[relPath]
        g.es('cach ', image, image.get_height(), getColor('magenta'))
        return image, image.get_height()

    try:
        path = g.os_path_normpath(g.os_path_join(g.app.loadDir,"..","Icons", relPath))
        globalImages[relPath] = image = loadIcon(path)
        return image

    except Exception:
        pass

    try:
        path = g.os_path_normpath(relPath)
        localImages[relPath] =  image = loadIcon(path)
        return image
    except Exception:
        pass

    return None
</t>
<t tx="bob.20080113170657">def loadIcon(fname):

    try:
        icon = gtk.gdk.pixbuf_new_from_file(fname)
    except:
        icon = None

    if icon and icon.get_width()&gt;0:
        return icon

    g.pr('Can not load icon from', fname)
</t>
<t tx="bob.20080113183321">def onButtonPress(self, w, event, *args):

    codes = {
        gtk.gdk.BUTTON_PRESS: 'click',
        gtk.gdk._2BUTTON_PRESS: 'double_click',
        gtk.gdk._3BUTTON_PRESS: 'triple_click',
        gtk.gdk.BUTTON_RELEASE: 'release'
    }


    sp, item = self.canvas.hitTest(event.x, event.y)
    g.pr(
        codes[event.type], '%s[%s]: %s'%(
            g.choose(isinstance(item, int), 'headStringIcon[%s]'%item, item),
            'button-%s'%event.button,
            sp.headString()
        ))

    if item == 'ClickBox' and event.button == 1:
        if sp.isExpanded():
            sp.contract()
        else:
            sp.expand()

        self.canvas.update()
</t>
<t tx="bob.20080113183321.1"></t>
<t tx="bob.20080113184034">def __init__(self):

    #for n in c.allNodes_iter():
    #    g.pr(n.headString())


    window = gtk.Window(gtk.WINDOW_TOPLEVEL)
    window.set_title("gtkLeo Outline Widget Demo")
    window.connect("destroy", lambda w: gtk.main_quit())
    window.set_size_request(10, 10)
    window.resize(400, 300)

    loadIcons()

    self.panel = OutlineCanvasPanel(window, c, 'canvas')

    self.canvas = canvas = self.panel._canvas
    g.trace(canvas)

    canvas.set_events(gtk.gdk.ALL_EVENTS_MASK)
    canvas.connect('button_press_event', self.onButtonPress)
    #canvas.connect('button_release_event', self.onButtonPress)

    window.show_all()



</t>
<t tx="bob.20080114060133"></t>
<t tx="edreamleo.20080110083531">import gtk

@others

createWindow()

gtk.main()</t>
<t tx="edreamleo.20080110130828">def createWindow():

    def onKeyUp(w,event):
        g.trace(event.state,event.keyval,event.string)

    window = gtk.Window()
    window.set_title("Hello World")

    # button = gtk.Button("-----Press me-----")
    # button.connect("clicked",onButtonPressed)
    # window.add(button)

    splitter1 = gtk.VPaned()
    window.add(splitter1)

    tree = gtk.TextView()
    buf1 = tree.get_buffer()
    buf1.set_text("tree")

    body = gtk.TextView()
    buf2 = body.get_buffer()
    buf2.set_text("body")
    body.connect("key_release_event",onKeyUp)

    splitter1.add(tree)
    splitter1.add2(body)

    window.connect("delete-event",gtk.main_quit)
    window.show_all()
    return window
</t>
<t tx="edward.20081127113749.1"></t>
<t tx="edward.20081127113749.2">wordsep = u'., -+\n\r[]{}&lt;&gt;=-+*&amp;%$#@!"\'?/\\|^()~`:;'
word_completer_key = 'back_word_completer'
@others
completer = g.app.config.get(c,word_completer_key,'WordCompleter')
if completer is None:
    completer = WordCompleter(p,c,back=True)
    g.app.config.set(c,word_completer_key,'WordCompleter',completer)
    completer.run()
else:
    completer.adjust(p, c.frame.body.getInsertPoint())
    completer.complete_word()
</t>
<t tx="edward.20081127113749.3">class WordCompleter:
    def __init__(self, p, c, back=True):
        self.p = p.copy()
        self.c = c
        self.back = back
        self.pos = -1
    @others
</t>
<t tx="edward.20081127113749.4">def complete_word(self):
    txt = self.chunk
    word = self.word
    try:
        if self.back:
            &lt;&lt;backward search&gt;&gt;
        else:
            &lt;&lt;forward search&gt;&gt;
        &lt;&lt;clean up and exit&gt;&gt;
    except:
        self.exit()
        g.es_exception()</t>
<t tx="edward.20081127113749.5">p = self.search_pos
start = -1
counter = 0
while p:
    &lt;&lt;counter check&gt;&gt;
    i = txt.rfind(word, 0, start)
    if i == -1:
        p.moveToThreadBack()
        if p:self.chunk = txt = p.bodyString()
        start = -1
    else:
        if self.acceptable_word(i, txt, word):
            self.chunk = txt[:i+len(word)-1]
            return
        start = i+len(word)-1</t>
<t tx="edward.20081127113749.6">counter+=1
if counter &gt; 10000:
    g.es_trace("counter max")
    break</t>
<t tx="edward.20081127113749.7">p = self.search_pos
start = 0
counter = 0
while p:
    &lt;&lt;counter check&gt;&gt;
    i = txt.find(word, start)
    if i == -1:
        p.moveToThreadNext()
        if p:self.chunk = txt = p.bodyString()
        start = 0
    else:
        if self.acceptable_word(i, txt, word):
            self.chunk = txt[i+1:]
            return
        start = i+1</t>
<t tx="edward.20081127113749.8">if len(self.tried) &gt; 1:
    # there was some tries so we need to restore
    self.c.setBodyString(self.p, self.before+self.word+self.after)
    self.c.frame.body.setInsertPoint(self.pos)
return self.exit()</t>
<t tx="edward.20081127113749.9">@ if found word for the first time then try it
@c
def acceptable_word(self, i, txt, word):
    if i == 0 or wordsep.find(txt[i-1]) != -1:
        j = i+len(word)
        while j &lt; len(txt) and wordsep.find(txt[j]) &lt; 0:
            j += 1
        nword = txt[i:j]
        if nword not in self.tried:
            self.tried[nword] = 1
            u = self.c.undoer
            bunch = u.createCommonBunch(p)
            bunch.oldBody = p.bodyString()
            bunch.insertPos = self.pos
            # Set the type &amp; helpers.
            bunch.kind = 'node'
            bunch.undoType = 'complete word'
            bunch.undoHelper = self.undo_replacement
            bunch.redoHelper = self.redo_replacement
            bunch.newBody = newBody = self.before+nword+self.after

            self.c.setBodyString(self.p, newBody)
            self.c.frame.body.setInsertPoint(self.pos)

            bunch.dirtyVnodeList = [p.v]
            bunch.newChanged = u.c.isChanged()
            bunch.newDirty = p.isDirty()
            bunch.newMarked = p.isMarked()

            u.pushBead(bunch)

            return True
    return False
</t>
<t tx="edward.20081127113749.10">def undo_replacement(self):
    u = self.c.undoer; c=self.c; p=u.p
    bunch = u.getBead(u.bead)
    c.setBodyString(p, bunch.oldBody)
    c.frame.body.setInsertPoint(bunch.insertPos)</t>
<t tx="edward.20081127113749.11">def redo_replacement(self):
    c = self.c; u=c.undoer; bunch=u.getBead(u.bead+1)
    c.setBodyString(bunch.p, bunch.newBody)
    c.frame.body.setInsertPoint(bunch.insertPos)</t>
<t tx="edward.20081127113749.12">def exit(self):
    #g.app.config.set(c,word_completer_key,'WordCompleter',None)
    #g.app.config.set(c,'next_word_completer','WordCompleter',None)
    self.pos = -1</t>
<t tx="edward.20081127113749.13">def run(self):
    self.adjust(self.p, c.frame.body.getInsertPoint())
    self.complete_word()
</t>
<t tx="edward.20081127113749.14">def adjust(self, p, pos):
    if p != self.p or pos != self.pos:
        self.p = p.copy()
        self.pos = pos
        bs = p.bodyString()
        word = getCurrentWord(bs, pos)
        self.word = word
        self.before = bs[:pos-len(word)]
        self.after = bs[pos:]
        self.search_pos = p.copy()
        if self.back:
            self.chunk = self.before
        else:
            self.chunk = self.after
        self.tried = {word:1}</t>
<t tx="edward.20081127113749.15">def getCurrentWord(s, pos):
    i = pos-1
    while i&gt;=0 and wordsep.find(s[i]) &lt; 0:
         i -= 1
    return s[i+1:pos]</t>
<t tx="edward.20081127113749.16">wordsep = u'., -+\n\r[]{}&lt;&gt;=-+*&amp;%$#@!"\'?/\\|^()~`:;'
word_completer_key = 'next_word_completer'
@others
completer = g.app.config.get(c,word_completer_key,'WordCompleter')
if completer is None:
    completer = WordCompleter(p, c, back=False)
    g.app.config.set(c, word_completer_key, 'WordCompleter', completer)
    completer.run()
else:
    completer.adjust(p, c.frame.body.getInsertPoint())
    completer.complete_word()

</t>
<t tx="edward.20081221145716.1">def debug(f,*args,**keys):
    if 1:
        def debugCallback(*args,**keys):
            print f.__name__,args,keys
            f(*args,**keys)
            print 'after',f.__name__
        return debugCallback
    else:
        print 'in debug'
        return f
@debug
def spam(a=5):
    g.trace(a,g.callers(4))

spam(3)
spam(a=4)
</t>
<t tx="ekr.20041001211817">import os

g.pr(os.path.exists(os.path.normpath("C:\\Progra~1\\Eclipse")))</t>
<t tx="ekr.20060427103457"># Open leoSettings.leo
c.openLeoSettings()</t>
<t tx="ekr.20060809084033">'''A script to convert calls to g.es to g.et, and raw strings s to g._(s)'''

__version__ = 0.2
&lt;&lt; version history &gt;&gt;

@others

trace = False # For debugging.
doReplace = True # True: actually replace the body text.

if not doReplace: g.es_print('-' * 40)
c.beginUpdate()
try:
    u = c.undoer
    undoType = 'Convert g.es'
    u.beforeChangeGroup (p,undoType)
    for p in c.currentPosition().self_and_subtree_iter():
        replace(p)
    u.afterChangeGroup(p,undoType,reportFlag=True)
finally:
    c.endUpdate()</t>
<t tx="ekr.20060809090508"># Based on leoImport.scanPythonText.
def replace(p):
    '''Replace g.es by g.et and strings s by g._(s)'''
    s = p.bodyString()
    if not s.strip(): return
    result = [] ;  i = 0 ; count = 0
    while i &lt; len(s):
        progress = j = i
        ch = s[i]
        if ch == '\n' or ch == '\r':
            i = g.skip_nl(s,i)
            result.append(s[j:i])
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
            result.append(s[j:i])
        elif ch == '"' or ch == "'":
            &lt;&lt; handle string &gt;&gt;
        elif g.is_c_id(ch):
            if g.match_word(s,i,'g.es'):
                &lt;&lt; handle g.es &gt;&gt;
            else:
                i = g.skip_c_id(s,i)
                result.append(s[j:i])
        else:
            i += 1
            result.append(s[j:i])
        assert(progress &lt; i)
    if count:
        result = ''.join(result)
        if doReplace:
            undoData = u.beforeChangeNodeContents(p)
            p.setBodyStringOrPane(result)
            p.v.t.setDirty()
            u.afterChangeNodeContents(p,'Change Body',undoData)
        else:
            g.trace('result...\n',result)</t>
<t tx="ekr.20060809091749.72">i = g.skip_python_string(s,i)
s2 = s[j:i].strip()
result.append('g._(%s)' % s2)
if trace: g.trace('string:',s2)
count += 1</t>
<t tx="ekr.20060809091749.73">i += 4 ; k1 = i
i = g.skip_ws(s,i)
found = False
if g.match(s,i,'('):
    k2 = i
    k3 = g.skip_parens(s,i)
    if g.match(s,k3,')'):
        # Only translate if there are exactly one string in the parens.
        s2 = s[k2+1:k3]
        if (
            s2 and s2.count(',') == 0 and
            (s2.count('"') == 2 or s2.count("'") == 2)
        ):
            i = k3
            if trace: g.trace('call g.es:',g.get_line(s,i))
            result.append('g.et')
            result.append(s[k1:i])
            count += 1 ; found = True
if not found:
    result.append(s[j:i])</t>
<t tx="ekr.20060809092023"></t>
<t tx="ekr.20060809103738">def test1():
    
    g.es('abc')
    g.es('abc',xyz)
    g.es(xyz)</t>
<t tx="ekr.20060809103738.1">def test2():

    x = 'abc' + 'xyz'
    y = abc</t>
<t tx="ekr.20060809104405">@nocolor
@
0.1 EKR: Initial version.
0.2 EKR: Support doReplace and made script fully undoable.</t>
<t tx="ekr.20060814111542"># Add an editor to the body pane.
c.frame.body.addEditor()</t>
<t tx="ekr.20060904110922"></t>
<t tx="ekr.20060904111037">if hasattr(c,'opmlCommands'):
    c.opmlCommands.readOpmlCommand()
else:
    g.es_print('opml plugin not loaded')</t>
<t tx="ekr.20060904111037.1">if hasattr(c,'opmlCommands'):
    c.opmlCommands.writeOpmlCommand()
else:
    g.es_print('opml plugin not loaded')</t>
<t tx="ekr.20060918083159">put = g.es_print

for p in c.allNodes_iter():

    if hasattr(p.v,"unknownAttributes"):
        put("deleting v.unknownAttributes:",
            p.headString(),
            g.listToString(p.v.unknownAttributes.keys()))
        delattr(p.v,"unknownAttributes")

    if hasattr(p.v.t,"unknownAttributes"):
        put("deleting t.unknownAttributes:",
            p.headString(),
            g.listToString(p.v.t.unknownAttributes.keys()))
        delattr(p.v.t,"unknownAttributes")
           
put('done') 
c.redraw()</t>
<t tx="ekr.20060924180049">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060924180049.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others</t>
<t tx="ekr.20060924180049.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")</t>
<t tx="ekr.20060924180049.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060924180049.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.currentPosition()
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.headString())
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060924180049.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().headString()
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)</t>
<t tx="ekr.20060924180049.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20061030041200">import os, sys

if 1: # Executes Iron Python in the console. (But not from the tutorials directory).
    path = r'c:\prog\IronPython-1.0.1\ipy.exe'
    args = ['-i']
        
    if 1: # Use present environment.
        os.spawnv(os.P_NOWAIT, path, args)
    else: # Use a pristine environment.
        os.spawnve(os.P_NOWAIT, path, args, os.environ)</t>
<t tx="ekr.20061030041356"></t>
<t tx="ekr.20061030041450"></t>
<t tx="ekr.20070115092430"># Invoke winpdb for general scripts **not** containing the predefined g, p or d constants.

# This is essentially the same as using the debug command.

import os,subprocess,sys

# Important: scriptFile2 must be different from scriptFile.
filename = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','scriptFile2'))
f = open(filename,'w') 
f.write(p.bodyString()) 
f.close() 
python = sys.executable
pythonDir = g.os_path_dirname(python) 
#winpdb = g.os_path_join(pythonDir,'Scripts','_winpdb.py') # For older versions of winpdb.
winpdb = g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py') # For version 1.1.2 and newer.
os.chdir(g.app.loadDir)
cmdline = '%s %s -t %s' % (python,winpdb,filename) 
subprocess.Popen(cmdline)
</t>
<t tx="ekr.20070223164126"># An example of running this script:
    
import os

@others

types = (".py",) #,".c",".html",".txt")

dir = r'C:\prog\Notabene'

c.beginUpdate()
try:
    importFiles(dir,types,recursive=True)
finally:
    c.endUpdate()

g.es("done",color="blue")
</t>
<t tx="ekr.20070223164126.1">def importFiles (dir,type=None,kind="@file",recursive=False):
    
    v = c.currentVnode()

    # Check the params.
    if kind != "@file" and kind != "@root":
        g.es("kind must be @file or @root: " + kind)
        return

    if not g.os_path_exists(dir):
        g.es("directory does not exist: " + dir)
        return
    
    c.beginUpdate()
    try:
        root = createLastChildOf(v,"imported files")
        try:
            importDir (dir,type,kind,recursive,root)
            root.contract()
        except:
            g.es_exception()
    finally:
        c.endUpdate()</t>
<t tx="ekr.20070223164126.2">def importDir (dir,types,kind,recursive,root):

    g.es("dir: " + dir,color="blue")
    
    try:
        files = os.listdir(dir)
        files2 = [] ; dirs =[]
        for f in files:
            path = g.os_path_join(dir,f)
            if g.os_path_isfile(path):
                name, ext = g.os_path_splitext(f)
                if not types or ext in types:
                    files2.append(path)
            elif recursive:
                dirs.append(path)
        if len(files2) &gt; 0 or len(dirs) &gt; 0:
            child = createLastChildOf(root,dir)
            c.selectVnode(child)
        if len(files2) &gt; 0:
            c.importCommands.importFilesCommand(files2,kind)
        if len(dirs) &gt; 0:
            dirs.sort()
            for dir in dirs:
                importDir(dir,types,kind,recursive,child)
    except:
        g.es("exception in importFiles script")
        g.es_exception()
</t>
<t tx="ekr.20070223164126.3">def createLastChildOf (v,headline):
    
    child = v.insertAsLastChild()
    child.initHeadString(headline)
    return child
</t>
<t tx="ekr.20070224123943"></t>
<t tx="ekr.20070305085403"></t>
<t tx="ekr.20070305085403.1"></t>
<t tx="ekr.20070305085403.2"></t>
<t tx="ekr.20070410063214"></t>
<t tx="ekr.20070416075121"></t>
<t tx="ekr.20070503085527"></t>
<t tx="ekr.20070504080933">This option applies to directories specified in filenames in all kinds of @file trees, and to filenames specified in the @path directive.

True:  Leo attempts to create directories if they do not exist.
False: Leo never attempts to create directories.</t>
<t tx="ekr.20070515073111">g.pr('=' * 50)</t>
<t tx="ekr.20070517070854">import leoGui
oldGui = g.app.gui
g.app.gui = leoGui.nullGui(guiName='testGui')
try:
    fileName = g.os_path_abspath(g.os_path_join(
        g.app.loadDir,'..','doc','LeoDocs.leo'))
    ok,frame = g.openWithFileName(fileName,old_c=c)
    if ok:
        c2 = frame.c
        for p in c2.allNodes_iter():
            g.pr('.'*p.level(),p.headString())
        g.app.closeLeoWindow(frame)
finally:
    g.app.gui = oldGui</t>
<t tx="ekr.20070517071510">import leoBridge

path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','doc','LeoDocs.leo'))

if 0: # This can not be run locally: leoBridge.controller starts a Tk event loop.

    controller = leoBridge.controller(gui='nullGui')
    g = controller.globals()
    c = controller.openLeoFile(path)
    n = 0
    for p in c.allNodes_iter():
        n += 1
    g.pr('%d nodes in %s' % (n,path))
    # g.app.closeLeoWindow(c.frame)</t>
<t tx="ekr.20070517160058.1"></t>
<t tx="ekr.20070528111805"># FrontWindowCapture.pyw
# Version 0.1
# Date    20070526
# Author  Roger Erens (roger AT erens-krekels.net)
"""
        Purpose:
        Capture the image of the front-most window into a fixed-name
        (_front_window), max-size (default MAX_WIDTH is 640 pixels), and
        fixed-format (PNG) file that can easily be used when creating
        documentation for an application on a wiki or in some HTML-docs.
        This script does _not_ copy the captured image to the clipboard (handy
        when creating MS Word or OpenOffice documents) since MS Windows already
        has ALT-PRTSCR to do so.

        Dependencies:
        Fairly recent versions of Python, wxPython, and PIL should be installed

        Start:
        Double click FrontWindowCapture.pyw; an icon appears in the Task Bar (lower right of
        the screen).

        Use:
        Bring a window to the front and then left-click on the
        icon in the Task Bar. A file named '_front_window.png' will be saved
        in the current directory.
        A pictures wider than MAXWIDTH is scaled down in order to make it easily
        used in wikis or HTML-documentation.
        Usually, human intelligence is needed to rename that file; this is also
        why this script does not copy the image to the clipboard.

        End:
        Close the application by right-clicking the icon in the Task Bar.

        Note:
        Make sure that your system is fast enough to find the frontmost
        window. That is, when a virusscanner is running or virtual memory is
        low, this script will choke. You can see what happens by enabling the
        print statements and running this script from a console (change the
        extension from .pyw to .py).
"""
import wx
import sys
import win32ui
import win32gui
import win32con
import time
from PIL import Image, ImageGrab

Image.init()

MAX_WIDTH = 640
BLINK_STATE = 0

class TaskBarApp(wx.Frame):
    def __init__(self, parent, id, title):
        wx.Frame.__init__(self, parent, -1, title, size = (1, 1),
            style=wx.FRAME_NO_TASKBAR| wx.NO_FULL_REPAINT_ON_RESIZE)
        self.tbicon = wx.TaskBarIcon()
        icon = wx.Icon('LeoApp16.ico', wx.BITMAP_TYPE_ICO)
        self.tbicon.SetIcon(icon, 'Click to capture the foremost window')
        self.tbicon.Bind(wx.EVT_TASKBAR_LEFT_UP, self.OnTaskBarLeftClick)
        self.tbicon.Bind(wx.EVT_TASKBAR_RIGHT_UP, self.OnTaskBarRightClick)
        self.Show(True)

    def OnTaskBarLeftClick(self, evt):

        self.FlashIcon(evt)

        def _MyCallback(hwnd, extra ):
            extra.append(hwnd)

        windows = []
        win32gui.EnumWindows(_MyCallback, windows)

        winList = []
        for i in windows:
            if win32gui.IsWindowVisible(i):
                winList.append(i)
                #g.pr(i)

        win32gui.SetForegroundWindow(winList[1])    # found by trial and error
                                                    # that I need the second
                                                    # window from the list
        time.sleep(0.1)  # give the previous command some time to finish

        fgwindow = win32ui.GetForegroundWindow()
        #g.pr("(C)lick!")

        bbox = fgwindow.GetWindowRect()
        img = ImageGrab.grab( bbox)
        width = bbox[2] - bbox[0]
        if width &gt; MAX_WIDTH:
            coeff = MAX_WIDTH * 1. / width
            height = bbox[3] - bbox[1]
            newHeight = int( coeff * height)
            #g.pr(width, height, "scaled down to", MAX_WIDTH, newHeight)
            img = img.resize((MAX_WIDTH,newHeight), Image.ANTIALIAS)
        img = img.convert("P", dither=Image.NONE,
                              palette=Image.ADAPTIVE, colors=256)
        img.save("_front_window.png", "PNG", optimize=1)
        #img.show() # show the image in an image viewer

        self.FlashIcon(evt)

    def OnTaskBarRightClick(self, evt):
        #g.pr("Auta..." # that's about it...)
        self.tbicon.Destroy()
        self.Close(True)
        wx.GetApp().ProcessIdle()

    def FlashIcon(self, evt):
        global BLINK_STATE
        if BLINK_STATE == 0:
            icon = wx.Icon('LeoApp16lick.ico', wx.BITMAP_TYPE_ICO)
            self.tbicon.SetIcon(icon, 'Window is being captured...')
            BLINK_STATE = 1
            return
        else:
            icon = wx.Icon('LeoApp16.ico', wx.BITMAP_TYPE_ICO)
            self.tbicon.SetIcon(icon, 'Click to capture the foremost window')
            BLINK_STATE = 0
            return

class MyApp(wx.App):
    def OnInit(self):
        frame = TaskBarApp(None, -1, ' ')
        frame.Center(wx.BOTH)
        frame.Show(False)
        return True

def main():
    app = MyApp(0)
    app.MainLoop()

if __name__ == '__main__':
    main()

""" CREDITS

    Thanks to
    Roger Upole:
    http://groups.google.com/group/comp.lang.python/
    browse_thread/thread/ff39ec79f7c3248a/
    e600c892772bf52a?lnk=gst&amp;q=screen+capture&amp;rnum=6#e600c892772bf52a
    for his time.sleep() Aha (This took me a year and a half to note!)

    Christian Wyglendowski, Werner Bruhin, and Xavier Morel for the
    http://wiki.wxpython.org/index.cgi/FlashingTaskbarIcon
    discussion

    'Rob aspn at msolutionsinc.com '
    http://mail.python.org/pipermail/python-win32/2003-June/001129.html
    for his suggestion to find out the foremost window

    and of course the usual suspects that created/maintain
    wxPython,
    PIL,
    pywin32,
    LEO,
    gvim,
    and Python itself.
"""</t>
<t tx="ekr.20070529172620"></t>
<t tx="ekr.20070529173219"></t>
<t tx="ekr.20070529173219.1"></t>
<t tx="ekr.20070530072113">c.chapterController.hideChapters()</t>
<t tx="ekr.20070530072113.1">c.chapterController.showChapters()</t>
<t tx="ekr.20070531102813"></t>
<t tx="ekr.20070531103315">c.abbrevCommands.dynamicExpansion(event=None)</t>
<t tx="ekr.20070531104646">c.abbrevCommands.dynamicCompletion()</t>
<t tx="ekr.20070603175054">cc = c.chapterController
cc.selectChapterByName('abc')</t>
<t tx="ekr.20070603175054.1">cc = c.chapterController
cc.selectChapterByName('main')</t>
<t tx="ekr.20070603190713">cc = c.chapterController
cc.createChapterByName('xyz')</t>
<t tx="ekr.20070603190713.1">cc = c.chapterController
cc.selectChapterByName('xyz')</t>
<t tx="ekr.20070603190944"></t>
<t tx="ekr.20070603190944.1"></t>
<t tx="ekr.20070604095313"></t>
<t tx="ekr.20070604100125"></t>
<t tx="ekr.20070609085533"></t>
<t tx="ekr.20070630142904"></t>
<t tx="ekr.20070630142904.2">@nocolor

To build your module using GCC is a three step process on Unix:

1. Use Pyrex to translate mymodule.pyx to mymodule.c::

    python pyrexc mymodule.pyx

mymodule.pyx is the name of the Pyrex module you are writing.

2. Compile mymodule.c to mymodule.o::

    gcc -c -fPIC -I/usr/include/python2.2/ mymodule.c

-c  Produces a .o file instead of an executable. 
-fPIC Produces position independent code, so we can dynamically link against it later. 
-I/usr/include/python2.2/ is the location of the Python 2.2 include file.
 The location of your Python include file may differ from /usr/include/python2.2/. 

3 Link the mymodule.o into a mymodule.so::
    
    gcc -shared mymodule.o -lxosd -o mymodule.so

-shared produces a shared-object file, instead of an executable. 
-lxosd links against a C-library, with the name of the library given as the argument. 
</t>
<t tx="ekr.20070630142904.3">@nocolor

The pyrexc command supports the following options:

  Short Long              Argument    Description
  ----- ----              --------    -----------
  -v    --version                     Display version number of pyrex compiler
  -l    --create-listing              Write error messages to a .lis file
  -I    --include-dir     &lt;directory&gt; Search for include files in named 
                                      directory (may be repeated)
  -o    --output-file     &lt;filename&gt;  Specify name of generated C file (only
                                      one source file allowed if this is used)

Anything else is taken as the name of a Pyrex source file and compiled
to a C source file. Multiple Pyrex source files can be specified
(unless -o is used), in which case each source file is treated as the
source of a distinct extension module and compiled separately to
produce its own C file.
</t>
<t tx="ekr.20070630142904.4">def spam(int i, char *s):
    if 1:
        g.pr(i,s)</t>
<t tx="ekr.20070630142904.5"># Use pyrexc to create myModule.c from myModule.pyx.

import os,sys
python = sys.executable
theFile = r'C:\prog\tigris-cvs\leo\test\myModule.pyx'
pyrexc = r'c:\prog\Pyrex-0.9.6.4\pyrexc.py'
os.system(r'%s %s %s' % (python,pyrexc,theFile))

# Use pyrex/Demos/setup.py to create module on Linux.</t>
<t tx="ekr.20070701090143"></t>
<t tx="ekr.20070723091227">
        
        
        </t>
<t tx="ekr.20070723091227.1"></t>
<t tx="ekr.20070723091227.2"></t>
<t tx="ekr.20070723091227.3"></t>
<t tx="ekr.20070927175908">'''Convert a normal Leo tree to a networkx graph'''
import networkx as nx
import sys

x = nx.Graph()

def node_id(p):
    return '%s: %s' % (id(p.v.t),p.headString())

def addTree(p):
    x.add_node(node_id(p))
    for child in p.children_iter():
        addTree(child)
        x.add_edge(node_id(p),node_id(child))

addTree(p)

g.pr('nodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('edges...\n', g.listToString(x.edges(),sort=True))
g.pr('yaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')
</t>
<t tx="ekr.20070928095102">@ This is a plain Leo tree.

You can convert it to a networkx graph using the leo2graph button.
</t>
<t tx="ekr.20070928095102.1"></t>
<t tx="ekr.20070928095102.2"></t>
<t tx="ekr.20070929062147">@nocolor

The following scripts convert between Leo trees and NetworkX graphs.

- leo2graph:            convert a normal Leo tree to a NetworkX graph.
- at-graph2graph:       convert an @graph tree to a Networkx graph.
- at-networkx2graph:    convert an @networkx tree to a Networkx graph
- at-networkx2at-graph: create an @graph tree from an @networkx tree.

Not ready yet:

- tree2pict: convert a Leo @graph tree to a picture of the corresponding graph.

@color</t>
<t tx="ekr.20070929062147.1">'''Convert an @graph tree to a networkx graph.'''
import networkx as nx
import sys

x = nx.Graph()

def node_id(p):
    return '%s: %s' % (str(p.v.t.fileIndex),p.headString())

def addTree(p):
    tag = '@link'
    h = p.headString()
    if h.startswith('@graph'):
        for child in p.children_iter():
            addTree(child)
    elif h.startswith('@node'):
        x.add_node(node_id(p))
        for child in p.children_iter():
            h = child.headString()
            if h.startswith(tag):
                link = h[len(tag):].strip()
                if link: x.add_edge(node_id(p),link)
            elif child.headString().startswith('@node'):
                addTree(child)
                x.add_edge(node_id(p),node_id(child))

addTree(p)

g.pr('nodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('edges...\n', g.listToString(x.edges(),sort=True))
g.pr('yaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')</t>
<t tx="ekr.20070929062147.2">'''Convert an @networkx node to a networkx graph.'''
import networkx as nx
import sys

@others

x = nx.Graph()

edges,nodes = parse(p)

for z in nodes:
    x.add_node(z)

for z in edges:
    a,b = z
    x.add_edge(a,b)

g.pr('\nnodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('\nedges...\n', g.listToString(x.edges(),sort=True))
g.pr('\nyaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')
</t>
<t tx="ekr.20070929070257">@ This is an @graph tree.

You can convert it to a networkx graph using the at-graph2graph button.</t>
<t tx="ekr.20070929070257.1"></t>
<t tx="ekr.20070929070257.2"></t>
<t tx="ekr.20070929070426">g.es('@link %s: %s' % (str(p.v.t.fileIndex),p.headString()))</t>
<t tx="ekr.20070929070632"></t>
<t tx="ekr.20070929070632.1"></t>
<t tx="ekr.20070929072043">@ This node defines a networkx graph using nodes and edges.

You can create an @graph tree from this node using the graph2at-graph button.
</t>
<t tx="ekr.20070929072506"># Each edge is represented as two lines.

# child1 --&gt; child2
('ekr', '20070929070257', 1): @node child1
('ekr', '20070929070257', 2): @node child2

# child2 --&gt; child1
('ekr', '20070929070257', 2): @node child2
('ekr', '20070929070257', 1): @node child1

</t>
<t tx="ekr.20070929072506.1"># Each node is on a separate line.

('ekr', '20070929070257', 1): @node child1
('ekr', '20070929070257', 2): @node child2
</t>
<t tx="ekr.20070929072506.2">def parseNodes (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(g.listToString(lines))
    return lines
</t>
<t tx="ekr.20070929074830">def parse (p):

    tag = '@networkx'
    if not p.headString().startswith(tag):
        p = g.findNodeAnywhere(c,tag)
        if not p.headString().startswith(tag):
            error('No %s node in the outline' % tag)
            return [],[]

    nodes = []
    for tag in ('@edges','@nodes'):
        node = g.findNodeInTree(c,p,tag)
        if node:
            nodes.append(node)
        else:
            error('No %s node in @networkx tree' % tag)
            return [],[]
    edgesNode,nodesNode = nodes
    edges = parseEdges(edgesNode)
    nodes = parseNodes(nodesNode)
    return edges,nodes
</t>
<t tx="ekr.20070929074830.1">def parseEdges (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(len(lines),lines)
    if (len(lines) % 2) == 0:
        i = 0 ; edges = []
        while i &lt; len(lines):
            data = lines[i],lines[i+1]
            edges.append(data)
            i += 2
        # g.trace(g.listToString(edges))
        return edges
    else:
        error('edges node must have even number of lines')
        return []

</t>
<t tx="ekr.20070929081505">def error (s):

    g.es_print(s,color='red')
</t>
<t tx="ekr.20070929082546">'''Convert an @networkx node to an @graph tree.
Create the tree as the child of the @graph-target node,
or the current position if no such node.'''

import networkx as nx
import sys

@others

g.pr('=' * 10)

p,edges,nodes = parse(p)

createTree(p,edges,nodes)
</t>
<t tx="ekr.20070929114410.2">def error (s):

    g.es_print(s,color='red')
</t>
<t tx="ekr.20070929114410.3">def parse (p):

    tag = '@graph-target'
    if not p.headString().startswith(tag):
        p = g.findNodeAnywhere(c,tag)
    if not (p and p.headString().startswith(tag)):
        p = c.currentPosition() # Use the presently selected node.

    nodes = [] ; tag = '@networkx'
    data = g.findNodeAnywhere(c,tag)
    if not data:
        error('No %s tree' % tag)
        return None,[],[]
    for tag in ('@edges','@nodes'):
        node = g.findNodeInTree(c,data,tag)
        if node:
            nodes.append(node)
        else:
            error('No %s node in @networkx tree' % tag)
            return None,[],[]
    edgesNode,nodesNode = nodes
    edges = parseEdges(edgesNode)
    nodes = parseNodes(nodesNode)
    return p,edges,nodes
</t>
<t tx="ekr.20070929114410.4">def parseNodes (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(g.listToString(lines))
    return lines
</t>
<t tx="ekr.20070929114410.5">def parseEdges (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(len(lines),lines)
    if (len(lines) % 2) == 0:
        i = 0 ; edges = []
        while i &lt; len(lines):
            data = lines[i],lines[i+1]
            edges.append(data)
            i += 2
        # g.trace(g.listToString(edges))
        return edges
    else:
        error('edges node must have even number of lines')
        return []

</t>
<t tx="ekr.20070929114617">@ This will be the root node for the @graph tree produced by the at-networkx2at-graph button.</t>
<t tx="ekr.20070929115302">def createTree (parent,edges,nodes):

    if 0:
        g.trace('nodes...\n', g.listToString(nodes,sort=True))
        g.trace('edges...\n', g.listToString(edges,sort=True))

    c.beginUpdate()
    try:
        p = parent.insertAsLastChild()
        p.setHeadString('@graph')
        d = createNodes(p,nodes)
        createEdges(d,edges)
        c.selectPosition(p)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070929120541">def createEdges (d,edges):

    for edge in edges:
        a,b = edge
        g.trace('\n%s --&gt; %s' % (a,b))
        p = d.get(a)
        if p:
            p2 = p.insertAsLastChild()
            p2.setHeadString('@link %s' % (b))
        else:
            error('@node not found: %s' % (a))
</t>
<t tx="ekr.20070929120541.1">def createNodes (parent,nodes):

    d = {}

    for node in nodes:
        # g.trace(node)
        p = parent.insertAsLastChild()
        p.setHeadString('@node %s' % (node))
        d[node] = p.copy()

    return d
</t>
<t tx="ekr.20070929122956"></t>
<t tx="ekr.20070929122956.1"></t>
<t tx="ekr.20071002150320">log = c.frame.log
tag = 'my-canvas'

w = log.canvasDict.get(tag)
if not w:
    w = log.createCanvas(tag)
    w.configure(bg='yellow')

log.selectTab(tag)
</t>
<t tx="ekr.20071006084354">w = c.frame.body.bodyCtrl
s = w.getAllText()
ins = w.getInsertPoint()
row,col = g.convertPythonIndexToRowCol(s,ins)
g.pr('row',row,'col',col)</t>
<t tx="ekr.20071025192258">import leoTest
leoTest.doTests (c,all=False)</t>
<t tx="ekr.20071025193940"># Caution: you will have to disable cursesGui in an external editor
# if you enable the cursesGui plugin here

# Important: if you want to specify a gui plugin here,
# enable that plugin first.

# qtGui.py
# tkGui.py

plugins_menu.py

# leoOPML.py
# graphed.py

# not normally enabled by default.  Recently changed.
# EditAttributes.py
# UASearch.py
# active_path.py
# cleo.py
# datenodes.py
# mod_labels.py
# newButtons.py
# searchbox.py

# This works only with tk.  It is not needed for qt.
# threading_colorizer.py

# open_shell.py
ipython.py
open_with.py
rClick.py
toolbar.py

# add_directives.py # scan-directives hook not ready.
# color_markup.py # Does not work with threading colorizer.
rst3.py
UNL.py

mod_scripting.py
nav_buttons.py
nodenavigator.py
image.py
#### leo_to_html.py
####  vim.py
#### xemacs.py
</t>
<t tx="ekr.20071026102420.2"></t>
<t tx="ekr.20071026102420.3"></t>
<t tx="ekr.20071105085941"></t>
<t tx="ekr.20071128122043">log = c.frame.log ; tag = 'Shell'
frame1 = log.frameDict.get(tag)
shellKind = 'text' # in ('plain','text','canvas')

if frame1:
    log.selectTab(tag)
elif shellKind == 'plain':
    log.selectTab (tag,createText=False)
    frame = log.frameDict.get(tag)
elif shellKind == 'text':
    log.selectTab (tag,createText=True)
    frame = log.textDict.get(tag)
elif shellKind == 'canvas':
    log.createCanvas(tag)
    log.selectTab(tag)
    frame = log.canvasDict.get(tag)
else:
    frame = None
    g.es('bad shellKind',shellKind)

if frame and not frame1:
    frame.configure(bg='white')
    g.pr('logFrame',log.frameDict.get(tag))
</t>
<t tx="ekr.20071129103842"># A script to create @auto nodes from all .py files in a directory.

import glob,os

reallyCreate = True
baseDir = r'c:\leo.repo\pythoscope\lib2to3\pgen2'
dirs = (r'',)
g.pr('-----')

for theDir in dirs:
    pattern = g.os_path_join(baseDir,theDir,'*.py')
    files = glob.glob(pattern)
    g.pr(pattern)
    # g.pr(g.listToString(files))
    for name in files:
        h = '@auto %s' % (name[len(baseDir) + 1:].strip())
        g.pr('creating',h)
        if reallyCreate:
            child = p.insertAsLastChild()
            child.initHeadString(h)</t>
<t tx="ekr.20071206070207"></t>
<t tx="ekr.20080105115712"># This hangs Leo while pylint is running.
import pylint.lint as lint
import sys

rcFile = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','pylint-leo-rc.txt'))
rcArg = '--rcfile=%s' % rcFile
&lt;&lt; define data &gt;&gt;

# We expect only one W104 error, in leoGlobals.py
g.pr('\n','=' * 40)
for name,s in data:
    name2 = g.os_path_abspath(g.os_path_join(g.app.loadDir,name))
    args = [name2,rcArg]
    if s.strip():
        args.append('--disable-msg=%s' % s)
    g.pr(name,s)
    lint.Run(args)
g.pr('\n' + 'End of pylint run')</t>
<t tx="ekr.20080105120559">data = (
    ('leoAtFile.py',''), 
    ('leoChapters.py',''),
    ('leoCommands.py',''), 
    ('leoEditCommands.py','E1101'),
    ('leoFileCommands.py',''), 
    ('leoFind.py',''),
    ('leoFrame.py',''),
    ('leoGlobals.py','E0602,E1101'),
    ('leoGui.py',''),
    ('leoImport.py',''),
    ('leoMenu.py',''),
    ('leoNodes.py',''),
    ('leoPlugins.py',''),
    ('leoTangle.py',''),
    ('leoUndo.py','W0102'),
    ('leoTkinterDialog.py',''),
    ('leoTkinterFind.py',''),
    ('leoTkinterGui.py',''),
    ('leoTkinterFrame.py','W0221'),
    ('leoTkinterKeys.py',''), 
    ('leoTkinterMenu.py',''), 
    ('leoTkinterTree.py',''),
)
</t>
<t tx="ekr.20080105130903">@nocolor
@
C0111 Missing docstring
C0301 Line too long
C0311 Bad indentation
C0321 More than one statement on a single line
C0322 Operator not preceded by a space
C0323 Operator not followed by a space
C0324 Comma not followed by a space

R0201 Method could be a function.
R0903 Too few public methods (0/1)

W0102 Dangerous default value [] as argument
W0104 Statement seems to have no effect
W0106 Unnecessary semicolon
W0107 Unnecessary pass statement
W0122 Use of the exec statement
W0141 Used builtin function 'map'
W0142 Used * or * magic*
W0201 Attribute defined outside __init__
W0212 Access to a protected member of a client class
W0231 __init__ method from base class is not called
W0232 Class has no __init__ method
W0401 Wildcard import (pychecker)
W0402 Uses of a deprecated module (like string)
W0404 Reimport &lt;module&gt;: let pychecker do this.
W0406 Module import itself
W0602 Using global for x but no assigment is done (leoEditCommands defines classList after all classes).
W0603 Using the global statement
W0612 Unused variable
W0613 Unused argument (sometimes used for debugging)
W0621 Redefining &lt;name&gt; from outer scope: especially __pychecker__
W0622 Redefining built-in
W0631 Using possibly undefined loop variable
W0702 No exception type specified
W0703 Catch "Exception"
W0704 Except doesn't do anything (Except: pass)
W1111 Assigning to a function call that only returns None</t>
<t tx="ekr.20080115085447">@nocolor
@

************* Module leoGlobals
W0104:3871: Statement seems to have no effect
</t>
<t tx="ekr.20080206055658">g.pr('settings...')
for z in ('body','button','headline','log','menu','outline'):
    for z2 in ('family','size','slant','weight',):
        setting = '%s_text_font_%s' % (z,z2)
        g.pr(setting,c.config.get(setting,z2))

g.pr('default sizes...')
for z in ('Body','Log','Menu','Tree'):
    setting = 'default%sFontSize' % z
    g.pr(setting,getattr(c.config,setting))

g.pr('actual fonts...')
for z in ('body','button','headline','log','menu','outline'):
    kind = ('family','size','slant','weight')
    arg0,arg1,arg2,arg3 = args = ['%s_text_font_%s' % (z,z2) for z2 in kind]
    setting = '%s_text_font' % (z)
    g.pr('%20s' % (setting),c.config.getFontFromParams(arg0,arg1,arg2,arg3,defaultSize=12))
</t>
<t tx="ekr.20080214091706.2">g.pr('hello from ekr')</t>
<t tx="ekr.20080310111916.1">def myTranslateString (s):

    i = s.lower().find('can not')
    if i == -1:
        return s
    else:
        return s[:i+1] + "an't" + s[i+7:]

g.translateString = myTranslateString

</t>
<t tx="ekr.20080412082246.1"></t>
<t tx="ekr.20080503202744.3">import rope.base.project
import rope.contrib.codeassist as codeassist
import leo.core.leoGlobals as g
import leo.core.leoCommands as leoCommands
c2 = leoCommands.Commands(frame=c.frame,fileName='xyz-file')

class leoFSCommands (object):
    def create_file(self,path):         g.trace(path)
    def create_folder(self,path):       g.trace(path)
    def move (self,path,new_location):  g.trace(path,new_location)
    def remove (self,path):             g.trace(path)
    def write (self,path,data):         g.trace(path,data)

path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','..'))
    # Make the trunk folder a project
project = rope.base.project.Project(path,fscommands=leoFSCommands)
s = p.bodyString() # Could simulate a write to allow @others.

g.pr('*' * 40)
for pattern in (
    # 'g.', # works.
    # 'g.trace(', # weird.
    # 'rope.base.', # works.
    'g.list', # works: gives g.listToString
    'c2.de', # works.
):
    i = s.find(pattern)
    if i &gt; -1:
        proposals = codeassist.code_assist(project,s,i+len(pattern))
        g.pr('-' * 20)
        g.pr('pattern:',pattern)
        g.pr(g.listToString(proposals))</t>
<t tx="ekr.20080529111617.1"></t>
<t tx="ekr.20080529111617.2"></t>
<t tx="ekr.20080529111617.3">The colour used instead of green in progress bars</t>
<t tx="ekr.20080529111617.4">The colour used instead of red in progress bars</t>
<t tx="ekr.20080529111617.5"># list of @file node types to color.
# Uncomment these to enable coloring for these kinds of nodes.
# @asis
# @file
# @auto
# @thin
@auto</t>
<t tx="ekr.20080529111617.6">The base width of progress bars, in pixels.</t>
<t tx="ekr.20080529111617.7">The default number of time units.</t>
<t tx="ekr.20080529111617.8">0: no progress bars
1: unscaled progress bars
2: scaled progress bars</t>
<t tx="ekr.20080529111617.9">pixels per time unit to add to width of scaled progress bars</t>
<t tx="ekr.20080529111617.10">The name of time unit (e.g. days, weeks, hours)</t>
<t tx="ekr.20080531080812.1">def eggs():
    g.trace()

def spam():
    g.trace()
    eggs()

t = g.startTracer()
spam()
t.stop()
</t>
<t tx="ekr.20080531131542.1">import mx.TextTools as tt

&lt;&lt; define scan4 tables &gt;&gt;
&lt;&lt; define s &gt;&gt;

@others

g.pr('*' * 60)
ok,taglist,nextindex = tt.tag(s,lineTable)
# g.pr(g.listToString(taglist))
for z in taglist:
    printItem(z,level=0)
g.pr('ok:',ok)
</t>
<t tx="ekr.20080531131542.2">from mx.TextTools import * # Required for tags.

ws_charset   = CharSet(' \t')
name_charset = CharSet(alpha)

gnxTable = (
    (None,Is,':',MatchFail),
    (None,AllNotIn,':',MatchFail),
    (None,Is,':',MatchFail,MatchOk),
)

sentinelNameTable = (
    (None,Is,'@',+1,+3),
    (None,Is,'+',+1,+2),
    (None,Is,'-',+1),
    (None,AllInCharSet,name_charset,MatchFail,MatchOk),
)

sentinelTable = (
    # Start of another line.
    # Skip ws.
    (None,AllInCharSet,ws_charset,+1),
    # Require sentinel comment.
    (None,Word,'#@',MatchFail),
    ('kind',Table,sentinelNameTable,MatchFail),
    ('gnx',Table,gnxTable,+1),
    # Everything else is the sentinel value
    ('extra',AllNotIn,'\n',+1),
    (None,Is,'\n',MatchOk,MatchOk),
)

normalLineTable = (
    (None,AllNotIn,'\n',+1),
    (None,Is,'\n',MatchOk,MatchOk),
)

lineTable = (
    ('sent',Table,sentinelTable,+1,+2),
    ('line',Table,normalLineTable,+1,+1),
    ('eof',EOF,Here,-2),
)</t>
<t tx="ekr.20080531131542.4">def printItem(aList,level):

    obj,lt_index,rt_index,subtag = aList
    g.pr('  '*level,obj,repr(s[lt_index:rt_index]))
    if subtag:
        for z in subtag:
            printItem(z,level+1)
</t>
<t tx="ekr.20080531141227.1">path = r'c:\leo.repo\trunk\leo\core\runLeo.py'
f = file(path)
s = f.read()
f.close()</t>
<t tx="ekr.20080604101239.1">Martin Lëwis and friends.</t>
<t tx="ekr.20080604104453.5">@nocolor

This setting determines the initial binding for otherwise-unbound keystrokes
when no mode is in effect.  Note: the keyboard-quit command exits all modes.

The valid values are::

command:  Leo ignores the key (like Vim).
insert:  Leo inserts the key at the cursor (like Emacs)
overwrite: Leo replaces the character at the cursor.</t>
<t tx="ekr.20080610144233.1">aaaaaaaaaaaa bbbbbbbbbbbbbbbbbb cccccccccccccccc ddddddddddddddddddd eeeeeeeeeeeeeee ffffffffffffffffff ggggggggggggggggggggg hhhhhhhhhhhhhhhh iiiiiiiiiiiii jjjjjjjjjjjjjjjj kkkkkkkkkkkkkk llllllllllllll mmmmmmmmmmmmmmmmm nnnnnnnnnnnn ooooooooo</t>
<t tx="ekr.20080617170334.1">@first # -*- coding: utf-8 -*-

import Tkinter as Tk

top = Tk.Toplevel()
w = Tk.Text(top)
w.pack()

def key(event):
    if event.char: g.pr('state',event.state,'char', repr(event.char), repr(event.keysym))

def after():
    g.trace()
    w.event_generate('&lt;Key&gt;',keysym='a')
    w.event_generate('A')
    w.event_generate(g.toEncodedString('Á',encoding='utf8'))
    # w.event_generate('&lt;Key-Control_L&gt;')
    # w.event_generate('c')
    # w.event_generate('Shift-Control-a')

w.bind('&lt;Key&gt;',key)
w.focus_set()
w.update()
# top.after_idle(after)
top.mainloop()
</t>
<t tx="ekr.20080628094340.1">if 0:
    # Called when func is **defined**
    def leo_command(func):
        g.trace(func.__name__)
        return func
else:
    class leo_command:
        def __init__(self,func,c=c):
            self.c = c
            self.func = func
            self.name = func.__name__
            g.pr("registering",self.name)

        def __call__(__self,*__args,**__kw):
            g.pr("before", __self.name)
            try:
                return __self.func(*__args,**__kw)
            finally:
                g.pr("after ", __self.name)
                g.pr('c',c)
                c.outerUpdate()


@leo_command
def hello():
    g.pr("Hello, world!")

hello()
</t>
<t tx="ekr.20080701101740.1">import locale
aList = dir(locale)
# g.pr(g.listToString(aList))

g.pr(g.getpreferredencoding())
# import os
# g.pr(dir(os))
</t>
<t tx="ekr.20080701130406.1">import glob

aList = glob.glob(r'c:\leo.repo\trunk\leo\plugins\*.py')
for z in aList:
    name = g.shortFileName(z)
    if not name.startswith('_'):
        g.pr('echo .')
        g.pr('echo',name)
        g.pr('call pylint.bat core\%s' % name)</t>
<t tx="ekr.20080729153237.1"></t>
<t tx="ekr.20080729153237.2"># True: calls to the garbage collector.</t>
<t tx="ekr.20080729153237.3"># True (recommended): print a message when Leo calls gc.collect explicitly.</t>
<t tx="ekr.20080729153237.4"># True: verbose trace the garbage collector.</t>
<t tx="ekr.20080801160915.1">@others
</t>
<t tx="ekr.20080803120643.1">def spam():
    pass</t>
<t tx="ekr.20080806145258.1">@language javascript

/**********************************************
* Contractible Headers script- © Dynamic Drive (www.dynamicdrive.com)
* This notice must stay intact for legal use. Last updated Mar 23rd, 2004.
* Visit http://www.dynamicdrive.com/ for full source code
***********************************************/

// alert("start");

var enablepersist="on" //Enable saving state of content structure using session cookies? (on/off)
var collapseprevious="no" //Collapse previously open content when opening present? (yes/no)

if (document.getElementById){
    document.write('&lt;style type="text/css"&gt;')
    document.write('.switchcontent{display:none;}')
    document.write('&lt;\/style&gt;')
}

@others</t>
<t tx="ekr.20080806145258.2">function getElementbyClass(classname){
    ccollect=new Array()
    var inc=0
    var alltags=document.all? document.all : document.getElementsByTagName("*")
    for (i=0; i&lt;alltags.length; i++){
        if (alltags[i].className==classname)
            ccollect[inc++]=alltags[i]
    }
}

</t>
<t tx="ekr.20080806145258.3">function contractcontent(omit){
    var inc=0
    while (ccollect[inc]){
        if (ccollect[inc].id!=omit)
        ccollect[inc].style.display="none"
        inc++
    }
}
</t>
<t tx="ekr.20080806145258.4">function expandcontent(cid){
    if (typeof ccollect!="undefined"){
        if (collapseprevious=="yes")
            contractcontent(cid)
        document.getElementById(cid).style.display=(document.getElementById(cid).style.display!="block")? "block" : "none"
    }
}
</t>
<t tx="ekr.20080806145258.5">function revivecontent(){
    contractcontent("omitnothing")
    selectedItem=getselectedItem()
    selectedComponents=selectedItem.split("|")
    for (i=0; i&lt;selectedComponents.length-1; i++)
        document.getElementById(selectedComponents[i]).style.display="block"
}

</t>
<t tx="ekr.20080806145258.6">function get_cookie(Name) { 
    var search = Name + "="
    var returnvalue = "";
    if (document.cookie.length &gt; 0) {
        offset = document.cookie.indexOf(search)
        if (offset != -1) { 
            offset += search.length
            end = document.cookie.indexOf(";", offset);
            if (end == -1) end = document.cookie.length;
            returnvalue=unescape(document.cookie.substring(offset, end))
        }
    }
    return returnvalue;
}

</t>
<t tx="ekr.20080806145258.7">function getselectedItem(){
    if (get_cookie(window.location.pathname) != ""){
        selectedItem=get_cookie(window.location.pathname)
        return selectedItem
    }
    else
        return ""
}

</t>
<t tx="ekr.20080806145258.8">function saveswitchstate(){
    var inc=0, selectedItem=""
    while (ccollect[inc]){
        if (ccollect[inc].style.display=="block")
            selectedItem+=ccollect[inc].id+"|"
        inc++
    }
    document.cookie=window.location.pathname+"="+selectedItem
}

</t>
<t tx="ekr.20080806145258.9">function do_onload(){
    // alert("do_onload");
    uniqueidn=window.location.pathname+"firsttimeload"
    getElementbyClass("switchcontent")
    if (enablepersist=="on" &amp;&amp; typeof ccollect!="undefined"){
        document.cookie=(get_cookie(uniqueidn)=="")? uniqueidn+"=1" : uniqueidn+"=0" 
        firsttimeload=(get_cookie(uniqueidn)==1)? 1 : 0 //check if this is 1st page load
        if (!firsttimeload)
        revivecontent()
    }
}

if (window.addEventListener)
    window.addEventListener("load", do_onload, false)
else if (window.attachEvent)
    window.attachEvent("onload", do_onload)
else if (document.getElementById)
    window.onload=do_onload

if (enablepersist=="on" &amp;&amp; document.getElementById)
    window.onunload=saveswitchstate

</t>
<t tx="ekr.20080806145258.10">function format() {

    return;

    // var sections = document.getElementsByTagName("pre");  // EKR: was span.
    // //alert("format:" + sections.length + "sections")
    // for(i=0; i &lt; sections.length; i++) {
        // formatText(sections[i]);
    // }
}
</t>
<t tx="ekr.20080806145258.11">function formatText(item) {

    ;
    // alert(item);
}
</t>
<t tx="ekr.20080806145258.12">@nocolor

Notes:
    
- button Leo2dHTML creates leo\test\x.htm, where x is the name of the .leo file
  containing the script. The file contains javascript that allows a browser to
  expand and contract headlines.  Leo2DHTML is *unrelated* to the other files.
    
- leo\test\server.py is a minimal Python server.  Invoke from a console with::
    
    python server.py

To use this server, type this url in a web browser: http://localhost:8080/
The server will print the contents of the directory from which it was invoked.
Choose hello.html to see the 'Hello World' test page.

- leo\test\hello.html is a test page.  It uses leo\test\cgi-bin\edward.py

- leo\test\cgi-bin\edward.py is the script called from hello.leo when the user
  hits the 'Submit Query button.
  This is recompiled (as needed) for every query, which makes testing it easier.
  
  **Important** edward.py returns its result by printing (in a special format):
  Thus, everything you print will be part of the returned form(!). You **can**
  print debug info: just make sure you don't mess up the special conventions:
  the best place to print debugging info is in print_all.

@color</t>
<t tx="ekr.20080806145258.13">@

edward.py:
    
How can we get the content of an input form?</t>
<t tx="ekr.20080806145258.14">@first # -*- coding: utf-8 -*-
@language python
@tabwidth -4

&lt;&lt; about LeoToHTML &gt;&gt;
import leo.core.leoGlobals as g
&lt;&lt; define dhtml stuff &gt;&gt;
@others

fileName = c.frame.shortFileName() # Get current outline file name
if fileName.endswith('.leo'): fileName = fileName[:-4] # Remove .leo suffix
path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test',fileName)) + '.htm'

# Write the file.
f=open(path, 'w')
writeAll(f)
f.close() 
g.es('wrote: %s' % (path),color="turquoise4") 
</t>
<t tx="ekr.20080806145258.15">@

LeoToHTML by Dan Rahmel, modified by EKR.

This @button script creates an .htm file containing the contents of the selected tree.
The file is called x.htm, where x is the name of the .leo file containing the script.
This file is written to the leo/test folder.

The script inserts javascript into the page so that nodes can be expanded and contracted.

The script presently works well.  This script may become the basis for a facebook app.

The generated html passes html-tidy: http://www.w3.org/People/Raggett/tidy/
</t>
<t tx="ekr.20080806145258.16">division = """
&lt;div STYLE="margin-left:3em;text-indent:0em;margin-top:0em; margin-bottom:0em;"&gt;
&lt;h3 onClick="expandcontent('sc%d')" style="cursor:hand; cursor:pointer; margin-top:0em; margin-bottom:0em"&gt;+ %s&lt;/h3&gt;
    &lt;div id="sc%d" class="switchcontent" style="margin-top:0em; margin-bottom:0em;"&gt;
"""

javascript  = """
&lt;script src="cgi-bin/leo.js" type="text/javascript"&gt;&lt;/script&gt;
"""

style = '''
&lt;STYLE type="text/css"&gt;
    BODY {font:x-medium 'Verdana'; margin-right:1.5em}
    PRE {margin:0px; display:inline}
&lt;/STYLE&gt;
'''
</t>
<t tx="ekr.20080806145258.17">def escape (s):

    return s.replace('&amp;','&amp;amp;').replace('&lt;','&amp;lt;').replace('&gt;','&amp;gt;')
</t>
<t tx="ekr.20080806145258.18">def writeAll(f):

    f.write('&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;')
    f.write('&lt;html&gt;')
    writeHead(f)
    writeBody(f)
    f.write("&lt;/html&gt;")
</t>
<t tx="ekr.20080806145258.19">def writeBody(f):

    f.write('&lt;body class="st" onload="format()"&gt;')
    writeContents(f)
    f.write("&lt;/body&gt;")
</t>
<t tx="ekr.20080806145258.20">def writeHead(f):

    f.write('&lt;head&gt;')
    f.write(style)
    f.write(javascript)
    f.write('&lt;title&gt;%s&lt;/title&gt;' % c.shortFileName())
    f.write('&lt;/head&gt;')
</t>
<t tx="ekr.20080806145258.21">def writeContents(f):

    div = "&lt;div class='c' STYLE='margin-left:4em;margin-top:0em; margin-bottom:0em;'&gt;\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n&lt;/div&gt;"
    end_div = "&lt;/div&gt;\n&lt;/div&gt;\n"
    n = 1 # The node number
    current = c.currentPosition()
    prev_level = current.level()
    open_divs = 0
    for p in current.self_and_subtree_iter():
        h = p.headString()
        while prev_level &gt;= p.level() and open_divs &gt; 0:
            f.write(end_div)
            prev_level -= 1
            open_divs -= 1
        body = p.bodyString().encode( "utf-8" )
        body = body.rstrip().rstrip("\n")
        f.write(division % (n,escape(h),n))
        open_divs += 1
        if body:
            f.write(div % escape(body))
        prev_level = p.level()
        n += 1

    # Close all divisions.
    while open_divs &gt; 0:
        f.write(end_div)
        open_divs -= 1
</t>
<t tx="ekr.20080806145258.22"># def writePreamble(f):

    # '''Write HTML header information.'''

    # header_start = '''\


# &lt;body class="st" onload="format()"&gt;
# '''

    # for s in (header_start,style,javascript,header_end):
        # # f.write(g.adjustTripleString(s,c.tab_width))
        # f.write(s)
</t>
<t tx="ekr.20080806145258.23"># def writePostamble (f):

    # pass

</t>
<t tx="ekr.20080806145258.24"># A minimal python server for testing.
# To access this server, type this url in a web browser: http://localhost:8080/
# The server will print the contents of the directory from which it was invoked.
# Choose hello.html to see the 'Hello World' test page.

import CGIHTTPServer
import SocketServer

port = 8080

Handler = CGIHTTPServer.CGIHTTPRequestHandler
s = SocketServer.TCPServer(("", port), Handler)

s.server_name = '127.0.0.1' # represents local host.
s.server_port = port

# import os ; print 'cwd', os.getcwd()

print "server.py: serving at port", port
s.serve_forever()
</t>
<t tx="ekr.20080806145258.25">@language html

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;/title&gt;

&lt;!-- Used by edward.old.py
&lt;script language="JavaScript" type="text/javascript"&gt;
   var openImg = new Image();
   openImg.src = "open.gif";
   var closedImg = new Image();
   closedImg.src = "closed.gif";

   function showNode(node) {
      var objBranch = 
         document.getElementById(node).style;
      if(objBranch.display=="block")
         objBranch.display="none";
      else
         objBranch.display="block";
   }

   function swapFolder(img) {
      objImg = document.getElementById(img);
      if(objImg.src.indexOf('closed.gif')&gt;-1)
         objImg.src = openImg.src;
      else
         objImg.src = closedImg.src;
   }
&lt;/script&gt;
--&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;form action="cgi-bin/edward.py" method="GET"&gt;
&lt;input type="submit" name="George"&gt;
&lt;/form&gt;

&lt;p&gt;This is the hello world test page.
The server in server.py should be running when using this page.

&lt;p&gt;The button (form) above should cause the server to send a "GET" request
to the edward.py script, which will respond with a new page.

&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20080806145258.26">@first #! c:\python25\python.exe
@first # -*- coding: utf-8 -*-

'''This is the cgi script called from hello.html when the user hits the button.'''

### Print statements are used to return results (return the form).
### You *can* use print statement for tracing, but only in print_all.
# To do: use cgi.FieldStorage.

@language python
@tabwidth -4
&lt;&lt; imports &gt;&gt;
&lt;&lt; define dhtml stuff &gt;&gt;
@others

if 1: # Open the bridge.
    path = os.path.abspath(os.path.join(leoParentDir,'leo','test','test.leo')) # c does not exist!
    b = leoBridge.controller(gui='nullGui',loadPlugins=False,readSettings=False,verbose=False)
    g = b.globals()
    c = b.openLeoFile(path)
    p = c.rootPosition()
else:
    c = None

# import pdb ; pdb.Pdb() # Doesn't work.
print_all(c)</t>
<t tx="ekr.20080806145258.27">division = """
&lt;div STYLE="margin-left:3em;text-indent:0em;margin-top:0em; margin-bottom:0em;"&gt;
&lt;h3 onClick="expandcontent('sc%d')" style="cursor:hand; cursor:pointer; margin-top:0em; margin-bottom:0em"&gt;+ %s&lt;/h3&gt;
    &lt;div id="sc%d" class="switchcontent" style="margin-top:0em; margin-bottom:0em;"&gt;
"""

style = """
&lt;STYLE type="text/css"&gt;
    BODY {font:x-medium 'Verdana'; margin-right:1.5em}
    PRE {margin:0px; display:inline}
&lt;/STYLE&gt;
"""</t>
<t tx="ekr.20080806145258.28">def escape (s):

    return s.replace('&amp;','&amp;amp;').replace('&lt;','&amp;lt;').replace('&gt;','&amp;gt;')
</t>
<t tx="ekr.20080806145258.29">def print_all(c):

    # This line is required (with extra newline), but does not show on the page.
    print "Content-type:text/html\n"

    print '&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;'
    print '&lt;html&gt;'
    if c:
        # Print the page.
        print_head(c)
        print_body(c)
    else:
        # Print the debugging info.
        print '__file__',__file__
        print 'os.getcwd()',os.getcwd()

    print '&lt;/html&gt;'
</t>
<t tx="ekr.20080806145258.30">def print_body(c):

    print '&lt;body class="st" onload="format()"&gt;'

    if 0:
        # Debugging info.
        form = cgi.FieldStorage()
        print repr(form)
        # if form.has_key('name'):
            # print 'name',form['name'].value
        # else:
            # print 'no name'
    print_tree(c)
    print '&lt;/body&gt;'
</t>
<t tx="ekr.20080806145258.31">def print_head(c):

    print '&lt;head&gt;'

    if 1: # Copy the entire leo.js file into the page.
        print '&lt;script type="text/javascript"&gt;'
        print_leo_dot_js(c)
        print '&lt;/script&gt;'

    else: # Possible bug in the python server??
        # The Python says leo.js is not executable(!)
        print '&lt;script src="leo.js" type="text/javascript"&gt;&lt;/script&gt;'

    print '&lt;title&gt;%s&lt;/title&gt;' % (c.shortFileName())
    print '&lt;/head&gt;'
</t>
<t tx="ekr.20080806145258.32">def print_leo_dot_js(c):

    path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','cgi-bin','leo.js'))

    try:
        f = file(path)
    except IOError:
        print 'can not open',path
        return

    for line in f.readlines():
        print line,

    f.close()
</t>
<t tx="ekr.20080806145258.33">def print_tree(c):

    div = "&lt;div class='c' STYLE='margin-left:4em;margin-top:0em; margin-bottom:0em;'&gt;\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n&lt;/div&gt;"
    end_div = "&lt;/div&gt;\n&lt;/div&gt;\n"
    n = 1 # The node number
    prev_level = 0
    open_divs = 0
    for p in c.allNodes_iter():
        h = p.headString()
        while prev_level &gt;= p.level() and open_divs &gt; 0:
            print end_div
            prev_level -= 1
            open_divs -= 1
        body = p.bodyString().encode( "utf-8" )
        body = body.rstrip().rstrip("\n")
        print division % (n,escape(h),n)
        open_divs += 1
        if body: print div % escape(body)
        prev_level = p.level()
        n += 1

    # Close all divisions.
    while open_divs &gt; 0:
        print end_div
        open_divs -= 1
</t>
<t tx="ekr.20080806145258.34"></t>
<t tx="ekr.20080806145702.1">import os
import sys

# Add the *parent* of the leo directory to sys.path.
leoParentDir = os.path.abspath(os.path.join(os.path.dirname(__file__),'..','..','..'))

if leoParentDir not in sys.path:
    sys.path.append(leoParentDir)

import leo.core.leoBridge as leoBridge

import cgi
import cgitb ; cgitb.enable()
</t>
<t tx="ekr.20080807091001.1">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20080807091201.7">#!/usr/local/bin/python
# -*- coding: utf-8 -*-
"""
module docs
"""

</t>
<t tx="ekr.20080807091201.8">class Person(object):
   '''class docs
   '''
   field1 = 10
   field2 = 20

   @others
</t>
<t tx="ekr.20080807091201.9">def talk(self):
    ''' this is the func doc
    '''
    print 'hello world'

</t>
<t tx="ekr.20080807091201.10">class Meta:
    age = 10</t>
<t tx="ekr.20080807114145.2">@
A script button to run any body text as a Windows Script.
See: http://en.wikipedia.org/wiki/Windows_Script_Host

You need the win32 extensions and you must enable the script engine.
Adapted from Active State examples:ch21_active_scripting:ActiveApp.py
http://python.net/crew/mhammond/win32/
@c

&lt;&lt; imports &gt;&gt;

@others

RunCode("python",p.bodyString())
</t>
<t tx="ekr.20080807115344.1">Application.Echo("Hello from Python")
</t>
<t tx="ekr.20080807115344.2">class MySite(axsite.AXSite):
    # Our error handler will simply print to the console.
    def OnScriptError(self, activeScriptError):
        exc = activeScriptError.GetExceptionInfo()
        print "Exception:", exc[1]
        try:
            sourceText = activeScriptError.GetSourceLineText()
        except pythoncom.com_error:
            sourceText = None
        if sourceText is not None: 
            context, lineNo, charNo = activeScriptError.GetSourcePosition()
            print sourceText
            indent = " " * (charNo-1)
            print indent + "^"
        return winerror.S_OK
</t>
<t tx="ekr.20080807115344.3"># A named object for our namespace
# A normal Python COM object (minus registration info)
class Application:
    _public_methods_ = [ 'Echo' ]
    def Echo(self, *args):
        print string.join(map(str, args))

</t>
<t tx="ekr.20080807115344.4"># Create the site and the engine and runs the code.
def RunCode(engineName, code):

    app = win32com.server.util.wrap( Application() )

    # Create a dictionary holding our object model.
    model = {'Application' : app,}

    # Create the scripting site.
    site = MySite(model)
    # Create the engine and add the code.
    engine = site.AddEngine(engineName)
    engine.AddCode(code)

    # Run the code.
    engine.Start()
</t>
<t tx="ekr.20080807115344.5">import string
import sys
from win32com.axscript import axscript
from win32com.axscript.server import axsite
import pythoncom
import win32com.server.util</t>
<t tx="ekr.20080811112727.1">False: (recommended) Enable import parsing for @shadow and @auto
True: @shadow and @auto create a single node for the entire file.</t>
<t tx="ekr.20080811113441.2"></t>
<t tx="ekr.20080812102914.1">root first line
@others
root last line</t>
<t tx="ekr.20080812102914.2">child line 1
child line 2</t>
<t tx="ekr.20080812112440.1">@language ini
[section]
blah blah
changed
changed2
changed3
changed4
change5</t>
<t tx="ekr.20080812135254.1"># Line one
# line two</t>
<t tx="ekr.20080813080627.1">@others</t>
<t tx="ekr.20080813080627.2">def spam():
    pass</t>
<t tx="ekr.20080813080627.3">def eggs():
    pass</t>
<t tx="ekr.20080813080729.1"></t>
<t tx="ekr.20080813080809.1"></t>
<t tx="ekr.20080813100905.1">import sys
print sys.argv</t>
<t tx="ekr.20080815073750.1">n = 0
for p in c.allNodes_iter():
    if p.isAtNoSentFileNode():
        c.atFileCommands.write(p,nosentinels=True)
        n += 1
g.es('done: %s files written' %(n))</t>
<t tx="ekr.20080819095720.1">@language unknown_language
# huh language .................
changed 7
</t>
<t tx="ekr.20080821111715.1">@first # -*- coding: utf-8 -*-

# Important: see http://webpages.charter.net/edreamleo/FAQ.html#unicode-issues

import sys
        
print '=' * 40

e = sys.getdefaultencoding()
assert e.lower() == 'utf-8'
print 'encoding',e

table = (
    'La Peña',
    unicode('La Peña','utf-8'),
    u'La Peña',
    u'La Pe\xf1a',
    # u'AA \u0102 BB',
)

for s in table:
    print type(s)
    g.es_print('g.es_print',s)
    if type(s) != type(u'a'):
        s = unicode(s,e)
    print      'print     ',s
    print      'repr(s)   ',repr(s)</t>
<t tx="ekr.20080822153619.1"></t>
<t tx="ekr.20080823154546.1">p2 = p.insertAfter()
p2.setHeadString('inserted node')
s = p.bodyString()

# Remove Leo directives.
directives = ['@'+z for z in g.globalDirectiveList]
def isDirective(s):
    for z in directives:
        if s.startswith(z):
            return True
    else: return False
aList = [z for z in g.splitLines(s) if not isDirective(z)]
s = ''.join(aList)
if not s.endswith('\n'): s = s + '\n'

c.importCommands.scanPythonText(s,p2.copy(),atAuto=True)
c.redraw_now()
g.pr('done')</t>
<t tx="ekr.20080909075224.1">@language html
../hex6x -
changed</t>
<t tx="ekr.20080911080311.1">@language conf
; This is a comment
P1 = 0
</t>
<t tx="ekr.20080915095329.1">import leo.core.leoPlugins as leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    controller = rst3.controllers.get(c)
    if controller:
        controller.processTopTree(p)
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True</t>
<t tx="ekr.20080917063615.1">aList = (
'aspellbindir',
'wholeword',
'Whole-Word',
'vimcmd',
'huh',
)

for name in aList:
    kind, val = c.config.getSettingSource(name)
    print '%-20s %-20s %s' % (name,repr(val),kind)
</t>
<t tx="ekr.20080920101658.1">def getInput (event=None):

    '''Evaluate a Python Expression entered in the minibuffer.'''

    stateName = 'get-input'
    k = c.k ; state = k.getState(stateName)

    if state == 0:
        k.setLabelBlue('Input: ',protect=True)
        k.getArg(event,stateName,1,getInput)
    else:
        k.clearState()
        g.es_print('input:',k.arg)

getInput()
</t>
<t tx="ekr.20080921144924.1">print(g.os_path_finalize(r'~/.leo/notebook.leo'))
print(g.os_path_finalize(g.os_path_join(g.app.loadDir,r'~/.leo/notebook.leo')))
print(g.os_path_finalize_join(g.app.loadDir,r'~/.leo/notebook.leo'))</t>
<t tx="ekr.20080922142953.1"># @string default_leo_file = ~/.leo/workbook.leo
path = "{{c.config.getString('default_leo_file')}}"
# print g.os_path_expandExpression(path,c=c)
print g.os_path_finalize(path,c=c)</t>
<t tx="ekr.20080922164255.1"></t>
<t tx="ekr.20080922164255.2"></t>
<t tx="ekr.20080922164656.1"></t>
<t tx="ekr.20080923073240.1">{{c.config.getString('test')}}/eval-test.txt
=
c:\leo.repo\trunk\leo\test\eval-test.txt</t>
<t tx="ekr.20080923073240.2"></t>
<t tx="ekr.20080923173133.1">@markup wiki

@

''text''                # write text in italics</t>
<t tx="ekr.20080924033317.1">@language c

@others</t>
<t tx="ekr.20080924033317.2">int spam():
    ;</t>
<t tx="ekr.20080924081821.1"># c.k.ab

# Test this code using the execute-script command.

s = p.bodyString()
lines = g.splitLines(s)
s = lines[0]

theObject,aList = c.k.autoCompleter.getExternalCompletions(s)

print '='*20
print 'theObject',theObject and theObject.__class__
print 'len(completions)',len(aList)
print g.listToString(aList, tag='completion list', sort=True, indent='')
</t>
<t tx="ekr.20080929112400.1">import PyQt4.Qt as qt
import sys

a=qt.QApplication(sys.argv)
parent = None
w=qt.QPushButton("Hello World",parent) # No parent: top-level.
# a.setMainWidget(w)
w.show()
# print g.listToString(dir(a),sort=True)
a.exec_()
</t>
<t tx="ekr.20080930080501.1">c.frame.iconBar.addRow()
c.frame.addIconButton(text="New")</t>
<t tx="ekr.20080930083052.1">c.frame.hideIconBar()</t>
<t tx="ekr.20080930083052.2">c.frame.showIconBar()</t>
<t tx="ekr.20080930085514.1">c.frame.clearIconBar()</t>
<t tx="ekr.20080930114036.1"></t>
<t tx="ekr.20081001110047.1">@others</t>
<t tx="ekr.20081001110047.2">def spam():
    
    pass # changed</t>
<t tx="ekr.20081001110047.3">def eggs():
    
    pass</t>
<t tx="ekr.20081003094737.1"></t>
<t tx="ekr.20081006070847.2"># aList = g.get_directives_dict_list(p)
# path = c.scanAtPathDirectives(aList)
# filename = p.isAnyAtFileNode()
# print g.os_path_finalize_join(path,filename)

print c.getNodePath (p)

print c.getNodeFileName(p)

</t>
<t tx="ekr.20081020082611.1">class baseClass:

    def foo(self):
        g.trace('baseClass')

class subClass (baseClass):

    def foo(self):
        g.trace('subClass')
        baseClass.foo(self)

z = subClass()
z.foo()
</t>
<t tx="ekr.20081025105942.1">import os
os.system("dir")</t>
<t tx="ekr.20081124102740.1">âäåň</t>
<t tx="ekr.20081202095209.1">import PyQt4.QtCore as QtCore
import PyQt4.QtGui as QtGui

ui = c.frame.top.ui
h =ui.horizontalLayout
v= ui.verticalLayout
v.removeItem(h)
hh = QtGui.QHBoxLayout()
hh.setContentsMargins(0,0,0,0)
hh.expandingDirections = QtCore.Qt.Horizontal

# make the minibuffer area a panel
p = ui.miniBufferPanel =QtGui.QWidget()
p.setLayout(hh)
p.setContentsMargins(0,0,0,0)
hh.addWidget(ui.label)
hh.addWidget(ui.lineEdit)

tb = QtGui.QToolBar()

c.frame.top.addToolBar( QtCore.Qt.BottomToolBarArea,tb)

tb.addWidget(p)
tb.setWindowTitle('Minibuffer')</t>
<t tx="ekr.20081205104320.1"># import os
tag = '#!/bin/bash\n'
s = g.getScript(c,p,
    useSelectedText=False,
    forcePythonSentinels=False,
    useSentinels=True)
if not s.startswith(tag):
    s = tag + s
print s
os.system(s)
</t>
<t tx="ekr.20081216091605.2">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20090102095951.1">import re

class PosList(list):
    def select(self, pat):
        result = PosList()
        for p in self:
            #print "po",p
            for chi_p in p.children_iter():
                #print "chi",chi_p
                if re.match(pat, chi_p.headString()):
                    result.append(chi_p.copy())
        return result

pl = PosList([c.currentPosition()])
print type(pl)
print pl.select('.*')</t>
<t tx="ekr.20090102095951.2"></t>
<t tx="ekr.20090102095951.3"></t>
<t tx="ekr.20090107082739.1">old_g_es = g.es

def g_es (*args,**keys):
    print ''.join(args)

def redirect():
    g.es = g_es

def undirect():
    g.es = old_g_es

g.funcToMethod(redirect,c,name='redirectScriptOutput')
g.funcToMethod(undirect,c,name='unredirectScriptOutput')

print('script output now goes to the console')

</t>
<t tx="ekr.20090114100446.1">plugins_menu.py

vim.py</t>
<t tx="ekr.20090122211549.1">
class test:
    
    '''Class docstring
test line 2'''
    @others
</t>
<t tx="ekr.20090122211549.2">
def spam (self):

    '''Spam docstring.
\\-4spam line 2'''

    pass
</t>
<t tx="ekr.20090128112453.1"># print p.b
# p.b = p.b + '\n# new'
# p.h = p.h + 'z'

print c.p

if 0:
    print p.v.u
    print p.v.u.get('key')
    p.v.u['key'] = 'abc'
    print p.v.u.get('key')
    p.v.u = {'key':'xyz'}
    # p.v.u = 'abc'
    print p.v.u

if 0:
    print p.v.t.u
    print p.v.t.u.get('t-key')
    p.v.t.u['t-key'] = 'pdq'
    print p.v.t.u.get('t-key')
    # p.v.t.u = {'key':'pdq'}
    # # p.v.t.u = 'pdq'
    # print p.v.t.u</t>
<t tx="ekr.20090128131130.1">aList = g.posList(c) # Start with all positions
print len(aList)
aList2 = aList.select('plugin',regex=False,removeClones=True)
print aList2.dump(sort=True)
aList3 = aList2.select('http')
print aList3.dump()

# To see the docstring, enable auto-completion and type g.posList?
# g.posList</t>
<t tx="ekr.20090201162523.1"># define a macro: ctrl-f ab ctrl-r AB
pass</t>
<t tx="ekr.20090201192257.1">b = p.b
try:
    w = c.frame.body.bodyCtrl
    w.setInsertPoint(0)
    m = c.macroCommands
    fn = g.os_path_finalize_join(g.app.loadDir,'..','..','ekr-macros.txt')
    f = open(fn)
    m.loadMacros(f)
    macro = m.namedMacros.get('ab')
    m.executeMacro(macro)
finally:
    assert p.b =='ab' + b,p.b
    p.b = b
</t>
<t tx="ekr.20090205070715.1">#colorer = c.frame.body.colorizer.highlighter.colorer
g.es ('total characters: %s, keywords: %s, leo_keywords: %s' % (
    colorer.totalChars,
    colorer.totalKeywordsCalls,
    colorer.totalLeoKeywordsCalls))</t>
<t tx="ekr.20090206065021.1">@tabwidth -4

#

a = '''ab'''
    # test

b = 'c'

if 1:
    def a():
        pass

# test</t>
<t tx="ekr.20090211123924.1">@color

import time

path = g.os_path_finalize_join(
    g.app.loadDir,'..','plugins','qtGui.py')

s = s2 = open(path).read()

g.es_print('start %s' % len(s2))
t = time.time()

d = {}
for i in range(10000):
    # s2 = s2[:2] + s2[2:-2] + s2[-2:]
    d[i] = s2 = s[:i] + s[:-i]
    # s2 = "hello" + s

t2 = "%1.2f sec" % (time.time()-t)
g.es_print('done %s %s' % (len(s2),t2))
</t>
<t tx="ekr.20090212084402.1">@killcolor

# -*- coding: utf-8 -*-
#@+leo-ver=4-thin
#@+node:ekr.20081121105001.188:@thin qtGui.py
#@@first

'''qt gui plugin.'''

#@@language python
#@@tabwidth -4
#@@pagewidth 80

# safe_mode = False
    # True: Bypass k.masterKeyHandler for problem keys or visible characters.

# Define these to suppress pylint warnings...
__timing = None # For timing stats.
__qh = None # For quick headlines.

#@&lt;&lt; qt imports &gt;&gt;
#@+node:ekr.20081121105001.189: &lt;&lt; qt imports &gt;&gt;
import leo.core.leoGlobals as g

import leo.core.leoChapters as leoChapters
import leo.core.leoColor as leoColor
import leo.core.leoFrame as leoFrame
import leo.core.leoFind as leoFind
import leo.core.leoGui as leoGui
import leo.core.leoKeys as leoKeys
import leo.core.leoMenu as leoMenu

import leo.plugins.baseNativeTree as baseNativeTree

import re
import string

import os
import re # For colorizer
import string
import sys
import time
import types

try:
    # import PyQt4.Qt as Qt # Loads all modules of Qt.
    # import qt_main # Contains Ui_MainWindow class
    import PyQt4.QtCore as QtCore
    import PyQt4.QtGui as QtGui
except ImportError:
    QtCore = None
    print('\nqtGui.py: can not import Qt\n')
try:
    from PyQt4 import Qsci
except ImportError:
    QtCore = None
    print('\nqtGui.py: can not import scintilla for Qt')
    print('\nqtGui.py: qt-scintilla may be a separate package on your system')
    print('\nqtGui.py: e.g. "python-qscintilla2" or similar\n')

#@-node:ekr.20081121105001.189: &lt;&lt; qt imports &gt;&gt;
#@nl

#@+at
# Notes:
# 1. All leoQtX classes are two-way adapator classes
#@-at
#@@c

#@+others
#@+node:ekr.20081121105001.190: Module level

#@+node:ekr.20081121105001.191:init
def init():

    if g.app.unitTesting: # Not Ok for unit testing!
        return False

    if not QtCore:
        return False

    if g.app.gui:
        return g.app.gui.guiName() == 'qt'
    else:
        g.app.gui = leoQtGui()

        # Override g.pdb
        def qtPdb(message=''):
            if message: print message
            import pdb
            QtCore.pyqtRemoveInputHook()
            pdb.set_trace()
        g.pdb = qtPdb

        # if False: # This will be done, if at all, in leoQtBody.
            # def qtHandleDefaultChar(self,event,stroke):
                # # This is an error.
                # g.trace(stroke,g.callers())
                # return False
            # if safe_mode: # Override handleDefaultChar method.
                # h = leoKeys.keyHandlerClass
                # g.funcToMethod(qtHandleDefaultChar,h,"handleDefaultChar")

        g.app.gui.finishCreate()
        g.plugin_signon(__name__)
        return True
#@-node:ekr.20081121105001.191:init
#@+node:ekr.20081121105001.192:embed_ipython
def embed_ipython():

    import IPython.ipapi

    # sys.argv = ['ipython', '-p' , 'sh']
    # ses = IPython.ipapi.make_session(dict(w = window))
    # ip = ses.IP.getapi()
    # ip.load('ipy_leo')
    # ses.mainloop()
#@nonl
#@-node:ekr.20081121105001.192:embed_ipython
#@+node:ekr.20081121105001.193:tstart &amp; tstop
def tstart():
    global __timing
    __timing = time.time()

def tstop():
    return "%1.2f sec" % (time.time()-__timing)
#@-node:ekr.20081121105001.193:tstart &amp; tstop
#@-node:ekr.20081121105001.190: Module level
#@+node:ekr.20081121105001.194:Frame and component classes...
#@+node:ekr.20081121105001.200:class  DynamicWindow
from PyQt4 import uic

class DynamicWindow(QtGui.QMainWindow):

    '''A class representing all parts of the main Qt window
    as created by Designer.

    c.frame.top is a Window object.

    All leoQtX classes use the ivars of this Window class to
    support operations requested by Leo's core.
    '''

    #@    @+others
    #@+node:ekr.20081121105001.201: ctor (Window)
    # Called from leoQtFrame.finishCreate.

    def __init__(self,c,parent=None):

        '''Create Leo's main window, c.frame.top'''

        self.c = c ; top = c.frame.top
        # g.pr('DynamicWindow.__init__',c)

        # Init both base classes.

        ui_file_name = c.config.getString('qt_ui_file_name')
        if not ui_file_name:
            ui_file_name = 'qt_main.ui'

        ui_description_file = g.app.loadDir + "/../plugins/" + ui_file_name
        g.pr(ui_description_file)
        assert g.os_path_exists(ui_description_file)

        QtGui.QMainWindow.__init__(self,parent)        
        self.ui = uic.loadUi(ui_description_file, self)

        # Init the QDesigner elements.
        #self.setupUi(self)

        ivars = """
        tabWidget treeWidget stackedWidget richTextEdit lineEdit
        findPattern findChange checkBoxWholeWord checkBoxIgnoreCase
        checkBoxWrapAround checkBoxReverse checkBoxRexexp checkBoxMarkFinds
        checkBoxEntireOutline checkBoxSubroutineOnly checkBoxNodeOnly
        checkBoxSearchHeadline checkBoxSearchBody checkBoxMarkChanges
        setWindowIcon setWindowTitle show setGeometry windowTitle
        menuBar

        """.strip().split()

        #for v in ivars:
        #    setattr(self, v, getattr(self.ui, v))

        self.iconBar = self.addToolBar("IconBar")
        self.menubar = self.menuBar()
        self.statusBar = QtGui.QStatusBar()
        self.setStatusBar(self.statusBar)

        orientation = c.config.getString('initial_split_orientation')
        self.setSplitDirection(orientation)
        self.setStyleSheets()
    #@+node:leohag.20081203210510.17:do_leo_spell_btn_*
    def doSpellBtn(self, btn):
        getattr(self.c.spellCommands.handler.tab, btn)() 

    def do_leo_spell_btn_Add(self):
        self.doSpellBtn('onAddButton')

    def do_leo_spell_btn_Change(self):
        self.doSpellBtn('onChangeButton')

    def do_leo_spell_btn_Find(self):
        self.doSpellBtn('onFindButton')

    def do_leo_spell_btn_FindChange(self):
        self.doSpellBtn('onChangeThenFindButton')

    def do_leo_spell_btn_Hide(self):
        self.doSpellBtn('onHideButton')

    def do_leo_spell_btn_Ignore(self):
        self.doSpellBtn('onIgnoreButton')
    #@-node:leohag.20081203210510.17:do_leo_spell_btn_*
    #@-node:ekr.20081121105001.201: ctor (Window)
    #@+node:ekr.20081121105001.202:closeEvent (qtFrame)
    def closeEvent (self,event):

        c = self.c

        if c.inCommand:
            # g.trace('requesting window close')
            c.requestCloseWindow = True
        else:
            ok = g.app.closeLeoWindow(c.frame)
            # g.trace('ok',ok)
            if ok:
                event.accept()
            else:
                event.ignore()
    #@-node:ekr.20081121105001.202:closeEvent (qtFrame)
    #@+node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
    def setSplitDirection (self,orientation='vertical'):

        vert = orientation and orientation.lower().startswith('v')
        # g.trace('vert',vert)

        orientation1 = g.choose(vert,QtCore.Qt.Horizontal, QtCore.Qt.Vertical)
        orientation2 = g.choose(vert,QtCore.Qt.Vertical, QtCore.Qt.Horizontal)
        self.splitter.setOrientation(orientation1)
        self.splitter_2.setOrientation(orientation2)
    #@-node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
    #@+node:ekr.20081121105001.203:setStyleSheets &amp; helper
    styleSheet_inited = False

    def setStyleSheets(self):

        trace = False
        c = self.c

        sheet = c.config.getData('qt-gui-plugin-style-sheet')
        if sheet:
            sheet = '\n'.join(sheet)
            if trace: g.trace(len(sheet))
            self.ui.setStyleSheet(sheet or self.default_sheet())
        else:
            if trace: g.trace('no style sheet')
    #@nonl
    #@+node:ekr.20081121105001.204:defaultStyleSheet
    def defaultStyleSheet (self):

        '''Return a reasonable default style sheet.'''

        # Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords
        return '''\

    /* A QWidget: supports only background attributes.*/
    QSplitter::handle {

        background-color: #CAE1FF; /* Leo's traditional lightSteelBlue1 */
    }
    QSplitter {
        border-color: white;
        background-color: white;
        border-width: 3px;
        border-style: solid;
    }
    QTreeWidget {
        background-color: #ffffec; /* Leo's traditional tree color */
    }
    /* Not supported. */
    QsciScintilla {
        background-color: pink;
    }
    '''
    #@-node:ekr.20081121105001.204:defaultStyleSheet
    #@-node:ekr.20081121105001.203:setStyleSheets &amp; helper
    #@-others

#@-node:ekr.20081121105001.200:class  DynamicWindow
#@+node:ekr.20081121105001.205:class leoQtBody (leoBody)
class leoQtBody (leoFrame.leoBody):

    """A class that represents the body pane of a Qt window."""

    #@    @+others
    #@+node:ekr.20081121105001.206: Birth
    #@+node:ekr.20081121105001.207: ctor (qtBody)
    def __init__ (self,frame,parentFrame):

        # Call the base class constructor.
        leoFrame.leoBody.__init__(self,frame,parentFrame)

        c = self.c
        assert c.frame == frame and frame.c == c

        self.useScintilla = c.config.getBool('qt-use-scintilla')

        # Set the actual gui widget.
        if self.useScintilla:
            self.widget = w = leoQScintillaWidget(
                c.frame.top.textEdit,
                name='body',c=c)
            self.bodyCtrl = w # The widget as seen from Leo's core.
            self.colorizer = leoColor.nullColorizer(c)
        else:
            top = c.frame.top ; sw = top.ui.stackedWidget
            sw.setCurrentIndex(1)
            self.widget = w = leoQTextEditWidget(
                top.ui.richTextEdit,
                name = 'body',c=c) # A QTextEdit.
            self.bodyCtrl = w # The widget as seen from Leo's core.

            # Hook up the QSyntaxHighlighter
            self.colorizer = leoQtColorizer(c,w.widget)
            w.acceptRichText = False

        # Config stuff.
        self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
        wrap = c.config.getBool('body_pane_wraps')
        # g.trace('wrap',wrap,self.widget.widget)
        if self.useScintilla:
            pass
        else:
            self.widget.widget.setWordWrapMode(g.choose(wrap,
                QtGui.QTextOption.WordWrap,
                QtGui.QTextOption.NoWrap))
        wrap = g.choose(wrap,"word","none")
        self.wrapState = wrap

        # For multiple body editors.
        self.editor_name = None
        self.editor_v = None
        self.numberOfEditors = 1
        self.totalNumberOfEditors = 1
    #@-node:ekr.20081121105001.207: ctor (qtBody)
    #@+node:ekr.20081121105001.208:createBindings (qtBody)
    def createBindings (self,w=None):

        '''(qtBody) Create gui-dependent bindings.
        These are *not* made in nullBody instances.'''

        # frame = self.frame ; c = self.c ; k = c.k
        # if not w: w = self.widget

        # c.bind(w,'&lt;Key&gt;', k.masterKeyHandler)

        # def onFocusOut(event,c=c):
            # # This interferes with inserting new nodes.
                # # c.k.setDefaultInputState()
            # self.setEditorColors(
                # bg=c.k.unselected_body_bg_color,
                # fg=c.k.unselected_body_fg_color)
            # # This is required, for example, when typing Alt-Shift-anyArrow in insert mode.
            # # But we suppress coloring in the widget.
            # oldState = k.unboundKeyAction
            # k.unboundKeyAction = k.defaultUnboundKeyAction
            # c.k.showStateAndMode(w=g.app.gui.get_focus(c))
            # k.unboundKeyAction = oldState

        # def onFocusIn(event,c=c):
            # # g.trace('callback')
            # c.k.setDefaultInputState()
            # c.k.showStateAndMode()  # TNB - fix color when window manager returns focus to Leo

        # c.bind(w,'&lt;FocusOut&gt;', onFocusOut)
        # c.bind(w,'&lt;FocusIn&gt;', onFocusIn)

        # table = [
            # ('&lt;Button-1&gt;',  frame.OnBodyClick,          k.masterClickHandler),
            # ('&lt;Button-3&gt;',  frame.OnBodyRClick,         k.masterClick3Handler),
            # ('&lt;Double-1&gt;',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
            # ('&lt;Double-3&gt;',  None,                       k.masterDoubleClick3Handler),
            # ('&lt;Button-2&gt;',  frame.OnPaste,              k.masterClickHandler),
        # ]

        # table2 = (
            # ('&lt;Button-2&gt;',  frame.OnPaste,              k.masterClickHandler),
        # )

        # if c.config.getBool('allow_middle_button_paste'):
            # table.extend(table2)

        # for kind,func,handler in table:
            # def bodyClickCallback(event,handler=handler,func=func):
                # return handler(event,func)

            # c.bind(w,kind,bodyClickCallback)
    #@-node:ekr.20081121105001.208:createBindings (qtBody)
    #@+node:ekr.20081121105001.209:get_name
    def getName (self):

        return 'body-widget'
    #@-node:ekr.20081121105001.209:get_name
    #@-node:ekr.20081121105001.206: Birth
    #@+node:ekr.20081121105001.210:Do-nothings

    # Configuration will be handled by style sheets.
    def cget(self,*args,**keys):        return None
    def configure (self,*args,**keys):  pass
    def setEditorColors (self,bg,fg):   pass

    def oops (self):
        g.trace('qtBody',g.callers(3))
    #@-node:ekr.20081121105001.210:Do-nothings
    #@+node:ekr.20081121105001.211:High-level interface to self.widget
    def appendText (self,s):
        return self.widget.appendText(s)

    def bind (self,kind,*args,**keys):
        return self.widget.bind(kind,*args,**keys)

    def deleteTextSelection (self):
        return self.widget.deleteTextSelection()

    def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75):
        return self.widget(i,bg,fg,flashes,delay)

    def get(self,i,j=None):
        return self.widget.get(i,j)

    def getAllText (self):
        return self.widget.getAllText()

    def getFocus (self):
        return self.widget.getFocus()

    def getInsertPoint(self):
        return self.widget.getInsertPoint()

    def getSelectedText (self):
        return self.widget.getSelectedText()

    def getSelectionRange (self,sort=True):
        return self.widget.getSelectionRange(sort)

    def getYScrollPosition (self):
        return self.widget.getYScrollPosition()

    def insert(self,i,s):
        return self.widget.insert(i,s)

    def scrollLines (self,n):
        return self.widget.scrollLines(n)

    def see(self,index):
        return self.widget.see(index)

    def seeInsertPoint(self):
        return self.widget.seeInsertPoint()

    def setAllText (self,s):
        return self.widget.setAllText(s)

    def setBackgroundColor (self,color):
        return self.widget.setBackgroundColor(color)

    def setFocus (self):
        return self.widget.setFocus()

    def setForegroundColor (self,color):
        return self.widget.setForegroundColor(color)

    def setInsertPoint (self,pos):
        return self.widget.setInsertPoint(pos)

    def setSelectionRange (self,sel):
        i,j = sel
        return self.widget.setSelectionRange(i,j)

    def setYScrollPosition (self,i):
        return self.widget.setYScrollPosition(i)
    #@-node:ekr.20081121105001.211:High-level interface to self.widget
    #@+node:ekr.20081121105001.212:Editors (qtBody)
    # This code uses self.pb, a paned body widget,
    # created by tkBody.finishCreate.
    #@+node:ekr.20081121105001.213:createEditorFrame
    def createEditorFrame (self,pane):

        return None

        # f = Tk.Frame(pane)
        # f.pack(side='top',expand=1,fill='both')
        # return f
    #@-node:ekr.20081121105001.213:createEditorFrame
    #@+node:ekr.20081121105001.214:packEditorLabelWidget
    def packEditorLabelWidget (self,w):

        '''Create a Tk label widget.'''

        # if not hasattr(w,'leo_label') or not w.leo_label:
            # # g.trace('w.leo_frame',id(w.leo_frame))
            # w.pack_forget()
            # w.leo_label = Tk.Label(w.leo_frame)
            # w.leo_label.pack(side='top')
            # w.pack(expand=1,fill='both')
    #@nonl
    #@-node:ekr.20081121105001.214:packEditorLabelWidget
    #@+node:ekr.20081121105001.215:entries
    if 1:
        #@    @+others
        #@+node:ekr.20081121105001.216:addEditor
        def addEditor (self,event=None):

            '''Add another editor to the body pane.'''

            self.editorWidgets['1'] = self.c.frame.body.bodyCtrl

            # c = self.c ; p = c.currentPosition()

            # self.totalNumberOfEditors += 1
            # self.numberOfEditors += 1

            # if self.numberOfEditors == 2:
                # # Inject the ivars into the first editor.
                # # Bug fix: Leo 4.4.8 rc1: The name of the last editor need not be '1'
                # d = self.editorWidgets ; keys = d.keys()
                # if len(keys) == 1:
                    # w_old = d.get(keys[0])
                    # self.updateInjectedIvars(w_old,p)
                    # self.selectLabel(w_old) # Immediately create the label in the old editor.
                # else:
                    # g.trace('can not happen: unexpected editorWidgets',d)

            # name = '%d' % self.totalNumberOfEditors
            # pane = self.pb.add(name)
            # panes = self.pb.panes()
            # minSize = float(1.0/float(len(panes)))

            # f = self.createEditorFrame(pane)
            # 
            #@nonl
            #@&lt;&lt; create text widget w &gt;&gt;
            #@+node:ekr.20081121105001.217:&lt;&lt; create text widget w &gt;&gt;
            # w = self.createTextWidget(f,name=name,p=p)
            # w.delete(0,'end')
            # w.insert('end',p.bodyString())
            # w.see(0)

            # self.setFontFromConfig(w=w)
            # self.setColorFromConfig(w=w)
            # self.createBindings(w=w)
            # c.k.completeAllBindingsForWidget(w)

            # self.recolorWidget(p,w)
            #@nonl
            #@-node:ekr.20081121105001.217:&lt;&lt; create text widget w &gt;&gt;
            #@nl
            # self.editorWidgets[name] = w

            # for pane in panes:
                # self.pb.configurepane(pane,size=minSize)

            # self.pb.updatelayout()
            # c.frame.body.bodyCtrl = w

            # self.updateInjectedIvars(w,p)
            # self.selectLabel(w)
            # self.selectEditor(w)
            # self.updateEditors()
            # c.bodyWantsFocusNow()
        #@-node:ekr.20081121105001.216:addEditor
        #@+node:ekr.20081121105001.218:assignPositionToEditor
        def assignPositionToEditor (self,p):

            '''Called *only* from tree.select to select the present body editor.'''

            c = self.c ; cc = c.chapterController ; w = c.frame.body.bodyCtrl

            # self.updateInjectedIvars(w,p)
            # self.selectLabel(w)

            # g.trace('===',id(w),w.leo_chapter.name,w.leo_p.headString())
        #@-node:ekr.20081121105001.218:assignPositionToEditor
        #@+node:ekr.20081121105001.219:cycleEditorFocus
        def cycleEditorFocus (self,event=None):

            '''Cycle keyboard focus between the body text editors.'''

            # c = self.c ; d = self.editorWidgets ; w = c.frame.body.bodyCtrl
            # values = d.values()
            # if len(values) &gt; 1:
                # i = values.index(w) + 1
                # if i == len(values): i = 0
                # w2 = d.values()[i]
                # assert(w!=w2)
                # self.selectEditor(w2)
                # c.frame.body.bodyCtrl = w2
                # # g.pr('***',g.app.gui.widget_name(w2),id(w2))

            # return 'break'
        #@-node:ekr.20081121105001.219:cycleEditorFocus
        #@+node:ekr.20081121105001.220:deleteEditor
        def deleteEditor (self,event=None):

            '''Delete the presently selected body text editor.'''

            # c = self.c ; w = c.frame.body.bodyCtrl ; d = self.editorWidgets

            # if len(d.keys()) == 1: return

            # name = w.leo_name

            # del d [name] 
            # self.pb.delete(name)
            # panes = self.pb.panes()
            # minSize = float(1.0/float(len(panes)))

            # for pane in panes:
                # self.pb.configurepane(pane,size=minSize)

            # # Select another editor.
            # w = d.values()[0]
            # # c.frame.body.bodyCtrl = w # Don't do this now?
            # self.numberOfEditors -= 1
            # self.selectEditor(w)
        #@-node:ekr.20081121105001.220:deleteEditor
        #@+node:ekr.20081121105001.221:findEditorForChapter (leoBody)
        def findEditorForChapter (self,chapter,p):

            '''Return an editor to be assigned to chapter.'''

            return self.c.frame.body.bodyCtrl

            # c = self.c ; d = self.editorWidgets ; values = d.values()

            # # First, try to match both the chapter and position.
            # if p:
                # for w in values:
                    # if (
                        # hasattr(w,'leo_chapter') and w.leo_chapter == chapter and
                        # hasattr(w,'leo_p') and w.leo_p and w.leo_p == p
                    # ):
                        # # g.trace('***',id(w),'match chapter and p',p.headString())
                        # return w

            # # Next, try to match just the chapter.
            # for w in values:
                # if hasattr(w,'leo_chapter') and w.leo_chapter == chapter:
                    # # g.trace('***',id(w),'match only chapter',p.headString())
                    # return w

            # # As a last resort, return the present editor widget.
            # # g.trace('***',id(self.bodyCtrl),'no match',p.headString())
            # return c.frame.body.bodyCtrl
        #@-node:ekr.20081121105001.221:findEditorForChapter (leoBody)
        #@+node:ekr.20081121105001.222:select/unselectLabel
        def unselectLabel (self,w):

            pass

            # self.createChapterIvar(w)
            # self.packEditorLabelWidget(w)
            # s = self.computeLabel(w)
            # if hasattr(w,'leo_label') and w.leo_label:
                # w.leo_label.configure(text=s,bg='LightSteelBlue1')

        def selectLabel (self,w):

            pass

            # if self.numberOfEditors &gt; 1:
                # self.createChapterIvar(w)
                # self.packEditorLabelWidget(w)
                # s = self.computeLabel(w)
                # # g.trace(s,g.callers())
                # if hasattr(w,'leo_label') and w.leo_label:
                    # w.leo_label.configure(text=s,bg='white')
            # elif hasattr(w,'leo_label') and w.leo_label:
                # w.leo_label.pack_forget()
                # w.leo_label = None
        #@-node:ekr.20081121105001.222:select/unselectLabel
        #@+node:ekr.20081121105001.223:selectEditor &amp; helpers
        selectEditorLockout = False

        def selectEditor(self,w):

            '''Select editor w and node w.leo_p.'''

            return self.c.frame.body.bodyCtrl

            #  Called by body.onClick and whenever w must be selected.
            # trace = False
            # c = self.c
            # if not w: return self.c.frame.body.bodyCtrl
            # if self.selectEditorLockout: return

            # if w and w == self.c.frame.body.bodyCtrl:
                # if w.leo_p and w.leo_p != c.currentPosition():
                    # c.selectPosition(w.leo_p)
                    # c.bodyWantsFocusNow()
                # return

            # try:
                # val = None
                # self.selectEditorLockout = True
                # val = self.selectEditorHelper(w)
            # finally:
                # self.selectEditorLockout = False

            # return val # Don't put a return in a finally clause.
        #@+node:ekr.20081121105001.224:selectEditorHelper
        def selectEditorHelper (self,w):

            c = self.c ; cc = c.chapterController ; d = self.editorWidgets

            trace = False

            if not w.leo_p:
                g.trace('no w.leo_p') 
                return 'break'

            if trace:
                g.trace('==1',id(w),
                    hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
                    hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

            self.inactivateActiveEditor(w)

            # The actual switch.
            c.frame.body.bodyCtrl = w
            w.leo_active = True

            self.switchToChapter(w)
            self.selectLabel(w)

            if not self.ensurePositionExists(w):
                g.trace('***** no position editor!')
                return 'break'

            if trace:
                g.trace('==2',id(w),
                    hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
                    hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

            # g.trace('expanding ancestors of ',w.leo_p.headString(),g.callers())
            c.expandAllAncestors(w.leo_p)
            c.selectPosition(w.leo_p) # Calls assignPositionToEditor.
            c.redraw()

            c.recolor_now()
            #@    &lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
            #@+node:ekr.20081121105001.225:&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
            # g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

            if w.leo_insertSpot:
                w.setInsertPoint(w.leo_insertSpot)
            else:
                w.setInsertPoint(0)

            if w.leo_scrollBarSpot is not None:
                first,last = w.leo_scrollBarSpot
                w.yview('moveto',first)
            else:
                w.seeInsertPoint()

            if w.leo_selection:
                try:
                    start,end = w.leo_selection
                    w.setSelectionRange(start,end)
                except Exception:
                    pass
            #@-node:ekr.20081121105001.225:&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
            #@nl
            c.bodyWantsFocusNow()
            return 'break'
        #@-node:ekr.20081121105001.224:selectEditorHelper
        #@-node:ekr.20081121105001.223:selectEditor &amp; helpers
        #@+node:ekr.20081121105001.226:updateEditors
        # Called from addEditor and assignPositionToEditor

        def updateEditors (self):

            pass

            # c = self.c ; p = c.currentPosition()
            # d = self.editorWidgets
            # if len(d.keys()) &lt; 2: return # There is only the main widget.

            # for key in d:
                # w = d.get(key)
                # v = w.leo_v
                # if v and v == p.v and w != c.frame.body.bodyCtrl:
                    # w.delete(0,'end')
                    # w.insert('end',p.bodyString())
                    # # g.trace('update',w,v)
                    # self.recolorWidget(p,w)

            # c.bodyWantsFocus()
        #@-node:ekr.20081121105001.226:updateEditors
        #@-others
    #@nonl
    #@-node:ekr.20081121105001.215:entries
    #@+node:ekr.20081121105001.227:utils
    #@+node:ekr.20081121105001.228:computeLabel
    def computeLabel (self,w):

        s = w.leo_label_s

        if hasattr(w,'leo_chapter') and w.leo_chapter:
            s = '%s: %s' % (w.leo_chapter.name,s)

        return s
    #@-node:ekr.20081121105001.228:computeLabel
    #@+node:ekr.20081121105001.229:createChapterIvar
    def createChapterIvar (self,w):

        c = self.c ; cc = c.chapterController

        if not hasattr(w,'leo_chapter') or not w.leo_chapter:
            if cc and self.use_chapters:
                w.leo_chapter = cc.getSelectedChapter()
            else:
                w.leo_chapter = None
    #@-node:ekr.20081121105001.229:createChapterIvar
    #@+node:ekr.20081121105001.230:ensurePositionExists
    def ensurePositionExists(self,w):

        '''Return True if w.leo_p exists or can be reconstituted.'''

        c = self.c

        if c.positionExists(w.leo_p):
            return True
        else:
            g.trace('***** does not exist',w.leo_name)
            for p2 in c.all_positions_with_unique_vnodes_iter():
                if p2.v and p2.v == w.leo_v:
                    w.leo_p = p2.copy()
                    return True
            else:
                 # This *can* happen when selecting a deleted node.
                w.leo_p = c.currentPosition()
                return False
    #@-node:ekr.20081121105001.230:ensurePositionExists
    #@+node:ekr.20081121105001.231:inactivateActiveEditor
    def inactivateActiveEditor(self,w):

        '''Inactivate the previously active editor.'''

        d = self.editorWidgets

        # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
        for key in d:
            w2 = d.get(key)
            if w2 != w and w2.leo_active:
                w2.leo_active = False
                self.unselectLabel(w2)
                w2.leo_scrollBarSpot = w2.yview()
                w2.leo_insertSpot = w2.getInsertPoint()
                w2.leo_selection = w2.getSelectionRange()
                # g.trace('inactive:',id(w2),'scroll',w2.leo_scrollBarSpot,'ins',w2.leo_insertSpot)
                # g.trace('inactivate',id(w2))
                return
    #@-node:ekr.20081121105001.231:inactivateActiveEditor
    #@+node:ekr.20081121105001.232:recolorWidget
    def recolorWidget (self,p,w):

        c = self.c ; old_w = c.frame.body.bodyCtrl

        # g.trace('w',id(w),p.headString(),len(w.getAllText()))

        # Save.
        c.frame.body.bodyCtrl = w
        try:
            # c.recolor_now(interruptable=False) # Force a complete recoloring.
            c.frame.body.colorizer.colorize(p,incremental=False,interruptable=False)
        finally:
            # Restore.
            c.frame.body.bodyCtrl = old_w
    #@-node:ekr.20081121105001.232:recolorWidget
    #@+node:ekr.20081121105001.233:switchToChapter (leoBody)
    def switchToChapter (self,w):

        '''select w.leo_chapter.'''

        c = self.c ; cc = c.chapterController

        if hasattr(w,'leo_chapter') and w.leo_chapter:
            chapter = w.leo_chapter
            name = chapter and chapter.name
            oldChapter = cc.getSelectedChapter()
            if chapter != oldChapter:
                # g.trace('===','old',oldChapter.name,'new',name,w.leo_p)
                cc.selectChapterByName(name)
                c.bodyWantsFocusNow()
    #@-node:ekr.20081121105001.233:switchToChapter (leoBody)
    #@+node:ekr.20081121105001.234:updateInjectedIvars
    # Called from addEditor and assignPositionToEditor.

    def updateInjectedIvars (self,w,p):

        c = self.c ; cc = c.chapterController

        if cc and self.use_chapters:
            w.leo_chapter = cc.getSelectedChapter()
        else:
            w.leo_chapter = None

        w.leo_p = p.copy()
        w.leo_v = w.leo_p.v
        w.leo_label_s = p.headString()

        # g.trace('   ===', id(w),w.leo_chapter and w.leo_chapter.name,p.headString())
    #@-node:ekr.20081121105001.234:updateInjectedIvars
    #@-node:ekr.20081121105001.227:utils
    #@-node:ekr.20081121105001.212:Editors (qtBody)
    #@-others
#@-node:ekr.20081121105001.205:class leoQtBody (leoBody)
#@+node:ekr.20081121105001.235:class leoQtFindTab (findTab)
class leoQtFindTab (leoFind.findTab):

    '''A subclass of the findTab class containing all Qt Gui code.'''

    if 0: # We can use the base-class ctor.
        def __init__ (self,c,parentFrame):
            leoFind.findTab.__init__(self,c,parentFrame)
                # Init the base class.
                # Calls initGui, createFrame, createBindings &amp; init(c), in that order.

    # Define these to suppress oops messages.
    def createBindings (self): pass
    def createFindTab (self,c,parentFrame): pass
    def createFrame (self,parentFrame): pass

    #@    @+others
    #@+node:ekr.20081121105001.236: Birth: called from leoFind ctor
    # leoFind.__init__ calls initGui, createFrame, createBindings &amp; init, in that order.
    #@+node:ekr.20081121105001.237:initGui
    def initGui (self):

        owner = self

        self.svarDict = {}
            # Keys are ivar names, values are svar objects.

        for ivar in self.intKeys:
            self.svarDict[ivar] = self.svar(owner,ivar)

        # Add a hack for 'entire_outline' radio button.
        ivar = 'entire_outline'
        self.svarDict[ivar] = self.svar(owner,ivar)

        for ivar in self.newStringKeys:
            self.svarDict[ivar] = self.svar(owner,ivar=None)
    #@-node:ekr.20081121105001.237:initGui
    #@+node:ekr.20081121105001.238:init (qtFindTab) &amp; helpers
    def init (self,c):

        '''Init the widgets of the 'Find' tab.'''

        # g.trace('leoQtFindTab.init')

        self.createIvars()
        self.initIvars()
        self.initTextWidgets()
        self.initCheckBoxes()
        self.initRadioButtons()
    #@+node:ekr.20081121105001.239:createIvars
    def createIvars (self):

        c = self.c ; w = c.frame.top.ui # A Window ui object.

        # Bind boxes to Window objects.
        self.widgetsDict = {} # Keys are ivars, values are Qt widgets.
        data = (
            ('find_ctrl',       findTextWrapper(w.findPattern,'find-widget',c)),
            ('change_ctrl',     findTextWrapper(w.findChange,'change-widget',c)),
            ('whole_word',      w.checkBoxWholeWord),
            ('ignore_case',     w.checkBoxIgnoreCase),
            ('wrap',            w.checkBoxWrapAround),
            ('reverse',         w.checkBoxReverse),
            ('pattern_match',   w.checkBoxRexexp),
            ('mark_finds',      w.checkBoxMarkFinds),
            ('entire_outline',  w.checkBoxEntireOutline),
            ('suboutline_only', w.checkBoxSubroutineOnly),  
            ('node_only',       w.checkBoxNodeOnly),
            ('search_headline', w.checkBoxSearchHeadline),
            ('search_body',     w.checkBoxSearchBody),
            ('mark_changes',    w.checkBoxMarkChanges),
            ('batch', None), ####
        )
        for ivar,widget in data:
            setattr(self,ivar,widget)
            self.widgetsDict[ivar] = widget
            # g.trace(ivar,widget)
    #@-node:ekr.20081121105001.239:createIvars
    #@+node:ekr.20081121105001.240:initIvars
    def initIvars(self):

        c = self.c

        # Separate c.ivars are much more convenient than a svarDict.
        for ivar in self.intKeys:
            # Get ivars from @settings.
            val = c.config.getBool(ivar)
            setattr(self,ivar,val)
            val = g.choose(val,1,0)
            svar = self.svarDict.get(ivar)
            if svar:
                svar.set(val)

            # g.trace(ivar,val)
    #@-node:ekr.20081121105001.240:initIvars
    #@+node:ekr.20081121105001.241:initTextWidgets
    def initTextWidgets(self):

        '''Init the find/change text areas.'''

        c = self.c

        table = (
            (self.find_ctrl,    "find_text",    '&lt;find pattern here&gt;'),
            (self.change_ctrl,  "change_text",  ''),
        )

        for w,setting,defaultText in table:
            # w is a textWrapper object
            w.setAllText(c.config.getString(setting) or defaultText)
    #@-node:ekr.20081121105001.241:initTextWidgets
    #@+node:ekr.20081121105001.242:initCheckBoxes
    def initCheckBoxes (self):

        for ivar,key in (
            ("pattern_match","pattern-search"),
        ):
            svar = self.svarDict[ivar].get()
            if svar:
                self.svarDict["radio-find-type"].set(key)
                w = self.widgetsDict.get(key)
                if w: w.setChecked(True)
                break
        else:
            self.svarDict["radio-find-type"].set("plain-search")

        aList = (
            'ignore_case','mark_changes','mark_finds',
            'pattern_match','reverse','search_body','search_headline',
            'whole_word','wrap',
            # Temp: add boxes that should be radio buttons.
            'node_only','suboutline_only','entire_outline',
        )

        for ivar in aList:
            svar = self.svarDict.get(ivar)
            if svar:
                # w is a QCheckBox.
                w = self.widgetsDict.get(ivar)
                if w:
                    val = svar.get()
                    svar.setWidget(w)
                    svar.set(val)
                    def checkBoxCallback(val,svar=svar):
                        svar.setVal(val)
                        # g.trace(ivar,bool(val))
                    w.connect(w,
                        QtCore.SIGNAL("stateChanged(int)"),
                        checkBoxCallback)
                    # g.trace(ivar,val,w)
                else: g.trace('*** no w',ivar)
            else: g.trace('*** no svar',ivar)
    #@-node:ekr.20081121105001.242:initCheckBoxes
    #@+node:ekr.20081121105001.243:initRadioButtons
    def initRadioButtons (self):

        for ivar,key in (
            ("suboutline_only","suboutline-only"),
            ("node_only","node-only"),
            # ("selection_only","selection-only")
        ):
            svar = self.svarDict[ivar].get()
            if svar:
                self.svarDict["radio-search-scope"].set(key)
                break
        else:
            key = 'entire-outline'
            self.svarDict["radio-search-scope"].set(key)
            # XXX At present w is a QCheckbox, not a QRadioButton.
            w = self.widgetsDict.get(key)
            if w: w.setChecked(True)

        # For entire-outline to be checked.
        self.svarDict.get('entire_outline').set(True)

    #@-node:ekr.20081121105001.243:initRadioButtons
    #@-node:ekr.20081121105001.238:init (qtFindTab) &amp; helpers
    #@-node:ekr.20081121105001.236: Birth: called from leoFind ctor
    #@+node:ekr.20081121105001.244:class svar
    class svar:
        '''A class like Tk's IntVar and StringVar classes.'''
        def __init__(self,owner,ivar):
            # g.trace('svar.__init__',ivar)
            self.ivar = ivar
            self.owner = owner
            self.val = None
            self.w = None
        def clearRadioButtons(self):
            buttons = ['node_only','suboutline_only','entire_outline']
            if self.ivar in buttons:
                buttons.remove(self.ivar)
                for ivar in buttons:
                    w = self.owner.widgetsDict.get(ivar)
                    if w: w.setChecked(False)
        def get (self):
            return self.w and bool(self.w.isChecked()) or self.val
        def set (self,val):
            self.clearRadioButtons()
            self.val = bool(val)
            if self.w: self.w.setChecked(bool(val))
            # g.trace(val,self.w,g.callers(4))
        def setVal(self,val):
            self.clearRadioButtons()
            self.val = bool(val)
        def setWidget(self,w):
            self.w = w
    #@-node:ekr.20081121105001.244:class svar
    #@+node:ekr.20081121105001.245:Support for minibufferFind class (qtFindTab)
    # This is the same as the Tk code because we simulate Tk svars.
    #@nonl
    #@+node:ekr.20081121105001.246:getOption
    def getOption (self,ivar):

        var = self.svarDict.get(ivar)

        if var:
            val = var.get()
            # g.trace('%s = %s' % (ivar,val))
            return val
        else:
            g.trace('bad ivar name: %s' % ivar)
            return None
    #@-node:ekr.20081121105001.246:getOption
    #@+node:ekr.20081121105001.247:setOption
    def setOption (self,ivar,val):

        if ivar in self.intKeys:
            if val is not None:
                svar = self.svarDict.get(ivar)
                svar.set(val)
                # g.trace('%s = %s' % (ivar,val))

        elif not g.app.unitTesting:
            g.trace('oops: bad find ivar %s' % ivar)
    #@-node:ekr.20081121105001.247:setOption
    #@+node:ekr.20081121105001.248:toggleOption
    def toggleOption (self,ivar):

        if ivar in self.intKeys:
            var = self.svarDict.get(ivar)
            val = not var.get()
            var.set(val)
            # g.trace('%s = %s' % (ivar,val),var)
        else:
            g.trace('oops: bad find ivar %s' % ivar)
    #@-node:ekr.20081121105001.248:toggleOption
    #@-node:ekr.20081121105001.245:Support for minibufferFind class (qtFindTab)
    #@-others
#@-node:ekr.20081121105001.235:class leoQtFindTab (findTab)
#@+node:ekr.20081121105001.249:class leoQtFrame
class leoQtFrame (leoFrame.leoFrame):

    """A class that represents a Leo window rendered in qt."""

    #@    @+others
    #@+node:ekr.20081121105001.250: Birth &amp; Death (qtFrame)
    #@+node:ekr.20081121105001.251:__init__ (qtFrame)
    def __init__(self,title,gui):

        # Init the base class.
        leoFrame.leoFrame.__init__(self,gui)

        self.title = title
        self.initComplete = False # Set by initCompleteHint().
        leoQtFrame.instances += 1

        self.c = None # Set in finishCreate.
        self.iconBarClass = self.qtIconBarClass
        self.statusLineClass = self.qtStatusLineClass
        self.iconBar = None

        self.trace_status_line = None # Set in finishCreate.

        #@    &lt;&lt; set the leoQtFrame ivars &gt;&gt;
        #@+node:ekr.20081121105001.252:&lt;&lt; set the leoQtFrame ivars &gt;&gt; (removed frame.bodyCtrl ivar)
        # "Official ivars created in createLeoFrame and its allies.
        self.bar1 = None
        self.bar2 = None
        self.body = None
        self.f1 = self.f2 = None
        self.findPanel = None # Inited when first opened.
        self.iconBarComponentName = 'iconBar'
        self.iconFrame = None 
        self.log = None
        self.canvas = None
        self.outerFrame = None
        self.statusFrame = None
        self.statusLineComponentName = 'statusLine'
        self.statusText = None 
        self.statusLabel = None 
        self.top = None # This will be a class Window object.
        self.tree = None
        # self.treeBar = None # Replaced by injected frame.canvas.leo_treeBar.

        # Used by event handlers...
        self.controlKeyIsDown = False # For control-drags
        self.draggedItem = None
        self.isActive = True
        self.redrawCount = 0
        self.wantedWidget = None
        self.wantedCallbackScheduled = False
        self.scrollWay = None
        #@-node:ekr.20081121105001.252:&lt;&lt; set the leoQtFrame ivars &gt;&gt; (removed frame.bodyCtrl ivar)
        #@nl

        self.minibufferVisible = True
    #@-node:ekr.20081121105001.251:__init__ (qtFrame)
    #@+node:ekr.20081121105001.253:__repr__ (qtFrame)
    def __repr__ (self):

        return "&lt;leoQtFrame: %s&gt;" % self.title
    #@-node:ekr.20081121105001.253:__repr__ (qtFrame)
    #@+node:ekr.20081121105001.254:qtFrame.finishCreate &amp; helpers
    def finishCreate (self,c):

        f = self ; f.c = c

        # g.trace('***qtFrame')

        self.bigTree           = c.config.getBool('big_outline_pane')
        self.trace_status_line = c.config.getBool('trace_status_line')
        self.use_chapters      = c.config.getBool('use_chapters')
        self.use_chapter_tabs  = c.config.getBool('use_chapter_tabs')

        # xx todo
        f.top = DynamicWindow(c)
        g.app.gui.attachLeoIcon(f.top)
        f.top.setWindowTitle(self.title)
        f.top.show()

        # This must be done after creating the commander.
        f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
        # # f.createOuterFrames()
        f.createIconBar() # A base class method.
        # # f.createLeoSplitters(f.outerFrame)
        f.createSplitterComponents()
        f.createStatusLine() # A base class method.
        f.createFirstTreeNode() # Call the base-class method.
        f.menu = leoQtMenu(f)
        c.setLog()
        g.app.windowList.append(f)
        c.initVersion()
        c.signOnWithVersion()
        f.miniBufferWidget = leoQtMinibuffer(c)
        c.bodyWantsFocusNow()
    #@+node:ekr.20081121105001.255:createSplitterComponents (qtFrame)
    def createSplitterComponents (self):

        f = self ; c = f.c

        f.tree  = leoQtTree(c,f)
        f.log   = leoQtLog(f,None)
        f.body  = leoQtBody(f,None)

        if f.use_chapters:
            c.chapterController = cc = leoChapters.chapterController(c)

        # # Create the canvas, tree, log and body.
        # if f.use_chapters:
            # c.chapterController = cc = leoChapters.chapterController(c)

        # # split1.pane1 is the secondary splitter.

        # if self.bigTree: # Put outline in the main splitter.
            # if self.use_chapters and self.use_chapter_tabs:
                # cc.tt = leoQtTreeTab(c,f.split1Pane2,cc)
            # f.canvas = f.createCanvas(f.split1Pane1)
            # f.tree  = leoQtTree(c,f,f.canvas)
            # f.log   = leoQtLog(f,f.split2Pane2)
            # f.body  = leoQtBody(f,f.split2Pane1)
        # else:
            # if self.use_chapters and self.use_chapter_tabs:
                # cc.tt = leoQtTreeTab(c,f.split2Pane1,cc)
            # f.canvas = f.createCanvas(f.split2Pane1)
            # f.tree   = leoQtTree(c,f,f.canvas)
            # f.log    = leoQtLog(f,f.split2Pane2)
            # f.body   = leoQtBody(f,f.split1Pane2)

        # # Yes, this an "official" ivar: this is a kludge.
        # # f.bodyCtrl = f.body.bodyCtrl

        # # Configure.
        # f.setTabWidth(c.tab_width)
        # f.reconfigurePanes()
        # f.body.setFontFromConfig()
        # f.body.setColorFromConfig()
    #@-node:ekr.20081121105001.255:createSplitterComponents (qtFrame)
    #@-node:ekr.20081121105001.254:qtFrame.finishCreate &amp; helpers
    #@+node:ekr.20081121105001.256:initCompleteHint
    def initCompleteHint (self):

        '''A kludge: called to enable text changed events.'''

        self.initComplete = True
        # g.trace(self.c)
    #@-node:ekr.20081121105001.256:initCompleteHint
    #@+node:ekr.20081121105001.257:Destroying the qtFrame
    #@+node:ekr.20081121105001.258:destroyAllObjects
    def destroyAllObjects (self):

        """Clear all links to objects in a Leo window."""

        frame = self ; c = self.c

        # g.printGcAll()

        # Do this first.
        #@    &lt;&lt; clear all vnodes and tnodes in the tree &gt;&gt;
        #@+node:ekr.20081121105001.259:&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;
        # Using a dict here is essential for adequate speed.
        vList = [] ; tDict = {}

        for p in c.all_positions_with_unique_vnodes_iter():
            vList.append(p.v)
            if p.v.t:
                key = id(p.v.t)
                if key not in tDict:
                    tDict[key] = p.v.t

        for key in tDict:
            g.clearAllIvars(tDict[key])

        for v in vList:
            g.clearAllIvars(v)

        vList = [] ; tDict = {} # Remove these references immediately.
        #@-node:ekr.20081121105001.259:&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;
        #@nl

        if 1:
            # Destroy all ivars in subcommanders.
            g.clearAllIvars(c.atFileCommands)
            if c.chapterController: # New in Leo 4.4.3 b1.
                g.clearAllIvars(c.chapterController)
            g.clearAllIvars(c.fileCommands)
            g.clearAllIvars(c.keyHandler) # New in Leo 4.4.3 b1.
            g.clearAllIvars(c.importCommands)
            g.clearAllIvars(c.tangleCommands)
            g.clearAllIvars(c.undoer)
            g.clearAllIvars(c)
        if 0: # No need.
            tree = frame.tree ; body = self.body
            g.clearAllIvars(body.colorizer)
            g.clearAllIvars(body)
            g.clearAllIvars(tree)

    #@-node:ekr.20081121105001.258:destroyAllObjects
    #@+node:ekr.20081121105001.260:destroySelf (qtFrame)
    def destroySelf (self):

        # Remember these: we are about to destroy all of our ivars!
        c,top = self.c,self.top 

        # Indicate that the commander is no longer valid.
        c.exists = False

        if 0: # We can't do this unless we unhook the event filter.
            # Destroys all the objects of the commander.
            self.destroyAllObjects()

        c.exists = False # Make sure this one ivar has not been destroyed.

        # g.trace('qtFrame',c,g.callers(4))
        top.close()

    #@-node:ekr.20081121105001.260:destroySelf (qtFrame)
    #@-node:ekr.20081121105001.257:Destroying the qtFrame
    #@-node:ekr.20081121105001.250: Birth &amp; Death (qtFrame)
    #@+node:ekr.20081121105001.261:class qtStatusLineClass (qtFrame)
    class qtStatusLineClass:

        '''A class representing the status line.'''

        #@    @+others
        #@+node:ekr.20081121105001.262:ctor
        def __init__ (self,c,parentFrame):

            self.c = c
            self.statusBar = c.frame.top.statusBar
            self.lastFcol= 0
            self.lastRow = 0
            self.lastCol = 0

            # Create the text widgets.
            self.textWidget1 = w1 = QtGui.QLineEdit(self.statusBar)
            self.textWidget2 = w2 = QtGui.QLineEdit(self.statusBar)
            w1.setObjectName('status1')
            w2.setObjectName('status2')
            self.statusBar.addWidget(w1,True)
            self.statusBar.addWidget(w2,True)
            self.put('')
            self.update()
            c.frame.top.setStyleSheets()
        #@-node:ekr.20081121105001.262:ctor
        #@+node:ekr.20081121105001.263: do-nothings
        def disable (self,background=None): pass
        def enable(self,background="white"):pass
        def getFrame (self):                return None
        def isEnabled(self):                return True
        def onActivate (self,event=None):   pass
        def pack (self):                    pass
        def setBindings (self):             pass
        def unpack (self):                  pass

        hide = unpack
        show = pack

        #@-node:ekr.20081121105001.263: do-nothings
        #@+node:ekr.20081121105001.264:clear, get &amp; put/1
        def clear (self):
            self.put('')

        def get (self):
            return self.textWidget2.text()

        def put(self,s,color=None):
            self.put_helper(s,self.textWidget2)

        def put1(self,s,color=None):
            self.put_helper(s,self.textWidget1)

        def put_helper(self,s,w):
            # w.setEnabled(True)
            w.setText(s)
            # w.setEnabled(False)
        #@-node:ekr.20081121105001.264:clear, get &amp; put/1
        #@+node:ekr.20081121105001.265:update
        def update (self):

            if g.app.killed: return
            c = self.c ; body = c.frame.body
            s = body.getAllText()
            i = body.getInsertPoint()
            # Compute row,col &amp; fcol
            row,col = g.convertPythonIndexToRowCol(s,i)
            if col &gt; 0:
                s2 = s[i-col:i]
                s2 = g.toUnicode(s2,g.app.tkEncoding)
                col = g.computeWidth (s2,c.tab_width)
            fcol = col + c.currentPosition().textOffset()
            self.put1(
                "line: %d, col: %d, fcol: %d" % (row,col,fcol))
            self.lastRow = row
            self.lastCol = col
            self.lastFcol = fcol
        #@-node:ekr.20081121105001.265:update
        #@-others
    #@-node:ekr.20081121105001.261:class qtStatusLineClass (qtFrame)
    #@+node:ekr.20081121105001.266:class qtIconBarClass
    class qtIconBarClass:

        '''A class representing the singleton Icon bar'''

        #@    @+others
        #@+node:ekr.20081121105001.267: ctor
        def __init__ (self,c,parentFrame):

            self.c = c
            self.parentFrame = parentFrame
            self.w = c.frame.top.iconBar # A QToolBar.

            # g.app.iconWidgetCount = 0
        #@-node:ekr.20081121105001.267: ctor
        #@+node:ekr.20081121105001.268: do-nothings
        def addRow(self,height=None):   pass
        def getFrame (self):            return None
        def getNewFrame (self):         return None
        def pack (self):                pass
        def unpack (self):              pass

        hide = unpack
        show = pack
        #@-node:ekr.20081121105001.268: do-nothings
        #@+node:ekr.20081121105001.269:add
        def add(self,*args,**keys):

            '''Add a button to the icon bar.'''

            c = self.c
            command = keys.get('command')
            text = keys.get('text')
            if not text: return

            # imagefile = keys.get('imagefile')
            # image = keys.get('image')

            b = QtGui.QPushButton(text,self.w)
            b.leo_buttonAction = self.addWidget(b)

            b.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)

            def delete_callback(b=b,):
                a = b.leo_buttonAction
                self.w.removeAction(a)
                b.leo_buttonAction = None
                self.deleteButton(b)

            b.leo_removeAction = rb = QtGui.QAction('Remove Button' ,b)
            b.addAction(rb)
            rb.connect(rb, QtCore.SIGNAL("triggered()"), delete_callback)

            if command:
                def button_callback(c=c,command=command):
                    g.trace('command',command.__name__)
                    val = command()
                    if c.exists:
                        c.bodyWantsFocus()
                        c.outerUpdate()
                    return val

                b.connect(b,
                    QtCore.SIGNAL("clicked()"),
                    button_callback)

            return b
        #@-node:ekr.20081121105001.269:add
        #@+node:ekr.20081121105001.270:addRowIfNeeded
        def addRowIfNeeded (self):

            '''Add a new icon row if there are too many widgets.'''

            # n = g.app.iconWidgetCount

            # if n &gt;= self.widgets_per_row:
                # g.app.iconWidgetCount = 0
                # self.addRow()

            # g.app.iconWidgetCount += 1
        #@-node:ekr.20081121105001.270:addRowIfNeeded
        #@+node:ekr.20081121105001.271:addWidget
        def addWidget (self,w):

            self.w.addWidget(w)
        #@-node:ekr.20081121105001.271:addWidget
        #@+node:ekr.20081121105001.272:clear
        def clear(self):

            """Destroy all the widgets in the icon bar"""

            self.w.clear()

            g.app.iconWidgetCount = 0
        #@-node:ekr.20081121105001.272:clear
        #@+node:ekr.20081121105001.273:deleteButton
        def deleteButton (self,w):

            #g.trace(w, '##')
            self.c.bodyWantsFocus()
            self.c.outerUpdate()
        #@-node:ekr.20081121105001.273:deleteButton
        #@+node:ekr.20081121105001.274:setCommandForButton
        def setCommandForButton(self,button,command):

            if command:
                QtCore.QObject.connect(button,
                    QtCore.SIGNAL("clicked()"),command)
        #@-node:ekr.20081121105001.274:setCommandForButton
        #@-others
    #@-node:ekr.20081121105001.266:class qtIconBarClass
    #@+node:ekr.20081121105001.275:Minibuffer methods
    #@+node:ekr.20081121105001.276:showMinibuffer
    def showMinibuffer (self):

        '''Make the minibuffer visible.'''

        # frame = self

        # if not frame.minibufferVisible:
            # frame.minibufferFrame.pack(side='bottom',fill='x')
            # frame.minibufferVisible = True
    #@-node:ekr.20081121105001.276:showMinibuffer
    #@+node:ekr.20081121105001.277:hideMinibuffer
    def hideMinibuffer (self):

        '''Hide the minibuffer.'''

        # frame = self

        # if frame.minibufferVisible:
            # frame.minibufferFrame.pack_forget()
            # frame.minibufferVisible = False
    #@-node:ekr.20081121105001.277:hideMinibuffer
    #@+node:ekr.20081121105001.278:f.setMinibufferBindings
    def setMinibufferBindings (self):

        '''Create bindings for the minibuffer..'''

        pass
    #@-node:ekr.20081121105001.278:f.setMinibufferBindings
    #@-node:ekr.20081121105001.275:Minibuffer methods
    #@+node:ekr.20081121105001.279:Configuration (qtFrame)
    #@+node:ekr.20081121105001.280:configureBar (qtFrame)
    def configureBar (self,bar,verticalFlag):

        c = self.c

        # Get configuration settings.
        w = c.config.getInt("split_bar_width")
        if not w or w &lt; 1: w = 7
        relief = c.config.get("split_bar_relief","relief")
        if not relief: relief = "flat"
        color = c.config.getColor("split_bar_color")
        if not color: color = "LightSteelBlue2"

        try:
            if verticalFlag:
                # Panes arranged vertically; horizontal splitter bar
                bar.configure(relief=relief,height=w,bg=color,cursor="sb_v_double_arrow")
            else:
                # Panes arranged horizontally; vertical splitter bar
                bar.configure(relief=relief,width=w,bg=color,cursor="sb_h_double_arrow")
        except: # Could be a user error. Use all defaults
            g.es("exception in user configuration for splitbar")
            g.es_exception()
            if verticalFlag:
                # Panes arranged vertically; horizontal splitter bar
                bar.configure(height=7,cursor="sb_v_double_arrow")
            else:
                # Panes arranged horizontally; vertical splitter bar
                bar.configure(width=7,cursor="sb_h_double_arrow")
    #@-node:ekr.20081121105001.280:configureBar (qtFrame)
    #@+node:ekr.20081121105001.281:configureBarsFromConfig (qtFrame)
    def configureBarsFromConfig (self):

        c = self.c

        w = c.config.getInt("split_bar_width")
        if not w or w &lt; 1: w = 7

        relief = c.config.get("split_bar_relief","relief")
        if not relief or relief == "": relief = "flat"

        color = c.config.getColor("split_bar_color")
        if not color or color == "": color = "LightSteelBlue2"

        if self.splitVerticalFlag:
            bar1,bar2=self.bar1,self.bar2
        else:
            bar1,bar2=self.bar2,self.bar1

        try:
            bar1.configure(relief=relief,height=w,bg=color)
            bar2.configure(relief=relief,width=w,bg=color)
        except: # Could be a user error.
            g.es("exception in user configuration for splitbar")
            g.es_exception()
    #@-node:ekr.20081121105001.281:configureBarsFromConfig (qtFrame)
    #@+node:ekr.20081121105001.282:reconfigureFromConfig (qtFrame)
    def reconfigureFromConfig (self):

        frame = self ; c = frame.c

        frame.tree.setFontFromConfig()
        frame.configureBarsFromConfig()

        frame.body.setFontFromConfig()
        frame.body.setColorFromConfig()

        frame.setTabWidth(c.tab_width)
        frame.log.setFontFromConfig()
        frame.log.setColorFromConfig()

        c.redraw()
    #@-node:ekr.20081121105001.282:reconfigureFromConfig (qtFrame)
    #@+node:ekr.20081121105001.283:setInitialWindowGeometry (qtFrame)
    def setInitialWindowGeometry(self):

        """Set the position and size of the frame to config params."""

        c = self.c

        h = c.config.getInt("initial_window_height") or 500
        w = c.config.getInt("initial_window_width") or 600
        x = c.config.getInt("initial_window_left") or 10
        y = c.config.getInt("initial_window_top") or 10

        if h and w and x and y:
            self.setTopGeometry(w,h,x,y)
    #@-node:ekr.20081121105001.283:setInitialWindowGeometry (qtFrame)
    #@+node:ekr.20081121105001.284:setTabWidth (qtFrame)
    def setTabWidth (self, w):

        return

        # try: # This can fail when called from scripts
            # # Use the present font for computations.
            # font = self.body.bodyCtrl.cget("font") # 2007/10/27
            # root = g.app.root # 4/3/03: must specify root so idle window will work properly.
            # font = tkFont.Font(root=root,font=font)
            # tabw = font.measure(" " * abs(w)) # 7/2/02
            # self.body.bodyCtrl.configure(tabs=tabw)
            # self.tab_width = w
            # # g.trace(w,tabw)
        # except:
            # g.es_exception()
    #@-node:ekr.20081121105001.284:setTabWidth (qtFrame)
    #@+node:ekr.20081121105001.285:setWrap (qtFrame)
    def setWrap (self,p):

        c = self.c
        theDict = c.scanAllDirectives(p)
        if not theDict: return

        return

        # wrap = theDict.get("wrap")
        # if self.body.wrapState == wrap: return

        # self.body.wrapState = wrap
        # w = self.body.bodyCtrl

        # # g.trace(wrap)
        # if wrap:
            # w.configure(wrap="word") # 2007/10/25
            # w.leo_bodyXBar.pack_forget() # 2007/10/31
        # else:
            # w.configure(wrap="none")
            # # Bug fix: 3/10/05: We must unpack the text area to make the scrollbar visible.
            # w.pack_forget()  # 2007/10/25
            # w.leo_bodyXBar.pack(side="bottom", fill="x") # 2007/10/31
            # w.pack(expand=1,fill="both")  # 2007/10/25
    #@-node:ekr.20081121105001.285:setWrap (qtFrame)
    #@+node:ekr.20081121105001.286:reconfigurePanes (use config bar_width) (qtFrame)
    def reconfigurePanes (self):

        return

        # c = self.c

        # border = c.config.getInt('additional_body_text_border')
        # if border == None: border = 0

        # # The body pane needs a _much_ bigger border when tiling horizontally.
        # border = g.choose(self.splitVerticalFlag,2+border,6+border)
        # self.body.bodyCtrl.configure(bd=border) # 2007/10/25

        # # The log pane needs a slightly bigger border when tiling vertically.
        # border = g.choose(self.splitVerticalFlag,4,2) 
        # self.log.configureBorder(border)
    #@-node:ekr.20081121105001.286:reconfigurePanes (use config bar_width) (qtFrame)
    #@+node:ekr.20081121105001.287:resizePanesToRatio (qtFrame)
    def resizePanesToRatio(self,ratio,ratio2):

        #g.trace(ratio,ratio2,g.callers())

        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
    #@-node:ekr.20081121105001.287:resizePanesToRatio (qtFrame)
    #@+node:leohag.20081208130321.12:divideLeoSplitter
    # Divides the main or secondary splitter, using the key invariant.
    def divideLeoSplitter (self, verticalFlag, frac):

        if self.splitVerticalFlag == verticalFlag:
            self.divideLeoSplitter1(frac,verticalFlag)
            self.ratio = frac # Ratio of body pane to tree pane.
        else:
            self.divideLeoSplitter2(frac,verticalFlag)
            self.secondary_ratio = frac # Ratio of tree pane to log pane.

    # Divides the main splitter.
    def divideLeoSplitter1 (self, frac, verticalFlag): 
        self.divideAnySplitter(frac, self.top.splitter_2 )

    # Divides the secondary splitter.
    def divideLeoSplitter2 (self, frac, verticalFlag): 
        self.divideAnySplitter (frac, self.top.ui.splitter)

    #@-node:leohag.20081208130321.12:divideLeoSplitter
    #@+node:leohag.20081208130321.13:divideAnySplitter
    # This is the general-purpose placer for splitters.
    # It is the only general-purpose splitter code in Leo.

    def divideAnySplitter (self, frac, splitter ):#verticalFlag, bar, pane1, pane2):

        sizes = splitter.sizes()

        if len(sizes)!=2:
            g.trace('there must be two and only two widgets in the splitter')

        if frac &gt; 1 or frac &lt; 0:
            g.trace('split ratio [%s] out of range 0 &lt;= frac &lt;= 1'%frac)

        s1, s2 = sizes
        s = s1+s2
        s1 = int(s * frac + 0.5)
        s2 = s - s1 

        splitter.setSizes([s1,s2])

    #@+at
    #     # if self.bigTree:
    #         # pane1,pane2 = pane2,pane1
    # 
    #     if verticalFlag:
    #         # Panes arranged vertically; horizontal splitter bar
    #         bar.place(rely=frac)
    #         pane1.place(relheight=frac)
    #         pane2.place(relheight=1-frac)
    #     else:
    #         # Panes arranged horizontally; vertical splitter bar
    #         bar.place(relx=frac)
    #         pane1.place(relwidth=frac)
    #         pane2.place(relwidth=1-frac)
    #@-at
    #@-node:leohag.20081208130321.13:divideAnySplitter
    #@-node:ekr.20081121105001.279:Configuration (qtFrame)
    #@+node:ekr.20081121105001.288:Event handlers (qtFrame)
    #@+node:ekr.20081121105001.289:frame.OnCloseLeoEvent
    # Called from quit logic and when user closes the window.
    # Returns True if the close happened.

    def OnCloseLeoEvent(self):

        f = self ; c = f.c

        if c.inCommand:
            # g.trace('requesting window close')
            c.requestCloseWindow = True
        else:
            g.app.closeLeoWindow(self)
    #@-node:ekr.20081121105001.289:frame.OnCloseLeoEvent
    #@+node:ekr.20081121105001.290:frame.OnControlKeyUp/Down
    def OnControlKeyDown (self,event=None):

        self.controlKeyIsDown = True

    def OnControlKeyUp (self,event=None):

        self.controlKeyIsDown = False
    #@-node:ekr.20081121105001.290:frame.OnControlKeyUp/Down
    #@+node:ekr.20081121105001.291:OnActivateBody (qtFrame)
    def OnActivateBody (self,event=None):

        # try:
            # frame = self ; c = frame.c
            # c.setLog()
            # w = c.get_focus()
            # if w != c.frame.body.bodyCtrl:
                # frame.tree.OnDeactivate()
            # c.bodyWantsFocusNow()
        # except:
            # g.es_event_exception("activate body")

        return 'break'
    #@-node:ekr.20081121105001.291:OnActivateBody (qtFrame)
    #@+node:ekr.20081121105001.292:OnActivateLeoEvent, OnDeactivateLeoEvent
    def OnActivateLeoEvent(self,event=None):

        '''Handle a click anywhere in the Leo window.'''

        self.c.setLog()

    def OnDeactivateLeoEvent(self,event=None):

        pass # This causes problems on the Mac.
    #@-node:ekr.20081121105001.292:OnActivateLeoEvent, OnDeactivateLeoEvent
    #@+node:ekr.20081121105001.293:OnActivateTree
    def OnActivateTree (self,event=None):

        try:
            frame = self ; c = frame.c
            c.setLog()

            if 0: # Do NOT do this here!
                # OnActivateTree can get called when the tree gets DE-activated!!
                c.bodyWantsFocus()

        except:
            g.es_event_exception("activate tree")
    #@-node:ekr.20081121105001.293:OnActivateTree
    #@+node:ekr.20081121105001.294:OnBodyClick, OnBodyRClick (Events)
    def OnBodyClick (self,event=None):

        try:
            c = self.c ; p = c.currentPosition()
            if not g.doHook("bodyclick1",c=c,p=p,v=p,event=event):
                self.OnActivateBody(event=event)
                c.k.showStateAndMode(w=c.frame.body.bodyCtrl)
            g.doHook("bodyclick2",c=c,p=p,v=p,event=event)
        except:
            g.es_event_exception("bodyclick")

    def OnBodyRClick(self,event=None):

        try:
            c = self.c ; p = c.currentPosition()
            if not g.doHook("bodyrclick1",c=c,p=p,v=p,event=event):
                c.k.showStateAndMode(w=c.frame.body.bodyCtrl)
            g.doHook("bodyrclick2",c=c,p=p,v=p,event=event)
        except:
            g.es_event_exception("iconrclick")
    #@-node:ekr.20081121105001.294:OnBodyClick, OnBodyRClick (Events)
    #@+node:ekr.20081121105001.295:OnBodyDoubleClick (Events)
    def OnBodyDoubleClick (self,event=None):

        try:
            c = self.c ; p = c.currentPosition()
            if event and not g.doHook("bodydclick1",c=c,p=p,v=p,event=event):
                c.editCommands.extendToWord(event) # Handles unicode properly.
                c.k.showStateAndMode(w=c.frame.body.bodyCtrl)
            g.doHook("bodydclick2",c=c,p=p,v=p,event=event)
        except:
            g.es_event_exception("bodydclick")

        return "break" # Restore this to handle proper double-click logic.
    #@-node:ekr.20081121105001.295:OnBodyDoubleClick (Events)
    #@-node:ekr.20081121105001.288:Event handlers (qtFrame)
    #@+node:ekr.20081121105001.296:Gui-dependent commands
    #@+node:ekr.20081121105001.297:Minibuffer commands... (qtFrame)
    #@+node:ekr.20081121105001.298:contractPane
    def contractPane (self,event=None):

        '''Contract the selected pane.'''

        # f = self ; c = f.c
        # w = c.get_requested_focus()
        # wname = c.widget_name(w)

        # # g.trace(wname)
        # if not w: return

        # if wname.startswith('body'):
            # f.contractBodyPane()
        # elif wname.startswith('log'):
            # f.contractLogPane()
        # elif wname.startswith('head') or wname.startswith('canvas'):
            # f.contractOutlinePane()
    #@-node:ekr.20081121105001.298:contractPane
    #@+node:ekr.20081121105001.299:expandPane
    def expandPane (self,event=None):

        '''Expand the selected pane.'''

        # f = self ; c = f.c

        # w = c.get_requested_focus()
        # wname = c.widget_name(w)

        # # g.trace(wname)
        # if not w: return

        # if wname.startswith('body'):
            # f.expandBodyPane()
        # elif wname.startswith('log'):
            # f.expandLogPane()
        # elif wname.startswith('head') or wname.startswith('canvas'):
            # f.expandOutlinePane()
    #@-node:ekr.20081121105001.299:expandPane
    #@+node:ekr.20081121105001.300:fullyExpandPane
    def fullyExpandPane (self,event=None):

        '''Fully expand the selected pane.'''

        # f = self ; c = f.c

        # w = c.get_requested_focus()
        # wname = c.widget_name(w)

        # # g.trace(wname)
        # if not w: return

        # if wname.startswith('body'):
            # f.fullyExpandBodyPane()
        # elif wname.startswith('log'):
            # f.fullyExpandLogPane()
        # elif wname.startswith('head') or wname.startswith('canvas'):
            # f.fullyExpandOutlinePane()
    #@-node:ekr.20081121105001.300:fullyExpandPane
    #@+node:ekr.20081121105001.301:hidePane
    def hidePane (self,event=None):

        '''Completely contract the selected pane.'''

        # f = self ; c = f.c

        # w = c.get_requested_focus()
        # wname = c.widget_name(w)

        # g.trace(wname)
        # if not w: return

        # if wname.startswith('body'):
            # f.hideBodyPane()
            # c.treeWantsFocusNow()
        # elif wname.startswith('log'):
            # f.hideLogPane()
            # c.bodyWantsFocusNow()
        # elif wname.startswith('head') or wname.startswith('canvas'):
            # f.hideOutlinePane()
            # c.bodyWantsFocusNow()
    #@-node:ekr.20081121105001.301:hidePane
    #@+node:ekr.20081121105001.302:expand/contract/hide...Pane
    #@+at 
    #@nonl
    # The first arg to divideLeoSplitter means the following:
    # 
    #     f.splitVerticalFlag: use the primary   (tree/body) ratio.
    # not f.splitVerticalFlag: use the secondary (tree/log) ratio.
    #@-at
    #@@c

    def contractBodyPane (self,event=None):
        '''Contract the body pane.'''
        f = self ; r = min(1.0,f.ratio+0.1)
        f.divideLeoSplitter(f.splitVerticalFlag,r)

    def contractLogPane (self,event=None):
        '''Contract the log pane.'''
        f = self ; r = min(1.0,f.ratio+0.1)
        f.divideLeoSplitter(not f.splitVerticalFlag,r)

    def contractOutlinePane (self,event=None):
        '''Contract the outline pane.'''
        f = self ; r = max(0.0,f.ratio-0.1)
        f.divideLeoSplitter(f.splitVerticalFlag,r)

    def expandBodyPane (self,event=None):
        '''Expand the body pane.'''
        self.contractOutlinePane()

    def expandLogPane(self,event=None):
        '''Expand the log pane.'''
        f = self ; r = max(0.0,f.ratio-0.1)
        f.divideLeoSplitter(not f.splitVerticalFlag,r)

    def expandOutlinePane (self,event=None):
        '''Expand the outline pane.'''
        self.contractBodyPane()
    #@-node:ekr.20081121105001.302:expand/contract/hide...Pane
    #@+node:ekr.20081121105001.303:fullyExpand/hide...Pane
    def fullyExpandBodyPane (self,event=None):
        '''Fully expand the body pane.'''
        f = self
        f.divideLeoSplitter(f.splitVerticalFlag,0.0)

    def fullyExpandLogPane (self,event=None):
        '''Fully expand the log pane.'''
        f = self
        f.divideLeoSplitter(not f.splitVerticalFlag,0.0)

    def fullyExpandOutlinePane (self,event=None):
        '''Fully expand the outline pane.'''
        f = self
        f.divideLeoSplitter(f.splitVerticalFlag,1.0)

    def hideBodyPane (self,event=None):
        '''Completely contract the body pane.'''
        f = self
        f.divideLeoSplitter(f.splitVerticalFlag,1.0)

    def hideLogPane (self,event=None):
        '''Completely contract the log pane.'''
        f = self
        f.divideLeoSplitter(not f.splitVerticalFlag,1.0)

    def hideOutlinePane (self,event=None):
        '''Completely contract the outline pane.'''
        f = self
        f.divideLeoSplitter(f.splitVerticalFlag,0.0)
    #@-node:ekr.20081121105001.303:fullyExpand/hide...Pane
    #@-node:ekr.20081121105001.297:Minibuffer commands... (qtFrame)
    #@+node:ekr.20081121105001.304:Window Menu...
    #@+node:ekr.20081121105001.305:toggleActivePane (qtFrame)
    def toggleActivePane (self,event=None):

        '''Toggle the focus between the outline and body panes.'''

        frame = self ; c = frame.c

        if c.get_focus() == frame.body.bodyCtrl: # 2007/10/25
            c.treeWantsFocusNow()
        else:
            c.endEditing()
            c.bodyWantsFocusNow()
    #@-node:ekr.20081121105001.305:toggleActivePane (qtFrame)
    #@+node:ekr.20081121105001.306:cascade
    def cascade (self,event=None):

        '''Cascade all Leo windows.'''

        # x,y,delta = 10,10,10
        # for frame in g.app.windowList:
            # top = frame.top

            # # Compute w,h
            # top.update_idletasks() # Required to get proper info.
            # geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
            # dim,junkx,junky = geom.split('+')
            # w,h = dim.split('x')
            # w,h = int(w),int(h)

            # # Set new x,y and old w,h
            # frame.setTopGeometry(w,h,x,y,adjustSize=False)

            # # Compute the new offsets.
            # x += 30 ; y += 30
            # if x &gt; 200:
                # x = 10 + delta ; y = 40 + delta
                # delta += 10
    #@-node:ekr.20081121105001.306:cascade
    #@+node:ekr.20081121105001.307:equalSizedPanes
    def equalSizedPanes (self,event=None):

        '''Make the outline and body panes have the same size.'''

        frame = self
        frame.resizePanesToRatio(0.5,frame.secondary_ratio)
    #@-node:ekr.20081121105001.307:equalSizedPanes
    #@+node:ekr.20081121105001.308:hideLogWindow
    def hideLogWindow (self,event=None):

        frame = self

        frame.divideLeoSplitter2(0.99, not frame.splitVerticalFlag)
    #@-node:ekr.20081121105001.308:hideLogWindow
    #@+node:ekr.20081121105001.309:minimizeAll
    def minimizeAll (self,event=None):

        '''Minimize all Leo's windows.'''

        self.minimize(g.app.pythonFrame)
        for frame in g.app.windowList:
            self.minimize(frame)
            self.minimize(frame.findPanel)

    def minimize(self,frame):

        pass

        # if frame and frame.top.state() == "normal":
            # frame.top.iconify()
    #@-node:ekr.20081121105001.309:minimizeAll
    #@+node:ekr.20081121105001.310:toggleSplitDirection (qtFrame)
    # The key invariant: self.splitVerticalFlag tells the alignment of the main splitter.

    def toggleSplitDirection (self,event=None):

        '''Toggle the split direction in the present Leo window.'''

        frame = self ; top = frame.top

        for w in (top.splitter,top.splitter_2):
            w.setOrientation(
                g.choose(w.orientation() == QtCore.Qt.Horizontal,
                    QtCore.Qt.Vertical,QtCore.Qt.Horizontal))
    #@nonl
    #@+node:ekr.20081121105001.311:toggleQtSplitDirection
    def toggleQtSplitDirection (self,verticalFlag):

        # Abbreviations.
        frame = self
        # bar1 = self.bar1 ; bar2 = self.bar2
        # split1Pane1,split1Pane2 = self.split1Pane1,self.split1Pane2
        # split2Pane1,split2Pane2 = self.split2Pane1,self.split2Pane2
        # # Reconfigure the bars.
        # bar1.place_forget()
        # bar2.place_forget()
        # self.configureBar(bar1,verticalFlag)
        # self.configureBar(bar2,not verticalFlag)
        # # Make the initial placements again.
        # self.placeSplitter(bar1,split1Pane1,split1Pane2,verticalFlag)
        # self.placeSplitter(bar2,split2Pane1,split2Pane2,not verticalFlag)
        # # Adjust the log and body panes to give more room around the bars.
        # self.reconfigurePanes()
        # # Redraw with an appropriate ratio.
        # vflag,ratio,secondary_ratio = frame.initialRatios()
        # self.resizePanesToRatio(ratio,secondary_ratio)
    #@-node:ekr.20081121105001.311:toggleQtSplitDirection
    #@-node:ekr.20081121105001.310:toggleSplitDirection (qtFrame)
    #@+node:ekr.20081121105001.312:resizeToScreen
    def resizeToScreen (self,event=None):

        '''Resize the Leo window so it fill the entire screen.'''

        top = self.top

        # w = top.winfo_screenwidth()
        # h = top.winfo_screenheight()

        # if sys.platform.startswith('win'):
            # top.state('zoomed')
        # elif sys.platform == 'darwin':
            # # Must leave room to get at very small resizing area.
            # geom = "%dx%d%+d%+d" % (w-20,h-55,10,25)
            # top.geometry(geom)
        # else:
            # # Fill almost the entire screen.
            # # Works on Windows. YMMV for other platforms.
            # geom = "%dx%d%+d%+d" % (w-8,h-46,0,0)
            # top.geometry(geom)
    #@-node:ekr.20081121105001.312:resizeToScreen
    #@-node:ekr.20081121105001.304:Window Menu...
    #@+node:ekr.20081121105001.313:Help Menu...
    #@+node:ekr.20081121105001.314:leoHelp
    def leoHelp (self,event=None):

        '''Open Leo's offline tutorial.'''

        frame = self ; c = frame.c

        theFile = g.os_path_join(g.app.loadDir,"..","doc","sbooks.chm")

        if g.os_path_exists(theFile):
            os.startfile(theFile)
        else:
            answer = g.app.gui.runAskYesNoDialog(c,
                "Download Tutorial?",
                "Download tutorial (sbooks.chm) from SourceForge?")

            if answer == "yes":
                try:
                    if 0: # Download directly.  (showProgressBar needs a lot of work)
                        url = "http://umn.dl.sourceforge.net/sourceforge/leo/sbooks.chm"
                        import urllib
                        self.scale = None
                        urllib.urlretrieve(url,theFile,self.showProgressBar)
                        if self.scale:
                            self.scale.destroy()
                            self.scale = None
                    else:
                        url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
                        import webbrowser
                        os.chdir(g.app.loadDir)
                        webbrowser.open_new(url)
                except:
                    g.es("exception downloading","sbooks.chm")
                    g.es_exception()
    #@+node:ekr.20081121105001.315:showProgressBar
    def showProgressBar (self,count,size,total):

        # g.trace("count,size,total:",count,size,total)
        if self.scale == None:
            pass
            #@        &lt;&lt; create the scale widget &gt;&gt;
            #@+node:ekr.20081121105001.316:&lt;&lt; create the scale widget &gt;&gt;
            # top = qt.Toplevel()
            # top.title("Download progress")
            # self.scale = scale = qt.Scale(top,state="normal",orient="horizontal",from_=0,to=total)
            # scale.pack()
            # top.lift()
            #@-node:ekr.20081121105001.316:&lt;&lt; create the scale widget &gt;&gt;
            #@nl
        # self.scale.set(count*size)
        # self.scale.update_idletasks()
    #@-node:ekr.20081121105001.315:showProgressBar
    #@-node:ekr.20081121105001.314:leoHelp
    #@-node:ekr.20081121105001.313:Help Menu...
    #@-node:ekr.20081121105001.296:Gui-dependent commands
    #@+node:ekr.20081121105001.317:Qt bindings... (qtFrame)
    def bringToFront (self):
        self.top.showNormal()
    def deiconify (self):
        self.top.showNormal()
    def getFocus(self):
        return g.app.gui.get_focus() 
    def get_window_info(self):
        rect = self.top.geometry()
        topLeft = rect.topLeft()
        x,y = topLeft.x(),topLeft.y()
        w,h = rect.width(),rect.height()
        return w,h,x,y
    def iconify(self):
        g.trace()
        self.top.showMinimized()
    def lift (self):
        self.top.activateWindow()
    def update (self):
        pass
    def getTitle (self):
        return g.app.gui.toUnicode(self.top.windowTitle())

    def setTitle (self,s):
        self.top.setWindowTitle(s)
    def setTopGeometry(self,w,h,x,y,adjustSize=True):
        self.top.setGeometry(QtCore.QRect(x,y,w,h))
    #@-node:ekr.20081121105001.317:Qt bindings... (qtFrame)
    #@-others
#@-node:ekr.20081121105001.249:class leoQtFrame
#@+node:ekr.20081121105001.318:class leoQtLog
class leoQtLog (leoFrame.leoLog):

    """A class that represents the log pane of a Qt window."""

    #@    @+others
    #@+node:ekr.20081121105001.319:qtLog Birth
    #@+node:ekr.20081121105001.320:qtLog.__init__
    def __init__ (self,frame,parentFrame):

        # g.trace("leoQtLog")

        # Call the base class constructor and calls createControl.
        leoFrame.leoLog.__init__(self,frame,parentFrame)

        self.c = c = frame.c # Also set in the base constructor, but we need it here.
        self.logCtrl = None # The text area for log messages.

        self.contentsDict = {} # Keys are tab names.  Values are widgets.
        self.logDict = {} # Keys are tab names text widgets.  Values are the widgets.
        self.menu = None # A menu that pops up on right clicks in the hull or in tabs.

        self.tabWidget = tw = c.frame.top.ui.tabWidget
            # The Qt.TabWidget that holds all the tabs.
        self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")

        # g.trace('qtLog.__init__',self.tabWidget)

        if 0: # Not needed to make onActivateEvent work.
            # Works only for .tabWidget, *not* the individual tabs!
            theFilter = leoQtEventFilter(c,w=tw,tag='tabWidget')
            tw.installEventFilter(theFilter)

        self.setFontFromConfig()
        self.setColorFromConfig()
    #@-node:ekr.20081121105001.320:qtLog.__init__
    #@+node:ekr.20081121105001.321:qtLog.finishCreate
    def finishCreate (self):

        c = self.c ; log = self ; w = self.tabWidget

        # Remove unneeded tabs.
        for name in ('Tab 1','Page'):
            for i in range(w.count()):
                if name == w.tabText(i):
                    w.removeTab(i)
                    break

        # Rename the 'Tab 2' tab to 'Find'.
        for i in range(w.count()):
            if w.tabText(i) == 'Tab 2':
                w.setTabText(i,'Find')
                self.contentsDict['Find'] = w.currentWidget()
                break

        # Create the log tab as the leftmost tab.
        log.selectTab('Log')

        logWidget = self.contentsDict.get('Log')
        for i in range(w.count()):
            if w.tabText(i) == 'Log':
                w.removeTab(i)
                w.insertTab(0,logWidget,'Log')
                break

        c.searchCommands.openFindTab(show=False)
        c.spellCommands.openSpellTab()
    #@-node:ekr.20081121105001.321:qtLog.finishCreate
    #@-node:ekr.20081121105001.319:qtLog Birth
    #@+node:ekr.20081121105001.322:Do nothings
    # def createCanvas (self,tabName=None): pass

    # def getSelectedTab (self): return self.tabName

    # def lowerTab (self,tabName):
        # self.c.invalidateFocus()
        # self.c.bodyWantsFocus()

    # def makeTabMenu (self,tabName=None,allowRename=True): pass

    # def onLogTextRightClick(self, event):
        # g.doHook('rclick-popup',c=self.c,event=event, context_menu='log')

    # def raiseTab (self,tabName):
        # self.c.invalidateFocus()
        # self.c.bodyWantsFocus()

    # def renameTab (self,oldName,newName): pass

    # def setCanvasTabBindings (self,tabName,menu): pass

    # def setTabBindings (self,tabName): pass

    #@+node:ekr.20081121105001.323:Config
    # These will probably be replaced by style sheets.

    def configureBorder(self,border):   pass
    def configureFont(self,font):       pass
    def getFontConfig (self):           pass

    def setColorFromConfig (self):
        c = self.c
        # bg = c.config.getColor("log_pane_background_color") or 'white'

    def SetWidgetFontFromConfig (self,logCtrl=None):
        c = self.c
        # font = c.config.getFontFromParams(
            # "log_text_font_family", "log_text_font_size",
            # "log_text_font_slant", "log_text_font_weight",
            # c.config.defaultLogFontSize)

    def saveAllState (self):
        '''Return a dict containing all data needed to recreate the log in another widget.'''
        # Save text and colors
    def restoreAllState (self,d):
        '''Restore the log from a dict created by saveAllState.'''
        # Restore text and colors.
    #@-node:ekr.20081121105001.323:Config
    #@+node:ekr.20081121105001.324:Focus &amp; update
    def onActivateLog (self,event=None):    pass
    def hasFocus (self):                    return None
    def forceLogUpdate (self,s):            pass
    #@-node:ekr.20081121105001.324:Focus &amp; update
    #@-node:ekr.20081121105001.322:Do nothings
    #@+node:ekr.20081121105001.325:put &amp; putnl (qtLog)
    #@+node:ekr.20081121105001.326:put
    # All output to the log stream eventually comes here.
    def put (self,s,color=None,tabName='Log'):

        c = self.c
        if g.app.quitting or not c or not c.exists:
            return

        if color:
            color = leoColor.getColor(color, 'black')

        self.selectTab(tabName or 'Log')
        # print('qtLog.put',tabName,'%3s' % (len(s)),self.logCtrl)

        # Note: this must be done after the call to selectTab.
        w = self.logCtrl # w is a QTextBrowser
        if w:
            if s.endswith('\n'): s = s[:-1]
            s=s.replace('&amp;', '&amp;amp;').replace('&lt;', '&amp;lt;').replace('&gt;', '&amp;gt;')
            s = s.replace(' ','&amp;nbsp;')
            if color:
                s = '&lt;font color="%s"&gt;%s&lt;/font&gt;' % (color, s)
            s = s.replace('\n','&lt;br&gt;')
            sb = w.horizontalScrollBar()
            pos = sb.sliderPosition()
            w.append(s)
            w.moveCursor(QtGui.QTextCursor.End)
            sb.setSliderPosition(pos)
        else:
            # put s to logWaiting and print s
            g.app.logWaiting.append((s,color),)
            if g.isUnicode(s):
                s = g.toEncodedString(s,"ascii")
            print (s)
    #@-node:ekr.20081121105001.326:put
    #@+node:ekr.20081121105001.327:putnl
    def putnl (self,tabName='Log'):

        if g.app.quitting:
            return

        if tabName:
            self.selectTab(tabName)

        w = self.logCtrl
        if w:
            sb = w.horizontalScrollBar()
            pos = sb.sliderPosition()
            contents = w.toHtml()
            w.setHtml(contents + '\n')
            w.moveCursor(QtGui.QTextCursor.End)
            sb.setSliderPosition(pos)
            w.repaint()
        else:
            # put s to logWaiting and print  a newline
            g.app.logWaiting.append(('\n','black'),)
    #@-node:ekr.20081121105001.327:putnl
    #@-node:ekr.20081121105001.325:put &amp; putnl (qtLog)
    #@+node:ekr.20081121105001.328:Tab (qtLog)
    #@+node:ekr.20081121105001.329:clearTab
    def clearTab (self,tabName,wrap='none'):

        w = self.logDict.get(tabName)
        if w:
            w.clear() # w is a QTextBrowser.
    #@-node:ekr.20081121105001.329:clearTab
    #@+node:ekr.20081121105001.330:createTab
    def createTab (self,tabName,widget=None,wrap='none'):
        """ Create a new tab in tab widget

        if widget is None, Create a QTextBrowser,
        suitable for log functionality.
        """
        c = self.c ; w = self.tabWidget

        if widget is None:
            contents = QtGui.QTextBrowser()
            contents.setWordWrapMode(QtGui.QTextOption.NoWrap)
            self.logDict[tabName] = contents
            if tabName == 'Log': self.logCtrl = contents
            theFilter = leoQtEventFilter(c,w=contents,tag='tab')
            contents.installEventFilter(theFilter)
        else:
            contents = widget

        self.contentsDict[tabName] = contents
        w.addTab(contents,tabName)
        return contents

    #@-node:ekr.20081121105001.330:createTab
    #@+node:ekr.20081121105001.331:cycleTabFocus (to do)
    def cycleTabFocus (self,event=None,stop_w = None):

        '''Cycle keyboard focus between the tabs in the log pane.'''

        c = self.c ; w = self.tabWidget

        i = w.currentIndex()
        i += 1
        if i &gt;= w.count():
            i = 0

        tabName = w.tabText(i)
        w.setCurrentIndex(i)
        log = self.logDict.get(tabName)
        if log: self.logCtrl = log

    #@-node:ekr.20081121105001.331:cycleTabFocus (to do)
    #@+node:ekr.20081121105001.332:deleteTab
    def deleteTab (self,tabName,force=False):

        c = self.c ; w = self.tabWidget

        if force or tabName not in ('Log','Find','Spell'):
            for i in range(w.count()):
                if tabName == w.tabText(i):
                    w.removeTab(i)
                    break

        self.selectTab('Log')
        c.invalidateFocus()
        c.bodyWantsFocus()
    #@-node:ekr.20081121105001.332:deleteTab
    #@+node:ekr.20081121105001.333:hideTab
    def hideTab (self,tabName):

        self.selectTab('Log')
    #@-node:ekr.20081121105001.333:hideTab
    #@+node:ekr.20081121105001.334:numberOfVisibleTabs
    def numberOfVisibleTabs (self):

        return len([val for val in self.frameDict.values() if val != None])
    #@-node:ekr.20081121105001.334:numberOfVisibleTabs
    #@+node:ekr.20081121105001.335:selectTab &amp; helper
    def selectTab (self,tabName,createText=True,wrap='none'):

        '''Create the tab if necessary and make it active.'''

        c = self.c ; w = self.tabWidget ; trace = False

        ok = self.selectHelper(tabName,createText)
        if ok: return

        self.createTab(tabName,widget= None,wrap = wrap)
        self.selectHelper(tabName,createText)

    #@+node:ekr.20081121105001.336:selectHelper
    def selectHelper (self,tabName,createText):

        w = self.tabWidget

        for i in range(w.count()):
            if tabName == w.tabText(i):
                w.setCurrentIndex(i)
                if createText and tabName not in ('Spell','Find',):
                    self.logCtrl = w.widget(i)
                if tabName == 'Spell':
                    # the base class uses this as a flag to see if
                    # the spell system needs initing
                    self.frameDict['Spell'] = w.widget(i)
                return True
        else:
            return False
    #@-node:ekr.20081121105001.336:selectHelper
    #@-node:ekr.20081121105001.335:selectTab &amp; helper
    #@-node:ekr.20081121105001.328:Tab (qtLog)
    #@+node:ekr.20081121105001.337:qtLog color tab stuff
    def createColorPicker (self,tabName):

        return

        # log = self

        #@    &lt;&lt; define colors &gt;&gt;
        #@+node:ekr.20081121105001.338:&lt;&lt; define colors &gt;&gt;
        # colors = (
            # "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
            # "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
            # "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
            # "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
            # "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
            # "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
            # "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
            # "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
            # "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
            # "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
            # "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
            # "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
            # "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
            # "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
            # "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
            # "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
            # "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
            # "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
            # "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
            # "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
            # "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
            # "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
            # "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
            # "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
            # "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
            # "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
            # "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
            # "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
            # "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
            # "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
            # "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
            # "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
            # "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
            # "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
            # "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
            # "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
            # "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
            # "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
            # "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
            # "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
            # "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
            # "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
            # "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
            # "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
            # "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
            # "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
            # "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
            # "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
            # "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
            # "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
            # "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
            # "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
            # "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
            # "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
            # "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
            # "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
            # "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
            # "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
            # "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
            # "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
            # "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
            # "thistle4" )
        #@-node:ekr.20081121105001.338:&lt;&lt; define colors &gt;&gt;
        #@nl

        # parent = log.frameDict.get(tabName)
        # w = log.textDict.get(tabName)
        # w.pack_forget()

        # colors = list(colors)
        # bg = parent.cget('background')

        # outer = qt.Frame(parent,background=bg)
        # outer.pack(side='top',fill='both',expand=1,pady=10)

        # f = qt.Frame(outer)
        # f.pack(side='top',expand=0,fill='x')
        # f1 = qt.Frame(f) ; f1.pack(side='top',expand=0,fill='x')
        # f2 = qt.Frame(f) ; f2.pack(side='top',expand=1,fill='x')
        # f3 = qt.Frame(f) ; f3.pack(side='top',expand=1,fill='x')

        # label = g.app.gui.plainTextWidget(f1,height=1,width=20)
        # label.insert('1.0','Color name or value...')
        # label.pack(side='left',pady=6)

        #@    &lt;&lt; create optionMenu and callback &gt;&gt;
        #@+node:ekr.20081121105001.339:&lt;&lt; create optionMenu and callback &gt;&gt;
        # colorBox = Pmw.ComboBox(f2,scrolledlist_items=colors)
        # colorBox.pack(side='left',pady=4)

        # def colorCallback (newName): 
            # label.delete('1.0','end')
            # label.insert('1.0',newName)
            # try:
                # for theFrame in (parent,outer,f,f1,f2,f3):
                    # theFrame.configure(background=newName)
            # except: pass # Ignore invalid names.

        # colorBox.configure(selectioncommand=colorCallback)
        #@-node:ekr.20081121105001.339:&lt;&lt; create optionMenu and callback &gt;&gt;
        #@nl
        #@    &lt;&lt; create picker button and callback &gt;&gt;
        #@+node:ekr.20081121105001.340:&lt;&lt; create picker button and callback &gt;&gt;
        # def pickerCallback ():
            # return

            # rgb,val = tkColorChooser.askcolor(parent=parent,initialcolor=f.cget('background'))
            # if rgb or val:
                # # label.configure(text=val)
                # label.delete('1.0','end')
                # label.insert('1.0',val)
                # for theFrame in (parent,outer,f,f1,f2,f3):
                    # theFrame.configure(background=val)

        # b = qt.Button(f3,text="Color Picker...",
            # command=pickerCallback,background=bg)
        # b.pack(side='left',pady=4)
        #@-node:ekr.20081121105001.340:&lt;&lt; create picker button and callback &gt;&gt;
        #@nl
    #@-node:ekr.20081121105001.337:qtLog color tab stuff
    #@+node:ekr.20081121105001.341:qtLog font tab stuff
    #@+node:ekr.20081121105001.342:createFontPicker
    def createFontPicker (self,tabName):

        return

        # log = self ; c = self.c
        # parent = log.frameDict.get(tabName)
        # w = log.textDict.get(tabName)
        # w.pack_forget()

        # bg = parent.cget('background')
        # font = self.getFont()

        #@    &lt;&lt; create the frames &gt;&gt;
        #@+node:ekr.20081121105001.343:&lt;&lt; create the frames &gt;&gt;
        # f = qt.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
        # f1 = qt.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
        # f2 = qt.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
        # f3 = qt.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
        # f4 = qt.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')
        #@-node:ekr.20081121105001.343:&lt;&lt; create the frames &gt;&gt;
        #@nl
        #@    &lt;&lt; create the family combo box &gt;&gt;
        #@+node:ekr.20081121105001.344:&lt;&lt; create the family combo box &gt;&gt;
        # names = tkFont.families()
        # names = list(names)
        # names.sort()
        # names.insert(0,'&lt;None&gt;')

        # self.familyBox = familyBox = Pmw.ComboBox(f1,
            # labelpos="we",label_text='Family:',label_width=10,
            # label_background=bg,
            # arrowbutton_background=bg,
            # scrolledlist_items=names)

        # familyBox.selectitem(0)
        # familyBox.pack(side="left",padx=2,pady=2)
        #@-node:ekr.20081121105001.344:&lt;&lt; create the family combo box &gt;&gt;
        #@nl
        #@    &lt;&lt; create the size entry &gt;&gt;
        #@+node:ekr.20081121105001.345:&lt;&lt; create the size entry &gt;&gt;
        # qt.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

        # sizeEntry = qt.Entry(f2,width=4)
        # sizeEntry.insert(0,'12')
        # sizeEntry.pack(side="left",padx=2,pady=2)
        #@-node:ekr.20081121105001.345:&lt;&lt; create the size entry &gt;&gt;
        #@nl
        #@    &lt;&lt; create the weight combo box &gt;&gt;
        #@+node:ekr.20081121105001.346:&lt;&lt; create the weight combo box &gt;&gt;
        # weightBox = Pmw.ComboBox(f3,
            # labelpos="we",label_text="Weight:",label_width=10,
            # label_background=bg,
            # arrowbutton_background=bg,
            # scrolledlist_items=['normal','bold'])

        # weightBox.selectitem(0)
        # weightBox.pack(side="left",padx=2,pady=2)
        #@-node:ekr.20081121105001.346:&lt;&lt; create the weight combo box &gt;&gt;
        #@nl
        #@    &lt;&lt; create the slant combo box &gt;&gt;
        #@+node:ekr.20081121105001.347:&lt;&lt; create the slant combo box&gt;&gt;
        # slantBox = Pmw.ComboBox(f4,
            # labelpos="we",label_text="Slant:",label_width=10,
            # label_background=bg,
            # arrowbutton_background=bg,
            # scrolledlist_items=['roman','italic'])

        # slantBox.selectitem(0)
        # slantBox.pack(side="left",padx=2,pady=2)
        #@-node:ekr.20081121105001.347:&lt;&lt; create the slant combo box&gt;&gt;
        #@nl
        #@    &lt;&lt; create the sample text widget &gt;&gt;
        #@+node:ekr.20081121105001.348:&lt;&lt; create the sample text widget &gt;&gt;
        # self.sampleWidget = sample = g.app.gui.plainTextWidget(f,height=20,width=80,font=font)
        # sample.pack(side='left')

        # s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
        # sample.insert(0,s)
        #@-node:ekr.20081121105001.348:&lt;&lt; create the sample text widget &gt;&gt;
        #@nl
        #@    &lt;&lt; create and bind the callbacks &gt;&gt;
        #@+node:ekr.20081121105001.349:&lt;&lt; create and bind the callbacks &gt;&gt;
        # def fontCallback(event=None):
            # self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

        # for w in (familyBox,slantBox,weightBox):
            # w.configure(selectioncommand=fontCallback)

        # c.bind(sizeEntry,'&lt;Return&gt;',fontCallback)
        #@-node:ekr.20081121105001.349:&lt;&lt; create and bind the callbacks &gt;&gt;
        #@nl

        # self.createBindings()
    #@-node:ekr.20081121105001.342:createFontPicker
    #@+node:ekr.20081121105001.350:createBindings (fontPicker)
    def createBindings (self):

        c = self.c ; k = c.k

        # table = (
            # ('&lt;Button-1&gt;',  k.masterClickHandler),
            # ('&lt;Double-1&gt;',  k.masterClickHandler),
            # ('&lt;Button-3&gt;',  k.masterClickHandler),
            # ('&lt;Double-3&gt;',  k.masterClickHandler),
            # ('&lt;Key&gt;',       k.masterKeyHandler),
            # ("&lt;Escape&gt;",    self.hideFontTab),
        # )

        # w = self.sampleWidget
        # for event, callback in table:
            # c.bind(w,event,callback)

        # k.completeAllBindingsForWidget(w)
    #@-node:ekr.20081121105001.350:createBindings (fontPicker)
    #@+node:ekr.20081121105001.351:getFont
    def getFont(self,family=None,size=12,slant='roman',weight='normal'):

        return g.app.config.defaultFont

        # try:
            # return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # except Exception:
            # g.es("exception setting font")
            # g.es('','family,size,slant,weight:','',family,'',size,'',slant,'',weight)
            # # g.es_exception() # This just confuses people.
            # return g.app.config.defaultFont
    #@-node:ekr.20081121105001.351:getFont
    #@+node:ekr.20081121105001.352:setFont
    def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):

        pass

        # d = {}
        # for box,key in (
            # (familyBox, 'family'),
            # (None,      'size'),
            # (slantBox,  'slant'),
            # (weightBox, 'weight'),
        # ):
            # if box: val = box.get()
            # else:
                # val = sizeEntry.get().strip() or ''
                # try: int(val)
                # except ValueError: val = None
            # if val and val.lower() not in ('none','&lt;none&gt;',):
                # d[key] = val

        # family=d.get('family',None)
        # size=d.get('size',12)
        # weight=d.get('weight','normal')
        # slant=d.get('slant','roman')
        # font = self.getFont(family,size,slant,weight)
        # label.configure(font=font)
    #@-node:ekr.20081121105001.352:setFont
    #@+node:ekr.20081121105001.353:hideFontTab
    def hideFontTab (self,event=None):

        c = self.c
        c.frame.log.selectTab('Log')
        c.bodyWantsFocus()
    #@-node:ekr.20081121105001.353:hideFontTab
    #@-node:ekr.20081121105001.341:qtLog font tab stuff
    #@-others
#@-node:ekr.20081121105001.318:class leoQtLog
#@+node:ekr.20081121105001.354:class leoQtMenu (leoMenu)
class leoQtMenu (leoMenu.leoMenu):

    #@    @+others
    #@+node:ekr.20081121105001.355:leoQtMenu.__init__
    def __init__ (self,frame):

        assert frame
        assert frame.c

        # Init the base class.
        leoMenu.leoMenu.__init__(self,frame)

        # g.pr('leoQtMenu.__init__',g.callers(4))

        self.frame = frame
        self.c = c = frame.c
        self.leo_label = '&lt;no leo_label&gt;'

        self.menuBar = c.frame.top.menuBar()
        assert self.menuBar

        # Inject this dict into the commander.
        if not hasattr(c,'menuAccels'):
            setattr(c,'menuAccels',{})

        if 0:
            self.font = c.config.getFontFromParams(
                'menu_text_font_family', 'menu_text_font_size',
                'menu_text_font_slant',  'menu_text_font_weight',
                c.config.defaultMenuFontSize)
    #@-node:ekr.20081121105001.355:leoQtMenu.__init__
    #@+node:ekr.20081121105001.356:Activate menu commands (to do)
    #@+node:ekr.20081121105001.357:qtMenu.activateMenu
    def activateMenu (self,menuName):

        c = self.c ;  top = c.frame.top
        # topx,topy = top.winfo_rootx(),top.winfo_rooty()
        # menu = c.frame.menu.getMenu(menuName)

        # if menu:
            # d = self.computeMenuPositions()
            # x = d.get(menuName)
            # if x is None:
                # x = 0 ; g.trace('oops, no menu offset: %s' % menuName)

            # menu.tk_popup(topx+d.get(menuName,0),topy) # Fix by caugm.  Thanks!
        # else:
            # g.trace('oops, no menu: %s' % menuName)
    #@-node:ekr.20081121105001.357:qtMenu.activateMenu
    #@+node:ekr.20081121105001.358:qtMenu.computeMenuPositions
    def computeMenuPositions (self):

        # A hack.  It would be better to set this when creating the menus.
        menus = ('File','Edit','Outline','Plugins','Cmds','Window','Help')

        # Compute the *approximate* x offsets of each menu.
        d = {}
        n = 0
        # for z in menus:
            # menu = self.getMenu(z)
            # fontName = menu.cget('font')
            # font = tkFont.Font(font=fontName)
            # # g.pr('%8s' % (z),menu.winfo_reqwidth(),menu.master,menu.winfo_x())
            # d [z] = n
            # # A total hack: sorta works on windows.
            # n += font.measure(z+' '*4)+1

        return d
    #@-node:ekr.20081121105001.358:qtMenu.computeMenuPositions
    #@-node:ekr.20081121105001.356:Activate menu commands (to do)
    #@+node:ekr.20081121105001.359:Tkinter menu bindings
    # See the Tk docs for what these routines are to do
    #@+node:ekr.20081121105001.360:Methods with Tk spellings
    #@+node:ekr.20081121105001.361:add_cascade
    def add_cascade (self,parent,label,menu,underline):

        """Wrapper for the Tkinter add_cascade menu method.

        Adds a submenu to the parent menu, or the menubar."""

        c = self.c ; leoFrame = c.frame
        n = underline
        if -1 &lt; n &lt; len(label):
            label = label[:n] + '&amp;' + label[n:]

        menu.setTitle(label)
        menu.leo_label = label

        if parent:
            parent.addMenu(menu)
        else:
            self.menuBar.addMenu(menu)

        return menu
    #@-node:ekr.20081121105001.361:add_cascade
    #@+node:ekr.20081121105001.362:add_command (qt)
    def add_command (self,**keys):

        """Wrapper for the Tkinter add_command menu method."""

        c = self.c
        accel = keys.get('accelerator') or ''
        command = keys.get('command')
        label = keys.get('label')
        n = keys.get('underline')
        menu = keys.get('menu') or self
        if not label: return

        if -1 &lt; n &lt; len(label):
            label = label[:n] + '&amp;' + label[n:]
        if accel:
            label = '%s\t%s' % (label,accel)

        if menu.leo_label == 'File': g.trace(label,g.callers(4))

        action = menu.addAction(label)

        if command:
            def add_command_callback(label=label,command=command):
                return command()

            QtCore.QObject.connect(action,
                QtCore.SIGNAL("triggered()"),add_command_callback)
    #@-node:ekr.20081121105001.362:add_command (qt)
    #@+node:ekr.20081121105001.363:add_separator
    def add_separator(self,menu):

        """Wrapper for the Tkinter add_separator menu method."""

        if menu:
            menu.addSeparator()
    #@-node:ekr.20081121105001.363:add_separator
    #@+node:ekr.20081121105001.364:delete
    def delete (self,menu,realItemName):

        """Wrapper for the Tkinter delete menu method."""

        # if menu:
            # return menu.delete(realItemName)
    #@-node:ekr.20081121105001.364:delete
    #@+node:ekr.20081121105001.365:delete_range
    def delete_range (self,menu,n1,n2):

        """Wrapper for the Tkinter delete menu method."""

        # if menu:
            # return menu.delete(n1,n2)
    #@-node:ekr.20081121105001.365:delete_range
    #@+node:ekr.20081121105001.366:destroy
    def destroy (self,menu):

        """Wrapper for the Tkinter destroy menu method."""

        # if menu:
            # return menu.destroy()
    #@-node:ekr.20081121105001.366:destroy
    #@+node:ekr.20081121105001.367:insert
    def insert (self,menuName,position,label,command,underline=None):

        # g.trace(menuName,position,label,command,underline)

        menu = self.getMenu(menuName)
        if menu and label:
            n = underline
            if -1 &gt; n &gt; len(label):
                label = label[:n] + '&amp;' + label[n:]
            action = menu.addAction(label)
            if command:
                def insert_callback(label=label,command=command):
                    command()
                QtCore.QObject.connect(
                    action,QtCore.SIGNAL("triggered()"),insert_callback)
    #@-node:ekr.20081121105001.367:insert
    #@+node:ekr.20081121105001.368:insert_cascade
    def insert_cascade (self,parent,index,label,menu,underline):

        """Wrapper for the Tkinter insert_cascade menu method."""

        g.trace(label,menu)

        menu.setTitle(label)
        menu.leo_label = label

        if parent:
            parent.addMenu(menu)
        else:
            self.menuBar.addMenu(menu)

        return menu
    #@-node:ekr.20081121105001.368:insert_cascade
    #@+node:ekr.20081121105001.369:new_menu (qt)
    def new_menu(self,parent,tearoff=False,label=''): # label is for debugging.

        """Wrapper for the Tkinter new_menu menu method."""

        c = self.c ; leoFrame = self.frame

        # g.trace(parent,label)

        # Parent can be None, in which case it will be added to the menuBar.
        menu = qtMenuWrapper(c,leoFrame,parent)

        return menu
    #@nonl
    #@-node:ekr.20081121105001.369:new_menu (qt)
    #@-node:ekr.20081121105001.360:Methods with Tk spellings
    #@+node:ekr.20081121105001.370:Methods with other spellings (Qtmenu)
    #@+node:ekr.20081121105001.371:clearAccel
    def clearAccel(self,menu,name):

        pass

        # if not menu:
            # return

        # realName = self.getRealMenuName(name)
        # realName = realName.replace("&amp;","")

        # menu.entryconfig(realName,accelerator='')
    #@-node:ekr.20081121105001.371:clearAccel
    #@+node:ekr.20081121105001.372:createMenuBar (Qtmenu)
    def createMenuBar(self,frame):

        '''Create all top-level menus.
        The menuBar itself has already been created.'''

        self.createMenusFromTables()
    #@-node:ekr.20081121105001.372:createMenuBar (Qtmenu)
    #@+node:ekr.20081121105001.373:createOpenWithMenu
    def createOpenWithMenu(self,parent,label,index,amp_index):

        '''Create a submenu.'''

        c = self.c ; leoFrame = c.frame

        g.trace()

        # menu = qtMenuWrapper(c,leoFrame,parent)
        # self.insert_cascade(parent,index,label,menu,underline=amp_index)

        # menu = Tk.Menu(parent,tearoff=0)
        # if menu:
            # parent.insert_cascade(index,label=label,menu=menu,underline=amp_index)
        # return menu
    #@-node:ekr.20081121105001.373:createOpenWithMenu
    #@+node:ekr.20081121105001.374:disableMenu
    def disableMenu (self,menu,name):

        if not menu:
            return

        # try:
            # menu.entryconfig(name,state="disabled")
        # except: 
            # try:
                # realName = self.getRealMenuName(name)
                # realName = realName.replace("&amp;","")
                # menu.entryconfig(realName,state="disabled")
            # except:
                # g.pr("disableMenu menu,name:",menu,name)
                # g.es_exception()
    #@-node:ekr.20081121105001.374:disableMenu
    #@+node:ekr.20081121105001.375:enableMenu
    # Fail gracefully if the item name does not exist.

    def enableMenu (self,menu,name,val):

        if not menu:
            return

        # state = g.choose(val,"normal","disabled")
        # try:
            # menu.entryconfig(name,state=state)
        # except:
            # try:
                # realName = self.getRealMenuName(name)
                # realName = realName.replace("&amp;","")
                # menu.entryconfig(realName,state=state)
            # except:
                # g.pr("enableMenu menu,name,val:",menu,name,val)
                # g.es_exception()
    #@nonl
    #@-node:ekr.20081121105001.375:enableMenu
    #@+node:ekr.20081121105001.376:getMenuLabel
    def getMenuLabel (self,menu,name):

        '''Return the index of the menu item whose name (or offset) is given.
        Return None if there is no such menu item.'''

        g.trace('menu',menu,'name',name)

        actions = menu.actions()
        for action in actions:
            g.trace(action.label())

        # try:
            # index = menu.index(name)
        # except:
            # index = None

        # return index
    #@-node:ekr.20081121105001.376:getMenuLabel
    #@+node:ekr.20081121105001.377:setMenuLabel
    def setMenuLabel (self,menu,name,label,underline=-1):

        def munge(s):
            s = g.app.gui.toUnicode(s)
            return s.replace('&amp;','')

        # menu is a qtMenuWrapper.

        # g.trace('menu',menu,'name: %20s label: %s' % (name,label))

        if not menu: return

        realName  = munge(self.getRealMenuName(name))
        realLabel = self.getRealMenuName(label)
        for action in menu.actions():
            s = munge(action.text())
            s = s.split('\t')[0]
            if s == realName:
                action.setText(realLabel)
                break
    #@-node:ekr.20081121105001.377:setMenuLabel
    #@-node:ekr.20081121105001.370:Methods with other spellings (Qtmenu)
    #@-node:ekr.20081121105001.359:Tkinter menu bindings
    #@+node:ekr.20081121105001.378:getMacHelpMenu
    def getMacHelpMenu (self,table):

        return None

        # defaultTable = [
                # # &amp;: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
                # ('&amp;About Leo...',           'about-leo'),
                # ('Online &amp;Home Page',       'open-online-home'),
                # '*open-online-&amp;tutorial',
                # '*open-&amp;users-guide',
                # '-',
                # ('Open Leo&amp;Docs.leo',       'open-leoDocs-leo'),
                # ('Open Leo&amp;Plugins.leo',    'open-leoPlugins-leo'),
                # ('Open Leo&amp;Settings.leo',   'open-leoSettings-leo'),
                # ('Open &amp;myLeoSettings.leo', 'open-myLeoSettings-leo'),
                # ('Open scr&amp;ipts.leo',       'open-scripts-leo'),
                # '-',
                # '*he&amp;lp-for-minibuffer',
                # '*help-for-&amp;command',
                # '-',
                # '*&amp;apropos-autocompletion',
                # '*apropos-&amp;bindings',
                # '*apropos-&amp;debugging-commands',
                # '*apropos-&amp;find-commands',
                # '-',
                # '*pri&amp;nt-bindings',
                # '*print-c&amp;ommands',
            # ]

        # try:
            # topMenu = self.getMenu('top')
            # # Use the name argument to create the special Macintosh Help menu.
            # helpMenu = Tk.Menu(topMenu,name='help',tearoff=0)
            # self.add_cascade(topMenu,label='Help',menu=helpMenu,underline=0)
            # self.createMenuEntries(helpMenu,table or defaultTable)
            # return helpMenu

        # except Exception:
            # g.trace('Can not get MacOS Help menu')
            # g.es_exception()
            # return None
    #@-node:ekr.20081121105001.378:getMacHelpMenu
    #@-others
#@-node:ekr.20081121105001.354:class leoQtMenu (leoMenu)
#@+node:ekr.20081121105001.379:class leoQtSpellTab
class leoQtSpellTab:

    #@    @+others
    #@+node:ekr.20081121105001.380:leoQtSpellTab.__init__
    def __init__ (self,c,handler,tabName):

        self.c = c
        self.handler = handler

        # hack:
        handler.workCtrl = leoFrame.stringTextWidget(c, 'spell-workctrl')

        self.tabName = tabName

        ui = c.frame.top.ui

        # self.createFrame()

        if not hasattr(ui, 'leo_spell_label'):
            self.handler.loaded = False
            return

        self.wordLabel = ui.leo_spell_label
        self.listBox = ui.leo_spell_listBox

        #self.createBindings()

        self.fillbox([])
    #@-node:ekr.20081121105001.380:leoQtSpellTab.__init__
    #@+node:ekr.20081121105001.381:createBindings TO DO
    def createBindings (self):
        pass
    #@-node:ekr.20081121105001.381:createBindings TO DO
    #@+node:ekr.20081121105001.382:createFrame (to be done in Qt designer)
    def createFrame (self):
        pass

    #@-node:ekr.20081121105001.382:createFrame (to be done in Qt designer)
    #@+node:ekr.20081121105001.386:Event handlers
    #@+node:ekr.20081121105001.387:onAddButton
    def onAddButton(self):
        """Handle a click in the Add button in the Check Spelling dialog."""

        self.handler.add()
    #@-node:ekr.20081121105001.387:onAddButton
    #@+node:ekr.20081121105001.388:onChangeButton &amp; onChangeThenFindButton
    def onChangeButton(self,event=None):

        """Handle a click in the Change button in the Spell tab."""

        state = self.updateButtons()
        if state:
            self.handler.change()
        self.updateButtons()

    def onChangeThenFindButton(self,event=None):

        """Handle a click in the "Change, Find" button in the Spell tab."""

        state = self.updateButtons()
        if state:
            self.handler.change()
            if self.handler.change():
                self.handler.find()
            self.updateButtons()
    #@-node:ekr.20081121105001.388:onChangeButton &amp; onChangeThenFindButton
    #@+node:ekr.20081121105001.389:onFindButton
    def onFindButton(self):

        """Handle a click in the Find button in the Spell tab."""

        c = self.c
        self.handler.find()
        self.updateButtons()
        c.invalidateFocus()
        c.bodyWantsFocusNow()
    #@-node:ekr.20081121105001.389:onFindButton
    #@+node:ekr.20081121105001.390:onHideButton
    def onHideButton(self):

        """Handle a click in the Hide button in the Spell tab."""

        self.handler.hide()
    #@-node:ekr.20081121105001.390:onHideButton
    #@+node:ekr.20081121105001.391:onIgnoreButton
    def onIgnoreButton(self,event=None):

        """Handle a click in the Ignore button in the Check Spelling dialog."""

        self.handler.ignore()
    #@-node:ekr.20081121105001.391:onIgnoreButton
    #@+node:ekr.20081121105001.392:onMap
    def onMap (self, event=None):
        """Respond to a Tk &lt;Map&gt; event."""

        self.update(show= False, fill= False)
    #@-node:ekr.20081121105001.392:onMap
    #@+node:ekr.20081121105001.393:onSelectListBox
    def onSelectListBox(self, event=None):
        """Respond to a click in the selection listBox."""

        c = self.c
        self.updateButtons()
        c.bodyWantsFocus()
    #@-node:ekr.20081121105001.393:onSelectListBox
    #@-node:ekr.20081121105001.386:Event handlers
    #@+node:ekr.20081121105001.394:Helpers
    #@+node:ekr.20081121105001.395:bringToFront
    def bringToFront (self):

        self.c.frame.log.selectTab('Spell')
    #@-node:ekr.20081121105001.395:bringToFront
    #@+node:ekr.20081121105001.396:fillbox
    def fillbox(self, alts, word=None):
        """Update the suggestions listBox in the Check Spelling dialog."""

        ui = self.c.frame.top.ui

        self.suggestions = alts

        if not word:
            word = ""

        self.wordLabel.setText("Suggestions for: " + word)
        self.listBox.clear()
        if len(self.suggestions):
            self.listBox.addItems(self.suggestions)
            self.listBox.setCurrentRow(0)
    #@-node:ekr.20081121105001.396:fillbox
    #@+node:ekr.20081121105001.397:getSuggestion
    def getSuggestion(self):
        """Return the selected suggestion from the listBox."""

        idx = self.listBox.currentRow()
        value = self.suggestions[idx]
        return value
    #@-node:ekr.20081121105001.397:getSuggestion
    #@+node:ekr.20081121105001.398:update
    def update(self,show=True,fill=False):

        """Update the Spell Check dialog."""

        c = self.c

        if fill:
            self.fillbox([])

        self.updateButtons()

        if show:
            self.bringToFront()
            c.bodyWantsFocus()
    #@-node:ekr.20081121105001.398:update
    #@+node:ekr.20081121105001.399:updateButtons (spellTab)
    def updateButtons (self):

        """Enable or disable buttons in the Check Spelling dialog."""

        c = self.c

        ui = c.frame.top.ui

        w = c.frame.body.bodyCtrl
        state = self.suggestions and w.hasSelection()

        ui.leo_spell_btn_Change.setDisabled(not state)
        ui.leo_spell_btn_FindChange.setDisabled(not state)

        # # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
        # # self.redoButton.configure(state=state)
        # # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
        # # self.undoButton.configure(state=state)

        # self.addButton.configure(state='normal')
        # self.ignoreButton.configure(state='normal')

        return state
    #@nonl
    #@-node:ekr.20081121105001.399:updateButtons (spellTab)
    #@-node:ekr.20081121105001.394:Helpers
    #@-others
#@-node:ekr.20081121105001.379:class leoQtSpellTab
#@+node:ekr.20081121105001.400:class leoQtTree (baseNativeTree)
class leoQtTree (baseNativeTree.baseNativeTreeWidget):

    """Leo qt tree class, a subclass of baseNativeTreeWidget."""

    callbacksInjected = False # A class var.

    #@    @+others
    #@+node:ekr.20090124174652.118: Birth (leoQtTree)
    #@+node:ekr.20090124174652.119:ctor
    def __init__(self,c,frame):

        # Init the base class.
        baseNativeTree.baseNativeTreeWidget.__init__(self,c,frame)

        # Components.
        self.headlineWrapper = leoQtHeadlineWidget # This is a class.
        self.treeWidget = w = frame.top.ui.treeWidget # An internal ivar.

        # Early inits...
        try: w.headerItem().setHidden(True)
        except Exception: pass

        w.setIconSize(QtCore.QSize(160,16))
    #@-node:ekr.20090124174652.119:ctor
    #@+node:ekr.20090124174652.120:qtTree.initAfterLoad
    def initAfterLoad (self):

        '''Do late-state inits.'''

        # Called by Leo's core.

        c = self.c ; frame = c.frame
        w = c.frame.top ; tw = self.treeWidget

        if not leoQtTree.callbacksInjected:
            leoQtTree.callbacksInjected = True
            self.injectCallbacks() # A base class method.

        w.connect(self.treeWidget,QtCore.SIGNAL(
                "itemDoubleClicked(QTreeWidgetItem*, int)"),
            self.onItemDoubleClicked)

        w.connect(self.treeWidget,QtCore.SIGNAL(
                "itemSelectionChanged()"),
            self.onTreeSelect)

        # We don't need this.  Hooray!
        # w.connect(self.treeWidget,QtCore.SIGNAL(
                # "itemChanged(QTreeWidgetItem*, int)"),
            # self.onItemChanged)

        w.connect(self.treeWidget,QtCore.SIGNAL(
                "itemCollapsed(QTreeWidgetItem*)"),
            self.onItemCollapsed)

        w.connect(self.treeWidget,QtCore.SIGNAL(
                "itemExpanded(QTreeWidgetItem*)"),
            self.onItemExpanded)

        self.ev_filter = leoQtEventFilter(c,w=self,tag='tree')
        tw.installEventFilter(self.ev_filter)

        c.setChanged(False)
    #@-node:ekr.20090124174652.120:qtTree.initAfterLoad
    #@-node:ekr.20090124174652.118: Birth (leoQtTree)
    #@+node:ekr.20090124174652.102:Widget-dependent helpers (leoQtTree)
    #@+node:ekr.20090126120517.11:Drawing
    def clear (self):
        '''Clear all widgets in the tree.'''
        w = self.treeWidget
        w.clear()

    def repaint (self):
        '''Repaint the widget.'''
        w = self.treeWidget
        w.repaint()
    #@nonl
    #@-node:ekr.20090126120517.11:Drawing
    #@+node:ekr.20090124174652.109:Icons
    #@+node:ekr.20090124174652.110:drawIcon
    def drawIcon (self,p):

        '''Redraw the icon at p.'''

        w = self.treeWidget
        itemOrTree = self.position2item(p) or w
        item = QtGui.QTreeWidgetItem(itemOrTree)
        icon = self.getIcon(p)
        self.setItemIcon(item,icon)
    #@-node:ekr.20090124174652.110:drawIcon
    #@+node:ekr.20090124174652.111:getIcon
    def getIcon(self,p):

        '''Return the proper icon for position p.'''

        p.v.iconVal = val = p.v.computeIcon()
        return self.getCompositeIconImage(p, val)

    def getCompositeIconImage(self, p, val):

        userIcons = self.c.editCommands.getIconList(p)
        statusIcon = self.getIconImage(val)

        if not userIcons:
            return statusIcon

        hash = [i['file'] for i in userIcons if i['where'] == 'beforeIcon']
        hash.append(str(val))
        hash.extend([i['file'] for i in userIcons if i['where'] == 'beforeHeadline'])
        hash = ':'.join(hash)

        if hash in g.app.gui.iconimages:
            return g.app.gui.iconimages[hash]

        images = [g.app.gui.getImageImage(i['file']) for i in userIcons
                 if i['where'] == 'beforeIcon']
        images.append(g.app.gui.getImageImage("box%02d.GIF" % val))
        images.extend([g.app.gui.getImageImage(i['file']) for i in userIcons
                      if i['where'] == 'beforeHeadline'])
        width = sum([i.width() for i in images])
        height = max([i.height() for i in images])

        pix = QtGui.QPixmap(width,height)
        pix.fill()
        pix.setAlphaChannel(pix)
        painter = QtGui.QPainter(pix)
        x = 0
        for i in images:
            painter.drawPixmap(x,(height-i.height())//2,i)
            x += i.width()
        painter.end()

        g.app.gui.iconimages[hash] = QtGui.QIcon(pix)

        return g.app.gui.iconimages[hash]
    #@-node:ekr.20090124174652.111:getIcon
    #@+node:ekr.20090124174652.112:setItemIconHelper (qtTree)
    def setItemIconHelper (self,item,icon):

        # Generates an item-changed event.
        item.setIcon(0,icon)
    #@-node:ekr.20090124174652.112:setItemIconHelper (qtTree)
    #@-node:ekr.20090124174652.109:Icons
    #@+node:ekr.20090124174652.115:Items
    #@+node:ekr.20090124174652.67:childIndexOfItem
    def childIndexOfItem (self,item):

        parent = item.parent()

        if parent:
            n = parent.indexOfChild(item)
        else:
            w = self.treeWidget
            n = w.indexOfTopLevelItem(item)

        return n

    #@-node:ekr.20090124174652.67:childIndexOfItem
    #@+node:ekr.20090124174652.66:childItems
    def childItems (self,parent_item):

        '''Return the list of child items of the parent item,
        or the top-level items if parent_item is None.'''

        if parent_item:
            n = parent_item.childCount()
            items = [parent_item.child(z) for z in range(n)]
        else:
            w = self.treeWidget
            n = w.topLevelItemCount()
            items = [w.topLevelItem(z) for z in range(n)]

        return items
    #@-node:ekr.20090124174652.66:childItems
    #@+node:ekr.20090124174652.18:contractItem &amp; expandItem
    def contractItem (self,item):

        self.treeWidget.collapseItem(item)

    def expandItem (self,item):

        self.treeWidget.expandItem(item)
    #@-node:ekr.20090124174652.18:contractItem &amp; expandItem
    #@+node:ekr.20090124174652.104:createTreeEditorForItem
    def createTreeEditorForItem(self,item):

        w = self.treeWidget
        w.setCurrentItem(item) # Must do this first.
        w.editItem(item)
        e = w.itemWidget(item,0)
        e.setObjectName('headline')

        # Hook up the widget.
        e.connect(e,QtCore.SIGNAL(
            "textEdited(QTreeWidgetItem*,int)"),
            self.onHeadChanged)

        return e
    #@-node:ekr.20090124174652.104:createTreeEditorForItem
    #@+node:ekr.20090129062500.13:editLabelHelper
    def editLabelHelper (self,item,selectAll,selection):

        '''Called by nativeTree.editLabel to do
        gui-specific stuff.'''

        w = self.treeWidget
        w.setCurrentItem(item) # Must do this first.
        w.editItem(item)
            # Generates focus-in event that tree doesn't report.
        e = w.itemWidget(item,0) # A QLineEdit

        if e:
            s = e.text() ; len_s = len(s)
            if selection:
                i,j,ins = selection
                start,n = i,abs(i-j)
                    # Not right for backward searches.
            elif selectAll: start,n,ins = 0,len_s,len_s
            else:           start,n,ins = len_s,0,len_s
            e.setObjectName('headline')
            e.setSelection(start,n)
            # e.setCursorPosition(ins) # Does not work.
            e.setFocus()
        else:
            self.error('no edit widget')

        return e
    #@-node:ekr.20090129062500.13:editLabelHelper
    #@+node:ekr.20090124174652.103:createTreeItem
    def createTreeItem(self,p,parent_item):

        w = self.treeWidget
        itemOrTree = parent_item or w
        item = QtGui.QTreeWidgetItem(itemOrTree)
        item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)
        return item
    #@-node:ekr.20090124174652.103:createTreeItem
    #@+node:ekr.20090124174652.105:getCurrentItem
    def getCurrentItem (self):

        w = self.treeWidget
        return w.currentItem()
    #@-node:ekr.20090124174652.105:getCurrentItem
    #@+node:ekr.20090126120517.22:getItemText (debugging only)
    def getItemText (self,item):

        '''Return the text of the item.'''

        if item:
            s = item.text(0)
            s = g.toUnicode(s,'utf-8')
            return s
        else:
            return '&lt;no item&gt;'
    #@nonl
    #@-node:ekr.20090126120517.22:getItemText (debugging only)
    #@+node:ekr.20090126120517.19:getParentItem
    def getParentItem(self,item):

        return item.parent()
    #@nonl
    #@-node:ekr.20090126120517.19:getParentItem
    #@+node:ekr.20090124174652.106:getTreeEditorForItem
    def getTreeEditorForItem(self,item):

        '''Return the edit widget if it exists.
        Do *not* create one if it does not exist.'''

        w = self.treeWidget
        e = w.itemWidget(item,0)
        return e
    #@-node:ekr.20090124174652.106:getTreeEditorForItem
    #@+node:ekr.20090124174652.69:nthChildItem
    def nthChildItem (self,n,parent_item):

        children = self.childItems(parent_item)

        if n &lt; len(children):
            item = children[n]
        else:
            # This is **not* an error.
            # It simply means that we need to redraw the tree.
            item = None

        return item
    #@-node:ekr.20090124174652.69:nthChildItem
    #@+node:ekr.20090201080444.12:scrollToItem
    def scrollToItem (self,item):

        w = self.treeWidget

        # g.trace(self.traceItem(item),g.callers(4))

        hPos,vPos = self.getScroll()

        w.scrollToItem(item,w.PositionAtCenter)

        self.setHScroll(hPos)
    #@-node:ekr.20090201080444.12:scrollToItem
    #@+node:ekr.20090124174652.107:setCurrentItemHelper
    def setCurrentItemHelper(self,item):

        w = self.treeWidget
        w.setCurrentItem(item)
    #@-node:ekr.20090124174652.107:setCurrentItemHelper
    #@+node:ekr.20090124174652.108:setItemText
    def setItemText (self,item,s):

        item.setText(0,s)
    #@-node:ekr.20090124174652.108:setItemText
    #@-node:ekr.20090124174652.115:Items
    #@+node:ekr.20090124174652.122:Scroll bars
    def getScroll (self):

        '''Return the hPos,vPos for the tree's scrollbars.'''

        w = self.treeWidget
        hScroll = w.horizontalScrollBar()
        vScroll = w.verticalScrollBar()
        hPos = hScroll.sliderPosition()
        vPos = vScroll.sliderPosition()
        return hPos,vPos

    def setHScroll (self,hPos):
        w = self.treeWidget
        hScroll = w.horizontalScrollBar()

    def setVScroll (self,vPos):
        w = self.treeWidget
    #@nonl
    #@-node:ekr.20090124174652.122:Scroll bars
    #@-node:ekr.20090124174652.102:Widget-dependent helpers (leoQtTree)
    #@-others
#@-node:ekr.20081121105001.400:class leoQtTree (baseNativeTree)
#@+node:ekr.20081121105001.459:class leoQtTreeTab
class leoQtTreeTab (leoFrame.leoTreeTab):

    '''A class representing a tabbed outline pane drawn with Qt.'''

    #@    @+others
    #@+node:ekr.20081121105001.460: Birth &amp; death
    #@+node:ekr.20081121105001.461: ctor (leoTreeTab)
    def __init__ (self,c,parentFrame,chapterController):

        leoFrame.leoTreeTab.__init__ (self,c,chapterController,parentFrame)
            # Init the base class.  Sets self.c, self.cc and self.parentFrame.

        self.tabNames = [] # The list of tab names.  Changes when tabs are renamed.

        self.createControl()
    #@-node:ekr.20081121105001.461: ctor (leoTreeTab)
    #@+node:ekr.20081121105001.462:tt.createControl
    def createControl (self):

        return None

        # tt = self ; c = tt.c

        # # Create the main container, possibly in a new row.
        # tt.frame = c.frame.getNewIconFrame()

        # # Create the chapter menu.
        # self.chapterVar = var = qt.StringVar()
        # var.set('main')

        # tt.chapterMenu = menu = Pmw.OptionMenu(tt.frame,
            # labelpos = 'w', label_text = 'chapter',
            # menubutton_textvariable = var,
            # items = [],
            # command = tt.selectTab,
        # )
        # menu.pack(side='left',padx=5)

        # # Actually add tt.frame to the icon row.
        # c.frame.addIconWidget(tt.frame)
    #@-node:ekr.20081121105001.462:tt.createControl
    #@-node:ekr.20081121105001.460: Birth &amp; death
    #@+node:ekr.20081121105001.463:Tabs...
    #@+node:ekr.20081121105001.464:tt.createTab
    def createTab (self,tabName,select=True):

        tt = self

        # if tabName not in tt.tabNames:
            # tt.tabNames.append(tabName)
            # tt.setNames()
    #@-node:ekr.20081121105001.464:tt.createTab
    #@+node:ekr.20081121105001.465:tt.destroyTab
    def destroyTab (self,tabName):

        tt = self

        # if tabName in tt.tabNames:
            # tt.tabNames.remove(tabName)
            # tt.setNames()
    #@-node:ekr.20081121105001.465:tt.destroyTab
    #@+node:ekr.20081121105001.466:tt.selectTab
    def selectTab (self,tabName):

        tt = self

        # if tabName not in self.tabNames:
            # tt.createTab(tabName)

        # tt.cc.selectChapterByName(tabName)

        # self.c.redraw()
        # self.c.outerUpdate()
    #@-node:ekr.20081121105001.466:tt.selectTab
    #@+node:ekr.20081121105001.467:tt.setTabLabel
    def setTabLabel (self,tabName):

        tt = self
    #     tt.chapterVar.set(tabName)
    #@-node:ekr.20081121105001.467:tt.setTabLabel
    #@+node:ekr.20081121105001.468:tt.setNames
    def setNames (self):

        '''Recreate the list of items.'''

        # tt = self
        # names = tt.tabNames[:]
        # if 'main' in names: names.remove('main')
        # names.sort()
        # names.insert(0,'main')
        # tt.chapterMenu.setitems(names)
    #@-node:ekr.20081121105001.468:tt.setNames
    #@-node:ekr.20081121105001.463:Tabs...
    #@-others
#@nonl
#@-node:ekr.20081121105001.459:class leoQtTreeTab
#@+node:ekr.20081121105001.469:class qtMenuWrapper (QtMenu,leoQtMenu)
class qtMenuWrapper (QtGui.QMenu,leoQtMenu):

    def __init__ (self,c,frame,parent):

        assert c
        assert frame
        QtGui.QMenu.__init__(self,parent)
        leoQtMenu.__init__(self,frame)

    def __repr__(self):

        return '&lt;qtMenuWrapper %s&gt;' % self.leo_label or 'unlabeled'
#@-node:ekr.20081121105001.469:class qtMenuWrapper (QtMenu,leoQtMenu)
#@+node:ekr.20081121105001.470:class qtSearchWidget
class qtSearchWidget:

    """A dummy widget class to pass to Leo's core find code."""

    def __init__ (self):

        self.insertPoint = 0
        self.selection = 0,0
        self.bodyCtrl = self
        self.body = self
        self.text = None
#@nonl
#@-node:ekr.20081121105001.470:class qtSearchWidget
#@-node:ekr.20081121105001.194:Frame and component classes...
#@+node:ekr.20081121105001.471:Gui wrapper
#@+node:ekr.20081121105001.472:class leoQtGui
class leoQtGui(leoGui.leoGui):

    '''A class implementing Leo's Qt gui.'''

    #@    @+others
    #@+node:ekr.20081121105001.473:  Birth &amp; death (qtGui)
    #@+node:ekr.20081121105001.474: qtGui.__init__
    def __init__ (self):

        # Initialize the base class.
        leoGui.leoGui.__init__(self,'qt')

        self.qtApp = app = QtGui.QApplication(sys.argv)

        self.bodyTextWidget  = leoQtBaseTextWidget
        self.plainTextWidget = leoQtBaseTextWidget

        self.iconimages = {} # Image cache set by getIconImage().

        self.mGuiName = 'qt'
    #@-node:ekr.20081121105001.474: qtGui.__init__
    #@+node:ekr.20081121105001.475:createKeyHandlerClass (qtGui)
    def createKeyHandlerClass (self,c,useGlobalKillbuffer=True,useGlobalRegisters=True):

        # Use the base class
        return leoKeys.keyHandlerClass(c,useGlobalKillbuffer,useGlobalRegisters)
    #@-node:ekr.20081121105001.475:createKeyHandlerClass (qtGui)
    #@+node:ekr.20090123150451.11:onActivateEvent (qtGui)
    def onActivateEvent (self,event,c,obj,tag):

        '''Put the focus in the body pane when the Leo window is
        activated, say as the result of an Alt-tab or click.'''

        # This is called several times for each window activation.
        # We only need to set the focus once.

        if c.exists and tag == 'body':

            # g.trace('Activate',tag,g.callers(5))

            # Putting focus in the body is clearest.
            c.bodyWantsFocus()
            c.outerUpdate()
    #@-node:ekr.20090123150451.11:onActivateEvent (qtGui)
    #@+node:ekr.20081121105001.476:runMainLoop (qtGui)
    def runMainLoop(self):

        '''Start the Qt main loop.'''

        if self.script:
            log = g.app.log
            if log:
                g.pr('Start of batch script...\n')
                log.c.executeScript(script=self.script)
                g.pr('End of batch script')
            else:
                g.pr('no log, no commander for executeScript in qtGui.runMainLoop')
        else:
            sys.exit(self.qtApp.exec_())
    #@-node:ekr.20081121105001.476:runMainLoop (qtGui)
    #@+node:ekr.20081121105001.477:destroySelf
    def destroySelf (self):
        QtCore.pyqtRemoveInputHook()
        self.qtApp.exit()
    #@nonl
    #@-node:ekr.20081121105001.477:destroySelf
    #@-node:ekr.20081121105001.473:  Birth &amp; death (qtGui)
    #@+node:ekr.20081121105001.183:Clipboard (qtGui)
    def replaceClipboardWith (self,s):

        '''Replace the clipboard with the string s.'''

        trace = False
        cb = self.qtApp.clipboard()
        if cb:
            cb.clear()
            s = g.app.gui.toUnicode(s,
                encoding=g.app.tkEncoding,
                reportErrors=True)
            cb.setText(s)
            if trace: g.trace(len(s),type(s))
        else:
            g.trace('no clipboard!')

    def getTextFromClipboard (self):

        '''Get a unicode string from the clipboard.'''

        trace = False
        cb = self.qtApp.clipboard()
        if cb:
            s = cb.text()
            if trace: g.trace (len(s),type(s))
            s = g.app.gui.toUnicode(s,
                encoding=g.app.tkEncoding,
                reportErrors=True)
            return s
        else:
            g.trace('no clipboard!')
            return ''
    #@-node:ekr.20081121105001.183:Clipboard (qtGui)
    #@+node:ekr.20081121105001.478:Do nothings
    def color (self,color):
        return None

    def createRootWindow(self):
        pass

    def killGui(self,exitFlag=True):
        """Destroy a gui and terminate Leo if exitFlag is True."""

    def killPopupMenu(self):
        pass

    def recreateRootWindow(self):
        """Create the hidden root window of a gui
        after a previous gui has terminated with killGui(False)."""


    #@-node:ekr.20081121105001.478:Do nothings
    #@+node:ekr.20081121105001.479:Dialogs &amp; panels
    #@+node:ekr.20081122170423.1:alert (qtGui)
    def alert (self,message):

        if g.unitTesting: return

        b = QtGui.QMessageBox
        d = b(None)
        d.setWindowTitle('Alert')
        d.setText(message)
        d.setIcon(b.Warning)
        yes = d.addButton('Ok',b.YesRole)
        d.exec_()
    #@nonl
    #@-node:ekr.20081122170423.1:alert (qtGui)
    #@+node:ekr.20081121105001.480:makeFilter
    def makeFilter (self,filetypes):

        '''Return the Qt-style dialog filter from filetypes list.'''

        filters = ['%s (%s)' % (z) for z in filetypes]

        return ';;'.join(filters)
    #@-node:ekr.20081121105001.480:makeFilter
    #@+node:ekr.20081121105001.481:not used
    def runAskOkCancelNumberDialog(self,c,title,message):

        """Create and run askOkCancelNumber dialog ."""

        if g.unitTesting: return None
        g.trace('not ready yet')

    def runAskOkCancelStringDialog(self,c,title,message):

        """Create and run askOkCancelString dialog ."""

        if g.unitTesting: return None
        g.trace('not ready yet')


    #@-node:ekr.20081121105001.481:not used
    #@+node:ekr.20081121105001.482:qtGui panels
    def createComparePanel(self,c):

        """Create a qt color picker panel."""
        return None # This window is optional.
        # return leoQtComparePanel(c)

    def createFindTab (self,c,parentFrame):
        """Create a qt find tab in the indicated frame."""
        return leoQtFindTab(c,parentFrame)

    def createLeoFrame(self,title):
        """Create a new Leo frame."""
        gui = self
        return leoQtFrame(title,gui)

    def createSpellTab(self,c,spellHandler,tabName):
        return leoQtSpellTab(c,spellHandler,tabName)

    #@-node:ekr.20081121105001.482:qtGui panels
    #@+node:ekr.20081121105001.483:runAboutLeoDialog
    def runAboutLeoDialog(self,c,version,theCopyright,url,email):

        """Create and run a qt About Leo dialog."""

        if g.unitTesting: return None

        b = QtGui.QMessageBox
        d = b(c.frame.top)

        d.setText('%s\n%s\n%s\n%s' % (
            version,theCopyright,url,email))
        d.setIcon(b.Information)
        yes = d.addButton('Ok',b.YesRole)
        d.setDefaultButton(yes)
        d.exec_()
    #@-node:ekr.20081121105001.483:runAboutLeoDialog
    #@+node:ekr.20081121105001.484:runAskLeoIDDialog
    def runAskLeoIDDialog(self):

        """Create and run a dialog to get g.app.LeoID."""

        if g.unitTesting: return None

        message = (
            "leoID.txt not found\n\n" +
            "Please enter an id that identifies you uniquely.\n" +
            "Your cvs/bzr login name is a good choice.\n\n" +
            "Your id must contain only letters and numbers\n" +
            "and must be at least 3 characters in length.")
        parent = None
        title = 'Enter Leo id'
        s,ok = QtGui.QInputDialog.getText(parent,title,message)
        return g.app.gui.toUnicode(s)
    #@nonl
    #@-node:ekr.20081121105001.484:runAskLeoIDDialog
    #@+node:ekr.20081121105001.485:runAskOkDialog
    def runAskOkDialog(self,c,title,message=None,text="Ok"):

        """Create and run a qt an askOK dialog ."""

        if g.unitTesting: return None

        b = QtGui.QMessageBox
        d = b(c.frame.top)

        d.setWindowTitle(title)
        if message: d.setText(message)
        d.setIcon(b.Information)
        yes = d.addButton(text,b.YesRole)
        d.exec_()

    #@-node:ekr.20081121105001.485:runAskOkDialog
    #@+node:ekr.20081121105001.486:runAskYesNoCancelDialog
    def runAskYesNoCancelDialog(self,c,title,
        message=None,
        yesMessage="&amp;Yes",noMessage="&amp;No",defaultButton="Yes"
    ):

        """Create and run an askYesNo dialog."""

        if g.unitTesting: return None

        b = QtGui.QMessageBox

        d = b(c.frame.top)
        if message: d.setText(message)
        d.setIcon(b.Warning)
        d.setWindowTitle(title)
        yes    = d.addButton(yesMessage,b.YesRole)
        no     = d.addButton(noMessage,b.NoRole)
        cancel = d.addButton(b.Cancel)
        if   defaultButton == "Yes": d.setDefaultButton(yes)
        elif defaultButton == "No": d.setDefaultButton(no)
        else: d.setDefaultButton(cancel)
        val = d.exec_()

        if   val == 0: val = 'yes'
        elif val == 1: val = 'no'
        else:          val = 'cancel'
        return val
    #@-node:ekr.20081121105001.486:runAskYesNoCancelDialog
    #@+node:ekr.20081121105001.487:runAskYesNoDialog
    def runAskYesNoDialog(self,c,title,message=None):

        """Create and run an askYesNo dialog."""

        if g.unitTesting: return None

        b = QtGui.QMessageBox
        d = b(c.frame.top)

        d.setWindowTitle(title)
        if message: d.setText(message)
        d.setIcon(b.Information)
        yes = d.addButton('&amp;Yes',b.YesRole)
        no  = d.addButton('&amp;No',b.NoRole)
        d.setDefaultButton(yes)
        val = d.exec_()
        return g.choose(val == 0,'yes','no')

    #@-node:ekr.20081121105001.487:runAskYesNoDialog
    #@+node:ekr.20081121105001.488:runOpenFileDialog
    def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

        """Create and run an Qt open file dialog ."""

        parent = None
        filter = self.makeFilter(filetypes)
        s = QtGui.QFileDialog.getOpenFileName(parent,title,os.curdir,filter)
        s = g.app.gui.toUnicode(s)
        if multiple:
            return [s]
        else:
            return s
    #@nonl
    #@-node:ekr.20081121105001.488:runOpenFileDialog
    #@+node:ekr.20081121105001.489:runSaveFileDialog
    def runSaveFileDialog(self,initialfile='',title='Save',filetypes=[],defaultextension=''):

        """Create and run an Qt save file dialog ."""

        parent = None
        filter_ = self.makeFilter(filetypes)
        s = QtGui.QFileDialog.getSaveFileName(parent,title,os.curdir,filter_)
        return g.app.gui.toUnicode(s)
    #@-node:ekr.20081121105001.489:runSaveFileDialog
    #@+node:ekr.20081121105001.490:runScrolledMessageDialog
    def runScrolledMessageDialog (self, title='Message', label= '', msg='', c=None, **kw):

        if g.unitTesting: return None

        def send(title=title, label=label, msg=msg, c=c, kw=kw):
            return g.doHook('scrolledMessage', title=title, label=label, msg=msg, c=c, **kw)

        if not c or not c.exists:
            #@        &lt;&lt; no c error&gt;&gt;
            #@+node:leohag.20081205043707.12:&lt;&lt; no c error&gt;&gt;
            g.es_print_error('%s\n%s\n\t%s' % (
                "The qt plugin requires calls to g.app.gui.scrolledMessageDialog to include 'c'",
                "as a keyword argument",
                g.callers()
            ))
            #@nonl
            #@-node:leohag.20081205043707.12:&lt;&lt; no c error&gt;&gt;
            #@nl
        else:        
            retval = send()
            if retval: return retval
            #@        &lt;&lt; load scrolledmessage plugin &gt;&gt;
            #@+node:leohag.20081205043707.14:&lt;&lt; load scrolledmessage plugin &gt;&gt;
            import leo.core.leoPlugins as leoPlugins
            sm = leoPlugins.getPluginModule('scrolledmessage')

            if not sm:
                sm = leoPlugins.loadOnePlugin('scrolledmessage',verbose=True)
                if sm:
                    g.es('scrolledmessage plugin loaded.', color='blue')
                    sm.onCreate('tag',{'c':c})
            #@-node:leohag.20081205043707.14:&lt;&lt; load scrolledmessage plugin &gt;&gt;
            #@nl
            retval = send()
            if retval: return retval
            #@        &lt;&lt; no dialog error &gt;&gt;
            #@+node:leohag.20081205043707.11:&lt;&lt; no dialog error &gt;&gt;
            g.es_print_error('The handler for the "scrolledMessage" hook appears to be missing or not working.\n\t%s'%g.callers())
            #@nonl
            #@-node:leohag.20081205043707.11:&lt;&lt; no dialog error &gt;&gt;
            #@nl

        #@    &lt;&lt; emergency fallback &gt;&gt;
        #@+node:leohag.20081205043707.13:&lt;&lt; emergency fallback &gt;&gt;

        b = QtGui.QMessageBox
        d = b(None) # c.frame.top)
        d.setWindowFlags(QtCore.Qt.Dialog) # That is, not a fixed size dialog.

        d.setWindowTitle(title)
        if msg: d.setText(msg)
        d.setIcon(b.Information)
        yes = d.addButton('Ok',b.YesRole)
        d.exec_()
        #@nonl
        #@-node:leohag.20081205043707.13:&lt;&lt; emergency fallback &gt;&gt;
        #@nl
    #@-node:ekr.20081121105001.490:runScrolledMessageDialog
    #@-node:ekr.20081121105001.479:Dialogs &amp; panels
    #@+node:ekr.20081121105001.491:Focus (qtGui)
    def get_focus(self,c=None):

        """Returns the widget that has focus."""

        w = QtGui.QApplication.focusWidget()
        # g.trace('leoQtGui',w)
        return w

    def set_focus(self,c,w):

        """Put the focus on the widget."""

        if w:
            # g.trace('leoQtGui',w,g.callers(4))
            w.setFocus()
    #@-node:ekr.20081121105001.491:Focus (qtGui)
    #@+node:ekr.20081121105001.492:Font
    #@+node:ekr.20081121105001.493:qtGui.getFontFromParams
    def getFontFromParams(self,family,size,slant,weight,defaultSize=12):

        try: size = int(size)
        except Exception: size = 0
        if size &lt; 1: size = defaultSize

        d = {
            'black':QtGui.QFont.Black,
            'bold':QtGui.QFont.Bold,
            'demibold':QtGui.QFont.DemiBold,
            'light':QtGui.QFont.Light,
            'normal':QtGui.QFont.Normal,
        }
        weight_val = d.get(weight.lower(),QtGui.QFont.Normal)
        italic = slant == 'italic'

        try:
            font = QtGui.QFont(family,size,weight_val,italic)
            # g.trace(family,size,slant,weight,'returns',font)
            return font
        except:
            g.es("exception setting font",g.callers(4))
            g.es("","family,size,slant,weight:","",family,"",size,"",slant,"",weight)
            # g.es_exception() # This just confuses people.
            return g.app.config.defaultFont
    #@-node:ekr.20081121105001.493:qtGui.getFontFromParams
    #@-node:ekr.20081121105001.492:Font
    #@+node:ekr.20081121105001.494:getFullVersion
    def getFullVersion (self,c):

        try:
            qtLevel = 'version %s' % QtCore.QT_VERSION
        except Exception:
            # g.es_exception()
            qtLevel = '&lt;qtLevel&gt;'

        return 'qt %s' % (qtLevel)
    #@-node:ekr.20081121105001.494:getFullVersion
    #@+node:ekr.20081121105001.495:Icons
    #@+node:ekr.20081121105001.496:attachLeoIcon
    def attachLeoIcon (self,window):

        """Attach a Leo icon to the window."""

        icon = self.getIconImage('leoApp.ico')

        window.setWindowIcon(icon)
    #@-node:ekr.20081121105001.496:attachLeoIcon
    #@+node:ekr.20081121105001.497:getIconImage
    def getIconImage (self,name):

        '''Load the icon and return it.'''

        # Return the image from the cache if possible.
        if name in self.iconimages:
            return self.iconimages.get(name)
        try:
            fullname = g.os_path_finalize_join(g.app.loadDir,"..","Icons",name)

            if 0: # Not needed: use QTreeWidget.setIconsize.
                pixmap = QtGui.QPixmap()
                pixmap.load(fullname)
                image = QtGui.QIcon(pixmap)
            else:
                image = QtGui.QIcon(fullname)

            self.iconimages[name] = image
            return image

        except Exception:
            g.es("exception loading:",fullname)
            g.es_exception()
            return None
    #@-node:ekr.20081121105001.497:getIconImage
    #@+node:tbrown.20081229204443.10:getImageImage
    def getImageImage (self,name):

        '''Load the image and return it.'''

        try:
            fullname = g.os_path_finalize_join(g.app.loadDir,"..","Icons",name)

            pixmap = QtGui.QPixmap()
            pixmap.load(fullname)

            return pixmap

        except Exception:
            g.es("exception loading:",fullname)
            g.es_exception()
            return None
    #@-node:tbrown.20081229204443.10:getImageImage
    #@+node:ekr.20081123003126.2:getTreeImage (test)
    def getTreeImage (self,c,path):

        image = QtGui.QPixmap(path)

        if image.height() &gt; 0 and image.width() &gt; 0:
            return image,image.height()
        else:
            return None,None
    #@-node:ekr.20081123003126.2:getTreeImage (test)
    #@-node:ekr.20081121105001.495:Icons
    #@+node:ekr.20081121105001.498:Idle Time (to do)
    #@+node:ekr.20081121105001.499:qtGui.setIdleTimeHook
    def setIdleTimeHook (self,idleTimeHookHandler):

        # if self.root:
            # self.root.after_idle(idleTimeHookHandler)

        pass
    #@nonl
    #@-node:ekr.20081121105001.499:qtGui.setIdleTimeHook
    #@+node:ekr.20081121105001.500:setIdleTimeHookAfterDelay
    def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):

        pass

        # if self.root:
            # g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)
    #@-node:ekr.20081121105001.500:setIdleTimeHookAfterDelay
    #@-node:ekr.20081121105001.498:Idle Time (to do)
    #@+node:ekr.20081121105001.501:isTextWidget
    def isTextWidget (self,w):

        '''Return True if w is a Text widget suitable for text-oriented commands.'''

        if not w: return False

        return (
            isinstance(w,leoFrame.baseTextWidget) or
            isinstance(w,leoQtBody) or
            isinstance(w,leoQtBaseTextWidget)
        )

    #@-node:ekr.20081121105001.501:isTextWidget
    #@+node:ekr.20081121105001.502:toUnicode (qtGui)
    def toUnicode (self,s,encoding='utf-8',reportErrors=True):

        if g.isPython3:
            return str(s)
        else:
            if type(s) == type(u'a'):
                return s
            else:
                return g.toUnicode(
                    s,encoding=encoding,reportErrors=reportErrors)
    #@nonl
    #@-node:ekr.20081121105001.502:toUnicode (qtGui)
    #@+node:ekr.20081121105001.503:widget_name (qtGui)
    def widget_name (self,w):

        # First try the widget's getName method.
        if not 'w':
            name = '&lt;no widget&gt;'
        elif hasattr(w,'getName'):
            name = w.getName()
        elif hasattr(w,'objectName'):
            name = str(w.objectName())
            # if name == 'treeWidget':
                # name = 'canvas(treeWidget)'
        elif hasattr(w,'_name'):
            name = w._name
        else:
            name = repr(w)

        # g.trace(name,w,g.callers(4))
        return name
    #@-node:ekr.20081121105001.503:widget_name (qtGui)
    #@+node:ekr.20081121105001.504:makeScriptButton (to do)
    def makeScriptButton (self,c,
        args=None,
        p=None, # A node containing the script.
        script=None, # The script itself.
        buttonText=None,
        balloonText='Script Button',
        shortcut=None,bg='LightSteelBlue1',
        define_g=True,define_name='__main__',silent=False, # Passed on to c.executeScript.
    ):

        '''Create a script button for the script in node p.
        The button's text defaults to p.headString'''

        k = c.k
        if p and not buttonText: buttonText = p.headString().strip()
        if not buttonText: buttonText = 'Unnamed Script Button'
        #@    &lt;&lt; create the button b &gt;&gt;
        #@+node:ekr.20081121105001.505:&lt;&lt; create the button b &gt;&gt;
        iconBar = c.frame.getIconBarObject()
        b = iconBar.add(text=buttonText)
        #@-node:ekr.20081121105001.505:&lt;&lt; create the button b &gt;&gt;
        #@nl
        #@    &lt;&lt; define the callbacks for b &gt;&gt;
        #@+node:ekr.20081121105001.506:&lt;&lt; define the callbacks for b &gt;&gt;
        def deleteButtonCallback(event=None,b=b,c=c):
            if b: b.pack_forget()
            c.bodyWantsFocus()

        def executeScriptCallback (event=None,
            b=b,c=c,buttonText=buttonText,p=p and p.copy(),script=script):

            if c.disableCommandsMessage:
                g.es('',c.disableCommandsMessage,color='blue')
            else:
                g.app.scriptDict = {}
                c.executeScript(args=args,p=p,script=script,
                define_g= define_g,define_name=define_name,silent=silent)
                # Remove the button if the script asks to be removed.
                if g.app.scriptDict.get('removeMe'):
                    g.es("removing","'%s'" % (buttonText),"button at its request")
                    b.pack_forget()
            # Do not assume the script will want to remain in this commander.
        #@-node:ekr.20081121105001.506:&lt;&lt; define the callbacks for b &gt;&gt;
        #@nl
        b.configure(command=executeScriptCallback)
        c.bind(b,'&lt;3&gt;',deleteButtonCallback)
        if shortcut:
            #@        &lt;&lt; bind the shortcut to executeScriptCallback &gt;&gt;
            #@+node:ekr.20081121105001.507:&lt;&lt; bind the shortcut to executeScriptCallback &gt;&gt;
            func = executeScriptCallback
            shortcut = k.canonicalizeShortcut(shortcut)
            ok = k.bindKey ('button', shortcut,func,buttonText)
            if ok:
                g.es_print('bound @button',buttonText,'to',shortcut,color='blue')
            #@-node:ekr.20081121105001.507:&lt;&lt; bind the shortcut to executeScriptCallback &gt;&gt;
            #@nl
        #@    &lt;&lt; create press-buttonText-button command &gt;&gt;
        #@+node:ekr.20081121105001.508:&lt;&lt; create press-buttonText-button command &gt;&gt;
        aList = [g.choose(ch.isalnum(),ch,'-') for ch in buttonText]

        buttonCommandName = ''.join(aList)
        buttonCommandName = buttonCommandName.replace('--','-')
        buttonCommandName = 'press-%s-button' % buttonCommandName.lower()

        # This will use any shortcut defined in an @shortcuts node.
        k.registerCommand(buttonCommandName,None,executeScriptCallback,pane='button',verbose=False)
        #@-node:ekr.20081121105001.508:&lt;&lt; create press-buttonText-button command &gt;&gt;
        #@nl
    #@-node:ekr.20081121105001.504:makeScriptButton (to do)
    #@-others
#@-node:ekr.20081121105001.472:class leoQtGui
#@-node:ekr.20081121105001.471:Gui wrapper
#@+node:ekr.20081121105001.509:Non-essential
#@+node:ekr.20081121105001.510:class LeoQuickSearchWidget
import qt_quicksearch

def install_qt_quicksearch_tab(c):
    #tabw = c.frame.top.tabWidget

    wdg = LeoQuickSearchWidget(c)
    c.frame.log.createTab('QuickSearch', widget = wdg)
    #tabw.addTab(wdg, "QuickSearch")

g.insqs = install_qt_quicksearch_tab

class LeoQuickSearchWidget(QtGui.QWidget):
    """ Real-time search widget """
    #@    @+others
    #@+node:ekr.20081121105001.511:methods
    def __init__(self, c, parent = None):
        QtGui.QWidget.__init__(self, parent)
        self.ui = qt_quicksearch.Ui_LeoQuickSearchWidget()
        self.ui.setupUi(self)

        #self.connect(self.ui.lineEdit,
        #            QtCore.SIGNAL("textChanged(const QString&amp;)"),
        #              self.textChanged)
        self.connect(self.ui.tableWidget,
                    QtCore.SIGNAL("cellClicked(int, int)"),
                      self.cellClicked)
        self.connect(self.ui.lineEdit,
                    QtCore.SIGNAL("returnPressed()"),
                      self.returnPressed)


        self.c = c                  
        self.ps = {} # item=&gt; pos

    def update_matches(self, matches):
        self.ui.tableWidget.clear()
        matches = list(matches)
        self.ui.tableWidget.setRowCount(len(matches))
        for idx,p in enumerate(matches):
            s = p.headString()
            it = QtGui.QTableWidgetItem('test')
            it.setText(QtCore.QString(s))
            g.trace("Match",s)
            self.ps[idx] = p.copy(), it
            self.ui.tableWidget.setItem(idx, 0, it)
            idx+=1



    def returnPressed(self):
        m = self.match_any(unicode(self.ui.lineEdit.text()))
        self.update_matches(m)


    def textChanged(self):
        g.trace("New text", self.ui.lineEdit.text())
        m = self.match_headlines(unicode(self.ui.lineEdit.text()))
        self.update_matches(m)

    def cellClicked (self, row, column ) :
        p = self.ps[row][0]
        g.trace("Go to pos",p)
        self.c.selectPosition(p)

    def match_headlines(self, pat):
        c = self.c
        pat = pat.lower()
        for p in c.allNodes_iter():
            if pat in p.headString():
                yield p
        return 

    def match_any(self, pat):
        c = self.c
        pat = pat.lower()
        for p in c.allNodes_iter():
            if pat in p.headString():
                yield p.copy()
            elif pat in p.bodyString():
                yield p.copy()
        return 

    #@-node:ekr.20081121105001.511:methods
    #@-others
#@-node:ekr.20081121105001.510:class LeoQuickSearchWidget
#@+node:ekr.20081121105001.512:quickheadlines
def install_qt_quickheadlines_tab(c):
    global __qh
    __qh = QuickHeadlines(c)

g.insqh = install_qt_quickheadlines_tab

class QuickHeadlines:
    def __init__(self, c):
        self.c = c
        tabw = c.frame.top.tabWidget
        self.listWidget = QtGui.QListWidget(tabw)
        tabw.addTab(self.listWidget, "Headlines")
        c.frame.top.connect(c.frame.top.treeWidget,
          QtCore.SIGNAL("itemSelectionChanged()"), self.req_update)
        self.requested = False
    def req_update(self):
        """ prevent too frequent updates (only one/100 msec) """
        if self.requested:
            return
        QtCore.QTimer.singleShot(100, self.update)
        self.requested = True

    def update(self):

        g.trace("quickheadlines update")
        self.requested = False
        self.listWidget.clear()
        p = self.c.currentPosition()
        for n in p.children_iter():
            self.listWidget.addItem(n.headString())



#@-node:ekr.20081121105001.512:quickheadlines
#@-node:ekr.20081121105001.509:Non-essential
#@+node:ekr.20081121105001.513:Key handling
#@+node:ekr.20081121105001.514:class leoKeyEvent
class leoKeyEvent:

    '''A wrapper for wrapper for qt events.

    This does *not* override leoGui.leoKeyevent because
    it is a separate class, not member of leoQtGui.'''

    def __init__ (self,event,c,w,ch,tkKey,stroke):

        # g.trace('ch: %s, tkKey: %s' % (repr(ch),repr(tkKey)))

        # Last minute-munges to keysym.
        if tkKey in ('Return','Tab','Escape'):
            ch = tkKey

        # The main ivars.
        self.actualEvent = event
        self.c      = c
        self.char   = ch
        self.keysym = ch
        self.stroke = stroke
        self.w = self.widget = w # A leoQtX object

        # Auxiliary info.
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0
        # Support for fastGotoNode plugin
        self.x_root = hasattr(event,'x_root') and event.x_root or 0
        self.y_root = hasattr(event,'y_root') and event.y_root or 0

        # g.trace('qt.leoKeyEvent: %s' % repr(self))

    def __repr__ (self):

        return 'qtGui.leoKeyEvent: stroke: %s' % (repr(self.stroke))

        # return 'qtGui.leoKeyEvent: stroke: %s, char: %s, keysym: %s' % (
            # repr(self.stroke),repr(self.char),repr(self.keysym))
#@-node:ekr.20081121105001.514:class leoKeyEvent
#@+node:ekr.20081121105001.166:class leoQtEventFilter
class leoQtEventFilter(QtCore.QObject):

    #@    &lt;&lt; about internal bindings &gt;&gt;
    #@+node:ekr.20081121105001.167:&lt;&lt; about internal bindings &gt;&gt;
    #@@nocolor-node
    #@+at
    # 
    # Here are the rules for translating key bindings (in leoSettings.leo) 
    # into keys for k.bindingsDict:
    # 
    # 1.  The case of plain letters is significant:  a is not A.
    # 
    # 2. The Shift- prefix can be applied *only* to letters. Leo will ignore 
    # (with a
    # warning) the shift prefix applied to any other binding, e.g., 
    # Ctrl-Shift-(
    # 
    # 3. The case of letters prefixed by Ctrl-, Alt-, Key- or Shift- is *not*
    # significant. Thus, the Shift- prefix is required if you want an 
    # upper-case
    # letter (with the exception of 'bare' uppercase letters.)
    # 
    # The following table illustrates these rules. In each row, the first 
    # entry is the
    # key (for k.bindingsDict) and the other entries are equivalents that the 
    # user may
    # specify in leoSettings.leo:
    # 
    # a, Key-a, Key-A
    # A, Shift-A
    # Alt-a, Alt-A
    # Alt-A, Alt-Shift-a, Alt-Shift-A
    # Ctrl-a, Ctrl-A
    # Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
    # !, Key-!,Key-exclam,exclam
    # 
    # This table is consistent with how Leo already works (because it is 
    # consistent
    # with Tk's key-event specifiers). It is also, I think, the least 
    # confusing set of
    # rules.
    #@-at
    #@nonl
    #@-node:ekr.20081121105001.167:&lt;&lt; about internal bindings &gt;&gt;
    #@nl

    #@    @+others
    #@+node:ekr.20081121105001.180: ctor
    def __init__(self,c,w,tag=''):

        # Init the base class.
        QtCore.QObject.__init__(self)

        self.c = c
        self.w = w      # A leoQtX object, *not* a Qt object.
        self.tag = tag

        # Pretend there is a binding for these characters.
        close_flashers = c.config.getString('close_flash_brackets') or ''
        open_flashers  = c.config.getString('open_flash_brackets') or ''
        self.flashers = open_flashers + close_flashers


    #@-node:ekr.20081121105001.180: ctor
    #@+node:ekr.20081121105001.168:eventFilter
    def eventFilter(self, obj, event):

        trace = False ; verbose = False
        traceFocus = False and not g.unitTesting
        c = self.c ; k = c.k
        eventType = event.type()
        ev = QtCore.QEvent
        kinds = [ev.ShortcutOverride,ev.KeyPress,ev.KeyRelease]
        if traceFocus:
            table = (
                (ev.FocusIn,        'focus-in '),
                (ev.FocusOut,       'focus-out'),
                (ev.WindowActivate, 'activate '))
            for evKind,kind in table:
                if eventType == evKind:
                    g.trace('%s %s %s' % (
                        (kind,id(obj),
                        # event.reason(),
                        g.app.gui.widget_name(obj) or obj)))
            # else: g.trace('unknown kind: %s' % eventType)

        if eventType == ev.WindowActivate:
            g.app.gui.onActivateEvent(event,c,obj,self.tag)
            override = False ; tkKey = None
            # g.trace(g.app.gui.get_focus(c))
        elif eventType in kinds:
            tkKey,ch,ignore = self.toTkKey(event)
            aList = c.k.masterGuiBindingsDict.get('&lt;%s&gt;' %tkKey,[])
            if ignore:
                override = False
            elif self.isSpecialOverride(tkKey,ch):
                override = True
            elif k.inState():
                override = not ignore # allow all keystrokes.
            # elif safe_mode:
                # override = len(aList) &gt; 0 and not self.isDangerous(tkKey,ch)
            else:
                override = len(aList) &gt; 0
        else:
            override = False ; tkKey = '&lt;no key&gt;'

        # A hack. QLineEdit generates ev.KeyRelease only.
        if eventType in (ev.KeyPress,ev.KeyRelease):
            p = c.currentPosition()
            isEditWidget = obj == c.frame.tree.edit_widget(p)
            keyIsActive = g.choose(
                isEditWidget,
                eventType == ev.KeyRelease,
                eventType == ev.KeyPress)
        else:
            keyIsActive = False

        if keyIsActive:
            if override:
                w = self.w # Pass the wrapper class, not the wrapped widget.
                stroke = self.toStroke(tkKey,ch)
                leoEvent = leoKeyEvent(event,c,w,ch,tkKey,stroke)
                ret = k.masterKeyHandler(leoEvent,stroke=stroke)
                c.outerUpdate()
            else:
                if True or trace and verbose:
                    stroke = self.toStroke(tkKey,ch)
                    if (stroke and not stroke.startswith('Alt+') and 
                        not stroke.startswith('Ctrl+')):
                            g.trace(self.tag,'unbound',tkKey,stroke)

        if trace: self.traceEvent(obj,event,tkKey,override)

        return override
    #@-node:ekr.20081121105001.168:eventFilter
    #@+node:ekr.20081121105001.181:isDangerous
    def isDangerous (self,tkKey,ch):

        c = self.c

        if not c.frame.body.useScintilla: return False

        arrows = ('home','end','left','right','up','down')
        special = ('tab','backspace','period','parenright','parenleft')

        key = tkKey.lower()
        ch = ch.lower()
        isAlt = key.find('alt') &gt; -1
        w = g.app.gui.get_focus()
        inTree = w == self.c.frame.tree.treeWidget

        val = (
            key in special or
            ch in arrows and not inTree and not isAlt or
            key == 'return' and not inTree # Just barely works.
        )

        # g.trace(tkKey,ch,val)
        return val
    #@-node:ekr.20081121105001.181:isDangerous
    #@+node:ekr.20081121105001.182:isSpecialOverride
    def isSpecialOverride (self,tkKey,ch):

        # g.trace(repr(tkKey),repr(ch))
        c = self.c
        d = c.k.guiBindNamesDict

        table = [d.get(key) for key in d]
        table.append('Tab')

        if tkKey in table:
            return True
        elif len(tkKey) == 1:
            return True # Must process all ascii keys.
        elif ch in self.flashers:
            return True
        else:
            return False
    #@-node:ekr.20081121105001.182:isSpecialOverride
    #@+node:ekr.20081121105001.169:toStroke
    def toStroke (self,tkKey,ch):

        trace = False
        k = self.c.k ; s = tkKey

        special = ('Alt','Ctrl','Control',)
        isSpecial = [True for z in special if s.find(z) &gt; -1]

        if not isSpecial:
            # Keep the Tk spellings for special keys.
            ch2 = k.guiBindNamesDict.get(ch) # was inverseDict
            if trace: g.trace('ch',repr(ch),'ch2',repr(ch2))
            if ch2: s = s.replace(ch,ch2)

        table = (
            ('Alt-','Alt+'),
            ('Ctrl-','Ctrl+'),
            ('Control-','Ctrl+'),
            # Use Alt+Key-1, etc.  Sheesh.
            # ('Key-','Key+'),
            ('Shift-','Shift+')
        )
        for a,b in table:
            s = s.replace(a,b)

        if trace: g.trace('tkKey',tkKey,'--&gt;',s)
        return s
    #@-node:ekr.20081121105001.169:toStroke
    #@+node:ekr.20081121105001.170:toTkKey
    def toTkKey (self,event):

        mods = self.qtMods(event)

        keynum,text,toString,ch = self.qtKey(event)

        tkKey,ch,ignore = self.tkKey(
            event,mods,keynum,text,toString,ch)

        return tkKey,ch,ignore
    #@+node:ekr.20081121105001.171:isFKey
    def isFKey(self,ch):

        return (
            ch and len(ch) in (2,3) and
            ch[0].lower() == 'f' and
            ch[1:].isdigit()
        )
    #@-node:ekr.20081121105001.171:isFKey
    #@+node:ekr.20081121105001.172:qtKey
    def qtKey (self,event):

        '''Return the components of a Qt key event.'''

        keynum = event.key()
        text   = event.text()
        toString = QtGui.QKeySequence(keynum).toString()
        try:
            ch = chr(keynum)
        except ValueError:
            ch = ''
        ch       = g.app.gui.toUnicode(ch)
        text     = g.app.gui.toUnicode(text)
        toString = g.app.gui.toUnicode(toString)

        return keynum,text,toString,ch


    #@-node:ekr.20081121105001.172:qtKey
    #@+node:ekr.20081121105001.173:qtMods
    def qtMods (self,event):

        modifiers = event.modifiers()

        # The order of this table is significant.
        # It must the order of modifiers in bindings
        # in k.masterGuiBindingsDict

        table = (
            (QtCore.Qt.AltModifier,     'Alt'),
            (QtCore.Qt.ControlModifier, 'Control'),
            (QtCore.Qt.MetaModifier,    'Meta'),
            (QtCore.Qt.ShiftModifier,   'Shift'),
        )

        mods = [b for a,b in table if (modifiers &amp; a)]

        return mods
    #@-node:ekr.20081121105001.173:qtMods
    #@+node:ekr.20081121105001.174:tkKey &amp; helpers
    def tkKey (self,event,mods,keynum,text,toString,ch):

        '''Carefully convert the Qt key to a 
        Tk-style binding compatible with Leo's core
        binding dictionaries.'''

        trace = False ; verbose = True
        k = self.c.k

        # Thanks to Jesse Aldridge for additional entries.
        special = {
           'Backspace': 'BackSpace',
           'Esc':       'Escape',
           'Del':       'Delete',
           'Ins':       'Insert',
           'PgDown':    'PgDn',
           'PgUp':      'PgUp', # The entry must exist.
        }

        # Convert '&amp;' to 'ampersand', for example.
        ch2 = k.guiBindNamesDict.get(ch or toString)

        if not ch: ch = ch2
        if not ch: ch = ''

        # Handle special cases.
        ch3 = special.get(toString)
        if ch3: ch = ch3

        ch4 = k.guiBindNamesDict.get(ch)
        if ch4: ch = ch4

        if trace and verbose: g.trace(
    'keynum: %s, mods: %s text: %s, toString: %s, '
    'ch: %s, ch2: %s, ch3: %s, ch4: %s' % (
    keynum,mods,repr(text),toString,
    repr(ch),repr(ch2),repr(ch3),repr(ch4)))

        if 'Shift' in mods:
            mods,ch = self.shifted(mods,ch)
        elif len(ch) == 1:
            ch = ch.lower()

        if ('Alt' in mods or 'Control' in mods) and ch and ch in string.digits:
            mods.append('Key')

        tkKey = '%s%s%s' % ('-'.join(mods),mods and '-' or '',ch)
        ignore = not ch

        if trace and (ignore or verbose):
            g.trace('tkKey: %s, ch: %s, ignore: %s' % (
                repr(tkKey),repr(ch),ignore))

        ch = text or toString # was ch
        return tkKey,ch,ignore
    #@+node:ekr.20081121105001.175:keyboardUpper1
    def keyboardUpper1 (self,ch):

        '''A horrible, keyboard-dependent hack.

        Return the upper-case version of the given character
        whose original spelling has length == 1.'''

        d = {
            '1':'exclam',
            '2':'at',
            '3':'numbersign',
            '4':'dollar',
            '5':'percent',
            '6':'asciicircum',
            '7':'ampersand',
            '8':'asterisk',
            '9':'parenleft',
            '0':'parenright',
        }

        # g.trace(ch,d.get(ch))
        return d.get(ch)

    #@-node:ekr.20081121105001.175:keyboardUpper1
    #@+node:ekr.20081121105001.176:keyboardUpperLong
    def keyboardUpperLong (self,ch):

        '''A horrible, keyboard-dependent hack.

        Return the upper-case version of the given character
        whose original spelling has length &gt; 1.'''

        d = {
            '1':'exclam',
            '2':'at',
            '3':'numbersign',
            '4':'dollar',
            '5':'percent',
            '6':'asciicircum',
            '7':'ampersand',
            '8':'asterisk',
            '9':'parenleft',
            '0':'parenright',
            "quoteleft":    "asciitilde",
            "minus":        "underscore",
            "equal":        "plus",
            "bracketleft":  "braceleft",
            "bracketright": "braceright",
            "semicolon":    "colon",
            "quoteright":   "quotedbl",
            "backslash":    "bar",
            "comma":        "less",
            "period":       "greater",
            "slash":        "question",
            "parenleft":    "parenleft", # Bug fix: 2008/11/24
            "parenright":   "parenright", # Bug fix: 2008/11/24
        }
        # g.trace(ch,d.get(ch))
        return d.get(ch)
    #@-node:ekr.20081121105001.176:keyboardUpperLong
    #@+node:ekr.20081121105001.177:shifted
    def shifted (self,mods,ch):
        '''
            A horrible, keyboard-dependent kludge.
            return the shifted version of the letter.
            return mods, ch.
        '''

        # Special tk symbols, like '&amp;' have already
        # been converted to names like 'ampersand'.

        # These special characters should be handled in Leo's core.
        noShiftList = ('Return','BackSpace','Tab',)

        special = ('Home','End','Right','Left','Up','Down',)

        if len(ch) == 1:
            ch2 = self.keyboardUpper1(ch)
            if ch2:
                mods.remove('Shift')
                ch = ch2
            elif len(ch) == 1:
                # Correct regardless of alt/ctrl mods.
                mods.remove('Shift')
                ch = ch.upper()
            elif len(mods) == 1: # No alt/ctrl.
                mods.remove('Shift')
            else:
                pass
            # g.trace('ch',ch,'ch2',ch2,mods)
        else:
            ch3 = self.keyboardUpperLong(ch)
            if ch3: ch = ch3

            if ch3 or ch in noShiftList:
                mods.remove('Shift')
            elif ch in special:
                pass # Allow the shift.
            elif len(mods) == 1: # No alt/ctrl.
                mods.remove('Shift')
            else:
                pass # Retain shift modifier for all special keys.

        return mods,ch
    #@-node:ekr.20081121105001.177:shifted
    #@-node:ekr.20081121105001.174:tkKey &amp; helpers
    #@-node:ekr.20081121105001.170:toTkKey
    #@+node:ekr.20081121105001.179:traceEvent
    def traceEvent (self,obj,event,tkKey,override):

        c = self.c ; e = QtCore.QEvent

        eventType = event.type()

        if 0: # Show focus events.
            show = (
                (e.FocusIn,'focus-in'),(e.FocusOut,'focus-out'),
                (e.Enter,'enter'),(e.Leave,'leave'),
            )

        else:
            show = (
                (e.KeyPress,'key-press'),(e.KeyRelease,'key-release'),
                (e.ShortcutOverride,'shortcut-override'),
            )

        ignore = (
            e.ToolTip,
            e.FocusIn,e.FocusOut,e.Enter,e.Leave,
            e.MetaCall,e.Move,e.Paint,e.Resize,
            e.Polish,e.PolishRequest,
        )

        for val,kind in show:
            if eventType == val:
                if override:
                    g.trace(
                        'tag: %s, kind: %s, in-state: %s, key: %s, override: %s' % (
                        self.tag,kind,repr(c.k.inState()),tkKey,override))
                return

        # if trace: g.trace(self.tag,
            # 'bound in state: %s, key: %s, returns: %s' % (
            # k.getState(),tkKey,ret))

        if False and eventType not in ignore:
            g.trace('%3s:%s' % (eventType,'unknown'))
    #@-node:ekr.20081121105001.179:traceEvent
    #@-others
#@-node:ekr.20081121105001.166:class leoQtEventFilter
#@-node:ekr.20081121105001.513:Key handling
#@+node:ekr.20081204090029.1:Syntax coloring
#@+node:ekr.20081205131308.15:leoQtColorizer
# This is c.frame.body.colorizer

class leoQtColorizer:

    '''An adaptor class that interfaces Leo's core to two class:

    1. a subclass of QSyntaxHighlighter,

    2. the jEditColorizer class that contains the
       pattern-matchin code from the threading colorizer plugin.'''

    #@    @+others
    #@+node:ekr.20081205131308.16:ctor (leoQtColorizer)
    def __init__ (self,c,w):

        self.c = c
        self.w = w

        # g.pr('leoQtColorizer.__init__',c,w,g.callers(4))

        self.count = 0 # For unit testing.
        self.enabled = True
        self.error = False # Set if there is an error in jeditColorizer.recolor

        self.highlighter = leoQtSyntaxHighlighter(c,w,colorizer=self)
        self.colorer = self.highlighter.colorer

        if self.colorer.enabled:
            self.colorer.enabled = hasattr(self.highlighter,'currentBlock')

    #@-node:ekr.20081205131308.16:ctor (leoQtColorizer)
    #@+node:ekr.20081205131308.18:colorize (leoQtColorizer)
    def colorize(self,p,incremental=False,interruptable=True):

        '''The main colorizer entry point.'''

        trace = False and not g.unitTesting

        self.count += 1 # For unit testing.

        if self.enabled:
            self.updateSyntaxColorer(p) # Sets self.flag.
            if incremental:
                pass
            else:
                self.highlighter.rehighlight(p)

            if trace: g.trace('***** incremental',incremental)

        return "ok" # For unit testing.
    #@-node:ekr.20081205131308.18:colorize (leoQtColorizer)
    #@+node:ekr.20081207061047.10:entry points
    def disable (self):
        self.colorer.enabled=False

    def enable (self):
        self.colorer.enabled=True

    def interrupt(self):
        pass

    def isSameColorState (self):
        return False

    def kill (self):
        pass

    def scanColorDirectives(self,p):
        return self.colorer.scanColorDirectives(p)

    def updateSyntaxColorer (self,p):
        return self.colorer.updateSyntaxColorer(p)

    def useSyntaxColoring (self,p):
        return self.colorer.useSyntaxColoring(p)
    #@-node:ekr.20081207061047.10:entry points
    #@-others

#@-node:ekr.20081205131308.15:leoQtColorizer
#@+node:ekr.20081205131308.27:leoQtSyntaxHighlighter
# This is c.frame.body.colorizer.highlighter

class leoQtSyntaxHighlighter (QtGui.QSyntaxHighlighter):

    '''A subclass of QSyntaxHighlighter that overrides
    the highlightBlock and rehighlight methods.

    All actual syntax coloring is done in the jeditColorer class.'''

    #@    @+others
    #@+node:ekr.20081205131308.1:ctor (leoQtSyntaxHighlighter)
    def __init__ (self,c,w,colorizer):

        self.c = c
        self.w = w

        # g.pr('leoQtSyntaxHighlighter.__init__',c,w,g.callers(4))

        # Init the base class.
        QtGui.QSyntaxHighlighter.__init__(self,w)

        self.colorizer = colorizer

        self.colorer = jEditColorizer(
            c,
            colorizer=colorizer,
            highlighter=self,
            w=c.frame.body.bodyCtrl)
    #@-node:ekr.20081205131308.1:ctor (leoQtSyntaxHighlighter)
    #@+node:ekr.20081205131308.11:highlightBlock
    def highlightBlock (self,s):

        colorer = self.colorer
        s = unicode(s)
        colorer.recolor(s)
    #@-node:ekr.20081205131308.11:highlightBlock
    #@+node:ekr.20081206062411.15:rehighlight
    def rehighlight (self,p):

        '''Override base rehighlight method'''

        trace = False and not g.unitTesting

        if trace: g.trace('***',g.callers())

        s = unicode(self.w.toPlainText())
        self.colorer.init(p,s)

        # Call the base class method.
        QtGui.QSyntaxHighlighter.rehighlight(self)

    #@-node:ekr.20081206062411.15:rehighlight
    #@-others
#@-node:ekr.20081205131308.27:leoQtSyntaxHighlighter
#@+node:ekr.20081205131308.48:class jeditColorizer
# This is c.frame.body.colorizer.highlighter.colorer

class jEditColorizer:

    '''This class contains the pattern matching code
    from the threading_colorizer plugin, adapted for
    use with QSyntaxHighlighter.'''

    #@    @+others
    #@+node:ekr.20081205131308.49: Birth &amp; init
    #@+node:ekr.20081205131308.50:__init__ (jeditColorizer)
    def __init__(self,c,colorizer,highlighter,w):

        # Basic data...
        self.c = c
        self.colorizer = colorizer
        self.highlighter = highlighter # a QSyntaxHighlighter
        self.p = None
        self.w = w
        assert(w == self.c.frame.body.bodyCtrl)

        # Used by recolor and helpers...
        self.all_s = '' # The cached string to be colored.
        self.actualColorDict = {} # Used only by setTag.
        self.global_i,self.global_j = 0,0 # The global bounds of colorizing.
        self.global_offset = 0
        self.hyperCount = 0
        self.initFlag = False # True if recolor must reload self.all_s.
        self.defaultState = u'default-state:' # The name of the default state.
        self.minimalMatch = ''
        self.nextState = 1 # Dont use 0.
        self.stateDict = {} # Keys are state numbers, values state names.
        self.stateNameDict = {} # Keys are state names, values are state numbers.

        # Attributes dict ivars: defaults are as shown...
        self.default = 'null'
        self.digit_re = ''
        self.escape = ''
        self.highlight_digits = True
        self.ignore_case = True
        self.no_word_sep = ''
        # Config settings...
        self.comment_string = None # Set by scanColorDirectives on @comment
        self.showInvisibles = False # True: show "invisible" characters.
        self.underline_undefined = c.config.getBool("underline_undefined_section_names")
        self.use_hyperlinks = c.config.getBool("use_hyperlinks")
        self.enabled = c.config.getBool('use_syntax_coloring')
        # Debugging...
        self.count = 0 # For unit testing.
        self.allow_mark_prev = True # The new colorizer tolerates this nonsense :-)
        self.trace = False or c.config.getBool('trace_colorizer')
        self.trace_leo_matches = False
        self.trace_match_flag = False # (Useful) True: trace all matching methods.
        self.verbose = False
        # Profiling...
        self.recolorCount = 0 # Total calls to recolor
        self.stateCount = 0 # Total calls to setCurrentState
        self.totalChars = 0 # The total number of characters examined by recolor.
        self.totalStates = 0
        self.maxStateNumber = 0
        self.totalKeywordsCalls = 0
        self.totalLeoKeywordsCalls = 0
        # Mode data...
        self.comment_string = None # Can be set by @comment directive.
        self.defaultRulesList = []
        self.flag = True # True unless in range of @nocolor
        self.importedRulesets = {}
        self.language = 'python' # set by scanColorDirectives.
        self.prev = None # The previous token.
        self.fonts = {} # Keys are config names.  Values are actual fonts.
        self.keywords = {} # Keys are keywords, values are 0..5.
        self.modes = {} # Keys are languages, values are modes.
        self.mode = None # The mode object for the present language.
        self.modeBunch = None # A bunch fully describing a mode.
        self.modeStack = []
        self.rulesDict = {}
        # self.defineAndExtendForthWords()
        self.word_chars = {} # Inited by init_keywords().
        self.setFontFromConfig()
        self.tags = [
            "blank","comment","cwebName","docPart","keyword","leoKeyword",
            "latexModeBackground","latexModeKeyword",
            "latexBackground","latexKeyword",
            "link","name","nameBrackets","pp","string",
            "elide","bold","bolditalic","italic", # new for wiki styling.
            "tab",
            # Leo jEdit tags...
            '@color', '@nocolor', 'doc_part', 'section_ref',
            # jEdit tags.
            'bracketRange',
            'comment1','comment2','comment3','comment4',
            'function',
            'keyword1','keyword2','keyword3','keyword4',
            'label','literal1','literal2','literal3','literal4',
            'markup','operator',
        ]

        #@    &lt;&lt; define leoKeywordsDict &gt;&gt;
        #@+node:ekr.20081205131308.35:&lt;&lt; define leoKeywordsDict &gt;&gt;
        self.leoKeywordsDict = {}

        for key in g.globalDirectiveList:
            self.leoKeywordsDict [key] = 'leoKeyword'
        #@nonl
        #@-node:ekr.20081205131308.35:&lt;&lt; define leoKeywordsDict &gt;&gt;
        #@nl
        #@    &lt;&lt; define default_colors_dict &gt;&gt;
        #@+node:ekr.20081205131308.36:&lt;&lt; define default_colors_dict &gt;&gt;
        # These defaults are sure to exist.

        self.default_colors_dict = {
            # tag name       :(     option name,           default color),
            'comment'        :('comment_color',               'red'),
            'cwebName'       :('cweb_section_name_color',     'red'),
            'pp'             :('directive_color',             'blue'),
            'docPart'        :('doc_part_color',              'red'),
            'keyword'        :('keyword_color',               'blue'),
            'leoKeyword'     :('leo_keyword_color',           'blue'),
            'link'           :('section_name_color',          'red'),
            'nameBrackets'   :('section_name_brackets_color', 'blue'),
            'string'         :('string_color',                '#00aa00'), # Used by IDLE.
            'name'           :('undefined_section_name_color','red'),
            'latexBackground':('latex_background_color',      'white'),

            # Tags used by forth.
            'keyword5'       :('keyword5_color',              'blue'),
            'bracketRange'   :('bracket_range_color',         'orange'),
            # jEdit tags.

            'comment1'       :('comment1_color', 'red'),
            'comment2'       :('comment2_color', 'red'),
            'comment3'       :('comment3_color', 'red'),
            'comment4'       :('comment4_color', 'red'),
            'function'       :('function_color', 'black'),
            'keyword1'       :('keyword1_color', 'blue'),
            'keyword2'       :('keyword2_color', 'blue'),
            'keyword3'       :('keyword3_color', 'blue'),
            'keyword4'       :('keyword4_color', 'blue'),
            'label'          :('label_color',    'black'),
            'literal1'       :('literal1_color', '#00aa00'),
            'literal2'       :('literal2_color', '#00aa00'),
            'literal3'       :('literal3_color', '#00aa00'),
            'literal4'       :('literal4_color', '#00aa00'),
            'markup'         :('markup_color',   'red'),
            'null'           :('null_color',     'black'),
            'operator'       :('operator_color', 'black'),
            }
        #@-node:ekr.20081205131308.36:&lt;&lt; define default_colors_dict &gt;&gt;
        #@nl
        #@    &lt;&lt; define default_font_dict &gt;&gt;
        #@+node:ekr.20081205131308.37:&lt;&lt; define default_font_dict &gt;&gt;
        self.default_font_dict = {
            # tag name      : option name
            'comment'       :'comment_font',
            'cwebName'      :'cweb_section_name_font',
            'pp'            :'directive_font',
            'docPart'       :'doc_part_font',
            'keyword'       :'keyword_font',
            'leoKeyword'    :'leo_keyword_font',
            'link'          :'section_name_font',
            'nameBrackets'  :'section_name_brackets_font',
            'string'        :'string_font',
            'name'          :'undefined_section_name_font',
            'latexBackground':'latex_background_font',

            # Tags used by forth.
            'bracketRange'   :'bracketRange_font',
            'keyword5'       :'keyword5_font',

             # jEdit tags.
            'comment1'      :'comment1_font',
            'comment2'      :'comment2_font',
            'comment3'      :'comment3_font',
            'comment4'      :'comment4_font',
            'function'      :'function_font',
            'keyword1'      :'keyword1_font',
            'keyword2'      :'keyword2_font',
            'keyword3'      :'keyword3_font',
            'keyword4'      :'keyword4_font',
            'keyword5'      :'keyword5_font',
            'label'         :'label_font',
            'literal1'      :'literal1_font',
            'literal2'      :'literal2_font',
            'literal3'      :'literal3_font',
            'literal4'      :'literal4_font',
            'markup'        :'markup_font',
            # 'nocolor' This tag is used, but never generates code.
            'null'          :'null_font',
            'operator'      :'operator_font',
            }
        #@-node:ekr.20081205131308.37:&lt;&lt; define default_font_dict &gt;&gt;
        #@nl

        # New in Leo 4.6: configure tags only once here.
        # Some changes will be needed for multiple body editors.
        self.configure_tags() # Must do this every time to support multiple editors.
    #@-node:ekr.20081205131308.50:__init__ (jeditColorizer)
    #@+node:ekr.20081205131308.51:addImportedRules
    def addImportedRules (self,mode,rulesDict,rulesetName):

        '''Append any imported rules at the end of the rulesets specified in mode.importDict'''

        if self.importedRulesets.get(rulesetName):
            return
        else:
            self.importedRulesets [rulesetName] = True

        names = hasattr(mode,'importDict') and mode.importDict.get(rulesetName,[]) or []

        for name in names:
            savedBunch = self.modeBunch
            ok = self.init_mode(name)
            if ok:
                rulesDict2 = self.rulesDict
                for key in rulesDict2.keys():
                    aList = self.rulesDict.get(key,[])
                    aList2 = rulesDict2.get(key)
                    if aList2:
                        # Don't add the standard rules again.
                        rules = [z for z in aList2 if z not in aList]
                        if rules:
                            # g.trace([z.__name__ for z in rules])
                            aList.extend(rules)
                            self.rulesDict [key] = aList
            # g.trace('***** added rules for %s from %s' % (name,rulesetName))
            self.initModeFromBunch(savedBunch)
    #@nonl
    #@-node:ekr.20081205131308.51:addImportedRules
    #@+node:ekr.20081205131308.52:addLeoRules
    def addLeoRules (self,theDict):

        '''Put Leo-specific rules to theList.'''

        table = (
            # Rules added at front are added in **reverse** order.
            ('@',  self.match_leo_keywords,True), # Called after all other Leo matchers.
                # Debatable: Leo keywords override langauge keywords.
            ('@',  self.match_at_color,    True),
            ('@',  self.match_at_nocolor,  True),
            ('@',  self.match_doc_part,    True), 
            ('&lt;',  self.match_section_ref, True), # Called **first**.
            # Rules added at back are added in normal order.
            (' ',  self.match_blanks,      False),
            ('\t', self.match_tabs,        False),
        )

        for ch, rule, atFront, in table:

            # Replace the bound method by an unbound method.
            rule = rule.im_func
            # g.trace(rule)

            theList = theDict.get(ch,[])
            if rule not in theList:
                if atFront:
                    theList.insert(0,rule)
                else:
                    theList.append(rule)
                theDict [ch] = theList

        # g.trace(g.listToString(theDict.get('@')))
    #@-node:ekr.20081205131308.52:addLeoRules
    #@+node:ekr.20081205131308.53:configure_tags
    def configure_tags (self):

        c = self.c ; w = self.w ; trace = False

        if w and hasattr(w,'start_tag_configure'):
            w.start_tag_configure()

        # Get the default body font.
        defaultBodyfont = self.fonts.get('default_body_font')
        if not defaultBodyfont:
            defaultBodyfont = c.config.getFontFromParams(
                "body_text_font_family", "body_text_font_size",
                "body_text_font_slant",  "body_text_font_weight",
                c.config.defaultBodyFontSize)
            self.fonts['default_body_font'] = defaultBodyfont

        # Configure fonts.
        keys = self.default_font_dict.keys() ; keys.sort()
        for key in keys:
            option_name = self.default_font_dict[key]
            # First, look for the language-specific setting, then the general setting.
            for name in ('%s_%s' % (self.language,option_name),(option_name)):
                font = self.fonts.get(name)
                if font:
                    if trace: g.trace('found',name,id(font))
                    w.tag_config(key,font=font)
                    break
                else:
                    family = c.config.get(name + '_family','family')
                    size   = c.config.get(name + '_size',  'size')   
                    slant  = c.config.get(name + '_slant', 'slant')
                    weight = c.config.get(name + '_weight','weight')
                    if family or slant or weight or size:
                        family = family or g.app.config.defaultFontFamily
                        size   = size or c.config.defaultBodyFontSize
                        slant  = slant or 'roman'
                        weight = weight or 'normal'
                        font = g.app.gui.getFontFromParams(family,size,slant,weight)
                        # Save a reference to the font so it 'sticks'.
                        self.fonts[name] = font 
                        if trace: g.trace(key,name,family,size,slant,weight,id(font))
                        w.tag_config(key,font=font)
                        break
            else: # Neither the general setting nor the language-specific setting exists.
                if self.fonts.keys(): # Restore the default font.
                    if trace: g.trace('default',key)
                    w.tag_config(key,font=defaultBodyfont)

        keys = self.default_colors_dict.keys() ; keys.sort()
        for name in keys:
            option_name,default_color = self.default_colors_dict[name]
            color = (
                c.config.getColor('%s_%s' % (self.language,option_name)) or
                c.config.getColor(option_name) or
                default_color
            )
            if trace: g.trace(option_name,color)

            # Must use foreground, not fg.
            try:
                w.tag_configure(name, foreground=color)
            except: # Recover after a user error.
                g.es_exception()
                w.tag_configure(name, foreground=default_color)

        # underline=var doesn't seem to work.
        if 0: # self.use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
            w.tag_configure("link",underline=1) # defined
            w.tag_configure("name",underline=0) # undefined
        else:
            w.tag_configure("link",underline=0)
            if self.underline_undefined:
                w.tag_configure("name",underline=1)
            else:
                w.tag_configure("name",underline=0)

        self.configure_variable_tags()

        # Colors for latex characters.  Should be user options...

        if 1: # Alas, the selection doesn't show if a background color is specified.
            w.tag_configure("latexModeBackground",foreground="black")
            w.tag_configure("latexModeKeyword",foreground="blue")
            w.tag_configure("latexBackground",foreground="black")
            w.tag_configure("latexKeyword",foreground="blue")
        else: # Looks cool, and good for debugging.
            w.tag_configure("latexModeBackground",foreground="black",background="seashell1")
            w.tag_configure("latexModeKeyword",foreground="blue",background="seashell1")
            w.tag_configure("latexBackground",foreground="black",background="white")
            w.tag_configure("latexKeyword",foreground="blue",background="white")

        # Tags for wiki coloring.
        w.tag_configure("bold",font=self.bold_font)
        w.tag_configure("italic",font=self.italic_font)
        w.tag_configure("bolditalic",font=self.bolditalic_font)
        for name in self.color_tags_list:
            w.tag_configure(name,foreground=name)

        try:
            w.end_tag_configure()
        except AttributeError:
            pass
    #@-node:ekr.20081205131308.53:configure_tags
    #@+node:ekr.20081205131308.54:configure_variable_tags
    def configure_variable_tags (self):

        c = self.c ; w = self.w

        # g.trace()

        for name,option_name,default_color in (
            ("blank","show_invisibles_space_background_color","Gray90"),
            ("tab",  "show_invisibles_tab_background_color",  "Gray80"),
            ("elide", None,                                   "yellow"),
        ):
            if self.showInvisibles:
                color = option_name and c.config.getColor(option_name) or default_color
            else:
                option_name,default_color = self.default_colors_dict.get(name,(None,None),)
                color = option_name and c.config.getColor(option_name) or ''
            try:
                w.tag_configure(name,background=color)
            except: # A user error.
                w.tag_configure(name,background=default_color)

        # Special case:
        if not self.showInvisibles:
            w.tag_configure("elide",elide="1")
    #@-node:ekr.20081205131308.54:configure_variable_tags
    #@+node:ekr.20081205131308.74:init (jeditColorizer)
    def init (self,p,s):

        trace = False and not g.unitTesting

        if p: self.p = p.copy()
        self.all_s = s or ''

        if trace: g.trace('***',p and p.h,len(self.all_s),g.callers(4))

        # State info.
        self.all_s = s
        self.global_i,self.global_j = 0,0
        self.global_offset = 0
        self.initFlag = False
        self.nextState = 1 # Dont use 0.
        self.stateDict = {}
        self.stateNameDict = {}

        self.updateSyntaxColorer(self.p)
            # Sets self.flag and self.language.

        self.init_mode(self.language)

        # Used by matchers.
        self.prev = None

        ####
        # self.configure_tags() # Must do this every time to support multiple editors.
    #@-node:ekr.20081205131308.74:init (jeditColorizer)
    #@+node:ekr.20081205131308.55:init_mode &amp; helpers
    def init_mode (self,name):

        '''Name may be a language name or a delegate name.'''

        if not name: return False
        language,rulesetName = self.nameToRulesetName(name)
        bunch = self.modes.get(rulesetName)
        if bunch:
            # g.trace('found',language,rulesetName)
            self.initModeFromBunch(bunch)
            return True
        else:
            # g.trace('****',language,rulesetName)
            path = g.os_path_join(g.app.loadDir,'..','modes')
            # Bug fix: 2008/2/10: Don't try to import a non-existent language.
            fileName = g.os_path_join(path,'%s.py' % (language))
            if g.os_path_exists(fileName):
                mode = g.importFromPath (language,path)
            else: mode = None

            if mode:
                # A hack to give modes/forth.py access to c.
                if hasattr(mode,'pre_init_mode'):
                    mode.pre_init_mode(self.c)
            else:
                # Create a dummy bunch to limit recursion.
                self.modes [rulesetName] = self.modeBunch = g.Bunch(
                    attributesDict  = {},
                    defaultColor    = None,
                    keywordsDict    = {},
                    language        = language,
                    mode            = mode,
                    properties      = {},
                    rulesDict       = {},
                    rulesetName     = rulesetName)
                # g.trace('No colorizer file: %s.py' % language)
                return False
            self.language = language
            self.rulesetName = rulesetName
            self.properties = hasattr(mode,'properties') and mode.properties or {}
            self.keywordsDict = hasattr(mode,'keywordsDictDict') and mode.keywordsDictDict.get(rulesetName,{}) or {}
            self.setKeywords()
            self.attributesDict = hasattr(mode,'attributesDictDict') and mode.attributesDictDict.get(rulesetName) or {}
            self.setModeAttributes()
            self.rulesDict = hasattr(mode,'rulesDictDict') and mode.rulesDictDict.get(rulesetName) or {}
            self.addLeoRules(self.rulesDict)

            self.defaultColor = 'null'
            self.mode = mode
            self.modes [rulesetName] = self.modeBunch = g.Bunch(
                attributesDict  = self.attributesDict,
                defaultColor    = self.defaultColor,
                keywordsDict    = self.keywordsDict,
                language        = self.language,
                mode            = self.mode,
                properties      = self.properties,
                rulesDict       = self.rulesDict,
                rulesetName     = self.rulesetName)
            # Do this after 'officially' initing the mode, to limit recursion.
            self.addImportedRules(mode,self.rulesDict,rulesetName)
            self.updateDelimsTables()

            initialDelegate = self.properties.get('initialModeDelegate')
            if initialDelegate:
                # g.trace('initialDelegate',initialDelegate)
                # Replace the original mode by the delegate mode.
                self.init_mode(initialDelegate)
                language2,rulesetName2 = self.nameToRulesetName(initialDelegate)
                self.modes[rulesetName] = self.modes.get(rulesetName2)
            return True
    #@+node:ekr.20081205131308.56:nameToRulesetName
    def nameToRulesetName (self,name):

        '''Compute language and rulesetName from name, which is either a language or a delegate name.'''

        if not name: return ''

        i = name.find('::')
        if i == -1:
            language = name
            rulesetName = '%s_main' % (language)
        else:
            language = name[:i]
            delegate = name[i+2:]
            rulesetName = self.munge('%s_%s' % (language,delegate))

        # g.trace(name,language,rulesetName)
        return language,rulesetName
    #@nonl
    #@-node:ekr.20081205131308.56:nameToRulesetName
    #@+node:ekr.20081205131308.57:setKeywords
    def setKeywords (self):

        '''Initialize the keywords for the present language.

         Set self.word_chars ivar to string.letters + string.digits
         plus any other character appearing in any keyword.'''

        # Add any new user keywords to leoKeywordsDict.
        d = self.keywordsDict
        keys = d.keys()
        for s in g.globalDirectiveList:
            key = '@' + s
            if key not in keys:
                d [key] = 'leoKeyword'

        # Create a temporary chars list.  It will be converted to a dict later.
        chars = [g.toUnicode(ch,encoding='UTF-8')
            for ch in (string.letters + string.digits)]

        for key in d.keys():
            for ch in key:
                if ch not in chars:
                    chars.append(g.toUnicode(ch,encoding='UTF-8'))

        # jEdit2Py now does this check, so this isn't really needed.
        # But it is needed for forth.py.
        for ch in (' ', '\t'):
            if ch in chars:
                # g.es_print('removing %s from word_chars' % (repr(ch)))
                chars.remove(ch)

        # g.trace(self.language,[str(z) for z in chars])

        # Convert chars to a dict for faster access.
        self.word_chars = {}
        for z in chars:
            self.word_chars[z] = z
    #@-node:ekr.20081205131308.57:setKeywords
    #@+node:ekr.20081205131308.58:setModeAttributes
    def setModeAttributes (self):

        '''Set the ivars from self.attributesDict,
        converting 'true'/'false' to True and False.'''

        d = self.attributesDict
        aList = (
            ('default',         'null'),
    	    ('digit_re',        ''),
            ('escape',          ''), # New in Leo 4.4.2.
    	    ('highlight_digits',True),
    	    ('ignore_case',     True),
    	    ('no_word_sep',     ''),
        )

        for key, default in aList:
            val = d.get(key,default)
            if val in ('true','True'): val = True
            if val in ('false','False'): val = False
            setattr(self,key,val)
            # g.trace(key,val)
    #@nonl
    #@-node:ekr.20081205131308.58:setModeAttributes
    #@+node:ekr.20081205131308.59:initModeFromBunch
    def initModeFromBunch (self,bunch):

        self.modeBunch = bunch
        self.attributesDict = bunch.attributesDict
        self.setModeAttributes()
        self.defaultColor   = bunch.defaultColor
        self.keywordsDict   = bunch.keywordsDict
        self.language       = bunch.language
        self.mode           = bunch.mode
        self.properties     = bunch.properties
        self.rulesDict      = bunch.rulesDict
        self.rulesetName    = bunch.rulesetName

        # g.trace(self.rulesetName)
    #@nonl
    #@-node:ekr.20081205131308.59:initModeFromBunch
    #@+node:ekr.20081205131308.60:updateDelimsTables
    def updateDelimsTables (self):

        '''Update g.app.language_delims_dict if no entry for the language exists.'''

        d = self.properties
        lineComment = d.get('lineComment')
        startComment = d.get('commentStart')
        endComment = d.get('commentEnd')

        if lineComment and startComment and endComment:
            delims = '%s %s %s' % (lineComment,startComment,endComment)
        elif startComment and endComment:
            delims = '%s %s' % (startComment,endComment)
        elif lineComment:
            delims = '%s' % lineComment
        else:
            delims = None

        if delims:
            d = g.app.language_delims_dict
            if not d.get(self.language):
                d [self.language] = delims
                # g.trace(self.language,'delims:',repr(delims))
    #@-node:ekr.20081205131308.60:updateDelimsTables
    #@-node:ekr.20081205131308.55:init_mode &amp; helpers
    #@+node:ekr.20081205131308.106:munge
    def munge(self,s):

        '''Munge a mode name so that it is a valid python id.'''

        valid = string.ascii_letters + string.digits + '_'

        return ''.join([g.choose(ch in valid,ch.lower(),'_') for ch in s])
    #@nonl
    #@-node:ekr.20081205131308.106:munge
    #@+node:ekr.20081205131308.111:setFontFromConfig
    def setFontFromConfig (self):

        c = self.c
        # isQt = g.app.gui.guiName() == 'qt'

        self.bold_font = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize) # , tag = "colorer bold")

        # if self.bold_font and not isQt:
            # self.bold_font.configure(weight="bold")

        self.italic_font = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize) # , tag = "colorer italic")

        # if self.italic_font and not isQt:
            # self.italic_font.configure(slant="italic",weight="normal")

        self.bolditalic_font = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize) # , tag = "colorer bold italic")

        # if self.bolditalic_font and not isQt:
            # self.bolditalic_font.configure(weight="bold",slant="italic")

        self.color_tags_list = []
        # self.image_references = []
    #@nonl
    #@-node:ekr.20081205131308.111:setFontFromConfig
    #@-node:ekr.20081205131308.49: Birth &amp; init
    #@+node:ekr.20081206062411.13:colorRangeWithTag
    def colorRangeWithTag (self,s,i,j,tag,delegate='',exclude_match=False):

        '''Actually colorize the selected range.

        This is called whenever a pattern matcher succeed.'''

        trace = False
        if not self.flag: return

        if delegate:
            if trace: g.trace('delegate',delegate,i,j,tag,g.callers(3))
            self.modeStack.append(self.modeBunch)
            self.init_mode(delegate)
            # Color everything now, using the same indices as the caller.
            while i &lt; j:
                progress = i
                assert j &gt;= 0, 'colorRangeWithTag: negative j'
                for f in self.rulesDict.get(s[i],[]):
                    n = f(self,s,i)
                    if n is None:
                        g.trace('Can not happen: delegate matcher returns None')
                    elif n &gt; 0:
                        if trace: g.trace('delegate',delegate,i,n,f.__name__,repr(s[i:i+n]))
                        i += n ; break
                else:
                    # New in Leo 4.6: Use the default chars for everything else.
                    self.setTag(tag,s,i,i+1)
                    i += 1
                assert i &gt; progress
            bunch = self.modeStack.pop()
            self.initModeFromBunch(bunch)
        elif not exclude_match:
            self.setTag(tag,s,i,j)
    #@nonl
    #@-node:ekr.20081206062411.13:colorRangeWithTag
    #@+node:ekr.20081205131308.87:pattern matchers
    #@@nocolor-node
    #@+at
    # 
    # The following jEdit matcher methods return the length of the matched 
    # text if the
    # match succeeds, and zero otherwise.  In most cases, these methods 
    # colorize all the matched text.
    # 
    # The following arguments affect matching:
    # 
    # - at_line_start         True: sequence must start the line.
    # - at_whitespace_end     True: sequence must be first non-whitespace text 
    # of the line.
    # - at_word_start         True: sequence must start a word.
    # - hash_char             The first character that must match in a regular 
    # expression.
    # - no_escape:            True: ignore an 'end' string if it is preceded 
    # by the ruleset's escape character.
    # - no_line_break         True: the match will not succeed across line 
    # breaks.
    # - no_word_break:        True: the match will not cross word breaks.
    # 
    # The following arguments affect coloring when a match succeeds:
    # 
    # - delegate              A ruleset name. The matched text will be colored 
    # recursively by the indicated ruleset.
    # - exclude_match         If True, the actual text that matched will not 
    # be colored.
    # - kind                  The color tag to be applied to colored text.
    #@-at
    #@@c
    #@@color
    #@+node:ekr.20081205131308.105:dump
    def dump (self,s):

        if s.find('\n') == -1:
            return s
        else:
            return '\n' + s + '\n'
    #@nonl
    #@-node:ekr.20081205131308.105:dump
    #@+node:ekr.20081205131308.38:Leo rule functions
    #@+node:ekr.20081205131308.39:match_at_color
    def match_at_color (self,s,i):

        if self.trace_leo_matches: g.trace()

        seq = '@color'

        # Only matches at start of line.
        if i != 0 and s[i-1] != '\n': return 0

        if g.match_word(s,i,seq):
            self.flag = True # Enable coloring.
            j = i + len(seq)
            self.colorRangeWithTag(s,i,j,'leoKeyword')
            return j - i
        else:
            return 0
    #@nonl
    #@-node:ekr.20081205131308.39:match_at_color
    #@+node:ekr.20081205131308.40:match_at_nocolor
    def match_at_nocolor (self,s,i):

        if self.trace_leo_matches: g.trace()

        # Only matches at start of line.
        if i != 0 and s[i-1] != '\n':
            return 0
        if not g.match_word(s,i,'@nocolor'):
            return 0

        j = i + len('@nocolor')
        k = s.find('\n@color',j)
        if k == -1:
            # No later @color: don't color the @nocolor directive.
            self.flag = False # Disable coloring.
            return len(s) - j
        else:
            # A later @color: do color the @nocolor directive.
            self.colorRangeWithTag(s,i,j,'leoKeyword')
            self.flag = False # Disable coloring.
            return k+1-j

    #@-node:ekr.20081205131308.40:match_at_nocolor
    #@+node:ekr.20081205131308.45:match_blanks
    def match_blanks (self,s,i):

        # g.trace(self,s,i)

        j = i ; n = len(s)

        while j &lt; n and s[j] == ' ':
            j += 1

        if j &gt; i:
            # g.trace(i,j)
            if self.showInvisibles:
                self.colorRangeWithTag(s,i,j,'blank')
            return j - i
        else:
            return 0
    #@-node:ekr.20081205131308.45:match_blanks
    #@+node:ekr.20081205131308.41:match_doc_part
    def match_doc_part (self,s,i):

        # New in Leo 4.5: only matches at start of line.
        if i != 0 and s[i-1] != '\n':
            return 0

        if g.match_word(s,i,'@doc'):
            j = i+4
            self.colorRangeWithTag(s,i,j,'leoKeyword')
        elif g.match(s,i,'@') and (i+1 &gt;= len(s) or s[i+1] in (' ','\t','\n')):
            j = i + 1
            self.colorRangeWithTag(s,i,j,'leoKeyword')
        else: return 0

        i = j ; n = len(s)
        while j &lt; n:
            k = s.find('@c',j)
            if k == -1:
                # g.trace('i,len(s)',i,len(s))
                j = n+1 # Bug fix: 2007/12/14
                self.colorRangeWithTag(s,i,j,'docPart')
                return j - i
            if s[k-1] == '\n' and (g.match_word(s,k,'@c') or g.match_word(s,k,'@code')):
                j = k
                self.colorRangeWithTag(s,i,j,'docPart')
                return j - i
            else:
                j = k + 2
        j = n - 1
        return max(0,j - i) # Bug fix: 2008/2/10
    #@-node:ekr.20081205131308.41:match_doc_part
    #@+node:ekr.20081205131308.42:match_leo_keywords
    def match_leo_keywords(self,s,i):

        '''Succeed if s[i:] is a Leo keyword.'''

        # g.trace(i,g.get_line(s,i))

        self.totalLeoKeywordsCalls += 1

        # We must be at the start of a word.
        if i &gt; 0 and s[i-1] in self.word_chars:
            return 0

        if s[i] != '@':
            return 0

        # Get the word as quickly as possible.
        j = i+1
        while j &lt; len(s) and s[j] in self.word_chars:
            j += 1
        word = s[i+1:j] # Bug fix: 10/17/07: entries in leoKeywordsDict do not start with '@'

        if self.leoKeywordsDict.get(word):
            kind = 'leoKeyword'
            self.colorRangeWithTag(s,i,j,kind)
            self.prev = (i,j,kind)
            result = j-i+1 # Bug fix: skip the last character.
            self.trace_match(kind,s,i,j)
            return result
        else:
            return -(j-i+1) # An important optimization.
    #@-node:ekr.20081205131308.42:match_leo_keywords
    #@+node:ekr.20081205131308.43:match_section_ref
    def match_section_ref (self,s,i):

        if self.trace_leo_matches: g.trace()
        c = self.c ; p = c.currentPosition()
        w = self.w

        if not g.match(s,i,'&lt;&lt;'):
            return 0
        k = g.find_on_line(s,i+2,'&gt;&gt;')
        if k is not None:
            j = k + 2
            self.colorRangeWithTag(s,i,i+2,'nameBrackets')
            ref = g.findReference(c,s[i:j],p) #### self.p)
            if ref:
                if self.use_hyperlinks:
                    #@                &lt;&lt; set the hyperlink &gt;&gt;
                    #@+node:ekr.20081205131308.44:&lt;&lt; set the hyperlink &gt;&gt;
                    # Set the bindings to vnode callbacks.
                    # Create the tag.
                    # Create the tag name.
                    tagName = "hyper" + str(self.hyperCount)
                    self.hyperCount += 1
                    w.tag_delete(tagName)
                    w.tag_add(tagName,i+2,j)

                    ref.tagName = tagName
                    c.tag_bind(w,tagName,"&lt;Control-1&gt;",ref.OnHyperLinkControlClick)
                    c.tag_bind(w,tagName,"&lt;Any-Enter&gt;",ref.OnHyperLinkEnter)
                    c.tag_bind(w,tagName,"&lt;Any-Leave&gt;",ref.OnHyperLinkLeave)
                    #@nonl
                    #@-node:ekr.20081205131308.44:&lt;&lt; set the hyperlink &gt;&gt;
                    #@nl
                else:
                    self.colorRangeWithTag(s,i+2,k,'link')
            else:
                self.colorRangeWithTag(s,i+2,k,'name')
            self.colorRangeWithTag(s,k,j,'nameBrackets')
            return j - i
        else:
            return 0
    #@nonl
    #@-node:ekr.20081205131308.43:match_section_ref
    #@+node:ekr.20081205131308.46:match_tabs
    def match_tabs (self,s,i):

        if self.trace_leo_matches: g.trace()

        j = i ; n = len(s)

        while j &lt; n and s[j] == '\t':
            j += 1

        if j &gt; i:
            # g.trace(i,j)
            self.colorRangeWithTag(s,i,j,'tab')
            return j - i
        else:
            return 0
    #@nonl
    #@-node:ekr.20081205131308.46:match_tabs
    #@-node:ekr.20081205131308.38:Leo rule functions
    #@+node:ekr.20081205131308.88:match_eol_span
    def match_eol_span (self,s,i,
        kind=None,seq='',
        at_line_start=False,at_whitespace_end=False,at_word_start=False,
        delegate='',exclude_match=False):

        '''Succeed if seq matches s[i:]'''

        if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

        if at_line_start and i != 0 and s[i-1] != '\n': return 0
        if at_whitespace_end and i != g.skip_ws(s,0): return 0
        if at_word_start and i &gt; 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
        if at_word_start and i + len(seq) + 1 &lt; len(s) and s[i+len(seq)] in self.word_chars:
            return 0 # 7/5/2008

        if g.match(s,i,seq):
            #j = g.skip_line(s,i) # Include the newline so we don't get a flash at the end of the line.
            j = self.skip_line(s,i)
            self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            self.minimalMatch = seq
            return j - i
        else:
            return 0
    #@-node:ekr.20081205131308.88:match_eol_span
    #@+node:ekr.20081205131308.89:match_eol_span_regexp
    def match_eol_span_regexp (self,s,i,
        kind='',regexp='',
        at_line_start=False,at_whitespace_end=False,at_word_start=False,
        delegate='',exclude_match=False):

        '''Succeed if the regular expression regex matches s[i:].'''

        if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

        if at_line_start and i != 0 and s[i-1] != '\n': return 0
        if at_whitespace_end and i != g.skip_ws(s,0): return 0
        if at_word_start and i &gt; 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008

        n = self.match_regexp_helper(s,i,regexp)
        if n &gt; 0:
            # j = g.skip_line(s,i) # Include the newline so we don't get a flash at the end of the line.
            j = self.skip_line(s,i)
            self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            self.minimalMatch = seq
            return j - i
        else:
            return 0
    #@nonl
    #@-node:ekr.20081205131308.89:match_eol_span_regexp
    #@+node:ekr.20081205131308.91:match_keywords
    # This is a time-critical method.
    def match_keywords (self,s,i):

        '''Succeed if s[i:] is a keyword.'''

        self.totalKeywordsCalls += 1

        # Important.  Return -len(word) for failure greatly reduces
        # the number of times this method is called.

        # We must be at the start of a word.
        if i &gt; 0 and s[i-1] in self.word_chars:
            return 0

        trace = False

        # Get the word as quickly as possible.
        j = i ; n = len(s) ; chars = self.word_chars
        while j &lt; n and s[j] in chars:
            j += 1

        word = s[i:j]
        if self.ignore_case: word = word.lower()
        kind = self.keywordsDict.get(word)
        if kind:
            self.colorRangeWithTag(s,i,j,kind)
            self.prev = (i,j,kind)
            result = j - i
            if trace: g.trace('success',word,kind,j-i)
            # g.trace('word in self.keywordsDict.keys()',word in self.keywordsDict.keys())
            self.trace_match(kind,s,i,j)
            return result
        else:
            if trace: g.trace('fail',word,kind)
            # g.trace('word in self.keywordsDict.keys()',word in self.keywordsDict.keys())
            return -len(word) # An important new optimization.
    #@-node:ekr.20081205131308.91:match_keywords
    #@+node:ekr.20081205131308.92:match_mark_following &amp; getNextToken
    def match_mark_following (self,s,i,
        kind='',pattern='',
        at_line_start=False,at_whitespace_end=False,at_word_start=False,
        exclude_match=False):

        '''Succeed if s[i:] matches pattern.'''

        if not self.allow_mark_prev: return 0

        if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

        if at_line_start and i != 0 and s[i-1] != '\n': return 0
        if at_whitespace_end and i != g.skip_ws(s,0): return 0
        if at_word_start and i &gt; 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
        if at_word_start and i + len(pattern) + 1 &lt; len(s) and s[i+len(pattern)] in self.word_chars:
            return 0 # 7/5/2008

        if g.match(s,i,pattern):
            j = i + len(pattern)
            self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
            k = self.getNextToken(s,j)
            if k &gt; j:
                self.colorRangeWithTag(s,j,k,kind,exclude_match=False)
                j = k
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            self.minimalMatch = pattern
            return j - i
        else:
            return 0
    #@+node:ekr.20081205131308.93:getNextToken
    def getNextToken (self,s,i):

        '''Return the index of the end of the next token for match_mark_following.

        The jEdit docs are not clear about what a 'token' is, but experiments with jEdit
        show that token means a word, as defined by word_chars.'''

        while i &lt; len(s) and s[i] in self.word_chars:
            i += 1

        return min(len(s),i+1)
    #@nonl
    #@-node:ekr.20081205131308.93:getNextToken
    #@-node:ekr.20081205131308.92:match_mark_following &amp; getNextToken
    #@+node:ekr.20081205131308.94:match_mark_previous
    def match_mark_previous (self,s,i,
        kind='',pattern='',
        at_line_start=False,at_whitespace_end=False,at_word_start=False,
        exclude_match=False):

        '''Return the length of a matched SEQ or 0 if no match.

        'at_line_start':    True: sequence must start the line.
        'at_whitespace_end':True: sequence must be first non-whitespace text of the line.
        'at_word_start':    True: sequence must start a word.'''

        if not self.allow_mark_prev: return 0

        if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

        if at_line_start and i != 0 and s[i-1] != '\n': return 0
        if at_whitespace_end and i != g.skip_ws(s,0): return 0
        if at_word_start and i &gt; 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
        if at_word_start and i + len(pattern) + 1 &lt; len(s) and s[i+len(pattern)] in self.word_chars:
            return 0 # 7/5/2008

        if g.match(s,i,pattern):
            j = i + len(pattern)
            # Color the previous token.
            if self.prev:
                i2,j2,kind2 = self.prev
                # g.trace(i2,j2,kind2)
                self.colorRangeWithTag(s,i2,j2,kind2,exclude_match=False)
            if not exclude_match:
                self.colorRangeWithTag(s,i,j,kind)
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            self.minimalMatch = pattern
            return j - i
        else:
            return 0
    #@-node:ekr.20081205131308.94:match_mark_previous
    #@+node:ekr.20081205131308.95:match_regexp_helper
    def match_regexp_helper (self,s,i,pattern):

        '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

        if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'pattern',pattern)
        trace = False

        try:
            flags = re.MULTILINE
            if self.ignore_case: flags|= re.IGNORECASE
            re_obj = re.compile(pattern,flags)
        except Exception:
            # Bug fix: 2007/11/07: do not call g.es here!
            g.trace('Invalid regular expression: %s' % (pattern))
            return 0

        # Match succeeds or fails more quickly than search.
        # g.trace('before')
        self.match_obj = mo = re_obj.match(s,i) # re_obj.search(s,i) 
        # g.trace('after')

        if mo is None:
            return 0
        else:
            start, end = mo.start(), mo.end()
            if start != i: # Bug fix 2007-12-18: no match at i
                return 0
            if trace:
                g.trace('pattern',pattern)
                g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
                g.trace('groups',mo.groups())
            return end - start
    #@-node:ekr.20081205131308.95:match_regexp_helper
    #@+node:ekr.20081205131308.96:match_seq
    def match_seq (self,s,i,
        kind='',seq='',
        at_line_start=False,at_whitespace_end=False,at_word_start=False,
        delegate=''):

        '''Succeed if s[:] mathces seq.'''

        if at_line_start and i != 0 and s[i-1] != '\n':
            j = i
        elif at_whitespace_end and i != g.skip_ws(s,0):
            j = i
        elif at_word_start and i &gt; 0 and s[i-1] in self.word_chars:  # 7/5/2008
            j = i
        if at_word_start and i + len(seq) + 1 &lt; len(s) and s[i+len(seq)] in self.word_chars:
            j = i # 7/5/2008
        elif g.match(s,i,seq):
            j = i + len(seq)
            self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            self.minimalMatch = seq
        else:
            j = i
        return j - i
    #@nonl
    #@-node:ekr.20081205131308.96:match_seq
    #@+node:ekr.20081205131308.97:match_seq_regexp
    def match_seq_regexp (self,s,i,
        kind='',regexp='',
        at_line_start=False,at_whitespace_end=False,at_word_start=False,
        delegate=''):

        '''Succeed if the regular expression regexp matches at s[i:].'''

        if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

        if at_line_start and i != 0 and s[i-1] != '\n': return 0
        if at_whitespace_end and i != g.skip_ws(s,0): return 0
        if at_word_start and i &gt; 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008

        # g.trace('before')
        n = self.match_regexp_helper(s,i,regexp)
        # g.trace('after')
        j = i + n # Bug fix: 2007-12-18
        assert (j-i == n)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    #@nonl
    #@-node:ekr.20081205131308.97:match_seq_regexp
    #@+node:ekr.20081205131308.98:match_span &amp; helper
    def match_span (self,s,i,
        kind='',begin='',end='',
        at_line_start=False,at_whitespace_end=False,at_word_start=False,
        delegate='',exclude_match=False,
        no_escape=False,no_line_break=False,no_word_break=False):

        '''Succeed if s[i:] starts with 'begin' and contains a following 'end'.'''

        if at_line_start and i != 0 and s[i-1] != '\n':
            j = i
        elif at_whitespace_end and i != g.skip_ws(s,0):
            j = i
        elif at_word_start and i &gt; 0 and s[i-1] in self.word_chars: # 7/5/2008
            j = i
        elif at_word_start and i + len(begin) + 1 &lt; len(s) and s[i+len(begin)] in self.word_chars:
            j = i # 7/5/2008
        elif not g.match(s,i,begin):
            j = i
        else:
            j = self.match_span_helper(s,i+len(begin),end,no_escape,no_line_break,no_word_break=no_word_break)
            if j == -1:
                j = i
            else:
                i2 = i + len(begin) ; j2 = j + len(end)
                # g.trace(i,j,s[i:j2],kind)
                if delegate:
                    self.colorRangeWithTag(s,i,i2,kind,delegate=None,    exclude_match=exclude_match)
                    self.colorRangeWithTag(s,i2,j,kind,delegate=delegate,exclude_match=exclude_match)
                    self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
                else: # avoid having to merge ranges in addTagsToList.
                    self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
                j = j2
                self.prev = (i,j,kind)
                self.minimalMatch = begin

        self.trace_match(kind,s,i,j)
        return j - i
    #@+node:ekr.20081205131308.99:match_span_helper
    def match_span_helper (self,s,i,pattern,no_escape,no_line_break,no_word_break=False):

        '''Return n &gt;= 0 if s[i] ends with a non-escaped 'end' string.'''

        esc = self.escape

        while 1:
            j = s.find(pattern,i)
            if j == -1:
                # Match to end of text if not found and no_line_break is False
                if no_line_break:
                    return -1
                else:
                    return len(s)
            elif no_word_break and j &gt; 0 and s[j-1] in self.word_chars:
                return -1 # New in Leo 4.5.
            elif no_line_break and '\n' in s[i:j]:
                return -1
            elif esc and not no_escape:
                # Only an odd number of escapes is a 'real' escape.
                escapes = 0 ; k = 1
                while j-k &gt;=0 and s[j-k] == esc:
                    escapes += 1 ; k += 1
                if (escapes % 2) == 1:
                    # Continue searching past the escaped pattern string.
                    i = j + len(pattern) # Bug fix: 7/25/07.
                    # g.trace('escapes',escapes,repr(s[i:]))
                else:
                    return j
            else:
                return j
    #@nonl
    #@-node:ekr.20081205131308.99:match_span_helper
    #@-node:ekr.20081205131308.98:match_span &amp; helper
    #@+node:ekr.20081205131308.100:match_span_regexp
    def match_span_regexp (self,s,i,
        kind='',begin='',end='',
        at_line_start=False,at_whitespace_end=False,at_word_start=False,
        delegate='',exclude_match=False,
        no_escape=False,no_line_break=False, no_word_break=False,
    ):

        '''Succeed if s[i:] starts with 'begin' (a regular expression) and contains a following 'end'.'''

        if self.verbose: g.trace('begin',repr(begin),'end',repr(end),self.dump(s[i:]))

        if at_line_start and i != 0 and s[i-1] != '\n': return 0
        if at_whitespace_end and i != g.skip_ws(s,0): return 0
        if at_word_start and i &gt; 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
        if at_word_start and i + len(begin) + 1 &lt; len(s) and s[i+len(begin)] in self.word_chars:
            return 0 # 7/5/2008

        n = self.match_regexp_helper(s,i,begin)
        # We may have to allow $n here, in which case we must use a regex object?
        if n &gt; 0:
            j = i + n
            j2 = s.find(end,j)
            if j2 == -1: return 0
            if self.escape and not no_escape:
                # Only an odd number of escapes is a 'real' escape.
                escapes = 0 ; k = 1
                while j-k &gt;=0 and s[j-k] == self.escape:
                    escapes += 1 ; k += 1
                if (escapes % 2) == 1:
                    # An escaped end **aborts the entire match**:
                    # there is no way to 'restart' the regex.
                    return 0
            i2 = j2 - len(end)
            if delegate:
                self.colorRangeWithTag(s,i,j,kind, delegate=None,     exclude_match=exclude_match)
                self.colorRangeWithTag(s,j,i2,kind, delegate=delegate,exclude_match=False)
                self.colorRangeWithTag(s,i2,j2,kind,delegate=None,    exclude_match=exclude_match)
            else: # avoid having to merge ranges in addTagsToList.
                self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j2)
            return j2 - i
        else: return 0
    #@-node:ekr.20081205131308.100:match_span_regexp
    #@+node:ekr.20081205131308.101:match_word_and_regexp
    def match_word_and_regexp (self,s,i,
        kind1='',word='',
        kind2='',pattern='',
        at_line_start=False,at_whitespace_end=False,at_word_start=False,
        exclude_match=False):

        '''Succeed if s[i:] matches pattern.'''

        if not self.allow_mark_prev: return 0

        if (False or self.verbose): g.trace(i,repr(s[i:i+20]))

        if at_line_start and i != 0 and s[i-1] != '\n': return 0
        if at_whitespace_end and i != g.skip_ws(s,0): return 0
        if at_word_start and i &gt; 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
        if at_word_start and i + len(word) + 1 &lt; len(s) and s[i+len(word)] in self.word_chars:
            j = i # 7/5/2008

        if not g.match(s,i,word):
            return 0

        j = i + len(word)
        n = self.match_regexp_helper(s,j,pattern)
        # g.trace(j,pattern,n)
        if n == 0:
            return 0
        self.colorRangeWithTag(s,i,j,kind1,exclude_match=exclude_match)
        k = j + n
        self.colorRangeWithTag(s,j,k,kind2,exclude_match=False)    
        self.prev = (j,k,kind2)
        self.trace_match(kind1,s,i,j)
        self.trace_match(kind2,s,j,k)
        return k - i
    #@-node:ekr.20081205131308.101:match_word_and_regexp
    #@+node:ekr.20081205131308.102:skip_line
    def skip_line (self,s,i):

        if self.escape:
            escape = self.escape + '\n'
            n = len(escape)
            while i &lt; len(s):
                j = g.skip_line(s,i)
                if not g.match(s,j-n,escape):
                    return j
                # g.trace('escape',s[i:j])
                i = j
            return i
        else:
            return g.skip_line(s,i)
                # Include the newline so we don't get a flash at the end of the line.
    #@nonl
    #@-node:ekr.20081205131308.102:skip_line
    #@+node:ekr.20081205131308.112:trace_match
    def trace_match(self,kind,s,i,j):

        if j != i and self.trace_match_flag:
            g.trace(kind,i,j,g.callers(2),self.dump(s[i:j]))
    #@nonl
    #@-node:ekr.20081205131308.112:trace_match
    #@-node:ekr.20081205131308.87:pattern matchers
    #@+node:ekr.20081206062411.12:recolor &amp; helpers
    def recolor (self,s):

        '''Recolor line s.'''

        trace = True and not g.unitTesting
        verbose = False ; traceMatch = False

        if self.initFlag:
            self.initFlag = False
            self.all_s = self.w.getAllText()
            if trace and verbose:
                g.trace('**** set all_s: %s' % len(self.all_s))

        all_s = self.all_s
        if not all_s: return

        len_s = len(s)
        self.recolorCount += 1
        self.totalChars += len_s
        b = self.getPrevState()
        lastFunc,lastMatch = b.lastFunc,b.lastMatch
        lastN,minimalMatch = 0,'' # Not used until there is a match.
        offset = self.highlighter.currentBlock().position()
        # Calculate the bounds of the scan.
        i = g.choose(lastFunc,lastMatch,offset)
        j = offset + len_s
        j = min(j,len(all_s))
        self.global_i,self.global_j = offset,j

        # An important check.
        s2 = all_s[offset:j]
        if s2 != s:
            g.trace('**** mismatch! offset %s len %s %s\n%s\n%s' % (
                offset,len(all_s),g.callers(5),repr(s),repr(s2)))
            return

        while i &lt; j:
            assert 0 &lt;= i &lt; len(all_s)
            progress = i
            functions = self.rulesDict.get(all_s[i],[])
            self.minimalMatch = ''
            for f in functions:
                n = f(self,all_s,i)
                if n is None:
                    g.trace('Can not happen' % (repr(n),repr(f)))
                    break
                elif n &gt; 0: # Success.
                    if trace and traceMatch:
                        g.trace('match: i %3s, n %3s, f %s' % (i,n,f.__name__))
                    lastFunc,lastMatch,lastN,minimalMatch = f,i,n,self.minimalMatch
                    i += n
                    break # Stop searching the functions.
                elif n &lt; 0: # Fail and skip n chars.
                    # match_keyword now sets n &lt; 0 on first failure.
                    i += -n # Don't set lastMatch on failure!
                    break # Stop searching the functions.
                else: # Fail.  Go on to the next f in functions.
                    pass # Do not break or change i!
            else:
                i += 1 # Don't set lastMatch on failure!
            assert i &gt; progress

        self.setCurrentState(s,offset,len(s)+1,
            lastFunc,lastMatch,lastN,minimalMatch)
    #@+node:ekr.20090211072718.14:computeStateName
    def computeStateName (self,lastFunc,lastMatch,lastN,minimalMatch):

        if lastFunc:
            matchString = g.choose(minimalMatch,
                minimalMatch,
                self.all_s[lastMatch:lastMatch+lastN])
            return '%s:%s' % (
                lastFunc.__name__,matchString)
        else:
            return self.defaultState
    #@-node:ekr.20090211072718.14:computeStateName
    #@+node:ekr.20090211072718.2:getPrevState
    def getPrevState (self):

        h = self.highlighter
        n = h.previousBlockState()

        if n == -1:
            return g.Bunch(lastFunc=None,lastMatch=0,lastN=0)
                # active = False,
                # offset=0,
                # len_s=0,
                # minimalMatch=''
                # stateName=self.defaultState)
        else:
            bunch = self.stateDict.get(n)
            assert bunch,'n=%s' % (n)
            return bunch
    #@nonl
    #@-node:ekr.20090211072718.2:getPrevState
    #@+node:ekr.20090211072718.3:setCurrentState
    def setCurrentState (self,s,offset,len_s,lastFunc,lastMatch,lastN,minimalMatch):

        trace = False and not g.unitTesting
        verbose = False
        h = self.highlighter

        self.stateCount += 1
        oldN = h.currentBlockState()
        active = bool(lastFunc and lastMatch + lastN &gt; offset + len_s)

        if active:
            b = self.stateDict.get(oldN)
            if b:
                changeState = b.lastFunc != lastFunc or b.lastN != lastN
            else:
                changeState = True
        else:
            lastFunc,lastMatch,lastN,minimalMatch = None,None,None,None
            changeState = oldN != -1

        stateName = self.computeStateName(
            lastFunc,lastMatch,lastN,minimalMatch)

        if trace and (changeState or active or verbose):
            g.trace('%2d ** active %5s changed %5s %-20s %s' % (
                self.stateCount,active,changeState,stateName,s))

        if not changeState:
            return

        n = self.stateNameDict.get(stateName)
        if n is None:
            n = self.nextState
            self.nextState += 1
            self.totalStates += 1
            self.maxStateNumber = max(n,self.maxStateNumber)

        state = g.bunch(lastFunc=lastFunc,lastMatch=lastMatch,lastN=lastN)
            # active=active,
            # offset=offset,
            # len_s=len_s,
            # minimalMatch=minimalMatch,
            # stateName=stateName)

        self.stateNameDict[stateName] = n
        self.stateDict[n] = state

        h.setCurrentBlockState(n)
    #@-node:ekr.20090211072718.3:setCurrentState
    #@-node:ekr.20081206062411.12:recolor &amp; helpers
    #@+node:ekr.20081205131308.26:scanColorDirectives
    def scanColorDirectives(self,p):

        '''Scan position p and p's ancestors looking for @comment,
        @language and @root directives,
        setting corresponding colorizer ivars.'''

        c = self.c
        if not c: return # May be None for testing.

        table = (
            ('lang-dict',   g.scanAtCommentAndAtLanguageDirectives),
            ('root',        c.scanAtRootDirectives),
        )

        # Set d by scanning all directives.
        aList = g.get_directives_dict_list(p)
        d = {}
        for key,func in table:
            val = func(aList)
            if val: d[key]=val

        # Post process.
        lang_dict       = d.get('lang-dict')
        self.rootMode   = d.get('root') or None

        if lang_dict:
            self.language       = lang_dict.get('language')
            self.comment_string = lang_dict.get('comment')
        else:
            self.language       = c.target_language and c.target_language.lower()
            self.comment_string = None

        # g.trace('self.language',self.language)
        return self.language # For use by external routines.
    #@-node:ekr.20081205131308.26:scanColorDirectives
    #@+node:ekr.20081206062411.14:setTag
    def setTag (self,tag,s,i,j):

        trace = False
        w = self.w
        colorName = w.configDict.get(tag)

        # Munch the color name.
        if not colorName or colorName == 'black':
            return
        if colorName[-1].isdigit() and colorName[0] != '#':
            colorName = colorName[:-1]

        # Get the actual color.
        color = self.actualColorDict.get(colorName)
        if not color:
            color = QtGui.QColor(colorName)
            if color.isValid():
                self.actualColorDict[colorName] = color
            else:
                return g.trace('unknown color name',colorName)

        # Clip the colorizing to the global bounds.
        offset = self.global_i
        lim_i,lim_j = self.global_i,self.global_j
        clip_i = max(i,lim_i)
        clip_j = min(j,lim_j)
        ok = clip_i &lt; clip_j

        if trace:
            kind = g.choose(ok,' ','***')
            s2 = g.choose(ok,s[clip_i:clip_j],all_s[i:j]) #### was self.s
            g.trace('%3s %3s %3s %3s %3s %3s %3s %s' % (
                kind,tag,offset,i,j,lim_i,lim_j,s2))

        if ok:
            self.highlighter.setFormat(clip_i-offset,clip_j-clip_i,color)
    #@nonl
    #@-node:ekr.20081206062411.14:setTag
    #@+node:ekr.20081205131308.24:updateSyntaxColorer
    def updateSyntaxColorer (self,p):

        trace = False
        p = p.copy()

        # self.flag is True unless an unambiguous @nocolor is seen.
        if trace: g.trace('1',self.flag,p,g.callers(5))
        self.flag = self.useSyntaxColoring(p)
        self.scanColorDirectives(p)
        if trace: g.trace('2',self.flag,p)
    #@nonl
    #@-node:ekr.20081205131308.24:updateSyntaxColorer
    #@+node:ekr.20081205131308.23:useSyntaxColoring
    def useSyntaxColoring (self,p):

        """Return True unless p is unambiguously under the control of @nocolor."""

        trace = False and not g.unitTesting
        if not p:
            if trace: g.trace('no p',repr(p))
            return False
        p = p.copy() ; first = p.copy()
        val = True ; self.killcolorFlag = False

        # New in Leo 4.6: @nocolor-node disables one node only.
        theDict = g.get_directives_dict(p)
        if 'nocolor-node' in theDict:
            if trace: g.trace('nocolor-node',p.h)
            return False

        for p in p.self_and_parents_iter():
            theDict = g.get_directives_dict(p)
            no_color = 'nocolor' in theDict
            color = 'color' in theDict
            kill_color = 'killcolor' in theDict
            # A killcolor anywhere disables coloring.
            if kill_color:
                if trace: g.trace('@killcolor',p.h)
                val = False ; self.killcolorFlag = True ; break
            # A color anywhere in the target enables coloring.
            if color and p == first:
                if trace: g.trace('@color',p.h)
                val = True ; break
            # Otherwise, the @nocolor specification must be unambiguous.
            elif no_color and not color:
                if trace: g.trace('@nocolor',p.h)
                val = False ; break
            elif color and not no_color:
                if trace: g.trace('@color',p.h)
                val = True ; break

        # g.trace(first.headString(),val)
        return val
    #@-node:ekr.20081205131308.23:useSyntaxColoring
    #@-others
#@-node:ekr.20081205131308.48:class jeditColorizer
#@-node:ekr.20081204090029.1:Syntax coloring
#@+node:ekr.20081121105001.515:Text widget classes
#@+node:ekr.20081121105001.516: class leoQtBaseTextWidget
class leoQtBaseTextWidget (leoFrame.baseTextWidget):

    #@    @+others
    #@+node:ekr.20081121105001.517: Birth
    #@+node:ekr.20081121105001.518:ctor (leoQtBaseTextWidget)
    def __init__ (self,widget,name='leoQtBaseTextWidget',c=None):

        self.widget = widget
        self.c = c or self.widget.c

        # Init the base class.
        leoFrame.baseTextWidget.__init__(
            self,c,baseClassName='leoQtBaseTextWidget',
            name=name,
            widget=widget,
            highLevelInterface=True)

        # Init ivars.
        self.tags = {}
        self.configDict = {} # Keys are tags, values are colors (names or values).
        self.useScintilla = False # This is used!

        if not c: return # Can happen.

        # Hook up qt events.
        self.ev_filter = leoQtEventFilter(c,w=self,tag='body')
        self.widget.installEventFilter(self.ev_filter)

        self.widget.connect(self.widget,
            QtCore.SIGNAL("textChanged()"),self.onTextChanged)

        self.widget.connect(self.widget,
            QtCore.SIGNAL("cursorPositionChanged()"),self.onClick)

        self.injectIvars(c)
    #@-node:ekr.20081121105001.518:ctor (leoQtBaseTextWidget)
    #@+node:ekr.20081121105001.519:injectIvars
    def injectIvars (self,name='1',parentFrame=None):

        w = self ; p = self.c.currentPosition()

        if name == '1':
            w.leo_p = w.leo_v = None # Will be set when the second editor is created.
        else:

            w.leo_p = p.copy()
            w.leo_v = w.leo_p.v

        w.leo_active = True

        # New in Leo 4.4.4 final: inject the scrollbar items into the text widget.
        w.leo_bodyBar = None
        w.leo_bodyXBar = None
        w.leo_chapter = None
        w.leo_frame = None
        w.leo_name = name
        w.leo_label = None
        w.leo_label_s = None
        w.leo_scrollBarSpot = None
        w.leo_insertSpot = None
        w.leo_selection = None

        return w
    #@-node:ekr.20081121105001.519:injectIvars
    #@-node:ekr.20081121105001.517: Birth
    #@+node:ekr.20081121105001.520: Do nothings
    def bind (self,stroke,command,**keys):
        pass # eventFilter handles all keys.
    #@-node:ekr.20081121105001.520: Do nothings
    #@+node:ekr.20081121105001.521: Must be defined in base class
    #@+node:ekr.20081121105001.522: Focus
    def getFocus(self):

        g.trace('leoQtBody',self.widget,g.callers(4))
        return g.app.gui.get_focus()

    findFocus = getFocus

    def hasFocus (self):

        val = self.widget == g.app.gui.get_focus(self.c)
        # g.trace('leoQtBody returns',val,self.widget,g.callers(4))
        return val

    def setFocus (self):

        # g.trace('leoQtBody',self.widget,g.callers(4))
        g.app.gui.set_focus(self.c,self.widget)
    #@-node:ekr.20081121105001.522: Focus
    #@+node:ekr.20081121105001.523: Indices
    def toPythonIndex (self,index):

        w = self

        if type(index) == type(99):
            return index
        elif index == '1.0':
            return 0
        elif index == 'end':
            return w.getLastPosition()
        else:
            # g.trace(repr(index))
            s = w.getAllText()
            data = index.split('.')
            if len(data) == 2:
                row,col = data
                row,col = int(row),int(col)
                i = g.convertRowColToPythonIndex(s,row-1,col)
                # g.trace(index,row,col,i,g.callers(6))
                return i
            else:
                g.trace('bad string index: %s' % index)
                return 0

    toGuiIndex = toPythonIndex
    #@-node:ekr.20081121105001.523: Indices
    #@+node:ekr.20081121105001.524: Text getters/settters
    #@+node:ekr.20081121105001.525:appendText
    def appendText(self,s):

        s2 = self.getAllText()
        self.setAllText(s2+s,insert=len(s2))

    #@-node:ekr.20081121105001.525:appendText
    #@+node:ekr.20081121105001.526:delete
    def delete (self,i,j=None):

        w = self.widget
        s = self.getAllText()

        i = self.toGuiIndex(i)
        if j is None: j = i+1
        j = self.toGuiIndex(j)
        if i &gt; j: i,j = j,i

        # g.trace('i',i,'j',j)

        s = s[:i] + s[j:]
        self.setAllText(s,insert=i)

        if i &gt; 0 or j &gt; 0: self.indexWarning('leoQtBody.delete')
        return i
    #@-node:ekr.20081121105001.526:delete
    #@+node:ekr.20081121105001.527:deleteTextSelection
    def deleteTextSelection (self):

        i,j = self.getSelectionRange()
        self.delete(i,j)
    #@-node:ekr.20081121105001.527:deleteTextSelection
    #@+node:ekr.20081121105001.528:get
    def get(self,i,j=None):

        w = self.widget
        s = self.getAllText()
        i = self.toGuiIndex(i)
        if j is None: j = i+1
        j = self.toGuiIndex(j)
        return s[i:j]
    #@-node:ekr.20081121105001.528:get
    #@+node:ekr.20081121105001.529:getLastPosition
    def getLastPosition(self):

        return len(self.getAllText())
    #@-node:ekr.20081121105001.529:getLastPosition
    #@+node:ekr.20081121105001.530:getSelectedText
    def getSelectedText(self):

        w = self.widget

        i,j = self.getSelectionRange()
        if i == j:
            return ''
        else:
            s = self.getAllText()
            # g.trace(repr(s[i:j]))
            return s[i:j]
    #@-node:ekr.20081121105001.530:getSelectedText
    #@+node:ekr.20081121105001.531:insert
    def insert(self,i,s):

        s2 = self.getAllText()
        i = self.toGuiIndex(i)
        self.setAllText(s2[:i] + s + s2[i:],insert=i+len(s))
        return i
    #@-node:ekr.20081121105001.531:insert
    #@+node:ekr.20081121105001.532:selectAllText
    def selectAllText(self,insert=None):

        w = self.widget
        w.selectAll()
        if insert is not None:
            self.setInsertPoint(insert)
        # g.trace('insert',insert)

    #@-node:ekr.20081121105001.532:selectAllText
    #@+node:ekr.20081121105001.533:setSelectionRange &amp; dummy helper
    def setSelectionRange(self,*args,**keys):

        # A kludge to allow a single arg containing i,j
        w = self.widget

        if len(args) == 1:
            i,j = args[0]
        elif len(args) == 2:
            i,j = args
        else:
            g.trace('can not happen',args)
        insert = keys.get('insert')
        i,j = self.toGuiIndex(i),self.toGuiIndex(j)
        if i &gt; j: i,j = j,i

        return self.setSelectionRangeHelper(i,j,insert)

        # g.trace('i',i,'j',j,'insert',insert,g.callers(4))

        # if self.useScintilla:
            # if i &gt; j: i,j = j,i
            # if insert in (j,None):
                # self.setInsertPoint(j)
                # w.SendScintilla(w.SCI_SETANCHOR,i)
            # else:
                # self.setInsertPoint(i)
                # w.SendScintilla(w.SCI_SETANCHOR,j)
        # else:
            # e = QtGui.QTextCursor
            # if i &gt; j: i,j = j,i
            # s = w.toPlainText()
            # i = max(0,min(i,len(s)))
            # j = max(0,min(j,len(s)))
            # k = max(0,min(j-i,len(s)))
            # cursor = w.textCursor()
            # if i == j:
                # cursor.setPosition(i)
            # elif insert in (j,None):
                # cursor.setPosition(i)
                # k = max(0,min(k,len(s)))
                # cursor.movePosition(e.Right,e.KeepAnchor,k)
            # else:
                # cursor.setPosition(j)
                # cursor.movePosition(e.Left,e.KeepAnchor,k)

            # w.setTextCursor(cursor)
    #@+node:ekr.20081121105001.534:setSelectionRangeHelper
    def setSelectionRangeHelper(self,i,j,insert):

        self.oops()
    #@-node:ekr.20081121105001.534:setSelectionRangeHelper
    #@-node:ekr.20081121105001.533:setSelectionRange &amp; dummy helper
    #@-node:ekr.20081121105001.524: Text getters/settters
    #@+node:ekr.20081121105001.535:getName (baseTextWidget)
    def getName (self):

        # g.trace('leoQtBaseTextWidget',self.name,g.callers())

        return self.name
    #@-node:ekr.20081121105001.535:getName (baseTextWidget)
    #@+node:ekr.20081208041503.499:onClick
    def onClick(self):

        c = self.c
        name = c.widget_name(self)

        if name.startswith('body'):
            if hasattr(c.frame,'statusLine'):
                c.frame.statusLine.update()
    #@-node:ekr.20081208041503.499:onClick
    #@+node:ekr.20081121105001.536:onTextChanged (qtTree)
    def onTextChanged (self):

        '''Update Leo after the body has been changed.

        self.selecting is guaranteed to be True during
        the entire selection process.'''

        trace = False ; verbose = False
        c = self.c ; p = c.currentPosition()
        tree = c.frame.tree ; w = self

        if tree.selecting:
            if trace and verbose: g.trace('selecting')
            return
        if tree.redrawing:
            if trace and verbose: g.trace('redrawing')
            return
        if not p:
            return g.trace('*** no p')

        newInsert = w.getInsertPoint()
        newSel = w.getSelectionRange()
        newText = w.getAllText() # Converts to unicode.

        # Get the previous values from the tnode.
        oldText = g.app.gui.toUnicode(p.v.t._bodyString)
        if oldText == newText:
            # This can happen as the result of undo.
            # g.trace('*** unexpected non-change',color="red")
            return

        if trace and verbose:
            g.trace(p.headString(),len(oldText),len(newText))

        oldIns  = p.v.t.insertSpot
        i,j = p.v.t.selectionStart,p.v.t.selectionLength
        oldSel  = (i,j-i)
        oldYview = None
        undoType = 'Typing'
        c.undoer.setUndoTypingParams(p,undoType,
            oldText=oldText,newText=newText,
            oldSel=oldSel,newSel=newSel,oldYview=oldYview)

        # Update the tnode.
        p.v.setBodyString(newText)
        p.v.t.insertSpot = newInsert
        i,j = newSel
        i,j = self.toGuiIndex(i),self.toGuiIndex(j)
        if i &gt; j: i,j = j,i
        p.v.t.selectionStart,p.v.t.selectionLength = (i,j-i)

        # No need to redraw the screen.
        if not self.useScintilla:
            c.recolor()
        if not c.changed and c.frame.initComplete:
            c.setChanged(True)
        c.frame.body.updateEditors()
        # This will be called by onBodyChanged.
        # c.frame.tree.updateIcon(p)
        c.incrementalRecolorFlag = True
        c.outerUpdate()
    #@-node:ekr.20081121105001.536:onTextChanged (qtTree)
    #@+node:ekr.20081121105001.537:indexWarning
    warningsDict = {}

    def indexWarning (self,s):

        return

        # if s not in self.warningsDict:
            # g.es_print('warning: using dubious indices in %s' % (s),color='red')
            # g.es_print('callers',g.callers(5))
            # self.warningsDict[s] = True
    #@-node:ekr.20081121105001.537:indexWarning
    #@-node:ekr.20081121105001.521: Must be defined in base class
    #@+node:ekr.20081121105001.538: May be overridden in subclasses
    def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75):
        pass

    def getYScrollPosition(self):
        return None # A flag

    def seeInsertPoint (self):
        self.see(self.getInsertPoint())

    def setYScrollPosition(self,pos):
        pass

    def scrollLines(self,n):
        pass

    #@+node:ekr.20081121105001.539:Configuration
    # Configuration will be handled by style sheets.
    def cget(self,*args,**keys):            return None
    def configure (self,*args,**keys):      pass
    def setBackgroundColor(self,color):     pass
    def setEditorColors (self,bg,fg):       pass
    def setForegroundColor(self,color):     pass
    #@-node:ekr.20081121105001.539:Configuration
    #@+node:ekr.20081121105001.540:Idle time
    def after_idle(self,func,threadCount):
        # g.trace(func.__name__,'threadCount',threadCount)
        return func(threadCount)

    def after(self,n,func,threadCount):
        def after_callback(func=func,threadCount=threadCount):
            # g.trace(func.__name__,threadCount)
            return func(threadCount)
        QtCore.QTimer.singleShot(n,after_callback)

    def scheduleIdleTimeRoutine (self,function,*args,**keys):
        g.trace()
        # if not g.app.unitTesting:
            # self.widget.after_idle(function,*args,**keys)
    #@-node:ekr.20081121105001.540:Idle time
    #@+node:ekr.20081121105001.541:Coloring (baseTextWidget)
    # These *are* used.

    def removeAllTags(self):
        s = self.getAllText()
        self.colorSelection(0,len(s),'black')

    def tag_names (self):
        return []
    #@+node:ekr.20081121105001.542:colorSelection
    def colorSelection (self,i,j,colorName):

        g.trace()

        w = self.widget
        if not colorName: return
        if g.unitTesting: return

    #@+at
    #     # Unlike Tk names, Qt names don't end in a digit.
    #     if colorName[-1].isdigit() and colorName[0] != '#':
    #         color = QtGui.QColor(colorName[:-1])
    #     else:
    #         color = QtGui.QColor(colorName)
    #@-at
    #@@c
        color = QtGui.QColor(leoColor.getColor(colorName, 'black'))
        if not color.isValid():
            # g.trace('unknown color name',colorName)
            return

        sb = w.verticalScrollBar()
        pos = sb.sliderPosition()
        old_i,old_j = self.getSelectionRange()
        old_ins = self.getInsertPoint()
        self.setSelectionRange(i,j)
        w.setTextColor(color)
        self.setSelectionRange(old_i,old_j,insert=old_ins)
        sb.setSliderPosition(pos)
    #@-node:ekr.20081121105001.542:colorSelection
    #@+node:ekr.20081124102726.10:tag_add
    def tag_add(self,tag,x1,x2):

        g.trace(tag)

        val = self.configDict.get(tag)
        if val:
            self.colorSelection(x1,x2,val)
    #@-node:ekr.20081124102726.10:tag_add
    #@+node:ekr.20081124102726.11:tag_config &amp; tag_configure
    def tag_config (self,*args,**keys):

        if len(args) == 1:
            key = args[0]
            self.tags[key] = keys
            val = keys.get('foreground')
            if val:
                # g.trace(key,val)
                self.configDict [key] = val
        else:
            g.trace('oops',args,keys)

    tag_configure = tag_config
    #@-node:ekr.20081124102726.11:tag_config &amp; tag_configure
    #@-node:ekr.20081121105001.541:Coloring (baseTextWidget)
    #@-node:ekr.20081121105001.538: May be overridden in subclasses
    #@+node:ekr.20081121105001.543: Must be overridden in subclasses
    # These methods avoid calls to setAllText.

    # Allow the base-class method for headlines.
    # def delete(self,i,j=None):              self.oops()
    # def insert(self,i,s):                   self.oops()

    def getAllText(self):                   self.oops()
    def getInsertPoint(self):               self.oops()
    def getSelectionRange(self,sort=True):  self.oops()
    def hasSelection(self):                 self.oops()
    def see(self,i):                        self.oops()
    def setAllText(self,s,insert=None):     self.oops()
    def setInsertPoint(self,i):             self.oops()
    #@-node:ekr.20081121105001.543: Must be overridden in subclasses
    #@-others
#@-node:ekr.20081121105001.516: class leoQtBaseTextWidget
#@+node:ekr.20081121105001.544: class leoQLineEditWidget (leoQtBaseTextWidget)
class leoQLineEditWidget (leoQtBaseTextWidget):

    #@    @+others
    #@+node:ekr.20081121105001.545:Birth
    #@+node:ekr.20081121105001.546:ctor
    def __init__ (self,widget,name,c=None):

        # Init the base class.
        leoQtBaseTextWidget.__init__(self,widget,name,c=c)

        self.baseClassName='leoQLineEditWidget'

        # g.trace('leoQLineEditWidget',id(widget),g.callers(4))

        self.setConfig()
        self.setFontFromConfig()
        self.setColorFromConfig()
    #@-node:ekr.20081121105001.546:ctor
    #@+node:ekr.20081121105001.547:setFontFromConfig
    def setFontFromConfig (self,w=None):

        '''Set the font in the widget w (a body editor).'''

        return

        # c = self.c
        # if not w: w = self.widget

        # font = c.config.getFontFromParams(
            # "head_text_font_family", "head_text_font_size",
            # "head_text_font_slant",  "head_text_font_weight",
            # c.config.defaultBodyFontSize)

        # self.fontRef = font # ESSENTIAL: retain a link to font.
        # # w.configure(font=font)

        # # g.trace("BODY",body.cget("font"),font.cget("family"),font.cget("weight"))
    #@-node:ekr.20081121105001.547:setFontFromConfig
    #@+node:ekr.20081121105001.548:setColorFromConfig
    def setColorFromConfig (self,w=None):

        '''Set the font in the widget w (a body editor).'''

        return

        # c = self.c
        # if w is None: w = self.widget

        # bg = c.config.getColor("body_text_background_color") or 'white'
        # try:
            # pass ### w.configure(bg=bg)
        # except:
            # g.es("exception setting body text background color")
            # g.es_exception()

        # fg = c.config.getColor("body_text_foreground_color") or 'black'
        # try:
            # pass ### w.configure(fg=fg)
        # except:
            # g.es("exception setting body textforeground color")
            # g.es_exception()

        # bg = c.config.getColor("body_insertion_cursor_color")
        # if bg:
            # try:
                # pass ### w.configure(insertbackground=bg)
            # except:
                # g.es("exception setting body pane cursor color")
                # g.es_exception()

        # sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
        # try:
            # pass ### w.configure(selectbackground=sel_bg)
        # except Exception:
            # g.es("exception setting body pane text selection background color")
            # g.es_exception()

        # sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
        # try:
            # pass ### w.configure(selectforeground=sel_fg)
        # except Exception:
            # g.es("exception setting body pane text selection foreground color")
            # g.es_exception()

        # # if sys.platform != "win32": # Maybe a Windows bug.
            # # fg = c.config.getColor("body_cursor_foreground_color")
            # # bg = c.config.getColor("body_cursor_background_color")
            # # if fg and bg:
                # # cursor="xterm" + " " + fg + " " + bg
                # # try:
                    # # pass ### w.configure(cursor=cursor)
                # # except:
                    # # import traceback ; traceback.print_exc()
    #@-node:ekr.20081121105001.548:setColorFromConfig
    #@+node:ekr.20081121105001.549:setConfig
    def setConfig (self):
        pass
    #@nonl
    #@-node:ekr.20081121105001.549:setConfig
    #@-node:ekr.20081121105001.545:Birth
    #@+node:ekr.20081121105001.550:Widget-specific overrides (QLineEdit)
    #@+node:ekr.20081121105001.551:getAllText
    def getAllText(self):

        w = self.widget
        s = w.text()
        return g.app.gui.toUnicode(s)
    #@nonl
    #@-node:ekr.20081121105001.551:getAllText
    #@+node:ekr.20081121105001.552:getInsertPoint
    def getInsertPoint(self):

        i = self.widget.cursorPosition()
        # g.trace(i)
        return i
    #@-node:ekr.20081121105001.552:getInsertPoint
    #@+node:ekr.20081121105001.553:getSelectionRange
    def getSelectionRange(self,sort=True):

        w = self.widget

        if w.hasSelectedText():
            i = w.selectionStart()
            s = w.selectedText()
            s = g.app.gui.toUnicode(s)
            j = i + len(s)
        else:
            i = j = w.cursorPosition()

        # g.trace(i,j)
        return i,j
    #@-node:ekr.20081121105001.553:getSelectionRange
    #@+node:ekr.20081121105001.554:hasSelection
    def hasSelection(self):

        return self.widget.hasSelection()
    #@-node:ekr.20081121105001.554:hasSelection
    #@+node:ekr.20081121105001.555:see &amp; seeInsertPoint
    def see(self,i):
        pass

    def seeInsertPoint (self):
        pass
    #@-node:ekr.20081121105001.555:see &amp; seeInsertPoint
    #@+node:ekr.20081121105001.556:setAllText
    def setAllText(self,s,insert=None):

        w = self.widget
        i = g.choose(insert is None,0,insert)
        w.setText(s)
        if insert is not None:
            self.setSelectionRange(i,i,insert=i)
    #@nonl
    #@-node:ekr.20081121105001.556:setAllText
    #@+node:ekr.20081121105001.557:setInsertPoint
    def setInsertPoint(self,i):

        w = self.widget
        s = w.text()
        s = g.app.gui.toUnicode(s)
        i = max(0,min(i,len(s)))
        w.setCursorPosition(i)
    #@-node:ekr.20081121105001.557:setInsertPoint
    #@+node:ekr.20081121105001.558:setSelectionRangeHelper
    def setSelectionRangeHelper(self,i,j,insert):

        w = self.widget
        # g.trace('i',i,'j',j,'insert',insert,g.callers(4))
        if i &gt; j: i,j = j,i
        s = w.text()
        s = g.app.gui.toUnicode(s)
        i = max(0,min(i,len(s)))
        j = max(0,min(j,len(s)))
        k = max(0,min(j-i,len(s)))
        if i == j:
            w.setCursorPosition(i)
        else:
            w.setSelection(i,k)
    #@-node:ekr.20081121105001.558:setSelectionRangeHelper
    #@-node:ekr.20081121105001.550:Widget-specific overrides (QLineEdit)
    #@-others
#@-node:ekr.20081121105001.544: class leoQLineEditWidget (leoQtBaseTextWidget)
#@+node:ekr.20081121105001.559: class leoQScintillaWidget
class leoQScintillaWidget (leoQtBaseTextWidget):

    #@    @+others
    #@+node:ekr.20081121105001.560:Birth
    #@+node:ekr.20081121105001.561:ctor
    def __init__ (self,widget,name,c=None):

        # Init the base class.
        leoQtBaseTextWidget.__init__(self,widget,name,c=c)

        self.baseClassName='leoQScintillaWidget'

        self.useScintilla = True
        self.setConfig()
    #@-node:ekr.20081121105001.561:ctor
    #@+node:ekr.20081121105001.562:setConfig
    def setConfig (self):

        c = self.c ; w = self.widget
        tag = 'qt-scintilla-styles'
        qcolor,qfont = QtGui.QColor,QtGui.QFont

        def oops(s): g.trace('bad @data %s: %s' % (tag,s))

        # To do: make this configurable the leo way
        if 0: # Suppress lexing.
            w.setLexer()
            lexer = w.lexer()
        else:
            lexer = Qsci.QsciLexerPython(w)
            # A small font size, to be magnified.
            font = qfont("Courier New",8,qfont.Bold)
            lexer.setFont(font)
            table = None
            aList = c.config.getData('qt-scintilla-styles')
            if aList:
                aList = [s.split(',') for s in aList]
                table = []
                for z in aList:
                    if len(z) == 2:
                        color,style = z
                        table.append((color.strip(),style.strip()),)
                    else: oops('entry: %s' % z)
                # g.trace(g.printList(table))

            if not table:
                table = (
                    ('red','Comment'),
                    ('green','SingleQuotedString'),
                    ('green','DoubleQuotedString'),
                    ('green','TripleSingleQuotedString'),
                    ('green','TripleDoubleQuotedString'),
                    ('green','UnclosedString'),
                    ('blue','Keyword'),
                )
            for color,style in table:
                if hasattr(lexer,style):
                    style = getattr(lexer,style)
                    try:
                        lexer.setColor(qcolor(color),style)
                    except Exception:
                        oops('bad color: %s' % color)
                else: oops('bad style: %s' % style)

        w.setLexer(lexer)

        n = c.config.getInt('qt-scintilla-zoom-in')
        if n not in (None,0): w.zoomIn(n)

        w.setIndentationWidth(4)
        w.setIndentationsUseTabs(False)
        w.setAutoIndent(True)
    #@-node:ekr.20081121105001.562:setConfig
    #@-node:ekr.20081121105001.560:Birth
    #@+node:ekr.20081121105001.563:Widget-specific overrides (QScintilla)
    #@+node:ekr.20081121105001.564:getAllText
    def getAllText(self):

        w = self.widget
        s = w.text()
        s = g.app.gui.toUnicode(s)
        return s
    #@-node:ekr.20081121105001.564:getAllText
    #@+node:ekr.20081121105001.565:getInsertPoint
    def getInsertPoint(self):

        w = self.widget
        s = self.getAllText()
        row,col = w.getCursorPosition()  
        i = g.convertRowColToPythonIndex(s, row, col)
        return i
    #@-node:ekr.20081121105001.565:getInsertPoint
    #@+node:ekr.20081121105001.566:getSelectionRange
    def getSelectionRange(self,sort=True):

        w = self.widget

        if w.hasSelectedText():
            s = self.getAllText()
            row_i,col_i,row_j,col_j = w.getSelection()
            i = g.convertRowColToPythonIndex(s, row_i, col_i)
            j = g.convertRowColToPythonIndex(s, row_j, col_j)
            if sort and i &gt; j: sel = j,i
        else:
            i = j = self.getInsertPoint()

        return i,j

    #@-node:ekr.20081121105001.566:getSelectionRange
    #@+node:ekr.20081121105001.567:hasSelection
    def hasSelection(self):

        return self.widget.hasSelectedText()
    #@-node:ekr.20081121105001.567:hasSelection
    #@+node:ekr.20081121105001.568:see
    def see(self,i):

        # Ok for now.  Using SCI_SETYCARETPOLICY might be better.
        w = self.widget
        s = self.getAllText()
        row,col = g.convertPythonIndexToRowCol(s,i)
        w.ensureLineVisible(row)

    # Use base-class method for seeInsertPoint.
    #@nonl
    #@-node:ekr.20081121105001.568:see
    #@+node:ekr.20081121105001.569:setAllText
    def setAllText(self,s,insert=None):

        '''Set the text of the widget.

        If insert is None, the insert point, selection range and scrollbars are initied.
        Otherwise, the scrollbars are preserved.'''

        w = self.widget
        w.setText(s)

    #@-node:ekr.20081121105001.569:setAllText
    #@+node:ekr.20081121105001.570:setInsertPoint
    def setInsertPoint(self,i):

        w = self.widget
        w.SendScintilla(w.SCI_SETCURRENTPOS,i)
        w.SendScintilla(w.SCI_SETANCHOR,i)
    #@-node:ekr.20081121105001.570:setInsertPoint
    #@+node:ekr.20081121105001.571:setSelectionRangeHelper
    def setSelectionRangeHelper(self,i,j,insert):

        w = self.widget

        # g.trace('i',i,'j',j,'insert',insert,g.callers(4))

        if insert in (j,None):
            self.setInsertPoint(j)
            w.SendScintilla(w.SCI_SETANCHOR,i)
        else:
            self.setInsertPoint(i)
            w.SendScintilla(w.SCI_SETANCHOR,j)
    #@-node:ekr.20081121105001.571:setSelectionRangeHelper
    #@-node:ekr.20081121105001.563:Widget-specific overrides (QScintilla)
    #@-others
#@-node:ekr.20081121105001.559: class leoQScintillaWidget
#@+node:ekr.20081121105001.572: class leoQTextEditWidget
class leoQTextEditWidget (leoQtBaseTextWidget):

    #@    @+others
    #@+node:ekr.20081121105001.573:Birth
    #@+node:ekr.20081121105001.574:ctor
    def __init__ (self,widget,name,c=None):

        # Init the base class.
        leoQtBaseTextWidget.__init__(self,widget,name,c=c)

        self.baseClassName='leoQTextEditWidget'

        widget.setUndoRedoEnabled(False)

        self.setConfig()
        self.setFontFromConfig()
        self.setColorFromConfig()
    #@-node:ekr.20081121105001.574:ctor
    #@+node:ekr.20081121105001.575:setFontFromConfig
    def setFontFromConfig (self,w=None):

        '''Set the font in the widget w (a body editor).'''

        c = self.c
        if not w: w = self.widget

        font = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize)

        self.fontRef = font # ESSENTIAL: retain a link to font.
        # w.configure(font=font)

        # g.trace("BODY",body.cget("font"),font.cget("family"),font.cget("weight"))
    #@-node:ekr.20081121105001.575:setFontFromConfig
    #@+node:ekr.20081121105001.576:setColorFromConfig
    def setColorFromConfig (self,w=None):

        '''Set the font in the widget w (a body editor).'''

        c = self.c
        if w is None: w = self.widget

        bg = c.config.getColor("body_text_background_color") or 'white'
        try:
            pass ### w.configure(bg=bg)
        except:
            g.es("exception setting body text background color")
            g.es_exception()

        fg = c.config.getColor("body_text_foreground_color") or 'black'
        try:
            pass ### w.configure(fg=fg)
        except:
            g.es("exception setting body textforeground color")
            g.es_exception()

        bg = c.config.getColor("body_insertion_cursor_color")
        if bg:
            try:
                pass ### w.configure(insertbackground=bg)
            except:
                g.es("exception setting body pane cursor color")
                g.es_exception()

        sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
        try:
            pass ### w.configure(selectbackground=sel_bg)
        except Exception:
            g.es("exception setting body pane text selection background color")
            g.es_exception()

        sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
        try:
            pass ### w.configure(selectforeground=sel_fg)
        except Exception:
            g.es("exception setting body pane text selection foreground color")
            g.es_exception()

        # if sys.platform != "win32": # Maybe a Windows bug.
            # fg = c.config.getColor("body_cursor_foreground_color")
            # bg = c.config.getColor("body_cursor_background_color")
            # if fg and bg:
                # cursor="xterm" + " " + fg + " " + bg
                # try:
                    # pass ### w.configure(cursor=cursor)
                # except:
                    # import traceback ; traceback.print_exc()
    #@-node:ekr.20081121105001.576:setColorFromConfig
    #@+node:ekr.20081121105001.577:setConfig
    def setConfig (self):

        c = self.c ; w = self.widget

        n = c.config.getInt('qt-rich-text-zoom-in')

        w.setWordWrapMode(QtGui.QTextOption.NoWrap)

        # w.zoomIn(1)
        # w.updateMicroFocus()
        if n not in (None,0):
            # This only works when there is no style sheet.
            # g.trace('zoom-in',n)
            w.zoomIn(n)
            w.updateMicroFocus()
    #@-node:ekr.20081121105001.577:setConfig
    #@-node:ekr.20081121105001.573:Birth
    #@+node:ekr.20081121105001.578:Widget-specific overrides (QTextEdit)
    #@+node:ekr.20090205153624.11:delete (avoid call to setAllText)
    def delete(self,i,j=None):

        trace = False and not g.unitTesting
        c,w = self.c,self.widget
        colorer = c.frame.body.colorizer.highlighter.colorer
        n = colorer.recolorCount

        i = self.toGuiIndex(i)
        if j is None: j = i+1
        j = self.toGuiIndex(j)

        # Set a hook for the colorer.
        colorer.initFlag = True

        sb = w.verticalScrollBar()
        pos = sb.sliderPosition()
        cursor = w.textCursor()
        cursor.setPosition(i)
        moveCount = abs(j-i)
        cursor.movePosition(cursor.Right,cursor.KeepAnchor,moveCount)
        cursor.removeSelectedText()
        sb.setSliderPosition(pos)

        if trace:
            g.trace('%s calls to recolor' % (
                colorer.recolorCount-n))
    #@-node:ekr.20090205153624.11:delete (avoid call to setAllText)
    #@+node:ekr.20081121105001.579:flashCharacter (leoQTextEditWidget)
    def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75):

        # This might causes problems during unit tests.
        # The selection point isn't restored in time.
        if g.app.unitTesting: return

        w = self.widget # A QTextEdit.
        e = QtGui.QTextCursor

        def after(func):
            QtCore.QTimer.singleShot(delay,func)

        def addFlashCallback(self=self,w=w):
            n,i = self.flashCount,self.flashIndex

            cursor = w.textCursor() # Must be the widget's cursor.
            cursor.setPosition(i)
            cursor.movePosition(e.Right,e.KeepAnchor,1)

            extra = w.ExtraSelection()
            extra.cursor = cursor
            if self.flashBg: extra.format.setBackground(QtGui.QColor(self.flashBg))
            if self.flashFg: extra.format.setForeground(QtGui.QColor(self.flashFg))
            self.extraSelList = [extra] # keep the reference.
            w.setExtraSelections(self.extraSelList)

            self.flashCount -= 1
            after(removeFlashCallback)

        def removeFlashCallback(self=self,w=w):
            w.setExtraSelections([])
            if self.flashCount &gt; 0:
                after(addFlashCallback)
            else:
                w.setFocus()

        # g.trace(flashes,fg,bg)
        self.flashCount = flashes
        self.flashIndex = i
        self.flashBg = g.choose(bg.lower()=='same',None,bg)
        self.flashFg = g.choose(fg.lower()=='same',None,fg)

        addFlashCallback()
    #@-node:ekr.20081121105001.579:flashCharacter (leoQTextEditWidget)
    #@+node:ekr.20081121105001.580:getAllText (leoQTextEditWidget)
    def getAllText(self):

        w = self.widget
        s = w.toPlainText()
        # g.trace(len(s),g.callers(5))
        return unicode(s)
    #@nonl
    #@-node:ekr.20081121105001.580:getAllText (leoQTextEditWidget)
    #@+node:ekr.20081121105001.581:getInsertPoint
    def getInsertPoint(self):

        return self.widget.textCursor().position()
    #@-node:ekr.20081121105001.581:getInsertPoint
    #@+node:ekr.20081121105001.582:getSelectionRange
    def getSelectionRange(self,sort=True):

        w = self.widget
        tc = w.textCursor()
        i,j = tc.selectionStart(),tc.selectionEnd()
        # g.trace(i,j,g.callers(4))
        return i,j
    #@nonl
    #@-node:ekr.20081121105001.582:getSelectionRange
    #@+node:ekr.20081121105001.583:getYScrollPosition
    def getYScrollPosition(self):

        w = self.widget
        sb = w.verticalScrollBar()
        i = sb.sliderPosition()

        # Return a tuple, only the first of which is used.
        return i,i 
    #@-node:ekr.20081121105001.583:getYScrollPosition
    #@+node:ekr.20081121105001.584:hasSelection
    def hasSelection(self):

        return self.widget.textCursor().hasSelection()
    #@-node:ekr.20081121105001.584:hasSelection
    #@+node:ekr.20090205153624.12:insert (avoid call to setAllText)
    def insert(self,i,s):

        trace = False and not g.unitTesting
        c,w = self.c,self.widget
        colorer = c.frame.body.colorizer.highlighter.colorer
        n = colorer.recolorCount

        # Set a hook for the colorer.
        colorer.initFlag = True

        i = self.toGuiIndex(i)

        sb = w.verticalScrollBar()
        pos = sb.sliderPosition()
        cursor = w.textCursor()
        cursor.setPosition(i)
        cursor.insertText(s) # This cause an incremental call to recolor.
        sb.setSliderPosition(pos)

        if trace:
            g.trace('%s calls to recolor' % (
                colorer.recolorCount-n))
    #@-node:ekr.20090205153624.12:insert (avoid call to setAllText)
    #@+node:ekr.20081121105001.585:see
    def see(self,i):

        self.widget.ensureCursorVisible()
    #@nonl
    #@-node:ekr.20081121105001.585:see
    #@+node:ekr.20081121105001.586:seeInsertPoint
    def seeInsertPoint (self):

        self.widget.ensureCursorVisible()
    #@-node:ekr.20081121105001.586:seeInsertPoint
    #@+node:ekr.20081121105001.587:setAllText
    def setAllText(self,s,insert=None):

        '''Set the text of the widget.

        If insert is None, the insert point, selection range and scrollbars are initied.
        Otherwise, the scrollbars are preserved.'''

        trace = False and not g.unitTesting
        c,w = self.c,self.widget
        colorer = c.frame.body.colorizer.highlighter.colorer
        n = colorer.recolorCount

        # Set a hook for the colorer.
        colorer.initFlag = True

        sb = w.verticalScrollBar()
        if insert is None: i,pos = 0,0
        else: i,pos = insert,sb.sliderPosition()
        w.setPlainText(s)
        self.setSelectionRange(i,i,insert=i)
        sb.setSliderPosition(pos)

        if trace:
            g.trace('%s calls to recolor' % (
                colorer.recolorCount-n))
    #@-node:ekr.20081121105001.587:setAllText
    #@+node:ekr.20081121105001.588:setInsertPoint
    def setInsertPoint(self,i):

        w = self.widget
        s = w.toPlainText()
        cursor = w.textCursor()
        i = max(0,min(i,len(s)))
        cursor.setPosition(i)
        w.setTextCursor(cursor)
    #@-node:ekr.20081121105001.588:setInsertPoint
    #@+node:ekr.20081121105001.589:setSelectionRangeHelper &amp; helper
    def setSelectionRangeHelper(self,i,j,insert):

        w = self.widget
        # g.trace('i',i,'j',j,'insert',insert,g.callers(4))
        e = QtGui.QTextCursor
        if i &gt; j: i,j = j,i
        n = self.lengthHelper()
        # s = w.toPlainText() ; n = len(s)
        i = max(0,min(i,n))
        j = max(0,min(j,n))
        k = max(0,min(j-i,n))
        cursor = w.textCursor()
        if i == j:
            cursor.setPosition(i)
        elif insert in (j,None):
            cursor.setPosition(i)
            cursor.movePosition(e.Right,e.KeepAnchor,k)
        else:
            cursor.setPosition(j)
            cursor.movePosition(e.Left,e.KeepAnchor,k)

        w.setTextCursor(cursor)
    #@+node:ekr.20081121105001.590:lengthHelper
    def lengthHelper(self):

        '''Return the length of the text.'''

        w = self.widget
        cursor = w.textCursor()
        cursor.movePosition(QtGui.QTextCursor.End)
        n = cursor.position()
        return n

    #@-node:ekr.20081121105001.590:lengthHelper
    #@-node:ekr.20081121105001.589:setSelectionRangeHelper &amp; helper
    #@+node:ekr.20081121105001.591:setYScrollPosition
    def setYScrollPosition(self,pos):

        w = self.widget
        sb = w.verticalScrollBar()
        if pos is None: pos = 0
        elif type(pos) == types.TupleType:
            pos = pos[0]
        sb.setSliderPosition(pos)
    #@-node:ekr.20081121105001.591:setYScrollPosition
    #@-node:ekr.20081121105001.578:Widget-specific overrides (QTextEdit)
    #@-others
#@-node:ekr.20081121105001.572: class leoQTextEditWidget
#@+node:ekr.20081121105001.592:class leoQtHeadlineWidget
class leoQtHeadlineWidget (leoQLineEditWidget):

    def __repr__ (self):
        return 'leoQLineEditWidget: %s' % id(self)
#@nonl
#@-node:ekr.20081121105001.592:class leoQtHeadlineWidget
#@+node:ekr.20081121105001.593:class findTextWrapper
class findTextWrapper (leoQLineEditWidget):

    '''A class representing the find/change edit widgets.'''

    pass
#@-node:ekr.20081121105001.593:class findTextWrapper
#@+node:ekr.20081121105001.594:class leoQtMinibuffer (leoQLineEditWidget)
class leoQtMinibuffer (leoQLineEditWidget):

    def __init__ (self,c):
        self.c = c
        w = c.frame.top.ui.lineEdit # QLineEdit
        # Init the base class.
        leoQLineEditWidget.__init__(self,widget=w,name='minibuffer',c=c)

        self.ev_filter = leoQtEventFilter(c,w=self,tag='minibuffer')
        w.installEventFilter(self.ev_filter)

    def setBackgroundColor(self,color):
        self.widget.setStyleSheet('background-color:%s' % color)

    def setForegroundColor(self,color):
        pass
#@-node:ekr.20081121105001.594:class leoQtMinibuffer (leoQLineEditWidget)
#@-node:ekr.20081121105001.515:Text widget classes
#@-others
#@-node:ekr.20081121105001.188:@thin qtGui.py
#@-leo
</t>
<t tx="ekr.20090217151906.1">@others</t>
<t tx="ekr.20090218112656.1"># 'self' is now defined in @test and @suite nodes.
a,b = 1,2
self.assertEqual(a,b)</t>
<t tx="ekr.20090218121844.1">#changed 2

def child():
    pass</t>
<t tx="ekr.20090304073837.1">import PyQt4.QtGui as QtGui
w = c.frame.tree.treeWidget
item = w.currentItem()
w.editItem(item)
e = w.itemWidget(item,0)
print item,e
if 1:
    w.closeEditor(e,QtGui.QAbstractItemDelegate.NoHint)
    w.setCurrentItem(item)</t>
<t tx="ekr.20090304173642.1">new_node = c.p.insertAsLastChild()
new_node.initHeadString("I am a new node")
new_node.moveAfter(c.rootPosition())
c.redraw()</t>
</tnodes>
</leo_file>
