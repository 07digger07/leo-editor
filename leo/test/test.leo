<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.50" body_secondary_ratio="0.53">
	<global_window_position top="30" left="461" height="1011" width="1198"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070416075121"><vh>Startup</vh>
<v t="ekr.20070224123943"><vh>@settings</vh>
<v t="ekr.20100118190256.2014"><vh> Chapters</vh>
<v t="ekr.20070604100125"><vh>@bool use_chapter_tabs = True</vh></v>
<v t="ekr.20070503085527"><vh>@bool use_chapters = True</vh></v>
</v>
<v t="ekr.20100118190256.2015"><vh> Files &amp; directories</vh>
<v t="ekr.20080822153619.1"><vh>@string shadow_subdir = .leo/shadow</vh></v>
<v t="ekr.20080922164255.1"><vh>@string test = c:\leo.repo\trunk\leo\test</vh></v>
</v>
<v t="ekr.20080729153237.1"><vh> Gc settings</vh>
<v t="ekr.20080729153237.2"><vh>@bool trace_gc = False</vh></v>
<v t="ekr.20080729153237.3"><vh>@bool trace_gc_calls = False</vh></v>
<v t="ekr.20080729153237.4"><vh>@bool trace_gc_verbose = False</vh></v>
</v>
<v t="ekr.20080529111617.1"><vh> Plugins</vh>
<v t="ekr.20070723091227"><vh>http plugin</vh>
<v t="ekr.20070723091227.1"><vh>@bool http_active = True</vh></v>
<v t="ekr.20070723091227.2"><vh>@int</vh>
<v t="ekr.20090316115500.1"><vh>port = 8080</vh></v>
</v>
<v t="ekr.20070723091227.3"><vh>@string rst_http_attributename = 'rst_http_attribute'</vh></v>
</v>
<v t="ekr.20080529111617.2"><vh>cleo</vh>
<v t="ekr.20080529111617.3"><vh>@color cleo_color_prog_green =</vh></v>
<v t="ekr.20080529111617.4"><vh>@color cleo_color_prog_red =</vh></v>
<v t="ekr.20080529111617.5"><vh>@data cleo_color_file_node_list</vh></v>
<v t="ekr.20080529111617.6"><vh>@int cleo_prog_width = 18</vh></v>
<v t="ekr.20080529111617.7"><vh>@float cleo_time_init = 1.0</vh></v>
<v t="ekr.20080529111617.8"><vh>@int cleo_prog_scale = 1</vh></v>
<v t="ekr.20080529111617.9"><vh>@float cleo_prog_extra = 4</vh></v>
<v t="ekr.20080529111617.10"><vh>@string cleo_time_name = 'days'</vh></v>
</v>
</v>
<v t="ekr.20100118190256.2012"><vh> Syntax coloring</vh>
<v t="ekr.20100118141712.2011"><vh>@@int qt_tab_width = 80</vh></v>
<v t="ekr.20100118122048.2003"><vh>@@font python keyword1 fonts</vh></v>
<v t="ekr.20100118133026.2008"><vh>@@font python keyword3 fonts</vh></v>
<v t="ekr.20100119095312.2041"><vh>@font rest keyword2 fonts</vh></v>
<v t="ekr.20100119100926.2046"><vh>@font rest keyword4 fonts</vh></v>
<v t="ekr.20100330084954.2125"><vh>@color pseudoplain_operator_color = blue</vh></v>
</v>
<v t="ekr.20100118190256.2016"><vh> Vim</vh>
<v t="ekr.20090815161520.1815"><vh>@string vim_trigger_event = select2</vh></v>
<v t="ekr.20080604104453.5"><vh>@strings [command,insert, overwrite] top_level_unbound_key_action = insert</vh></v>
</v>
<v t="ekr.20100118190256.2013"><vh> Windows</vh>
<v t="ekr.20100507151756.2123"><vh>@string qt-toolbar-location=top</vh></v>
<v t="ekr.20090629105832.1790"><vh>@@bool big_outline_pane = True</vh></v>
<v t="ekr.20080412082246.1"><vh>@bool fixedWindow = False</vh></v>
</v>
<v t="ekr.20091230064146.1911"><vh>@data import_xml_tags</vh></v>
<v t="ekr.20071025193940"><vh>@enabled-plugins</vh></v>
</v>
<v t="ekr.20041001211817"><vh>Buttons</vh>
<v t="ekr.20080915095329.1"><vh>@@button rst3</vh></v>
<v t="ekr.20090819085532.4265"><vh>@button detach-body</vh></v>
<v t="ekr.20090718072135.1786"><vh>@button print sep</vh></v>
<v t="ekr.20090715064044.1782"><vh>@button render-as-sphinx</vh></v>
<v t="ekr.20090521070342.1907"><vh>@button show-rst</vh></v>
<v t="ekr.20070531102813"><vh>Disabled buttons</vh>
<v t="ekr.20060814111542"><vh>@@button add-e</vh></v>
<v t="ekr.20080813100905.1"><vh>@@button args-test @args = a,b,c</vh></v>
<v t="ekr.20060918083159"><vh>@@button Clear uAs</vh></v>
<v t="ekr.20071002150320"><vh>@@button create-canvas</vh></v>
<v t="ekr.20060809084033"><vh>@@button cvt to g.et</vh>
<v t="ekr.20060809104405"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20060809092023"><vh>test</vh>
<v t="ekr.20060809103738"><vh>test1</vh></v>
<v t="ekr.20060809103738.1"><vh>test2</vh></v>
</v>
<v t="ekr.20060809090508"><vh>replace</vh>
<v t="ekr.20060809091749.72"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="ekr.20060809091749.73"><vh>&lt;&lt; handle g.es &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070531104646"><vh>@@button da-comp</vh></v>
<v t="ekr.20070531103315"><vh>@@button da-expand</vh></v>
<v t="ekr.20081025105942.1"><vh>@@button dir</vh></v>
<v t="ekr.20070530072113"><vh>@@button hide-ch</vh></v>
<v t="ekr.20061030041200"><vh>@@button iron-py @key=Alt-5</vh></v>
<v t="ekr.20071025192258"><vh>@@button local-tests @key=Alt+4</vh></v>
<v t="ekr.20071006084354"><vh>@@button print tk line number</vh></v>
<v t="ekr.20080105115712"><vh>@@button pylint</vh>
<v t="ekr.20080115085447"><vh>harmless warnings, errors</vh></v>
<v t="ekr.20080105130903"><vh>warnings</vh></v>
<v t="ekr.20080105120559"><vh>&lt;&lt; define data &gt;&gt;</vh></v>
</v>
<v t="ekr.20070515073111"><vh>@@button sep</vh></v>
<v t="ekr.20060427103457"><vh>@@button settings.leo</vh></v>
<v t="ekr.20080310111916.1"><vh>@@button Translate "can not" to "can't"</vh></v>
<v t="ekr.20070115092430"><vh>@@button winpdb</vh></v>
<v t="ekr.20080815073750.1"><vh>@@button write-nosent-files</vh></v>
<v t="ekr.20071128122043"><vh>@@command create-shell-tab @key = Alt+5</vh></v>
<v t="ekr.20070604095313"><vh>Chapter buttons</vh>
<v t="ekr.20070530072113.1"><vh>@@button show-ch</vh></v>
<v t="ekr.20070603175054.1"><vh>@@button ch-main</vh></v>
<v t="ekr.20070603175054"><vh>@@button ch-abc</vh></v>
<v t="ekr.20070603190713.1"><vh>@@button ch-xyz</vh></v>
<v t="ekr.20070603190713"><vh>@@button ch-add-xyz</vh></v>
</v>
<v t="ekr.20060904110922"><vh>OPML buttons</vh>
<v t="ekr.20060904111037.1"><vh>@@button opml-write</vh></v>
<v t="ekr.20060904111037"><vh>@@button opml-read</vh></v>
</v>
</v>
<v t="ekr.20061030041450"><vh>Run Iron Python scripts</vh>
<v t="ekr.20061030041356"><vh>@url c:\prog\IronPython-1.0.1\Doc\IronPythonApiReference.chm</vh></v>
</v>
</v>
<v t="ekr.20070410063214"><vh>Commands</vh>
<v t="ekr.20060924180049"><vh>@@command clones-tab</vh>
<v t="ekr.20060924180049.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060924180049.2"><vh>init</vh></v>
<v t="ekr.20060924180049.3"><vh>getAllClones</vh></v>
<v t="ekr.20060924180049.4"><vh>displayClones</vh>
<v t="ekr.20060924180049.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060924180049.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20080214091706.2"><vh>@@command ekr-command</vh></v>
<v t="ekr.20080823154546.1"><vh>@@command parse-python @key = Alt-5</vh></v>
<v t="edward.20081127113749.2"><vh>@@command complete-previous</vh>
<v t="edward.20081127113749.3"><vh>WordCompleter</vh>
<v t="edward.20081127113749.4"><vh>complete_word</vh>
<v t="edward.20081127113749.5"><vh>&lt;&lt;backward search&gt;&gt;</vh>
<v t="edward.20081127113749.6"><vh>&lt;&lt;counter check&gt;&gt;</vh></v>
</v>
<v t="edward.20081127113749.7"><vh>&lt;&lt;forward search&gt;&gt;</vh>
<v t="edward.20081127113749.6"></v>
</v>
<v t="edward.20081127113749.8"><vh>&lt;&lt;clean up and exit&gt;&gt;</vh></v>
</v>
<v t="edward.20081127113749.9"><vh>acceptable_word</vh></v>
<v t="edward.20081127113749.10"><vh>undo_replacement</vh></v>
<v t="edward.20081127113749.11"><vh>redo_replacement</vh></v>
<v t="edward.20081127113749.12"><vh>exit</vh></v>
<v t="edward.20081127113749.13"><vh>run</vh></v>
<v t="edward.20081127113749.14"><vh>adjust</vh></v>
</v>
<v t="edward.20081127113749.15"><vh>getCurrentWord</vh></v>
</v>
<v t="edward.20081127113749.16"><vh>@@command complete-next</vh>
<v t="edward.20081127113749.3"></v>
<v t="edward.20081127113749.15"></v>
</v>
</v>
<v t="ekr.20071026102420.3"><vh>Scripts</vh>
<v t="ekr.20100127111425.2062"><vh>search script (do not delete)</vh>
<v t="ekr.20100731123441.2155"><vh>searchDir</vh></v>
</v>
<v t="ekr.20090309064612.2"><vh> Example scripts</vh>
<v t="ekr.20080701130406.1"><vh>Run pylint on plugins</vh></v>
<v t="ekr.20080617170334.1"><vh>Determining key values</vh></v>
<v t="ekr.20080920101658.1"><vh>getInput</vh></v>
<v t="ekr.20080917063615.1"><vh>getSettingSource</vh></v>
<v t="ekr.20081205104320.1"><vh>run bash script</vh></v>
</v>
<v t="ekr.20071129103842"><vh>create-at-auto-nodes</vh></v>
<v t="ekr.20090428081009.1"><vh>patching auto-completion table</vh></v>
<v t="ekr.20090205070715.1"><vh>print colorer stats</vh></v>
<v t="ekr.20090728090618.2832"><vh>Recursive import script</vh>
<v t="ekr.20090728090618.2833"><vh>importFiles</vh></v>
<v t="ekr.20090728090618.2834"><vh>importDir</vh></v>
<v t="ekr.20090728090618.2835"><vh>createLastChildOf</vh></v>
</v>
<v t="ekr.20070517070854"><vh>run script in nullGui</vh></v>
<v t="ekr.20070517071510"><vh>run script with leoBridge</vh></v>
<v t="ekr.20080206055658"><vh>Script to print font settings</vh></v>
</v>
</v>
<v t="ekr.20070224123943"></v>
<v t="ekr.20071025193940"></v>
<v t="ekr.20090309064612.3"><vh>New features</vh>
<v t="ekr.20090309064612.4"><vh>Decorator tests</vh>
<v t="ekr.20080628094340.1"><vh>Decorator test</vh></v>
<v t="edward.20081221145716.1"><vh>decorator test 2</vh></v>
</v>
<v t="ekr.20090201162523.1"><vh>Macro test</vh>
<v t="ekr.20090201192257.1"><vh>@@test macro ab</vh></v>
</v>
<v t="ekr.20090128131130.1"><vh>posList tests</vh></v>
<v t="ekr.20090128112453.1"><vh>Property tests</vh></v>
<v t="ekr.20090507082111.1904"><vh>test creation of gnx's</vh></v>
<v t="ekr.20090601093755.1802"><vh>Test of @g.command decorator</vh></v>
<v t="ekr.20080922164656.1"><vh>Tests of path expressions</vh>
<v t="ekr.20080921144924.1"><vh>Tests of g.os_path_finalize</vh></v>
<v t="ekr.20080922142953.1"><vh>test os_pathExpression</vh></v>
<v t="ekr.20080922164255.1"></v>
<v t="ekr.20080922164255.2"><vh>@@shadow {{c.config.getString('test')}}/eval-shadow-test.txt</vh></v>
<v t="ekr.20080923073240.2"><vh>@path {{c.config.getString('test')}}</vh>
<v t="ekr.20080923073240.1"><vh>@@thin eval-thin-test.txt</vh></v>
</v>
</v>
<v t="ekr.20080531080812.1"><vh>tracer tests</vh></v>
<v t="ekr.20100616085524.2191"><vh>config iter</vh></v>
<v t="ekr.20100615095815.2189"><vh>activate/deactivate events</vh></v>
</v>
<v t="ekr.20070517160058.1"><vh>Prototypes</vh>
<v t="ekr.20100108090658.1958"><vh>generate key events</vh>
<v t="ekr.20100108090658.1959"><vh>Reference</vh></v>
<v t="ekr.20100108111728.2077"><vh>Binding dicts</vh></v>
<v t="ekr.20100108102030.1962"><vh>&lt;&lt; imports&gt;&gt;</vh></v>
<v t="ekr.20100108102030.1963"><vh>&lt;&lt; constants &gt;&gt;</vh></v>
<v t="ekr.20100108111728.2076"><vh>adjustBindings</vh></v>
<v t="ekr.20100108102217.1966"><vh>overrideCommand</vh></v>
<v t="ekr.20100108102217.1967"><vh>setKeyAndMods</vh></v>
<v t="ekr.20100108102217.1968"><vh>testKeys</vh></v>
</v>
<v t="ekr.20090507082535.1906"><vh>Get my email</vh></v>
<v t="ekr.20080531131542.1"><vh>mxTextTools proto</vh>
<v t="ekr.20080531141227.1"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
<v t="ekr.20080531131542.2"><vh>&lt;&lt; define scan4 tables &gt;&gt;</vh></v>
<v t="ekr.20080531131542.4"><vh>printItem</vh></v>
</v>
<v t="ekr.20080806145258.12"><vh>Prototype of Leo in Ajax</vh>
<v t="ekr.20080806145258.13"><vh>To do</vh></v>
<v t="ekr.20080806145258.14"><vh>@@button Leo2DHTML</vh>
<v t="ekr.20080806145258.15"><vh>&lt;&lt; about LeoToHTML &gt;&gt;</vh></v>
<v t="ekr.20080806145258.16"><vh>&lt;&lt; define dhtml stuff &gt;&gt;</vh></v>
<v t="ekr.20080806145258.17"><vh>escape</vh></v>
<v t="ekr.20080806145258.18"><vh>writeAll</vh></v>
<v t="ekr.20080806145258.19"><vh>writeBody</vh></v>
<v t="ekr.20080806145258.20"><vh>writeHead</vh></v>
<v t="ekr.20080806145258.21"><vh>writeContents</vh></v>
<v t="ekr.20080806145258.22"><vh>writePreamble</vh></v>
<v t="ekr.20080806145258.23"><vh>writePostamble</vh></v>
</v>
<v t="ekr.20080806145258.24"><vh>@@file server.py</vh></v>
<v t="ekr.20080806145258.25"><vh>@@file hello.html</vh></v>
<v t="ekr.20080806145258.26"><vh>@@file cgi-bin/edward.py</vh>
<v t="ekr.20080806145702.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20080806145258.27"><vh>&lt;&lt; define dhtml stuff &gt;&gt;</vh></v>
<v t="ekr.20080806145258.28"><vh>escape</vh></v>
<v t="ekr.20080806145258.29"><vh>print_all</vh></v>
<v t="ekr.20080806145258.30"><vh>print_body</vh></v>
<v t="ekr.20080806145258.31"><vh>print_head</vh></v>
<v t="ekr.20080806145258.32"><vh>print_leo_dot_js</vh></v>
<v t="ekr.20080806145258.33"><vh>print_tree</vh></v>
</v>
<v t="ekr.20080806145258.1"><vh>@@thin cgi-bin/leo.js</vh></v>
<v t="ekr.20080806145258.34"><vh>@@thin jqueryTest.html</vh></v>
</v>
<v t="ekr.20070929062147"><vh>Prototype of networkx graph tools</vh>
<v t="ekr.20070929122956"><vh>Data trees</vh>
<v t="ekr.20070929114617"><vh>@graph-target</vh></v>
<v t="ekr.20070929072043"><vh>@networkx</vh>
<v t="ekr.20070929072506.1"><vh>@nodes</vh></v>
<v t="ekr.20070929072506"><vh>@edges</vh></v>
</v>
<v t="ekr.20070929070257"><vh>@graph</vh>
<v t="ekr.20070929070257.1"><vh>@node child1</vh>
<v t="ekr.20070929070632"><vh>@link ('ekr', '20070929070257', 2): @node child2</vh></v>
</v>
<v t="ekr.20070929070257.2"><vh>@node child2</vh>
<v t="ekr.20070929070632.1"><vh>@link ('ekr', '20070929070257', 1): @node child1</vh></v>
</v>
</v>
<v t="ekr.20070928095102"><vh>root-node</vh>
<v t="ekr.20070928095102.1"><vh>child1</vh></v>
<v t="ekr.20070928095102.2"><vh>child2</vh></v>
</v>
</v>
<v t="ekr.20070929122956.1"><vh>buttons</vh>
<v t="ekr.20070929070426"><vh>@@button print link</vh></v>
<v t="ekr.20070927175908"><vh>@@button leo2graph</vh></v>
<v t="ekr.20070929062147.1"><vh>@@button at-graph2graph</vh></v>
<v t="ekr.20070929062147.2"><vh>@@button at-networkx2graph</vh>
<v t="ekr.20070929081505"><vh>error</vh></v>
<v t="ekr.20070929074830"><vh>parse</vh></v>
<v t="ekr.20070929072506.2"><vh>parseNodes</vh></v>
<v t="ekr.20070929074830.1"><vh>parseEdges</vh></v>
</v>
<v t="ekr.20070929082546"><vh>@@button at-networkx2at-graph</vh>
<v t="ekr.20070929120541"><vh>createEdges</vh></v>
<v t="ekr.20070929120541.1"><vh>createNodes</vh></v>
<v t="ekr.20070929115302"><vh>createTree</vh></v>
<v t="ekr.20070929114410.2"><vh>error</vh></v>
<v t="ekr.20070929114410.3"><vh>parse</vh></v>
<v t="ekr.20070929114410.5"><vh>parseEdges</vh></v>
<v t="ekr.20070929114410.4"><vh>parseNodes</vh></v>
</v>
</v>
</v>
<v t="ekr.20070630142904"><vh>Prototype of pyrex</vh>
<v t="ekr.20070630142904.2"><vh>gcc build docs</vh></v>
<v t="ekr.20070630142904.3"><vh>pyrexc command-line options</vh></v>
<v t="ekr.20070630142904.4"><vh>@@file myModule.pyx</vh></v>
<v t="ekr.20070630142904.5"><vh>Make myModule.c</vh></v>
</v>
<v t="ekr.20090620063706.1826"><vh>Prototype of rendering commands</vh>
<v t="ekr.20090619103402.1818"><vh>@@button render-as-html</vh></v>
<v t="ekr.20090619103402.1821"><vh>@@button render-as-text</vh></v>
</v>
<v t="ekr.20091013153026.2721"><vh>prototype of using patternmatch library</vh>
<v t="ekr.20091011110344.1853"><vh>@@button find script a</vh></v>
<v t="ekr.20091010091628.1836"><vh>@@button create find button</vh>
<v t="ekr.20091010104145.1840"><vh>class patController</vh>
<v t="ekr.20091010104145.1842"><vh>ctor</vh></v>
<v t="ekr.20091010104145.1843"><vh>setup</vh></v>
<v t="ekr.20091010104145.1844"><vh>driver</vh></v>
<v t="ekr.20091010104145.1845"><vh>find</vh></v>
<v t="ekr.20091010104145.1846"><vh>findr</vh></v>
</v>
</v>
<v t="ekr.20091010091628.1837"><vh>find pat a</vh></v>
</v>
<v t="ekr.20100109084336.1996"><vh>Prototypes of gui-dependent cursor move helpers</vh>
<v t="ekr.20100109081612.1984"><vh>@@button up</vh></v>
<v t="ekr.20100109081746.1990"><vh>@@button up-extend</vh></v>
<v t="ekr.20100109081746.1993"><vh>@@button up-page-extend</vh></v>
<v t="ekr.20100109081746.1988"><vh>@@button down</vh></v>
<v t="ekr.20100109081746.1992"><vh>@@button down-extend</vh></v>
</v>
<v t="ekr.20090728090618.2837"><vh>pydiction-1.0</vh>
<v t="ekr.20090728090618.2846"><vh>pydiction.vim</vh></v>
<v t="ekr.20090728090618.2847"><vh>README.txt</vh></v>
<v t="ekr.20090728090618.2838"><vh>pydiction.py</vh>
<v t="ekr.20090728090618.2849"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20090728090618.2839"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="ekr.20090728090618.2848"><vh>&lt;&lt; process command line &gt;&gt;</vh></v>
<v t="ekr.20090728090618.2840"><vh>get_submodules</vh></v>
<v t="ekr.20090728090618.2841"><vh>write_dictionary</vh></v>
<v t="ekr.20090728090618.2842"><vh>my_import</vh></v>
<v t="ekr.20090728090618.2843"><vh>remove_duplicates</vh></v>
<v t="ekr.20090728090618.2844"><vh>get_yesno</vh></v>
<v t="ekr.20090728090618.2845"><vh>main</vh></v>
</v>
</v>
<v t="ekr.20090630141519.1793"><vh>rClick proto script</vh></v>
<v t="ekr.20080503202744.3"><vh>Rope</vh></v>
<v t="ekr.20080811113441.2"><vh>Running body text as a windows script</vh>
<v t="ekr.20080807115344.1"><vh>Windows script</vh></v>
<v t="ekr.20080807114145.2"><vh>@@button run-windows-script</vh>
<v t="ekr.20080807115344.5"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20080807115344.2"><vh>class MySite</vh></v>
<v t="ekr.20080807115344.3"><vh>class Application</vh></v>
<v t="ekr.20080807115344.4"><vh>RunCode</vh></v>
</v>
</v>
<v t="ekr.20071026102420.2"><vh>Screen capture with Wink</vh>
<v t="ekr.20070528111805"><vh>FrontWindowCapture.pyw</vh></v>
<v t="ekr.20070609085533"><vh>@@url c:\prog\wink\ChangeViewMenu.htm</vh></v>
</v>
<v t="ekr.20100516140428.2135"><vh>sha1 hashes</vh></v>
<v t="ekr.20091230081322.1919"><vh>unicode categories</vh></v>
<v t="ekr.20100521101729.2148"><vh>proto of template</vh></v>
</v>
<v t="ekr.20071105085941"><vh>Tests</vh>
<v t="ekr.20100203174233.2032"><vh>@@test paste-script</vh></v>
<v t="ekr.20100122125233.2053"><vh>@test zcpspm</vh></v>
<v t="ekr.20091230121016.1931"><vh>at-auto stuff</vh>
<v t="ekr.20090706044257.1784"><vh>@@auto ../../install</vh></v>
<v t="ekr.20091217210235.1866"><vh>@@auto-rst at-auto-rst-test.txt</vh>
<v t="ekr.20100110172917.1916"><vh>section 1</vh></v>
<v t="ekr.20100110172917.1917"><vh>section 2</vh></v>
</v>
<v t="ekr.20091229092257.1930"><vh>@@auto-rst ../doc/html/intro.html.txt</vh>
<v t="ekr.20100110172917.1918"><vh>@rst-no-head intro.html declarations</vh></v>
<v t="ekr.20100110172917.1919"><vh>Chapter 2: The Leo Tutorial</vh>
<v t="ekr.20100110172917.1920"><vh>Leo's main window</vh></v>
<v t="ekr.20100110172917.1921"><vh>Outline commands</vh></v>
<v t="ekr.20100110172917.1922"><vh>External files and @file nodes</vh></v>
<v t="ekr.20100110172917.1923"><vh>Creating external files from outlines</vh>
<v t="ekr.20100110172917.1924"><vh>Section references</vh></v>
<v t="ekr.20100110172917.1925"><vh>The @others directive</vh></v>
<v t="ekr.20100110172917.1926"><vh>The @all directive</vh></v>
<v t="ekr.20100110172917.1927"><vh>Choosing between @others and sections</vh></v>
<v t="ekr.20100110172917.1928"><vh>Organizing programs as outlines</vh></v>
</v>
<v t="ekr.20100110172917.1929"><vh>Clones &amp; views</vh></v>
<v t="ekr.20100110172917.1930"><vh>More about directives</vh></v>
<v t="ekr.20100110172917.1931"><vh>Scripting, extending and customizing Leo</vh></v>
<v t="ekr.20100110172917.1932"><vh>Summary</vh></v>
<v t="ekr.20100110172917.1933"><vh>Further study</vh></v>
</v>
</v>
<v t="ekr.20091229101227.1902"><vh>@@auto-rst quickstart.txt</vh>
<v t="ekr.20100110172917.1934"><vh>A ReStructuredText Primer</vh>
<v t="ekr.20100110172917.1935"><vh>Structure</vh></v>
<v t="ekr.20100110172917.1936"><vh>Text styles</vh></v>
<v t="ekr.20100110172917.1937"><vh>Lists</vh></v>
<v t="ekr.20100110172917.1938"><vh>Preformatting (code samples)</vh></v>
<v t="ekr.20100110172917.1939"><vh>Sections</vh>
<v t="ekr.20100110172917.1940"><vh>Document Title / Subtitle</vh></v>
</v>
<v t="ekr.20100110172917.1941"><vh>Images</vh></v>
<v t="ekr.20100110172917.1942"><vh>What Next?</vh></v>
</v>
</v>
<v t="ekr.20091230064146.1912"><vh>@@auto xml-tags-test.xml</vh>
<v t="ekr.20100110172917.1943"><vh>xml</vh></v>
<v t="ekr.20100110172917.1944"><vh>test.a</vh></v>
<v t="ekr.20100110172917.1945"><vh>test-b</vh></v>
</v>
<v t="ekr.20091230090645.1925"><vh>@@auto layout.html</vh>
<v t="ekr.20100110172917.1946"><vh>layout declarations</vh></v>
<v t="ekr.20100110172917.1947"><vh>html</vh>
<v t="ekr.20100110172917.1948"><vh>py:match</vh>
<v t="ekr.20100110172917.1949"><vh>head</vh>
<v t="ekr.20100110172917.1950"><vh>py:if</vh></v>
</v>
</v>
<v t="ekr.20100110172917.1951"><vh>py:match</vh>
<v t="ekr.20100110172917.1952"><vh>body</vh></v>
</v>
<v t="ekr.20100110172917.1953"><vh>py:match</vh></v>
<v t="ekr.20100110172917.1954"><vh>py:match</vh></v>
</v>
</v>
<v t="ekr.20091230160238.1922"><vh>@@auto-rst cheatsheet.txt</vh>
<v t="ekr.20100110172917.1955"><vh>The reStructuredText_ Cheat Sheet: Syntax Reminders</vh>
<v t="ekr.20100110172917.1956"><vh>Section Structure</vh></v>
<v t="ekr.20100110172917.1957"><vh>Body Elements</vh></v>
<v t="ekr.20100110172917.1958"><vh>Inline Markup</vh></v>
<v t="ekr.20100110172917.1959"><vh>Directive Quick Reference</vh></v>
<v t="ekr.20100110172917.1960"><vh>Interpreted Text Role Quick Reference</vh></v>
</v>
</v>
<v t="ekr.20100110151049.2004"><vh>@@auto-rst unicode-headline-test.txt</vh>
<v t="ekr.20100110172917.1961"><vh>section 1: Ę</vh></v>
</v>
</v>
<v t="ekr.20100205114630.2091"><vh>File tests</vh>
<v t="ekr.20100203233053.2033"><vh>@@thin at-path-in-body-test.py</vh></v>
<v t="ekr.20100204062222.2035"><vh>@@@auto C:\leo.repo\trunk\leo\extensions\Pmw\Pmw_1_3\lib</vh></v>
<v t="ekr.20100204082851.2038"><vh>@@auto test-PmwComboBox.py</vh>
<v t="ekr.20100204085631.2041"><vh>test-PmwComboBox declarations</vh></v>
<v t="ekr.20100204085631.2042"><vh>class ComboBox</vh>
<v t="ekr.20100204085631.2043"><vh>__init__</vh></v>
<v t="ekr.20100204085631.2044"><vh>destroy</vh></v>
<v t="ekr.20100204085631.2045"><vh>get</vh></v>
<v t="ekr.20100204085631.2046"><vh>invoke</vh></v>
<v t="ekr.20100204085631.2047"><vh>selectitem</vh></v>
<v t="ekr.20100204085631.2048"><vh>size</vh></v>
<v t="ekr.20100204085631.2049"><vh>bbox</vh></v>
<v t="ekr.20100204085631.2050"><vh>clear</vh></v>
<v t="ekr.20100204085631.2051"><vh>_addHistory</vh></v>
<v t="ekr.20100204085631.2052"><vh>_next</vh></v>
<v t="ekr.20100204085631.2053"><vh>_previous</vh></v>
<v t="ekr.20100204085631.2054"><vh>_selectCmd</vh></v>
<v t="ekr.20100204085631.2055"><vh>_drawArrow</vh></v>
<v t="ekr.20100204085631.2056"><vh>_postList</vh></v>
<v t="ekr.20100204085631.2057"><vh>_dropdownBtnRelease</vh></v>
<v t="ekr.20100204085631.2058"><vh>_unpostOnNextRelease</vh></v>
<v t="ekr.20100204085631.2059"><vh>_resizeArrow</vh></v>
<v t="ekr.20100204085631.2060"><vh>_unpostList</vh></v>
<v t="ekr.20100204085631.2061"><vh>_selectUnpost</vh></v>
</v>
</v>
<v t="ekr.20100204085410.2060"><vh>@@auto test-blank-lines.py</vh>
<v t="ekr.20100205114630.2089"><vh>test-blank-lines declarations</vh></v>
<v t="ekr.20100205114630.2090"><vh>class ComboBox</vh></v>
</v>
<v t="ekr.20100329100226.2108"><vh>@@auto-rst at-auto-test.txt</vh>
<v t="ekr.20100329100841.2109"><vh>Level 1</vh>
<v t="ekr.20100329100841.2110"><vh>Level 2</vh></v>
</v>
</v>
</v>
<v t="ekr.20080930114036.1"><vh>Icon stuff</vh>
<v t="ekr.20100824124015.2195"><vh>print icons</vh></v>
<v t="ekr.20090701125834.1765"><vh>@@button insert-inst-icon</vh></v>
<v t="ekr.20080930080501.1"><vh>Add icon row</vh></v>
<v t="ekr.20080930083052.1"><vh>hide icon rows</vh></v>
<v t="ekr.20080930083052.2"><vh>show icon rows</vh></v>
<v t="ekr.20080930085514.1"><vh>clear icon bar</vh></v>
</v>
<v t="ekr.20100103112623.1951"><vh>Insert form-feed</vh></v>
<v t="ekr.20100119095726.2043"><vh>rest colorizing</vh></v>
<v t="ekr.20100130095415.2023"><vh>Simulate startup code for non-ascii directories</vh></v>
<v t="ekr.20080924081821.1"><vh>test of autoCompleter.getExternalCompletions (do not deletes)</vh></v>
<v t="ekr.20081003094737.1"><vh>Unicode tests</vh>
<v t="ekr.20080701101740.1"><vh>locale tests</vh></v>
<v t="ekr.20080821111715.1"><vh>Standard print test (only works for Latin-1 and ascii)</vh></v>
<v t="ekr.20090525090210.1940"><vh>Unicode characters: La Peña</vh></v>
<v t="ekr.20090617083033.1814"><vh>Test of copy/paste of unicode</vh>
<v t="ekr.20090617083033.1813"><vh>Unicode characters: La Peña תּ</vh></v>
</v>
<v t="ekr.20090618102458.1816"><vh>Converting QString to unicode</vh></v>
<v t="ekr.20100127122240.2063"><vh>Terry's unicode problem</vh></v>
<v t="ekr.20100202115249.2023"><vh>@@thin qttexttest.py</vh></v>
</v>
<v t="ekr.20090514103332.1929"><vh>Unit tests</vh>
<v t="ekr.20090514073218.1923"><vh>@button run test.leo tests @key = alt-7</vh></v>
<v t="ekr.20090218112656.1"><vh>@test self.assertEqual</vh></v>
<v t="ekr.20090514101216.1927"><vh>@test self.assertNotEqual</vh></v>
</v>
<v t="ekr.20100127111116.2059"><vh>wrapping</vh></v>
<v t="ekr.20100205074729.2085"><vh>Clone battle test</vh>
<v t="ekr.20100205074729.2086"><vh>node a</vh></v>
<v t="ekr.20100205074729.2087"><vh>@@thin clone-battle-test.txt</vh>
<v t="ekr.20100205074729.2086"></v>
</v>
</v>
<v t="ekr.20100330082345.2120"><vh>pseudoplain</vh></v>
<v t="ekr.20100526075442.2155"><vh>@@auto-rst c:\prog\graphs.rst</vh>
<v t="ekr.20100526092131.2157"><vh>DOT</vh>
<v t="ekr.20100526092131.2158"><vh>Examples from User guide</vh></v>
<v t="ekr.20100526092131.2159"><vh>Small graph</vh></v>
<v t="ekr.20100526092131.2160"><vh>Fancy graph</vh></v>
<v t="ekr.20100526092131.2161"><vh>Graph with polygonal shapes</vh></v>
<v t="ekr.20100526092131.2162"><vh>Records with nested fields</vh></v>
<v t="ekr.20100526092131.2163"><vh>HTML-like labels</vh></v>
<v t="ekr.20100526092131.2164"><vh>Graph with constrained ranks</vh></v>
</v>
<v t="ekr.20100526092131.2165"><vh>Server status</vh>
<v t="ekr.20100526092131.2166"><vh>dhcpd.conf</vh></v>
</v>
<v t="ekr.20100526092131.2167"><vh>networkx</vh>
<v t="ekr.20100526092131.2168"><vh>Tutorial</vh></v>
<v t="ekr.20100526092131.2169"><vh>Examples</vh>
<v t="ekr.20100526092131.2170"><vh>File hierarchy to graph</vh></v>
</v>
</v>
<v t="ekr.20100526092131.2171"><vh>pygraphviz</vh></v>
<v t="ekr.20100526092131.2172"><vh>Diagraming apt components</vh></v>
</v>
</v>
<v t="ekr.20100728114551.2149"><vh>@asis at-asis-test.txt</vh></v>
<v t="ekr.20100729114420.2152"><vh>plain fonts</vh></v>
<v t="ekr.20100812102648.2193"><vh>@button format-code</vh>
<v t="ekr.20100812102648.2195"><vh>&lt;&lt; options &gt;&gt;</vh></v>
<v t="ekr.20100812114823.2176"><vh>The code-to-rst command</vh>
<v t="ekr.20100812114823.2177"><vh>code_to_rst_command &amp; helpers</vh>
<v t="ekr.20100812114823.2178"><vh>write_code_body &amp; helpers</vh>
<v t="ekr.20100812114823.2179"><vh>split_parts</vh></v>
<v t="ekr.20100812114823.2180"><vh>write_code_block</vh></v>
</v>
<v t="ekr.20100812114823.2181"><vh>write_code_headline &amp; helper</vh>
<v t="ekr.20100812114823.2182"><vh>write_code_headline_helper</vh></v>
</v>
<v t="ekr.20100812114823.2183"><vh>write_code_node</vh></v>
<v t="ekr.20100812114823.2184"><vh>write_code_tree</vh></v>
</v>
<v t="ekr.20100812114823.2185"><vh>Changed methods</vh>
<v t="ekr.20100812114823.2186"><vh>getOption &amp; setOption</vh></v>
<v t="ekr.20100812114823.2187"><vh>initOptionsFromSettings</vh></v>
<v t="ekr.20100812114823.2188"><vh>writeSpecialTree</vh></v>
</v>
</v>
</v>
<v t="ekr.20100821214143.2190"><vh>@@html Leo's home page</vh></v>
</vnodes>
<tnodes>
<t tx="edward.20081127113749.10">def undo_replacement(self):
    u = self.c.undoer; c=self.c; p=u.p
    bunch = u.getBead(u.bead)
    c.setBodyString(p, bunch.oldBody)
    c.frame.body.setInsertPoint(bunch.insertPos)</t>
<t tx="edward.20081127113749.11">def redo_replacement(self):
    c = self.c; u=c.undoer; bunch=u.getBead(u.bead+1)
    c.setBodyString(bunch.p, bunch.newBody)
    c.frame.body.setInsertPoint(bunch.insertPos)</t>
<t tx="edward.20081127113749.12">def exit(self):
    #g.app.config.set(c,word_completer_key,'WordCompleter',None)
    #g.app.config.set(c,'next_word_completer','WordCompleter',None)
    self.pos = -1</t>
<t tx="edward.20081127113749.13">def run(self):
    self.adjust(self.p, c.frame.body.getInsertPoint())
    self.complete_word()
</t>
<t tx="edward.20081127113749.14">def adjust(self, p, pos):
    if p != self.p or pos != self.pos:
        self.p = p.copy()
        self.pos = pos
        bs = p.bodyString()
        word = getCurrentWord(bs, pos)
        self.word = word
        self.before = bs[:pos-len(word)]
        self.after = bs[pos:]
        self.search_pos = p.copy()
        if self.back:
            self.chunk = self.before
        else:
            self.chunk = self.after
        self.tried = {word:1}</t>
<t tx="edward.20081127113749.15">def getCurrentWord(s, pos):
    i = pos-1
    while i&gt;=0 and wordsep.find(s[i]) &lt; 0:
         i -= 1
    return s[i+1:pos]</t>
<t tx="edward.20081127113749.16">wordsep = u'., -+\n\r[]{}&lt;&gt;=-+*&amp;%$#@!"\'?/\\|^()~`:;'
word_completer_key = 'next_word_completer'
@others
completer = g.app.config.get(c,word_completer_key,'WordCompleter')
if completer is None:
    completer = WordCompleter(p, c, back=False)
    g.app.config.set(c, word_completer_key, 'WordCompleter', completer)
    completer.run()
else:
    completer.adjust(p, c.frame.body.getInsertPoint())
    completer.complete_word()

</t>
<t tx="edward.20081127113749.2">wordsep = u'., -+\n\r[]{}&lt;&gt;=-+*&amp;%$#@!"\'?/\\|^()~`:;'
word_completer_key = 'back_word_completer'
@others
completer = g.app.config.get(c,word_completer_key,'WordCompleter')
if completer is None:
    completer = WordCompleter(p,c,back=True)
    g.app.config.set(c,word_completer_key,'WordCompleter',completer)
    completer.run()
else:
    completer.adjust(p, c.frame.body.getInsertPoint())
    completer.complete_word()
</t>
<t tx="edward.20081127113749.3">class WordCompleter:
    def __init__(self, p, c, back=True):
        self.p = p.copy()
        self.c = c
        self.back = back
        self.pos = -1
    @others
</t>
<t tx="edward.20081127113749.4">def complete_word(self):
    txt = self.chunk
    word = self.word
    try:
        if self.back:
            &lt;&lt;backward search&gt;&gt;
        else:
            &lt;&lt;forward search&gt;&gt;
        &lt;&lt;clean up and exit&gt;&gt;
    except:
        self.exit()
        g.es_exception()</t>
<t tx="edward.20081127113749.5">p = self.search_pos
start = -1
counter = 0
while p:
    &lt;&lt;counter check&gt;&gt;
    i = txt.rfind(word, 0, start)
    if i == -1:
        p.moveToThreadBack()
        if p:self.chunk = txt = p.bodyString()
        start = -1
    else:
        if self.acceptable_word(i, txt, word):
            self.chunk = txt[:i+len(word)-1]
            return
        start = i+len(word)-1</t>
<t tx="edward.20081127113749.6">counter+=1
if counter &gt; 10000:
    g.es_trace("counter max")
    break</t>
<t tx="edward.20081127113749.7">p = self.search_pos
start = 0
counter = 0
while p:
    &lt;&lt;counter check&gt;&gt;
    i = txt.find(word, start)
    if i == -1:
        p.moveToThreadNext()
        if p:self.chunk = txt = p.bodyString()
        start = 0
    else:
        if self.acceptable_word(i, txt, word):
            self.chunk = txt[i+1:]
            return
        start = i+1</t>
<t tx="edward.20081127113749.8">if len(self.tried) &gt; 1:
    # there was some tries so we need to restore
    self.c.setBodyString(self.p, self.before+self.word+self.after)
    self.c.frame.body.setInsertPoint(self.pos)
return self.exit()</t>
<t tx="edward.20081127113749.9">@ if found word for the first time then try it
@c
def acceptable_word(self, i, txt, word):
    if i == 0 or wordsep.find(txt[i-1]) != -1:
        j = i+len(word)
        while j &lt; len(txt) and wordsep.find(txt[j]) &lt; 0:
            j += 1
        nword = txt[i:j]
        if nword not in self.tried:
            self.tried[nword] = 1
            u = self.c.undoer
            bunch = u.createCommonBunch(p)
            bunch.oldBody = p.bodyString()
            bunch.insertPos = self.pos
            # Set the type &amp; helpers.
            bunch.kind = 'node'
            bunch.undoType = 'complete word'
            bunch.undoHelper = self.undo_replacement
            bunch.redoHelper = self.redo_replacement
            bunch.newBody = newBody = self.before+nword+self.after

            self.c.setBodyString(self.p, newBody)
            self.c.frame.body.setInsertPoint(self.pos)

            bunch.dirtyVnodeList = [p.v]
            bunch.newChanged = u.c.isChanged()
            bunch.newDirty = p.isDirty()
            bunch.newMarked = p.isMarked()

            u.pushBead(bunch)

            return True
    return False
</t>
<t tx="edward.20081221145716.1">def debug(f,*args,**keys):
    if 1:
        def debugCallback(*args,**keys):
            print f.__name__,args,keys
            f(*args,**keys)
            print 'after',f.__name__
        return debugCallback
    else:
        print 'in debug'
        return f
@debug
def spam(a=5):
    g.trace(a,g.callers(4))

spam(3)
spam(a=4)
</t>
<t tx="ekr.20041001211817">import os

g.pr(os.path.exists(os.path.normpath("C:\\Progra~1\\Eclipse")))</t>
<t tx="ekr.20060427103457"># Open leoSettings.leo
c.openLeoSettings()</t>
<t tx="ekr.20060809084033">'''A script to convert calls to g.es to g.et, and raw strings s to g._(s)'''

__version__ = 0.2
&lt;&lt; version history &gt;&gt;

@others

trace = False # For debugging.
doReplace = True # True: actually replace the body text.

if not doReplace: g.es_print('-' * 40)
c.beginUpdate()
try:
    u = c.undoer
    undoType = 'Convert g.es'
    u.beforeChangeGroup (p,undoType)
    for p in c.currentPosition().self_and_subtree_iter():
        replace(p)
    u.afterChangeGroup(p,undoType,reportFlag=True)
finally:
    c.endUpdate()</t>
<t tx="ekr.20060809090508"># Based on leoImport.scanPythonText.
def replace(p):
    '''Replace g.es by g.et and strings s by g._(s)'''
    s = p.bodyString()
    if not s.strip(): return
    result = [] ;  i = 0 ; count = 0
    while i &lt; len(s):
        progress = j = i
        ch = s[i]
        if ch == '\n' or ch == '\r':
            i = g.skip_nl(s,i)
            result.append(s[j:i])
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
            result.append(s[j:i])
        elif ch == '"' or ch == "'":
            &lt;&lt; handle string &gt;&gt;
        elif g.is_c_id(ch):
            if g.match_word(s,i,'g.es'):
                &lt;&lt; handle g.es &gt;&gt;
            else:
                i = g.skip_c_id(s,i)
                result.append(s[j:i])
        else:
            i += 1
            result.append(s[j:i])
        assert(progress &lt; i)
    if count:
        result = ''.join(result)
        if doReplace:
            undoData = u.beforeChangeNodeContents(p)
            p.setBodyStringOrPane(result)
            p.v.t.setDirty()
            u.afterChangeNodeContents(p,'Change Body',undoData)
        else:
            g.trace('result...\n',result)</t>
<t tx="ekr.20060809091749.72">i = g.skip_python_string(s,i)
s2 = s[j:i].strip()
result.append('g._(%s)' % s2)
if trace: g.trace('string:',s2)
count += 1</t>
<t tx="ekr.20060809091749.73">i += 4 ; k1 = i
i = g.skip_ws(s,i)
found = False
if g.match(s,i,'('):
    k2 = i
    k3 = g.skip_parens(s,i)
    if g.match(s,k3,')'):
        # Only translate if there are exactly one string in the parens.
        s2 = s[k2+1:k3]
        if (
            s2 and s2.count(',') == 0 and
            (s2.count('"') == 2 or s2.count("'") == 2)
        ):
            i = k3
            if trace: g.trace('call g.es:',g.get_line(s,i))
            result.append('g.et')
            result.append(s[k1:i])
            count += 1 ; found = True
if not found:
    result.append(s[j:i])</t>
<t tx="ekr.20060809092023"></t>
<t tx="ekr.20060809103738">def test1():
    
    g.es('abc')
    g.es('abc',xyz)
    g.es(xyz)</t>
<t tx="ekr.20060809103738.1">def test2():

    x = 'abc' + 'xyz'
    y = abc</t>
<t tx="ekr.20060809104405">@nocolor
@
0.1 EKR: Initial version.
0.2 EKR: Support doReplace and made script fully undoable.</t>
<t tx="ekr.20060814111542"># Add an editor to the body pane.
c.frame.body.addEditor()</t>
<t tx="ekr.20060904110922"></t>
<t tx="ekr.20060904111037">if hasattr(c,'opmlCommands'):
    c.opmlCommands.readOpmlCommand()
else:
    g.es_print('opml plugin not loaded')</t>
<t tx="ekr.20060904111037.1">if hasattr(c,'opmlCommands'):
    c.opmlCommands.writeOpmlCommand()
else:
    g.es_print('opml plugin not loaded')</t>
<t tx="ekr.20060918083159">put = g.es_print

for p in c.allNodes_iter():

    if hasattr(p.v,"unknownAttributes"):
        put("deleting v.unknownAttributes:",
            p.headString(),
            g.listToString(p.v.unknownAttributes.keys()))
        delattr(p.v,"unknownAttributes")

    if hasattr(p.v.t,"unknownAttributes"):
        put("deleting t.unknownAttributes:",
            p.headString(),
            g.listToString(p.v.t.unknownAttributes.keys()))
        delattr(p.v.t,"unknownAttributes")
           
put('done') 
c.redraw()</t>
<t tx="ekr.20060924180049">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060924180049.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others</t>
<t tx="ekr.20060924180049.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")</t>
<t tx="ekr.20060924180049.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060924180049.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.currentPosition()
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.headString())
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060924180049.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().headString()
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)</t>
<t tx="ekr.20060924180049.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20061030041200">import os, sys

if 1: # Executes Iron Python in the console. (But not from the tutorials directory).
    path = r'c:\prog\IronPython-1.0.1\ipy.exe'
    args = ['-i']
        
    if 1: # Use present environment.
        os.spawnv(os.P_NOWAIT, path, args)
    else: # Use a pristine environment.
        os.spawnve(os.P_NOWAIT, path, args, os.environ)</t>
<t tx="ekr.20061030041356"></t>
<t tx="ekr.20061030041450"></t>
<t tx="ekr.20070115092430"># Invoke winpdb for general scripts **not** containing the predefined g, p or d constants.

# This is essentially the same as using the debug command.

import os,subprocess,sys

# Important: scriptFile2 must be different from scriptFile.
filename = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','scriptFile2'))
f = open(filename,'w') 
f.write(p.bodyString()) 
f.close() 
python = sys.executable
pythonDir = g.os_path_dirname(python) 
#winpdb = g.os_path_join(pythonDir,'Scripts','_winpdb.py') # For older versions of winpdb.
winpdb = g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py') # For version 1.1.2 and newer.
os.chdir(g.app.loadDir)
cmdline = '%s %s -t %s' % (python,winpdb,filename) 
subprocess.Popen(cmdline)
</t>
<t tx="ekr.20070224123943"></t>
<t tx="ekr.20070410063214"></t>
<t tx="ekr.20070416075121" str_leo_pos="2"></t>
<t tx="ekr.20070503085527"></t>
<t tx="ekr.20070515073111">g.pr('=' * 50)</t>
<t tx="ekr.20070517070854">import leoGui
oldGui = g.app.gui
g.app.gui = leoGui.nullGui(guiName='testGui')
try:
    fileName = g.os_path_abspath(g.os_path_join(
        g.app.loadDir,'..','doc','LeoDocs.leo'))
    ok,frame = g.openWithFileName(fileName,old_c=c)
    if ok:
        c2 = frame.c
        for p in c2.allNodes_iter():
            g.pr('.'*p.level(),p.headString())
        g.app.closeLeoWindow(frame)
finally:
    g.app.gui = oldGui</t>
<t tx="ekr.20070517071510">import leoBridge

path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','doc','LeoDocs.leo'))

if 0: # This can not be run locally: leoBridge.controller starts a Tk event loop.

    controller = leoBridge.controller(gui='nullGui')
    g = controller.globals()
    c = controller.openLeoFile(path)
    n = 0
    for p in c.allNodes_iter():
        n += 1
    g.pr('%d nodes in %s' % (n,path))
    # g.app.closeLeoWindow(c.frame)</t>
<t tx="ekr.20070517160058.1">@language python
</t>
<t tx="ekr.20070528111805"># FrontWindowCapture.pyw
# Version 0.1
# Date    20070526
# Author  Roger Erens (roger AT erens-krekels.net)
"""
        Purpose:
        Capture the image of the front-most window into a fixed-name
        (_front_window), max-size (default MAX_WIDTH is 640 pixels), and
        fixed-format (PNG) file that can easily be used when creating
        documentation for an application on a wiki or in some HTML-docs.
        This script does _not_ copy the captured image to the clipboard (handy
        when creating MS Word or OpenOffice documents) since MS Windows already
        has ALT-PRTSCR to do so.

        Dependencies:
        Fairly recent versions of Python, wxPython, and PIL should be installed

        Start:
        Double click FrontWindowCapture.pyw; an icon appears in the Task Bar (lower right of
        the screen).

        Use:
        Bring a window to the front and then left-click on the
        icon in the Task Bar. A file named '_front_window.png' will be saved
        in the current directory.
        A pictures wider than MAXWIDTH is scaled down in order to make it easily
        used in wikis or HTML-documentation.
        Usually, human intelligence is needed to rename that file; this is also
        why this script does not copy the image to the clipboard.

        End:
        Close the application by right-clicking the icon in the Task Bar.

        Note:
        Make sure that your system is fast enough to find the frontmost
        window. That is, when a virusscanner is running or virtual memory is
        low, this script will choke. You can see what happens by enabling the
        print statements and running this script from a console (change the
        extension from .pyw to .py).
"""
import wx
import sys
import win32ui
import win32gui
import win32con
import time
from PIL import Image, ImageGrab

Image.init()

MAX_WIDTH = 640
BLINK_STATE = 0

class TaskBarApp(wx.Frame):
    def __init__(self, parent, id, title):
        wx.Frame.__init__(self, parent, -1, title, size = (1, 1),
            style=wx.FRAME_NO_TASKBAR| wx.NO_FULL_REPAINT_ON_RESIZE)
        self.tbicon = wx.TaskBarIcon()
        icon = wx.Icon('LeoApp16.ico', wx.BITMAP_TYPE_ICO)
        self.tbicon.SetIcon(icon, 'Click to capture the foremost window')
        self.tbicon.Bind(wx.EVT_TASKBAR_LEFT_UP, self.OnTaskBarLeftClick)
        self.tbicon.Bind(wx.EVT_TASKBAR_RIGHT_UP, self.OnTaskBarRightClick)
        self.Show(True)

    def OnTaskBarLeftClick(self, evt):

        self.FlashIcon(evt)

        def _MyCallback(hwnd, extra ):
            extra.append(hwnd)

        windows = []
        win32gui.EnumWindows(_MyCallback, windows)

        winList = []
        for i in windows:
            if win32gui.IsWindowVisible(i):
                winList.append(i)
                #g.pr(i)

        win32gui.SetForegroundWindow(winList[1])    # found by trial and error
                                                    # that I need the second
                                                    # window from the list
        time.sleep(0.1)  # give the previous command some time to finish

        fgwindow = win32ui.GetForegroundWindow()
        #g.pr("(C)lick!")

        bbox = fgwindow.GetWindowRect()
        img = ImageGrab.grab( bbox)
        width = bbox[2] - bbox[0]
        if width &gt; MAX_WIDTH:
            coeff = MAX_WIDTH * 1. / width
            height = bbox[3] - bbox[1]
            newHeight = int( coeff * height)
            #g.pr(width, height, "scaled down to", MAX_WIDTH, newHeight)
            img = img.resize((MAX_WIDTH,newHeight), Image.ANTIALIAS)
        img = img.convert("P", dither=Image.NONE,
                              palette=Image.ADAPTIVE, colors=256)
        img.save("_front_window.png", "PNG", optimize=1)
        #img.show() # show the image in an image viewer

        self.FlashIcon(evt)

    def OnTaskBarRightClick(self, evt):
        #g.pr("Auta..." # that's about it...)
        self.tbicon.Destroy()
        self.Close(True)
        wx.GetApp().ProcessIdle()

    def FlashIcon(self, evt):
        global BLINK_STATE
        if BLINK_STATE == 0:
            icon = wx.Icon('LeoApp16lick.ico', wx.BITMAP_TYPE_ICO)
            self.tbicon.SetIcon(icon, 'Window is being captured...')
            BLINK_STATE = 1
            return
        else:
            icon = wx.Icon('LeoApp16.ico', wx.BITMAP_TYPE_ICO)
            self.tbicon.SetIcon(icon, 'Click to capture the foremost window')
            BLINK_STATE = 0
            return

class MyApp(wx.App):
    def OnInit(self):
        frame = TaskBarApp(None, -1, ' ')
        frame.Center(wx.BOTH)
        frame.Show(False)
        return True

def main():
    app = MyApp(0)
    app.MainLoop()

if __name__ == '__main__':
    main()

""" CREDITS

    Thanks to
    Roger Upole:
    http://groups.google.com/group/comp.lang.python/
    browse_thread/thread/ff39ec79f7c3248a/
    e600c892772bf52a?lnk=gst&amp;q=screen+capture&amp;rnum=6#e600c892772bf52a
    for his time.sleep() Aha (This took me a year and a half to note!)

    Christian Wyglendowski, Werner Bruhin, and Xavier Morel for the
    http://wiki.wxpython.org/index.cgi/FlashingTaskbarIcon
    discussion

    'Rob aspn at msolutionsinc.com '
    http://mail.python.org/pipermail/python-win32/2003-June/001129.html
    for his suggestion to find out the foremost window

    and of course the usual suspects that created/maintain
    wxPython,
    PIL,
    pywin32,
    LEO,
    gvim,
    and Python itself.
"""</t>
<t tx="ekr.20070530072113">c.chapterController.hideChapters()</t>
<t tx="ekr.20070530072113.1">c.chapterController.showChapters()</t>
<t tx="ekr.20070531102813"></t>
<t tx="ekr.20070531103315">c.abbrevCommands.dynamicExpansion(event=None)</t>
<t tx="ekr.20070531104646">c.abbrevCommands.dynamicCompletion()</t>
<t tx="ekr.20070603175054">cc = c.chapterController
cc.selectChapterByName('abc')</t>
<t tx="ekr.20070603175054.1">cc = c.chapterController
cc.selectChapterByName('main')</t>
<t tx="ekr.20070603190713">cc = c.chapterController
cc.createChapterByName('xyz')</t>
<t tx="ekr.20070603190713.1">cc = c.chapterController
cc.selectChapterByName('xyz')</t>
<t tx="ekr.20070604095313"></t>
<t tx="ekr.20070604100125"></t>
<t tx="ekr.20070609085533"></t>
<t tx="ekr.20070630142904"></t>
<t tx="ekr.20070630142904.2">@nocolor

To build your module using GCC is a three step process on Unix:

1. Use Pyrex to translate mymodule.pyx to mymodule.c::

    python pyrexc mymodule.pyx

mymodule.pyx is the name of the Pyrex module you are writing.

2. Compile mymodule.c to mymodule.o::

    gcc -c -fPIC -I/usr/include/python2.2/ mymodule.c

-c  Produces a .o file instead of an executable. 
-fPIC Produces position independent code, so we can dynamically link against it later. 
-I/usr/include/python2.2/ is the location of the Python 2.2 include file.
 The location of your Python include file may differ from /usr/include/python2.2/. 

3 Link the mymodule.o into a mymodule.so::
    
    gcc -shared mymodule.o -lxosd -o mymodule.so

-shared produces a shared-object file, instead of an executable. 
-lxosd links against a C-library, with the name of the library given as the argument. 
</t>
<t tx="ekr.20070630142904.3">@nocolor

The pyrexc command supports the following options:

  Short Long              Argument    Description
  ----- ----              --------    -----------
  -v    --version                     Display version number of pyrex compiler
  -l    --create-listing              Write error messages to a .lis file
  -I    --include-dir     &lt;directory&gt; Search for include files in named 
                                      directory (may be repeated)
  -o    --output-file     &lt;filename&gt;  Specify name of generated C file (only
                                      one source file allowed if this is used)

Anything else is taken as the name of a Pyrex source file and compiled
to a C source file. Multiple Pyrex source files can be specified
(unless -o is used), in which case each source file is treated as the
source of a distinct extension module and compiled separately to
produce its own C file.
</t>
<t tx="ekr.20070630142904.4">def spam(int i, char *s):
    if 1:
        g.pr(i,s)</t>
<t tx="ekr.20070630142904.5"># Use pyrexc to create myModule.c from myModule.pyx.

import os,sys
python = sys.executable
theFile = r'C:\prog\tigris-cvs\leo\test\myModule.pyx'
pyrexc = r'c:\prog\Pyrex-0.9.6.4\pyrexc.py'
os.system(r'%s %s %s' % (python,pyrexc,theFile))

# Use pyrex/Demos/setup.py to create module on Linux.</t>
<t tx="ekr.20070723091227">
        
        
        </t>
<t tx="ekr.20070723091227.1"></t>
<t tx="ekr.20070723091227.2"></t>
<t tx="ekr.20070723091227.3"></t>
<t tx="ekr.20070927175908">'''Convert a normal Leo tree to a networkx graph'''
import networkx as nx
import sys

x = nx.Graph()

def node_id(p):
    return '%s: %s' % (id(p.v.t),p.headString())

def addTree(p):
    x.add_node(node_id(p))
    for child in p.children_iter():
        addTree(child)
        x.add_edge(node_id(p),node_id(child))

addTree(p)

g.pr('nodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('edges...\n', g.listToString(x.edges(),sort=True))
g.pr('yaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')
</t>
<t tx="ekr.20070928095102">@ This is a plain Leo tree.

You can convert it to a networkx graph using the leo2graph button.
</t>
<t tx="ekr.20070928095102.1"></t>
<t tx="ekr.20070928095102.2"></t>
<t tx="ekr.20070929062147">@nocolor

The following scripts convert between Leo trees and NetworkX graphs.

- leo2graph:            convert a normal Leo tree to a NetworkX graph.
- at-graph2graph:       convert an @graph tree to a Networkx graph.
- at-networkx2graph:    convert an @networkx tree to a Networkx graph
- at-networkx2at-graph: create an @graph tree from an @networkx tree.

Not ready yet:

- tree2pict: convert a Leo @graph tree to a picture of the corresponding graph.

@color</t>
<t tx="ekr.20070929062147.1">'''Convert an @graph tree to a networkx graph.'''
import networkx as nx
import sys

x = nx.Graph()

def node_id(p):
    return '%s: %s' % (str(p.v.t.fileIndex),p.headString())

def addTree(p):
    tag = '@link'
    h = p.headString()
    if h.startswith('@graph'):
        for child in p.children_iter():
            addTree(child)
    elif h.startswith('@node'):
        x.add_node(node_id(p))
        for child in p.children_iter():
            h = child.headString()
            if h.startswith(tag):
                link = h[len(tag):].strip()
                if link: x.add_edge(node_id(p),link)
            elif child.headString().startswith('@node'):
                addTree(child)
                x.add_edge(node_id(p),node_id(child))

addTree(p)

g.pr('nodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('edges...\n', g.listToString(x.edges(),sort=True))
g.pr('yaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')</t>
<t tx="ekr.20070929062147.2">'''Convert an @networkx node to a networkx graph.'''
import networkx as nx
import sys

@others

x = nx.Graph()

edges,nodes = parse(p)

for z in nodes:
    x.add_node(z)

for z in edges:
    a,b = z
    x.add_edge(a,b)

g.pr('\nnodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('\nedges...\n', g.listToString(x.edges(),sort=True))
g.pr('\nyaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')
</t>
<t tx="ekr.20070929070257">@ This is an @graph tree.

You can convert it to a networkx graph using the at-graph2graph button.</t>
<t tx="ekr.20070929070257.1"></t>
<t tx="ekr.20070929070257.2"></t>
<t tx="ekr.20070929070426">g.es('@link %s: %s' % (str(p.v.t.fileIndex),p.headString()))</t>
<t tx="ekr.20070929070632"></t>
<t tx="ekr.20070929070632.1"></t>
<t tx="ekr.20070929072043">@ This node defines a networkx graph using nodes and edges.

You can create an @graph tree from this node using the graph2at-graph button.
</t>
<t tx="ekr.20070929072506"># Each edge is represented as two lines.

# child1 --&gt; child2
('ekr', '20070929070257', 1): @node child1
('ekr', '20070929070257', 2): @node child2

# child2 --&gt; child1
('ekr', '20070929070257', 2): @node child2
('ekr', '20070929070257', 1): @node child1

</t>
<t tx="ekr.20070929072506.1"># Each node is on a separate line.

('ekr', '20070929070257', 1): @node child1
('ekr', '20070929070257', 2): @node child2
</t>
<t tx="ekr.20070929072506.2">def parseNodes (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(g.listToString(lines))
    return lines
</t>
<t tx="ekr.20070929074830">def parse (p):

    tag = '@networkx'
    if not p.headString().startswith(tag):
        p = g.findNodeAnywhere(c,tag)
        if not p.headString().startswith(tag):
            error('No %s node in the outline' % tag)
            return [],[]

    nodes = []
    for tag in ('@edges','@nodes'):
        node = g.findNodeInTree(c,p,tag)
        if node:
            nodes.append(node)
        else:
            error('No %s node in @networkx tree' % tag)
            return [],[]
    edgesNode,nodesNode = nodes
    edges = parseEdges(edgesNode)
    nodes = parseNodes(nodesNode)
    return edges,nodes
</t>
<t tx="ekr.20070929074830.1">def parseEdges (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(len(lines),lines)
    if (len(lines) % 2) == 0:
        i = 0 ; edges = []
        while i &lt; len(lines):
            data = lines[i],lines[i+1]
            edges.append(data)
            i += 2
        # g.trace(g.listToString(edges))
        return edges
    else:
        error('edges node must have even number of lines')
        return []

</t>
<t tx="ekr.20070929081505">def error (s):

    g.es_print(s,color='red')
</t>
<t tx="ekr.20070929082546">'''Convert an @networkx node to an @graph tree.
Create the tree as the child of the @graph-target node,
or the current position if no such node.'''

import networkx as nx
import sys

@others

g.pr('=' * 10)

p,edges,nodes = parse(p)

createTree(p,edges,nodes)
</t>
<t tx="ekr.20070929114410.2">def error (s):

    g.es_print(s,color='red')
</t>
<t tx="ekr.20070929114410.3">def parse (p):

    tag = '@graph-target'
    if not p.headString().startswith(tag):
        p = g.findNodeAnywhere(c,tag)
    if not (p and p.headString().startswith(tag)):
        p = c.currentPosition() # Use the presently selected node.

    nodes = [] ; tag = '@networkx'
    data = g.findNodeAnywhere(c,tag)
    if not data:
        error('No %s tree' % tag)
        return None,[],[]
    for tag in ('@edges','@nodes'):
        node = g.findNodeInTree(c,data,tag)
        if node:
            nodes.append(node)
        else:
            error('No %s node in @networkx tree' % tag)
            return None,[],[]
    edgesNode,nodesNode = nodes
    edges = parseEdges(edgesNode)
    nodes = parseNodes(nodesNode)
    return p,edges,nodes
</t>
<t tx="ekr.20070929114410.4">def parseNodes (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(g.listToString(lines))
    return lines
</t>
<t tx="ekr.20070929114410.5">def parseEdges (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(len(lines),lines)
    if (len(lines) % 2) == 0:
        i = 0 ; edges = []
        while i &lt; len(lines):
            data = lines[i],lines[i+1]
            edges.append(data)
            i += 2
        # g.trace(g.listToString(edges))
        return edges
    else:
        error('edges node must have even number of lines')
        return []

</t>
<t tx="ekr.20070929114617">@ This will be the root node for the @graph tree produced by the at-networkx2at-graph button.</t>
<t tx="ekr.20070929115302">def createTree (parent,edges,nodes):

    if 0:
        g.trace('nodes...\n', g.listToString(nodes,sort=True))
        g.trace('edges...\n', g.listToString(edges,sort=True))

    c.beginUpdate()
    try:
        p = parent.insertAsLastChild()
        p.setHeadString('@graph')
        d = createNodes(p,nodes)
        createEdges(d,edges)
        c.selectPosition(p)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070929120541">def createEdges (d,edges):

    for edge in edges:
        a,b = edge
        g.trace('\n%s --&gt; %s' % (a,b))
        p = d.get(a)
        if p:
            p2 = p.insertAsLastChild()
            p2.setHeadString('@link %s' % (b))
        else:
            error('@node not found: %s' % (a))
</t>
<t tx="ekr.20070929120541.1">def createNodes (parent,nodes):

    d = {}

    for node in nodes:
        # g.trace(node)
        p = parent.insertAsLastChild()
        p.setHeadString('@node %s' % (node))
        d[node] = p.copy()

    return d
</t>
<t tx="ekr.20070929122956"></t>
<t tx="ekr.20070929122956.1"></t>
<t tx="ekr.20071002150320">log = c.frame.log
tag = 'my-canvas'

w = log.canvasDict.get(tag)
if not w:
    w = log.createCanvas(tag)
    w.configure(bg='yellow')

log.selectTab(tag)
</t>
<t tx="ekr.20071006084354">w = c.frame.body.bodyCtrl
s = w.getAllText()
ins = w.getInsertPoint()
row,col = g.convertPythonIndexToRowCol(s,ins)
g.pr('row',row,'col',col)</t>
<t tx="ekr.20071025192258">import leoTest
leoTest.doTests (c,all=False)</t>
<t tx="ekr.20071025193940"># attrib_edit.py
# ctagscompleter.py
codewisecompleter.py
# rst3.py
# contextmenu.py
plugins_menu.py
# open_with.py
quicksearch.py
# ipython.py
# templates.py
scrolledmessage.py
UNL.py
mod_scripting.py
# stickynotes.py # requires Python 3.0
# stickynotes_plus.py
# pydeeshell.py
# nodenavigator.py
# vim.py
# xemacs.py

# test of @bool warn_when_plugins_fail_to_load
# xyzzy.py 

# Other interesting plugins
# leo_to_html.py
# leoOPML.py
nav_qt.py
# graphed.py

# Tk plugins...
# cleo.py
# color_markup.py # Does not work with threading colorizer.
# image.py
# nav_buttons.py
# rClick.py
# threading_colorizer.py
# toolbar.py
</t>
<t tx="ekr.20071026102420.2"></t>
<t tx="ekr.20071026102420.3"></t>
<t tx="ekr.20071105085941"></t>
<t tx="ekr.20071128122043">log = c.frame.log ; tag = 'Shell'
frame1 = log.frameDict.get(tag)
shellKind = 'text' # in ('plain','text','canvas')

if frame1:
    log.selectTab(tag)
elif shellKind == 'plain':
    log.selectTab (tag,createText=False)
    frame = log.frameDict.get(tag)
elif shellKind == 'text':
    log.selectTab (tag,createText=True)
    frame = log.textDict.get(tag)
elif shellKind == 'canvas':
    log.createCanvas(tag)
    log.selectTab(tag)
    frame = log.canvasDict.get(tag)
else:
    frame = None
    g.es('bad shellKind',shellKind)

if frame and not frame1:
    frame.configure(bg='white')
    g.pr('logFrame',log.frameDict.get(tag))
</t>
<t tx="ekr.20071129103842"># A script to create @auto nodes from all .py files in a directory.

import glob,os

reallyCreate = True
baseDir = r'c:\leo.repo\pythoscope\lib2to3\pgen2'
dirs = (r'',)
g.pr('-----')

for theDir in dirs:
    pattern = g.os_path_join(baseDir,theDir,'*.py')
    files = glob.glob(pattern)
    g.pr(pattern)
    # g.pr(g.listToString(files))
    for name in files:
        h = '@auto %s' % (name[len(baseDir) + 1:].strip())
        g.pr('creating',h)
        if reallyCreate:
            child = p.insertAsLastChild()
            child.initHeadString(h)</t>
<t tx="ekr.20080105115712"># This hangs Leo while pylint is running.
import pylint.lint as lint
import sys

rcFile = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','pylint-leo-rc.txt'))
rcArg = '--rcfile=%s' % rcFile
&lt;&lt; define data &gt;&gt;

# We expect only one W104 error, in leoGlobals.py
g.pr('\n','=' * 40)
for name,s in data:
    name2 = g.os_path_abspath(g.os_path_join(g.app.loadDir,name))
    args = [name2,rcArg]
    if s.strip():
        args.append('--disable-msg=%s' % s)
    g.pr(name,s)
    lint.Run(args)
g.pr('\n' + 'End of pylint run')</t>
<t tx="ekr.20080105120559">data = (
    ('leoAtFile.py',''), 
    ('leoChapters.py',''),
    ('leoCommands.py',''), 
    ('leoEditCommands.py','E1101'),
    ('leoFileCommands.py',''), 
    ('leoFind.py',''),
    ('leoFrame.py',''),
    ('leoGlobals.py','E0602,E1101'),
    ('leoGui.py',''),
    ('leoImport.py',''),
    ('leoMenu.py',''),
    ('leoNodes.py',''),
    ('leoPlugins.py',''),
    ('leoTangle.py',''),
    ('leoUndo.py','W0102'),
    ('leoTkinterDialog.py',''),
    ('leoTkinterFind.py',''),
    ('leoTkinterGui.py',''),
    ('leoTkinterFrame.py','W0221'),
    ('leoTkinterKeys.py',''), 
    ('leoTkinterMenu.py',''), 
    ('leoTkinterTree.py',''),
)
</t>
<t tx="ekr.20080105130903">@nocolor
@
C0111 Missing docstring
C0301 Line too long
C0311 Bad indentation
C0321 More than one statement on a single line
C0322 Operator not preceded by a space
C0323 Operator not followed by a space
C0324 Comma not followed by a space

R0201 Method could be a function.
R0903 Too few public methods (0/1)

W0102 Dangerous default value [] as argument
W0104 Statement seems to have no effect
W0106 Unnecessary semicolon
W0107 Unnecessary pass statement
W0122 Use of the exec statement
W0141 Used builtin function 'map'
W0142 Used * or * magic*
W0201 Attribute defined outside __init__
W0212 Access to a protected member of a client class
W0231 __init__ method from base class is not called
W0232 Class has no __init__ method
W0401 Wildcard import (pychecker)
W0402 Uses of a deprecated module (like string)
W0404 Reimport &lt;module&gt;: let pychecker do this.
W0406 Module import itself
W0602 Using global for x but no assigment is done (leoEditCommands defines classList after all classes).
W0603 Using the global statement
W0612 Unused variable
W0613 Unused argument (sometimes used for debugging)
W0621 Redefining &lt;name&gt; from outer scope: especially __pychecker__
W0622 Redefining built-in
W0631 Using possibly undefined loop variable
W0702 No exception type specified
W0703 Catch "Exception"
W0704 Except doesn't do anything (Except: pass)
W1111 Assigning to a function call that only returns None</t>
<t tx="ekr.20080115085447">@nocolor
@

************* Module leoGlobals
W0104:3871: Statement seems to have no effect
</t>
<t tx="ekr.20080206055658">g.pr('settings...')
for z in ('body','button','headline','log','menu','outline'):
    for z2 in ('family','size','slant','weight',):
        setting = '%s_text_font_%s' % (z,z2)
        g.pr(setting,c.config.get(setting,z2))

g.pr('default sizes...')
for z in ('Body','Log','Menu','Tree'):
    setting = 'default%sFontSize' % z
    g.pr(setting,getattr(c.config,setting))

g.pr('actual fonts...')
for z in ('body','button','headline','log','menu','outline'):
    kind = ('family','size','slant','weight')
    arg0,arg1,arg2,arg3 = args = ['%s_text_font_%s' % (z,z2) for z2 in kind]
    setting = '%s_text_font' % (z)
    g.pr('%20s' % (setting),c.config.getFontFromParams(arg0,arg1,arg2,arg3,defaultSize=12))
</t>
<t tx="ekr.20080214091706.2">g.pr('hello from ekr')</t>
<t tx="ekr.20080310111916.1">def myTranslateString (s):

    i = s.lower().find('can not')
    if i == -1:
        return s
    else:
        return s[:i+1] + "an't" + s[i+7:]

g.translateString = myTranslateString

</t>
<t tx="ekr.20080412082246.1"></t>
<t tx="ekr.20080503202744.3">import rope.base.project
import rope.contrib.codeassist as codeassist
import leo.core.leoGlobals as g
import leo.core.leoCommands as leoCommands
c2 = leoCommands.Commands(frame=c.frame,fileName='xyz-file')

class leoFSCommands (object):
    def create_file(self,path):         g.trace(path)
    def create_folder(self,path):       g.trace(path)
    def move (self,path,new_location):  g.trace(path,new_location)
    def remove (self,path):             g.trace(path)
    def write (self,path,data):         g.trace(path,data)

path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','..'))
    # Make the trunk folder a project
project = rope.base.project.Project(path,fscommands=leoFSCommands)
s = p.bodyString() # Could simulate a write to allow @others.

g.pr('*' * 40)
for pattern in (
    # 'g.', # works.
    # 'g.trace(', # weird.
    # 'rope.base.', # works.
    'g.list', # works: gives g.listToString
    'c2.de', # works.
):
    i = s.find(pattern)
    if i &gt; -1:
        proposals = codeassist.code_assist(project,s,i+len(pattern))
        g.pr('-' * 20)
        g.pr('pattern:',pattern)
        g.pr(g.listToString(proposals))</t>
<t tx="ekr.20080529111617.1"></t>
<t tx="ekr.20080529111617.10">The name of time unit (e.g. days, weeks, hours)</t>
<t tx="ekr.20080529111617.2"></t>
<t tx="ekr.20080529111617.3">The colour used instead of green in progress bars</t>
<t tx="ekr.20080529111617.4">The colour used instead of red in progress bars</t>
<t tx="ekr.20080529111617.5"># list of @file node types to color.
# Uncomment these to enable coloring for these kinds of nodes.
# @asis
# @file
# @auto
# @thin
@auto</t>
<t tx="ekr.20080529111617.6">The base width of progress bars, in pixels.</t>
<t tx="ekr.20080529111617.7">The default number of time units.</t>
<t tx="ekr.20080529111617.8">0: no progress bars
1: unscaled progress bars
2: scaled progress bars</t>
<t tx="ekr.20080529111617.9">pixels per time unit to add to width of scaled progress bars</t>
<t tx="ekr.20080531080812.1">def eggs():
    g.trace()

def spam():
    g.trace()
    eggs()

t = g.startTracer()
spam()
t.stop()
</t>
<t tx="ekr.20080531131542.1">import mx.TextTools as tt

&lt;&lt; define scan4 tables &gt;&gt;
&lt;&lt; define s &gt;&gt;

@others

g.pr('*' * 60)
ok,taglist,nextindex = tt.tag(s,lineTable)
# g.pr(g.listToString(taglist))
for z in taglist:
    printItem(z,level=0)
g.pr('ok:',ok)
</t>
<t tx="ekr.20080531131542.2">from mx.TextTools import * # Required for tags.

ws_charset   = CharSet(' \t')
name_charset = CharSet(alpha)

gnxTable = (
    (None,Is,':',MatchFail),
    (None,AllNotIn,':',MatchFail),
    (None,Is,':',MatchFail,MatchOk),
)

sentinelNameTable = (
    (None,Is,'@',+1,+3),
    (None,Is,'+',+1,+2),
    (None,Is,'-',+1),
    (None,AllInCharSet,name_charset,MatchFail,MatchOk),
)

sentinelTable = (
    # Start of another line.
    # Skip ws.
    (None,AllInCharSet,ws_charset,+1),
    # Require sentinel comment.
    (None,Word,'#@',MatchFail),
    ('kind',Table,sentinelNameTable,MatchFail),
    ('gnx',Table,gnxTable,+1),
    # Everything else is the sentinel value
    ('extra',AllNotIn,'\n',+1),
    (None,Is,'\n',MatchOk,MatchOk),
)

normalLineTable = (
    (None,AllNotIn,'\n',+1),
    (None,Is,'\n',MatchOk,MatchOk),
)

lineTable = (
    ('sent',Table,sentinelTable,+1,+2),
    ('line',Table,normalLineTable,+1,+1),
    ('eof',EOF,Here,-2),
)</t>
<t tx="ekr.20080531131542.4">def printItem(aList,level):

    obj,lt_index,rt_index,subtag = aList
    g.pr('  '*level,obj,repr(s[lt_index:rt_index]))
    if subtag:
        for z in subtag:
            printItem(z,level+1)
</t>
<t tx="ekr.20080531141227.1">path = r'c:\leo.repo\trunk\leo\core\runLeo.py'
f = file(path)
s = f.read()
f.close()</t>
<t tx="ekr.20080604104453.5">@nocolor

This setting determines the initial binding for otherwise-unbound keystrokes
when no mode is in effect.  Note: the keyboard-quit command exits all modes.

The valid values are::

command:  Leo ignores the key (like Vim).
insert:  Leo inserts the key at the cursor (like Emacs)
overwrite: Leo replaces the character at the cursor.</t>
<t tx="ekr.20080617170334.1">@first # -*- coding: utf-8 -*-

import Tkinter as Tk

top = Tk.Toplevel()
w = Tk.Text(top)
w.pack()

def key(event):
    if event.char: g.pr('state',event.state,'char', repr(event.char), repr(event.keysym))

def after():
    g.trace()
    w.event_generate('&lt;Key&gt;',keysym='a')
    w.event_generate('A')
    w.event_generate(g.toEncodedString('Á',encoding='utf8'))
    # w.event_generate('&lt;Key-Control_L&gt;')
    # w.event_generate('c')
    # w.event_generate('Shift-Control-a')

w.bind('&lt;Key&gt;',key)
w.focus_set()
w.update()
# top.after_idle(after)
top.mainloop()
</t>
<t tx="ekr.20080628094340.1">if 0:
    # Called when func is **defined**
    def leo_command(func):
        g.trace(func.__name__)
        return func
else:
    class leo_command:
        def __init__(self,func,c=c):
            self.c = c
            self.func = func
            self.name = func.__name__
            g.pr("registering",self.name)

        def __call__(__self,*__args,**__kw):
            g.pr("before", __self.name)
            try:
                return __self.func(*__args,**__kw)
            finally:
                g.pr("after ", __self.name)
                g.pr('c',c)
                c.outerUpdate()


@leo_command
def hello():
    g.pr("Hello, world!")

hello()
</t>
<t tx="ekr.20080701101740.1">import locale
aList = dir(locale)
# g.pr(g.listToString(aList))

g.pr(g.getpreferredencoding())
# import os
# g.pr(dir(os))
</t>
<t tx="ekr.20080701130406.1">import glob

aList = glob.glob(r'c:\leo.repo\trunk\leo\plugins\*.py')
for z in aList:
    name = g.shortFileName(z)
    if not name.startswith('_'):
        g.pr('echo .')
        g.pr('echo',name)
        g.pr('call pylint.bat core\%s' % name)</t>
<t tx="ekr.20080729153237.1"></t>
<t tx="ekr.20080729153237.2"># True: calls to the garbage collector.</t>
<t tx="ekr.20080729153237.3"># True (recommended): print a message when Leo calls gc.collect explicitly.</t>
<t tx="ekr.20080729153237.4"># True: verbose trace the garbage collector.</t>
<t tx="ekr.20080806145258.1"></t>
<t tx="ekr.20080806145258.12">@nocolor

Notes:
    
- button Leo2dHTML creates leo\test\x.htm, where x is the name of the .leo file
  containing the script. The file contains javascript that allows a browser to
  expand and contract headlines.  Leo2DHTML is *unrelated* to the other files.
    
- leo\test\server.py is a minimal Python server.  Invoke from a console with::
    
    python server.py

To use this server, type this url in a web browser: http://localhost:8080/
The server will print the contents of the directory from which it was invoked.
Choose hello.html to see the 'Hello World' test page.

- leo\test\hello.html is a test page.  It uses leo\test\cgi-bin\edward.py

- leo\test\cgi-bin\edward.py is the script called from hello.leo when the user
  hits the 'Submit Query button.
  This is recompiled (as needed) for every query, which makes testing it easier.
  
  **Important** edward.py returns its result by printing (in a special format):
  Thus, everything you print will be part of the returned form(!). You **can**
  print debug info: just make sure you don't mess up the special conventions:
  the best place to print debugging info is in print_all.

@color</t>
<t tx="ekr.20080806145258.13">@

edward.py:
    
How can we get the content of an input form?</t>
<t tx="ekr.20080806145258.14">@first # -*- coding: utf-8 -*-
@language python
@tabwidth -4

&lt;&lt; about LeoToHTML &gt;&gt;
import leo.core.leoGlobals as g
&lt;&lt; define dhtml stuff &gt;&gt;
@others

fileName = c.frame.shortFileName() # Get current outline file name
if fileName.endswith('.leo'): fileName = fileName[:-4] # Remove .leo suffix
path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test',fileName)) + '.htm'

# Write the file.
f=open(path, 'w')
writeAll(f)
f.close() 
g.es('wrote: %s' % (path),color="turquoise4") 
</t>
<t tx="ekr.20080806145258.15">@

LeoToHTML by Dan Rahmel, modified by EKR.

This @button script creates an .htm file containing the contents of the selected tree.
The file is called x.htm, where x is the name of the .leo file containing the script.
This file is written to the leo/test folder.

The script inserts javascript into the page so that nodes can be expanded and contracted.

The script presently works well.  This script may become the basis for a facebook app.

The generated html passes html-tidy: http://www.w3.org/People/Raggett/tidy/
</t>
<t tx="ekr.20080806145258.16">division = """
&lt;div STYLE="margin-left:3em;text-indent:0em;margin-top:0em; margin-bottom:0em;"&gt;
&lt;h3 onClick="expandcontent('sc%d')" style="cursor:hand; cursor:pointer; margin-top:0em; margin-bottom:0em"&gt;+ %s&lt;/h3&gt;
    &lt;div id="sc%d" class="switchcontent" style="margin-top:0em; margin-bottom:0em;"&gt;
"""

javascript  = """
&lt;script src="cgi-bin/leo.js" type="text/javascript"&gt;&lt;/script&gt;
"""

style = '''
&lt;STYLE type="text/css"&gt;
    BODY {font:x-medium 'Verdana'; margin-right:1.5em}
    PRE {margin:0px; display:inline}
&lt;/STYLE&gt;
'''
</t>
<t tx="ekr.20080806145258.17">def escape (s):

    return s.replace('&amp;','&amp;amp;').replace('&lt;','&amp;lt;').replace('&gt;','&amp;gt;')
</t>
<t tx="ekr.20080806145258.18">def writeAll(f):

    f.write('&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;')
    f.write('&lt;html&gt;')
    writeHead(f)
    writeBody(f)
    f.write("&lt;/html&gt;")
</t>
<t tx="ekr.20080806145258.19">def writeBody(f):

    f.write('&lt;body class="st" onload="format()"&gt;')
    writeContents(f)
    f.write("&lt;/body&gt;")
</t>
<t tx="ekr.20080806145258.20">def writeHead(f):

    f.write('&lt;head&gt;')
    f.write(style)
    f.write(javascript)
    f.write('&lt;title&gt;%s&lt;/title&gt;' % c.shortFileName())
    f.write('&lt;/head&gt;')
</t>
<t tx="ekr.20080806145258.21">def writeContents(f):

    div = "&lt;div class='c' STYLE='margin-left:4em;margin-top:0em; margin-bottom:0em;'&gt;\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n&lt;/div&gt;"
    end_div = "&lt;/div&gt;\n&lt;/div&gt;\n"
    n = 1 # The node number
    current = c.currentPosition()
    prev_level = current.level()
    open_divs = 0
    for p in current.self_and_subtree_iter():
        h = p.headString()
        while prev_level &gt;= p.level() and open_divs &gt; 0:
            f.write(end_div)
            prev_level -= 1
            open_divs -= 1
        body = p.bodyString().encode( "utf-8" )
        body = body.rstrip().rstrip("\n")
        f.write(division % (n,escape(h),n))
        open_divs += 1
        if body:
            f.write(div % escape(body))
        prev_level = p.level()
        n += 1

    # Close all divisions.
    while open_divs &gt; 0:
        f.write(end_div)
        open_divs -= 1
</t>
<t tx="ekr.20080806145258.22"># def writePreamble(f):

    # '''Write HTML header information.'''

    # header_start = '''\


# &lt;body class="st" onload="format()"&gt;
# '''

    # for s in (header_start,style,javascript,header_end):
        # # f.write(g.adjustTripleString(s,c.tab_width))
        # f.write(s)
</t>
<t tx="ekr.20080806145258.23"># def writePostamble (f):

    # pass

</t>
<t tx="ekr.20080806145258.24"># A minimal python server for testing.
# To access this server, type this url in a web browser: http://localhost:8080/
# The server will print the contents of the directory from which it was invoked.
# Choose hello.html to see the 'Hello World' test page.

import CGIHTTPServer
import SocketServer

port = 8080

Handler = CGIHTTPServer.CGIHTTPRequestHandler
s = SocketServer.TCPServer(("", port), Handler)

s.server_name = '127.0.0.1' # represents local host.
s.server_port = port

# import os ; print 'cwd', os.getcwd()

print "server.py: serving at port", port
s.serve_forever()
</t>
<t tx="ekr.20080806145258.25">@language html

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;/title&gt;

&lt;!-- Used by edward.old.py
&lt;script language="JavaScript" type="text/javascript"&gt;
   var openImg = new Image();
   openImg.src = "open.gif";
   var closedImg = new Image();
   closedImg.src = "closed.gif";

   function showNode(node) {
      var objBranch = 
         document.getElementById(node).style;
      if(objBranch.display=="block")
         objBranch.display="none";
      else
         objBranch.display="block";
   }

   function swapFolder(img) {
      objImg = document.getElementById(img);
      if(objImg.src.indexOf('closed.gif')&gt;-1)
         objImg.src = openImg.src;
      else
         objImg.src = closedImg.src;
   }
&lt;/script&gt;
--&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;form action="cgi-bin/edward.py" method="GET"&gt;
&lt;input type="submit" name="George"&gt;
&lt;/form&gt;

&lt;p&gt;This is the hello world test page.
The server in server.py should be running when using this page.

&lt;p&gt;The button (form) above should cause the server to send a "GET" request
to the edward.py script, which will respond with a new page.

&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20080806145258.26">@first #! c:\python25\python.exe
@first # -*- coding: utf-8 -*-

'''This is the cgi script called from hello.html when the user hits the button.'''

### Print statements are used to return results (return the form).
### You *can* use print statement for tracing, but only in print_all.
# To do: use cgi.FieldStorage.

@language python
@tabwidth -4
&lt;&lt; imports &gt;&gt;
&lt;&lt; define dhtml stuff &gt;&gt;
@others

if 1: # Open the bridge.
    path = os.path.abspath(os.path.join(leoParentDir,'leo','test','test.leo')) # c does not exist!
    b = leoBridge.controller(gui='nullGui',loadPlugins=False,readSettings=False,verbose=False)
    g = b.globals()
    c = b.openLeoFile(path)
    p = c.rootPosition()
else:
    c = None

# import pdb ; pdb.Pdb() # Doesn't work.
print_all(c)</t>
<t tx="ekr.20080806145258.27">division = """
&lt;div STYLE="margin-left:3em;text-indent:0em;margin-top:0em; margin-bottom:0em;"&gt;
&lt;h3 onClick="expandcontent('sc%d')" style="cursor:hand; cursor:pointer; margin-top:0em; margin-bottom:0em"&gt;+ %s&lt;/h3&gt;
    &lt;div id="sc%d" class="switchcontent" style="margin-top:0em; margin-bottom:0em;"&gt;
"""

style = """
&lt;STYLE type="text/css"&gt;
    BODY {font:x-medium 'Verdana'; margin-right:1.5em}
    PRE {margin:0px; display:inline}
&lt;/STYLE&gt;
"""</t>
<t tx="ekr.20080806145258.28">def escape (s):

    return s.replace('&amp;','&amp;amp;').replace('&lt;','&amp;lt;').replace('&gt;','&amp;gt;')
</t>
<t tx="ekr.20080806145258.29">def print_all(c):

    # This line is required (with extra newline), but does not show on the page.
    print "Content-type:text/html\n"

    print '&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;'
    print '&lt;html&gt;'
    if c:
        # Print the page.
        print_head(c)
        print_body(c)
    else:
        # Print the debugging info.
        print '__file__',__file__
        print 'os.getcwd()',os.getcwd()

    print '&lt;/html&gt;'
</t>
<t tx="ekr.20080806145258.30">def print_body(c):

    print '&lt;body class="st" onload="format()"&gt;'

    if 0:
        # Debugging info.
        form = cgi.FieldStorage()
        print repr(form)
        # if form.has_key('name'):
            # print 'name',form['name'].value
        # else:
            # print 'no name'
    print_tree(c)
    print '&lt;/body&gt;'
</t>
<t tx="ekr.20080806145258.31">def print_head(c):

    print '&lt;head&gt;'

    if 1: # Copy the entire leo.js file into the page.
        print '&lt;script type="text/javascript"&gt;'
        print_leo_dot_js(c)
        print '&lt;/script&gt;'

    else: # Possible bug in the python server??
        # The Python says leo.js is not executable(!)
        print '&lt;script src="leo.js" type="text/javascript"&gt;&lt;/script&gt;'

    print '&lt;title&gt;%s&lt;/title&gt;' % (c.shortFileName())
    print '&lt;/head&gt;'
</t>
<t tx="ekr.20080806145258.32">def print_leo_dot_js(c):

    path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','cgi-bin','leo.js'))

    try:
        f = file(path)
    except IOError:
        print 'can not open',path
        return

    for line in f.readlines():
        print line,

    f.close()
</t>
<t tx="ekr.20080806145258.33">def print_tree(c):

    div = "&lt;div class='c' STYLE='margin-left:4em;margin-top:0em; margin-bottom:0em;'&gt;\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n&lt;/div&gt;"
    end_div = "&lt;/div&gt;\n&lt;/div&gt;\n"
    n = 1 # The node number
    prev_level = 0
    open_divs = 0
    for p in c.allNodes_iter():
        h = p.headString()
        while prev_level &gt;= p.level() and open_divs &gt; 0:
            print end_div
            prev_level -= 1
            open_divs -= 1
        body = p.bodyString().encode( "utf-8" )
        body = body.rstrip().rstrip("\n")
        print division % (n,escape(h),n)
        open_divs += 1
        if body: print div % escape(body)
        prev_level = p.level()
        n += 1

    # Close all divisions.
    while open_divs &gt; 0:
        print end_div
        open_divs -= 1
</t>
<t tx="ekr.20080806145258.34"></t>
<t tx="ekr.20080806145702.1">import os
import sys

# Add the *parent* of the leo directory to sys.path.
leoParentDir = os.path.abspath(os.path.join(os.path.dirname(__file__),'..','..','..'))

if leoParentDir not in sys.path:
    sys.path.append(leoParentDir)

import leo.core.leoBridge as leoBridge

import cgi
import cgitb ; cgitb.enable()
</t>
<t tx="ekr.20080807114145.2">@
A script button to run any body text as a Windows Script.
See: http://en.wikipedia.org/wiki/Windows_Script_Host

You need the win32 extensions and you must enable the script engine.
Adapted from Active State examples:ch21_active_scripting:ActiveApp.py
http://python.net/crew/mhammond/win32/
@c

&lt;&lt; imports &gt;&gt;

@others

RunCode("python",p.bodyString())
</t>
<t tx="ekr.20080807115344.1">Application.Echo("Hello from Python")
</t>
<t tx="ekr.20080807115344.2">class MySite(axsite.AXSite):
    # Our error handler will simply print to the console.
    def OnScriptError(self, activeScriptError):
        exc = activeScriptError.GetExceptionInfo()
        print "Exception:", exc[1]
        try:
            sourceText = activeScriptError.GetSourceLineText()
        except pythoncom.com_error:
            sourceText = None
        if sourceText is not None: 
            context, lineNo, charNo = activeScriptError.GetSourcePosition()
            print sourceText
            indent = " " * (charNo-1)
            print indent + "^"
        return winerror.S_OK
</t>
<t tx="ekr.20080807115344.3"># A named object for our namespace
# A normal Python COM object (minus registration info)
class Application:
    _public_methods_ = [ 'Echo' ]
    def Echo(self, *args):
        print string.join(map(str, args))

</t>
<t tx="ekr.20080807115344.4"># Create the site and the engine and runs the code.
def RunCode(engineName, code):

    app = win32com.server.util.wrap( Application() )

    # Create a dictionary holding our object model.
    model = {'Application' : app,}

    # Create the scripting site.
    site = MySite(model)
    # Create the engine and add the code.
    engine = site.AddEngine(engineName)
    engine.AddCode(code)

    # Run the code.
    engine.Start()
</t>
<t tx="ekr.20080807115344.5">import string
import sys
from win32com.axscript import axscript
from win32com.axscript.server import axsite
import pythoncom
import win32com.server.util</t>
<t tx="ekr.20080811113441.2"></t>
<t tx="ekr.20080813100905.1">import sys
print sys.argv</t>
<t tx="ekr.20080815073750.1">n = 0
for p in c.allNodes_iter():
    if p.isAtNoSentFileNode():
        c.atFileCommands.write(p,nosentinels=True)
        n += 1
g.es('done: %s files written' %(n))</t>
<t tx="ekr.20080821111715.1">@first # -*- coding: utf-8 -*-

# Important: see http://webpages.charter.net/edreamleo/FAQ.html#unicode-issues

import sys

print '=' * 40

e = sys.getdefaultencoding()
assert e.lower() == 'utf-8'
print 'encoding',e

table = (
    'La Peña',
    unicode('La Peña','utf-8'),
    u'La Peña',
    u'La Pe\xf1a',
    # u'AA \u0102 BB',
)

for s in table:
    print type(s)
    g.es_print('g.es_print',s)
    if type(s) != type(u'a'):
        s = unicode(s,e)
    print      'print     ',s
    print      'repr(s)   ',repr(s)
</t>
<t tx="ekr.20080822153619.1"></t>
<t tx="ekr.20080823154546.1">p2 = p.insertAfter()
p2.setHeadString('inserted node')
s = p.bodyString()

# Remove Leo directives.
directives = ['@'+z for z in g.globalDirectiveList]
def isDirective(s):
    for z in directives:
        if s.startswith(z):
            return True
    else: return False
aList = [z for z in g.splitLines(s) if not isDirective(z)]
s = ''.join(aList)
if not s.endswith('\n'): s = s + '\n'

c.importCommands.scanPythonText(s,p2.copy(),atAuto=True)
c.redraw_now()
g.pr('done')</t>
<t tx="ekr.20080915095329.1">import leo.core.leoPlugins as leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    controller = rst3.controllers.get(c)
    if controller:
        controller.processTopTree(p)
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True

# print 'done'
</t>
<t tx="ekr.20080917063615.1">aList = (
'aspellbindir',
'wholeword',
'Whole-Word',
'vimcmd',
'huh',
)

for name in aList:
    kind, val = c.config.getSettingSource(name)
    print '%-20s %-20s %s' % (name,repr(val),kind)
</t>
<t tx="ekr.20080920101658.1">def getInput (event=None):

    '''Evaluate a Python Expression entered in the minibuffer.'''

    stateName = 'get-input'
    k = c.k ; state = k.getState(stateName)

    if state == 0:
        k.setLabelBlue('Input: ',protect=True)
        k.getArg(event,stateName,1,getInput)
    else:
        k.clearState()
        g.es_print('input:',k.arg)

getInput()
</t>
<t tx="ekr.20080921144924.1">print(g.os_path_finalize(r'~/.leo/notebook.leo'))
print(g.os_path_finalize(g.os_path_join(g.app.loadDir,r'~/.leo/notebook.leo')))
print(g.os_path_finalize_join(g.app.loadDir,r'~/.leo/notebook.leo'))</t>
<t tx="ekr.20080922142953.1"># @string default_leo_file = ~/.leo/workbook.leo
path = "{{c.config.getString('default_leo_file')}}"
# print g.os_path_expandExpression(path,c=c)
print g.os_path_finalize(path,c=c)</t>
<t tx="ekr.20080922164255.1"></t>
<t tx="ekr.20080922164255.2"></t>
<t tx="ekr.20080922164656.1"></t>
<t tx="ekr.20080923073240.1">{{c.config.getString('test')}}/eval-test.txt
=
c:\leo.repo\trunk\leo\test\eval-test.txt</t>
<t tx="ekr.20080923073240.2"></t>
<t tx="ekr.20080924081821.1"># c.k.ab

# Test this code using the execute-script command.

s = p.bodyString()
lines = g.splitLines(s)
s = lines[0]

theObject,aList = c.k.autoCompleter.getExternalCompletions(s)

print '='*20
print 'theObject',theObject and theObject.__class__
print 'len(completions)',len(aList)
print g.listToString(aList, tag='completion list', sort=True, indent='')
</t>
<t tx="ekr.20080930080501.1">c.frame.iconBar.addRow()
c.frame.addIconButton(text="New")</t>
<t tx="ekr.20080930083052.1">c.frame.hideIconBar()</t>
<t tx="ekr.20080930083052.2">c.frame.showIconBar()</t>
<t tx="ekr.20080930085514.1">c.frame.clearIconBar()</t>
<t tx="ekr.20080930114036.1"></t>
<t tx="ekr.20081003094737.1"></t>
<t tx="ekr.20081025105942.1">import os
os.system("dir")</t>
<t tx="ekr.20081205104320.1"># import os
tag = '#!/bin/bash\n'
s = g.getScript(c,p,
    useSelectedText=False,
    forcePythonSentinels=False,
    useSentinels=True)
if not s.startswith(tag):
    s = tag + s
print s
os.system(s)
</t>
<t tx="ekr.20090128112453.1"># print p.b
# p.b = p.b + '\n# new'
# p.h = p.h + 'z'

print c.p

if 0:
    print p.v.u
    print p.v.u.get('key')
    p.v.u['key'] = 'abc'
    print p.v.u.get('key')
    p.v.u = {'key':'xyz'}
    # p.v.u = 'abc'
    print p.v.u

if 0:
    print p.v.t.u
    print p.v.t.u.get('t-key')
    p.v.t.u['t-key'] = 'pdq'
    print p.v.t.u.get('t-key')
    # p.v.t.u = {'key':'pdq'}
    # # p.v.t.u = 'pdq'
    # print p.v.t.u</t>
<t tx="ekr.20090128131130.1">aList = g.posList(c) # Start with all positions
print len(aList)
aList2 = aList.select('plugin',regex=False,removeClones=True)
print aList2.dump(sort=True)
aList3 = aList2.select('http')
print aList3.dump()

# To see the docstring, enable auto-completion and type g.posList?
# g.posList</t>
<t tx="ekr.20090201162523.1"># define a macro: ctrl-f ab ctrl-r AB
pass</t>
<t tx="ekr.20090201192257.1">b = p.b
try:
    w = c.frame.body.bodyCtrl
    w.setInsertPoint(0)
    m = c.macroCommands
    fn = g.os_path_finalize_join(g.app.loadDir,'..','..','ekr-macros.txt')
    f = open(fn)
    m.loadMacros(f)
    macro = m.namedMacros.get('ab')
    assert macro
    m.executeMacro(macro)
finally:
    assert p.b =='ab' + b,p.b
    p.b = b
</t>
<t tx="ekr.20090205070715.1">#colorer = c.frame.body.colorizer.highlighter.colorer
g.es ('total characters: %s, keywords: %s, leo_keywords: %s' % (
    colorer.totalChars,
    colorer.totalKeywordsCalls,
    colorer.totalLeoKeywordsCalls))</t>
<t tx="ekr.20090218112656.1"># 'self' is now defined in @test and @suite nodes.
self.assertEqual(1,1)</t>
<t tx="ekr.20090309064612.2"></t>
<t tx="ekr.20090309064612.3"></t>
<t tx="ekr.20090309064612.4"></t>
<t tx="ekr.20090316115500.1"></t>
<t tx="ekr.20090428081009.1">import PyQt4.QtCore as QtCore
import PyQt4.QtGui as QtGui
from PyQt4 import uic

table = (
    (['QtGui'],'object',QtGui),
    (['QtCore'],'object',QtCore),
)

c.k.autoCompleter.defineObjectDict(table)
print c.k.autoCompleter.objectDict.keys()

# print c.k.autoCompleter.objectDict.get('QtCore')</t>
<t tx="ekr.20090507082111.1904">print "---- inserting ----"
p2 = p.insertAsLastChild().copy()
p3 = p.insertAsLastChild().copy()

print [p2.gnx, p3.gnx]

children = p.children_iter()
print [p.gnx for p in children]

c.redraw()</t>
<t tx="ekr.20090507082535.1906">import email,getpass,imaplib,os

username = 'edreamleo@gmail.com'
passfile = os.path.expanduser('~/gmailpass.txt')
M = imaplib.IMAP4_SSL('imap.gmail.com',993)
try:
    f = open(passfile)
    password = f.read()
    M.login(username,password)
except IOError:
    g.es_print('file not found: %s' % (passfile),color='red')
    # M.login(username, getpass.getpass())

M.select()
typ, data = M.search(None, 'ALL')
for num in data[0].split():
    typ, data = M.fetch(num,'(RFC822)')
    s = data[0][1]
    m = email.message_from_string(s)
    # for z in m.keys(): print z
    payload = m.get_payload()
    p2 = p.insertAsLastChild()
    date,from_s,subject = m['date'],m['from'],m['subject']
    p2.setHeadString(subject)
    body = '@nocolor\n\nDate: %s\nFrom: %s\nSubject: %s\n\n%s' % (
        date,from_s,subject,payload)
    p2.setBodyString(body)
print 'done'
M.close()
M.logout()
c.redraw()</t>
<t tx="ekr.20090514073218.1923">import leo.core.leoTest as leoTest

if False:
    # Run tests locally.
    leoTest.doTests(c,all=True)
else:
    # Run tests externally.
    path = 'test.leo' # path is relative to leo\test directory
    leoTest.runUnitTestLeoFile(gui='nullGui',path=path,silent=False)
</t>
<t tx="ekr.20090514101216.1927"># 'self' is now defined in @test and @suite nodes.
self.assertNotEqual(1,2)</t>
<t tx="ekr.20090514103332.1929">@language python</t>
<t tx="ekr.20090521070342.1907">g.app.gui.runScrolledMessageDialog(c=c,msg=u'rst:'+p.b)</t>
<t tx="ekr.20090525090210.1940">La Peña</t>
<t tx="ekr.20090601093755.1802">bookmarks = []

@g.command('bookmark')
def bookmark(event):
    c = event.get('c')
    p = c.currentPosition()
    bookmarks.append(p.gnx)
    g.es('bookmarked') </t>
<t tx="ekr.20090617083033.1813">La Peña תּ
</t>
<t tx="ekr.20090617083033.1814"></t>
<t tx="ekr.20090618102458.1816">@first # -*- coding: utf-8 -*-

import PyQt4.QtCore as QtCore

s0 = unicode('La Peña','utf-8')
print s0
e = s0.encode('utf-8',"strict")
print e,repr(e)
s2 = QtCore.QString(s0)
print s2,repr(s2)
s3 = unicode(s2,'utf-8')
print s3
# s4 = QtCore.QString(e)
# print s4</t>
<t tx="ekr.20090619103402.1818"># Warning: this *replaces* the text.

bodyCtrl = c.frame.body.bodyCtrl
w = bodyCtrl.widget # A QTextEdit
s = bodyCtrl.getAllText()
w.setHtml(s)

try:
    # Lock out onTextChanged
    w.changingText = True
    w.setHtml(s)
finally:
    w.changingText = False</t>
<t tx="ekr.20090619103402.1821">bodyCtrl = c.frame.body.bodyCtrl
w = bodyCtrl.widget # A QTextEdit
s = bodyCtrl.getAllText()
w.setPlainText(s)</t>
<t tx="ekr.20090620063706.1826"></t>
<t tx="ekr.20090629105832.1790"></t>
<t tx="ekr.20090630141519.1793">#Example popup handler
from PyQt4 import QtCore

def test_acts(c,p,menu):

   # 'menu' is QMenu instance that was jsut created
   a1 = menu.addAction("Display " + p.h)
   a2 = menu.addAction("Es " + p.h)

   def a1_func():
       g.es("a1 from " + p.h)

   def a2_func():
       g.es("a2 from " + p.h)

   a1.connect(a1, QtCore.SIGNAL("triggered()"), a1_func)
   a2.connect(a2, QtCore.SIGNAL("triggered()"), a2_func)

def test_acts_handler2(c, p, menu):
   a = menu.addAction("Hello from handler 2")
   def f():
       g.es("Hello: " + p.h)

   a.connect(a, QtCore.SIGNAL("triggered()"), f)

def register():
   # the idea is just to append to the normal list g.tree_popup_handlers
   g.tree_popup_handlers.append(test_acts)
   g.tree_popup_handlers.append(test_acts_handler2)

register()</t>
<t tx="ekr.20090701125834.1765">fn = g.os_path_finalize_join(g.app.loadDir,'..','Icons','leo_inst.ico')
assert g.os_path_exists(fn)
c.editCommands.insertIconFromFile(path=fn)
c.bodyWantsFocusNow()</t>
<t tx="ekr.20090706044257.1784">@language unknown_language
#!/bin/sh
#@+leo-ver=4-thin
#@+node:EKR.20040519082027.33:@file-thin ../../install
#@@first

# This script installs Leo on *nix.
# Initial version by by Frank Merenda (fmerenda@yahoo.com)

# Variables...
LEO_PREFIX=${LEO_PREFIX:-/usr/local}
LEO_RUN_SCRIPT_OUTPUT="${LEO_PREFIX}/bin/leo"

# Bug fix: 2008/4/8: replace /lib/leo by /lib.
LEO_LIB_DIR="${LEO_PREFIX}/lib"

echo ""
echo "Prefix directory set to \"$LEO_PREFIX\""

# Make the directory structure
if [ ! -d $LEO_LIB_DIR ] ; then
    echo ""
    echo Making directory structure $LEO_LIB_DIR

    RESULTS=`mkdir -p -m755 $LEO_LIB_DIR 2&gt;&amp;1`
    if [ $? -ne 0 ]; then
        echo Failure making directory $LEO_LIB_DIR!
        exit 1;
    fi
fi

if [ ! -d $LEO_PREFIX/bin ] ; then
    echo ""
    echo Making directory structure $LEO_PREFIX/bin
    RESULTS=`mkdir -p -m755 $LEO_PREFIX/bin 2&gt;&amp;1`
    if [ $? -ne 0 ]; then
        echo Failure making directory $LEO_PREFIX/bin!
        exit 1;
    fi
fi

# Copy the files
cp -rp leo $LEO_LIB_DIR
chown -R root:root $LEO_LIB_DIR

echo "PYTHONPATH=${LEO_PREFIX}/lib python ${LEO_PREFIX}/lib/leo/core/runLeo.py \"\$@\"" &gt; $LEO_RUN_SCRIPT_OUTPUT

RESULTS=`chmod 755 $LEO_RUN_SCRIPT_OUTPUT`   

echo ""
echo "Leo installed successfully"
echo "Make sure ${LEO_PREFIX}/bin is in your path then"
echo "type 'leo filename.leo' to use it."   
echo ""

exit 0;
#@-node:EKR.20040519082027.33:@file-thin ../../install
#@-leo
</t>
<t tx="ekr.20090715064044.1782">@language python

b = p.b
p2 = g.findNodeAnywhere(c,'@sphinx')
if p2:
    c.selectPosition(p2)
else:
    c.insertHeadline(op_name='Create @sphinx node')
    p2 = c.p
    p2.h = '@sphinx'
    c.redraw()

w = c.frame.body.bodyCtrl.widget
w.setHtml(b)
</t>
<t tx="ekr.20090718072135.1786">print '=' * 40</t>
<t tx="ekr.20090728090618.2832"># An example of running this script:

import os

@others

types = (".py",".vim",".txt") #,".c",".html",".txt")

dir = r"C:\prog\pydiction-1.0"

importFiles(dir,types,recursive=True)
c.redraw()

g.es("done",color="blue")
</t>
<t tx="ekr.20090728090618.2833">def importFiles (dir,type=None,kind="@file",recursive=False):

    v = c.currentVnode()

    # Check the params.
    if kind != "@file" and kind != "@root":
        g.es("kind must be @file or @root: " + kind)
        return

    if not g.os_path_exists(dir):
        g.es("directory does not exist: " + dir)
        return

    root = createLastChildOf(v,"imported files")
    try:
        importDir (dir,type,kind,recursive,root)
        root.contract()
    except:
        g.es_exception()
    c.redraw()</t>
<t tx="ekr.20090728090618.2834">def importDir (dir,types,kind,recursive,root):

    g.es("dir: " + dir,color="blue")

    try:
        files = os.listdir(dir)
        files2 = [] ; dirs =[]
        for f in files:
            path = g.os_path_join(dir,f)
            if g.os_path_isfile(path):
                name, ext = g.os_path_splitext(f)
                if not types or ext in types:
                    files2.append(path)
            elif recursive:
                dirs.append(path)
        if len(files2) &gt; 0 or len(dirs) &gt; 0:
            child = createLastChildOf(root,dir)
            c.selectVnode(child)
        if len(files2) &gt; 0:
            c.importCommands.importFilesCommand(files2,kind)
        if len(dirs) &gt; 0:
            dirs.sort()
            for dir in dirs:
                importDir(dir,types,kind,recursive,child)
    except:
        g.es("exception in importFiles script")
        g.es_exception()
</t>
<t tx="ekr.20090728090618.2835">def createLastChildOf (v,headline):

    child = v.insertAsLastChild()
    child.initHeadString(headline)
    return child
</t>
<t tx="ekr.20090728090618.2837"></t>
<t tx="ekr.20090728090618.2838">@first #!/usr/bin/env python

# Last modified: July 15th, 2009

@language python
@tabwidth -4

&lt;&lt; docstring &gt;&gt;
&lt;&lt; declarations &gt;&gt;

# Path/filename of the vim dictionary file to write to:
PYDICTION_DICT = r'complete-dict'
# Path/filename of the vim dictionary backup file:
PYDICTION_DICT_BACKUP = r'complete-dict.last'

@others

if __name__ == '__main__':
    &lt;&lt; process command line &gt;&gt;
</t>
<t tx="ekr.20090728090618.2839">__author__ = "Ryan Kulla (rkulla AT gmail DOT com)"
__version__ = "1.0"
__copyright__ = "Copyright (c) 2003-2009 Ryan Kulla"

import os
import sys
import types
import shutil
</t>
<t tx="ekr.20090728090618.2840">def get_submodules(module_name, submodules):
    """Build a list of all the submodules of modules."""

    # Try to import a given module, so we can dir() it:
    try:
        imported_module = my_import(module_name)
    except ImportError, err:
        return submodules

    mod_attrs = dir(imported_module)

    for mod_attr in mod_attrs:
        if type(getattr(imported_module, mod_attr)) is types.ModuleType:
            submodules.append(module_name + '.' + mod_attr)

    return submodules


</t>
<t tx="ekr.20090728090618.2841">def write_dictionary(module_name):
    """Write to module attributes to the vim dictionary file."""

    try:
        imported_module = my_import(module_name)
    except ImportError, err:
        return

    mod_attrs = dir(imported_module)

    # Generate fully-qualified module names: 
    write_to.write('\n--- %(x)s module with "%(x)s." prefix ---\n' % 
                   {'x': module_name})
    for mod_attr in mod_attrs:
        if callable(getattr(imported_module, mod_attr)):
            # If an attribute is callable, show an opening parentheses:
            prefix_on = '%s.%s('
        else:
            prefix_on = '%s.%s'
        write_to.write(prefix_on % (module_name, mod_attr) + '\n')

    # Generate non-fully-qualified module names: 
    write_to.write('\n--- %(x)s module without "%(x)s." prefix ---\n' % 
                   {'x': module_name})
    for mod_attr in mod_attrs:
        if callable(getattr(imported_module, mod_attr)):
            prefix_off = '%s('
        else:
            prefix_off = '%s'
        write_to.write(prefix_off % mod_attr + '\n')
</t>
<t tx="ekr.20090728090618.2842">def my_import(name):
    """Make __import__ import "package.module" formatted names."""
    mod = __import__(name)
    components = name.split('.')
    for comp in components[1:]:
        mod = getattr(mod, comp)
    return mod


</t>
<t tx="ekr.20090728090618.2843">def remove_duplicates(seq, keep=()):
    """

    Remove duplicates from a sequence while perserving order.

    The optional tuple argument "keep" can be given to specificy 
    each string you don't want to be removed as a duplicate.
    """
    seq2 = []
    seen = set();
    for i in seq:
        if i in (keep):
            seq2.append(i)
            continue
        elif i not in seen:
            seq2.append(i)
        seen.add(i)
    return seq2


</t>
<t tx="ekr.20090728090618.2844">def get_yesno(msg="[Y/n]?"):
    """

    Returns True if user inputs 'n', 'Y', "yes", "Yes"...
    Returns False if user inputs 'n', 'N', "no", "No"...
    If they enter an invalid option it tells them so and asks again.
    Hitting Enter is equivalent to answering Yes.
    Takes an optional message to display, defaults to "[Y/n]?".

    """
    while True:
        answer = raw_input(msg)
        if answer == '':
            return True
        elif len(answer):
            answer = answer.lower()[0]
            if answer == 'y':
                return True
                break
            elif answer == 'n':
                return False
                break
            else:
                print "Invalid option. Please try again."
                continue


</t>
<t tx="ekr.20090728090618.2845">def main(write_to):
    """Generate a dictionary for Vim of python module attributes."""
    submodules = []

    for module_name in sys.argv[1:]:
        try:
            imported_module = my_import(module_name)
        except ImportError, err:
            print "Couldn't import: %s. %s" % (module_name, err)
            sys.argv.remove(module_name)

    cli_modules = sys.argv[1:]

    # Step through each command line argument:
    for module_name in cli_modules:
        print "Trying module: %s" % module_name
        submodules = get_submodules(module_name, submodules)

        # Step through the current module's submodules:
        for submodule_name in submodules:
            submodules = get_submodules(submodule_name, submodules)

    # Add the top-level modules to the list too:
    for module_name in cli_modules:
        submodules.append(module_name)

    submodules.sort()

    # Step through all of the modules and submodules to create the dict file:
    for submodule_name in submodules:
        write_dictionary(submodule_name)

    # Close and Reopen the file for reading and remove all duplicate lines:
    write_to.close()
    print "Removing duplicates..."
    f = open(PYDICTION_DICT, 'r')
    file_lines = f.readlines()
    file_lines = remove_duplicates(file_lines, ('\n'))
    f.close()

    # Delete the original file:
    os.unlink(PYDICTION_DICT)

    # Recreate the file, this time it won't have any duplicates lines:
    f = open(PYDICTION_DICT, 'w')
    for attr in file_lines:
        f.write(attr)
    f.close()
    print "Done."
</t>
<t tx="ekr.20090728090618.2846">@language vim
" ============================================================================
" python_pydiction.vim - Module and Keyword completion for Python
" ============================================================================
"
" Author: Ryan Kulla (rkulla AT gmail DOT com)
" Version: 1.0, for Vim 7
" URL: http://www.vim.org/scripts/script.php?script_id=850
" Last Modified: July 18th, 2009
" Installation: On Linux, put this file in ~/.vim/after/ftplugin/
"               On Windows, put this file in C:\vim\vimfiles\ftplugin\
"                        (assuming you installed vim in C:\vim\).
"               You may install the other files anywhere. 
"               In .vimrc, add the following:
"                   filetype plugin on
"                   let g:pydiction_location = 'path/to/complete-dict'
"               Optionally, you set the completion menu height like:
"                   let g:pydiction_menu_height = 20
"               The default menu height is 15
"               To do case-sensitive searches, set noignorecase (:set noic).
" License: BSD
" Copyright: Copyright (c) 2003-2009 Ryan Kulla
"            All rights reserved.
"
"            Redistribution and use in source and binary forms, with or without
"            modification, are permitted provided that the following conditions
"            are met:
"            1. Redistributions of source code must retain the above copyright
"               notice, this list of conditions and the following disclaimer.
"            2. Redistributions in binary form must reproduce the above
"               copyright notice, this list of conditions and the following
"               disclaimer in the documentation and/or other materials provided
"               with the distribution.
"            3. The name of the author may not be used to endorse or promote 
"               products derived from this software without specific prior 
"               written permission.
"
"            THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
"            OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
"            WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
"            ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
"            DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
"            DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
"            GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
"            INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
"            WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
"            NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
"            THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"
"

if v:version &lt; 700
    echoerr "Pydiction requires vim version 7 or greater."
    finish
endif


" Make the Tab key do python code completion:
inoremap &lt;silent&gt; &lt;buffer&gt; &lt;Tab&gt; 
         \&lt;C-R&gt;=&lt;SID&gt;SetVals()&lt;CR&gt;
         \&lt;C-R&gt;=&lt;SID&gt;TabComplete()&lt;CR&gt;
         \&lt;C-R&gt;=&lt;SID&gt;RestoreVals()&lt;CR&gt;


if !exists("*s:TabComplete")
    function! s:TabComplete()
        " Check if the char before the char under the cursor is an 
        " underscore, letter, number, dot or opening parentheses.
        " If it is, and if the popup menu is not visible, use 
        " I_CTRL-X_CTRL-K ('dictionary' only completion)--otherwise, 
        " use I_CTRL-N to scroll downward through the popup menu.
        " If the char is some other character, insert a normal Tab:
        if searchpos('[_a-zA-Z0-9.(]\%#', 'nb') != [0, 0] 
            if !pumvisible()
                return "\&lt;C-X&gt;\&lt;C-K&gt;"
            else
                return "\&lt;C-N&gt;"
            endif
        else
            return "\&lt;Tab&gt;"
        endif
    endfunction
endif


if !exists("*s:SetVals") 
    function! s:SetVals()
        " Save and change any config values we need.

        " Temporarily change isk to treat periods and opening 
        " parenthesis as part of a keyword -- so we can complete
        " python modules and functions:
        let s:pydiction_save_isk = &amp;iskeyword
        setlocal iskeyword +=.,(

        " Save any current dictionaries the user has set:
        let s:pydiction_save_dictions = &amp;dictionary
        " Temporarily use only pydiction's dictionary:
        let &amp;dictionary = g:pydiction_location

        " Save the ins-completion options the user has set:
        let s:pydiction_save_cot = &amp;completeopt
        " Have the completion menu show up for one or more matches:
        let &amp;completeopt = "menu,menuone"

        " Set the popup menu height:
        let s:pydiction_save_pumheight = &amp;pumheight
        if !exists('g:pydiction_menu_height')
            let g:pydiction_menu_height = 15
        endif
        let &amp;pumheight = g:pydiction_menu_height

        return ''
    endfunction
endif


if !exists("*s:RestoreVals")
    function! s:RestoreVals()
        " Restore the user's initial values.

        let &amp;dictionary = s:pydiction_save_dictions
        let &amp;completeopt = s:pydiction_save_cot
        let &amp;pumheight = s:pydiction_save_pumheight
        let &amp;iskeyword = s:pydiction_save_isk

        return ''
    endfunction
endif
</t>
<t tx="ekr.20090728090618.2847">@nocolor
Pydiction 1.0 by Ryan Kulla (http://www.vim.org/scripts/script.php?script_id=850)
-------------

Pydiction is a filetype plugin for python files to be able to tab-complete Python code, including Python's keywords, standard library and even third-party libraries.  

It consists of three main files: 
    python_pydiction.vim -- This is the ftplugin you put in your non-system ftplugin directory. (i.e., ~/.vim/after/ftplugin/, on Unix or C:\vim\vimfiles\ftplugin\, on Windows)
    complete-dict -- This is a vim dictionary file that consists of Python keywords and modules. This is what python_pydiction.vim looks at to know which things are completeable.
    pydiction.py -- This is a Python script that was used to generate complete-dict. You can optionally run this script to add more modules to complete-dict to be able to complete them.


Installing
----------
Unix/Linux: Put python_pydiction.vim in ~/.vim/after/ftplugin/   (if that directory doesn't exist, create it. Vim will know to look there automatically.)
Windows: Put python_pydiction.vim in C:\vim\vimfiles\ftplugin  (assuming you installed vim in C:\vim\).

You may install the other files (complete-dict and pydiction.py) anywhere you want. For this example, we'll assume you put them in "C:\vim\vimfiles\ftplugin\pydiction\" (Do not put any file but python_pydiction.vim in the ftplugin\ directory, only .vim files should go there. It's ok to make a subdirectory in it though, like I just did.)

In your .vimrc file, first add the following line to enable filetype plugins:

    filetype plugin on

then make sure you set "g:pydiction_location" to the full path of where yo uinstalled complete-dict. Ie:

    let g:pydiction_location = 'C:/vim/vimfiles/ftplugin/pydiction/complete-dict'

You can optionally set the height of the completion menu by setting "g:pydiction_menu_height" in your vimrc. The default height is 15:

    let g:pydiction_menu_height = 20

By default, pydiction ignores case while doing Tab-completion. If you want it to do case-sensitive searches, then set noignorecase (:set noic).


Pydiction versus other forms of completion 
------------------------------------------
Pydiction can complete Python Keywords, as well as Python module names, and their attributes and methods. It can also complete both the fully-qualified module names such as "module.method(", as well as non-fully qualified names such as "method(".

Pydiction only uses the Tab-key to complete, uses a special dictionary file to complete from, and only attempts to do it on python files. This has the advantages of only requiring one keystroke to do completion and of not polluting all of your completion menus that you may be using for other types of completion, such as Vim's regular omni-completion, or other completion scripts that you may be running.

Since pydiction uses a dictionary file of possible completion items, it can complete 3rd party modules much more accurately than other ways. You have full control over what it can and can't complete. If it's unable to complete anything you can either use pydiction.py to automatically add a new module's contents to the dictionary or you can even manually add them using a text editor. The dictionary is just a normal text file, which also makes it portable across all platforms.  For example, if you're a PyQT user, you can add all the PyQT related modules to the dictionary file (complete-dict) by using pydiction.py.

Also, because pydiction uses a dictionary file, You don't have to import a module before you can complete it. Nor do you even have to have the module installed. This frees you up to use pydiction as a way of looking up what a module attribute is called without having to install it first.

Pydiction is smart enough to know when you're completing callable method or not and if you are, it will automatically insert an opening parentheses for you.

The Tab key will work as normally expected for everything else. Pydiction will only try to use it to complete python code if you're editing a python file and you first type part of some python code, as specified in complete-dict.

Pydiction doesn't even require that python support be compiled into your version of vim!

python_pydiction.vim
--------------------
Pydiction will make it so your the Tab key on your keyboard is able to complete python code (as long as the functionality has been added to complete-dict).

Version 1.0 of pydiction uses a new file called python_pydiction.vim, which is an ftplugin that only activates when you're editing a python file (e.g., you're editing a file with a ".py" extension or you've manually typed ":set filetype=python").  Past versions of pydiction didn't use a plugin and instead just required you to change the value of "isk" in your .vimrc, which was not desirable. Version 1.0 and greater do not require you to manually change the value of isk, it changes it for you safely by only setting it while you're doing tab completion (of python code only), and automatically changes isk back to its original value whenever tab completion isn't being activated.

Pydiction works by using Vim's omni-completion functionality by temporarily remapping the Tab key to do the same thing as I_CTRL-X_CTRL_K (dictionary only completion). This means, whenever you're editing a Python file and you start typing the name of a python keyword or module, you can press the Tab key to complete it. For example, if you type "os.pa" and then press Tab, pydiction will pop up a completion menu in vim that will look like:
    os.pardir
    os.path
    os.pathconf(
    os.pathconf_names
    os.path.
    os.path.__all__
    os.path.__builtins__
    os.path.__doc__
    ...
Pressing Tab again while the menu is open will scroll down the menu so you can choose whatever item you want to go with, using the normal omni-completion keys:
    &lt;Ctrl-y&gt; will accept the current word.
    &lt;Space&gt; will accept the current word and insert a space.
    &lt;Ctrl-e&gt; will close the menu and not accept any word.

pydiction.py
------------
This is the Python script used to create the "complete-dict" vim dictionary file.  I have created and bundled a default complete-dict for your use. I created it in Ubuntu 9.04 Linux, so there won't be any win32 specific support in it. You're free to run pydiction.py to add as many more modules as you want.  The dictionary file will still work if you're using windows, but it won't complete win32 related modules unless you tell it to.      

Usage: In a command prompt, run: 
    $ python pydiction.py &lt;module&gt; ... [-v]
You have to have python 2.x installed.


Say you wanted to add a module called "mymodule" to complete-dict, do the following:
    $ python pydiction.py mymodule

You can input more than one module name on the command-line, just separate them by spaces:
    $ python pydiction.py mymodule1 mymodule2 mymodule3

The -v option will just write the results to stdout (standard output) instead of the complete-dict file.

If the backfup file "complete-dict.last" doesn't exist in the current directory, pydiction.py will create it for you. You should always keep a backup of your last working dictionary in case anything goes wrong, as it can get tedious having to recreate the file from scratch.

If complete-dict.last already exists, pydiction will ask you if you want to overwrite your old backup with the new backup.

If you try to add a module that already exists in complete-dict, pydiction will tell you it already exists, so don't worry about adding duplicates. In fact, you can't add duplicates, everytime pydiction.py runs it looks for and removes any duplicates in the file.

When pydiction adds new modules to complete-dict, it does so in two phases. First, it adds the fully-qualified name of the module. For example:
    module.attribute
    module.method(

then it adds the non-fully qualified name:
    attribute
    method(

this allows you to complete your python code the way that you imported it in the first place. E.g.:
    import module
or:
    from module import method

Say you want to complete "pygame.display.set_mode". If you imported Pygame using "import pygame", then you can Tab-complete using:
    pygame.di&lt;Tab&gt;
to expand to "pygame.display.". Then type:
    se&lt;Tab&gt; 
to expand to "pygame.display.set_mode("

Now say you imported using "from pygame import display". To expand to "display.set_mode(" just type:
    display.se&lt;Tab&gt;

And if you imported using "from pygame.display import set_mode" just type:
    se&lt;Tab&gt;

Keep in mind that if you don't use fully-qualified module names that you may get a lot of possible menu options popping up and so you may want to use more than just two letters to try to narrow it down. 


complete-dict
-------------
Again, this is the vim dictionary file that python_pydiction.vim reads from and pydiction.py writes to. Without this file, pydiction wouldn't know what python keywords and modules it can Tab-complete.

complete-dict is only an optional file in the sense that you can create your own if you don't want to use the default one that is bundled with pydiction.  The default complete-dict gives you a major headstart as far as what you can Tab-complete because I did my best to put all of the Python keywords, standard library and some popular third party modules in it for you. 

It currently contains:

    Python keywords:

        and       del       for       is        raise    
        assert    elif      from      lambda    return   
        break     else      global    not       try      
        class     except    if        or        while    
        continue  exec      import    pass      yield    
        def       finally   in        print
    
    Most of the standard library and builtins:  __builtin__, __future__, os, sys, time, re, sets, string, math, Tkinter, hashlib, urllib, etc... 

    It also contains some popular third-party libraries: pygame, wxPython, twisted, numarray and OpenGL.

If you open complete-dict in your text editor you'll see sections in it for each module, such as:
 
    --- os module with "os." prefix ---
    os.EX_CANTCREAT
    os.EX_CONFIG
    os.EX_DATAERR
    ...

    --- os module without "os." prefix ---
    EX_CANTCREAT
    EX_CONFIG
    EX_DATAERR
    ...

if certain attributes seem to be missing, it's probably because pydiction removed them because they were duplicates. This mainly happens with the non-fully qualified module sections. So first try searching the entire file for whatever string you assume is missing before you try adding it. For example, if you don't see "__doc__" under "--- sys module without "sys." prefix ---", it's because a previous module, such as "os" already has it.
    
If you try to recreate complete-dict from scratch, you'll need to manually add the Python keywords back to it, as those aren't generated with pydiction.py.

</t>
<t tx="ekr.20090728090618.2848">"""Process the command line."""

if sys.version_info[0:2] &lt; (2, 3):
    sys.exit("You need a Python 2.x version of at least Python 2.3")

if len(sys.argv) &lt;= 1:
    sys.exit("%s requires at least one argument. None given." % 
              sys.argv[0])

if '-v' in sys.argv:
    write_to = sys.stdout
    sys.argv.remove('-v')
elif os.path.exists(PYDICTION_DICT):
        # See if any of the given modules have already been pydiction'd:
        f = open(PYDICTION_DICT, 'r')
        file_lines = f.readlines()
        for module_name in sys.argv[1:]:
            for line in file_lines:
                if line.find('--- %s module with' % module_name) != -1:
                    print '"%s" already exists in %s. Skipping...' % \
                           (module_name, PYDICTION_DICT)
                    sys.argv.remove(module_name)
                    break
        f.close()

        if len(sys.argv) &lt; 2:
            # Check if there's still enough command-line arguments:
            sys.exit("Nothing new to do. Aborting.")

        if os.path.exists(PYDICTION_DICT_BACKUP):
            answer = get_yesno('Overwrite existing backup "%s" [Y/n]? ' % \
                                PYDICTION_DICT_BACKUP)
            if (answer):
                print "Backing up old dictionary to: %s" % \
                       PYDICTION_DICT_BACKUP
                try:
                    shutil.copyfile(PYDICTION_DICT, PYDICTION_DICT_BACKUP)
                except IOError, err:
                    print "Couldn't back up %s. %s" % (PYDICTION_DICT, err)
            else:
                print "Skipping backup..."

            print 'Appending to: "%s"' % PYDICTION_DICT
        else:
            print "Backing up current %s to %s" % \
                   (PYDICTION_DICT, PYDICTION_DICT_BACKUP)
            try:
                shutil.copyfile(PYDICTION_DICT, PYDICTION_DICT_BACKUP)
            except IOError, err:
                print "Couldn't back up %s. %s" % (PYDICTION_DICT, err)
else:
    print 'Creating file: "%s"' % PYDICTION_DICT

write_to = open(PYDICTION_DICT, 'a')

main(write_to)</t>
<t tx="ekr.20090728090618.2849">"""

pydiction.py 1.0 by Ryan Kulla (rkulla AT gmail DOT com).

Description: Creates a Vim dictionary of Python module attributes for Vim's 
             completion feature.  The created dictionary file is used by
             the Vim ftplugin "python_pydiction.vim".

Usage: pydiction.py &lt;module&gt; ... [-v]
Example: The following will append all the "time" and "math" modules'
         attributes to a file, in the current directory, called "pydiction"
         with and without the "time." and "math." prefix:
             $ python pydiction.py time math
         To print the output just to stdout, instead of appending to the file, 
         supply the -v option: 
             $ python pydiction.py -v time math

License: BSD.
"""
</t>
<t tx="ekr.20090815161520.1815">Reasonable values are iconclick2, icondclick2 and select2.

When using select2, you may want to use the detach-editor-toggle command.
</t>
<t tx="ekr.20090819085532.4265">w = c.frame.body.bodyCtrl.widget
w.setParent(None)
w.show()
</t>
<t tx="ekr.20091010091628.1836">@language python

'''Create a script button that will search for the icon-like
pattern in the selected node'''

from leo.plugins import mod_scripting as scripting

script = p.b + '\n'

sc = g.app.gui.ScriptingControllerClass(c)

shortcut = sc.getShortcut(p.h)
statusLine = 'pattern find button'
if shortcut: statusLine = '%s = %s' % (statusLine,shortcut)

patC = patController(c,script)
script = patC.setup() # Modify the script

sc.createAtButtonHelper(p,p.h,statusLine,shortcut,verbose=False)
</t>
<t tx="ekr.20091010091628.1837"># This will be done automatically.
import sys
import string
path = r'c:\python25\lib\site-customize\matching'
if path not in sys.path: sys.path.append(path)
from matching.patterns_b import *
from matching.textpatterns_b import *
from matching.MatchingInput import *

print '*' * 20
subject = MatchingInput (p.b) #"abcdefgh23;ijklmn")
while True:
    if subject ^ AnyOfP (string.letters) [4] &gt;&gt; "four letters":
       print "found four letters: \"" + subject ["four letters"] + "\""
    elif subject ^ AnyOfP (string.digits) [2:] &gt;&gt; "the digits" &amp; IsP (";"):
       print "found two or more digits followed by a semicolon: \"" + \
             subject ["the digits"] + "\""
    elif subject ^ AnyOfP (string.letters) [1:3] &gt;&gt; "1 2 3 letters":
       print "found less than four letters: \"" + \
             subject ["1 2 3 letters"] + "\""
    else: break
</t>
<t tx="ekr.20091010104145.1840">class patController:
    
    '''A class supporting icon-like find scripts using
    a very-slightly modified version of library at
    http://www.wilmott.ca/python/patternmatching.html'''
    
    @others</t>
<t tx="ekr.20091010104145.1842">def __init__ (c,script,forward=True):
    
    self.c = c
    self.v = c.p.v # The node containing the find-script to be applied.
    self.script = script # Will be modified in setup.</t>
<t tx="ekr.20091010104145.1843">def setup(self):
    
    pass</t>
<t tx="ekr.20091010104145.1844">def driver (self,forward=True):
    
    '''Search for the pattern in p and all following nodes
    until a match is found.'''
    
    if forward:
        while p:
            i = self.find(p)
            if i == -1:
                p.moveToThreadNext()
            else:
                self.select(p,i) ; break
    else:
        while p:
            i = self.findr(p)
            if i == -1:
                p.moveToThreadBack()
            else:
                self.select(p,i) ; break</t>
<t tx="ekr.20091010104145.1845">def find (self,p):
    
    '''Search for self.pattern in p.
    If p is the presently selected node, start at the cursor position.
    Otherwise, start at the start of the node.
    '''</t>
<t tx="ekr.20091010104145.1846"></t>
<t tx="ekr.20091011110344.1853">import string
import sys
path = r'c:\python25\lib\site-customize\matching'
if path not in sys.path: sys.path.append(path)
from matching.patterns_b import *
from matching.textpatterns_b import *
from matching.MatchingInput import *

def find(p):
    s = MatchingInput (p.b)
    while True:
        g.trace(s.Pos)
        if s ^ AnyOfP (string.letters) [4] &gt;&gt; 'pat':
            found = 'AnyOfP (letters) [4]'
        elif s ^ AnyOfP (string.digits) [2:] &gt;&gt; 'pat' &amp; IsP (';'):
            found = 'AnyOfP(digits)[2:]'
        elif s ^ AnyOfP (string.letters) [1:3] &gt;&gt; 'pat':
            found = 'AnyOfP (letters) [1:3]'
        else:
            found = False
        if found:
            pat = s['pat']
            print ('found: %s --&gt; %s' % (found,pat))
            yield s.Pos,pat
        else:
            raise StopIteration

print '*'*20
while p:
    print '----- searching',p.h
    for pos,pat in find(p):
        print pos,pat
    p.moveToThreadNext()
print('done')
</t>
<t tx="ekr.20091013153026.2721">@
This work has been mostly abandoned.

The idea was to use icon-like patterns, based on
http://www.wilmott.ca/python/patternmatching.html

There are several problems with this approach:
    
1. This library, while elegant, isn't necessarily so useful.
   Indeed, the typical "find script" in scripts.leo uses
   either the string method s.find (or s.findr) or similar
   g.match methods.
   
2. Unlike the python regex module, there do not appear to
   be the equivalent of search or findall methods.  This
   means that the search code must either
   a) step through the search string explicitly or 
   b) use more complicated search patterns that match anywhere.
   
3. Search scripts are typically more complex than other @button scripts.
   The search scripts in scripts.leo avoid this problem by doing all
   the replacements at once, without prompts.
   
State of the prototype code:
    
- @@button find script a kinda works, but it only finds patterns at
  the start of body text.  It does shows that generators are useful.
  
- @@button create find button doesn't do anything, and it's not clear
  that is can ever be extended to be useful.
  
  The idea of this button was that clicking on a node, say "pat a",
  containing an icon-like script, would create *another* @button node,
  say "@button pat-find pat a" that would (interactively?) find all
  nodes matched by the script in "pat a".  This isn't going to be easy.</t>
<t tx="ekr.20091217210235.1866" rst-import="7d710028580b000000756e6465726c696e657332710158000000007102580b000000756e6465726c696e657331710358010000003d7104752e">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20091229092257.1930" rst-import="7d710028580b000000756e6465726c696e65733271015801000000237102580b000000756e6465726c696e657331710358020000002b2a7104752e">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20091229101227.1902" rst-import="7d710028580b000000756e6465726c696e657332710158000000007102580b000000756e6465726c696e657331710358030000003d2d607104752e">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20091230064146.1911"># For xml-tags-test.xml
xml
test.a
test-b

# For layout.html
html
body
head
py:if
py:match
script
</t>
<t tx="ekr.20091230064146.1912">@language xml
@tabwidth -4
@others
</t>
<t tx="ekr.20091230081322.1919">import unicodedata as u
table = ('a','9','_',':','.',)
table2 = (
    (0xc0,0xd6),(0xd8,0xf6),(0xf8,0x2ff),(0x370,0x37d),(0x37f,0x1fff),
    (0x200c,0x200d),(0x2070,0x218f),(0x2c00,0x2fef),(0x3001,0xd7ff),
    (0xf900,0xfdcf),(0xfdf0,0xfffd),(0x10000,0xeffff),
    # Valid only after the start of a word.
    (0xb7,0xb7+1),(0x0300,0x036f),(0x203f,0x2040),
)
for ch in table:
    ch = g.u(ch)
    g.es(ch,u.category(ch))
for i,j in table2:
    g.es('*** range %xd %xd' % (i,j))
    for n in range(i,min(i+5,j)):
        if g.isPython3: ch = chr(n)
        else: ch = unichr(n)
        g.es(ch,u.category(ch))</t>
<t tx="ekr.20091230090645.1925">@language xml
@tabwidth -4
@others
</t>
<t tx="ekr.20091230121016.1931"></t>
<t tx="ekr.20091230160238.1922" rst-import="7d710028580b000000756e6465726c696e657332710158010000003d7102580b000000756e6465726c696e65733171036802752e">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20100103112623.1951"># This script insert a raw form-feed into the Leo outline.
# Leo's atFile write code should remove this.
s = p.b
p.b = s + '\n#\f'

# 
# </t>
<t tx="ekr.20100108090658.1958">&lt;&lt; imports&gt;&gt;
&lt;&lt; constants &gt;&gt;

@others

ec = leoEditCommands.editCommandsClass
table = (
    (ec,'next-line','Down'),
    (ec,'previous-line','Up'),
    (ec,'next-line-extend-selection','Shift+Down'),
    (ec,'previous-line-extend-selection','Shift+Up'),
)

for theClass,command,stroke in table:
    overrideCommand(command,theClass,stroke)

# testKeys()

# aa
</t>
<t tx="ekr.20100108090658.1959">@nocolor-node
@

For a list of official key symbols, see
http://doc.trolltech.com/4.4/qt.html#Key-enum

QKeyEvent::QKeyEvent (
    Type type, int key,
    Qt::KeyboardModifiers modifiers,
    const QString &amp; text = QString(),
    bool autorep = false, ushort count = 1 )

Modifiers
Qt::NoModifier	0x00000000	    No modifier key.
Qt::ShiftModifier	0x02000000	  A Shift key on the keyboard.
Qt::ControlModifier	0x04000000  A Ctrl key on the keyboard.
Qt::AltModifier	0x08000000	  An Alt key on the keyboard.
Qt::MetaModifier	0x10000000	  A Meta key on the keyboard.
</t>
<t tx="ekr.20100108102030.1962">import PyQt4.QtCore as QtCore
import PyQt4.QtGui as QtGui
Qt = QtCore.Qt

import leo.core.leoEditCommands as leoEditCommands</t>
<t tx="ekr.20100108102030.1963">noMod = Qt.NoModifier
shift = Qt.ShiftModifier
ctrl  = Qt.ControlModifier
alt   = Qt.AltModifier
meta  = Qt.MetaModifier</t>
<t tx="ekr.20100108102217.1966">def overrideCommand(command,theClass,stroke): # mods,key):

    qtKey,qtMods = setKeyAndMods(stroke)

    # Do the actual override
    f = c.commandsDict.get(command)
    if f:
        # Capture the lambda bindings.
        def qt_command_callback(self,event=None,qtKey=qtKey,qtMods=qtMods):
            g.trace(event,command,stroke)
            text=''
            qtKey = QtGui.QKeyEvent(QtCore.QEvent.KeyPress,qtKey,qtMods,text)
            w = c.frame.body.bodyCtrl.widget ### should be event.widget
            QtCore.QCoreApplication.sendEvent(w,qtKey)

        callback = qt_command_callback
        # g.trace(id(f),command,stroke)
        adjustBindings(command,callback,f,stroke,theClass)

    else:
        g.trace('no such command:',command)



</t>
<t tx="ekr.20100108102217.1967">def setKeyAndMods(stroke):

    d = {'Up':Qt.Key_Up,'Down':Qt.Key_Down,}

    mods = stroke.split('+')
    key = mods[-1]
    mods = mods[:-1]

    qtMods = Qt.NoModifier
    if mods:
        for mod in mods:
            mod = mod.lower()
            if mod.startswith('s'):
                qtMods |= Qt.ShiftModifier
            elif mod.startswith('c'):
                qtMods |= Qt.ControlModifier
            elif mod.startswith('a'):
                qtMods |= Qt.AltModifier
            elif mod.startswith('m'):
                qtMods |= Qt.MetaModifier
            else:
                tags.append('Unknown modifier: %s' % mod)

    qtKey = d.get(key,key)
    return qtKey,qtMods
</t>
<t tx="ekr.20100108102217.1968">def testKeys():

    table = (
        (ord('a'),noMod,'a'),
        (Qt.Key_Up,shift,''),
    )

    # Put new characters at end.
    w = c.frame.body.bodyCtrl
    w.setInsertPoint('end')

    for key,mod,text in table:
        key = QtGui.QKeyEvent(QtCore.QEvent.KeyPress,key,mod,text)
        for w in (
            # c.frame.top, # a DynamicWindow. Nothing happens.
            c.frame.body.bodyCtrl.widget,
            # c.frame.log.logCtrl.widget, # works
        ):
            QtCore.QCoreApplication.sendEvent(w,key)
</t>
<t tx="ekr.20100108111728.2076"># This will become something like k.replaceCommand

def adjustBindings (command,callback,f,stroke,theClass):

    # f is the *old* function, to be replaced by callback.
    trace = True and not g.unitTesting
    k = c.k
    g.funcToMethod(callback,theClass,name=f.__name__)
    if trace: g.trace('=====',command,id(f),f.__name__)


    stroke = c.k.shortcutFromSetting(stroke)
    bindStroke = c.k.tkbindingFromStroke(stroke)

    # Replace all entries for command in all bindings dicts...
    c.commandsDict [command] = None ### callback

    # k.masterGuiBindingsDict:
    # Keys are strokes; value is a list of widgets for which stroke is bound.
    k.masterGuiBindingsDict[bindStroke] = []

    # k.bindingsDict:
    # Keys are shortcuts;
    # values are *lists* of g.bunch(func,name,warningGiven)
    d = k.bindingsDict
    aList = d.get(stroke,[])
    if aList:
        result = []
        for b in aList:
            # g.trace(id(b.func),b.func.__name__)
            if b.func == f:
                if trace: g.trace('*** removing k.bindingsDict',stroke)
                ### b.func = callback
            else:
                result.append(b)
        d[stroke] = result

    # k.masterBindingsDict:
    # Keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts:  keys are strokes,
    # values are g.Bunch(commandName,func,pane,stroke)
    d = k.masterBindingsDict
    for key in list(k.masterBindingsDict.keys()):
        d2 = k.masterBindingsDict.get(key,{})
        b = d2.get(stroke,None)
        if b:
            # g.trace(b.pane,id(b.func),b.func.__name__)
            if b.func == f:
                if trace: g.trace('*** removing k.masterBindingsDict',stroke)
                b.func = callback
                d2[stroke] = None ### b
</t>
<t tx="ekr.20100108111728.2077">@nocolor-node

@
c.commandsDict:
    Keys are emacs command names; values are functions f.

k.inverseCommandsDict:
    Keys are f.__name__; values are emacs command names.

k.bindingsDict:
    Keys are shortcuts; values are *lists* of g.bunch(func,name,warningGiven)

k.masterBindingsDict:
    Keys are scope names: 'all','text',etc. or mode names.
    Values are dicts:  keys are strokes, values are g.Bunch(commandName,func,pane,stroke)

k.masterGuiBindingsDict:
    Keys are strokes; value is a list of widgets for which stroke is bound.

k.settingsNameDict:
    Keys are lowercase settings; values are 'real' Tk key specifiers.
    Important: this table has no inverse.

not an ivar (computed by k.computeInverseBindingDict):

inverseBindingDict
    Keys are emacs command names; values are *lists* of shortcuts.
</t>
<t tx="ekr.20100109081612.1984">import PyQt4.QtGui as QtGui

w = c.frame.body.bodyCtrl.widget
w.moveCursor(QtGui.QTextCursor.Up)
c.bodyWantsFocusNow()</t>
<t tx="ekr.20100109081746.1988">import PyQt4.QtGui as QtGui

w = c.frame.body.bodyCtrl.widget
w.moveCursor(QtGui.QTextCursor.Down)
c.bodyWantsFocusNow()</t>
<t tx="ekr.20100109081746.1990">import PyQt4.QtGui as QtGui

w = c.frame.body.bodyCtrl.widget
w.moveCursor(QtGui.QTextCursor.Up,QtGui.QTextCursor.KeepAnchor)
c.bodyWantsFocusNow()</t>
<t tx="ekr.20100109081746.1992">import PyQt4.QtGui as QtGui

w = c.frame.body.bodyCtrl.widget
w.moveCursor(QtGui.QTextCursor.Down,QtGui.QTextCursor.KeepAnchor)
c.bodyWantsFocusNow()</t>
<t tx="ekr.20100109081746.1993">import PyQt4.QtGui as QtGui

w = c.frame.body.bodyCtrl.widget
cursor = w.textCursor()
cursor.movePosition(QtGui.QTextCursor.Up,QtGui.QTextCursor.KeepAnchor,15)
w.setTextCursor(cursor)
c.bodyWantsFocusNow()</t>
<t tx="ekr.20100109084336.1996"></t>
<t tx="ekr.20100110151049.2004" rst-import="7d710028580b000000756e6465726c696e657332710158000000007102580b000000756e6465726c696e657331710358010000003d7104752e">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20100110172917.1916"></t>
<t tx="ekr.20100110172917.1917">section 2

</t>
<t tx="ekr.20100110172917.1918">.. rst3: filename: html\intro.html

</t>
<t tx="ekr.20100110172917.1919">Leo is a power tool for people who want to organize, study and work with data,
especially complex data like computer programs, books, web sites and data bases.
Superficially, Leo may look like other outlining programs, code folding editors
or class browsers, but it most certainly is not.

People say Leo is a revolutionary tool, and that Leo is fun to use, even
additive. There is a unique "Leo way" of managing data; the term **Leonine**
describes how people treat data in "the world according to Leo". Leo definitely
takes a bit of work to understand. Leo's users speak of an "Aha" moment, when
they see how these pieces fit together: outline structure is significant
everywhere.

Leo is freely available in source or binary form for all major platforms. You
may download Leo from http://sourceforge.net/projects/leo/files/Leo/ Leo is Open
Software and may be freely distributed.

`Leo's home page`_ contains additional documentation and links to other
resources. For another introduction to Leo, open the file quickstart.leo in the
leo/doc folder.

This tutorial introduces the reader to the basic concepts and features of Leo.
It helps to have Leo running for hands-on experience, but all examples here are
self-contained, so the tutorial can be read off-line as well.
See `Leo's Installation Guide`_. for detailed installation instructions. If you
have problems installing Leo, please ask for help on `Leo's help forum`_. 

This tutorial does not attempt to be comprehensive and cover every single
feature of Leo, or even every commonly used feature. Instead, it introduces many
of Leo's most noteworthy features, and will give you a good idea of Leo's flavor
and style. After reading it, you will be able to use Leo in basic ways to create
external files, organize data and run simple scripts. You will then be ready to
learn more about Leo's many advanced features in `Leo's Users Guide`_.

.. The :ref:`glossary` is also worth going through.

.. contents::

.. Links used in this document...

.. ----- External references.

.. _`LaTeX`:                    http://www.latex-project.org/
.. _`Leo's help forum`:         http://groups.google.com/group/leo-editor-users
.. _`Leo's home page`:          http://webpages.charter.net/edreamleo/front.html
.. _`Literate Programming`:     http://www.literateprogramming.com/
.. _`MySQL`:                    http://www.mysql.com/
.. _`noweb`:                    http://www.eecs.harvard.edu/~nr/noweb/
.. _`Python`:                   http://www.python.org/
.. _`reStructuredText`:         http://docutils.sourceforge.net/rst.html
.. _`XML`:                      http://en.wikipedia.org/wiki/XML

.. ----- Relative links....

.. _`external file`:        `external files`_
.. _glossary:               glossary.html
.. _`Good style and bad`:   `style`_
.. _outline:                `Leo's main window`_
.. _outlines:               `Leo's main window`_
.. _plugin:                 `extending`_
.. _plugins:                `extending`_
.. .. _quickstart:             `Quick start for programmers`_
.. _scripts:                `scripting`_
.. _settings:               `config`_
.. _`Configuring Leo`:      `config`_

.. ----- References to other chapters.

.. _`What people are saying about Leo`:             testimonials.html
.. _`@@auto trees`:                                  directives.html#auto-trees
.. _command:                                        commands.html
.. _commands:                                       commands.html
.. _directive:                                      directives.html
.. _directives:                                     directives.html
.. _`Leo directives`:                               directives.html
.. _`editing commands`:                             commands.html#the-edit-menu
.. _front:                                          front.html
.. _`install Leo`:                                  install.html
.. _`launch Leo`:                                   install.html#running-leo
.. _`Leo's Users Guide`:                            leo_TOC.html
.. _`Leo's Installation Guide`:                     install.html
.. _`Chapter 4: Writing Programs in Leo`:           directives.html
.. _`Chapter 5: Using Leo's Commands`:              commands.html
.. _`Chapter 6: Leo and Literate Programming`:      design.html
.. _`Chapter 7: Scripting Leo with Python`:         scripting.html
.. _`Chapter 8: Customizing Leo`:                   customizing.html

.. ----- References to the glossary

.. _`@@auto`:                    glossary.html#auto
.. _`@file`:                    glossary.html#file
.. _`@nosent`:                  glossary.html#nosent
.. _`@others`:                  glossary.html#others
.. _`@thin`:                    glossary.html#thin
.. _`@thin trees`:              glossary.html#thin-trees
.. _`body text`:                glossary.html#body-text
.. _ancestor:                   glossary.html#ancestor
.. _children:                   glossary.html#child
.. _clone:                      glossary.html#clone
.. _cloned:                     glossary.html#cloned
.. _cloning:                    glossary.html#clone
.. _clones:                     glossary.html#clones
.. _`code part`:                glossary.html#code-part
.. _`doc part`:                 glossary.html#doc-part
.. _descendant:                 glossary.html#descendant
.. _descendants:                glossary.html#descendants
.. _`doc part`:                 glossary.html#doc-part
.. _grandchildren:              glossary.html#grandchildren
.. _headline:                   glossary.html#headline
.. _headlines:                  glossary.html#headlines
.. _`organizer node`:           glossary.html#organizer-node
.. _`organizer nodes`:          glossary.html#organizer-nodes
.. _`outline order`:            glossary.html#outline-order
.. _node:                       glossary.html#node
.. _nodes:                      glossary.html#nodes
.. _reference:                  glossary.html#reference
.. _references:                 glossary.html#references
.. _root:                       glossary.html#root
.. _`root node`:   	            glossary.html#root
.. _section:                    glossary.html#section
.. _sections:                   glossary.html#section
.. _`section definition`:       glossary.html#section-definition
.. _`section definitions`:      glossary.html#section-definitions
.. _`section definition nodes`: glossary.html#section-definition-nodes
.. _`section name`:             glossary.html#section-name
.. _`section names`:            glossary.html#section-names
.. _`section reference`:        glossary.html#section-reference
.. _`section references`:       glossary.html#section-references
.. _siblings:                   glossary.html#siblings

.. For reasons unknown, this image must appear in the _images folder on the web site.
.. |leoMainWindow| image:: screen-shots/leo-qt-main-window.JPG

</t>
<t tx="ekr.20100110172917.1920">Let's start looking at Leo in detail. We'll start with what you see when you
first open Leo, Leo's main window. Leo's main window, shown below, represents an
entire project. As you can see, the main window contains three panes: the
**outline pane** at the top left, the **log pane** at the top right, and the
**body pane** at the bottom. The window also contains an **icon area** at the
very top, a **status area** and a **mini-buffer** at the very bottom.

|leoMainWindow|

The outline pane
    The outline pane shows your project as an outline. The outline
    contains all your project's data. An outline consists of **nodes**. The
    **icon box** is a small icon directly to the left of the headline text. If a
    node contains children, a smaller icon appears to the left of the icon box.
    This icon contains a '+' or '-' symbol. Clicking this **expansion box**
    expands or contracts the node.
    
Nodes
    Nodes have two parts, a **headline** and **body text**. The outline pane
    shows headlines. Selecting a headline selects the entire node; the node's
    body text appears in the body pane. Leo uses standard terminology to
    describe the relationships of nodes in an outline. We speak of **parent**
    nodes, **child** nodes, **ancestor** nodes and **descendant** nodes.

Body pane
    The body pane contains the body text of the node selected in the
    outline pane.

Log pane
    The log pane contains informational messages from Leo or your scripts.

Icon area Depending on what plugins are enabled, the icon area may contain
    buttons and other widgets that extend what Leo can do. The scripting plugin
    makes it easy to add buttons to the icon area.

Status area
    The status area shows the line and column containing the body text's cursor,
    and the **UNL** (Uniform Node Location), the path from the top of the outline
    to the selected node.  This path will change as you change outline nodes.

Mini-buffer
    You can type command and search strings in the minibuffer. It works much
    like the Emacs mini-buffer. To enter a command, type &lt;Alt-x&gt; followed by the
    command name and then &lt;return&gt;. To type a search string, type &lt;ctrl-f&gt;
    followed by the search string and then &lt;return&gt;. For full details, see
    `Chapter 5: Using Leo's Commands`_.

</t>
<t tx="ekr.20100110172917.1921">You can use Leo as fairly typical outliner. Play around with some of the
commands from the Outline menu:

- Click the expansion box of nodes to show and hide their children.

- The Insert Node command (Ctrl+I) inserts a new headline into the outline.

- The Cut Node command (Ctrl+Shift+X) deletes a headline and all its children,
  and copies the structure to clipboard - ready to paste with Paste Node command
  (Ctrl+Shift+V). Use the Copy Node command (Ctrl+Shift+C) to copy node to
  clipboard without deleting it from outline. Copy-paste command family works
  across different Leo documents.

- The Move Up (Ctrl+U), Move Down (Ctrl+D), Move Left (Ctrl+L) and Move Right
  (Ctrl+R) commands move the currently selected node, along with all its
  descendants.

- The Promote (Ctrl+}) command makes all the children of a headline siblings of
  the headline. The Demote (Ctrl+{) command makes all following siblings of a
  headline children of the headline.

- Move around the tree and expand/collapse nodes by pressing Alt + arrow keys.
  This also moves the focus to tree, so, after pressing Alt + arrow, you can
  move around by using arrow keys alone. Return the focus to the body control by
  pressing Enter.

- To edit the headline, use press Ctrl+H. This works regardless of whether body
  or headline has focus.

- We'll discuss the Clone Node command in the next section.

You enter body text for any node by selecting the node's headline in the outline
pane and then typing in the body pane. Leo has a full range of `editing
commands`_ that apply to the body pane.

</t>
<t tx="ekr.20100110172917.1922">.. _`external files`:

Leo stores outline data on your file system in **.leo files**. The format of
these files is `XML`_. You don't have to store all your data in .leo files: Leo
allows you to store parts of your outline data **external files**, that is,
other files on your file system.

**@file nodes** create external files. \@file nodes have headlines starting with
\@file followed by a file name. Some examples::

    @file leoNodes.py
    @file ../../notes.text
    
The file name can be an absolute path or a relative path to the file that starts
at Leo's **load directory**, the directory containing the .leo file.

Leo reads and writes external files automatically when you open or save your Leo
outline:

- When you open an outline (.leo file) Leo reads all the external files created
  by the \@file nodes in the outline. If you have changed an external file
  outside of Leo, Leo will update the corresponding \@file tree to reflect those
  changes when Leo next opens the outline.

- When you save your outline, Leo writes all **dirty** \@file nodes. An \@file
  is dirty if the node or any of its descendant nodes has changed.
  **Important**: When Leo writes an external file, Leo writes all the essential
  information in the \@file tree to the external file, *not* to the .leo file.
  The only nodes that gets written to the .leo file are nodes that are not
  contained in any \@file tree.

</t>
<t tx="ekr.20100110172917.1923">We come now to one of Leo's most important and unusual features. When Leo writes
an external file, it does so in a flexible manner, directed by **outline-based
markup**. This markup tells Leo exactly how to create the external file from an
\@file node.

The **obvious** way to write an external file would be to write the \@file node
itself followed by all the descendant nodes in **outline order** (the order in
which nodes appear in the outline). But Leo does *not* write external files
exactly this way.

Yes, Leo does indeed start by writing the \@file node itself. But Leo writes the
\@file node's descendants only only when it sees one of three kinds of Leo
markup: section references, the \@others directive and the \@all directive.
We'll discuss these three kinds of markup in the next section.

Section references and the \@others and \@all directives tell Leo to write the
**expansion** of one or more descendant nodes to the external file. Programmers
will recognize this process as akin to macro expansion. The following sections
will explain this process in detail.

</t>
<t tx="ekr.20100110172917.1924">A **section reference** is a line of body text of the form::

    &lt;&lt; a section name &gt;&gt;
    
Here, "a section name" can be any descriptive text not containing "&gt;&gt;". When Leo
encounters a section reference, Leo searches all the descendants of the node
containing the reference looking for a node whose headline matches the section
reference. That is, Leo looks for a descendant node whose headline starts with::

     &lt;&lt; a section name &gt;&gt;
     
We call such nodes **named nodes**. Leo doesn't require an exact match. Leo
ignores whitespace and the case of letters when comparing headlines to section
reference. Also, Leo ignores anything that may follow the section name in a
named node. For example, the following headline will match the section reference
above::

    &lt;&lt; A Section Name &gt;&gt; (to do)

If Leo does find a match, Leo *replaces* the section reference ("&lt;&lt; a section
name&gt;&gt;") by the *expansion* of the body text of the matched node. That is, Leo
replaces the section reference by the body text of the matched node, but Leo
**expands all markup** in the matched node *before* making the replacement. The
entire expansion of the matched node replaces the original section reference.
Programmers will recognize this process as recursive macro expansion.

We have just discussed what happens if Leo does find a descendant named node
that matches the section reference. If no such match is found the section
reference is said to be **undefined** and Leo does not write any data to the
external file. This is *not* a serious error: Leo will will save the erroneous
\@&lt;file&gt; tree in the .leo file instead of the external file. No information is
lost. By the way, Leo's syntax coloring will indicate undefined section
reference by underlining the section name.

**Important**: the indentation of section references matters. When expanding a
section reference, Leo indents every line of the expansion by the leading
whitespace that occurs before the section reference. Note also that you can't
write something after a section reference and expect it to end up on the same
line after expansion--Leo always writes a newline after the expansion.

</t>
<t tx="ekr.20100110172917.1925">The **@others directive** is the second (and most common) way of including
descendant nodes in an external files. When Leo encounters the \@others
directive it replaces the \@others directive by the *expansion* of all
**unnamed** descendant nodes. As with section references, Leo replaces all
markup in the descendant nodes, and the entire expansion replaces the \@others
directive.

In short, section references write *named* nodes; \@others directives write all
*unnamed* nodes. By the way, no node may contain more than one \@others
directive because there would be no way to "apportion" descendant nodes to more
than one \@others directive. However, nodes may contain as many section
references as you like.

As with section references, the indentation of the \@others directive matters.
This allows Leo to handle Python source code properly. For exmple, the following
is a common way of representing a Python class::

    class myClass:
        '''a docstring'''
        @others
        
When Leo writes this node to an external file, Leo will write the first two
lines to the external file, with the indentation in effect for the node. Leo
will then write all descendant nodes to the external files, with *additional*
indentation equal to the leading whitespace appearing before the \@others
directive.

</t>
<t tx="ekr.20100110172917.1926">The \@all directive is the third, simplest (and least common) way of including
descendant nodes. This directive causes Leo to write all descendant nodes in
outline order, regardless of whether they are named or not. Furthermore, the
\@all directive does not expand any markup in descendant nodes. This results in
Leo writing the external file in the "obvious" way. That is, Leo writes all
descendant nodes in outline order.

Use the all directive if your external file contains unrelated nodes. For
example, I use an external file to store programming notes. These notes
typically contain snippets of programming source code, but there is no real
relationships between the snippets--the file is simply a grab bag of
information. The \@all directive is designed for this situation.

</t>
<t tx="ekr.20100110172917.1927">.. _style:

Newcomers to Leo frequently ask when to use the \@others directive and when to
use sections. It is good style to use section references only when the order of
text within a external file matters. For example, Python programmers put
docstrings and imports at the start of files. So the body text of
\@file nodes typically look something like this::

    &lt;&lt; docstring &gt;&gt;
    @language python
    @tabwidth -4
    &lt;&lt; imports &gt;&gt;
    @others

This ensures that the docstring is first in the file, followed by imports,
followed by everything else. Note that the order in which functions are defined
in a file, or methods defined within a class, typically does *not* matter. Thus,
it is good style to define classes like this::

  class myClass:
        &lt;&lt; class attributes &gt;&gt;
        @others

It would be bad style to define a class like this::

  class myClass:
        &lt;&lt; class attributes &gt;&gt;
        &lt;&lt; method 1 &gt;&gt;
        &lt;&lt; method 2 &gt;&gt;
        ...

Not only does this over-specify the order in which methods are defined, but it
requires lots of extra typing. Not only must you add a line for each method, but
headlines must contain section names such as &lt;&lt; method 1 &gt;&gt;, &lt;&lt;method 2&gt;&gt;, etc.
When using \@others it is good style simply to put the name of each method in the
headline.

</t>
<t tx="ekr.20100110172917.1928">A few more words about style:

- It is good style to put each class, function or method in its own node. This
  makes it easy to see the shape of your code.

- It is good style to use organizer nodes to group related functions or methods.
  An organizer node has no content except maybe for comments. Like this::

    + myClass
        + birth and death
            + __init__
            etc.
        + getters
            etc.
        + setters
            etc.
        + misc methods
            etc.

  (In this notation, '+' denotes a headline.) This organization is far superior
  to using hideous comments like::

    ###########
    # Getters #
    ###########

- It is bad style to use \@others in organizer nodes. There is no need to do so.

- It is bad style to use \@others when order does matter. The reason is that it
  is very easy to move nodes in a tree by mistake, say by alphabetizing nodes.
  One wants to make the meaning of a external file immune from such movements.

One last word about style. The world won't end if you happen to use bad style by
mistake: you just might cause a bit more work for yourself than was strictly
necessary. Feel free to invent your own style of using Leo. Still, it would be
wise to "know the rules before you break them."

</t>
<t tx="ekr.20100110172917.1929">A **clone** is a node that appears in more than one place in a Leo outline.
Clones are marked with a small red arrow in the icon box. All clones of a node
are actually *the same node*, so any change to one clone affects all clones. For
example, inserting, moving or deleting any child of a clone will change all
other clones on the screen.

Please take a few moments to experiment with clones. Create a node whose
headline is A. Clone node A using the Clone Node command in Leo's Outline menu.
Type some text into the body of either clone of A. The same text appears in the
bodies of all other clones of A. Now insert a node, say B, as a child of any of
the A nodes. All the A nodes now have a B child. See what happens if you clone
B. See what happens if you insert, delete or move nodes that are children of A.
Verify that when you delete the penultimate clone, the last clone becomes a
regular node again.

Clones are much more than a cute feature. Clones allow multiple views of data to
exist **within a single outline**. With Leo, there is no such thing as a single,
"correct" view of data. You can have as many views of data as you like.

To create a new view of the data in your outline, just do the following:

1. Create an *ordinary* node, that will represent the view. We call these nodes
   **view nodes** merely to indicate they represent a view.
   
2. Clone all the nodes from the outline that you want the view to contain. Move
   these clones so they become children of the view node.
   
3. (Optional) You can add regular nodes as children of the view node too.
   
For example, when I fix a bug in Leo, I create an ordinary node to represent the
bug. This **bug node** is my view of all the data in Leo's source code that
relates to the bug. As I discover code related to the bug, I clone their nodes
and move them under the bug node. I'll also add ordinary nodes as children of
the bug node. These nodes contain the original bug report, descriptions of how I
fixed the bug, test data, or any other notes I might want to keep.

Once I have created the bug node, I concentrate *only* on that node and its
children. I can examine the bug node and its children without having to jump
around the outline. Everything I need is in one place. When I get around to
actually fixing the bug I can do so by changing the clones. Again, I do not have
to jump around the outline. It doesn't matter how big or complex the entire
outline is: I am only dealing with the bug node and its children. This extremely
narrow focus makes it *much* easier to fix bugs.

By the way, I never have to remember to save external files. When I change any
clone, Leo marks all instances of that clone throughout the entire outline as
dirty (changed). When I save the Leo outline, Leo automatically writes all the
external files that contain dirty nodes.

Views have an unlimited number of uses. Use them whenever you want to focus your
attention on some smaller set of nodes. For example, I often create view nodes
when studying other people's code. The view node helps me concentrate on just
the part of the code that interests me at the moment.

</t>
<t tx="ekr.20100110172917.1930">Leo's **directives** control such things as syntax coloring, line wrapping
within the body pane and the width of tabs. Leo directives may appear in
headlines or body text. Leo directives start with '@' in the leftmost column,
followed by the name of the directive. Here are some of Leo's directives::

    @language python
    @tabwidth -4
    @wrap
    @nowrap
    @color
    @nocolor
    @killcolor
    
Directives apply until overridden in a subtree. All of these directives apply to
the node they are contained in, and also to the entire tree of descendant nodes,
unless **over-ridden** by a similar directive in a descendant node. For example,
the directive::

    @language python
    
tells Leo to syntax color the node and all descendant nodes as Python code.
However, some descendant node mignt contain::

    @language rest
    
which tells Leo to color that node and all of *its* decendants as
reStructureText. This principle applies to almost all of Leo's directives: the
directive is in effect throughout a tree, unless overridden in some subtree.

- **\@color**, **\@nocolor** and **\@killcolor** control syntax coloring.

  You can mix \@nocolor and \@color directives in a single node, but these
  directives apply to descendant nodes only if they are **unambiguous**, that
  is, only if the ancestor node contains exactly one \@color or \@nocolor
  directive.

- **\@encoding** Sets the Unicode encoding used in external files.

- **\@first** directives orces lines to appear before the first sentinel of a
  external file.

    This directive may only appear in \@&lt;file&gt; nodes. A common use of \@first
    directives is to add shebang lines::
    
        @first #! /usr/bin/env python
        
    or Python encoding specifications::
    
        @first # -*- coding: utf-8 -*-

- **\@language** Sets the language used for syntax coloring **and** sets the
  comment delimiters used in sentinel lines and in doc parts. Some examples::

    @language python
    @language c
    @language rest # restructured text
    @language plain # text, that is, no syntax coloring.

- **\@last** Forces lines to appear after the last sentinel of a external file.

- **\@lineending** Specifies the line ending to be used in external files.

- **\@pagewidth** Sets the page width used to break doc parts into lines.

- **\@path** Sets the path to be prepended to filenames in descendant \@file
  nodes.

- **\@tabwidth** sets the width of tabs.

  Negative tab widths cause Leo to convert tabs to spaces and are highly
  recommended for Python programming.

- **\@wrap** and **\@nowrap** enable or disable line wrapping the Leo's body pane.

Leo treats lines starting with \@ as a normal code line unless the \@ starts a
Leo directive. In particular, Leo will output Python decorators correctly,
provided the name of the decorator does not conflict with a Leo directive.

</t>
<t tx="ekr.20100110172917.1931">.. _scripting:

Leo is fully scriptable using the Python language. Leo can execute any body text
as a Python script. To run the entire body text as a script, simply choose the
node and execute the Execute Script command (Ctrl+B). If text is selected, the
Execute Script command will run just the selected text as the script.

The Execute Script command **preprocesses** the script before executing it, in
exactly the same way that Leo writes external files. Leo expands section
references and processes \@others directives before executing the script. This
allows you to use all of Leo's outlining capabilities to organize your scripts.

Your Python scripts can easily access data in an outline. Leo's execute-script
(Ctrl-B) command predefines three variables, c, g and p, that scripts can use to
easily access any part of any Leo outline, and Leo's own source code. For
example, the following script will print all the headlines in an outline::

    for p in c.all_positions():
        print ' '*p.level(),p.h

The example above is only the beginning of what scripts can do. See `Chapter 7:
Scripting Leo with Python`_ for a complete discussion of scripting Leo.

.. _extending:

**Plugins** are Python modules that change how Leo works. Leo's user have
contributed dozens of plugins that have extended Leo's capabilities in many new
directions. The file leoPlugins.leo contains all plugins that are included in
Leo distributions.

.. _config:

Plugins and other parts of Leo can get options from **@settings** trees.
\@settings trees allow plugins to get options without any further support from
Leo's core code. For a full discussion of \@settings trees, see `Chapter 8:
Customizing Leo`_.

</t>
<t tx="ekr.20100110172917.1932">Using Leo quickly becomes second nature:

- You can use Leo like any ordinary outliner, as a filing cabinet, but Leo's
  clones makes this filing cabinet much more flexible and useful than usual.

- You create external files using \@file trees. Within \@file trees, you use
  section references and the \@others directive to tell Leo how to write nodes
  to the external file. Directives such as \@tabwidth and \@language provide other
  information to Leo. Leo's \@file trees allow you to organize your scripts
  and programs with Leo's outline structure.
  
- You can execute Python scripts from any node in a Leo outline. Leo scripts
  have full, easy, access to all the information in the outline. Using scripts
  and plugins, you can easily add new features to Leo.

</t>
<t tx="ekr.20100110172917.1933">LeoPyRef.leo (in the core subdirectory of the leo folder) contains almost all of
Leo's source code. It provides hundreds of examples of everything discussed
here. This file will repay close study. For full details on all aspects of Leo
see LeoDocs.leo or `Leo's Users Guide`_.

</t>
<t tx="ekr.20100110172917.1934">:Author: Richard Jones
:Version: $Revision: 5801 $
:Copyright: This document has been placed in the public domain.

.. contents::


The text below contains links that look like "(quickref__)".  These
are relative links that point to the `Quick reStructuredText`_ user
reference.  If these links don't work, please refer to the `master
quick reference`_ document.

__
.. _Quick reStructuredText: quickref.html
.. _master quick reference:
   http://docutils.sourceforge.net/docs/user/rst/quickref.html

.. Note:: This document is an informal introduction to
   reStructuredText.  The `What Next?`_ section below has links to
   further resources, including a formal reference.

</t>
<t tx="ekr.20100110172917.1935">From the outset, let me say that "Structured Text" is probably a bit
of a misnomer.  It's more like "Relaxed Text" that uses certain
consistent patterns.  These patterns are interpreted by a HTML
converter to produce "Very Structured Text" that can be used by a web
browser.

The most basic pattern recognised is a **paragraph** (quickref__).
That's a chunk of text that is separated by blank lines (one is
enough).  Paragraphs must have the same indentation -- that is, line
up at their left edge.  Paragraphs that start indented will result in
indented quote paragraphs. For example::

  This is a paragraph.  It's quite
  short.

     This paragraph will result in an indented block of
     text, typically used for quoting other text.

  This is another one.

Results in:

  This is a paragraph.  It's quite
  short.

     This paragraph will result in an indented block of
     text, typically used for quoting other text.

  This is another one.

__ quickref.html#paragraphs

</t>
<t tx="ekr.20100110172917.1936">(quickref__)

__ quickref.html#inline-markup

Inside paragraphs and other bodies of text, you may additionally mark
text for *italics* with "``*italics*``" or **bold** with
"``**bold**``".  This is called "inline markup".

If you want something to appear as a fixed-space literal, use
"````double back-quotes````".  Note that no further fiddling is done
inside the double back-quotes -- so asterisks "``*``" etc. are left
alone.

If you find that you want to use one of the "special" characters in
text, it will generally be OK -- reStructuredText is pretty smart.
For example, this lone asterisk * is handled just fine, as is the
asterisk in this equation: 5*6=30.  If you actually
want text \*surrounded by asterisks* to **not** be italicised, then
you need to indicate that the asterisk is not special.  You do this by
placing a backslash just before it, like so "``\*``" (quickref__), or
by enclosing it in double back-quotes (inline literals), like this::

    ``*``

__ quickref.html#escaping

.. Tip:: Think of inline markup as a form of (parentheses) and use it
   the same way: immediately before and after the text being marked
   up.  Inline markup by itself (surrounded by whitespace) or in the
   middle of a word won't be recognized.  See the `markup spec`__ for
   full details.

__ ../../ref/rst/restructuredtext.html#inline-markup

</t>
<t tx="ekr.20100110172917.1937">Lists of items come in three main flavours: **enumerated**,
**bulleted** and **definitions**.  In all list cases, you may have as
many paragraphs, sublists, etc. as you want, as long as the left-hand
side of the paragraph or whatever aligns with the first line of text
in the list item.

Lists must always start a new paragraph -- that is, they must appear
after a blank line.

**enumerated** lists (numbers, letters or roman numerals; quickref__)
  __ quickref.html#enumerated-lists

  Start a line off with a number or letter followed by a period ".",
  right bracket ")" or surrounded by brackets "( )" -- whatever you're
  comfortable with.  All of the following forms are recognised::

    1. numbers

    A. upper-case letters
       and it goes over many lines

       with two paragraphs and all!

    a. lower-case letters

       3. with a sub-list starting at a different number
       4. make sure the numbers are in the correct sequence though!

    I. upper-case roman numerals

    i. lower-case roman numerals

    (1) numbers again

    1) and again

  Results in (note: the different enumerated list styles are not
  always supported by every web browser, so you may not get the full
  effect here):

  1. numbers

  A. upper-case letters
     and it goes over many lines

     with two paragraphs and all!

  a. lower-case letters

     3. with a sub-list starting at a different number
     4. make sure the numbers are in the correct sequence though!

  I. upper-case roman numerals

  i. lower-case roman numerals

  (1) numbers again

  1) and again

**bulleted** lists (quickref__)
  __ quickref.html#bullet-lists

  Just like enumerated lists, start the line off with a bullet point
  character - either "-", "+" or "*"::

    * a bullet point using "*"

      - a sub-list using "-"

        + yet another sub-list

      - another item

  Results in:

  * a bullet point using "*"

    - a sub-list using "-"

      + yet another sub-list

    - another item

**definition** lists (quickref__)
  __ quickref.html#definition-lists

  Unlike the other two, the definition lists consist of a term, and
  the definition of that term.  The format of a definition list is::

    what
      Definition lists associate a term with a definition.

    *how*
      The term is a one-line phrase, and the definition is one or more
      paragraphs or body elements, indented relative to the term.
      Blank lines are not allowed between term and definition.

  Results in:

  what
    Definition lists associate a term with a definition.

  *how*
    The term is a one-line phrase, and the definition is one or more
    paragraphs or body elements, indented relative to the term.
    Blank lines are not allowed between term and definition.

</t>
<t tx="ekr.20100110172917.1938">(quickref__)

__ quickref.html#literal-blocks

To just include a chunk of preformatted, never-to-be-fiddled-with
text, finish the prior paragraph with "``::``".  The preformatted
block is finished when the text falls back to the same indentation
level as a paragraph prior to the preformatted block.  For example::

  An example::

      Whitespace, newlines, blank lines, and all kinds of markup
        (like *this* or \this) is preserved by literal blocks.
    Lookie here, I've dropped an indentation level
    (but not far enough)

  no more example

Results in:

  An example::

      Whitespace, newlines, blank lines, and all kinds of markup
        (like *this* or \this) is preserved by literal blocks.
    Lookie here, I've dropped an indentation level
    (but not far enough)

  no more example

Note that if a paragraph consists only of "``::``", then it's removed
from the output::

  ::

      This is preformatted text, and the
      last "::" paragraph is removed

Results in:

::

    This is preformatted text, and the
    last "::" paragraph is removed

</t>
<t tx="ekr.20100110172917.1939">(quickref__)

__ quickref.html#section-structure

To break longer text up into sections, you use **section headers**.
These are a single line of text (one or more words) with adornment: an
underline alone, or an underline and an overline together, in dashes
"``-----``", equals "``======``", tildes "``~~~~~~``" or any of the
non-alphanumeric characters ``= - ` : ' " ~ ^ _ * + # &lt; &gt;`` that you
feel comfortable with.  An underline-only adornment is distinct from
an overline-and-underline adornment using the same character.  The
underline/overline must be at least as long as the title text.  Be
consistent, since all sections marked with the same adornment style
are deemed to be at the same level::

  Chapter 1 Title
  ===============

  Section 1.1 Title
  -----------------

  Subsection 1.1.1 Title
  ~~~~~~~~~~~~~~~~~~~~~~

  Section 1.2 Title
  -----------------

  Chapter 2 Title
  ===============

This results in the following structure, illustrated by simplified
pseudo-XML::

    &lt;section&gt;
        &lt;title&gt;
            Chapter 1 Title
        &lt;section&gt;
            &lt;title&gt;
                Section 1.1 Title
            &lt;section&gt;
                &lt;title&gt;
                    Subsection 1.1.1 Title
        &lt;section&gt;
            &lt;title&gt;
                Section 1.2 Title
    &lt;section&gt;
        &lt;title&gt;
            Chapter 2 Title

(Pseudo-XML uses indentation for nesting and has no end-tags.  It's
not possible to show actual processed output, as in the other
examples, because sections cannot exist inside block quotes.  For a
concrete example, compare the section structure of this document's
source text and processed output.)

Note that section headers are available as link targets, just using
their name.  To link to the Lists_ heading, I write "``Lists_``".  If
the heading has a space in it like `text styles`_, we need to quote
the heading "```text styles`_``".

</t>
<t tx="ekr.20100110172917.1940">The title of the whole document is distinct from section titles and
may be formatted somewhat differently (e.g. the HTML writer by default
shows it as a centered heading).

To indicate the document title in reStructuredText, use a unique adornment
style at the beginning of the document.  To indicate the document subtitle,
use another unique adornment style immediately after the document title.  For
example::

    ================
     Document Title
    ================
    ----------
     Subtitle
    ----------

    Section Title
    =============

    ...

Note that "Document Title" and "Section Title" above both use equals
signs, but are distict and unrelated styles.  The text of
overline-and-underlined titles (but not underlined-only) may be inset
for aesthetics.

</t>
<t tx="ekr.20100110172917.1941">(quickref__)

__ quickref.html#directives

To include an image in your document, you use the the ``image`` directive__.
For example::

  .. image:: images/biohazard.png

results in:

.. image:: images/biohazard.png

The ``images/biohazard.png`` part indicates the filename of the image
you wish to appear in the document. There's no restriction placed on
the image (format, size etc).  If the image is to appear in HTML and
you wish to supply additional information, you may::

  .. image:: images/biohazard.png
     :height: 100
     :width: 200
     :scale: 50
     :alt: alternate text

See the full `image directive documentation`__ for more info.

__ ../../ref/rst/directives.html
__ ../../ref/rst/directives.html#images

</t>
<t tx="ekr.20100110172917.1942">This primer introduces the most common features of reStructuredText,
but there are a lot more to explore.  The `Quick reStructuredText`_
user reference is a good place to go next.  For complete details, the
`reStructuredText Markup Specification`_ is the place to go [#]_.

Users who have questions or need assistance with Docutils or
reStructuredText should post a message to the Docutils-users_ mailing
list.

.. [#] If that relative link doesn't work, try the master document:
   http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html.

.. _reStructuredText Markup Specification:
   ../../ref/rst/restructuredtext.html
.. _Docutils-users: ../mailing-lists.html#docutils-users
.. _Docutils project web site: http://docutils.sourceforge.net/

</t>
<t tx="ekr.20100110172917.1943">&lt;xml&gt;
&lt;/xml&gt;
</t>
<t tx="ekr.20100110172917.1944">&lt;test.a&gt;
a
&lt;/test.a&gt;
</t>
<t tx="ekr.20100110172917.1945">&lt;test-b&gt;
b
&lt;/test-b&gt;
</t>
<t tx="ekr.20100110172917.1946">&lt;!DOCTYPE xml&gt;
</t>
<t tx="ekr.20100110172917.1947">&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:py="http://genshi.edgewall.org/" py:strip=""&gt;
  &lt;?python v=value_of; import time?&gt;
  @others
&lt;/html&gt;
</t>
<t tx="ekr.20100110172917.1948">&lt;py:match path="head"&gt;
  @others
&lt;/py:match&gt;
</t>
<t tx="ekr.20100110172917.1949">&lt;head py:attrs="select('@*')"&gt;
  @others
  &lt;script py:for="i in v('jscripts',[])" 
    type='text/javascript' src="${url('/js/'+i)}"/&gt;
  &lt;link rel="stylesheet" href="${url('/css/main.css')}" type="text/css"/&gt;
  &lt;link py:for="i in v('css',[])" 
    rel="stylesheet" type='text/javascript' href="${url('/css/'+i)}"/&gt;
  ${select('node()')}
&lt;/head&gt;
</t>
<t tx="ekr.20100110172917.1950">&lt;py:if test="v('jscripts',[])"&gt;
  &lt;script type='text/javascript' src="${url('/js/jquery.js')}"/&gt;
  &lt;!--! CSS for JQuery UI --&gt;
  &lt;link rel="stylesheet" href="${url('/js/themes/flora/flora.all.css')}" type="text/css"/&gt;
  &lt;script type='text/javascript' src="${url('/js/ui.calendar.js')}"/&gt;
&lt;/py:if&gt;
</t>
<t tx="ekr.20100110172917.1951">&lt;py:match path="body"&gt;
  @others
&lt;/py:match&gt;
</t>
<t tx="ekr.20100110172917.1952">&lt;body py:attrs="select('@*')"&gt;
  &lt;div class="sections"&gt;${select('node()')}&lt;/div&gt;
  &lt;div class="site-footer"&gt;Generated ${time.ctime()}&lt;/div&gt;
&lt;/body&gt;
</t>
<t tx="ekr.20100110172917.1953">&lt;py:match path="xh1"&gt;
  &lt;div class="h1"&gt;
    &lt;h1 py:attrs="select('@*')" &gt;${select('node()')}&lt;/h1&gt;
  &lt;/div&gt;
&lt;/py:match&gt;
</t>
<t tx="ekr.20100110172917.1954">&lt;py:match path="NOTp"&gt;
  &lt;div py:for="i in range(2)" class="slide" style="border: solid red 3px;"&gt;
    &lt;p py:attrs="select('@*')"&gt;${i}. ${select('node()')}&lt;/p&gt;
  &lt;/div&gt;
&lt;/py:match&gt;
</t>
<t tx="ekr.20100110172917.1955">:Info: See &lt;http://docutils.sf.net/rst.html&gt; for introductory docs.
:Author: David Goodger &lt;goodger@python.org&gt;
:Date: $Date: 2006-01-23 02:13:55 +0100 (Mon, 23 Jän 2006) $
:Revision: $Revision: 4321 $
:Description: This is a "docinfo block", or bibliographic field list

</t>
<t tx="ekr.20100110172917.1956">Section titles are underlined or overlined &amp; underlined.

</t>
<t tx="ekr.20100110172917.1957">Grid table:

+--------------------------------+-----------------------------------+
| Paragraphs are flush-left,     | Literal block, preceded by "::":: |
| separated by blank lines.      |                                   |
|                                |     Indented                      |
|     Block quotes are indented. |                                   |
+--------------------------------+ or::                              |
| &gt;&gt;&gt; print 'Doctest block'      |                                   |
| Doctest block                  | &gt; Quoted                          |
+--------------------------------+-----------------------------------+
| | Line blocks preserve line breaks &amp; indents. [new in 0.3.6]       |
| |     Useful for addresses, verse, and adornment-free lists; long  |
|       lines can be wrapped with continuation lines.                |
+--------------------------------------------------------------------+

Simple tables:

================  ============================================================
List Type         Examples
================  ============================================================
Bullet list       * items begin with "-", "+", or "*"
Enumerated list   1. items use any variation of "1.", "A)", and "(i)"
                  #. also auto-enumerated
Definition list   Term is flush-left : optional classifier
                      Definition is indented, no blank line between
Field list        :field name: field body
Option list       -o  at least 2 spaces between option &amp; description
================  ============================================================

================  ============================================================
Explicit Markup   Examples (visible in the `text source &lt;cheatsheet.txt&gt;`_)
================  ============================================================
Footnote          .. [1] Manually numbered or [#] auto-numbered
                     (even [#labelled]) or [*] auto-symbol
Citation          .. [CIT2002] A citation.
Hyperlink Target  .. _reStructuredText: http://docutils.sf.net/rst.html
                  .. _indirect target: reStructuredText_
                  .. _internal target:
Anonymous Target  __ http://docutils.sf.net/docs/ref/rst/restructuredtext.html
Directive ("::")  .. image:: images/biohazard.png
Substitution Def  .. |substitution| replace:: like an inline directive
Comment           .. is anything else
Empty Comment     (".." on a line by itself, with blank lines before &amp; after,
                  used to separate indentation contexts)
================  ============================================================

</t>
<t tx="ekr.20100110172917.1958">*emphasis*; **strong emphasis**; `interpreted text`; `interpreted text
with role`:emphasis:; ``inline literal text``; standalone hyperlink,
http://docutils.sourceforge.net; named reference, reStructuredText_;
`anonymous reference`__; footnote reference, [1]_; citation reference,
[CIT2002]_; |substitution|; _`inline internal target`.

</t>
<t tx="ekr.20100110172917.1959">See &lt;http://docutils.sf.net/docs/ref/rst/directives.html&gt; for full info.

================  ============================================================
Directive Name    Description (Docutils version added to, in [brackets])
================  ============================================================
attention         Specific admonition; also "caution", "danger",
                  "error", "hint", "important", "note", "tip", "warning"
admonition        Generic titled admonition: ``.. admonition:: By The Way``
image             ``.. image:: picture.png``; many options possible
figure            Like "image", but with optional caption and legend
topic             ``.. topic:: Title``; like a mini section
sidebar           ``.. sidebar:: Title``; like a mini parallel document
parsed-literal    A literal block with parsed inline markup
rubric            ``.. rubric:: Informal Heading``
epigraph          Block quote with class="epigraph"
highlights        Block quote with class="highlights"
pull-quote        Block quote with class="pull-quote"
compound          Compound paragraphs [0.3.6]
container         Generic block-level container element [0.3.10]
table             Create a titled table [0.3.1]
list-table        Create a table from a uniform two-level bullet list [0.3.8]
csv-table         Create a table from CSV data (requires Python 2.3+) [0.3.4]
contents          Generate a table of contents
sectnum           Automatically number sections, subsections, etc.
header, footer    Create document decorations [0.3.8]
target-notes      Create an explicit footnote for each external target
meta              HTML-specific metadata
include           Read an external reST file as if it were inline
raw               Non-reST data passed untouched to the Writer
replace           Replacement text for substitution definitions
unicode           Unicode character code conversion for substitution defs
date              Generates today's date; for substitution defs
class             Set a "class" attribute on the next element
role              Create a custom interpreted text role [0.3.2]
default-role      Set the default interpreted text role [0.3.10]
title             Set the metadata document title [0.3.10]
================  ============================================================

</t>
<t tx="ekr.20100110172917.1960">See &lt;http://docutils.sf.net/docs/ref/rst/roles.html&gt; for full info.

================  ============================================================
Role Name         Description
================  ============================================================
emphasis          Equivalent to *emphasis*
literal           Equivalent to ``literal`` but processes backslash escapes
PEP               Reference to a numbered Python Enhancement Proposal
RFC               Reference to a numbered Internet Request For Comments
raw               For non-reST data; cannot be used directly (see docs) [0.3.6]
strong            Equivalent to **strong**
sub               Subscript
sup               Superscript
title             Title reference (book, etc.); standard default role
================  ============================================================

</t>
<t tx="ekr.20100110172917.1961">Section 1: Ę

</t>
<t tx="ekr.20100118122048.2003"># For new colorizer

python_keyword1_font_family = DejaVu Sans Mono
python_keyword1_font_size = 12
python_keyword1_font_slant = roman
    # roman, italic
python_keyword1_font_weight = bold
    # normal, bold</t>
<t tx="ekr.20100118133026.2008">python_keyword3_font_family = DejaVu Sans Mono
python_keyword3_font_size = 12
python_keyword3_font_slant = italic
    # roman, italic
python_keyword3_font_weight = bold
    # normal, bold
</t>
<t tx="ekr.20100118141712.2011">@nocolor-node

Use 40 for @tabwidth 4
Use 80 for @tabwidth 8</t>
<t tx="ekr.20100118190256.2012"></t>
<t tx="ekr.20100118190256.2013"></t>
<t tx="ekr.20100118190256.2014"></t>
<t tx="ekr.20100118190256.2015"></t>
<t tx="ekr.20100118190256.2016"></t>
<t tx="ekr.20100119095312.2041"># bold

rest_keyword2_font_size = 14
rest_keyword2_font_family = Bitstream Charter
rest_keyword2_font_slant = roman
rest_keyword2_font_weight = bold</t>
<t tx="ekr.20100119095726.2043">@language rest

This is **bold** and this is *italic*.</t>
<t tx="ekr.20100119100926.2046"># Italics
rest_keyword4_font_size = 14
rest_keyword4_font_family = Bitstream Charter
rest_keyword4_font_slant = italic
    # roman, italic
rest_keyword4_font_weight = normal
    # normal, bold</t>
<t tx="ekr.20100122125233.2053">root = p.copy()
while p.hasChildren():
   p.firstChild().doDelete(newNode = None)

print(g.app.gui.guiName())

try:
   p1 = p.insertAsLastChild()
   p1.expand()
   body = 'foo'
   # p1.setBodyString(body)
   p1.b = body
   c.selectPosition(p1)
   c.copyOutline()
   c.pasteOutline()
finally:
   c.redraw_now()
</t>
<t tx="ekr.20100127111116.2059">@nowrap

aaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbb cccccccccccccccccccccc ddddddddddddddddddddddd eeeeeeeeeeeeeeeeeee fffffffffffffffffffffff
aaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbb cccccccccccccccccccccc ddddddddddddddddddddddd eeeeeeeeeeeeeeeeeee fffffffffffffffffffffff
aaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbb cccccccccccccccccccccc ddddddddddddddddddddddd eeeeeeeeeeeeeeeeeee fffffffffffffffffffffff</t>
<t tx="ekr.20100127111425.2062"># Searching on Windows 7 is absolutely wretched.
import glob
import os

@others

pattern = "idxTitle = output.find('&lt;title&gt;&lt;/title&gt;')"
ignoreCase = True
paths = (
    # r'C:\Python31\Lib\site-packages\docutils',
    # r'C:\Python26\Lib\site-packages\pylint-0.19.0-py2.6.egg\pylint',
    # r'C:\Python31\Lib\site-packages\docutils',
    r'C:\Python26\Lib\site-packages\docutils-0.6-py2.6.egg\docutils',
)

os.system('CLS')
print('\n%s pattern: %s' % ('-'*20,pattern))
for path in paths:
    searchDir(path,pattern)
</t>
<t tx="ekr.20100127122240.2063">@nocolor

Select the following string: वादक.
Typing and undo now work.</t>
<t tx="ekr.20100130095415.2023"># @first # -*- coding: mbcs -*-
# @first # -*- coding: utf-8 -*-

path = 'c:\prog\Leo Stuff\chinese脖folder'

for encoding in ('mbcs','utf-8'):
    valid = g.isValidEncoding(encoding)
    theDir = g.os_path_finalize(path,encoding='utf-8')
    g.es(encoding,valid,theDir)
    print(encoding,valid,g.os_path_exists(theDir))</t>
<t tx="ekr.20100202115249.2023">@first # -*- coding: utf-8 -*-
@language python
import sys
from PyQt4 import Qt

isPython3 = sys.version_info &gt;= (3,0,0)
if isPython3:
    def gu(s): return s
else:
    def gu(s): return unicode(s)

s = gu('''Select the following string: वादक.
This string consists of 4 characters, followed by a period.
Hit do, then undo.
Notice that the selection range now includes the period.
''')

n1,n2 = None,None # The selection range.
app = Qt.QApplication(sys.argv) 
f = Qt.QFrame()
f.setLayout(Qt.QVBoxLayout())
w = Qt.QTextEdit()
w.setPlainText(s)

b1 = Qt.QPushButton("Do")
b2 = Qt.QPushButton("Undo")

f.layout().addWidget(w)
f.layout().addWidget(b1)
f.layout().addWidget(b2)
f.show()

def showselect():
    tc = w.textCursor()
    s = w.toPlainText()
    su = gu(s)
    n1,n2 = tc.selectionStart(),tc.selectionEnd()
    print(n1,n2,'length',abs(n2-n1),len(s),len(su),gu(s[n1:n2]).encode('utf-8'))

def do():
    # w.textCursor().removeSelectedText() # works
    global n1,n2,w
    tc = w.textCursor()
    n1,n2 = tc.selectionStart(),tc.selectionEnd()
    tc = w.textCursor()
    tc.removeSelectedText()
    w.setTextCursor(tc) # Has no effect.

def undo():
    global n1,n2,s,w
    w.setPlainText(s)
    tc = w.textCursor()
    if n1 &gt; n2: n1,n2 = n2,n1
    tc.setPosition(n1)
    tc.setPosition(n2,tc.KeepAnchor)
    # tc.movePosition(tc.Right,tc.KeepAnchor,n2-n1)
    w.setTextCursor(tc)

app.connect(w, Qt.SIGNAL("selectionChanged()"), showselect)
app.connect(b1, Qt.SIGNAL("clicked()"), do)
app.connect(b2, Qt.SIGNAL("clicked()"), undo)
app.exec_()
</t>
<t tx="ekr.20100203174233.2032"># My problem: the node that is being created by c.pasteOutline() has an
# empty body. If after running the test I type 'paste-node' in the
# minibuffer, a new node appears, it has 'foo' in the body.

root = p.copy()
while p.hasChildren():
   p.firstChild().doDelete(newNode = None)
try:
   p1 = p.insertAsLastChild()
   body = 'foo'
   p1.setBodyString(body)
   c.selectPosition(p1)
   c.copyOutline()
   c.pasteOutline()
finally:
   c.redraw_now()</t>
<t tx="ekr.20100203233053.2033">@language python

#@path aPathaab

# This is a test2</t>
<t tx="ekr.20100204062222.2035">This crashed Leo in path.py during startup</t>
<t tx="ekr.20100204082851.2038">@language python
@tabwidth -4
@others
Pmw.forwardmethods(ComboBox, Pmw.ScrolledListBox, '_list')
Pmw.forwardmethods(ComboBox, Pmw.EntryField, '_entryfield')
</t>
<t tx="ekr.20100204085410.2060">@language python
@tabwidth -4
@others
Pmw.forwardmethods(ComboBox, Pmw.ScrolledListBox, '_list')
Pmw.forwardmethods(ComboBox, Pmw.EntryField, '_entryfield')
</t>
<t tx="ekr.20100204085631.2041"># This file illustrates some off-by-n problems in goto-global-line.

# Actually, there may be a bigger problem with the @auto file write logic.
# Adding /deleteing blank lines here doesn't change the file!!!



# Based on iwidgets2.2.0/combobox.itk code.

import os
import string
import types
import Tkinter
import Pmw

</t>
<t tx="ekr.20100204085631.2042">class ComboBox(Pmw.MegaWidget):
    @others
    self._selectCmd()


</t>
<t tx="ekr.20100204085631.2043">def __init__(self, parent = None, **kw):

</t>
<t tx="ekr.20100204085631.2044"># Define the megawidget options.
INITOPT = Pmw.INITOPT
optiondefs = (
    ('autoclear',          0,          INITOPT),
    ('buttonaspect',       1.0,        INITOPT),
    ('dropdown',           1,          INITOPT),
    ('fliparrow',          0,          INITOPT),
    ('history',            1,          INITOPT),
    ('labelmargin',        0,          INITOPT),
    ('labelpos',           None,       INITOPT),
    ('listheight',         200,        INITOPT),
    ('selectioncommand',   None,       None),
    ('sticky',            'ew',        INITOPT),
    ('unique',             1,          INITOPT),
)
self.defineoptions(kw, optiondefs)

# Initialise the base class (after defining the options).
Pmw.MegaWidget.__init__(self, parent)

# Create the components.
interior = self.interior()

self._entryfield = self.createcomponent('entryfield',
    (('entry', 'entryfield_entry'),), None,
    Pmw.EntryField, (interior,))
self._entryfield.grid(column=2, row=2, sticky=self['sticky'])
interior.grid_columnconfigure(2, weight = 1)
self._entryWidget = self._entryfield.component('entry')

if self['dropdown']:
    self._isPosted = 0
        interior.grid_rowconfigure(2, weight = 1)

    # Create the arrow button.
    self._arrowBtn = self.createcomponent('arrowbutton',
        (), None,
        Tkinter.Canvas, (interior,), borderwidth = 2,
        relief = 'raised',
        width = 16, height = 16)
        if 'n' in self['sticky']:
            sticky = 'n'
        else:
            sticky = ''
        if 's' in self['sticky']:
            sticky = sticky + 's'
    self._arrowBtn.grid(column=3, row=2, sticky = sticky)
    self._arrowRelief = self._arrowBtn.cget('relief')

    # Create the label.
    self.createlabel(interior, childCols=2)

    # Create the dropdown window.
    self._popup = self.createcomponent('popup',
        (), None,
        Tkinter.Toplevel, (interior,))
    self._popup.withdraw()
    self._popup.overrideredirect(1)

    # Create the scrolled listbox inside the dropdown window.
    self._list = self.createcomponent('scrolledlist',
        (('listbox', 'scrolledlist_listbox'),), None,
        Pmw.ScrolledListBox, (self._popup,),
        hull_borderwidth = 2,
        hull_relief = 'raised',
        hull_height = self['listheight'],
        usehullsize = 1,
        listbox_exportselection = 0)
    self._list.pack(expand=1, fill='both')
    self.__listbox = self._list.component('listbox')

    # Bind events to the arrow button.
    self._arrowBtn.bind('&lt;1&gt;', self._postList)
    self._arrowBtn.bind('&lt;Configure&gt;', self._drawArrow)
    self._arrowBtn.bind('&lt;3&gt;', self._next)
    self._arrowBtn.bind('&lt;Shift-3&gt;', self._previous)
    self._arrowBtn.bind('&lt;Down&gt;', self._next)
    self._arrowBtn.bind('&lt;Up&gt;', self._previous)
    self._arrowBtn.bind('&lt;Control-n&gt;', self._next)
    self._arrowBtn.bind('&lt;Control-p&gt;', self._previous)
    self._arrowBtn.bind('&lt;Shift-Down&gt;', self._postList)
    self._arrowBtn.bind('&lt;Shift-Up&gt;', self._postList)
    self._arrowBtn.bind('&lt;F34&gt;', self._postList)
    self._arrowBtn.bind('&lt;F28&gt;', self._postList)
    self._arrowBtn.bind('&lt;space&gt;', self._postList)

    # Bind events to the dropdown window.
    self._popup.bind('&lt;Escape&gt;', self._unpostList)
    self._popup.bind('&lt;space&gt;', self._selectUnpost)
    self._popup.bind('&lt;Return&gt;', self._selectUnpost)
    self._popup.bind('&lt;ButtonRelease-1&gt;', self._dropdownBtnRelease)
    self._popup.bind('&lt;ButtonPress-1&gt;', self._unpostOnNextRelease)

    # Bind events to the Tk listbox.
    self.__listbox.bind('&lt;Enter&gt;', self._unpostOnNextRelease)

    # Bind events to the Tk entry widget.
    self._entryWidget.bind('&lt;Configure&gt;', self._resizeArrow)
    self._entryWidget.bind('&lt;Shift-Down&gt;', self._postList)
    self._entryWidget.bind('&lt;Shift-Up&gt;', self._postList)
    self._entryWidget.bind('&lt;F34&gt;', self._postList)
    self._entryWidget.bind('&lt;F28&gt;', self._postList)

        # Need to unpost the popup if the entryfield is unmapped (eg: 
        # its toplevel window is withdrawn) while the popup list is
        # displayed.
        self._entryWidget.bind('&lt;Unmap&gt;', self._unpostList)

else:
    # Create the scrolled listbox below the entry field.
    self._list = self.createcomponent('scrolledlist',
        (('listbox', 'scrolledlist_listbox'),), None,
        Pmw.ScrolledListBox, (interior,),
                selectioncommand = self._selectCmd)
    self._list.grid(column=2, row=3, sticky='nsew')
    self.__listbox = self._list.component('listbox')

    # The scrolled listbox should expand vertically.
    interior.grid_rowconfigure(3, weight = 1)

    # Create the label.
    self.createlabel(interior, childRows=2)

self._entryWidget.bind('&lt;Down&gt;', self._next)
self._entryWidget.bind('&lt;Up&gt;', self._previous)
self._entryWidget.bind('&lt;Control-n&gt;', self._next)
self._entryWidget.bind('&lt;Control-p&gt;', self._previous)
self.__listbox.bind('&lt;Control-n&gt;', self._next)
self.__listbox.bind('&lt;Control-p&gt;', self._previous)

if self['history']:
    self._entryfield.configure(command=self._addHistory)

# Check keywords and initialise options.
self.initialiseoptions()

def destroy(self):
</t>
<t tx="ekr.20100204085631.2045">if self['dropdown'] and self._isPosted:
        Pmw.popgrab(self._popup)
    Pmw.MegaWidget.destroy(self)

#======================================================================

# Public methods

def get(self, first = None, last=None):
</t>
<t tx="ekr.20100204085631.2046">if first is None:
    return self._entryWidget.get()
else:
    return self._list.get(first, last)

def invoke(self):
</t>
<t tx="ekr.20100204085631.2047">if self['dropdown']:
    self._postList()
else:
    return self._selectCmd()

def selectitem(self, index, setentry=1):
</t>
<t tx="ekr.20100204085631.2048">if type(index) == types.StringType:
    text = index
    items = self._list.get(0, 'end')
    if text in items:
    index = list(items).index(text)
    else:
        raise IndexError, 'index "%s" not found' % text
elif setentry:
    text = self._list.get(0, 'end')[index]

self._list.select_clear(0, 'end')
self._list.select_set(index, index)
self._list.activate(index)
self.see(index)
if setentry:
    self._entryfield.setentry(text)

# Need to explicitly forward this to override the stupid
# (grid_)size method inherited from Tkinter.Frame.Grid.
def size(self):
</t>
<t tx="ekr.20100204085631.2049">return self._list.size()

# Need to explicitly forward this to override the stupid
# (grid_)bbox method inherited from Tkinter.Frame.Grid.
def bbox(self, index):
</t>
<t tx="ekr.20100204085631.2050">return self._list.bbox(index)

def clear(self):
</t>
<t tx="ekr.20100204085631.2051">self._entryfield.clear()
self._list.clear()

#======================================================================

# Private methods for both dropdown and simple comboboxes.

def _addHistory(self):
</t>
<t tx="ekr.20100204085631.2052">input = self._entryWidget.get()

if input != '':
    index = None
    if self['unique']:
    # If item is already in list, select it and return.
    items = self._list.get(0, 'end')
    if input in items:
        index = list(items).index(input)

    if index is None:
    index = self._list.index('end')
    self._list.insert('end', input)

    self.selectitem(index)
    if self['autoclear']:
    self._entryWidget.delete(0, 'end')

    # Execute the selectioncommand on the new entry.
    self._selectCmd()

def _next(self, event):
</t>
<t tx="ekr.20100204085631.2053">size = self.size()
if size &lt;= 1:
    return

cursels = self.curselection()

if len(cursels) == 0:
    index = 0
else:
    index = string.atoi(cursels[0])
    if index == size - 1:
    index = 0
    else:
    index = index + 1

self.selectitem(index)

def _previous(self, event):
</t>
<t tx="ekr.20100204085631.2054">size = self.size()
if size &lt;= 1:
    return

cursels = self.curselection()

if len(cursels) == 0:
    index = size - 1
else:
    index = string.atoi(cursels[0])
    if index == 0:
    index = size - 1
    else:
    index = index - 1

self.selectitem(index)

def _selectCmd(self, event=None):

</t>
<t tx="ekr.20100204085631.2055">sels = self.getcurselection()
if len(sels) == 0:
    item = None
else:
    item = sels[0]
    self._entryfield.setentry(item)

cmd = self['selectioncommand']
if callable(cmd):
        if event is None:
            # Return result of selectioncommand for invoke() method.
            return cmd(item)
        else:
            cmd(item)

#======================================================================

# Private methods for dropdown combobox.

def _drawArrow(self, event=None, sunken=0):
    arrow = self._arrowBtn
</t>
<t tx="ekr.20100204085631.2056">if sunken:
    self._arrowRelief = arrow.cget('relief')
    arrow.configure(relief = 'sunken')
else:
    arrow.configure(relief = self._arrowRelief)

if self._isPosted and self['fliparrow']:
        direction = 'up'
    else:
        direction = 'down'
    Pmw.drawarrow(arrow, self['entry_foreground'], direction, 'arrow')

def _postList(self, event = None):
    self._isPosted = 1
    self._drawArrow(sunken=1)

    # Make sure that the arrow is displayed sunken.
    self.update_idletasks()

    x = self._entryfield.winfo_rootx()
    y = self._entryfield.winfo_rooty() + \
        self._entryfield.winfo_height()
    w = self._entryfield.winfo_width() + self._arrowBtn.winfo_width()
    h =  self.__listbox.winfo_height()
    sh = self.winfo_screenheight()

    if y + h &gt; sh and y &gt; sh / 2:
        y = self._entryfield.winfo_rooty() - h

    self._list.configure(hull_width=w)

    Pmw.setgeometryanddeiconify(self._popup, '+%d+%d' % (x, y))

    # Grab the popup, so that all events are delivered to it, and
    # set focus to the listbox, to make keyboard navigation
    # easier.
    Pmw.pushgrab(self._popup, 1, self._unpostList)
    self.__listbox.focus_set()

    self._drawArrow()

    # Ignore the first release of the mouse button after posting the
    # dropdown list, unless the mouse enters the dropdown list.
    self._ignoreRelease = 1

</t>
<t tx="ekr.20100204085631.2057">def _dropdownBtnRelease(self, event):
</t>
<t tx="ekr.20100204085631.2058">if (event.widget == self._list.component('vertscrollbar') or
    event.widget == self._list.component('horizscrollbar')):
    return

if self._ignoreRelease:
    self._unpostOnNextRelease()
    return

    self._unpostList()

if (event.x &gt;= 0 and event.x &lt; self.__listbox.winfo_width() and
    event.y &gt;= 0 and event.y &lt; self.__listbox.winfo_height()):
    self._selectCmd()

def _unpostOnNextRelease(self, event = None):
</t>
<t tx="ekr.20100204085631.2059">self._ignoreRelease = 0

def _resizeArrow(self, event):
</t>
<t tx="ekr.20100204085631.2060">bw = (string.atoi(self._arrowBtn['borderwidth']) + 
    string.atoi(self._arrowBtn['highlightthickness']))
newHeight = self._entryfield.winfo_reqheight() - 2 * bw
newWidth = int(newHeight * self['buttonaspect'])
self._arrowBtn.configure(width=newWidth, height=newHeight)
self._drawArrow()

def _unpostList(self, event=None):
</t>
<t tx="ekr.20100204085631.2061">if not self._isPosted:
        # It is possible to get events on an unposted popup.  For
        # example, by repeatedly pressing the space key to post
        # and unpost the popup.  The &lt;space&gt; event may be
        # delivered to the popup window even though
        # Pmw.popgrab() has set the focus away from the
        # popup window.  (Bug in Tk?)
        return

    # Restore the focus before withdrawing the window, since
    # otherwise the window manager may take the focus away so we
    # can't redirect it.  Also, return the grab to the next active
    # window in the stack, if any.
    Pmw.popgrab(self._popup)
self._popup.withdraw()

self._isPosted = 0
self._drawArrow()

def _selectUnpost(self, event):
    self._unpostList()
</t>
<t tx="ekr.20100205074729.2085"></t>
<t tx="ekr.20100205074729.2086">line 1: node a changed 2</t>
<t tx="ekr.20100205074729.2087">@all</t>
<t tx="ekr.20100205114630.2089"># This file illustrates some off-by-n problems in goto-global-line.

# Actually, there may be a bigger problem with the @auto file write logic.
# Adding /deleteing blank lines here doesn't change the file!!!


# Based on iwidgets2.2.0/combobox.itk code.

import os
import string
</t>
<t tx="ekr.20100205114630.2090">class ComboBox(Pmw.MegaWidget):
    pass
</t>
<t tx="ekr.20100205114630.2091"></t>
<t tx="ekr.20100329100226.2108">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20100329100841.2109">Level 1</t>
<t tx="ekr.20100329100841.2110">Level 2</t>
<t tx="ekr.20100330082345.2120">@language pseudoplain

This is a [[test]] of something.</t>
<t tx="ekr.20100330084954.2125"></t>
<t tx="ekr.20100507151756.2123"></t>
<t tx="ekr.20100516140428.2135">import base64
import getpass
import hashlib

print(getpass.getuser())

m = hashlib.sha1()
m.update("Nobody inspect2s")
key = m.digest()
key = base64.urlsafe_b64encode(str(key))
print(key)
</t>
<t tx="ekr.20100521101729.2148"># Just playing with part of a template system, the (partial) mock up for "range()" is:

def tabStopNaming (event=None):

  stateName = 'naming'
  k = c.k
  state = k.getState(stateName)

  help = ('start-value -- optional, -&gt; fill-in or tab eliminate.  ',
           'end-value -- required, -&gt; fill-in.  ',
           'step -- optional, -&gt;fill-in or tab to eliminate.  ')
  tabStop = ('start-value', 'end-value', 'step')

  if state == 0:
      k.setLabelBlue(help[0],protect=True)
      k.getArg(event,stateName,1,tabStopNaming)
      # g.es('does this ever executed?') # yes, imediately!
  else:
      k.clearState()
      g.es_print('%s : %s' % (tabStop[0], k.arg))
      k.setLabelBlue('')

tabStopNaming()</t>
<t tx="ekr.20100526075442.2155" rst-import="7d710028580b000000756e6465726c696e657332710158000000007102580b000000756e6465726c696e657331710358030000003d2b2a7104752e">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20100526092131.2157"></t>
<t tx="ekr.20100526092131.2158"></t>
<t tx="ekr.20100526092131.2159">::

  digraph G {
      main -&gt; parse -&gt; execute;
      main -&gt; init;
      main -&gt; cleanup;
      execute -&gt; make_string;
      execute -&gt; printf
      init -&gt; make_string;
      main -&gt; printf;
      execute -&gt; compare;
      }


.. graphviz::

  digraph G {
      main -&gt; parse -&gt; execute;
      main -&gt; init;
      main -&gt; cleanup;
      execute -&gt; make_string;
      execute -&gt; printf
      init -&gt; make_string;
      main -&gt; printf;
      execute -&gt; compare;
      }

</t>
<t tx="ekr.20100526092131.2160">::

    digraph G {
        size ="4,4";
        main [shape=box];    /* this is a comment */
        main -&gt; parse [weight=8];
        parse -&gt; execute;
        main -&gt; init [style=dotted];
        main -&gt; cleanup;
        execute -&gt; { make_string; printf}
        init -&gt; make_string;
        edge [color=red];    // so is this
        main -&gt; printf [style=bold,label="100 times"];
        make_string [label="make a\nstring"];
        node [shape=box,style=filled,color=".7 .3 1.0"];
        execute -&gt; compare;
    }

.. graphviz::

    digraph G {
        size ="4,4";
        main [shape=box];    /* this is a comment */
        main -&gt; parse [weight=8];
        parse -&gt; execute;
        main -&gt; init [style=dotted];
        main -&gt; cleanup;
        execute -&gt; { make_string; printf}
        init -&gt; make_string;
        edge [color=red];    // so is this
        main -&gt; printf [style=bold,label="100 times"];
        make_string [label="make a\nstring"];
        node [shape=box,style=filled,color=".7 .3 1.0"];
        execute -&gt; compare;
    }

</t>
<t tx="ekr.20100526092131.2161">::

    digraph G {
        a -&gt; b -&gt; c;
        b -&gt; d;
        a [shape=polygon,sides=5,peripheries=3,color=lightblue,style=filled];
        c [shape=polygon,sides=4,skew=.4,label="hello world"]
        d [shape=invtriangle];
        e [shape=polygon,sides=4,distortion=.7];
    }
    
.. graphviz::

    digraph G {
        a -&gt; b -&gt; c;
        b -&gt; d;
        a [shape=polygon,sides=5,peripheries=3,color=lightblue,style=filled];
        c [shape=polygon,sides=4,skew=.4,label="hello world"]
        d [shape=invtriangle];
        e [shape=polygon,sides=4,distortion=.7];
    }

</t>
<t tx="ekr.20100526092131.2162">::

    digraph structs {
    node [shape=record];
        struct1 [shape=record,label="&lt;f0&gt; left|&lt;f1&gt; mid\ dle|&lt;f2&gt; right"];
        struct2 [shape=record,label="&lt;f0&gt; one|&lt;f1&gt; two"];
        struct3 [shape=record,label="hello\nworld |{ b |{c|&lt;here&gt; d|e}| f}| g | h"];
        struct1 -&gt; struct2;
        struct1 -&gt; struct3;
    }

.. graphviz::

    digraph structs {
    node [shape=record];
        struct1 [shape=record,label="&lt;f0&gt; left|&lt;f1&gt; mid\ dle|&lt;f2&gt; right"];
        struct2 [shape=record,label="&lt;f0&gt; one|&lt;f1&gt; two"];
        struct3 [shape=record,label="hello\nworld |{ b |{c|&lt;here&gt; d|e}| f}| g | h"];
        struct1 -&gt; struct2;
        struct1 -&gt; struct3;
    }

</t>
<t tx="ekr.20100526092131.2163">::

    digraph html {
        abc [shape=none, margin=0, label=&lt;
    &lt;TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4"&gt;
      &lt;TR&gt;&lt;TD ROWSPAN="3"&gt;&lt;FONT COLOR="red"&gt;hello&lt;/FONT&gt;&lt;BR/&gt;world&lt;/TD&gt;
          &lt;TD COLSPAN="3"&gt;b&lt;/TD&gt;
          &lt;TD ROWSPAN="3" BGCOLOR="lightgrey"&gt;g&lt;/TD&gt;
          &lt;TD ROWSPAN="3"&gt;h&lt;/TD&gt;
      &lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;c&lt;/TD&gt;
          &lt;TD PORT="here"&gt;d&lt;/TD&gt;
          &lt;TD&gt;e&lt;/TD&gt;
      &lt;/TR&gt;
      &lt;TR&gt;&lt;TD COLSPAN="3"&gt;f&lt;/TD&gt;
      &lt;/TR&gt;
    &lt;/TABLE&gt;&gt;];
    }

.. graphviz::

    digraph html {
        abc [shape=none, margin=0, label=&lt;
    &lt;TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4"&gt;
      &lt;TR&gt;&lt;TD ROWSPAN="3"&gt;&lt;FONT COLOR="red"&gt;hello&lt;/FONT&gt;&lt;BR/&gt;world&lt;/TD&gt;
          &lt;TD COLSPAN="3"&gt;b&lt;/TD&gt;
          &lt;TD ROWSPAN="3" BGCOLOR="lightgrey"&gt;g&lt;/TD&gt;
          &lt;TD ROWSPAN="3"&gt;h&lt;/TD&gt;
      &lt;/TR&gt;
      &lt;TR&gt;&lt;TD&gt;c&lt;/TD&gt;
          &lt;TD PORT="here"&gt;d&lt;/TD&gt;
          &lt;TD&gt;e&lt;/TD&gt;
      &lt;/TR&gt;
      &lt;TR&gt;&lt;TD COLSPAN="3"&gt;f&lt;/TD&gt;
      &lt;/TR&gt;
    &lt;/TABLE&gt;&gt;];
    }

</t>
<t tx="ekr.20100526092131.2164">::

    digraph asde91 {
        ranksep=.75; size = "7.5,7.5";
        {
            node [shape=plaintext, fontsize=16];
            /* the time-line graph */
            past -&gt; 1978 -&gt; 1980 -&gt; 1982 -&gt; 1983 -&gt; 1985 -&gt; 1986 -&gt;
                     1987 -&gt; 1988 -&gt; 1989 -&gt; 1990 -&gt; "future";
            /* ancestor programs */
            "Bourne sh"; "make"; "SCCS"; "yacc"; "cron"; "Reiser cpp";
            "Cshell"; "emacs"; "build"; "vi"; "&lt;curses&gt;"; "RCS"; "C*";
        }
        { rank = same;
            "Software IS"; "Configuration Mgt"; "Architecture &amp; Libraries";
            "Process";
        };
        node [shape=box];
        { rank = same; "past"; "SCCS"; "make"; "Bourne sh"; "yacc"; "cron"; }
        { rank = same; 1978; "Reiser cpp"; "Cshell"; }
        { rank = same; 1980; "build"; "emacs"; "vi"; }
        { rank = same; 1982; "RCS"; "&lt;curses&gt;"; "IMX"; "SYNED"; }
        { rank = same; 1983; "ksh"; "IFS"; "TTU"; }
        { rank = same; 1985; "nmake"; "Peggy"; }
        { rank = same; 1986; "C*"; "ncpp"; "ksh-i"; "&lt;curses-i&gt;"; "PG2"; }
        { rank = same; 1987; "Ansi cpp"; "nmake 2.0"; "3D File System"; "fdelta";
            "DAG"; "CSAS";}
        { rank = same; 1988; "CIA"; "SBCS"; "ksh-88"; "PEGASUS/PML"; "PAX";
            "backtalk"; }
        { rank = same; 1989; "CIA++"; "APP"; "SHIP"; "DataShare"; "ryacc";
            "Mosaic"; }
        { rank = same; 1990; "libft"; "CoShell"; "DIA"; "IFS-i"; "kyacc"; "sfio";
            "yeast"; "ML-X"; "DOT"; }
        { rank = same; "future"; "Adv. Software Technology"; }
        "PEGASUS/PML" -&gt; "ML-X";
        "SCCS" -&gt; "nmake";
        "SCCS" -&gt; "3D File System";
        "SCCS" -&gt; "RCS";
        "make" -&gt; "nmake";
        "make" -&gt; "build";
        .
        .
        .
    }

.. graphviz::

    digraph asde91 {
        ranksep=.75; size = "7.5,7.5";
        {
            node [shape=plaintext, fontsize=16];
            /* the time-line graph */
            past -&gt; 1978 -&gt; 1980 -&gt; 1982 -&gt; 1983 -&gt; 1985 -&gt; 1986 -&gt;
                     1987 -&gt; 1988 -&gt; 1989 -&gt; 1990 -&gt; "future";
            /* ancestor programs */
            "Bourne sh"; "make"; "SCCS"; "yacc"; "cron"; "Reiser cpp";
            "Cshell"; "emacs"; "build"; "vi"; "&lt;curses&gt;"; "RCS"; "C*";
        }
        { rank = same;
            "Software IS"; "Configuration Mgt"; "Architecture &amp; Libraries";
            "Process";
        };
        node [shape=box];
        { rank = same; "past"; "SCCS"; "make"; "Bourne sh"; "yacc"; "cron"; }
        { rank = same; 1978; "Reiser cpp"; "Cshell"; }
        { rank = same; 1980; "build"; "emacs"; "vi"; }
        { rank = same; 1982; "RCS"; "&lt;curses&gt;"; "IMX"; "SYNED"; }
        { rank = same; 1983; "ksh"; "IFS"; "TTU"; }
        { rank = same; 1985; "nmake"; "Peggy"; }
        { rank = same; 1986; "C*"; "ncpp"; "ksh-i"; "&lt;curses-i&gt;"; "PG2"; }
        { rank = same; 1987; "Ansi cpp"; "nmake 2.0"; "3D File System"; "fdelta";
            "DAG"; "CSAS";}
        { rank = same; 1988; "CIA"; "SBCS"; "ksh-88"; "PEGASUS/PML"; "PAX";
            "backtalk"; }
        { rank = same; 1989; "CIA++"; "APP"; "SHIP"; "DataShare"; "ryacc";
            "Mosaic"; }
        { rank = same; 1990; "libft"; "CoShell"; "DIA"; "IFS-i"; "kyacc"; "sfio";
            "yeast"; "ML-X"; "DOT"; }
        { rank = same; "future"; "Adv. Software Technology"; }
        "PEGASUS/PML" -&gt; "ML-X";
        "SCCS" -&gt; "nmake";
        "SCCS" -&gt; "3D File System";
        "SCCS" -&gt; "RCS";
        "make" -&gt; "nmake";
        "make" -&gt; "build";
    }

</t>
<t tx="ekr.20100526092131.2165">Machine
 
 - physical
 - virtual
 
  - id
  
   - mac
   - ip
   - description
   - name
     - hostname
     - netbios
     - fqname
     
   - storage
   - ram
     
App

Input, Output

 - keyboard
 - mouse
 - file
 
   - config
   - log
   - data
   
 - stream

</t>
<t tx="ekr.20100526092131.2166">/etc/dhcp3/dhcpd.conf::

	option ntp-servers 192.168.0.12;
	option root-path "";
	option routers 192.168.0.12;
	option broadcast-address 192.168.0.255;
	option domain-name-servers 192.168.0.253, 192.168.0.12;
	use-host-decl-names on;
	default-lease-time 86400;
	max-lease-time 86400;
	#stop


	# Courthouse
	subnet 192.168.0.0 netmask 255.255.255.0 {
		range dynamic-bootp 192.168.0.151 192.168.0.225;
		}
	# Kent's W2k workstation
	host itstation2 {
		hardware ethernet 00:16:E6:9C:24:DF;
		fixed-address 192.168.0.32;
		}
	# Office workstation
	host itstation3 {
		hardware ethernet 00:24:1d:d1:4d:4b;
		fixed-address 192.168.0.33;
		}
	# lappy wireless
	host lappy-wireless {
		hardware ethernet 00:12:F0:E9:55:84;
		fixed-address 192.168.0.35;
		}
	# Plotter/Scanner storage
	host hpdjcc {
		hardware ethernet 00:d0:c9:98:92:2a;
		fixed-address 192.168.0.90;
		}
	# DNR License machine in Clerks office
	host DNRLICENSES {
		hardware ethernet 00:03:2d:0d:57:e2;
		fixed-address 192.168.0.40;
		}
	# Peg Kurilla laptop
	host COUNTYADMIN {
		hardware ethernet 00:19:7d:c9:25:d2;
		fixed-address 192.168.0.50;
		}
	# Netgear WG511v2 PCMCIA card (UWEX)
	host uwextwin98 {
		hardware ethernet 00:1b:2f:28:f0:91;
		fixed-address 192.168.0.51;
		}
	# GIS-MAIN Gis workstation
	host GIS-MAIN {
		hardware ethernet 00:0a:a6:8d:4f:2f;
		fixed-address 192.168.0.36;
		}
	# Mable in ROD
	host DEEDS-MABLE {
		hardware ethernet 00:18:f3:50:5c:e2;
		fixed-address 192.168.0.55;
		}
	# Kathie in Deeds
	host AUDITMACHINE {
		hardware ethernet 00:0c:6e:f5:7f:95;
		fixed-address 192.168.0.56;
		}
	# Karen in Deeds
	host KM-SCANNER {
		hardware ethernet 00:11:09:b4:fb:5d;
		fixed-address 192.168.0.57;
		}
	# Counter in Deeds
	host DEEDS-COUNTER {
		hardware ethernet 00:01:03:c4:d8:96;
		fixed-address 192.168.0.58;
		}

	# Lappy wired
	host lappy {
		hardware ethernet 00:0a:e4:37:00:80;
		fixed-address 192.168.0.34;
		}
	# laserfiche host
	host laserfiche {
		hardware ethernet 00:26:18:fb:98:8e;
		fixed-address 192.168.0.10;
		}
	# laserfiche VM
	host laserfichexp {
		hardware ethernet 08:00:27:d3:74:a7;
		fixed-address 192.168.0.11;
		}
	# Tape drive host in Child Support
	host csa-tape01 {
		hardware ethernet 00:40:63:d7:ae:e6;
		fixed-address 192.168.0.17;
		}
	# Child Support MX680 Canon all in one
	host CSA-MX680 {
		hardware ethernet 00:1e:8f:9c:1e:d8;
		fixed-address 192.168.0.30;
		}
	# Darlene in Child Support
	host CSA-70 {
		hardware ethernet 90:e6:ba:88:2f:ca;
		fixed-address 192.168.0.70;
		}
	# Jenny in Child Support
	host CSA-71 {
		hardware ethernet e0:cb:4e:32:09:2d;
		fixed-address 192.168.0.71;
		}
	# Bev's desktop workstation (in Lenovo case)
	host CSA-72 {
		hardware ethernet e0:cb:4e:24:33:1d;
		fixed-address 192.168.0.72;
		}
	# Patty in Treasurers
	host TREAS-85 {
		hardware ethernet 00:50:fc:cf:08:91;
		fixed-address 192.168.0.85;
		}
	# Tracey's computer
	host TREAS-86 {
		hardware ethernet 00:40:63:d8:9d:ce;
		fixed-address 192.168.0.86;
		}
	# Jeff Beirl's computer
	host ADMIN-91 {
		hardware ethernet 00:17:31:88:55:a1;
		fixed-address 192.168.0.91;
		}
	# Peg Kurilla's laptop
	host ADMIN-93 {
		hardware ethernet 00:19:7d:c9:25:d2;
		fixed-address 192.168.0.93;
		}
	# Treasurer counter machine
	host TREAS-87 {
		hardware ethernet 00:40:f4:4e:9c:b7;
		fixed-address 192.168.0.87;
		}
	# Sid in CSA
	host CSA-75 {
		hardware ethernet 00:26:55:43:9f:b9;
		fixed-address 192.168.0.76;
		}
	# Larry Hildebrandt
	host ZONE-100 {
		hardware ethernet 00:24:21:f0:f1:4b;
		fixed-address 192.168.0.100;
		}
	# Patience in CSA
	host CSA-73 {
		hardware ethernet 90:e6:ba:3a:47:56;
		fixed-address 192.168.0.73;
		}
	# Griff
	host CSA-77 {
		hardware ethernet 00:23:5a:d4:e5:2d;
		fixed-address 192.168.0.77;
		}
	# Traci in CSA
	host CSA-74 {
		hardware ethernet 18:a9:05:16:a6:4b;
		fixed-address 192.168.0.74;
		}
	# Joan in CSA
	host CSA-75 {
		hardware ethernet 18:a9:05:1f:98:df;
		fixed-address 192.168.0.75;
		}

</t>
<t tx="ekr.20100526092131.2167">&gt;&gt;&gt; import networkx as nx

&gt;&gt;&gt; G=nx.Graph()
&gt;&gt;&gt; G.add_node("spam")
&gt;&gt;&gt; G.add_edge(1,2)
&gt;&gt;&gt; print G.nodes()
[1, 2, 'spam']
&gt;&gt;&gt; print G.edges()
[(1, 2)]

</t>
<t tx="ekr.20100526092131.2168">.. include:: /home/ktenney/work/fetched/networkx/doc/source/tutorial/tutorial.rst

</t>
<t tx="ekr.20100526092131.2169"></t>
<t tx="ekr.20100526092131.2170">.. code-block:: python

 import networkx
 import pygraphviz
 import os
 G = networkx.Graph()
 
 contents = os.listdir('/tmp')
 
 
 G.add_nodes_from(contents)
 networkx.write_dot(G, '/tmp/networkx')
 
.. graphviz::
 
   digraph  {
	"pulse-LNhuxKcTtQ7o";
	"manuel-testrunner.py";
	"orbit-root";
	".ICE-unix";
	".esd-1000";
	".X0-lock";
	"keyring-IaomNN";
	"virtual-ktenney.OPfhI7";
	"orbit-ktenney";
	"ssh-AHVfka1250";
	"server-B20D7FC79C7F597315E3E501AEF10E0D866E8E92.xkm";
	"serverauth.XfwQdCpMON";
	".X11-unix";
	"tracker-ktenney";
	networkx;
	".exchange-ktenney";
	"Miro_Download_Daemon_1000.txt";
	"manuel-testfile.py";
      }

</t>
<t tx="ekr.20100526092131.2171"># differences between pygraphviz and networkx
# http://networkx.lanl.gov/pygraphviz/reference/api_notes.html
&gt;&gt;&gt; import pygraphviz
&gt;&gt;&gt; pygraphviz

</t>
<t tx="ekr.20100526092131.2172">.. code-block:: python

    import networkx

</t>
<t tx="ekr.20100615095815.2189">import leo.core.leoPlugins as leoPlugins

def on_deactivate(tag,keys):
    c = keys.get('c')
    g.trace(c)

def on_activate(tag,keys):
    c = keys.get('c',keys)
    g.trace(c)

leoPlugins.registerHandler("deactivate", on_deactivate)
leoPlugins.registerHandler("activate", on_activate)

print('window events activated')</t>
<t tx="ekr.20100616085524.2191">for name,val,c,letter in g.app.config.config_iter(c):
    print('%45s %s %s' % (name,letter,val))</t>
<t tx="ekr.20100728114551.2149">Changed again.</t>
<t tx="ekr.20100729114420.2152">@language plain

This is a test.</t>
<t tx="ekr.20100731123441.2155">def searchDir(path,pattern):
    print('\ndir',path)
    paths = glob.glob(g.os_path_join(path,'*'))
    files = [z for z in paths if not g.os_path_isdir(z)]
    dirs  = [z for z in paths if g.os_path_isdir(z)]
    for fn in files:
        if not fn.endswith('.pyc'):
            print(g.shortFileName(fn))
            found = False
            s,e = g.readFileIntoString(fn)
            if ignoreCase:
                s = s.lower()
                pattern = pattern.lower()
            i = 0
            while i &lt; len(s):
                i = s.find(pattern,i)
                if i == -1: break
                n1,n2 = g.getLine(s,i)
                i = n2
                if not found:
                    g.pr('\n','-' * 10,g.shortFileName(fn))
                    found = True
                g.pr(s[n1:n2-1])
    for fn in dirs:
        searchDir(g.os_path_join(path,fn),pattern)</t>
<t tx="ekr.20100812102648.2193">@ @rst-markup
########################
Leo's code markup script
########################
@c
'''A script showing how to convert code in Leo outlines to rST/Sphinx code.

The defaultOptions dict specifies default options.

This script uses leoRst.py:code_to_rst_command.'''

if 1: # Format a particular node.
    h = '@button format-code'
    p = g.findNodeAnywhere(c,h)

&lt;&lt; options &gt;&gt;

if p:
    c.rstCommands.code_to_rst_command(scriptSettingsDict=scriptSettingsDict)
else:
    print('not found',h)
</t>
<t tx="ekr.20100812102648.2195">@ Here are the options
@c
fn = '%s.html' % (g.sanitize_filename(p.h))

# g.es('output file',repr(fn))

scriptSettingsDict = {
    'output-file-name': 'format-code-output.html', # fn,
    'call-docutils': True,
    'number-code-lines': True,
    'show_doc_parts_as_paragraphs': True,
    'stylesheet_name': 'default.css',
    # 'stylesheet_path': '../doc', # Must be None, not ''.
    'write-intermediate-file': True,
    'write_intermediate_extension': 'txt'
}

# old_dict = {

    # # The following options are definitely used in the script.
    # 'generate-rst-header-comment': True,
    # 'output-file-name': fn,
    # 'show_headlines': True,
    # 'show_options_nodes': False,
    # 'show_organizer_nodes': True,
    # 'show_sections': True,
    # 'underline_characters': '''#=+*^~"'`-:&gt;&lt;_''',
    # 'verbose': True,

    # # The following are not used, but probably should be used.
    # 'code_block_string': '::',
    # 'default_path': None, # Must be None, not ''.
    # 'encoding': 'utf-8',
    # 'publish_argv_for_missing_stylesheets': None,
    # 'stylesheet_embed': True,
    # 'stylesheet_name': 'default.css',
    # 'stylesheet_path': None, # Must be None, not ''.

    # # The following are not used. Their status is unclear.
    # 'show_leo_directives': False,
# }
</t>
<t tx="ekr.20100812114823.2176"></t>
<t tx="ekr.20100812114823.2177">def code_to_rst_command (self,event=None,p=None,scriptSettingsDict=None):

    '''Format the presently selected node as computer code.

    When run from the minibuffer, initial settings come from the outline, as usual.

    When called from a script, initial setting may come from scriptSettingsDict.

    Return true and set self.source and self.output if all requested files were written.
    '''

    trace = False and not g.unitTesting
    c = self.c
    if p: p = p.copy()
    else: p = c.p

    # **Important**: This command works as much like the rst3 command as possible.
    # Difference arise because there is no @rst node to specify a filename.
    # Instead we get the filename from scriptSettingsDict, or use 'code_to_rst.html'

    # Capture the settings, munging all settings.
    self.scriptSettingsDict = {}
    d = scriptSettingsDict
    if d:
        for key in d.keys():
            self.scriptSettingsDict[self.munge(key)] = d.get(key)

    # From processTree...
    self.topLevel = p.level() # Define toplevel separately for each rst file.
    self.preprocessTree(p)
    self.scanAllOptions(p) # So we can get the next options.

    # getOption will not work until scanAllOptions::initOptionsFromSettings has been called.
    callDocutils = self.getOption('call_docutils')
    writeIntermediateFile = self.getOption('write_intermediate_file')
    g.trace(self.getOption('output-file-name'))
    outputFileName = self.getOption('output-file-name') or 'code_to_rst.html'
    junk,self.ext = g.os_path_splitext(outputFileName)
    isHtml = self.ext in ('.html','.htm')

    # From writeSpecialTree...
    self.initWrite(p)
    self.outputFile = StringIO()
    self.write_code_tree(p)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if callDocutils or writeIntermediateFile:
        # **Note**: self.outputFileName does not exist.
        self.outputFileName = self.computeOutputFileName(outputFileName)

        # Create the directory if it doesn't exist.
        theDir, junk = g.os_path_split(self.outputFileName)
        theDir = c.os_path_finalize(theDir)
        if not g.os_path_exists(theDir):
            ok = g.makeAllNonExistentDirectories(theDir,c=c,force=False)
            if not ok:
                g.es_print('did not create:',theDir,color='red')
                return False

    if writeIntermediateFile:
        ext = self.getOption('write_intermediate_extension') or '.txt' # .txt by default.
        if not ext.startswith('.'): ext = '.' + ext
        name = self.outputFileName.rsplit('.',1)[0] + ext
        if trace: g.trace('intermediate file',name)
        if g.isPython3:
            f = open(name,'w',encoding=self.encoding)
        else:
            f = open(name,'w')
        f.write(self.source)
        f.close()
        self.report(name)

    if callDocutils:
        if trace: g.trace('calling docutils')
        try:
            output = self.writeToDocutils(self.source)
            if g.isBytes(output):
                output = g.toUnicode(output)
        except Exception:
            g.pr('Exception in docutils')
            g.es_exception()
            return False

        if isHtml:
            import re
            if g.isBytes(output):
                output = g.toUnicode(output)
            idxTitle = output.find('&lt;title&gt;&lt;/title&gt;')
            if idxTitle &gt; -1:
                m = re.search('&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;', output)
                if not m:
                    m = re.search('&lt;h1&gt;&lt;[^&gt;]+&gt;([^&lt;]*)&lt;/a&gt;&lt;/h1&gt;', output)
                if m:
                    output = output.replace(
                        '&lt;title&gt;&lt;/title&gt;',
                        '&lt;title&gt;%s&lt;/title&gt;' % m.group(1)
                    )

        self.stringOutput = output # Always useful for scripts.

        # Write the file to the directory containing the .leo file.
        f = open(self.outputFileName,'w')
        f.write(output)
        f.close()
        self.report(self.outputFileName)

    return True
</t>
<t tx="ekr.20100812114823.2178">def write_code_body (self,p):

    trace = False
    self.p = p.copy() # for traces.
    if not p.b.strip():
        return # No need to write any more newlines.

    showDocsAsParagraphs = self.getOption('show_doc_parts_as_paragraphs')
    lines = g.splitLines(p.b)
    parts = self.split_parts(lines,showDocsAsParagraphs)
    result = []
    for kind,lines in parts:
        if trace: g.trace(kind,len(lines),p.h)
        if kind == '@rst-option': # Also handles '@rst-options'
            pass # The prepass has already handled the options.
        elif kind == '@rst-markup':
            lines.extend('\n')
            result.extend(lines)
        elif kind == '@doc':
            if showDocsAsParagraphs:
                result.extend(lines)
                result.append('\n')
            else:
                result.extend(self.write_code_block(lines))
        elif kind == 'code':
            result.extend(self.write_code_block(lines))
        else:
            g.trace('Can not happen',kind)

    # Write the lines with exactly two trailing newlines.
    s = ''.join(result).rstrip() + '\n\n'
    self.write(s)
</t>
<t tx="ekr.20100812114823.2179">def split_parts (self,lines,showDocsAsParagraphs):

    '''Split a list of body lines into a list of tuples (kind,lines).'''

    kind,parts,part_lines = 'code',[],[]
    for s in lines:
        if g.match_word(s,0,'@ @rst-markup'):
            if part_lines: parts.append((kind,part_lines[:]),)
            kind = '@rst-markup'
            n = len('@ @rst-markup')
            after = s[n:].strip()
            part_lines = g.choose(after,[after],[])
        elif s.startswith('@ @rst-option'):
            if part_lines: parts.append((kind,part_lines[:]),)
            kind,part_lines = '@rst-option',[s] # part_lines will be ignored.
        elif s.startswith('@ ') or s.startswith('@\n') or s.startswith('@doc'):
            if showDocsAsParagraphs:
                if part_lines: parts.append((kind,part_lines[:]),)
                kind = '@doc'
                # Put only what follows @ or @doc
                n = g.choose(s.startswith('@doc'),4,1)
                after = s[n:].lstrip()
                part_lines = g.choose(after,[after],[])
            else:
                part_lines.append(s) # still in code mode.
        elif g.match_word(s,0,'@c') and kind != 'code':
            if kind == '@doc' and not showDocsAsParagraphs:
                    part_lines.append(s) # Show the @c as code.
            parts.append((kind,part_lines[:]),)
            kind,part_lines = 'code',[]
        else:
            part_lines.append(s)

    if part_lines:
        parts.append((kind,part_lines[:]),)

    return parts
</t>
<t tx="ekr.20100812114823.2180">def write_code_block (self,lines):

    result = ['::\n\n'] # ['[**code block**]\n\n']

    if self.getOption('number-code-lines'):
        i = 1
        for s in lines:
            result.append('    %d: %s' % (i,s))
            i += 1
    else:
        result.extend(['    %s' % (z) for z in lines])

    s = ''.join(result).rstrip()+'\n\n'
    return g.splitLines(s)
</t>
<t tx="ekr.20100812114823.2181">def write_code_headline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''


    docOnly             = self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.write_code_headline_helper(p)
</t>
<t tx="ekr.20100812114823.2182">def write_code_headline_helper (self,p):

    h = p.h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0)
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip()
    if word:
        # Never generate a section for @rst-option or @rst-options or @rst-no-head.
        if word in ('@rst-option','@rst-options','@rst-no-head','@rst-no-headlines'):
            return

        for prefix in ('@rst-ignore-node','@rst-ignore-tree','@rst-ignore'):
            if word == prefix:
                h = h [len(word):].strip()
                break

    if not h.strip(): return

    if self.getOption('show_sections'):
        self.write(self.underline(h,p))
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
</t>
<t tx="ekr.20100812114823.2183">def write_code_node (self,p):

    '''Format a node according to the options presently in effect.

    Side effect: advance p'''

    h = p.h.strip()
    self.scanAllOptions(p)

    if self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.write_code_headline(p)
        self.write_code_body(p)
        p.moveToThreadNext()
</t>
<t tx="ekr.20100812114823.2184">def write_code_tree (self,p):

    '''Write p's tree as code to self.outputFile.'''

    self.scanAllOptions(p) # So we can get the next option.

    if self.getOption('generate_rst_header_comment'):
        self.write('.. rst3: filename: %s\n\n' % self.outputFileName)

    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    self.topNode = p.copy() # Indicate the top of this tree.
    after = p.nodeAfterTree()
    while p and p != after:
        self.write_code_node(p) # Side effect: advances p.
</t>
<t tx="ekr.20100812114823.2185"></t>
<t tx="ekr.20100812114823.2186">def getOption (self,name):

    # 2010/08/12: munging names here is safe because setOption munges.
    return self.optionsDict.get(self.munge(name))

def setOption (self,name,val,tag):

    self.optionsDict [self.munge(name)] = val
</t>
<t tx="ekr.20100812114823.2187">def initOptionsFromSettings (self):

    c = self.c

    d = self.defaultOptionsDict
    keys = sorted(d)

    for key in keys:
        for getter,kind in (
            (c.config.getBool,'@bool'),
            (c.config.getString,'@string'),
            (d.get,'default'),
        ):
            val = getter(key)
            if kind == 'default' or val is not None:
                self.setOption(key,val,'initOptionsFromSettings')
                break

    # 2010/08/12: Script settings override everything else.
    d2 = self.scriptSettingsDict or {}
    for key in d2.keys():
        val = d2.get(key)
        # g.trace(key,val)
        self.setOption(key,val,'initOptionsFromSettings')

    # Special case.
    if self.getOption('http_server_support') and not mod_http:
        g.es('No http_server_support: can not import mod_http plugin',color='red')
        self.setOption('http_server_support',False)
</t>
<t tx="ekr.20100812114823.2188">def writeSpecialTree (self,p,toString,justOneFile):

    c = self.c
    isHtml = self.ext in ('.html','.htm')
    if isHtml and not SilverCity:
        if not self.silverCityWarningGiven:
            self.silverCityWarningGiven = True
            g.es('SilverCity not present so no syntax highlighting')

    self.initWrite(p)
        # was encoding=g.choose(isHtml,'utf-8','iso-8859-1'))
    self.outputFile = StringIO()
    self.writeTree(p)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if not toString:
        # Compute this here for use by intermediate file.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)

        # Create the directory if it doesn't exist.
        theDir, junk = g.os_path_split(self.outputFileName)
        theDir = c.os_path_finalize(theDir)
        if not g.os_path_exists(theDir):
            ok = g.makeAllNonExistentDirectories(theDir,c=c,force=False)
            if not ok:
                g.es_print('did not create:',theDir,color='red')
                return False

        if self.getOption('write_intermediate_file'):
            ext = self.getOption('write_intermediate_extension')
            if not ext.startswith('.'): ext = '.' + ext
            name = self.outputFileName.rsplit('.',1)[0] + ext 
            if g.isPython3: # 2010/04/21
                f = open(name,'w',encoding=self.encoding)
            else:
                f = open(name,'w')
            f.write(self.source)
            f.close()
            self.report(name)

    # g.trace('call_docutils',self.getOption('call_docutils'))
    if not self.getOption('call_docutils'):
        return False

    try:
        output = self.writeToDocutils(self.source)
        if g.isBytes(output):
            output = g.toUnicode(output)
        ok = output is not None
    except Exception:
        g.pr('Exception in docutils')
        g.es_exception()
        ok = False

    if ok:
        if isHtml:
            import re
            # g.trace(repr(output)) # Type is byte for Python3.
            idxTitle = output.find('&lt;title&gt;&lt;/title&gt;')
            if idxTitle &gt; -1:
                m = re.search('&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;', output)
                if not m:
                    m = re.search('&lt;h1&gt;&lt;[^&gt;]+&gt;([^&lt;]*)&lt;/a&gt;&lt;/h1&gt;', output)
                if m:
                    output = output.replace(
                        '&lt;title&gt;&lt;/title&gt;',
                        '&lt;title&gt;%s&lt;/title&gt;' % m.group(1)
                    )

        if toString:
            self.stringOutput = output
        else:
            # Write the file to the directory containing the .leo file.
            f = open(self.outputFileName,'w')
            f.write(output)
            f.close()
            self.http_endTree(self.outputFileName, p, justOneFile=justOneFile)

    return ok
</t>
<t tx="ekr.20100821214143.2190">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;!--@+leo-ver=5-thin--&gt;
&lt;!--@+node:ekr.20100808060203.4273: * @thin html/front.html--&gt;
&lt;!--@@first--&gt;
&lt;!--@@first--&gt;

&lt;!--@@language html--&gt;
&lt;!--@@tabwidth -2--&gt;

&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
    &lt;!--@+&lt;&lt; head &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4274: ** &lt;&lt; head &gt;&gt;--&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;

    &lt;title&gt;Leo's Home Page&lt;/title&gt;
    &lt;link rel="stylesheet" href="_static/default.css" type="text/css" /&gt;
    &lt;link rel="stylesheet" href="_static/pygments.css" type="text/css" /&gt;
    &lt;!--
    &lt;script type="text/javascript"&gt;
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '4.7-final',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    &lt;/script&gt;
    --&gt;
    &lt;!-- &lt;script type="text/javascript" src="_static/jquery.js"&gt;&lt;/script&gt;--&gt;
    &lt;!-- &lt;script type="text/javascript" src="_static/doctools.js"&gt;&lt;/script&gt;--&gt;
    &lt;link rel="top" title="Leo v4.7-final documentation" href="index.html" /&gt;
    &lt;link rel="Users Guide" title="Leo&amp;#8217;s Users Guide" href="leo_toc.html" /&gt;
    &lt;!-- &lt;link rel="prev" title="Chapter 5: Using LeoÃ¢â‚¬â„¢s Commands" href="commands.html" /&gt;--&gt; 
    &lt;!--@-&lt;&lt; head &gt;&gt;--&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--@+&lt;&lt; div top nav &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4276: ** &lt;&lt; div top nav &gt;&gt;--&gt;
    &lt;div class="related"&gt;
      &lt;h3&gt;Navigation&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li class="right" style="margin-right: 10px"&gt;
          &lt;a href="genindex.html" title="General Index"
             accesskey="I"&gt;index&lt;/a&gt;&lt;/li&gt;
        &lt;li class="right" &gt;
          &lt;a href="leo_toc.html" title="Leo&amp;#8217;s Users Guide"
             accesskey="N"&gt;contents&lt;/a&gt; |&lt;/li&gt;
        &lt;!--
        &lt;li class="right" &gt;
          &lt;a href="commands.html" title="Chapter 5: Using Leo&amp;#8217;s Commands"
             accesskey="P"&gt;previous&lt;/a&gt; |&lt;/li&gt;
        --&gt;
        &lt;li&gt;&lt;a href="leo_toc.html"&gt;Leo v4.7-final documentation&lt;/a&gt; &amp;raquo;&lt;/li&gt;

      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--@-&lt;&lt; div top nav &gt;&gt;--&gt;
    &lt;div class="document"&gt;
      &lt;div class="documentwrapper"&gt;
        &lt;div class="bodywrapper"&gt;
          &lt;div class="body"&gt;
            &lt;!--@+&lt;&lt; div outer section &gt;&gt;--&gt;
            &lt;!--@+node:ekr.20100808060203.4286: ** &lt;&lt; div outer section &gt;&gt;--&gt;
            &lt;div class="section" id="Leo&amp;#8217;s Home page"&gt;

                &lt;h1&gt;Leo&amp;#8217;s Home Page&lt;/h1&gt;

                Leo is...

                &lt;!--@+&lt;&lt; what is Leo list &gt;&gt;--&gt;
                &lt;!--@+node:ekr.20100808060203.4288: *3* &lt;&lt; what is Leo list &gt;&gt;--&gt;
                &lt;li&gt;
                    An outline-oriented &lt;i&gt;browser&lt;/i&gt; and &lt;i&gt;project manager&lt;/i&gt; that organizes&lt;br&gt;
                    programs, web sites, URL's, pictures, movies or any other kind of data.&lt;br&gt;
                    You can organize your data in as many ways as you like within a &lt;i&gt;single&lt;/i&gt; outline.&lt;/li&gt;
                &lt;li&gt;
                    A &lt;i&gt;programmer's editor&lt;/i&gt; that fully integrates outline structure with programming.
                    &lt;!--
                    &lt;a HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/a&gt; and
                    &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt; markup.&lt;/li&gt;
                    --&gt;
                &lt;li&gt;
                    &lt;i&gt;Fully scriptable&lt;/i&gt; using &lt;a HREF="http://www.python.org/"&gt;Python&lt;/a&gt;.
                    Leo's core is 100% pure Python.&lt;/li&gt;
                &lt;li&gt;
                    &lt;i&gt;Portable&lt;/i&gt;. Leo runs on Windows, Linux and MacOS X.&lt;br&gt;
                    Leo requires either the
                    &lt;a HREF="http://docs.python.org/library/tkinter.html"&gt;Tkinter&lt;/a&gt; or
                    &lt;a HREF="http://www.riverbankcomputing.co.uk/software/pyqt/intro"&gt;PyQt&lt;/a&gt; widget set.&lt;br&gt;
                    Leo's outline files are &lt;a HREF="http://www.w3.org/XML/"&gt;XML&lt;/a&gt; format.&lt;/li&gt;
                &lt;li&gt;
                    &lt;a href="http://www.opensource.org/"&gt;&lt;i&gt;Open Software&lt;/i&gt;&lt;/a&gt;,
                    distributed under the
                    &lt;a href="http://www.opensource.org/licenses/mit-license.php/"&gt;MIT License&lt;/a&gt;.&lt;/li&gt;
                &lt;!--@-&lt;&lt; what is Leo list &gt;&gt;--&gt;
                &lt;!-- div body toc --&gt;
                &lt;!-- &lt; &lt; inner sections &gt; &gt; --&gt;

                &lt;p&gt;Leo has an active community of helpful users and developers.&lt;br&gt;
                Please use the &lt;a href="http://groups.google.com/group/leo-editor"&gt;leo-editor&lt;/a&gt;
                group to ask questions and make suggestions.&lt;/p&gt;

                &lt;p&gt;Leo's author is &lt;a HREF="ekr.html"&gt;Edward K. Ream&lt;/a&gt;&lt;/p&gt;

            &lt;/div&gt;
            &lt;!--@-&lt;&lt; div outer section &gt;&gt;--&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;!--@+&lt;&lt; sidebar &gt;&gt;--&gt;
      &lt;!--@+node:ekr.20100808060203.4282: ** &lt;&lt; sidebar &gt;&gt;--&gt;
      &lt;div class="sphinxsidebar"&gt;
          &lt;div class="sphinxsidebarwrapper"&gt;
              &lt;!--@+&lt;&lt; sidebar contents &gt;&gt;--&gt;
              &lt;!--@+node:ekr.20100808060203.4283: *3* &lt;&lt; sidebar contents &gt;&gt;--&gt;
              &lt;p class="logo"&gt;&lt;a href="leo_toc.html"&gt;
                &lt;img class="logo" src="_static/Leo4-80-border.jpg" alt="Logo"/&gt;&lt;/a&gt;&lt;/p&gt;

              &lt;a class="reference external" href="intro.html"&gt;
                Read this tutorial first&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;
                Another tutorial&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http:screen-shots.html"&gt;
                Screen shots of Leo&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="testimonials.html"&gt;
                Quotes from Leo&amp;#8217;s Users&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external"
                href="http://sourceforge.net/project/showfiles.php?group_id=3458&amp;amp;package_id=29106"&gt;
                Download Leo&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://groups.google.com/group/leo-editor"&gt;
                leo-editor: Google Groups&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://launchpad.net/leo-editor"&gt;
                leo-editor: Launchpad&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://leo.zwiki.org"&gt;
                Leo&amp;#8217;s Wiki&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://www.mind-mapping.org/"&gt;
                Mind Mapping&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="leoLinks.html"&gt;
                More links...&lt;/a&gt;&lt;br&gt;

              &lt;!-- &lt;a class="reference external"  href="install.html"&gt;Installing Leo&lt;/a&gt;&lt;br&gt;--&gt; 
              &lt;!-- &lt;a class="reference external"  href="intro.html"&gt;Beginners Guide&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!-- &lt;a class="reference external"  href="leo_toc.html"&gt;Users Guide&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!-- &lt;a class="reference external"  href="FAQ.html"&gt;FAQ&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!--Leo&amp;#8217;s &lt;a class="reference external" href="http://www.greygreen.org/leo/"&gt;Daily snapshots&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!-- 
              &lt;h5&gt;Edward K. Ream&lt;/h5&gt;
              &lt;a class="reference external" href="ekr.html"&gt;Home&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="mailto:edreamleo@gmail.com"&gt;Contact&lt;/a&gt;&lt;br&gt;
              --&gt; 
              &lt;!--@-&lt;&lt; sidebar contents &gt;&gt;--&gt;
          &lt;!-- &lt; &lt; sidebar links &gt; &gt; --&gt;
          &lt;!-- &lt; &lt; searchbox &gt; &gt; --&gt;
          &lt;/div&gt;
      &lt;/div&gt;
      &lt;!--@-&lt;&lt; sidebar &gt;&gt;--&gt;
      &lt;div class="clearer"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;!--@+&lt;&lt; div bottom nav &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4277: ** &lt;&lt; div bottom nav &gt;&gt;--&gt;
    &lt;div class="related"&gt;
      &lt;h3&gt;Navigation&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li class="right" style="margin-right: 10px"&gt;
          &lt;a href="genindex.html" title="General Index"
             &gt;index&lt;/a&gt;&lt;/li&gt;
        &lt;li class="right" &gt;
          &lt;a href="leo_toc.html" title="Leo&amp;#8217;s Users Guide"
             &gt;contents&lt;/a&gt; |&lt;/li&gt;
        &lt;!--
        &lt;li class="right" &gt;
          &lt;a href="commands.html" title="Chapter 5: Using Leo&amp;#8217;s Commands"
             &gt;previous&lt;/a&gt; |&lt;/li&gt;
        --&gt;
        &lt;li&gt;&lt;a href="leo_toc.html"&gt;Leo v4.7-final documentation&lt;/a&gt; &amp;raquo;&lt;/li&gt; 
      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--@-&lt;&lt; div bottom nav &gt;&gt;--&gt;
    &lt;!--@+&lt;&lt; div footer &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4278: ** &lt;&lt; div footer &gt;&gt;--&gt;
    &lt;div class="footer"&gt;
      &amp;copy; Copyright 2010, Edward K. Ream.
      Last updated on Aug 08, 2010.
      Created using &lt;a href="http://sphinx.pocoo.org/"&gt;Sphinx&lt;/a&gt; 0.6.3.
    &lt;/div&gt;
    &lt;!--@-&lt;&lt; div footer &gt;&gt;--&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;!--@-leo--&gt;
</t>
<t tx="ekr.20100824124015.2195" lineYOffset="4b032e" icons="5d7100287d71012858020000006f6e71025805000000746e6f64657103580500000077686572657104580e0000006265666f7265486561646c696e6571055807000000796f666673657471064b00580400000066696c6571075837000000433a5c6c656f2e7265706f5c7472756e6b5c6c656f5c49636f6e735c54616e676f5c31367831365c616374696f6e735c6164642e706e67710858040000007870616471094b01580400000074797065710a68075807000000786f6666736574710b4b02580700000072656c50617468710c581b00000054616e676f5c31367831365c616374696f6e735c6164642e706e67710d757d710e2858020000006f6e710f6803580500000077686572657110580e0000006265666f7265486561646c696e6571115807000000796f666673657471124b00580400000066696c657113583a000000433a5c6c656f2e7265706f5c7472756e6b5c6c656f5c49636f6e735c54616e676f5c31367831365c616374696f6e735c626f74746f6d2e706e67711458040000007870616471154b01580400000074797065711668135807000000786f666673657471174b02580700000072656c506174687118581e00000054616e676f5c31367831365c616374696f6e735c626f74746f6d2e706e67711975652e">for p in c.allNodes_iter():
    v = p.v
    icons = v.u and v.u.get('icons')
    if icons:
        for d in icons:
            fn = d.get('file')
            icon = g.app.gui.getIconImage(fn)
            print('v %s icon %s %s' % (id(v),id(icon),fn))
print('done')
</t>
</tnodes>
</leo_file>
