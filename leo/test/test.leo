<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="53" left="430" height="925" width="821"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070416075121" str_leo_pos="5"><vh>Startup</vh>
<v t="ekr.20070529172620"><vh>@chapters</vh>
<v t="ekr.20090605083941.1804"><vh>@chapter foo</vh>
<v t="ekr.20090605083941.1805"><vh>foo node 1</vh></v>
</v>
<v t="ekr.20070529173219"><vh>@chapter abc</vh>
<v t="ekr.20070529173219.1"><vh>abc node 1</vh></v>
<v t="ekr.20071206070207"><vh>cross-chapter-clone-test</vh></v>
</v>
<v t="ekr.20070603190944"><vh>@chapter xyz</vh>
<v t="ekr.20070603190944.1"><vh>xyz node 1</vh></v>
<v t="ekr.20071206070207"></v>
</v>
</v>
<v t="ekr.20070224123943"><vh>@settings</vh>
<v t="ekr.20080922164255.1"><vh>@string test = c:\leo.repo\trunk\leo\test</vh></v>
<v t="ekr.20090629105832.1790"><vh>@@bool big_outline_pane = True</vh></v>
<v t="ekr.20080412082246.1"><vh>@bool fixedWindow = False</vh></v>
<v t="ekr.20070604100125"><vh>@bool use_chapter_tabs = True</vh></v>
<v t="ekr.20070503085527"><vh>@bool use_chapters = True</vh></v>
<v t="ekr.20071025193940"><vh>@enabled-plugins</vh></v>
<v t="ekr.20080529111617.1"><vh>plugins</vh>
<v t="ekr.20070723091227"><vh>http plugin</vh>
<v t="ekr.20070723091227.1"><vh>@bool http_active = True</vh></v>
<v t="ekr.20070723091227.2"><vh>@int</vh>
<v t="ekr.20090316115500.1"><vh>port = 8080</vh></v>
</v>
<v t="ekr.20070723091227.3"><vh>@string rst_http_attributename = 'rst_http_attribute'</vh></v>
</v>
<v t="ekr.20080529111617.2"><vh>cleo</vh>
<v t="ekr.20080529111617.3"><vh>@color cleo_color_prog_green =</vh></v>
<v t="ekr.20080529111617.4"><vh>@color cleo_color_prog_red =</vh></v>
<v t="ekr.20080529111617.5"><vh>@data cleo_color_file_node_list</vh></v>
<v t="ekr.20080529111617.6"><vh>@int cleo_prog_width = 18</vh></v>
<v t="ekr.20080529111617.7"><vh>@float cleo_time_init = 1.0</vh></v>
<v t="ekr.20080529111617.8"><vh>@int cleo_prog_scale = 1</vh></v>
<v t="ekr.20080529111617.9"><vh>@float cleo_prog_extra = 4</vh></v>
<v t="ekr.20080529111617.10"><vh>@string cleo_time_name = 'days'</vh></v>
</v>
</v>
<v t="ekr.20080604104453.5"><vh>@strings [command,insert, overwrite] top_level_unbound_key_action = insert</vh></v>
<v t="ekr.20080729153237.1"><vh>Gc settings</vh>
<v t="ekr.20080729153237.2"><vh>@bool trace_gc = False</vh></v>
<v t="ekr.20080729153237.3"><vh>@bool trace_gc_calls = False</vh></v>
<v t="ekr.20080729153237.4"><vh>@bool trace_gc_verbose = False</vh></v>
</v>
<v t="ekr.20080822153619.1"><vh>@string shadow_subdir = .leo/shadow</vh></v>
</v>
<v t="ekr.20041001211817"><vh>Buttons</vh>
<v t="ekr.20090521070342.1907"><vh>@button show-rst</vh></v>
<v t="ekr.20061030041450"><vh>Run Iron Python scripts</vh>
<v t="ekr.20061030041356"><vh>@url c:\prog\IronPython-1.0.1\Doc\IronPythonApiReference.chm</vh></v>
</v>
<v t="ekr.20070531102813"><vh>Disabled buttons</vh>
<v t="ekr.20060814111542"><vh>@@button add-e</vh></v>
<v t="ekr.20080813100905.1"><vh>@@button args-test @args = a,b,c</vh></v>
<v t="ekr.20060918083159"><vh>@@button Clear uAs</vh></v>
<v t="ekr.20071002150320"><vh>@@button create-canvas</vh></v>
<v t="ekr.20060809084033"><vh>@@button cvt to g.et</vh>
<v t="ekr.20060809104405"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20060809092023"><vh>test</vh>
<v t="ekr.20060809103738"><vh>test1</vh></v>
<v t="ekr.20060809103738.1"><vh>test2</vh></v>
</v>
<v t="ekr.20060809090508"><vh>replace</vh>
<v t="ekr.20060809091749.72"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="ekr.20060809091749.73"><vh>&lt;&lt; handle g.es &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070531104646"><vh>@@button da-comp</vh></v>
<v t="ekr.20070531103315"><vh>@@button da-expand</vh></v>
<v t="ekr.20081025105942.1"><vh>@@button dir</vh></v>
<v t="ekr.20070530072113"><vh>@@button hide-ch</vh></v>
<v t="ekr.20061030041200"><vh>@@button iron-py @key=Alt-5</vh></v>
<v t="ekr.20071025192258"><vh>@@button local-tests @key=Alt+4</vh></v>
<v t="ekr.20071006084354"><vh>@@button print tk line number</vh></v>
<v t="ekr.20080105115712"><vh>@@button pylint</vh>
<v t="ekr.20080115085447"><vh>harmless warnings, errors</vh></v>
<v t="ekr.20080105130903"><vh>warnings</vh></v>
<v t="ekr.20080105120559"><vh>&lt;&lt; define data &gt;&gt;</vh></v>
</v>
<v t="ekr.20070515073111"><vh>@@button sep</vh></v>
<v t="ekr.20060427103457"><vh>@@button settings.leo</vh></v>
<v t="ekr.20080310111916.1"><vh>@@button Translate "can not" to "can't"</vh></v>
<v t="ekr.20070115092430"><vh>@@button winpdb</vh></v>
<v t="ekr.20080815073750.1"><vh>@@button write-nosent-files</vh></v>
<v t="ekr.20071128122043"><vh>@@command create-shell-tab @key = Alt+5</vh></v>
<v t="ekr.20070604095313"><vh>Chapter buttons</vh>
<v t="ekr.20070530072113.1"><vh>@@button show-ch</vh></v>
<v t="ekr.20070603175054.1"><vh>@@button ch-main</vh></v>
<v t="ekr.20070603175054"><vh>@@button ch-abc</vh></v>
<v t="ekr.20070603190713.1"><vh>@@button ch-xyz</vh></v>
<v t="ekr.20070603190713"><vh>@@button ch-add-xyz</vh></v>
</v>
<v t="ekr.20060904110922"><vh>OPML buttons</vh>
<v t="ekr.20060904111037.1"><vh>@@button opml-write</vh></v>
<v t="ekr.20060904111037"><vh>@@button opml-read</vh></v>
</v>
</v>
<v t="ekr.20080915095329.1"><vh>@@button rst3</vh></v>
</v>
<v t="ekr.20070410063214"><vh>Commands</vh>
<v t="ekr.20060924180049"><vh>@@command clones-tab</vh>
<v t="ekr.20060924180049.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060924180049.2"><vh>init</vh></v>
<v t="ekr.20060924180049.3"><vh>getAllClones</vh></v>
<v t="ekr.20060924180049.4"><vh>displayClones</vh>
<v t="ekr.20060924180049.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060924180049.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20080214091706.2"><vh>@@command ekr-command</vh></v>
<v t="ekr.20080823154546.1"><vh>@@command parse-python @key = Alt-5</vh></v>
<v t="edward.20081127113749.2"><vh>@@command complete-previous</vh>
<v t="edward.20081127113749.3"><vh>WordCompleter</vh>
<v t="edward.20081127113749.4"><vh>complete_word</vh>
<v t="edward.20081127113749.5"><vh>&lt;&lt;backward search&gt;&gt;</vh>
<v t="edward.20081127113749.6"><vh>&lt;&lt;counter check&gt;&gt;</vh></v>
</v>
<v t="edward.20081127113749.7"><vh>&lt;&lt;forward search&gt;&gt;</vh>
<v t="edward.20081127113749.6"></v>
</v>
<v t="edward.20081127113749.8"><vh>&lt;&lt;clean up and exit&gt;&gt;</vh></v>
</v>
<v t="edward.20081127113749.9"><vh>acceptable_word</vh></v>
<v t="edward.20081127113749.10"><vh>undo_replacement</vh></v>
<v t="edward.20081127113749.11"><vh>redo_replacement</vh></v>
<v t="edward.20081127113749.12"><vh>exit</vh></v>
<v t="edward.20081127113749.13"><vh>run</vh></v>
<v t="edward.20081127113749.14"><vh>adjust</vh></v>
</v>
<v t="edward.20081127113749.15"><vh>getCurrentWord</vh></v>
</v>
<v t="edward.20081127113749.16"><vh>@@command complete-next</vh>
<v t="edward.20081127113749.3"></v>
<v t="edward.20081127113749.15"></v>
</v>
</v>
<v t="ekr.20071026102420.3"><vh>Scripts</vh>
<v t="ekr.20071129103842"><vh>create-at-auto-nodes</vh></v>
<v t="ekr.20070223164126"><vh>Recursive import script</vh>
<v t="ekr.20070223164126.1"><vh>importFiles</vh></v>
<v t="ekr.20070223164126.2"><vh>importDir</vh></v>
<v t="ekr.20070223164126.3"><vh>createLastChildOf</vh></v>
</v>
<v t="ekr.20070517070854"><vh>run script in nullGui</vh></v>
<v t="ekr.20070517071510"><vh>run script with leoBridge</vh></v>
<v t="ekr.20080206055658"><vh>Script to print font settings</vh></v>
<v t="ekr.20090428081009.1"><vh>patching auto-completion table</vh></v>
</v>
</v>
<v t="ekr.20071025193940" annotate="7d71002855087072696f7269747971015504393939397102550870726f67726573737103550071045509617263686574797065710568045502666771066804752e"></v>
<v t="ekr.20070517160058.1"><vh>Prototypes</vh>
<v t="ekr.20070929062147"><vh>Prototype of networkx graph tools</vh>
<v t="ekr.20070929122956"><vh>Data trees</vh>
<v t="ekr.20070929114617"><vh>@graph-target</vh></v>
<v t="ekr.20070929072043"><vh>@networkx</vh>
<v t="ekr.20070929072506.1"><vh>@nodes</vh></v>
<v t="ekr.20070929072506"><vh>@edges</vh></v>
</v>
<v t="ekr.20070929070257"><vh>@graph</vh>
<v t="ekr.20070929070257.1"><vh>@node child1</vh>
<v t="ekr.20070929070632"><vh>@link ('ekr', '20070929070257', 2): @node child2</vh></v>
</v>
<v t="ekr.20070929070257.2"><vh>@node child2</vh>
<v t="ekr.20070929070632.1"><vh>@link ('ekr', '20070929070257', 1): @node child1</vh></v>
</v>
</v>
<v t="ekr.20070928095102"><vh>root-node</vh>
<v t="ekr.20070928095102.1"><vh>child1</vh></v>
<v t="ekr.20070928095102.2"><vh>child2</vh></v>
</v>
</v>
<v t="ekr.20070929122956.1"><vh>buttons</vh>
<v t="ekr.20070929070426"><vh>@@button print link</vh></v>
<v t="ekr.20070927175908"><vh>@@button leo2graph</vh></v>
<v t="ekr.20070929062147.1"><vh>@@button at-graph2graph</vh></v>
<v t="ekr.20070929062147.2"><vh>@@button at-networkx2graph</vh>
<v t="ekr.20070929081505"><vh>error</vh></v>
<v t="ekr.20070929074830"><vh>parse</vh></v>
<v t="ekr.20070929072506.2"><vh>parseNodes</vh></v>
<v t="ekr.20070929074830.1"><vh>parseEdges</vh></v>
</v>
<v t="ekr.20070929082546"><vh>@@button at-networkx2at-graph</vh>
<v t="ekr.20070929120541"><vh>createEdges</vh></v>
<v t="ekr.20070929120541.1"><vh>createNodes</vh></v>
<v t="ekr.20070929115302"><vh>createTree</vh></v>
<v t="ekr.20070929114410.2"><vh>error</vh></v>
<v t="ekr.20070929114410.3"><vh>parse</vh></v>
<v t="ekr.20070929114410.5"><vh>parseEdges</vh></v>
<v t="ekr.20070929114410.4"><vh>parseNodes</vh></v>
</v>
</v>
</v>
<v t="ekr.20070630142904"><vh>Prototype of pyrex</vh>
<v t="ekr.20070630142904.2"><vh>gcc build docs</vh></v>
<v t="ekr.20070630142904.3"><vh>pyrexc command-line options</vh></v>
<v t="ekr.20070630142904.4"><vh>@@file myModule.pyx</vh></v>
<v t="ekr.20070630142904.5"><vh>Make myModule.c</vh></v>
</v>
<v t="ekr.20071026102420.2"><vh>Screen capture with Wink</vh>
<v t="ekr.20070528111805"><vh>FrontWindowCapture.pyw</vh></v>
<v t="ekr.20070609085533"><vh>@@url c:\prog\wink\ChangeViewMenu.htm</vh></v>
</v>
<v t="ekr.20080503202744.3"><vh>Rope</vh></v>
<v t="ekr.20080531131542.1"><vh>mxTextTools proto</vh>
<v t="ekr.20080531141227.1"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
<v t="ekr.20080531131542.2"><vh>&lt;&lt; define scan4 tables &gt;&gt;</vh></v>
<v t="ekr.20080531131542.4"><vh>printItem</vh></v>
</v>
<v t="ekr.20080806145258.12"><vh>Prototype of Leo in Ajax</vh>
<v t="ekr.20080806145258.13"><vh>To do</vh></v>
<v t="ekr.20080806145258.14"><vh>@@button Leo2DHTML</vh>
<v t="ekr.20080806145258.15"><vh>&lt;&lt; about LeoToHTML &gt;&gt;</vh></v>
<v t="ekr.20080806145258.16"><vh>&lt;&lt; define dhtml stuff &gt;&gt;</vh></v>
<v t="ekr.20080806145258.17"><vh>escape</vh></v>
<v t="ekr.20080806145258.18"><vh>writeAll</vh></v>
<v t="ekr.20080806145258.19"><vh>writeBody</vh></v>
<v t="ekr.20080806145258.20"><vh>writeHead</vh></v>
<v t="ekr.20080806145258.21"><vh>writeContents</vh></v>
<v t="ekr.20080806145258.22"><vh>writePreamble</vh></v>
<v t="ekr.20080806145258.23"><vh>writePostamble</vh></v>
</v>
<v t="ekr.20080806145258.24"><vh>@@file server.py</vh></v>
<v t="ekr.20080806145258.25"><vh>@@file hello.html</vh></v>
<v t="ekr.20080806145258.26"><vh>@@file cgi-bin/edward.py</vh>
<v t="ekr.20080806145702.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20080806145258.27"><vh>&lt;&lt; define dhtml stuff &gt;&gt;</vh></v>
<v t="ekr.20080806145258.28"><vh>escape</vh></v>
<v t="ekr.20080806145258.29"><vh>print_all</vh></v>
<v t="ekr.20080806145258.30"><vh>print_body</vh></v>
<v t="ekr.20080806145258.31"><vh>print_head</vh></v>
<v t="ekr.20080806145258.32"><vh>print_leo_dot_js</vh></v>
<v t="ekr.20080806145258.33"><vh>print_tree</vh></v>
</v>
<v t="ekr.20080806145258.1"><vh>@@thin cgi-bin/leo.js</vh></v>
<v t="ekr.20080806145258.34"><vh>@@thin jqueryTest.html</vh></v>
</v>
<v t="ekr.20080811113441.2"><vh>Running body text as a windows script</vh>
<v t="ekr.20080807115344.1"><vh>Windows script</vh></v>
<v t="ekr.20080807114145.2"><vh>@@button run-windows-script</vh>
<v t="ekr.20080807115344.5"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20080807115344.2"><vh>class MySite</vh></v>
<v t="ekr.20080807115344.3"><vh>class Application</vh></v>
<v t="ekr.20080807115344.4"><vh>RunCode</vh></v>
</v>
</v>
<v t="ekr.20090507082535.1906"><vh>Get my email</vh></v>
<v t="ekr.20090620063706.1826"><vh>Prototype of rendering ccommands</vh>
<v t="ekr.20090619103402.1818"><vh>@@button render-as-html</vh></v>
<v t="ekr.20090619103402.1821"><vh>@@button render-as-text</vh></v>
</v>
</v>
<v t="ekr.20071105085941"><vh>Tests</vh>
<v t="ekr.20090309064612.1"><vh> Future features/bug fixes (do not delete)</vh>
<v t="ekr.20081216091605.2"><vh>@@auto under_indent.py</vh>
<v t="ekr.20090122211549.1"><vh>class test</vh>
<v t="ekr.20090122211549.2"><vh>spam</vh></v>
</v>
</v>
<v t="ekr.20080924081821.1"><vh>test of autoCompleter.getExternalCompletions</vh></v>
<v t="ekr.20080610144233.1"><vh>Wrap test</vh></v>
</v>
<v t="ekr.20090309064612.2"><vh>Example scripts</vh>
<v t="ekr.20080701130406.1"><vh>Run pylint on plugins</vh></v>
<v t="ekr.20080617170334.1"><vh>Determining key values</vh></v>
<v t="ekr.20080920101658.1"><vh>getInput</vh></v>
<v t="ekr.20080917063615.1"><vh>getSettingSource</vh></v>
<v t="ekr.20081205104320.1"><vh>run bash script</vh></v>
</v>
<v t="ekr.20080930114036.1"><vh>Icon stuff</vh>
<v t="ekr.20080930080501.1"><vh>Add icon row</vh></v>
<v t="ekr.20080930083052.1"><vh>hide icon rows</vh></v>
<v t="ekr.20080930083052.2"><vh>show icon rows</vh></v>
<v t="ekr.20080930085514.1"><vh>clear icon bar</vh></v>
</v>
<v t="ekr.20090205070715.1"><vh>print colorer stats</vh></v>
<v t="ekr.20090614142400.1806"><vh>syntax tests</vh></v>
<v t="ekr.20090309064612.3"><vh>Tests of new features</vh>
<v t="ekr.20090309064612.4"><vh>Decorator tests</vh>
<v t="ekr.20080628094340.1"><vh>Decorator test</vh></v>
<v t="edward.20081221145716.1"><vh>decorator test 2</vh></v>
</v>
<v t="ekr.20090201162523.1"><vh>Macro test</vh>
<v t="ekr.20090201192257.1"><vh>@@test macro ab</vh></v>
</v>
<v t="ekr.20090128131130.1"><vh>posList tests</vh></v>
<v t="ekr.20090128112453.1" key="550378797a71002e"><vh>Property tests</vh></v>
<v t="ekr.20090507082111.1904"><vh>test creation of gnx's</vh></v>
<v t="ekr.20090601093755.1802"><vh>Test of @g.command decorator</vh></v>
<v t="ekr.20080922164656.1"><vh>Tests of path expressions</vh>
<v t="ekr.20080921144924.1"><vh>Tests of g.os_path_finalize</vh></v>
<v t="ekr.20080922142953.1"><vh>test os_pathExpression</vh></v>
<v t="ekr.20080922164255.1"></v>
<v t="ekr.20080922164255.2"><vh>@@shadow {{c.config.getString('test')}}/eval-shadow-test.txt</vh></v>
<v t="ekr.20080923073240.2"><vh>@path {{c.config.getString('test')}}</vh>
<v t="ekr.20080923073240.1"><vh>@@thin eval-thin-test.txt</vh></v>
</v>
</v>
<v t="ekr.20080531080812.1"><vh>tracer tests</vh></v>
</v>
<v t="ekr.20081003094737.1"><vh>Unicode tests</vh>
<v t="ekr.20080701101740.1"><vh>locale tests</vh></v>
<v t="ekr.20080821111715.1"><vh>Standard print test (only works for Latin-1 and ascii)</vh></v>
<v t="ekr.20090525090210.1940"><vh>Unicode characters: La Peña</vh></v>
<v t="ekr.20090617083033.1814"><vh>Test of copy/paste of unicode</vh>
<v t="ekr.20090617083033.1813"><vh>Unicode characters: La Peña תּ</vh></v>
</v>
<v t="ekr.20090618102458.1816"><vh>Converting QString to unicode</vh></v>
</v>
<v t="ekr.20090620183227.1755" rst-import="7d710028550b756e6465726c696e65733271015501237102550b756e6465726c696e65733171036802752e"><vh>@@auto-rst round-trip-test.txt</vh>
<v t="ekr.20090620194509.1757"><vh>h1</vh>
<v t="ekr.20090620194509.1758"><vh>h2</vh></v>
</v>
</v>
<v t="ekr.20090623090418.1765"><vh>Previous syntax coloring bugs</vh>
<v t="ekr.20090623090418.1766"><vh>Bug 1</vh></v>
<v t="ekr.20090623090418.1767"><vh>Bug 2 (from mod_scripting)</vh></v>
<v t="ekr.20090623090418.1768"><vh>Bug 3 (from unitTest.py)</vh></v>
<v t="ekr.20090623095616.1769"><vh>New bug</vh></v>
<v t="ekr.20090623101016.1772"><vh>New bug 2</vh></v>
<v t="ekr.20090625082029.1775"><vh>strings</vh></v>
<v t="ekr.20090623120149.1773"><vh>@button print-sep</vh></v>
</v>
<v t="ekr.20090627063835.1783"><vh>@@auto line-number-test.py</vh>
<v t="ekr.20090627083001.1779"><vh>spam</vh></v>
<v t="ekr.20090627083001.1780"><vh>cheese</vh></v>
</v>
<v t="ekr.20090628095136.1786"><vh>@@thin check-derived-file.txt</vh></v>
<v t="ekr.20090628221657.1790"><vh>Large file</vh></v>
</v>
<v t="ekr.20090514103332.1929"><vh>Unit tests</vh>
<v t="ekr.20090514073218.1923"><vh>@button run test.leo tests @key = alt-7</vh></v>
<v t="ekr.20090218112656.1"><vh>@test self.assertEqual</vh></v>
<v t="ekr.20090514101216.1927"><vh>@test self.assertNotEqual</vh></v>
</v>
<v t="ekr.20090629193234.6122"><vh>docutils error test</vh>
<v t="ekr.20090629193234.1790"><vh>@rst rst-error-test.html</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="edward.20081127113749.2">wordsep = u'., -+\n\r[]{}&lt;&gt;=-+*&amp;%$#@!"\'?/\\|^()~`:;'
word_completer_key = 'back_word_completer'
@others
completer = g.app.config.get(c,word_completer_key,'WordCompleter')
if completer is None:
    completer = WordCompleter(p,c,back=True)
    g.app.config.set(c,word_completer_key,'WordCompleter',completer)
    completer.run()
else:
    completer.adjust(p, c.frame.body.getInsertPoint())
    completer.complete_word()
</t>
<t tx="edward.20081127113749.3">class WordCompleter:
    def __init__(self, p, c, back=True):
        self.p = p.copy()
        self.c = c
        self.back = back
        self.pos = -1
    @others
</t>
<t tx="edward.20081127113749.4">def complete_word(self):
    txt = self.chunk
    word = self.word
    try:
        if self.back:
            &lt;&lt;backward search&gt;&gt;
        else:
            &lt;&lt;forward search&gt;&gt;
        &lt;&lt;clean up and exit&gt;&gt;
    except:
        self.exit()
        g.es_exception()</t>
<t tx="edward.20081127113749.5">p = self.search_pos
start = -1
counter = 0
while p:
    &lt;&lt;counter check&gt;&gt;
    i = txt.rfind(word, 0, start)
    if i == -1:
        p.moveToThreadBack()
        if p:self.chunk = txt = p.bodyString()
        start = -1
    else:
        if self.acceptable_word(i, txt, word):
            self.chunk = txt[:i+len(word)-1]
            return
        start = i+len(word)-1</t>
<t tx="edward.20081127113749.6">counter+=1
if counter &gt; 10000:
    g.es_trace("counter max")
    break</t>
<t tx="edward.20081127113749.7">p = self.search_pos
start = 0
counter = 0
while p:
    &lt;&lt;counter check&gt;&gt;
    i = txt.find(word, start)
    if i == -1:
        p.moveToThreadNext()
        if p:self.chunk = txt = p.bodyString()
        start = 0
    else:
        if self.acceptable_word(i, txt, word):
            self.chunk = txt[i+1:]
            return
        start = i+1</t>
<t tx="edward.20081127113749.8">if len(self.tried) &gt; 1:
    # there was some tries so we need to restore
    self.c.setBodyString(self.p, self.before+self.word+self.after)
    self.c.frame.body.setInsertPoint(self.pos)
return self.exit()</t>
<t tx="edward.20081127113749.9">@ if found word for the first time then try it
@c
def acceptable_word(self, i, txt, word):
    if i == 0 or wordsep.find(txt[i-1]) != -1:
        j = i+len(word)
        while j &lt; len(txt) and wordsep.find(txt[j]) &lt; 0:
            j += 1
        nword = txt[i:j]
        if nword not in self.tried:
            self.tried[nword] = 1
            u = self.c.undoer
            bunch = u.createCommonBunch(p)
            bunch.oldBody = p.bodyString()
            bunch.insertPos = self.pos
            # Set the type &amp; helpers.
            bunch.kind = 'node'
            bunch.undoType = 'complete word'
            bunch.undoHelper = self.undo_replacement
            bunch.redoHelper = self.redo_replacement
            bunch.newBody = newBody = self.before+nword+self.after

            self.c.setBodyString(self.p, newBody)
            self.c.frame.body.setInsertPoint(self.pos)

            bunch.dirtyVnodeList = [p.v]
            bunch.newChanged = u.c.isChanged()
            bunch.newDirty = p.isDirty()
            bunch.newMarked = p.isMarked()

            u.pushBead(bunch)

            return True
    return False
</t>
<t tx="edward.20081127113749.10">def undo_replacement(self):
    u = self.c.undoer; c=self.c; p=u.p
    bunch = u.getBead(u.bead)
    c.setBodyString(p, bunch.oldBody)
    c.frame.body.setInsertPoint(bunch.insertPos)</t>
<t tx="edward.20081127113749.11">def redo_replacement(self):
    c = self.c; u=c.undoer; bunch=u.getBead(u.bead+1)
    c.setBodyString(bunch.p, bunch.newBody)
    c.frame.body.setInsertPoint(bunch.insertPos)</t>
<t tx="edward.20081127113749.12">def exit(self):
    #g.app.config.set(c,word_completer_key,'WordCompleter',None)
    #g.app.config.set(c,'next_word_completer','WordCompleter',None)
    self.pos = -1</t>
<t tx="edward.20081127113749.13">def run(self):
    self.adjust(self.p, c.frame.body.getInsertPoint())
    self.complete_word()
</t>
<t tx="edward.20081127113749.14">def adjust(self, p, pos):
    if p != self.p or pos != self.pos:
        self.p = p.copy()
        self.pos = pos
        bs = p.bodyString()
        word = getCurrentWord(bs, pos)
        self.word = word
        self.before = bs[:pos-len(word)]
        self.after = bs[pos:]
        self.search_pos = p.copy()
        if self.back:
            self.chunk = self.before
        else:
            self.chunk = self.after
        self.tried = {word:1}</t>
<t tx="edward.20081127113749.15">def getCurrentWord(s, pos):
    i = pos-1
    while i&gt;=0 and wordsep.find(s[i]) &lt; 0:
         i -= 1
    return s[i+1:pos]</t>
<t tx="edward.20081127113749.16">wordsep = u'., -+\n\r[]{}&lt;&gt;=-+*&amp;%$#@!"\'?/\\|^()~`:;'
word_completer_key = 'next_word_completer'
@others
completer = g.app.config.get(c,word_completer_key,'WordCompleter')
if completer is None:
    completer = WordCompleter(p, c, back=False)
    g.app.config.set(c, word_completer_key, 'WordCompleter', completer)
    completer.run()
else:
    completer.adjust(p, c.frame.body.getInsertPoint())
    completer.complete_word()

</t>
<t tx="edward.20081221145716.1">def debug(f,*args,**keys):
    if 1:
        def debugCallback(*args,**keys):
            print f.__name__,args,keys
            f(*args,**keys)
            print 'after',f.__name__
        return debugCallback
    else:
        print 'in debug'
        return f
@debug
def spam(a=5):
    g.trace(a,g.callers(4))

spam(3)
spam(a=4)
</t>
<t tx="ekr.20041001211817">import os

g.pr(os.path.exists(os.path.normpath("C:\\Progra~1\\Eclipse")))</t>
<t tx="ekr.20060427103457"># Open leoSettings.leo
c.openLeoSettings()</t>
<t tx="ekr.20060809084033">'''A script to convert calls to g.es to g.et, and raw strings s to g._(s)'''

__version__ = 0.2
&lt;&lt; version history &gt;&gt;

@others

trace = False # For debugging.
doReplace = True # True: actually replace the body text.

if not doReplace: g.es_print('-' * 40)
c.beginUpdate()
try:
    u = c.undoer
    undoType = 'Convert g.es'
    u.beforeChangeGroup (p,undoType)
    for p in c.currentPosition().self_and_subtree_iter():
        replace(p)
    u.afterChangeGroup(p,undoType,reportFlag=True)
finally:
    c.endUpdate()</t>
<t tx="ekr.20060809090508"># Based on leoImport.scanPythonText.
def replace(p):
    '''Replace g.es by g.et and strings s by g._(s)'''
    s = p.bodyString()
    if not s.strip(): return
    result = [] ;  i = 0 ; count = 0
    while i &lt; len(s):
        progress = j = i
        ch = s[i]
        if ch == '\n' or ch == '\r':
            i = g.skip_nl(s,i)
            result.append(s[j:i])
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
            result.append(s[j:i])
        elif ch == '"' or ch == "'":
            &lt;&lt; handle string &gt;&gt;
        elif g.is_c_id(ch):
            if g.match_word(s,i,'g.es'):
                &lt;&lt; handle g.es &gt;&gt;
            else:
                i = g.skip_c_id(s,i)
                result.append(s[j:i])
        else:
            i += 1
            result.append(s[j:i])
        assert(progress &lt; i)
    if count:
        result = ''.join(result)
        if doReplace:
            undoData = u.beforeChangeNodeContents(p)
            p.setBodyStringOrPane(result)
            p.v.t.setDirty()
            u.afterChangeNodeContents(p,'Change Body',undoData)
        else:
            g.trace('result...\n',result)</t>
<t tx="ekr.20060809091749.72">i = g.skip_python_string(s,i)
s2 = s[j:i].strip()
result.append('g._(%s)' % s2)
if trace: g.trace('string:',s2)
count += 1</t>
<t tx="ekr.20060809091749.73">i += 4 ; k1 = i
i = g.skip_ws(s,i)
found = False
if g.match(s,i,'('):
    k2 = i
    k3 = g.skip_parens(s,i)
    if g.match(s,k3,')'):
        # Only translate if there are exactly one string in the parens.
        s2 = s[k2+1:k3]
        if (
            s2 and s2.count(',') == 0 and
            (s2.count('"') == 2 or s2.count("'") == 2)
        ):
            i = k3
            if trace: g.trace('call g.es:',g.get_line(s,i))
            result.append('g.et')
            result.append(s[k1:i])
            count += 1 ; found = True
if not found:
    result.append(s[j:i])</t>
<t tx="ekr.20060809092023"></t>
<t tx="ekr.20060809103738">def test1():
    
    g.es('abc')
    g.es('abc',xyz)
    g.es(xyz)</t>
<t tx="ekr.20060809103738.1">def test2():

    x = 'abc' + 'xyz'
    y = abc</t>
<t tx="ekr.20060809104405">@nocolor
@
0.1 EKR: Initial version.
0.2 EKR: Support doReplace and made script fully undoable.</t>
<t tx="ekr.20060814111542"># Add an editor to the body pane.
c.frame.body.addEditor()</t>
<t tx="ekr.20060904110922"></t>
<t tx="ekr.20060904111037">if hasattr(c,'opmlCommands'):
    c.opmlCommands.readOpmlCommand()
else:
    g.es_print('opml plugin not loaded')</t>
<t tx="ekr.20060904111037.1">if hasattr(c,'opmlCommands'):
    c.opmlCommands.writeOpmlCommand()
else:
    g.es_print('opml plugin not loaded')</t>
<t tx="ekr.20060918083159">put = g.es_print

for p in c.allNodes_iter():

    if hasattr(p.v,"unknownAttributes"):
        put("deleting v.unknownAttributes:",
            p.headString(),
            g.listToString(p.v.unknownAttributes.keys()))
        delattr(p.v,"unknownAttributes")

    if hasattr(p.v.t,"unknownAttributes"):
        put("deleting t.unknownAttributes:",
            p.headString(),
            g.listToString(p.v.t.unknownAttributes.keys()))
        delattr(p.v.t,"unknownAttributes")
           
put('done') 
c.redraw()</t>
<t tx="ekr.20060924180049">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060924180049.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others</t>
<t tx="ekr.20060924180049.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")</t>
<t tx="ekr.20060924180049.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060924180049.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.currentPosition()
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.headString())
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060924180049.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().headString()
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)</t>
<t tx="ekr.20060924180049.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20061030041200">import os, sys

if 1: # Executes Iron Python in the console. (But not from the tutorials directory).
    path = r'c:\prog\IronPython-1.0.1\ipy.exe'
    args = ['-i']
        
    if 1: # Use present environment.
        os.spawnv(os.P_NOWAIT, path, args)
    else: # Use a pristine environment.
        os.spawnve(os.P_NOWAIT, path, args, os.environ)</t>
<t tx="ekr.20061030041356"></t>
<t tx="ekr.20061030041450"></t>
<t tx="ekr.20070115092430"># Invoke winpdb for general scripts **not** containing the predefined g, p or d constants.

# This is essentially the same as using the debug command.

import os,subprocess,sys

# Important: scriptFile2 must be different from scriptFile.
filename = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','scriptFile2'))
f = open(filename,'w') 
f.write(p.bodyString()) 
f.close() 
python = sys.executable
pythonDir = g.os_path_dirname(python) 
#winpdb = g.os_path_join(pythonDir,'Scripts','_winpdb.py') # For older versions of winpdb.
winpdb = g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py') # For version 1.1.2 and newer.
os.chdir(g.app.loadDir)
cmdline = '%s %s -t %s' % (python,winpdb,filename) 
subprocess.Popen(cmdline)
</t>
<t tx="ekr.20070223164126"># An example of running this script:
    
import os

@others

types = (".py",) #,".c",".html",".txt")

dir = r'C:\prog\Notabene'

c.beginUpdate()
try:
    importFiles(dir,types,recursive=True)
finally:
    c.endUpdate()

g.es("done",color="blue")
</t>
<t tx="ekr.20070223164126.1">def importFiles (dir,type=None,kind="@file",recursive=False):
    
    v = c.currentVnode()

    # Check the params.
    if kind != "@file" and kind != "@root":
        g.es("kind must be @file or @root: " + kind)
        return

    if not g.os_path_exists(dir):
        g.es("directory does not exist: " + dir)
        return
    
    c.beginUpdate()
    try:
        root = createLastChildOf(v,"imported files")
        try:
            importDir (dir,type,kind,recursive,root)
            root.contract()
        except:
            g.es_exception()
    finally:
        c.endUpdate()</t>
<t tx="ekr.20070223164126.2">def importDir (dir,types,kind,recursive,root):

    g.es("dir: " + dir,color="blue")
    
    try:
        files = os.listdir(dir)
        files2 = [] ; dirs =[]
        for f in files:
            path = g.os_path_join(dir,f)
            if g.os_path_isfile(path):
                name, ext = g.os_path_splitext(f)
                if not types or ext in types:
                    files2.append(path)
            elif recursive:
                dirs.append(path)
        if len(files2) &gt; 0 or len(dirs) &gt; 0:
            child = createLastChildOf(root,dir)
            c.selectVnode(child)
        if len(files2) &gt; 0:
            c.importCommands.importFilesCommand(files2,kind)
        if len(dirs) &gt; 0:
            dirs.sort()
            for dir in dirs:
                importDir(dir,types,kind,recursive,child)
    except:
        g.es("exception in importFiles script")
        g.es_exception()
</t>
<t tx="ekr.20070223164126.3">def createLastChildOf (v,headline):
    
    child = v.insertAsLastChild()
    child.initHeadString(headline)
    return child
</t>
<t tx="ekr.20070224123943"></t>
<t tx="ekr.20070410063214"></t>
<t tx="ekr.20070416075121"></t>
<t tx="ekr.20070503085527"></t>
<t tx="ekr.20070515073111">g.pr('=' * 50)</t>
<t tx="ekr.20070517070854">import leoGui
oldGui = g.app.gui
g.app.gui = leoGui.nullGui(guiName='testGui')
try:
    fileName = g.os_path_abspath(g.os_path_join(
        g.app.loadDir,'..','doc','LeoDocs.leo'))
    ok,frame = g.openWithFileName(fileName,old_c=c)
    if ok:
        c2 = frame.c
        for p in c2.allNodes_iter():
            g.pr('.'*p.level(),p.headString())
        g.app.closeLeoWindow(frame)
finally:
    g.app.gui = oldGui</t>
<t tx="ekr.20070517071510">import leoBridge

path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','doc','LeoDocs.leo'))

if 0: # This can not be run locally: leoBridge.controller starts a Tk event loop.

    controller = leoBridge.controller(gui='nullGui')
    g = controller.globals()
    c = controller.openLeoFile(path)
    n = 0
    for p in c.allNodes_iter():
        n += 1
    g.pr('%d nodes in %s' % (n,path))
    # g.app.closeLeoWindow(c.frame)</t>
<t tx="ekr.20070517160058.1"></t>
<t tx="ekr.20070528111805"># FrontWindowCapture.pyw
# Version 0.1
# Date    20070526
# Author  Roger Erens (roger AT erens-krekels.net)
"""
        Purpose:
        Capture the image of the front-most window into a fixed-name
        (_front_window), max-size (default MAX_WIDTH is 640 pixels), and
        fixed-format (PNG) file that can easily be used when creating
        documentation for an application on a wiki or in some HTML-docs.
        This script does _not_ copy the captured image to the clipboard (handy
        when creating MS Word or OpenOffice documents) since MS Windows already
        has ALT-PRTSCR to do so.

        Dependencies:
        Fairly recent versions of Python, wxPython, and PIL should be installed

        Start:
        Double click FrontWindowCapture.pyw; an icon appears in the Task Bar (lower right of
        the screen).

        Use:
        Bring a window to the front and then left-click on the
        icon in the Task Bar. A file named '_front_window.png' will be saved
        in the current directory.
        A pictures wider than MAXWIDTH is scaled down in order to make it easily
        used in wikis or HTML-documentation.
        Usually, human intelligence is needed to rename that file; this is also
        why this script does not copy the image to the clipboard.

        End:
        Close the application by right-clicking the icon in the Task Bar.

        Note:
        Make sure that your system is fast enough to find the frontmost
        window. That is, when a virusscanner is running or virtual memory is
        low, this script will choke. You can see what happens by enabling the
        print statements and running this script from a console (change the
        extension from .pyw to .py).
"""
import wx
import sys
import win32ui
import win32gui
import win32con
import time
from PIL import Image, ImageGrab

Image.init()

MAX_WIDTH = 640
BLINK_STATE = 0

class TaskBarApp(wx.Frame):
    def __init__(self, parent, id, title):
        wx.Frame.__init__(self, parent, -1, title, size = (1, 1),
            style=wx.FRAME_NO_TASKBAR| wx.NO_FULL_REPAINT_ON_RESIZE)
        self.tbicon = wx.TaskBarIcon()
        icon = wx.Icon('LeoApp16.ico', wx.BITMAP_TYPE_ICO)
        self.tbicon.SetIcon(icon, 'Click to capture the foremost window')
        self.tbicon.Bind(wx.EVT_TASKBAR_LEFT_UP, self.OnTaskBarLeftClick)
        self.tbicon.Bind(wx.EVT_TASKBAR_RIGHT_UP, self.OnTaskBarRightClick)
        self.Show(True)

    def OnTaskBarLeftClick(self, evt):

        self.FlashIcon(evt)

        def _MyCallback(hwnd, extra ):
            extra.append(hwnd)

        windows = []
        win32gui.EnumWindows(_MyCallback, windows)

        winList = []
        for i in windows:
            if win32gui.IsWindowVisible(i):
                winList.append(i)
                #g.pr(i)

        win32gui.SetForegroundWindow(winList[1])    # found by trial and error
                                                    # that I need the second
                                                    # window from the list
        time.sleep(0.1)  # give the previous command some time to finish

        fgwindow = win32ui.GetForegroundWindow()
        #g.pr("(C)lick!")

        bbox = fgwindow.GetWindowRect()
        img = ImageGrab.grab( bbox)
        width = bbox[2] - bbox[0]
        if width &gt; MAX_WIDTH:
            coeff = MAX_WIDTH * 1. / width
            height = bbox[3] - bbox[1]
            newHeight = int( coeff * height)
            #g.pr(width, height, "scaled down to", MAX_WIDTH, newHeight)
            img = img.resize((MAX_WIDTH,newHeight), Image.ANTIALIAS)
        img = img.convert("P", dither=Image.NONE,
                              palette=Image.ADAPTIVE, colors=256)
        img.save("_front_window.png", "PNG", optimize=1)
        #img.show() # show the image in an image viewer

        self.FlashIcon(evt)

    def OnTaskBarRightClick(self, evt):
        #g.pr("Auta..." # that's about it...)
        self.tbicon.Destroy()
        self.Close(True)
        wx.GetApp().ProcessIdle()

    def FlashIcon(self, evt):
        global BLINK_STATE
        if BLINK_STATE == 0:
            icon = wx.Icon('LeoApp16lick.ico', wx.BITMAP_TYPE_ICO)
            self.tbicon.SetIcon(icon, 'Window is being captured...')
            BLINK_STATE = 1
            return
        else:
            icon = wx.Icon('LeoApp16.ico', wx.BITMAP_TYPE_ICO)
            self.tbicon.SetIcon(icon, 'Click to capture the foremost window')
            BLINK_STATE = 0
            return

class MyApp(wx.App):
    def OnInit(self):
        frame = TaskBarApp(None, -1, ' ')
        frame.Center(wx.BOTH)
        frame.Show(False)
        return True

def main():
    app = MyApp(0)
    app.MainLoop()

if __name__ == '__main__':
    main()

""" CREDITS

    Thanks to
    Roger Upole:
    http://groups.google.com/group/comp.lang.python/
    browse_thread/thread/ff39ec79f7c3248a/
    e600c892772bf52a?lnk=gst&amp;q=screen+capture&amp;rnum=6#e600c892772bf52a
    for his time.sleep() Aha (This took me a year and a half to note!)

    Christian Wyglendowski, Werner Bruhin, and Xavier Morel for the
    http://wiki.wxpython.org/index.cgi/FlashingTaskbarIcon
    discussion

    'Rob aspn at msolutionsinc.com '
    http://mail.python.org/pipermail/python-win32/2003-June/001129.html
    for his suggestion to find out the foremost window

    and of course the usual suspects that created/maintain
    wxPython,
    PIL,
    pywin32,
    LEO,
    gvim,
    and Python itself.
"""</t>
<t tx="ekr.20070529172620"></t>
<t tx="ekr.20070529173219"></t>
<t tx="ekr.20070529173219.1"></t>
<t tx="ekr.20070530072113">c.chapterController.hideChapters()</t>
<t tx="ekr.20070530072113.1">c.chapterController.showChapters()</t>
<t tx="ekr.20070531102813"></t>
<t tx="ekr.20070531103315">c.abbrevCommands.dynamicExpansion(event=None)</t>
<t tx="ekr.20070531104646">c.abbrevCommands.dynamicCompletion()</t>
<t tx="ekr.20070603175054">cc = c.chapterController
cc.selectChapterByName('abc')</t>
<t tx="ekr.20070603175054.1">cc = c.chapterController
cc.selectChapterByName('main')</t>
<t tx="ekr.20070603190713">cc = c.chapterController
cc.createChapterByName('xyz')</t>
<t tx="ekr.20070603190713.1">cc = c.chapterController
cc.selectChapterByName('xyz')</t>
<t tx="ekr.20070603190944"></t>
<t tx="ekr.20070603190944.1"></t>
<t tx="ekr.20070604095313"></t>
<t tx="ekr.20070604100125"></t>
<t tx="ekr.20070609085533"></t>
<t tx="ekr.20070630142904"></t>
<t tx="ekr.20070630142904.2">@nocolor

To build your module using GCC is a three step process on Unix:

1. Use Pyrex to translate mymodule.pyx to mymodule.c::

    python pyrexc mymodule.pyx

mymodule.pyx is the name of the Pyrex module you are writing.

2. Compile mymodule.c to mymodule.o::

    gcc -c -fPIC -I/usr/include/python2.2/ mymodule.c

-c  Produces a .o file instead of an executable. 
-fPIC Produces position independent code, so we can dynamically link against it later. 
-I/usr/include/python2.2/ is the location of the Python 2.2 include file.
 The location of your Python include file may differ from /usr/include/python2.2/. 

3 Link the mymodule.o into a mymodule.so::
    
    gcc -shared mymodule.o -lxosd -o mymodule.so

-shared produces a shared-object file, instead of an executable. 
-lxosd links against a C-library, with the name of the library given as the argument. 
</t>
<t tx="ekr.20070630142904.3">@nocolor

The pyrexc command supports the following options:

  Short Long              Argument    Description
  ----- ----              --------    -----------
  -v    --version                     Display version number of pyrex compiler
  -l    --create-listing              Write error messages to a .lis file
  -I    --include-dir     &lt;directory&gt; Search for include files in named 
                                      directory (may be repeated)
  -o    --output-file     &lt;filename&gt;  Specify name of generated C file (only
                                      one source file allowed if this is used)

Anything else is taken as the name of a Pyrex source file and compiled
to a C source file. Multiple Pyrex source files can be specified
(unless -o is used), in which case each source file is treated as the
source of a distinct extension module and compiled separately to
produce its own C file.
</t>
<t tx="ekr.20070630142904.4">def spam(int i, char *s):
    if 1:
        g.pr(i,s)</t>
<t tx="ekr.20070630142904.5"># Use pyrexc to create myModule.c from myModule.pyx.

import os,sys
python = sys.executable
theFile = r'C:\prog\tigris-cvs\leo\test\myModule.pyx'
pyrexc = r'c:\prog\Pyrex-0.9.6.4\pyrexc.py'
os.system(r'%s %s %s' % (python,pyrexc,theFile))

# Use pyrex/Demos/setup.py to create module on Linux.</t>
<t tx="ekr.20070723091227">
        
        
        </t>
<t tx="ekr.20070723091227.1"></t>
<t tx="ekr.20070723091227.2"></t>
<t tx="ekr.20070723091227.3"></t>
<t tx="ekr.20070927175908">'''Convert a normal Leo tree to a networkx graph'''
import networkx as nx
import sys

x = nx.Graph()

def node_id(p):
    return '%s: %s' % (id(p.v.t),p.headString())

def addTree(p):
    x.add_node(node_id(p))
    for child in p.children_iter():
        addTree(child)
        x.add_edge(node_id(p),node_id(child))

addTree(p)

g.pr('nodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('edges...\n', g.listToString(x.edges(),sort=True))
g.pr('yaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')
</t>
<t tx="ekr.20070928095102">@ This is a plain Leo tree.

You can convert it to a networkx graph using the leo2graph button.
</t>
<t tx="ekr.20070928095102.1"></t>
<t tx="ekr.20070928095102.2"></t>
<t tx="ekr.20070929062147">@nocolor

The following scripts convert between Leo trees and NetworkX graphs.

- leo2graph:            convert a normal Leo tree to a NetworkX graph.
- at-graph2graph:       convert an @graph tree to a Networkx graph.
- at-networkx2graph:    convert an @networkx tree to a Networkx graph
- at-networkx2at-graph: create an @graph tree from an @networkx tree.

Not ready yet:

- tree2pict: convert a Leo @graph tree to a picture of the corresponding graph.

@color</t>
<t tx="ekr.20070929062147.1">'''Convert an @graph tree to a networkx graph.'''
import networkx as nx
import sys

x = nx.Graph()

def node_id(p):
    return '%s: %s' % (str(p.v.t.fileIndex),p.headString())

def addTree(p):
    tag = '@link'
    h = p.headString()
    if h.startswith('@graph'):
        for child in p.children_iter():
            addTree(child)
    elif h.startswith('@node'):
        x.add_node(node_id(p))
        for child in p.children_iter():
            h = child.headString()
            if h.startswith(tag):
                link = h[len(tag):].strip()
                if link: x.add_edge(node_id(p),link)
            elif child.headString().startswith('@node'):
                addTree(child)
                x.add_edge(node_id(p),node_id(child))

addTree(p)

g.pr('nodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('edges...\n', g.listToString(x.edges(),sort=True))
g.pr('yaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')</t>
<t tx="ekr.20070929062147.2">'''Convert an @networkx node to a networkx graph.'''
import networkx as nx
import sys

@others

x = nx.Graph()

edges,nodes = parse(p)

for z in nodes:
    x.add_node(z)

for z in edges:
    a,b = z
    x.add_edge(a,b)

g.pr('\nnodes...\n', g.listToString(x.nodes(),sort=True))
g.pr('\nedges...\n', g.listToString(x.edges(),sort=True))
g.pr('\nyaml...\n')
nx.write_yaml(x,sys.stdout) # 'graph.yaml')
</t>
<t tx="ekr.20070929070257">@ This is an @graph tree.

You can convert it to a networkx graph using the at-graph2graph button.</t>
<t tx="ekr.20070929070257.1"></t>
<t tx="ekr.20070929070257.2"></t>
<t tx="ekr.20070929070426">g.es('@link %s: %s' % (str(p.v.t.fileIndex),p.headString()))</t>
<t tx="ekr.20070929070632"></t>
<t tx="ekr.20070929070632.1"></t>
<t tx="ekr.20070929072043">@ This node defines a networkx graph using nodes and edges.

You can create an @graph tree from this node using the graph2at-graph button.
</t>
<t tx="ekr.20070929072506"># Each edge is represented as two lines.

# child1 --&gt; child2
('ekr', '20070929070257', 1): @node child1
('ekr', '20070929070257', 2): @node child2

# child2 --&gt; child1
('ekr', '20070929070257', 2): @node child2
('ekr', '20070929070257', 1): @node child1

</t>
<t tx="ekr.20070929072506.1"># Each node is on a separate line.

('ekr', '20070929070257', 1): @node child1
('ekr', '20070929070257', 2): @node child2
</t>
<t tx="ekr.20070929072506.2">def parseNodes (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(g.listToString(lines))
    return lines
</t>
<t tx="ekr.20070929074830">def parse (p):

    tag = '@networkx'
    if not p.headString().startswith(tag):
        p = g.findNodeAnywhere(c,tag)
        if not p.headString().startswith(tag):
            error('No %s node in the outline' % tag)
            return [],[]

    nodes = []
    for tag in ('@edges','@nodes'):
        node = g.findNodeInTree(c,p,tag)
        if node:
            nodes.append(node)
        else:
            error('No %s node in @networkx tree' % tag)
            return [],[]
    edgesNode,nodesNode = nodes
    edges = parseEdges(edgesNode)
    nodes = parseNodes(nodesNode)
    return edges,nodes
</t>
<t tx="ekr.20070929074830.1">def parseEdges (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(len(lines),lines)
    if (len(lines) % 2) == 0:
        i = 0 ; edges = []
        while i &lt; len(lines):
            data = lines[i],lines[i+1]
            edges.append(data)
            i += 2
        # g.trace(g.listToString(edges))
        return edges
    else:
        error('edges node must have even number of lines')
        return []

</t>
<t tx="ekr.20070929081505">def error (s):

    g.es_print(s,color='red')
</t>
<t tx="ekr.20070929082546">'''Convert an @networkx node to an @graph tree.
Create the tree as the child of the @graph-target node,
or the current position if no such node.'''

import networkx as nx
import sys

@others

g.pr('=' * 10)

p,edges,nodes = parse(p)

createTree(p,edges,nodes)
</t>
<t tx="ekr.20070929114410.2">def error (s):

    g.es_print(s,color='red')
</t>
<t tx="ekr.20070929114410.3">def parse (p):

    tag = '@graph-target'
    if not p.headString().startswith(tag):
        p = g.findNodeAnywhere(c,tag)
    if not (p and p.headString().startswith(tag)):
        p = c.currentPosition() # Use the presently selected node.

    nodes = [] ; tag = '@networkx'
    data = g.findNodeAnywhere(c,tag)
    if not data:
        error('No %s tree' % tag)
        return None,[],[]
    for tag in ('@edges','@nodes'):
        node = g.findNodeInTree(c,data,tag)
        if node:
            nodes.append(node)
        else:
            error('No %s node in @networkx tree' % tag)
            return None,[],[]
    edgesNode,nodesNode = nodes
    edges = parseEdges(edgesNode)
    nodes = parseNodes(nodesNode)
    return p,edges,nodes
</t>
<t tx="ekr.20070929114410.4">def parseNodes (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(g.listToString(lines))
    return lines
</t>
<t tx="ekr.20070929114410.5">def parseEdges (p):

    s = p.bodyString()
    lines = [str(z).strip() for z in g.splitLines(s) if z.strip() and not z.startswith('#')]
    # g.trace(len(lines),lines)
    if (len(lines) % 2) == 0:
        i = 0 ; edges = []
        while i &lt; len(lines):
            data = lines[i],lines[i+1]
            edges.append(data)
            i += 2
        # g.trace(g.listToString(edges))
        return edges
    else:
        error('edges node must have even number of lines')
        return []

</t>
<t tx="ekr.20070929114617">@ This will be the root node for the @graph tree produced by the at-networkx2at-graph button.</t>
<t tx="ekr.20070929115302">def createTree (parent,edges,nodes):

    if 0:
        g.trace('nodes...\n', g.listToString(nodes,sort=True))
        g.trace('edges...\n', g.listToString(edges,sort=True))

    c.beginUpdate()
    try:
        p = parent.insertAsLastChild()
        p.setHeadString('@graph')
        d = createNodes(p,nodes)
        createEdges(d,edges)
        c.selectPosition(p)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070929120541">def createEdges (d,edges):

    for edge in edges:
        a,b = edge
        g.trace('\n%s --&gt; %s' % (a,b))
        p = d.get(a)
        if p:
            p2 = p.insertAsLastChild()
            p2.setHeadString('@link %s' % (b))
        else:
            error('@node not found: %s' % (a))
</t>
<t tx="ekr.20070929120541.1">def createNodes (parent,nodes):

    d = {}

    for node in nodes:
        # g.trace(node)
        p = parent.insertAsLastChild()
        p.setHeadString('@node %s' % (node))
        d[node] = p.copy()

    return d
</t>
<t tx="ekr.20070929122956"></t>
<t tx="ekr.20070929122956.1"></t>
<t tx="ekr.20071002150320">log = c.frame.log
tag = 'my-canvas'

w = log.canvasDict.get(tag)
if not w:
    w = log.createCanvas(tag)
    w.configure(bg='yellow')

log.selectTab(tag)
</t>
<t tx="ekr.20071006084354">w = c.frame.body.bodyCtrl
s = w.getAllText()
ins = w.getInsertPoint()
row,col = g.convertPythonIndexToRowCol(s,ins)
g.pr('row',row,'col',col)</t>
<t tx="ekr.20071025192258">import leoTest
leoTest.doTests (c,all=False)</t>
<t tx="ekr.20071025193940"># Caution: you will have to disable cursesGui in an external editor
# if you enable the cursesGui plugin here

# Important: if you want to specify a gui plugin here,
# enable that plugin first.

# qtGui.py
# tkGui.py

plugins_menu.py
open_with.py
quicksearch.py
ipython.py
scrolledmessage.py
UNL.py
mod_scripting.py
# nodenavigator.py
# vim.py
# xemacs.py

# test of @bool warn_when_plugins_fail_to_load
# xyzzy.py 

# Other interesting plugins
# leo_to_html.py
# leoOPML.py
# nav_qt.py
# graphed.py

# Tk plugins...
# cleo.py
# color_markup.py # Does not work with threading colorizer.
# image.py
# nav_buttons.py
# rClick.py
# threading_colorizer.py
# toolbar.py
</t>
<t tx="ekr.20071026102420.2"></t>
<t tx="ekr.20071026102420.3"></t>
<t tx="ekr.20071105085941"></t>
<t tx="ekr.20071128122043">log = c.frame.log ; tag = 'Shell'
frame1 = log.frameDict.get(tag)
shellKind = 'text' # in ('plain','text','canvas')

if frame1:
    log.selectTab(tag)
elif shellKind == 'plain':
    log.selectTab (tag,createText=False)
    frame = log.frameDict.get(tag)
elif shellKind == 'text':
    log.selectTab (tag,createText=True)
    frame = log.textDict.get(tag)
elif shellKind == 'canvas':
    log.createCanvas(tag)
    log.selectTab(tag)
    frame = log.canvasDict.get(tag)
else:
    frame = None
    g.es('bad shellKind',shellKind)

if frame and not frame1:
    frame.configure(bg='white')
    g.pr('logFrame',log.frameDict.get(tag))
</t>
<t tx="ekr.20071129103842"># A script to create @auto nodes from all .py files in a directory.

import glob,os

reallyCreate = True
baseDir = r'c:\leo.repo\pythoscope\lib2to3\pgen2'
dirs = (r'',)
g.pr('-----')

for theDir in dirs:
    pattern = g.os_path_join(baseDir,theDir,'*.py')
    files = glob.glob(pattern)
    g.pr(pattern)
    # g.pr(g.listToString(files))
    for name in files:
        h = '@auto %s' % (name[len(baseDir) + 1:].strip())
        g.pr('creating',h)
        if reallyCreate:
            child = p.insertAsLastChild()
            child.initHeadString(h)</t>
<t tx="ekr.20071206070207"></t>
<t tx="ekr.20080105115712"># This hangs Leo while pylint is running.
import pylint.lint as lint
import sys

rcFile = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','pylint-leo-rc.txt'))
rcArg = '--rcfile=%s' % rcFile
&lt;&lt; define data &gt;&gt;

# We expect only one W104 error, in leoGlobals.py
g.pr('\n','=' * 40)
for name,s in data:
    name2 = g.os_path_abspath(g.os_path_join(g.app.loadDir,name))
    args = [name2,rcArg]
    if s.strip():
        args.append('--disable-msg=%s' % s)
    g.pr(name,s)
    lint.Run(args)
g.pr('\n' + 'End of pylint run')</t>
<t tx="ekr.20080105120559">data = (
    ('leoAtFile.py',''), 
    ('leoChapters.py',''),
    ('leoCommands.py',''), 
    ('leoEditCommands.py','E1101'),
    ('leoFileCommands.py',''), 
    ('leoFind.py',''),
    ('leoFrame.py',''),
    ('leoGlobals.py','E0602,E1101'),
    ('leoGui.py',''),
    ('leoImport.py',''),
    ('leoMenu.py',''),
    ('leoNodes.py',''),
    ('leoPlugins.py',''),
    ('leoTangle.py',''),
    ('leoUndo.py','W0102'),
    ('leoTkinterDialog.py',''),
    ('leoTkinterFind.py',''),
    ('leoTkinterGui.py',''),
    ('leoTkinterFrame.py','W0221'),
    ('leoTkinterKeys.py',''), 
    ('leoTkinterMenu.py',''), 
    ('leoTkinterTree.py',''),
)
</t>
<t tx="ekr.20080105130903">@nocolor
@
C0111 Missing docstring
C0301 Line too long
C0311 Bad indentation
C0321 More than one statement on a single line
C0322 Operator not preceded by a space
C0323 Operator not followed by a space
C0324 Comma not followed by a space

R0201 Method could be a function.
R0903 Too few public methods (0/1)

W0102 Dangerous default value [] as argument
W0104 Statement seems to have no effect
W0106 Unnecessary semicolon
W0107 Unnecessary pass statement
W0122 Use of the exec statement
W0141 Used builtin function 'map'
W0142 Used * or * magic*
W0201 Attribute defined outside __init__
W0212 Access to a protected member of a client class
W0231 __init__ method from base class is not called
W0232 Class has no __init__ method
W0401 Wildcard import (pychecker)
W0402 Uses of a deprecated module (like string)
W0404 Reimport &lt;module&gt;: let pychecker do this.
W0406 Module import itself
W0602 Using global for x but no assigment is done (leoEditCommands defines classList after all classes).
W0603 Using the global statement
W0612 Unused variable
W0613 Unused argument (sometimes used for debugging)
W0621 Redefining &lt;name&gt; from outer scope: especially __pychecker__
W0622 Redefining built-in
W0631 Using possibly undefined loop variable
W0702 No exception type specified
W0703 Catch "Exception"
W0704 Except doesn't do anything (Except: pass)
W1111 Assigning to a function call that only returns None</t>
<t tx="ekr.20080115085447">@nocolor
@

************* Module leoGlobals
W0104:3871: Statement seems to have no effect
</t>
<t tx="ekr.20080206055658">g.pr('settings...')
for z in ('body','button','headline','log','menu','outline'):
    for z2 in ('family','size','slant','weight',):
        setting = '%s_text_font_%s' % (z,z2)
        g.pr(setting,c.config.get(setting,z2))

g.pr('default sizes...')
for z in ('Body','Log','Menu','Tree'):
    setting = 'default%sFontSize' % z
    g.pr(setting,getattr(c.config,setting))

g.pr('actual fonts...')
for z in ('body','button','headline','log','menu','outline'):
    kind = ('family','size','slant','weight')
    arg0,arg1,arg2,arg3 = args = ['%s_text_font_%s' % (z,z2) for z2 in kind]
    setting = '%s_text_font' % (z)
    g.pr('%20s' % (setting),c.config.getFontFromParams(arg0,arg1,arg2,arg3,defaultSize=12))
</t>
<t tx="ekr.20080214091706.2">g.pr('hello from ekr')</t>
<t tx="ekr.20080310111916.1">def myTranslateString (s):

    i = s.lower().find('can not')
    if i == -1:
        return s
    else:
        return s[:i+1] + "an't" + s[i+7:]

g.translateString = myTranslateString

</t>
<t tx="ekr.20080412082246.1"></t>
<t tx="ekr.20080503202744.3">import rope.base.project
import rope.contrib.codeassist as codeassist
import leo.core.leoGlobals as g
import leo.core.leoCommands as leoCommands
c2 = leoCommands.Commands(frame=c.frame,fileName='xyz-file')

class leoFSCommands (object):
    def create_file(self,path):         g.trace(path)
    def create_folder(self,path):       g.trace(path)
    def move (self,path,new_location):  g.trace(path,new_location)
    def remove (self,path):             g.trace(path)
    def write (self,path,data):         g.trace(path,data)

path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','..'))
    # Make the trunk folder a project
project = rope.base.project.Project(path,fscommands=leoFSCommands)
s = p.bodyString() # Could simulate a write to allow @others.

g.pr('*' * 40)
for pattern in (
    # 'g.', # works.
    # 'g.trace(', # weird.
    # 'rope.base.', # works.
    'g.list', # works: gives g.listToString
    'c2.de', # works.
):
    i = s.find(pattern)
    if i &gt; -1:
        proposals = codeassist.code_assist(project,s,i+len(pattern))
        g.pr('-' * 20)
        g.pr('pattern:',pattern)
        g.pr(g.listToString(proposals))</t>
<t tx="ekr.20080529111617.1"></t>
<t tx="ekr.20080529111617.2"></t>
<t tx="ekr.20080529111617.3">The colour used instead of green in progress bars</t>
<t tx="ekr.20080529111617.4">The colour used instead of red in progress bars</t>
<t tx="ekr.20080529111617.5"># list of @file node types to color.
# Uncomment these to enable coloring for these kinds of nodes.
# @asis
# @file
# @auto
# @thin
@auto</t>
<t tx="ekr.20080529111617.6">The base width of progress bars, in pixels.</t>
<t tx="ekr.20080529111617.7">The default number of time units.</t>
<t tx="ekr.20080529111617.8">0: no progress bars
1: unscaled progress bars
2: scaled progress bars</t>
<t tx="ekr.20080529111617.9">pixels per time unit to add to width of scaled progress bars</t>
<t tx="ekr.20080529111617.10">The name of time unit (e.g. days, weeks, hours)</t>
<t tx="ekr.20080531080812.1">def eggs():
    g.trace()

def spam():
    g.trace()
    eggs()

t = g.startTracer()
spam()
t.stop()
</t>
<t tx="ekr.20080531131542.1">import mx.TextTools as tt

&lt;&lt; define scan4 tables &gt;&gt;
&lt;&lt; define s &gt;&gt;

@others

g.pr('*' * 60)
ok,taglist,nextindex = tt.tag(s,lineTable)
# g.pr(g.listToString(taglist))
for z in taglist:
    printItem(z,level=0)
g.pr('ok:',ok)
</t>
<t tx="ekr.20080531131542.2">from mx.TextTools import * # Required for tags.

ws_charset   = CharSet(' \t')
name_charset = CharSet(alpha)

gnxTable = (
    (None,Is,':',MatchFail),
    (None,AllNotIn,':',MatchFail),
    (None,Is,':',MatchFail,MatchOk),
)

sentinelNameTable = (
    (None,Is,'@',+1,+3),
    (None,Is,'+',+1,+2),
    (None,Is,'-',+1),
    (None,AllInCharSet,name_charset,MatchFail,MatchOk),
)

sentinelTable = (
    # Start of another line.
    # Skip ws.
    (None,AllInCharSet,ws_charset,+1),
    # Require sentinel comment.
    (None,Word,'#@',MatchFail),
    ('kind',Table,sentinelNameTable,MatchFail),
    ('gnx',Table,gnxTable,+1),
    # Everything else is the sentinel value
    ('extra',AllNotIn,'\n',+1),
    (None,Is,'\n',MatchOk,MatchOk),
)

normalLineTable = (
    (None,AllNotIn,'\n',+1),
    (None,Is,'\n',MatchOk,MatchOk),
)

lineTable = (
    ('sent',Table,sentinelTable,+1,+2),
    ('line',Table,normalLineTable,+1,+1),
    ('eof',EOF,Here,-2),
)</t>
<t tx="ekr.20080531131542.4">def printItem(aList,level):

    obj,lt_index,rt_index,subtag = aList
    g.pr('  '*level,obj,repr(s[lt_index:rt_index]))
    if subtag:
        for z in subtag:
            printItem(z,level+1)
</t>
<t tx="ekr.20080531141227.1">path = r'c:\leo.repo\trunk\leo\core\runLeo.py'
f = file(path)
s = f.read()
f.close()</t>
<t tx="ekr.20080604104453.5">@nocolor

This setting determines the initial binding for otherwise-unbound keystrokes
when no mode is in effect.  Note: the keyboard-quit command exits all modes.

The valid values are::

command:  Leo ignores the key (like Vim).
insert:  Leo inserts the key at the cursor (like Emacs)
overwrite: Leo replaces the character at the cursor.</t>
<t tx="ekr.20080610144233.1">aaaaaaaaaaaa bbbbbbbbbbbbbbbbbb cccccccccccccccc ddddddddddddddddddd eeeeeeeeeeeeeee ffffffffffffffffff ggggggggggggggggggggg hhhhhhhhhhhhhhhh iiiiiiiiiiiii jjjjjjjjjjjjjjjj kkkkkkkkkkkkkk llllllllllllll mmmmmmmmmmmmmmmmm nnnnnnnnnnnn ooooooooo</t>
<t tx="ekr.20080617170334.1">@first # -*- coding: utf-8 -*-

import Tkinter as Tk

top = Tk.Toplevel()
w = Tk.Text(top)
w.pack()

def key(event):
    if event.char: g.pr('state',event.state,'char', repr(event.char), repr(event.keysym))

def after():
    g.trace()
    w.event_generate('&lt;Key&gt;',keysym='a')
    w.event_generate('A')
    w.event_generate(g.toEncodedString('Á',encoding='utf8'))
    # w.event_generate('&lt;Key-Control_L&gt;')
    # w.event_generate('c')
    # w.event_generate('Shift-Control-a')

w.bind('&lt;Key&gt;',key)
w.focus_set()
w.update()
# top.after_idle(after)
top.mainloop()
</t>
<t tx="ekr.20080628094340.1">if 0:
    # Called when func is **defined**
    def leo_command(func):
        g.trace(func.__name__)
        return func
else:
    class leo_command:
        def __init__(self,func,c=c):
            self.c = c
            self.func = func
            self.name = func.__name__
            g.pr("registering",self.name)

        def __call__(__self,*__args,**__kw):
            g.pr("before", __self.name)
            try:
                return __self.func(*__args,**__kw)
            finally:
                g.pr("after ", __self.name)
                g.pr('c',c)
                c.outerUpdate()


@leo_command
def hello():
    g.pr("Hello, world!")

hello()
</t>
<t tx="ekr.20080701101740.1">import locale
aList = dir(locale)
# g.pr(g.listToString(aList))

g.pr(g.getpreferredencoding())
# import os
# g.pr(dir(os))
</t>
<t tx="ekr.20080701130406.1">import glob

aList = glob.glob(r'c:\leo.repo\trunk\leo\plugins\*.py')
for z in aList:
    name = g.shortFileName(z)
    if not name.startswith('_'):
        g.pr('echo .')
        g.pr('echo',name)
        g.pr('call pylint.bat core\%s' % name)</t>
<t tx="ekr.20080729153237.1"></t>
<t tx="ekr.20080729153237.2"># True: calls to the garbage collector.</t>
<t tx="ekr.20080729153237.3"># True (recommended): print a message when Leo calls gc.collect explicitly.</t>
<t tx="ekr.20080729153237.4"># True: verbose trace the garbage collector.</t>
<t tx="ekr.20080806145258.1"></t>
<t tx="ekr.20080806145258.12">@nocolor

Notes:
    
- button Leo2dHTML creates leo\test\x.htm, where x is the name of the .leo file
  containing the script. The file contains javascript that allows a browser to
  expand and contract headlines.  Leo2DHTML is *unrelated* to the other files.
    
- leo\test\server.py is a minimal Python server.  Invoke from a console with::
    
    python server.py

To use this server, type this url in a web browser: http://localhost:8080/
The server will print the contents of the directory from which it was invoked.
Choose hello.html to see the 'Hello World' test page.

- leo\test\hello.html is a test page.  It uses leo\test\cgi-bin\edward.py

- leo\test\cgi-bin\edward.py is the script called from hello.leo when the user
  hits the 'Submit Query button.
  This is recompiled (as needed) for every query, which makes testing it easier.
  
  **Important** edward.py returns its result by printing (in a special format):
  Thus, everything you print will be part of the returned form(!). You **can**
  print debug info: just make sure you don't mess up the special conventions:
  the best place to print debugging info is in print_all.

@color</t>
<t tx="ekr.20080806145258.13">@

edward.py:
    
How can we get the content of an input form?</t>
<t tx="ekr.20080806145258.14">@first # -*- coding: utf-8 -*-
@language python
@tabwidth -4

&lt;&lt; about LeoToHTML &gt;&gt;
import leo.core.leoGlobals as g
&lt;&lt; define dhtml stuff &gt;&gt;
@others

fileName = c.frame.shortFileName() # Get current outline file name
if fileName.endswith('.leo'): fileName = fileName[:-4] # Remove .leo suffix
path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test',fileName)) + '.htm'

# Write the file.
f=open(path, 'w')
writeAll(f)
f.close() 
g.es('wrote: %s' % (path),color="turquoise4") 
</t>
<t tx="ekr.20080806145258.15">@

LeoToHTML by Dan Rahmel, modified by EKR.

This @button script creates an .htm file containing the contents of the selected tree.
The file is called x.htm, where x is the name of the .leo file containing the script.
This file is written to the leo/test folder.

The script inserts javascript into the page so that nodes can be expanded and contracted.

The script presently works well.  This script may become the basis for a facebook app.

The generated html passes html-tidy: http://www.w3.org/People/Raggett/tidy/
</t>
<t tx="ekr.20080806145258.16">division = """
&lt;div STYLE="margin-left:3em;text-indent:0em;margin-top:0em; margin-bottom:0em;"&gt;
&lt;h3 onClick="expandcontent('sc%d')" style="cursor:hand; cursor:pointer; margin-top:0em; margin-bottom:0em"&gt;+ %s&lt;/h3&gt;
    &lt;div id="sc%d" class="switchcontent" style="margin-top:0em; margin-bottom:0em;"&gt;
"""

javascript  = """
&lt;script src="cgi-bin/leo.js" type="text/javascript"&gt;&lt;/script&gt;
"""

style = '''
&lt;STYLE type="text/css"&gt;
    BODY {font:x-medium 'Verdana'; margin-right:1.5em}
    PRE {margin:0px; display:inline}
&lt;/STYLE&gt;
'''
</t>
<t tx="ekr.20080806145258.17">def escape (s):

    return s.replace('&amp;','&amp;amp;').replace('&lt;','&amp;lt;').replace('&gt;','&amp;gt;')
</t>
<t tx="ekr.20080806145258.18">def writeAll(f):

    f.write('&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;')
    f.write('&lt;html&gt;')
    writeHead(f)
    writeBody(f)
    f.write("&lt;/html&gt;")
</t>
<t tx="ekr.20080806145258.19">def writeBody(f):

    f.write('&lt;body class="st" onload="format()"&gt;')
    writeContents(f)
    f.write("&lt;/body&gt;")
</t>
<t tx="ekr.20080806145258.20">def writeHead(f):

    f.write('&lt;head&gt;')
    f.write(style)
    f.write(javascript)
    f.write('&lt;title&gt;%s&lt;/title&gt;' % c.shortFileName())
    f.write('&lt;/head&gt;')
</t>
<t tx="ekr.20080806145258.21">def writeContents(f):

    div = "&lt;div class='c' STYLE='margin-left:4em;margin-top:0em; margin-bottom:0em;'&gt;\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n&lt;/div&gt;"
    end_div = "&lt;/div&gt;\n&lt;/div&gt;\n"
    n = 1 # The node number
    current = c.currentPosition()
    prev_level = current.level()
    open_divs = 0
    for p in current.self_and_subtree_iter():
        h = p.headString()
        while prev_level &gt;= p.level() and open_divs &gt; 0:
            f.write(end_div)
            prev_level -= 1
            open_divs -= 1
        body = p.bodyString().encode( "utf-8" )
        body = body.rstrip().rstrip("\n")
        f.write(division % (n,escape(h),n))
        open_divs += 1
        if body:
            f.write(div % escape(body))
        prev_level = p.level()
        n += 1

    # Close all divisions.
    while open_divs &gt; 0:
        f.write(end_div)
        open_divs -= 1
</t>
<t tx="ekr.20080806145258.22"># def writePreamble(f):

    # '''Write HTML header information.'''

    # header_start = '''\


# &lt;body class="st" onload="format()"&gt;
# '''

    # for s in (header_start,style,javascript,header_end):
        # # f.write(g.adjustTripleString(s,c.tab_width))
        # f.write(s)
</t>
<t tx="ekr.20080806145258.23"># def writePostamble (f):

    # pass

</t>
<t tx="ekr.20080806145258.24"># A minimal python server for testing.
# To access this server, type this url in a web browser: http://localhost:8080/
# The server will print the contents of the directory from which it was invoked.
# Choose hello.html to see the 'Hello World' test page.

import CGIHTTPServer
import SocketServer

port = 8080

Handler = CGIHTTPServer.CGIHTTPRequestHandler
s = SocketServer.TCPServer(("", port), Handler)

s.server_name = '127.0.0.1' # represents local host.
s.server_port = port

# import os ; print 'cwd', os.getcwd()

print "server.py: serving at port", port
s.serve_forever()
</t>
<t tx="ekr.20080806145258.25">@language html

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;/title&gt;

&lt;!-- Used by edward.old.py
&lt;script language="JavaScript" type="text/javascript"&gt;
   var openImg = new Image();
   openImg.src = "open.gif";
   var closedImg = new Image();
   closedImg.src = "closed.gif";

   function showNode(node) {
      var objBranch = 
         document.getElementById(node).style;
      if(objBranch.display=="block")
         objBranch.display="none";
      else
         objBranch.display="block";
   }

   function swapFolder(img) {
      objImg = document.getElementById(img);
      if(objImg.src.indexOf('closed.gif')&gt;-1)
         objImg.src = openImg.src;
      else
         objImg.src = closedImg.src;
   }
&lt;/script&gt;
--&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;form action="cgi-bin/edward.py" method="GET"&gt;
&lt;input type="submit" name="George"&gt;
&lt;/form&gt;

&lt;p&gt;This is the hello world test page.
The server in server.py should be running when using this page.

&lt;p&gt;The button (form) above should cause the server to send a "GET" request
to the edward.py script, which will respond with a new page.

&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="ekr.20080806145258.26">@first #! c:\python25\python.exe
@first # -*- coding: utf-8 -*-

'''This is the cgi script called from hello.html when the user hits the button.'''

### Print statements are used to return results (return the form).
### You *can* use print statement for tracing, but only in print_all.
# To do: use cgi.FieldStorage.

@language python
@tabwidth -4
&lt;&lt; imports &gt;&gt;
&lt;&lt; define dhtml stuff &gt;&gt;
@others

if 1: # Open the bridge.
    path = os.path.abspath(os.path.join(leoParentDir,'leo','test','test.leo')) # c does not exist!
    b = leoBridge.controller(gui='nullGui',loadPlugins=False,readSettings=False,verbose=False)
    g = b.globals()
    c = b.openLeoFile(path)
    p = c.rootPosition()
else:
    c = None

# import pdb ; pdb.Pdb() # Doesn't work.
print_all(c)</t>
<t tx="ekr.20080806145258.27">division = """
&lt;div STYLE="margin-left:3em;text-indent:0em;margin-top:0em; margin-bottom:0em;"&gt;
&lt;h3 onClick="expandcontent('sc%d')" style="cursor:hand; cursor:pointer; margin-top:0em; margin-bottom:0em"&gt;+ %s&lt;/h3&gt;
    &lt;div id="sc%d" class="switchcontent" style="margin-top:0em; margin-bottom:0em;"&gt;
"""

style = """
&lt;STYLE type="text/css"&gt;
    BODY {font:x-medium 'Verdana'; margin-right:1.5em}
    PRE {margin:0px; display:inline}
&lt;/STYLE&gt;
"""</t>
<t tx="ekr.20080806145258.28">def escape (s):

    return s.replace('&amp;','&amp;amp;').replace('&lt;','&amp;lt;').replace('&gt;','&amp;gt;')
</t>
<t tx="ekr.20080806145258.29">def print_all(c):

    # This line is required (with extra newline), but does not show on the page.
    print "Content-type:text/html\n"

    print '&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;'
    print '&lt;html&gt;'
    if c:
        # Print the page.
        print_head(c)
        print_body(c)
    else:
        # Print the debugging info.
        print '__file__',__file__
        print 'os.getcwd()',os.getcwd()

    print '&lt;/html&gt;'
</t>
<t tx="ekr.20080806145258.30">def print_body(c):

    print '&lt;body class="st" onload="format()"&gt;'

    if 0:
        # Debugging info.
        form = cgi.FieldStorage()
        print repr(form)
        # if form.has_key('name'):
            # print 'name',form['name'].value
        # else:
            # print 'no name'
    print_tree(c)
    print '&lt;/body&gt;'
</t>
<t tx="ekr.20080806145258.31">def print_head(c):

    print '&lt;head&gt;'

    if 1: # Copy the entire leo.js file into the page.
        print '&lt;script type="text/javascript"&gt;'
        print_leo_dot_js(c)
        print '&lt;/script&gt;'

    else: # Possible bug in the python server??
        # The Python says leo.js is not executable(!)
        print '&lt;script src="leo.js" type="text/javascript"&gt;&lt;/script&gt;'

    print '&lt;title&gt;%s&lt;/title&gt;' % (c.shortFileName())
    print '&lt;/head&gt;'
</t>
<t tx="ekr.20080806145258.32">def print_leo_dot_js(c):

    path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','cgi-bin','leo.js'))

    try:
        f = file(path)
    except IOError:
        print 'can not open',path
        return

    for line in f.readlines():
        print line,

    f.close()
</t>
<t tx="ekr.20080806145258.33">def print_tree(c):

    div = "&lt;div class='c' STYLE='margin-left:4em;margin-top:0em; margin-bottom:0em;'&gt;\n&lt;pre&gt;\n%s\n&lt;/pre&gt;\n&lt;/div&gt;"
    end_div = "&lt;/div&gt;\n&lt;/div&gt;\n"
    n = 1 # The node number
    prev_level = 0
    open_divs = 0
    for p in c.allNodes_iter():
        h = p.headString()
        while prev_level &gt;= p.level() and open_divs &gt; 0:
            print end_div
            prev_level -= 1
            open_divs -= 1
        body = p.bodyString().encode( "utf-8" )
        body = body.rstrip().rstrip("\n")
        print division % (n,escape(h),n)
        open_divs += 1
        if body: print div % escape(body)
        prev_level = p.level()
        n += 1

    # Close all divisions.
    while open_divs &gt; 0:
        print end_div
        open_divs -= 1
</t>
<t tx="ekr.20080806145258.34"></t>
<t tx="ekr.20080806145702.1">import os
import sys

# Add the *parent* of the leo directory to sys.path.
leoParentDir = os.path.abspath(os.path.join(os.path.dirname(__file__),'..','..','..'))

if leoParentDir not in sys.path:
    sys.path.append(leoParentDir)

import leo.core.leoBridge as leoBridge

import cgi
import cgitb ; cgitb.enable()
</t>
<t tx="ekr.20080807114145.2">@
A script button to run any body text as a Windows Script.
See: http://en.wikipedia.org/wiki/Windows_Script_Host

You need the win32 extensions and you must enable the script engine.
Adapted from Active State examples:ch21_active_scripting:ActiveApp.py
http://python.net/crew/mhammond/win32/
@c

&lt;&lt; imports &gt;&gt;

@others

RunCode("python",p.bodyString())
</t>
<t tx="ekr.20080807115344.1">Application.Echo("Hello from Python")
</t>
<t tx="ekr.20080807115344.2">class MySite(axsite.AXSite):
    # Our error handler will simply print to the console.
    def OnScriptError(self, activeScriptError):
        exc = activeScriptError.GetExceptionInfo()
        print "Exception:", exc[1]
        try:
            sourceText = activeScriptError.GetSourceLineText()
        except pythoncom.com_error:
            sourceText = None
        if sourceText is not None: 
            context, lineNo, charNo = activeScriptError.GetSourcePosition()
            print sourceText
            indent = " " * (charNo-1)
            print indent + "^"
        return winerror.S_OK
</t>
<t tx="ekr.20080807115344.3"># A named object for our namespace
# A normal Python COM object (minus registration info)
class Application:
    _public_methods_ = [ 'Echo' ]
    def Echo(self, *args):
        print string.join(map(str, args))

</t>
<t tx="ekr.20080807115344.4"># Create the site and the engine and runs the code.
def RunCode(engineName, code):

    app = win32com.server.util.wrap( Application() )

    # Create a dictionary holding our object model.
    model = {'Application' : app,}

    # Create the scripting site.
    site = MySite(model)
    # Create the engine and add the code.
    engine = site.AddEngine(engineName)
    engine.AddCode(code)

    # Run the code.
    engine.Start()
</t>
<t tx="ekr.20080807115344.5">import string
import sys
from win32com.axscript import axscript
from win32com.axscript.server import axsite
import pythoncom
import win32com.server.util</t>
<t tx="ekr.20080811113441.2"></t>
<t tx="ekr.20080813100905.1">import sys
print sys.argv</t>
<t tx="ekr.20080815073750.1">n = 0
for p in c.allNodes_iter():
    if p.isAtNoSentFileNode():
        c.atFileCommands.write(p,nosentinels=True)
        n += 1
g.es('done: %s files written' %(n))</t>
<t tx="ekr.20080821111715.1">@first # -*- coding: utf-8 -*-

# Important: see http://webpages.charter.net/edreamleo/FAQ.html#unicode-issues

import sys

print '=' * 40

e = sys.getdefaultencoding()
assert e.lower() == 'utf-8'
print 'encoding',e

table = (
    'La Peña',
    unicode('La Peña','utf-8'),
    u'La Peña',
    u'La Pe\xf1a',
    # u'AA \u0102 BB',
)

for s in table:
    print type(s)
    g.es_print('g.es_print',s)
    if type(s) != type(u'a'):
        s = unicode(s,e)
    print      'print     ',s
    print      'repr(s)   ',repr(s)
</t>
<t tx="ekr.20080822153619.1"></t>
<t tx="ekr.20080823154546.1">p2 = p.insertAfter()
p2.setHeadString('inserted node')
s = p.bodyString()

# Remove Leo directives.
directives = ['@'+z for z in g.globalDirectiveList]
def isDirective(s):
    for z in directives:
        if s.startswith(z):
            return True
    else: return False
aList = [z for z in g.splitLines(s) if not isDirective(z)]
s = ''.join(aList)
if not s.endswith('\n'): s = s + '\n'

c.importCommands.scanPythonText(s,p2.copy(),atAuto=True)
c.redraw_now()
g.pr('done')</t>
<t tx="ekr.20080915095329.1">import leo.core.leoPlugins as leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    controller = rst3.controllers.get(c)
    if controller:
        controller.processTopTree(p)
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True

# print 'done'
</t>
<t tx="ekr.20080917063615.1">aList = (
'aspellbindir',
'wholeword',
'Whole-Word',
'vimcmd',
'huh',
)

for name in aList:
    kind, val = c.config.getSettingSource(name)
    print '%-20s %-20s %s' % (name,repr(val),kind)
</t>
<t tx="ekr.20080920101658.1">def getInput (event=None):

    '''Evaluate a Python Expression entered in the minibuffer.'''

    stateName = 'get-input'
    k = c.k ; state = k.getState(stateName)

    if state == 0:
        k.setLabelBlue('Input: ',protect=True)
        k.getArg(event,stateName,1,getInput)
    else:
        k.clearState()
        g.es_print('input:',k.arg)

getInput()
</t>
<t tx="ekr.20080921144924.1">print(g.os_path_finalize(r'~/.leo/notebook.leo'))
print(g.os_path_finalize(g.os_path_join(g.app.loadDir,r'~/.leo/notebook.leo')))
print(g.os_path_finalize_join(g.app.loadDir,r'~/.leo/notebook.leo'))</t>
<t tx="ekr.20080922142953.1"># @string default_leo_file = ~/.leo/workbook.leo
path = "{{c.config.getString('default_leo_file')}}"
# print g.os_path_expandExpression(path,c=c)
print g.os_path_finalize(path,c=c)</t>
<t tx="ekr.20080922164255.1"></t>
<t tx="ekr.20080922164255.2"></t>
<t tx="ekr.20080922164656.1"></t>
<t tx="ekr.20080923073240.1">{{c.config.getString('test')}}/eval-test.txt
=
c:\leo.repo\trunk\leo\test\eval-test.txt</t>
<t tx="ekr.20080923073240.2"></t>
<t tx="ekr.20080924081821.1"># c.k.ab

# Test this code using the execute-script command.

s = p.bodyString()
lines = g.splitLines(s)
s = lines[0]

theObject,aList = c.k.autoCompleter.getExternalCompletions(s)

print '='*20
print 'theObject',theObject and theObject.__class__
print 'len(completions)',len(aList)
print g.listToString(aList, tag='completion list', sort=True, indent='')
</t>
<t tx="ekr.20080930080501.1">c.frame.iconBar.addRow()
c.frame.addIconButton(text="New")</t>
<t tx="ekr.20080930083052.1">c.frame.hideIconBar()</t>
<t tx="ekr.20080930083052.2">c.frame.showIconBar()</t>
<t tx="ekr.20080930085514.1">c.frame.clearIconBar()</t>
<t tx="ekr.20080930114036.1"></t>
<t tx="ekr.20081003094737.1"></t>
<t tx="ekr.20081025105942.1">import os
os.system("dir")</t>
<t tx="ekr.20081205104320.1"># import os
tag = '#!/bin/bash\n'
s = g.getScript(c,p,
    useSelectedText=False,
    forcePythonSentinels=False,
    useSentinels=True)
if not s.startswith(tag):
    s = tag + s
print s
os.system(s)
</t>
<t tx="ekr.20081216091605.2">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20090122211549.1">
class test:
    
    '''Class docstring
test line 2'''
    @others
</t>
<t tx="ekr.20090122211549.2">
def spam (self):

    '''Spam docstring.
\\-4spam line 2'''

    pass
</t>
<t tx="ekr.20090128112453.1"># print p.b
# p.b = p.b + '\n# new'
# p.h = p.h + 'z'

print c.p

if 0:
    print p.v.u
    print p.v.u.get('key')
    p.v.u['key'] = 'abc'
    print p.v.u.get('key')
    p.v.u = {'key':'xyz'}
    # p.v.u = 'abc'
    print p.v.u

if 0:
    print p.v.t.u
    print p.v.t.u.get('t-key')
    p.v.t.u['t-key'] = 'pdq'
    print p.v.t.u.get('t-key')
    # p.v.t.u = {'key':'pdq'}
    # # p.v.t.u = 'pdq'
    # print p.v.t.u</t>
<t tx="ekr.20090128131130.1">aList = g.posList(c) # Start with all positions
print len(aList)
aList2 = aList.select('plugin',regex=False,removeClones=True)
print aList2.dump(sort=True)
aList3 = aList2.select('http')
print aList3.dump()

# To see the docstring, enable auto-completion and type g.posList?
# g.posList</t>
<t tx="ekr.20090201162523.1"># define a macro: ctrl-f ab ctrl-r AB
pass</t>
<t tx="ekr.20090201192257.1">b = p.b
try:
    w = c.frame.body.bodyCtrl
    w.setInsertPoint(0)
    m = c.macroCommands
    fn = g.os_path_finalize_join(g.app.loadDir,'..','..','ekr-macros.txt')
    f = open(fn)
    m.loadMacros(f)
    macro = m.namedMacros.get('ab')
    assert macro
    m.executeMacro(macro)
finally:
    assert p.b =='ab' + b,p.b
    p.b = b
</t>
<t tx="ekr.20090205070715.1">#colorer = c.frame.body.colorizer.highlighter.colorer
g.es ('total characters: %s, keywords: %s, leo_keywords: %s' % (
    colorer.totalChars,
    colorer.totalKeywordsCalls,
    colorer.totalLeoKeywordsCalls))</t>
<t tx="ekr.20090218112656.1"># 'self' is now defined in @test and @suite nodes.
self.assertEqual(1,1)</t>
<t tx="ekr.20090309064612.1"></t>
<t tx="ekr.20090309064612.2"></t>
<t tx="ekr.20090309064612.3"></t>
<t tx="ekr.20090309064612.4"></t>
<t tx="ekr.20090316115500.1"></t>
<t tx="ekr.20090428081009.1">import PyQt4.QtCore as QtCore
import PyQt4.QtGui as QtGui
from PyQt4 import uic

table = (
    (['QtGui'],'object',QtGui),
    (['QtCore'],'object',QtCore),
)

c.k.autoCompleter.defineObjectDict(table)
print c.k.autoCompleter.objectDict.keys()

# print c.k.autoCompleter.objectDict.get('QtCore')</t>
<t tx="ekr.20090507082111.1904">print "---- inserting ----"
p2 = p.insertAsLastChild().copy()
p3 = p.insertAsLastChild().copy()

print [p2.gnx, p3.gnx]

children = p.children_iter()
print [p.gnx for p in children]

c.redraw()</t>
<t tx="ekr.20090507082535.1906">import email,getpass,imaplib,os

username = 'edreamleo@gmail.com'
passfile = os.path.expanduser('~/gmailpass.txt')
M = imaplib.IMAP4_SSL('imap.gmail.com',993)
try:
    f = open(passfile)
    password = f.read()
    M.login(username,password)
except IOError:
    g.es_print('file not found: %s' % (passfile),color='red')
    # M.login(username, getpass.getpass())

M.select()
typ, data = M.search(None, 'ALL')
for num in data[0].split():
    typ, data = M.fetch(num,'(RFC822)')
    s = data[0][1]
    m = email.message_from_string(s)
    # for z in m.keys(): print z
    payload = m.get_payload()
    p2 = p.insertAsLastChild()
    date,from_s,subject = m['date'],m['from'],m['subject']
    p2.setHeadString(subject)
    body = '@nocolor\n\nDate: %s\nFrom: %s\nSubject: %s\n\n%s' % (
        date,from_s,subject,payload)
    p2.setBodyString(body)
print 'done'
M.close()
M.logout()
c.redraw()</t>
<t tx="ekr.20090514073218.1923">import leo.core.leoTest as leoTest

if False:
    # Run tests locally.
    leoTest.doTests(c,all=True)
else:
    # Run tests externally.
    path = 'test.leo' # path is relative to leo\test directory
    leoTest.runUnitTestLeoFile(gui='nullGui',path=path,silent=False)
</t>
<t tx="ekr.20090514101216.1927"># 'self' is now defined in @test and @suite nodes.
self.assertNotEqual(1,2)</t>
<t tx="ekr.20090514103332.1929"></t>
<t tx="ekr.20090521070342.1907">g.app.gui.runScrolledMessageDialog(c=c,msg=u'rst:'+p.b)</t>
<t tx="ekr.20090525090210.1940">La Peña</t>
<t tx="ekr.20090601093755.1802">bookmarks = []

@g.command('bookmark')
def bookmark(event):
    c = event.get('c')
    p = c.currentPosition()
    bookmarks.append(p.gnx)
    g.es('bookmarked') </t>
<t tx="ekr.20090605083941.1804"></t>
<t tx="ekr.20090605083941.1805"></t>
<t tx="ekr.20090614142400.1806">@ first line.
line 1.
@c

# This is a test.

'''docstring
continued.
'''

if a: pass
    </t>
<t tx="ekr.20090617083033.1813">La Peña תּ
</t>
<t tx="ekr.20090617083033.1814"></t>
<t tx="ekr.20090618102458.1816">@first # -*- coding: utf-8 -*-

import PyQt4.QtCore as QtCore

s0 = unicode('La Peña','utf-8')
print s0
e = s0.encode('utf-8',"strict")
print e,repr(e)
s2 = QtCore.QString(s0)
print s2,repr(s2)
s3 = unicode(s2,'utf-8')
print s3
# s4 = QtCore.QString(e)
# print s4</t>
<t tx="ekr.20090619103402.1818"># Warning: this *replaces* the text.

bodyCtrl = c.frame.body.bodyCtrl
w = bodyCtrl.widget # A QTextEdit
s = bodyCtrl.getAllText()
w.setHtml(s)

try:
    # Lock out onTextChanged
    w.changingText = True
    w.setHtml(s)
finally:
    w.changingText = False</t>
<t tx="ekr.20090619103402.1821">bodyCtrl = c.frame.body.bodyCtrl
w = bodyCtrl.widget # A QTextEdit
s = bodyCtrl.getAllText()
w.setPlainText(s)</t>
<t tx="ekr.20090620063706.1826"></t>
<t tx="ekr.20090620183227.1755">@language rest
@tabwidth -4
@others

.. Warning: this node is ignored when writing this file.
.. However, @ @rst-options are recognized in this node.
</t>
<t tx="ekr.20090620194509.1757">h1 body 1. changed 3.

</t>
<t tx="ekr.20090620194509.1758">h2 body 1.

</t>
<t tx="ekr.20090623090418.1765"></t>
<t tx="ekr.20090623090418.1766">@ Here's an example node that gets colored wrong with trunk:

Qt gui--&gt;@thin qtGui.py--&gt;Syntax coloring--&gt;class jeditColorizer--&gt;&lt;&lt;
new jeditColorizer &gt;&gt;--&gt; Birth &amp; init--&gt;addLeoRules
@c


   table = (
       # Rules added at front are added in **reverse** order.
       ('@',  self.match_leo_keywords,True), # Called after all other
Leo matchers.
           # Debatable: Leo keywords override langauge keywords.
       ('@',  self.match_at_color,    True),
       ('@',  self.match_at_killcolor,True),

match_at_color is with comment color, while match_at_killcolor is ok (black).</t>
<t tx="ekr.20090623090418.1767">def handleAtScriptNode (self,p):
    g.es("executing script %s" % (name),color="blue")
    c.executeScript(arsg=args,p=p,useSelectedText=False,silent=True)</t>
<t tx="ekr.20090623090418.1768">@language c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
#include "eeprom.h"
#include &lt;rlydef.h&gt;
</t>
<t tx="ekr.20090623095616.1769">def match_regexp_helper (self,s,i,pattern):

    '''Return the length of the matching text if seq (a regular expression)
     matches the present position.'''
    ddd
</t>
<t tx="ekr.20090623101016.1772">def match_regexp_helper (self,s,i,pattern):

    '''Return present position.'''
    ddd
</t>
<t tx="ekr.20090623120149.1773">print ; print '=========' ; print</t>
<t tx="ekr.20090625082029.1775">'''abc'''

abc</t>
<t tx="ekr.20090627063835.1783">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20090627083001.1779"># Test of goto-global-line command

def spam(cheese):

    print cheese
</t>
<t tx="ekr.20090627083001.1780">def cheese():

    pass
</t>
<t tx="ekr.20090628095136.1786"># This is a test.</t>
<t tx="ekr.20090628221657.1790"># -*- coding: utf-8 -*-
#@+leo-ver=4-thin
#@+node:ekr.20041005105605.1:@thin leoAtFile.py
#@@first
    # Needed because of unicode characters in tests.

"""Classes to read and write @file nodes."""

#@@language python
#@@tabwidth -4
#@@pagewidth 80

#@&lt;&lt; imports &gt;&gt;
#@+node:ekr.20041005105605.2:&lt;&lt; imports &gt;&gt;
import leo.core.leoGlobals as g
import leo.core.leoTest as leoTest

if g.app and g.app.use_psyco:
    # print("enabled psyco classes",__file__)
    try: from psyco.classes import *
    except ImportError: pass

import leo.core.leoNodes as leoNodes
import os
# import string
import sys
import time
import hashlib
# import cPickle as pickle

#@-node:ekr.20041005105605.2:&lt;&lt; imports &gt;&gt;
#@nl

class atFile:

    """The class implementing the atFile subcommander."""

    #@    &lt;&lt; define class constants &gt;&gt;
    #@+node:ekr.20041005105605.5:&lt;&lt; define class constants &gt;&gt;
    # These constants must be global to this module because they are shared by several classes.

    # The kind of at_directives.
    noDirective     =  1 # not an at-directive.
    allDirective    =  2 # at-all (4.2)
    docDirective    =  3 # @doc.
    atDirective     =  4 # @&lt;space&gt; or @&lt;newline&gt;
    codeDirective   =  5 # @code
    cDirective      =  6 # @c&lt;space&gt; or @c&lt;newline&gt;
    othersDirective =  7 # at-others
    miscDirective   =  8 # All other directives
    rawDirective    =  9 # @raw
    endRawDirective = 10 # @end_raw

    # The kind of sentinel line.
    noSentinel   = 20 # Not a sentinel
    endAt        = 21 # @-at
    endBody      = 22 # @-body
    # not used   = 23
    endDoc       = 24 # @-doc
    endLeo       = 25 # @-leo
    endNode      = 26 # @-node
    endOthers    = 27 # @-others

    # not used     = 40
    startAt        = 41 # @+at
    startBody      = 42 # @+body
    startDoc       = 43 # @+doc
    startLeo       = 44 # @+leo
    startNode      = 45 # @+node
    startOthers    = 46 # @+others

    startComment   = 60 # @comment
    startDelims    = 61 # @delims
    startDirective = 62 # @@
    startRef       = 63 # @&lt; &lt; ... &gt; &gt;
    startVerbatim  = 64 # @verbatim
    startVerbatimAfterRef = 65 # @verbatimAfterRef (3.0 only)

    # New in 4.x. Paired
    endAll         = 70 # at-all (4.2)
    endMiddle      = 71 # at-middle (4.2)
    startAll       = 72 # at+all (4.2)
    startMiddle    = 73 # at+middle (4.2)

    # New in 4.x.  Unpaired.
    startAfterRef  = 80 # @afterref (4.0)
    startClone     = 81 # @clone (4.2)
    startNl        = 82 # @nl (4.0)
    startNonl      = 83 # @nonl (4.0)
    #@-node:ekr.20041005105605.5:&lt;&lt; define class constants &gt;&gt;
    #@nl
    #@    &lt;&lt; define sentinelDict &gt;&gt;
    #@+node:ekr.20041005105605.6:&lt;&lt; define sentinelDict &gt;&gt;
    sentinelDict = {

        # Unpaired sentinels: 3.x and 4.x.
        "@comment" : startComment,
        "@delims" :  startDelims,
        "@verbatim": startVerbatim,

        # Unpaired sentinels: 3.x only.
        "@verbatimAfterRef": startVerbatimAfterRef,

        # Unpaired sentinels: 4.x only.
        "@afterref" : startAfterRef,
        "@clone"    : startClone,
        "@nl"       : startNl,
        "@nonl"     : startNonl,

        # Paired sentinels: 3.x only.
        "@+body":   startBody,   "@-body":   endBody,

        # Paired sentinels: 3.x and 4.x.
        "@+all":    startAll,    "@-all":    endAll,
        "@+at":     startAt,     "@-at":     endAt,
        "@+doc":    startDoc,    "@-doc":    endDoc,
        "@+leo":    startLeo,    "@-leo":    endLeo,
        "@+middle": startMiddle, "@-middle": endMiddle,
        "@+node":   startNode,   "@-node":   endNode,
        "@+others": startOthers, "@-others": endOthers,
    }
    #@-node:ekr.20041005105605.6:&lt;&lt; define sentinelDict &gt;&gt;
    #@nl

    #@    @+others
    #@+node:ekr.20041005105605.7:at.Birth &amp; init
    #@+node:ekr.20041005105605.8:atFile.__init__ &amp; initIvars
    def __init__(self,c):

        # **Warning**: all these ivars must **also** be inited in initCommonIvars.
        self.c = c
        self.debug = False
        self.fileCommands = c.fileCommands
        self.testing = False # True: enable additional checks.
        self.errors = 0 # Make sure at.error() works even when not inited.

        # User options.
        self.checkPythonCodeOnWrite = c.config.getBool(
            'check-python-code-on-write',default=True)
        self.underindentEscapeString = c.config.getString(
            'underindent-escape-string') or '\\-'

        #@    &lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;
        #@+node:ekr.20041005105605.9:&lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;
        self.dispatch_dict = {
            # Plain line.
            self.noSentinel: self.readNormalLine,
            # Starting sentinels...
            self.startAll:    self.readStartAll,
            self.startAt:     self.readStartAt,
            self.startDoc:    self.readStartDoc,
            self.startLeo:    self.readStartLeo,
            self.startMiddle: self.readStartMiddle,
            self.startNode:   self.readStartNode,
            self.startOthers: self.readStartOthers,
            # Ending sentinels...
            self.endAll:    self.readEndAll,
            self.endAt:     self.readEndAt,
            self.endDoc:    self.readEndDoc,
            self.endLeo:    self.readEndLeo,
            self.endMiddle: self.readEndMiddle,
            self.endNode:   self.readEndNode,
            self.endOthers: self.readEndOthers,
            # Non-paired sentinels.
            self.startAfterRef:  self.readAfterRef,
            self.startClone:     self.readClone,
            self.startComment:   self.readComment,
            self.startDelims:    self.readDelims,
            self.startDirective: self.readDirective,
            self.startNl:        self.readNl,
            self.startNonl:      self.readNonl,
            self.startRef:       self.readRef,
            self.startVerbatim:  self.readVerbatim,
            # Ignored 3.x sentinels
            self.endBody:               self.ignoreOldSentinel,
            self.startBody:             self.ignoreOldSentinel,
            self.startVerbatimAfterRef: self.ignoreOldSentinel }
        #@-node:ekr.20041005105605.9:&lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;
        #@nl
    #@-node:ekr.20041005105605.8:atFile.__init__ &amp; initIvars
    #@+node:ekr.20041005105605.10:initCommonIvars
    def initCommonIvars (self):

        """Init ivars common to both reading and writing.

        The defaults set here may be changed later."""

        c = self.c

        if self.testing:
            # Save "permanent" ivars
            fileCommands = self.fileCommands
            dispatch_dict = self.dispatch_dict
            # Clear all ivars.
            g.clearAllIvars(self)
            # Restore permanent ivars
            self.testing = True
            self.c = c
            self.fileCommands = fileCommands
            self.dispatch_dict = dispatch_dict

        #@    &lt;&lt; set defaults for arguments and options &gt;&gt;
        #@+node:ekr.20041005105605.11:&lt;&lt; set defaults for arguments and options &gt;&gt;
        # These may be changed in initReadIvars or initWriteIvars.

        # Support of output_newline option.
        self.output_newline = g.getOutputNewline(c=c)

        # Set by scanHeader when reading and scanAllDirectives when writing.
        self.at_auto_encoding = c.config.default_at_auto_file_encoding
        self.encoding = c.config.default_derived_file_encoding
        self.endSentinelComment = ""
        self.startSentinelComment = ""

        # Set by scanAllDirectives when writing.
        self.default_directory = None
        self.page_width = None
        self.tab_width  = None
        self.startSentinelComment = ""
        self.endSentinelComment = ""
        self.language = None
        #@-node:ekr.20041005105605.11:&lt;&lt; set defaults for arguments and options &gt;&gt;
        #@nl
        #@    &lt;&lt; init common ivars &gt;&gt;
        #@+node:ekr.20041005105605.12:&lt;&lt; init common ivars &gt;&gt;
        # These may be set by initReadIvars or initWriteIvars.

        self.errors = 0
        self.inCode = True
        self.indent = 0  # The unit of indentation is spaces, not tabs.
        self.pending = []
        self.raw = False # True: in @raw mode
        self.root = None # The root of tree being read or written.
        self.root_seen = False # True: root vnode has been handled in this file.
        self.toString = False # True: sring-oriented read or write.
        self.writing_to_shadow_directory = False
        #@nonl
        #@-node:ekr.20041005105605.12:&lt;&lt; init common ivars &gt;&gt;
        #@nl
    #@-node:ekr.20041005105605.10:initCommonIvars
    #@+node:ekr.20041005105605.13:initReadIvars
    def initReadIvars(self,root,fileName,
        importFileName=None,
        perfectImportRoot=None,
        thinFile=False,
        atShadow=False,
    ):

        importing = importFileName is not None

        self.initCommonIvars()

        #@    &lt;&lt; init ivars for reading &gt;&gt;
        #@+node:ekr.20041005105605.14:&lt;&lt; init ivars for reading &gt;&gt;

        self.cloneSibCount = 0 # n &gt; 1: Make sure n cloned sibs exists at next @+node sentinel
        self.correctedLines = 0
        self.docOut = [] # The doc part being accumulated.
        self.done = False # True when @-leo seen.
        self.endSentinelStack = []
        self.importing = False
        self.importRootSeen = False
        self.indentStack = []
        self.inputFile = None
        self.lastLines = [] # The lines after @-leo
        self.lastThinNode = None # Used by createThinChild4.
        self.leadingWs = ""
        self.lineNumber = 0 # New in Leo 4.4.8.
        self.out = None
        self.outStack = []
        self.rootSeen = False
        self.tnodeList = []
        self.tnodeListIndex = 0
        self.t = None
        self.tStack = []
        self.thinNodeStack = [] # Used by createThinChild4.
        self.updateWarningGiven = False
        #@-node:ekr.20041005105605.14:&lt;&lt; init ivars for reading &gt;&gt;
        #@nl

        self.scanDefaultDirectory(root,importing=importing)
        if self.errors: return

        # Init state from arguments.
        self.perfectImportRoot = perfectImportRoot
        self.importing = importing
        self.root = root
        self.targetFileName = fileName
        self.thinFile = thinFile
        self.atShadow = atShadow
    #@-node:ekr.20041005105605.13:initReadIvars
    #@+node:ekr.20041005105605.15:initWriteIvars
    def initWriteIvars(self,root,targetFileName,
        atAuto=False,
        atEdit=False,
        atShadow=False,
        nosentinels=False,
        thinFile=False,
        scriptWrite=False,
        toString=False,
        forcePythonSentinels=None,
    ):

        self.initCommonIvars()
        #@    &lt;&lt; init ivars for writing &gt;&gt;
        #@+node:ekr.20041005105605.16:&lt;&lt; init ivars for writing &gt;&gt;&gt;
        #@+at
        # When tangling, we first write to a temporary output file. After 
        # tangling is
        # temporary file. Otherwise we delete the old target file and rename 
        # the temporary
        # file to be the target file.
        #@-at
        #@@c

        self.docKind = None
        self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
        self.fileChangedFlag = False # True: the file has actually been updated.
        self.atAuto = atAuto
        self.atEdit = atEdit
        self.atShadow = atShadow
        self.shortFileName = "" # short version of file name used for messages.
        self.thinFile = False
        self.force_newlines_in_at_nosent_bodies = self.c.config.getBool(
            'force_newlines_in_at_nosent_bodies')

        if toString:
            self.outputFile = g.fileLikeObject()
            self.stringOutput = ""
            self.targetFileName = self.outputFileName = "&lt;string-file&gt;"
        else:
            self.outputFile = None # The temporary output file.
            self.stringOutput = None

            if g.isPython3:
                self.targetFileName = self.outputFileName = ''
            else:
                self.targetFileName = self.outputFileName = unicode('')
        #@-node:ekr.20041005105605.16:&lt;&lt; init ivars for writing &gt;&gt;&gt;
        #@nl

        if forcePythonSentinels is None:
            forcePythonSentinels = scriptWrite

        if root:
            self.scanAllDirectives(root,
                scripting=scriptWrite,
                forcePythonSentinels=forcePythonSentinels)

        # g.trace(forcePythonSentinels,self.startSentinelComment,self.endSentinelComment)

        if forcePythonSentinels:
            # Force Python comment delims for g.getScript.
            self.startSentinelComment = "#"
            self.endSentinelComment = None

        # Init state from arguments.
        self.targetFileName = targetFileName
        self.sentinels = not nosentinels
        self.thinFile = thinFile
        self.toString = toString
        self.root = root

        # Ignore config settings for unit testing.
        if toString and g.app.unitTesting: self.output_newline = '\n'

        # Init all other ivars even if there is an error.
        if not self.errors and self.root:
            self.root.v.t.tnodeList = []
            self.root.v.t._p_changed = True
    #@-node:ekr.20041005105605.15:initWriteIvars
    #@-node:ekr.20041005105605.7:at.Birth &amp; init
    #@+node:ekr.20041005105605.17:at.Reading
    #@+node:ekr.20041005105605.18:Reading (top level)
    #@+at
    # 
    # All reading happens in the readOpenFile logic, so plugins should need to
    # override only this method.
    #@-at
    #@+node:ekr.20070919133659:checkDerivedFile (atFile)
    def checkDerivedFile (self, event=None):

        at = self ; c = at.c ; p = c.p

        if not p.isAtFileNode() and not p.isAtThinFileNode():
            return g.es('Please select an @thin or @file node',color='red')

        fn = p.anyAtFileNodeName()
        path = g.os_path_dirname(c.mFileName)
        fn = g.os_path_finalize_join(g.app.loadDir,path,fn)
        if not g.os_path_exists(fn):
            return g.es_print('file not found: %s' % (fn),color='red')

        try:
            s = open(fn,'r').read()
        except IOError:
            return g.es_print('can not open %s' % (fn),color='red')

        # Create a dummy, unconnected, vnode as the root.
        root_v = leoNodes.vnode(context=c)
        root = leoNodes.position(root_v)
        theFile = g.fileLikeObject(fromString=s)
        thinFile = at.scanHeaderForThin (theFile,fn)
        at.initReadIvars(root,fn,thinFile=thinFile)
        if at.errors: return
        at.openFileForReading(fn,fromString=s)
        if not at.inputFile: return
        at.readOpenFile(root,at.inputFile,fn)
        at.inputFile.close()
        if at.errors == 0:
            g.es_print('check-derived-file passed',color='blue')
    #@-node:ekr.20070919133659:checkDerivedFile (atFile)
    #@+node:ekr.20041005105605.19:openFileForReading (atFile) helper &amp; test
    def openFileForReading(self,fn,fromString=False):

        trace = False and not g.app.unitTesting
        verbose = False
        at = self ; c = at.c

        if fromString:
            if at.atShadow:
                return at.error('can not call at.read from string for @shadow files')
            at.inputFile = g.fileLikeObject(fromString=fromString)
        else:
            fn = at.fullPath(self.root) # Returns full path, including file name.
            at.setPathUa(self.root,fn) # Remember the full path to this node.
            if trace: g.trace(fn)

            if at.atShadow:
                x = at.c.shadowController
                # readOneAtShadowNode should already have checked these.
                shadow_fn     = x.shadowPathName(fn)
                shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
                if not shadow_exists:
                    g.trace('can not happen: no private file',shadow_fn,g.callers())
                    return at.error('can not happen: private file does not exist: %s' % (shadow_fn))
                # This method is the gateway to the essence of the shadow algorithm.
                x.updatePublicAndPrivateFiles(fn,shadow_fn)
                fn = shadow_fn

            try:
                # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
                if trace and verbose and at.atShadow: g.trace('opening %s file: %s' % (
                    g.choose(at.atShadow,'private','public'),fn))
                at.inputFile = open(fn,'rb')
                at.warnOnReadOnlyFile(fn)
            except IOError:
                at.error("can not open: '@file %s'" % (fn))
                at.inputFile = None
                fn = None

        return fn
    #@-node:ekr.20041005105605.19:openFileForReading (atFile) helper &amp; test
    #@+node:ekr.20041005105605.21:read (atFile)
    def read(self,root,importFileName=None,thinFile=False,fromString=None,atShadow=False):

        """Read any @thin, @file and @noref trees."""

        at = self ; c = at.c
        #@    &lt;&lt; set fileName &gt;&gt;
        #@+node:ekr.20041005105605.22:&lt;&lt; set fileName &gt;&gt;
        if fromString:
            fileName = "&lt;string-file&gt;"
        elif importFileName:
            fileName = importFileName
        elif root.isAnyAtFileNode():
            fileName = root.anyAtFileNodeName()
        else:
            fileName = None

        if not fileName:
            at.error("Missing file name.  Restoring @file tree from .leo file.")
            return False
        #@-node:ekr.20041005105605.22:&lt;&lt; set fileName &gt;&gt;
        #@nl

        at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile,atShadow=atShadow)
        if at.errors: return False
        fileName = at.openFileForReading(fileName,fromString=fromString)
        if at.inputFile:
            c.setFileTimeStamp(fileName)
        else:
            return False

        fileContent = open(fileName, "rb").read()
        cachefile = self._contentHashFile(root, fileContent)

        if cachefile in c.db:
            # This isn't so useful.
            # if not g.unitTesting: # g.es('uncache:',root.h)
            tree = c.db[cachefile]
            g.create_tree_at_vnode(c, root.v, tree)
            at.inputFile.close() # Bug fix.
            return

        if not g.unitTesting:
            g.es("reading:",root.h)

        root.clearVisitedInTree()
        at.scanAllDirectives(root,importing=at.importing,reading=True)
        at.readOpenFile(root,at.inputFile,fileName)
        at.inputFile.close()
        root.clearDirty() # May be set dirty below.
        if at.errors == 0:
            #@        &lt;&lt; advise user to delete all unvisited nodes &gt;&gt;
            #@+node:ekr.20071105164407:&lt;&lt; advise user to delete all unvisited nodes &gt;&gt;
            resurrected = 0
            for p in root.self_and_subtree_iter():

                if not p.v.t.isVisited():
                    g.es('resurrected node:',p.h,color='blue')
                    g.es('in file:',fileName,color='blue')
                    resurrected += 1

            if resurrected:
                g.es('you may want to delete ressurected nodes')

            #@-node:ekr.20071105164407:&lt;&lt; advise user to delete all unvisited nodes &gt;&gt;
            #@nl
        if at.errors == 0 and not at.importing:
            # Package this as a method for use by mod_labels plugin.
            self.copyAllTempBodyStringsToTnodes(root,thinFile)

        #@    &lt;&lt; delete all tempBodyStrings &gt;&gt;
        #@+node:ekr.20041005105605.25:&lt;&lt; delete all tempBodyStrings &gt;&gt;
        for t in c.all_unique_tnodes_iter():

            if hasattr(t,"tempBodyString"):
                delattr(t,"tempBodyString")
        #@-node:ekr.20041005105605.25:&lt;&lt; delete all tempBodyStrings &gt;&gt;
        #@nl

        # write out the cache version
        self.writeCachedTree(root, cachefile)

        return at.errors == 0
    #@-node:ekr.20041005105605.21:read (atFile)
    #@+node:ville.20090606131405.6362:writeCachedTree (atFile)
    def writeCachedTree(self, pos, cachefile):
        c = self.c

        if cachefile in c.db:
            # g.trace('Already cached')
            pass
        else:
            tree = g.tree_at_position(pos)
            c.db[cachefile] = tree

        return True
    #@-node:ville.20090606131405.6362:writeCachedTree (atFile)
    #@+node:ville.20090606150238.6351:_contentHashFile (atFile)
    def _contentHashFile(self, pos, content):
        c = self.c
        m = hashlib.md5()
        # note that we also consider the headline in hash, to separate @auto foo.py from @thin foo.py
        m.update(pos.h)
        m.update(content)
        return "fcache/" + m.hexdigest()




    #@-node:ville.20090606150238.6351:_contentHashFile (atFile)
    #@+node:ekr.20041005105605.26:readAll (atFile)
    def readAll(self,root,partialFlag=False):

        """Scan vnodes, looking for @file nodes to read."""

        use_tracer = False
        if use_tracer: tt = g.startTracer()

        at = self ; c = at.c
        if partialFlag:
            # Capture the current headline only if we aren't doing the initial read.
            c.endEditing() 
        anyRead = False
        p = root.copy()

        scanned_tnodes = set()

        if partialFlag: after = p.nodeAfterTree()    
        else: after = c.nullPosition()

        while p and p != after:
            gnx = p.gnx
            # g.trace(p.h)

            #skip clones
            if gnx in scanned_tnodes:
                p.moveToNodeAfterTree()
                continue
            scanned_tnodes.add(gnx)

            if not p.h.startswith('@'):
                p.moveToThreadNext()
            elif p.isAtIgnoreNode():
                p.moveToNodeAfterTree()
            elif p.isAtThinFileNode():
                anyRead = True
                at.read(p,thinFile=True)
                p.moveToNodeAfterTree()
            elif p.isAtAutoNode():
                fileName = p.atAutoNodeName()
                at.readOneAtAutoNode (fileName,p)
                p.moveToNodeAfterTree()
            elif p.isAtEditNode():
                fileName = p.atEditNodeName()
                at.readOneAtEditNode (fileName,p)
                p.moveToNodeAfterTree()
            elif p.isAtShadowFileNode():
                fileName = p.atShadowFileNodeName()
                at.readOneAtShadowNode (fileName,p)
                p.moveToNodeAfterTree()
            elif p.isAtFileNode() or p.isAtNorefFileNode():
                anyRead = True
                wasOrphan = p.isOrphan()
                ok = at.read(p)
                if wasOrphan and not partialFlag and not ok:
                    # Remind the user to fix the problem.
                    p.setDirty()
                    c.setChanged(True)
                p.moveToNodeAfterTree()
            else: p.moveToThreadNext()
        # Clear all orphan bits.
        for v in c.all_unique_vnodes_iter():
            v.clearOrphan()

        if partialFlag and not anyRead:
            g.es("no @file nodes in the selected tree")

        if use_tracer: tt.stop()
    #@-node:ekr.20041005105605.26:readAll (atFile)
    #@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
    def readOneAtAutoNode (self,fileName,p):

        at = self ; c = at.c ; ic = c.importCommands

        oldChanged = c.isChanged()
        at.scanDefaultDirectory(p,importing=True) # Set default_directory
        fileName = c.os_path_finalize_join(at.default_directory,fileName)

        # Delete all children.
        while p.hasChildren():
            p.firstChild().doDelete()

        try:
            fileContent = open(fileName, "rb").read()
            cachefile = self._contentHashFile(p, fileContent)
        except IOError:
            cachefile = None

        if cachefile is not None and cachefile in c.db:        
            # g.es('uncache:',p.h)
            tree = c.db[cachefile]
            g.create_tree_at_vnode(c, p.v, tree)
            return

        if not g.unitTesting:
            g.es("reading:",p.h)

        ic.createOutline(fileName,parent=p.copy(),atAuto=True)

        if ic.errors:
            g.es_print('errors inhibited read @auto',fileName,color='red')

        if ic.errors or not g.os_path_exists(fileName):
            # c.setBodyString(p,'')
            p.clearDirty()
            c.setChanged(oldChanged)
        else:
            self.writeCachedTree(p, cachefile)
            g.doHook('after-auto', p = p)  # call after-auto callbacks
    #@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
    #@+node:ekr.20090225080846.3:readOneAtEditNode (atFile)
    def readOneAtEditNode (self,fn,p):

        at = self ; c = at.c ; ic = c.importCommands
        oldChanged = c.isChanged()
        at.scanDefaultDirectory(p,importing=True) # Set default_directory
        fn = c.os_path_finalize_join(at.default_directory,fn)
        junk,ext = g.os_path_splitext(fn)

        if not g.unitTesting:
            g.es("reading @edit:", g.shortFileName(fn))

        # Read the file into s.
        try:
            s = open(fn).read()
        except IOError:
            g.es("can not open @edit ",fn,color='red')
            leoTest.fail()
            return

        # Delete all children.
        while p.hasChildren():
            p.firstChild().doDelete()

        changed = c.isChanged()
        head = ''
        ext = ext.lower()
        if ext in ('.html','.htm'):   head = '@language html\n'
        elif ext in ('.txt','.text'): head = '@nocolor\n'
        else:
            language = ic.languageForExtension(ext)
            if language and language != 'unknown_language':
                head = '@language %s\n' % language
            else:
                head = '@nocolor\n'

        p.b = head + s
        if not changed: c.setChanged(False)
        g.doHook('after-edit',p=p)
    #@-node:ekr.20090225080846.3:readOneAtEditNode (atFile)
    #@+node:ekr.20041005105605.27:readOpenFile
    def readOpenFile(self,root,theFile,fileName):

        '''Read an open derived file.

        Leo 4.5 and later can only read 4.x derived files.'''

        at = self ; ok = True

        firstLines,read_new,junk = at.scanHeader(theFile,fileName)

        if read_new:
            lastLines = at.scanText4(theFile,fileName,root)
        else:
            firstLines = [] ; lastLines = []
            ok = False
            if at.atShadow:
                g.trace(g.callers())
                g.trace('invalid @shadow private file',fileName)
                at.error('invalid @shadow private file',fileName)
            else:
                at.error('can not read 3.x derived file',fileName)
                g.es('you may upgrade these file using Leo 4.0 through 4.4.x')
                g.trace('root',root and root.h,fileName)

        if root:
            root.v.t.setVisited() # Disable warning about set nodes.

        #@    &lt;&lt; handle first and last lines &gt;&gt;
        #@+node:ekr.20041005105605.28:&lt;&lt; handle first and last lines &gt;&gt;
        try:
            body = root.v.t.tempBodyString
        except Exception:
            body = ""

        lines = body.split('\n')
        at.completeFirstDirectives(lines,firstLines)
        at.completeLastDirectives(lines,lastLines)
        s = '\n'.join(lines).replace('\r', '')
        root.v.t.tempBodyString = s
        #@-node:ekr.20041005105605.28:&lt;&lt; handle first and last lines &gt;&gt;
        #@nl

        return ok
    #@-node:ekr.20041005105605.27:readOpenFile
    #@+node:ekr.20050103163224:scanHeaderForThin
    def scanHeaderForThin (self,theFile,fileName):

        '''Scan the header of a derived file and return True if it is a thin file.

        N.B. We are not interested in @first lines, so any encoding will do.'''

        at = self

        # The encoding doesn't matter.  No error messages are given.
        at.encoding = at.c.config.default_derived_file_encoding

        junk,junk,isThin = at.scanHeader(theFile,fileName)

        return isThin
    #@-node:ekr.20050103163224:scanHeaderForThin
    #@+node:ekr.20080801071227.7:readAtShadowNodes (atFile)
    def readAtShadowNodes (self,p):

        '''Read all @shadow nodes in the p's tree.'''

        at = self ; after = p.nodeAfterTree()
        p = p.copy() # Don't change p in the caller.

        while p and p != after: # Don't use iterator.
            if p.isAtShadowFileNode():
                fileName = p.atShadowFileNodeName()
                at.readOneAtShadowNode (fileName,p)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    #@-node:ekr.20080801071227.7:readAtShadowNodes (atFile)
    #@+node:ekr.20080711093251.7:readOneAtShadowNode (atFile) &amp; helper
    def readOneAtShadowNode (self,fn,p):

        at = self ; c = at.c ; x = c.shadowController

        if not fn == p.atShadowFileNodeName():
            return at.error('can not happen: fn: %s != atShadowNodeName: %s' % (
                fn, p.atShadowFileNodeName()))

        at.scanDefaultDirectory(p,importing=True) # Sets at.default_directory

        fn = c.os_path_finalize_join(at.default_directory,fn)
        shadow_fn     = x.shadowPathName(fn)
        shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)

        if shadow_exists:
            # at.read (via at.openFileForReading) calls x.updatePublicAndPrivateFiles.
            at.read(p,thinFile=True,atShadow=True)
        else:
            if not g.unitTesting: g.es("reading:",p.h)
            ok = at.importAtShadowNode(fn,p)
            if ok:
                # Create the private file automatically.
                at.writeOneAtShadowNode(p,toString=False,force=True)
    #@+node:ekr.20080712080505.1:importAtShadowNode
    def importAtShadowNode (self,fn,p):

        at = self ; c = at.c  ; ic = c.importCommands
        oldChanged = c.isChanged()

        # Delete all the child nodes.
        while p.hasChildren():
            p.firstChild().doDelete()

        # Import the outline, exactly as @auto does.
        ic.createOutline(fn,parent=p.copy(),atAuto=True,atShadow=True)

        if ic.errors:
            g.es_print('errors inhibited read @shadow',fn,color='red')

        if ic.errors or not g.os_path_exists(fn):
            p.clearDirty()
            c.setChanged(oldChanged)

        # else: g.doHook('after-shadow', p = p)

        return ic.errors == 0
    #@-node:ekr.20080712080505.1:importAtShadowNode
    #@-node:ekr.20080711093251.7:readOneAtShadowNode (atFile) &amp; helper
    #@-node:ekr.20041005105605.18:Reading (top level)
    #@+node:ekr.20041005105605.71:Reading (4.x)
    #@+node:ekr.20041005105605.72:createThinChild4
    def createThinChild4 (self,gnxString,headline):

        """Find or create a new *vnode* whose parent (also a vnode) is at.lastThinNode.
        This is called only for @thin trees."""

        trace = False and not g.unitTesting
        verbose = False
        at = self ; c = at.c ; indices = g.app.nodeIndices
        last = at.lastThinNode ; lastIndex = last.t.fileIndex
        gnx = indices.scanGnx(gnxString,0)

        if trace and verbose: g.trace("last %s, gnx %s %s" % (
            last,gnxString,headline))

        parent = at.lastThinNode # A vnode.
        children = parent.t.children
        for child in children:
            if indices.areEqual(gnx,child.t.fileIndex):
                break
        else:
            child = None

        if at.cloneSibCount &gt; 1:
            n = at.cloneSibCount ; at.cloneSibCount = 0
            if child: clonedSibs,junk = at.scanForClonedSibs(parent,child)
            else: clonedSibs = 0
            copies = n - clonedSibs
            if trace: g.trace(copies,headline)
        else:
            if indices.areEqual(gnx,lastIndex):
                last.t.setVisited() # Supress warning/deletion of unvisited nodes.
                if trace:g.trace('found last',last)
                return last
            if child:
                child.t.setVisited() # Supress warning/deletion of unvisited nodes.
                if trace: g.trace('found child',child)
                return child
            copies = 1 # Create exactly one copy.

        while copies &gt; 0:
            copies -= 1
            # Create the tnode only if it does not already exist.
            tnodesDict = c.fileCommands.tnodesDict
            t = tnodesDict.get(gnxString)
            if t:
                if indices.areEqual(t.fileIndex,gnx):
                    pass
                else:
                    g.trace('can not happen: t.fileIndex: %s gnx: %s' % (t.fileIndex,gnx))
            else:
                if g.unified_nodes: t = leoNodes.vnode(context=c)
                else:               t = leoNodes.tnode()
                t._headString = headline
                t.fileIndex = gnx
                tnodesDict[gnxString] = t

            if g.unified_nodes:
                child = t
            else:
                child = leoNodes.vnode(context=c,t=t)

            if child not in t.vnodeList:
                t.vnodeList.append(child)
            child._linkAsNthChild(parent,parent.numberOfChildren())

        if trace and verbose: g.trace('new node: %s' % child)
        child.t.setVisited() # Supress warning/deletion of unvisited nodes.
        return child
    #@-node:ekr.20041005105605.72:createThinChild4
    #@+node:ekr.20041005105605.73:findChild4
    def findChild4 (self,headline):

        """Return the next tnode in at.root.t.tnodeList.
        This is called only for @file nodes"""

        # Note: tnodeLists are used _only_ when reading @file (not @thin) nodes.
        # tnodeLists compensate (a hack) for not having gnx's in derived files! 

        trace = False and not g.unitTesting
        at = self ; v = at.root.v

        if trace: g.trace('%s %s' % (
            v.t.tnodeList[at.tnodeListIndex],headline))

        if not hasattr(v.t,"tnodeList"):
            at.readError("no tnodeList for " + repr(v))
            g.es("write the @file node or use the Import Derived File command")
            g.trace("no tnodeList for ",v,g.callers())
            return None

        if at.tnodeListIndex &gt;= len(v.t.tnodeList):
            at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
            g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
            return None

        t = v.t.tnodeList[at.tnodeListIndex]
        assert(t)
        at.tnodeListIndex += 1

        # Get any vnode joined to t.
        try:
            v = t.vnodeList[0]
        except Exception:
            at.readError("No vnodeList for tnode: %s" % repr(t))
            g.trace(at.tnodeListIndex)
            return None

        # Don't check the headline.  It simply causes problems.
        t.setVisited() # Supress warning/deletion of unvisited nodes.
        return t
    #@-node:ekr.20041005105605.73:findChild4
    #@+node:ekr.20041005105605.74:scanText4 &amp; allies
    def scanText4 (self,theFile,fileName,p,verbose=False):

        """Scan a 4.x derived file non-recursively."""

        trace = False and not g.unitTesting
        at = self
        #@    &lt;&lt; init ivars for scanText4 &gt;&gt;
        #@+node:ekr.20041005105605.75:&lt;&lt; init ivars for scanText4 &gt;&gt;
        # Unstacked ivars...
        at.cloneSibCount = 0
        at.done = False
        at.inCode = True
        at.indent = 0 # Changed only for sentinels.
        at.lastLines = [] # The lines after @-leo
        at.leadingWs = ""
        at.lineNumber = 0
        at.root = p.copy() # Bug fix: 12/10/05
        at.rootSeen = False
        at.updateWarningGiven = False

        # Stacked ivars...
        at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
        at.out = [] ; at.outStack = []
        at.t = p.v.t ; at.tStack = []
        # New code: always identify root @thin node with self.root:
        at.lastThinNode = None
        at.thinNodeStack = []

        if 0: # Useful for debugging.
            if hasattr(p.v.t,"tnodeList"):
                g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
            else:
                g.trace("no tnodeList",p.v)

        # g.trace(at.startSentinelComment)
        #@-node:ekr.20041005105605.75:&lt;&lt; init ivars for scanText4 &gt;&gt;
        #@nl
        try:
            while at.errors == 0 and not at.done:
                s = at.readLine(theFile)
                self.lineNumber += 1
                if len(s) == 0: break
                kind = at.sentinelKind4(s)
                if kind == at.noSentinel:
                    i = 0
                else:
                    i = at.skipSentinelStart4(s,0)
                func = at.dispatch_dict[kind]
                if trace: g.trace(at.sentinelName(kind),s.strip(),func.__name__)
                func(s,i)
        except AssertionError:
            junk, message, junk = sys.exc_info()
            at.error('unexpected assertion failure in',fileName,'\n',message)

        if at.errors == 0 and not at.done:
            #@        &lt;&lt; report unexpected end of text &gt;&gt;
            #@+node:ekr.20041005105605.76:&lt;&lt; report unexpected end of text &gt;&gt;
            assert at.endSentinelStack,'empty sentinel stack'

            at.readError(
                "Unexpected end of file. Expecting %s sentinel" %
                at.sentinelName(at.endSentinelStack[-1]))
            #@-node:ekr.20041005105605.76:&lt;&lt; report unexpected end of text &gt;&gt;
            #@nl

        return at.lastLines
    #@+node:ekr.20041005105605.77:readNormalLine
    def readNormalLine (self,s,i):

        at = self

        if at.inCode:
            if not at.raw:
                s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
            at.out.append(s)
        else:
            #@        &lt;&lt; Skip the leading stuff &gt;&gt;
            #@+node:ekr.20041005105605.78:&lt;&lt; Skip the leading stuff &gt;&gt;
            if len(at.endSentinelComment) == 0:
                # Skip the single comment delim and a blank.
                i = g.skip_ws(s,0)
                if g.match(s,i,at.startSentinelComment):
                    i += len(at.startSentinelComment)
                    if g.match(s,i," "): i += 1
            else:
                i = at.skipIndent(s,0,at.indent)
            #@-node:ekr.20041005105605.78:&lt;&lt; Skip the leading stuff &gt;&gt;
            #@nl
            #@        &lt;&lt; Append s to docOut &gt;&gt;
            #@+node:ekr.20041005105605.79:&lt;&lt; Append s to docOut &gt;&gt;
            line = s[i:-1] # remove newline for rstrip.

            if line == line.rstrip():
                # no trailing whitespace: the newline is real.
                at.docOut.append(line + '\n')
            else:
                # trailing whitespace: the newline is fake.
                at.docOut.append(line)
            #@-node:ekr.20041005105605.79:&lt;&lt; Append s to docOut &gt;&gt;
            #@nl
    #@-node:ekr.20041005105605.77:readNormalLine
    #@+node:ekr.20041005105605.80:start sentinels
    #@+node:ekr.20041005105605.81:readStartAll (4.2)
    def readStartAll (self,s,i):

        """Read an @+all sentinel."""

        at = self
        j = g.skip_ws(s,i)
        leadingWs = s[i:j]
        if leadingWs:
            assert g.match(s,j,"@+all"),'missing @+all'
        else:
            assert g.match(s,j,"+all"),'missing +all'

        # Make sure that the generated at-all is properly indented.
        at.out.append(leadingWs + "@all\n")

        at.endSentinelStack.append(at.endAll)
    #@-node:ekr.20041005105605.81:readStartAll (4.2)
    #@+node:ekr.20041005105605.82:readStartAt &amp; readStartDoc
    def readStartAt (self,s,i):
        """Read an @+at sentinel."""
        at = self ; assert g.match(s,i,"+at"),'missing +at'
        if 0:# new code: append whatever follows the sentinel.
            i += 3 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
            at.out.append('@' + follow) ; at.docOut = []
        else:
            i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
            at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
        at.inCode = False
        at.endSentinelStack.append(at.endAt)

    def readStartDoc (self,s,i):
        """Read an @+doc sentinel."""
        at = self ; assert g.match(s,i,"+doc"),'missing +doc'
        if 0: # new code: append whatever follows the sentinel.
            i += 4 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
            at.out.append('@' + follow) ; at.docOut = []
        else:
            i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
            at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
        at.inCode = False
        at.endSentinelStack.append(at.endDoc)

    def skipToEndSentinel(self,s,i):
        at = self
        end = at.endSentinelComment
        if end:
            j = s.find(end,i)
            if j == -1:
                return g.skip_to_end_of_line(s,i)
            else:
                return j
        else:
            return g.skip_to_end_of_line(s,i)
    #@-node:ekr.20041005105605.82:readStartAt &amp; readStartDoc
    #@+node:ekr.20041005105605.83:readStartLeo
    def readStartLeo (self,s,i):

        """Read an unexpected @+leo sentinel."""

        at = self
        assert g.match(s,i,"+leo"),'missing +leo sentinel'
        at.readError("Ignoring unexpected @+leo sentinel")
    #@-node:ekr.20041005105605.83:readStartLeo
    #@+node:ekr.20041005105605.84:readStartMiddle
    def readStartMiddle (self,s,i):

        """Read an @+middle sentinel."""

        at = self

        at.readStartNode(s,i,middle=True)
    #@-node:ekr.20041005105605.84:readStartMiddle
    #@+node:ekr.20041005105605.85:readStartNode (4.x)
    def readStartNode (self,s,i,middle=False):

        """Read an @+node or @+middle sentinel."""

        trace = False and not g.unitTesting
        at = self
        if middle:
            assert g.match(s,i,"+middle:"),'missing +middle'
            i += 8
        else:
            assert g.match(s,i,"+node:"),'missing +node'
            i += 6

        if at.thinFile:
            #@        &lt;&lt; set gnx and bump i &gt;&gt;
            #@+node:ekr.20041005105605.86:&lt;&lt; set gnx and bump i &gt;&gt;
            # We have skipped past the opening colon of the gnx.
            j = s.find(':',i)
            if j == -1:
                g.trace("no closing colon",g.get_line(s,i))
                at.readError("Expecting gnx in @+node sentinel")
                return # 5/17/04
            else:
                gnx = s[i:j]
                i = j + 1 # Skip the i
            #@-node:ekr.20041005105605.86:&lt;&lt; set gnx and bump i &gt;&gt;
            #@nl
        #@    &lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;
        #@+node:ekr.20041005105605.87:&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;
        # Set headline to the rest of the line.
        # Don't strip leading whitespace."

        if len(at.endSentinelComment) == 0:
            headline = s[i:-1].rstrip()
        else:
            k = s.rfind(at.endSentinelComment,i)
            headline = s[i:k].rstrip() # works if k == -1

        # Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
        if at.startSentinelComment[-1:] == '@':
            headline = headline.replace('@@','@')
        #@-node:ekr.20041005105605.87:&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;
        #@nl
        if not at.root_seen:
            at.root_seen = True
            #@        &lt;&lt; Check the filename in the sentinel &gt;&gt;
            #@+node:ekr.20041005105605.88:&lt;&lt; Check the filename in the sentinel &gt;&gt;
            if 0: # This doesn't work so well in cooperative environments.
                if not at.importing:

                    h = headline.strip()

                    if h[:5] == "@file":
                        i,junk,junk = g.scanAtFileOptions(h)
                        fileName = h[i:].strip()
                        if fileName != at.targetFileName:
                            at.readError("File name in @node sentinel does not match file's name")
                    elif h[:8] == "@rawfile":
                        fileName = h[8:].strip()
                        if fileName != at.targetFileName:
                            at.readError("File name in @node sentinel does not match file's name")
                    else:
                        at.readError("Missing @file in root @node sentinel")
            #@-node:ekr.20041005105605.88:&lt;&lt; Check the filename in the sentinel &gt;&gt;
            #@nl

        i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
        at.indentStack.append(at.indent) ; at.indent = newIndent

        at.outStack.append(at.out) ; at.out = []
        at.tStack.append(at.t)

        if at.importing:
            p = at.createImportedNode(at.root,headline)
            at.t = p.v.t
        elif at.thinFile:
            if at.thinNodeStack:
                at.thinNodeStack.append(at.lastThinNode)
                v = at.createThinChild4(gnx,headline)
            else:
                v = at.root.v
                at.thinNodeStack.append(v)
            at.lastThinNode = v
            at.t = v.t
        else:
            at.t = at.findChild4(headline)

        at.endSentinelStack.append(at.endNode)
    #@-node:ekr.20041005105605.85:readStartNode (4.x)
    #@+node:ekr.20041005105605.89:readStartOthers
    def readStartOthers (self,s,i):

        """Read an @+others sentinel."""

        at = self
        j = g.skip_ws(s,i)
        leadingWs = s[i:j]
        if leadingWs:
            assert g.match(s,j,"@+others"),'missing @+others'
        else:
            assert g.match(s,j,"+others"),'missing +others'

        # Make sure that the generated at-others is properly indented.
        at.out.append(leadingWs + "@others\n")

        at.endSentinelStack.append(at.endOthers)
    #@-node:ekr.20041005105605.89:readStartOthers
    #@-node:ekr.20041005105605.80:start sentinels
    #@+node:ekr.20041005105605.90:end sentinels
    #@+node:ekr.20041005105605.91:readEndAll (4.2)
    def readEndAll (self,unused_s,unused_i):

        """Read an @-all sentinel."""

        at = self
        at.popSentinelStack(at.endAll)
    #@-node:ekr.20041005105605.91:readEndAll (4.2)
    #@+node:ekr.20041005105605.92:readEndAt &amp; readEndDoc
    def readEndAt (self,unused_s,unused_i):

        """Read an @-at sentinel."""

        at = self
        at.readLastDocLine("@")
        at.popSentinelStack(at.endAt)
        at.inCode = True

    def readEndDoc (self,unused_s,unused_i):

        """Read an @-doc sentinel."""

        at = self
        at.readLastDocLine("@doc")
        at.popSentinelStack(at.endDoc)
        at.inCode = True
    #@-node:ekr.20041005105605.92:readEndAt &amp; readEndDoc
    #@+node:ekr.20041005105605.93:readEndLeo
    def readEndLeo (self,unused_s,unused_i):

        """Read an @-leo sentinel."""

        at = self

        # Ignore everything after @-leo.
        # Such lines were presumably written by @last.
        while 1:
            s = at.readLine(at.inputFile)
            if len(s) == 0: break
            at.lastLines.append(s) # Capture all trailing lines, even if empty.

        at.done = True
    #@-node:ekr.20041005105605.93:readEndLeo
    #@+node:ekr.20041005105605.94:readEndMiddle
    def readEndMiddle (self,s,i):

        """Read an @-middle sentinel."""

        at = self

        at.readEndNode(s,i,middle=True)
    #@-node:ekr.20041005105605.94:readEndMiddle
    #@+node:ekr.20041005105605.95:readEndNode (4.x)
    def readEndNode (self,unused_s,unused_i,middle=False):

        """Handle end-of-node processing for @-others and @-ref sentinels."""

        at = self ; c = at.c

        # End raw mode.
        at.raw = False

        # Set the temporary body text.
        s = ''.join(at.out)
        s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

        if at.importing:
            at.t._bodyString = s
        elif middle: 
            pass # Middle sentinels never alter text.
        else:
            if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
                old = at.t.tempBodyString
            elif at.t.hasBody() and s != at.t.getBody():
                old = at.t.getBody()
            else:
                old = None
            # 9/4/04: Suppress this warning for the root: @first complicates matters.
            if old and not g.app.unitTesting and at.t != at.root.t:
                #@            &lt;&lt; indicate that the node has been changed &gt;&gt;
                #@+node:ekr.20041005105605.96:&lt;&lt; indicate that the node has been changed &gt;&gt;
                if at.perfectImportRoot:
                    #@    &lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;
                    #@+node:ekr.20041005105605.97:&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;
                    # Report the number of corrected nodes.
                    at.correctedLines += 1

                    found = False
                    for p in at.perfectImportRoot.self_and_subtree_iter():
                        if p.v.t == at.t:
                            found = True ; break

                    if found:
                        if 0: # For debugging.
                            g.pr('\n','-' * 40)
                            g.pr("old",len(old))
                            for line in g.splitLines(old):
                                #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
                                g.pr(repr(str(line)))
                            g.pr('\n','-' * 40)
                            g.pr("new",len(s))
                            for line in g.splitLines(s):
                                #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
                                g.pr(repr(str(line)))
                            g.pr('\n','-' * 40)
                    else:
                        # This should never happen.
                        g.es("correcting hidden node: t=",repr(at.t),color="red")
                    #@-node:ekr.20041005105605.97:&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;
                    #@nl
                    # p.setMarked()
                    at.t._bodyString = s # Just setting at.t.tempBodyString won't work here.
                    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
                    at.c.setChanged(True)
                else:
                    if 0: # New in 4.4.1 final.  This warning can be very confusing.
                        if not at.updateWarningGiven:
                            at.updateWarningGiven = True
                            # g.pr("***",at.t,at.root.t)
                            g.es("warning: updating changed text in",at.root.h,color="blue")
                    # Just set the dirty bit. Ancestors will be marked dirty later.
                    at.t.setDirty()
                    if 1: # We must avoid the full setChanged logic here!
                        c.changed = True
                    else: # Far too slow for mass changes.
                        at.c.setChanged(True)
                #@nonl
                #@-node:ekr.20041005105605.96:&lt;&lt; indicate that the node has been changed &gt;&gt;
                #@nl
            at.t.tempBodyString = s

        # Indicate that the tnode has been set in the derived file.
        at.t.setVisited()

        # End the previous node sentinel.
        at.indent = at.indentStack.pop()
        at.out = at.outStack.pop()
        at.t = at.tStack.pop()
        if at.thinFile and not at.importing:
            at.lastThinNode = at.thinNodeStack.pop()

        at.popSentinelStack(at.endNode)
    #@-node:ekr.20041005105605.95:readEndNode (4.x)
    #@+node:ekr.20041005105605.98:readEndOthers
    def readEndOthers (self,unused_s,unused_i):

        """Read an @-others sentinel."""

        at = self
        at.popSentinelStack(at.endOthers)
    #@-node:ekr.20041005105605.98:readEndOthers
    #@+node:ekr.20041005105605.99:readLastDocLine
    def readLastDocLine (self,tag):

        """Read the @c line that terminates the doc part.
        tag is @doc or @."""

        at = self
        end = at.endSentinelComment
        start = at.startSentinelComment
        s = ''.join(at.docOut)

        # Remove the @doc or @space.  We'll add it back at the end.
        if g.match(s,0,tag):
            s = s[len(tag):]
        else:
            at.readError("Missing start of doc part")
            return

        # Bug fix: Append any whitespace following the tag to tag.
        while s and s[0] in (' ','\t'):
            tag = tag + s[0] ; s = s[1:]

        if end:
            # Remove leading newline.
            if s[0] == '\n': s = s[1:]
            # Remove opening block delim.
            if g.match(s,0,start):
                s = s[len(start):]
            else:
                at.readError("Missing open block comment")
                g.trace('tag',repr(tag),'start',repr(start),'s',repr(s))
                return
            # Remove trailing newline.
            if s[-1] == '\n': s = s[:-1]
            # Remove closing block delim.
            if s[-len(end):] == end:
                s = s[:-len(end)]
            else:
                at.readError("Missing close block comment")
                g.trace(s)
                g.trace(end)
                g.trace(start)
                return

        at.out.append(tag + s)
        at.docOut = []
    #@-node:ekr.20041005105605.99:readLastDocLine
    #@-node:ekr.20041005105605.90:end sentinels
    #@+node:ekr.20041005105605.100:Unpaired sentinels
    #@+node:ekr.20041005105605.101:ignoreOldSentinel
    def  ignoreOldSentinel (self,s,unused_i):

        """Ignore an 3.x sentinel."""

        g.es("ignoring 3.x sentinel:",s.strip(),color="blue")
    #@-node:ekr.20041005105605.101:ignoreOldSentinel
    #@+node:ekr.20041005105605.102:readAfterRef
    def  readAfterRef (self,s,i):

        """Read an @afterref sentinel."""

        at = self
        assert g.match(s,i,"afterref"),'missing afterref'

        # Append the next line to the text.
        s = at.readLine(at.inputFile)
        at.out.append(s)
    #@-node:ekr.20041005105605.102:readAfterRef
    #@+node:ekr.20041005105605.103:readClone
    def readClone (self,s,i):

        at = self ; tag = "clone"

        assert g.match(s,i,tag),'missing clone sentinel'

        # Skip the tag and whitespace.
        i = g.skip_ws(s,i+len(tag))

        # Get the clone count.
        junk,val = g.skip_long(s,i)

        if val == None:
            at.readError("Invalid count in @clone sentinel")
        else:
            at.cloneSibCount = val
    #@-node:ekr.20041005105605.103:readClone
    #@+node:ekr.20041005105605.104:readComment
    def readComment (self,s,i):

        """Read an @comment sentinel."""

        assert g.match(s,i,"comment"),'missing comment sentinel'

        # Just ignore the comment line!
    #@-node:ekr.20041005105605.104:readComment
    #@+node:ekr.20041005105605.105:readDelims
    def readDelims (self,s,i):

        """Read an @delims sentinel."""

        at = self
        assert g.match(s,i-1,"@delims"),'missing @delims'

        # Skip the keyword and whitespace.
        i0 = i-1
        i = g.skip_ws(s,i-1+7)

        # Get the first delim.
        j = i
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1

        if j &lt; i:
            at.startSentinelComment = s[j:i]
            # g.pr("delim1:", at.startSentinelComment)

            # Get the optional second delim.
            j = i = g.skip_ws(s,i)
            while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
                i += 1
            end = g.choose(j&lt;i,s[j:i],"")
            i2 = g.skip_ws(s,i)
            if end == at.endSentinelComment and (i2 &gt;= len(s) or g.is_nl(s,i2)):
                at.endSentinelComment = "" # Not really two params.
                line = s[i0:j]
                line = line.rstrip()
                at.out.append(line+'\n')
            else:
                at.endSentinelComment = end
                # g.pr("delim2:",end)
                line = s[i0:i]
                line = line.rstrip()
                at.out.append(line+'\n')
        else:
            at.readError("Bad @delims")
            # Append the bad @delims line to the body text.
            at.out.append("@delims")
    #@-node:ekr.20041005105605.105:readDelims
    #@+node:ekr.20041005105605.106:readDirective (@@)
    def readDirective (self,s,i):

        """Read an @@sentinel."""

        at = self
        assert g.match(s,i,"@"),'missing @@ sentinel' # The first '@' has already been eaten.

        # g.trace(g.get_line(s,i))

        if g.match_word(s,i,"@raw"):
            at.raw = True
        elif g.match_word(s,i,"@end_raw"):
            at.raw = False

        e = at.endSentinelComment
        s2 = s[i:]
        if len(e) &gt; 0:
            k = s.rfind(e,i)
            if k != -1:
                s2 = s[i:k] + '\n'

        start = at.startSentinelComment
        if start and len(start) &gt; 0 and start[-1] == '@':
            s2 = s2.replace('@@','@')

        if 0: # New in 4.2.1: never change comment delims here...
            if g.match_word(s,i,"@language"):
                #@            &lt;&lt; handle @language &gt;&gt;
                #@+node:ekr.20041005105605.107:&lt;&lt; handle @language &gt;&gt;
                # Skip the keyword and whitespace.
                i += len("@language")
                i = g.skip_ws(s,i)
                j = g.skip_c_id(s,i)
                language = s[i:j]

                delim1,delim2,delim3 = g.set_delims_from_language(language)

                g.trace(g.get_line(s,i))
                g.trace(delim1,delim2,delim3)

                # Returns a tuple (single,start,end) of comment delims
                if delim1:
                    at.startSentinelComment = delim1
                    at.endSentinelComment = "" # Must not be None.
                elif delim2 and delim3:
                    at.startSentinelComment = delim2
                    at.endSentinelComment = delim3
                else:
                    line = g.get_line(s,i)
                    g.es("ignoring bad @language sentinel:",line,color="red")
                #@-node:ekr.20041005105605.107:&lt;&lt; handle @language &gt;&gt;
                #@nl
            elif g.match_word(s,i,"@comment"):
                #@            &lt;&lt; handle @comment &gt;&gt;
                #@+node:ekr.20041005105605.108:&lt;&lt; handle @comment &gt;&gt;
                j = g.skip_line(s,i)
                line = s[i:j]
                delim1,delim2,delim3 = g.set_delims_from_string(line)

                #g.trace(g.get_line(s,i))
                #g.trace(delim1,delim2,delim3)

                # Returns a tuple (single,start,end) of comment delims
                if delim1:
                    self.startSentinelComment = delim1
                    self.endSentinelComment = "" # Must not be None.
                elif delim2 and delim3:
                    self.startSentinelComment = delim2
                    self.endSentinelComment = delim3
                else:
                    line = g.get_line(s,i)
                    g.es("ignoring bad @comment sentinel:",line,color="red")
                #@-node:ekr.20041005105605.108:&lt;&lt; handle @comment &gt;&gt;
                #@nl

        at.out.append(s2)
    #@-node:ekr.20041005105605.106:readDirective (@@)
    #@+node:ekr.20041005105605.109:readNl
    def readNl (self,s,i):

        """Handle an @nonl sentinel."""

        at = self
        assert g.match(s,i,"nl"),'missing nl sentinel'

        if at.inCode:
            at.out.append('\n')
        else:
            at.docOut.append('\n')
    #@-node:ekr.20041005105605.109:readNl
    #@+node:ekr.20041005105605.110:readNonl
    def readNonl (self,s,i):

        """Handle an @nonl sentinel."""

        at = self
        assert g.match(s,i,"nonl"),'missing nonl sentinel'

        if at.inCode:
            s = ''.join(at.out)
            if s and s[-1] == '\n':
                at.out = [s[:-1]]
            else:
                g.trace("out:",s)
                at.readError("unexpected @nonl directive in code part")
        else:
            s = ''.join(at.pending)
            if s:
                if s and s[-1] == '\n':
                    at.pending = [s[:-1]]
                else:
                    g.trace("docOut:",s)
                    at.readError("unexpected @nonl directive in pending doc part")
            else:
                s = ''.join(at.docOut)
                if s and s[-1] == '\n':
                    at.docOut = [s[:-1]]
                else:
                    g.trace("docOut:",s)
                    at.readError("unexpected @nonl directive in doc part")
    #@-node:ekr.20041005105605.110:readNonl
    #@+node:ekr.20041005105605.111:readRef
    #@+at 
    #@nonl
    # The sentinel contains an @ followed by a section name in angle 
    # brackets.  This code is different from the code for the @@ sentinel: the 
    # expansion of the reference does not include a trailing newline.
    #@-at
    #@@c

    def readRef (self,s,i):

        """Handle an @&lt;&lt; sentinel."""

        at = self
        j = g.skip_ws(s,i)
        assert g.match(s,j,"&lt;&lt;"),'missing @&lt;&lt; sentinel'

        if len(at.endSentinelComment) == 0:
            line = s[i:-1] # No trailing newline
        else:
            k = s.find(at.endSentinelComment,i)
            line = s[i:k] # No trailing newline, whatever k is.

        # Undo the cweb hack.
        start = at.startSentinelComment
        if start and len(start) &gt; 0 and start[-1] == '@':
            line = line.replace('@@','@')

        at.out.append(line)
    #@-node:ekr.20041005105605.111:readRef
    #@+node:ekr.20041005105605.112:readVerbatim
    def readVerbatim (self,s,i):

        """Read an @verbatim sentinel."""

        at = self
        assert g.match(s,i,"verbatim"),'missing verbatim sentinel'

        # Append the next line to the text.
        s = at.readLine(at.inputFile) 
        i = at.skipIndent(s,0,at.indent)
        # Do **not** insert the verbatim line itself!
            # at.out.append("@verbatim\n")
        at.out.append(s[i:])
    #@+node:ekr.20090620101138.6072:@test verbatim sentinel
    if g.unitTesting:
        c,p = g.getTestVars()

        # Here is something that should generate a verbtim sentinel::

    #@verbatim
        #@+leo-encoding=iso-8859-1.

        # The length of this node should remain constant.

        assert len(p.b) == 235,len(p.b)
    #@nonl
    #@-node:ekr.20090620101138.6072:@test verbatim sentinel
    #@-node:ekr.20041005105605.112:readVerbatim
    #@-node:ekr.20041005105605.100:Unpaired sentinels
    #@+node:ekr.20041005105605.113:badEndSentinel, popSentinelStack
    def badEndSentinel (self,expectedKind):

        """Handle a mismatched ending sentinel."""

        at = self
        assert at.endSentinelStack,'empty sentinel stack'
        s = "Ignoring %s sentinel.  Expecting %s" % (
            at.sentinelName(at.endSentinelStack[-1]),
            at.sentinelName(expectedKind))
        at.readError(s)

    def popSentinelStack (self,expectedKind):

        """Pop an entry from endSentinelStack and check it."""

        at = self
        if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
            at.endSentinelStack.pop()
        else:
            at.badEndSentinel(expectedKind)
    #@-node:ekr.20041005105605.113:badEndSentinel, popSentinelStack
    #@-node:ekr.20041005105605.74:scanText4 &amp; allies
    #@+node:ekr.20041005105605.114:sentinelKind4
    def sentinelKind4(self,s):

        """Return the kind of sentinel at s."""

        at = self

        i = g.skip_ws(s,0)
        if g.match(s,i,at.startSentinelComment): 
            i += len(at.startSentinelComment)
        else:
            return at.noSentinel

        # Locally undo cweb hack here
        start = at.startSentinelComment
        if start and len(start) &gt; 0 and start[-1] == '@':
            s = s[:i] + s[i:].replace('@@','@')

        # 4.0: Look ahead for @[ws]@others and @[ws]&lt;&lt;
        if g.match(s,i,"@"):
            j = g.skip_ws(s,i+1)
            if j &gt; i+1:
                # g.trace(ws,s)
                if g.match(s,j,"@+others"):
                    return at.startOthers
                elif g.match(s,j,"&lt;&lt;"):
                    return at.startRef
                else:
                    # No other sentinels allow whitespace following the '@'
                    return at.noSentinel

        # Do not skip whitespace here!
        if g.match(s,i,"@&lt;&lt;"): return at.startRef
        if g.match(s,i,"@@"):   return at.startDirective
        if not g.match(s,i,'@'): return at.noSentinel
        j = i # start of lookup
        i += 1 # skip the at sign.
        if g.match(s,i,'+') or g.match(s,i,'-'):
            i += 1
        i = g.skip_c_id(s,i)
        key = s[j:i]
        if len(key) &gt; 0 and key in at.sentinelDict:
            return at.sentinelDict[key]
        else:
            return at.noSentinel
    #@-node:ekr.20041005105605.114:sentinelKind4
    #@+node:ekr.20041005105605.115:skipSentinelStart4
    def skipSentinelStart4(self,s,i):

        """Skip the start of a sentinel."""

        start = self.startSentinelComment
        assert(start and len(start)&gt;0)

        i = g.skip_ws(s,i)
        assert(g.match(s,i,start))
        i += len(start)

        # 7/8/02: Support for REM hack
        i = g.skip_ws(s,i)
        assert(i &lt; len(s) and s[i] == '@')
        return i + 1
    #@-node:ekr.20041005105605.115:skipSentinelStart4
    #@-node:ekr.20041005105605.71:Reading (4.x)
    #@+node:ekr.20041005105605.116:Reading utils...
    #@+node:ekr.20041005105605.117:completeFirstDirectives
    # 14-SEP-2002 DTHEIN: added for use by atFile.read()

    # this function scans the lines in the list 'out' for @first directives
    # and appends the corresponding line from 'firstLines' to each @first 
    # directive found.  NOTE: the @first directives must be the very first
    # lines in 'out'.
    def completeFirstDirectives(self,out,firstLines):

        tag = "@first"
        foundAtFirstYet = 0
        outRange = range(len(out))
        j = 0
        for k in outRange:
            # skip leading whitespace lines
            if (not foundAtFirstYet) and (len(out[k].strip()) == 0): continue
            # quit if something other than @first directive
            i = 0
            if not g.match(out[k],i,tag): break
            foundAtFirstYet = 1
            # quit if no leading lines to apply
            if j &gt;= len(firstLines): break
            # make the new @first directive
            #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
            # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @first directive
            leadingLine = " " + firstLines[j]
            out[k] = tag + leadingLine.rstrip() ; j += 1
    #@-node:ekr.20041005105605.117:completeFirstDirectives
    #@+node:ekr.20041005105605.118:completeLastDirectives
    # 14-SEP-2002 DTHEIN: added for use by atFile.read()

    # this function scans the lines in the list 'out' for @last directives
    # and appends the corresponding line from 'lastLines' to each @last 
    # directive found.  NOTE: the @last directives must be the very last
    # lines in 'out'.
    def completeLastDirectives(self,out,lastLines):

        tag = "@last"
        foundAtLastYet = 0
        outRange = range(-1,-len(out),-1)
        j = -1
        for k in outRange:
            # skip trailing whitespace lines
            if (not foundAtLastYet) and (len(out[k].strip()) == 0): continue
            # quit if something other than @last directive
            i = 0
            if not g.match(out[k],i,tag): break
            foundAtLastYet = 1
            # quit if no trailing lines to apply
            if j &lt; -len(lastLines): break
            # make the new @last directive
            #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
            # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @last directive
            trailingLine = " " + lastLines[j]
            out[k] = tag + trailingLine.rstrip() ; j -= 1
    #@-node:ekr.20041005105605.118:completeLastDirectives
    #@+node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
    def  copyAllTempBodyStringsToTnodes (self,root,thinFile):

        c = self.c
        for p in root.self_and_subtree_iter():
            try: s = p.v.t.tempBodyString
            except Exception: s = ""
            old_body = p.b
            if s != old_body:
                if False and old_body: # For debugging.
                    g.pr("\nchanged: " + p.h)
                    g.pr("\nnew:",s)
                    g.pr("\nold:",p.b)
                if thinFile:
                    p.v.setBodyString(s)
                    if p.v.isDirty():
                        p.setAllAncestorAtFileNodesDirty()
                else:
                    c.setBodyString(p,s) # Sets c and p dirty.

                if not thinFile or (thinFile and p.v.isDirty()):
                    # New in Leo 4.3: support for mod_labels plugin:
                    try:
                        c.mod_label_controller.add_label(p,"before change:",old_body)
                    except Exception:
                        pass
                    g.es("changed:",p.h,color="blue")
                    p.setMarked()
    #@-node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
    #@+node:ekr.20041005105605.119:createImportedNode
    def createImportedNode (self,root,headline):

        at = self

        if at.importRootSeen:
            p = root.insertAsLastChild()
            p.initHeadString(headline)
        else:
            # Put the text into the already-existing root node.
            p = root
            at.importRootSeen = True

        p.v.t.setVisited() # Suppress warning about unvisited node.
        return p
    #@-node:ekr.20041005105605.119:createImportedNode
    #@+node:ekr.20041005105605.120:at.parseLeoSentinel
    def parseLeoSentinel (self,s):

        at = self ; c = at.c
        new_df = False ; valid = True ; n = len(s)
        start = '' ; end = '' ; isThinDerivedFile = False
        encoding_tag = "-encoding="
        version_tag = "-ver="
        tag = "@+leo"
        thin_tag = "-thin"
        #@    &lt;&lt; set the opening comment delim &gt;&gt;
        #@+node:ekr.20041005105605.121:&lt;&lt; set the opening comment delim &gt;&gt;
        # s contains the tag
        i = j = g.skip_ws(s,0)

        # The opening comment delim is the initial non-tag
        while i &lt; n and not g.match(s,i,tag) and not g.is_nl(s,i):
            i += 1

        if j &lt; i:
            start = s[j:i]
        else:
            valid = False

        #@-node:ekr.20041005105605.121:&lt;&lt; set the opening comment delim &gt;&gt;
        #@nl
        #@    &lt;&lt; make sure we have @+leo &gt;&gt;
        #@+node:ekr.20041005105605.122:&lt;&lt; make sure we have @+leo &gt;&gt;
        #@+at 
        #@nonl
        # REM hack: leading whitespace is significant before the @+leo.  We do 
        # this so that sentinelKind need not skip whitespace following 
        # self.startSentinelComment.  This is correct: we want to be as 
        # restrictive as possible about what is recognized as a sentinel.  
        # This minimizes false matches.
        #@-at
        #@@c

        if 0: # Make leading whitespace significant.
            i = g.skip_ws(s,i)

        if g.match(s,i,tag):
            i += len(tag)
        else: valid = False
        #@-node:ekr.20041005105605.122:&lt;&lt; make sure we have @+leo &gt;&gt;
        #@nl
        #@    &lt;&lt; read optional version param &gt;&gt;
        #@+node:ekr.20041005105605.123:&lt;&lt; read optional version param &gt;&gt;
        new_df = g.match(s,i,version_tag)

        if new_df:
            # Pre Leo 4.4.1: Skip to the next minus sign or end-of-line.
            # Leo 4.4.1 +:   Skip to next minus sign, end-of-line, or non numeric character.
            # This is required to handle trailing comment delims properly.
            i += len(version_tag)
            j = i
            while i &lt; len(s) and (s[i] == '.' or s[i].isdigit()):
                i += 1

            if j &lt; i:
                pass
            else:
                valid = False
        #@-node:ekr.20041005105605.123:&lt;&lt; read optional version param &gt;&gt;
        #@nl
        #@    &lt;&lt; read optional thin param &gt;&gt;
        #@+node:ekr.20041005105605.124:&lt;&lt; read optional thin param &gt;&gt;
        if g.match(s,i,thin_tag):
            i += len(tag)
            isThinDerivedFile = True
        #@-node:ekr.20041005105605.124:&lt;&lt; read optional thin param &gt;&gt;
        #@nl
        #@    &lt;&lt; read optional encoding param &gt;&gt;
        #@+node:ekr.20041005105605.125:&lt;&lt; read optional encoding param &gt;&gt;
        # Set the default encoding
        at.encoding = c.config.default_derived_file_encoding

        if g.match(s,i,encoding_tag):
            # Read optional encoding param, e.g., -encoding=utf-8,
            i += len(encoding_tag)
            # Skip to the next end of the field.
            j = s.find(",.",i)
            if j &gt; -1:
                # The encoding field was written by 4.2 or after:
                encoding = s[i:j]
                i = j + 2 # 6/8/04, 1/11/05 (was i = j + 1)
            else:
                # The encoding field was written before 4.2.
                j = s.find('.',i)
                if j &gt; -1:
                    encoding = s[i:j]
                    i = j + 1 # 6/8/04
                else:
                    encoding = None
            # g.trace("encoding:",encoding)
            if encoding:
                if g.isValidEncoding(encoding):
                    at.encoding = encoding
                else:
                    g.es_print("bad encoding in derived file:",encoding)
            else:
                valid = False
        #@-node:ekr.20041005105605.125:&lt;&lt; read optional encoding param &gt;&gt;
        #@nl
        #@    &lt;&lt; set the closing comment delim &gt;&gt;
        #@+node:ekr.20041005105605.126:&lt;&lt; set the closing comment delim &gt;&gt;
        # The closing comment delim is the trailing non-whitespace.
        i = j = g.skip_ws(s,i)
        while i &lt; n and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = s[j:i]
        #@-node:ekr.20041005105605.126:&lt;&lt; set the closing comment delim &gt;&gt;
        #@nl
        if not new_df and not g.unitTesting:
            g.trace('not new_df(!)',repr(s))
        return valid,new_df,start,end,isThinDerivedFile
    #@-node:ekr.20041005105605.120:at.parseLeoSentinel
    #@+node:ekr.20041005105605.127:readError
    def readError(self,message):

        # This is useful now that we don't print the actual messages.
        if self.errors == 0:
            self.printError("----- read error. line: %s, file: %s" % (
                self.lineNumber,self.targetFileName,))

        # g.trace(self.root,g.callers())
        self.error(message)

        # Delete all of root's tree.
        self.root.t.children = []
        self.root.setOrphan()
        self.root.setDirty()
    #@-node:ekr.20041005105605.127:readError
    #@+node:ekr.20041005105605.128:readLine
    def readLine (self,theFile):

        """Reads one line from file using the present encoding"""

        s = g.readlineForceUnixNewline(theFile) # calls theFile.readline
        # g.trace(repr(s),g.callers(4))
        u = g.toUnicode(s,self.encoding)
        return u
    #@-node:ekr.20041005105605.128:readLine
    #@+node:ekr.20041005105605.129:at.scanHeader
    def scanHeader(self,theFile,fileName):

        """Scan the @+leo sentinel.

        Sets self.encoding, and self.start/endSentinelComment.

        Returns (firstLines,new_df,isThinDerivedFile) where:
        firstLines        contains all @first lines,
        new_df            is True if we are reading a new-format derived file.
        isThinDerivedFile is True if the file is an @thin file."""

        trace = False
        at = self
        firstLines = [] # The lines before @+leo.
        tag = "@+leo"
        valid = True ; new_df = False ; isThinDerivedFile = False
        #@    &lt;&lt; skip any non @+leo lines &gt;&gt;
        #@+node:ekr.20041005105605.130:&lt;&lt; skip any non @+leo lines &gt;&gt;
        #@+at 
        #@nonl
        # Queue up the lines before the @+leo.
        # 
        # These will be used to add as parameters to the @first directives, if 
        # any.
        # Empty lines are ignored (because empty @first directives are 
        # ignored).
        # NOTE: the function now returns a list of the lines before @+leo.
        # 
        # We can not call sentinelKind here because that depends on
        # the comment delimiters we set here.
        # 
        # at-first lines are written "verbatim", so nothing more needs to be 
        # done!
        #@-at
        #@@c

        s = at.readLine(theFile)
        if trace: g.trace('first line',repr(s))
        while len(s) &gt; 0:
            j = s.find(tag)
            if j != -1: break
            firstLines.append(s) # Queue the line
            s = at.readLine(theFile)

        n = len(s)
        valid = n &gt; 0
        #@-node:ekr.20041005105605.130:&lt;&lt; skip any non @+leo lines &gt;&gt;
        #@nl
        if valid:
            valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
        if valid:
            at.startSentinelComment = start
            at.endSentinelComment = end
            # g.trace('start',repr(start),'end',repr(end))
        else:
            at.error("No @+leo sentinel in: %s" % fileName)
        # g.trace("start,end",repr(at.startSentinelComment),repr(at.endSentinelComment))
        return firstLines,new_df,isThinDerivedFile
    #@-node:ekr.20041005105605.129:at.scanHeader
    #@+node:ekr.20041005105605.131:skipIndent
    # Skip past whitespace equivalent to width spaces.

    def skipIndent(self,s,i,width):

        ws = 0 ; n = len(s)
        while i &lt; n and ws &lt; width:
            if   s[i] == '\t': ws += (abs(self.tab_width) - (ws % abs(self.tab_width)))
            elif s[i] == ' ':  ws += 1
            else: break
            i += 1
        return i
    #@-node:ekr.20041005105605.131:skipIndent
    #@-node:ekr.20041005105605.116:Reading utils...
    #@-node:ekr.20041005105605.17:at.Reading
    #@+node:ekr.20041005105605.132:at.Writing
    #@+node:ekr.20041005105605.133:Writing (top level)
    #@+node:ekr.20041005105605.134:Don't override in plugins
    # Plugins probably should not need to override these methods.
    #@+node:ekr.20041005105605.136:norefWrite
    def norefWrite(self,root,toString=False):

        at = self ; c = at.c
        c.endEditing() # Capture the current headline.

        try:
            targetFileName = root.atNorefFileNodeName()
            at.initWriteIvars(root,targetFileName,nosentinels=False,toString=toString)
            if at.errors: return
            if not at.openFileForWriting(root,targetFileName,toString):
                # openFileForWriting calls root.setDirty() if there are errors.
                return
            #@        &lt;&lt; write root's tree &gt;&gt;
            #@+node:ekr.20041005105605.137:&lt;&lt; write root's tree &gt;&gt;
            #@&lt;&lt; put all @first lines in root &gt;&gt;
            #@+node:ekr.20041005105605.138:&lt;&lt; put all @first lines in root &gt;&gt;
            #@+at 
            #@nonl
            # Write any @first lines.  These lines are also converted to 
            # @verbatim lines, so the read logic simply ignores lines 
            # preceding the @+leo sentinel.
            #@-at
            #@@c

            s = root.v.t._bodyString
            tag = "@first"
            i = 0
            while g.match(s,i,tag):
                i += len(tag)
                i = g.skip_ws(s,i)
                j = i
                i = g.skip_to_end_of_line(s,i)
                # Write @first line, whether empty or not
                line = s[j:i]
                at.putBuffered(line) ; at.onl()
                i = g.skip_nl(s,i)
            #@-node:ekr.20041005105605.138:&lt;&lt; put all @first lines in root &gt;&gt;
            #@nl
            at.putOpenLeoSentinel("@+leo-ver=4")
            #@&lt;&lt; put optional @comment sentinel lines &gt;&gt;
            #@+node:ekr.20041005105605.139:&lt;&lt; put optional @comment sentinel lines &gt;&gt;
            s2 = c.config.output_initial_comment
            if s2:
                lines = s2.split("\\n")
                for line in lines:
                    line = line.replace("@date",time.asctime())
                    if len(line)&gt; 0:
                        at.putSentinel("@comment " + line)
            #@-node:ekr.20041005105605.139:&lt;&lt; put optional @comment sentinel lines &gt;&gt;
            #@nl

            for p in root.self_and_subtree_iter():
                #@    &lt;&lt; Write p's node &gt;&gt;
                #@+node:ekr.20041005105605.140:&lt;&lt; Write p's node &gt;&gt;
                at.putOpenNodeSentinel(p)

                s = p.b
                s = self.cleanLines(p,s)

                if s:
                    s = g.toEncodedString(s,at.encoding,reportErrors=True)
                    at.outputStringWithLineEndings(s)

                # Put an @nonl sentinel if s does not end in a newline.
                if s and s[-1] != '\n':
                    at.onl_sent() ; at.putSentinel("@nonl")

                at.putCloseNodeSentinel(p)
                #@-node:ekr.20041005105605.140:&lt;&lt; Write p's node &gt;&gt;
                #@nl

            at.putSentinel("@-leo")
            #@&lt;&lt; put all @last lines in root &gt;&gt;
            #@+node:ekr.20041005105605.141:&lt;&lt; put all @last lines in root &gt;&gt;
            #@+at 
            #@nonl
            # Write any @last lines.  These lines are also converted to 
            # @verbatim lines, so the read logic simply ignores lines 
            # following the @-leo sentinel.
            #@-at
            #@@c

            tag = "@last"
            lines = root.v.t._bodyString.split('\n')
            n = len(lines) ; j = k = n - 1
            # Don't write an empty last line.
            if j &gt;= 0 and len(lines[j])==0:
                j = k = n - 2
            # Scan backwards for @last directives.
            while j &gt;= 0:
                line = lines[j]
                if g.match(line,0,tag): j -= 1
                else: break
            # Write the @last lines.
            for line in lines[j+1:k+1]:
                i = len(tag) ; i = g.skip_ws(line,i)
                at.putBuffered(line[i:]) ; at.onl()
            #@-node:ekr.20041005105605.141:&lt;&lt; put all @last lines in root &gt;&gt;
            #@nl
            #@-node:ekr.20041005105605.137:&lt;&lt; write root's tree &gt;&gt;
            #@nl
            at.closeWriteFile()
            at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
        except Exception:
            at.writeException(root) # Sets dirty and orphan bits.

    rawWrite = norefWrite
    #@-node:ekr.20041005105605.136:norefWrite
    #@+node:ekr.20041005105605.142:openFileForWriting &amp; openFileForWritingHelper
    def openFileForWriting (self,root,fileName,toString):

        at = self
        at.outputFile = None

        if toString:
            at.shortFileName = g.shortFileName(fileName)
            at.outputFileName = "&lt;string: %s&gt;" % at.shortFileName
            at.outputFile = g.fileLikeObject()
        else:
            ok = at.openFileForWritingHelper(fileName)

            # New in Leo 4.4.8: set dirty bit if there are errors.
            if not ok: at.outputFile = None

        # New in 4.3 b2: root may be none when writing from a string.
        if root:
            if at.outputFile:
                root.clearOrphan()
            else:
                root.setOrphan()
                root.setDirty()

        return at.outputFile is not None
    #@+node:ekr.20041005105605.143:openFileForWritingHelper &amp; helper
    def openFileForWritingHelper (self,fileName):

        '''Open the file and return True if all went well.'''

        at = self ; c = at.c

        try:
            at.shortFileName = g.shortFileName(fileName)
            at.targetFileName = c.os_path_finalize_join(at.default_directory,fileName)
            path = g.os_path_dirname(at.targetFileName)
            if not path or not g.os_path_exists(path):
                if path:
                    path = g.makeAllNonExistentDirectories(path,c=c)
                if not path or not g.os_path_exists(path):
                    path = g.os_path_dirname(at.targetFileName)
                    at.writeError("path does not exist: " + path)
                    return False
        except Exception:
            at.exception("exception creating path: %s" % repr(path))
            g.es_exception()
            return False

        if g.os_path_exists(at.targetFileName):
            try:
                if not os.access(at.targetFileName,os.W_OK):
                    at.writeError("can not open: read only: " + at.targetFileName)
                    return False
            except AttributeError:
                pass # os.access() may not exist on all platforms.

        try:
            at.outputFileName = at.targetFileName + ".tmp"
            kind,at.outputFile = self.openForWrite(at.outputFileName,'wb')
            if not at.outputFile:
                kind = g.choose(kind=='check',
                    'did not overwrite','can not create')
                at.writeError("%s %s" % (kind,at.outputFileName))
                return False
        except Exception:
            at.exception("exception creating:" + at.outputFileName)
            return False

        return True
    #@+node:bwmulder.20050101094804:openForWrite (atFile)
    def openForWrite (self, filename, wb='wb'):

        '''Open a file for writes, handling shadow files.'''

        trace = False and not g.unitTesting
        at = self ; c = at.c ; x = c.shadowController

        try:
            shadow_filename = x.shadowPathName(filename)
            self.writing_to_shadow_directory = os.path.exists(shadow_filename)
            open_file_name       = g.choose(self.writing_to_shadow_directory,shadow_filename,filename)
            self.shadow_filename = g.choose(self.writing_to_shadow_directory,shadow_filename,None)

            if self.writing_to_shadow_directory:
                if trace: g.trace(filename,shadow_filename)
                x.message('writing %s' % shadow_filename)
                return 'shadow',open(open_file_name,wb)
            else:
                ok = c.checkFileTimeStamp(at.targetFileName)
                return 'check',ok and open(open_file_name,wb)

        except IOError:
            if not g.app.unitTesting:
                g.es_print('openForWrite: exception opening file: %s' % (open_file_name),color='red')
                g.es_exception()
            return 'error',None
    #@-node:bwmulder.20050101094804:openForWrite (atFile)
    #@-node:ekr.20041005105605.143:openFileForWritingHelper &amp; helper
    #@-node:ekr.20041005105605.142:openFileForWriting &amp; openFileForWritingHelper
    #@+node:ekr.20041005105605.144:write &amp; helper
    # This is the entry point to the write code.  root should be an @file vnode.

    def write (self,root,
        nosentinels = False,
        thinFile = False,
        scriptWrite = False,
        toString = False,
    ):

        """Write a 4.x derived file."""

        at = self ; c = at.c
        c.endEditing() # Capture the current headline.

        # g.trace(root.h)

        if hasattr(root.v.t,'tnodeList'):# 2008/10/3
            has_list,old_list = True,root.v.t.tnodeList[:]
        else:
            has_list,old_list = False,[]

        #@    &lt;&lt; set at.targetFileName &gt;&gt;
        #@+node:ekr.20041005105605.145:&lt;&lt; set at.targetFileName &gt;&gt;
        if toString:
            at.targetFileName = "&lt;string-file&gt;"
        elif nosentinels:
            at.targetFileName = root.atNoSentFileNodeName()
        elif thinFile:
            at.targetFileName = root.atThinFileNodeName()
        else:
            at.targetFileName = root.atFileNodeName()
        #@-node:ekr.20041005105605.145:&lt;&lt; set at.targetFileName &gt;&gt;
        #@nl
        at.initWriteIvars(root,at.targetFileName,
            nosentinels = nosentinels, thinFile = thinFile,
            scriptWrite = scriptWrite, toString = toString)

        if nosentinels and not scriptWrite and not toString:
            fileName = c.os_path_finalize_join(at.default_directory,at.targetFileName)
            # g.trace('fileName',fileName,'at.targetFileName',at.targetFileName)
            exists = g.os_path_exists(fileName)
            if not self.shouldWriteAtNosentNode(root,exists):
                return

        if not at.openFileForWriting(root,at.targetFileName,toString):
            # openFileForWriting calls root.setDirty() if there are errors.
            return

        try:
            at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
            if toString:
                at.closeWriteFile() # sets self.stringOutput
                # Major bug: failure to clear this wipes out headlines!
                # Minor bug: sometimes this causes slight problems...
                at.root.v.t.tnodeList = []
                at.root.v.t._p_changed = True
            else:
                at.closeWriteFile()
                if at.errors &gt; 0 or at.root.isOrphan():
                    #@                &lt;&lt; set dirty and orphan bits &gt;&gt;
                    #@+node:ekr.20041005105605.146:&lt;&lt; set dirty and orphan bits &gt;&gt;
                    # Setting the orphan and dirty flags tells Leo to write the tree..
                    root.setOrphan()
                    root.setDirty()
                    # Delete the temp file.
                    self.remove(at.outputFileName) 

                    #@-node:ekr.20041005105605.146:&lt;&lt; set dirty and orphan bits &gt;&gt;
                    #@nl
                    g.es("not written:",at.outputFileName)
                else:
                    at.replaceTargetFileIfDifferent(root)
                        # Sets/clears dirty and orphan bits.
                if has_list: root.v.t.tnodeList = old_list # 2008/10/3
        except Exception:
            if toString:
                at.exception("exception preprocessing script")
                at.root.v.t.tnodeList = []
                at.root.v.t._p_changed = True
            else:
                at.writeException() # Sets dirty and orphan bits.
                if has_list: root.v.t.tnodeList = old_list # 2008/10/3
    #@+node:ekr.20080620095343.1:shouldWriteAtNosentNode
    #@+at 
    #@nonl
    # Much thought went into this decision tree:
    # 
    # - We do not want decisions to depend on past history.That ' s too 
    # confusing.
    # - We must ensure that the file will be written if the user does 
    # significant work.
    # - We must ensure that the user can create an @auto x node at any time
    #   without risk of of replacing x with empty or insignificant 
    # information.
    # - We want the user to be able to create an @auto node which will be 
    # populated the next time the.leo file is opened.
    # - We don ' t want minor import imperfections to be written to the @auto 
    # file.
    # - The explicit commands that read and write @auto trees must always be 
    # honored.
    #@-at
    #@@c

    def shouldWriteAtNosentNode (self,p,exists):

        '''Return True if we should write the @auto node at p.'''

        if not exists: # We can write a non-existent file without danger.
            return True
        elif self.isSignificantTree(p):
            return True # Assume the tree contains what should be written.
        else:
            g.es_print(p.h,'not written:',color='red')
            g.es_print('no children and less than 10 characters (excluding directives)',color='blue')
            return False
    #@-node:ekr.20080620095343.1:shouldWriteAtNosentNode
    #@-node:ekr.20041005105605.144:write &amp; helper
    #@+node:ekr.20041005105605.147:writeAll (atFile)
    def writeAll(self,
        writeAtFileNodesFlag=False,
        writeDirtyAtFileNodesFlag=False,
        toString=False,
    ):

        """Write @file nodes in all or part of the outline"""

        trace = False and not g.unitTesting
        at = self ; c = at.c
        if trace: scanAtPathDirectivesCount = c.scanAtPathDirectivesCount
        writtenFiles = [] # Files that might be written again.
        mustAutoSave = False ; atOk = True

        if writeAtFileNodesFlag:
            # Write all nodes in the selected tree.
            p = c.p
            after = p.nodeAfterTree()
        else:
            # Write dirty nodes in the entire outline.
            p =  c.rootPosition()
            after = c.nullPosition()

        #@    &lt;&lt; Clear all orphan bits &gt;&gt;
        #@+node:ekr.20041005105605.148:&lt;&lt; Clear all orphan bits &gt;&gt;
        #@+at 
        #@nonl
        # We must clear these bits because they may have been set on a 
        # previous write.
        # Calls to atFile::write may set the orphan bits in @file nodes.
        # If so, write_Leo_file will write the entire @file tree.
        #@-at
        #@@c

        for v2 in p.self_and_subtree_iter():
            v2.clearOrphan()
        #@-node:ekr.20041005105605.148:&lt;&lt; Clear all orphan bits &gt;&gt;
        #@nl
        atOk = True
        while p and p != after:
            if p.isAnyAtFileNode() or p.isAtIgnoreNode():
                #@            &lt;&lt; handle v's tree &gt;&gt;
                #@+node:ekr.20041005105605.149:&lt;&lt; handle v's tree &gt;&gt;
                if p.isAtIgnoreNode() and not p.isAtAsisFileNode():
                    pathChanged = False
                else:
                    oldPath = at.getPathUa(p)
                    newPath = at.fullPath(p)
                    # if trace: g.trace('p %s\noldPath %s\nnewPath %s' % (
                        # p.h,repr(oldPath),repr(newPath)))
                    pathChanged = oldPath and oldPath != newPath
                    if pathChanged:
                        at.setPathUa(p,newPath) # Remember that we have changed paths.
                        g.es_print('path changed for',p.h,color='blue')

                if p.v.isDirty() or pathChanged or writeAtFileNodesFlag or p.v.t in writtenFiles:

                    at.fileChangedFlag = False
                    autoSave = False

                    # Tricky: @ignore not recognised in @silentfile nodes.
                    if p.isAtAsisFileNode():
                        at.asisWrite(p,toString=toString)
                        writtenFiles.append(p.v.t) ; autoSave = True
                    elif p.isAtIgnoreNode():
                        pass
                    elif p.isAtAutoNode():
                        at.writeOneAtAutoNode(p,toString=toString,force=False)
                        writtenFiles.append(p.v.t) # No need for autosave
                    elif p.isAtEditNode():
                        at.writeOneAtEditNode(p,toString=toString)
                        writtenFiles.append(p.v.t) # No need for autosave
                    elif p.isAtNorefFileNode():
                        at.norefWrite(p,toString=toString)
                        writtenFiles.append(p.v.t) ; autoSave = True
                    elif p.isAtNoSentFileNode():
                        at.write(p,nosentinels=True,toString=toString)
                        writtenFiles.append(p.v.t) # No need for autosave
                    elif p.isAtShadowFileNode():
                        at.writeOneAtShadowNode(p,toString=toString,force=False or pathChanged)
                        writtenFiles.append(p.v.t) ; autoSave = True # 2008/7/29
                    elif p.isAtThinFileNode():
                        at.write(p,thinFile=True,toString=toString)
                        writtenFiles.append(p.v.t) # No need for autosave.
                    elif p.isAtFileNode():
                        at.write(p,toString=toString)
                        writtenFiles.append(p.v.t) ; autoSave = True

                    if at.errors: atOk = False

                    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
                        mustAutoSave = True
                #@-node:ekr.20041005105605.149:&lt;&lt; handle v's tree &gt;&gt;
                #@nl
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()

        #@    &lt;&lt; say the command is finished &gt;&gt;
        #@+middle:ekr.20041005105605.149:&lt;&lt; handle v's tree &gt;&gt;
        #@+node:ekr.20041005105605.150:&lt;&lt; say the command is finished &gt;&gt;
        if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
            if len(writtenFiles) &gt; 0:
                g.es("finished")
            elif writeAtFileNodesFlag:
                g.es("no @file nodes in the selected tree")
            else:
                g.es("no dirty @file nodes")
        #@-node:ekr.20041005105605.150:&lt;&lt; say the command is finished &gt;&gt;
        #@-middle:ekr.20041005105605.149:&lt;&lt; handle v's tree &gt;&gt;
        #@nl
        if trace: g.trace('%s calls to c.scanAtPathDirectives()' % (
            c.scanAtPathDirectivesCount-scanAtPathDirectivesCount))
        return mustAutoSave,atOk
    #@-node:ekr.20041005105605.147:writeAll (atFile)
    #@+node:ekr.20070806105859:writeAtAutoNodes &amp; writeDirtyAtAutoNodes (atFile) &amp; helpers
    def writeAtAutoNodes (self,event=None):

        '''Write all @auto nodes in the selected outline.'''

        at = self
        at.writeAtAutoNodesHelper(writeDirtyOnly=False)

    def writeDirtyAtAutoNodes (self,event=None):

        '''Write all dirty @auto nodes in the selected outline.'''

        at = self
        at.writeAtAutoNodesHelper(writeDirtyOnly=True)
    #@nonl
    #@+node:ekr.20070806140208:writeAtAutoNodesHelper
    def writeAtAutoNodesHelper(self,toString=False,writeDirtyOnly=True):

        """Write @auto nodes in the selected outline"""

        at = self ; c = at.c
        p = c.p ; after = p.nodeAfterTree()
        found = False

        while p and p != after:
            if p.isAtAutoNode() and not p.isAtIgnoreNode() and (p.isDirty() or not writeDirtyOnly):
                ok = at.writeOneAtAutoNode(p,toString=toString,force=True)
                if ok:
                    found = True
                    p.moveToNodeAfterTree()
                else:
                    p.moveToThreadNext()
            else:
                p.moveToThreadNext()

        if found:
            g.es("finished")
        elif writeDirtyOnly:
            g.es("no dirty @auto nodes in the selected tree")
        else:
            g.es("no @auto nodes in the selected tree")
    #@-node:ekr.20070806140208:writeAtAutoNodesHelper
    #@+node:ekr.20070806141607:writeOneAtAutoNode &amp; helpers (atFile)
    def writeOneAtAutoNode(self,p,toString,force):

        '''Write p, an @auto node.

        File indices *must* have already been assigned.'''

        at = self ; c = at.c ; root = p.copy()

        fileName = p.atAutoNodeName()
        if not fileName and not toString: return False

        at.scanDefaultDirectory(p,importing=True) # Set default_directory
        fileName = c.os_path_finalize_join(at.default_directory,fileName)
        exists = g.os_path_exists(fileName)

        if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
            return False

        # This code is similar to code in at.write.
        c.endEditing() # Capture the current headline.
        at.targetFileName = g.choose(toString,"&lt;string-file&gt;",fileName)
        at.initWriteIvars(root,at.targetFileName,
            atAuto=True,
            nosentinels=True,thinFile=False,scriptWrite=False,
            toString=toString)

        ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
        if ok:
            if root.isAtAutoRstNode():
                c.rstCommands.writeAtAutoFile(root,fileName,self.outputFile)
            else:
                at.writeOpenFile(root,nosentinels=True,toString=toString)
            at.closeWriteFile() # Sets stringOutput if toString is True.
            if at.errors == 0:
                at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
            else:
                g.es("not written:",at.outputFileName)
                root.setDirty() # New in Leo 4.4.8.

        elif not toString:
            root.setDirty() # Make _sure_ we try to rewrite this file.
            g.es("not written:",at.outputFileName)

        return ok
    #@+node:ekr.20071019141745:shouldWriteAtAutoNode
    #@+at 
    #@nonl
    # Much thought went into this decision tree:
    # 
    # - We do not want decisions to depend on past history.  That's too 
    # confusing.
    # - We must ensure that the file will be written if the user does 
    # significant work.
    # - We must ensure that the user can create an @auto x node at any time
    #   without risk of of replacing x with empty or insignificant 
    # information.
    # - We want the user to be able to create an @auto node which will be 
    # populated the next time the .leo file is opened.
    # - We don't want minor import imperfections to be written to the @auto 
    # file.
    # - The explicit commands that read and write @auto trees must always be 
    # honored.
    #@-at
    #@@c

    def shouldWriteAtAutoNode (self,p,exists,force):

        '''Return True if we should write the @auto node at p.'''

        if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
            return True
        elif not exists: # We can write a non-existent file without danger.
            return True
        elif not p.isDirty(): # There is nothing new to write.
            return False
        elif not self.isSignificantTree(p): # There is noting of value to write.
            g.es_print(p.h,'not written:',color='red')
            g.es_print('no children and less than 10 characters (excluding directives)',color='red')
            return False
        else: # The @auto tree is dirty and contains significant info.
            return True
    #@-node:ekr.20071019141745:shouldWriteAtAutoNode
    #@-node:ekr.20070806141607:writeOneAtAutoNode &amp; helpers (atFile)
    #@-node:ekr.20070806105859:writeAtAutoNodes &amp; writeDirtyAtAutoNodes (atFile) &amp; helpers
    #@+node:ekr.20090225080846.5:writeOneAtEditNode
    # Similar to writeOneAtAutoNode.

    def writeOneAtEditNode(self,p,toString,force=False):

        '''Write p, an @edit node.

        File indices *must* have already been assigned.'''

        at = self ; c = at.c ; root = p.copy()

        fn = p.atEditNodeName()

        if fn:
            at.scanDefaultDirectory(p,importing=True) # Set default_directory
            fn = c.os_path_finalize_join(at.default_directory,fn)
            exists = g.os_path_exists(fn)
            if not self.shouldWriteAtEditNode(p,exists,force):
                return False
        elif not toString:
            return False

        # This code is similar to code in at.write.
        c.endEditing() # Capture the current headline.
        at.targetFileName = g.choose(toString,"&lt;string-file&gt;",fn)
        at.initWriteIvars(root,at.targetFileName,
            atAuto=True,
            atEdit=True,
            nosentinels=True,thinFile=False,scriptWrite=False,
            toString=toString)

        ok = at.openFileForWriting(root,fileName=fn,toString=toString)
        if ok:
            at.writeOpenFile(root,nosentinels=True,toString=toString)
            at.closeWriteFile() # Sets stringOutput if toString is True.
            if at.errors == 0:
                at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
            else:
                g.es("not written:",at.outputFileName)
                root.setDirty()

        elif not toString:
            root.setDirty() # Make _sure_ we try to rewrite this file.
            g.es("not written:",at.outputFileName)

        return ok
    #@+node:ekr.20090225080846.6:shouldWriteAtEditNode
    #@+at 
    #@nonl
    # Much thought went into this decision tree:
    # 
    # - We do not want decisions to depend on past history.  That's too 
    # confusing.
    # - We must ensure that the file will be written if the user does 
    # significant work.
    # - We must ensure that the user can create an @edit x node at any time
    #   without risk of of replacing x with empty or insignificant 
    # information.
    # - We want the user to be able to create an @edit node which will be read
    #   the next time the .leo file is opened.
    # - We don't want minor import imperfections to be written to the @edit 
    # file.
    # - The explicit commands that read and write @edit trees must always be 
    # honored.
    #@-at
    #@@c

    def shouldWriteAtEditNode (self,p,exists,force):

        '''Return True if we should write the @auto node at p.'''

        if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
            return True
        elif not exists: # We can write a non-existent file without danger.
            return True
        elif not p.isDirty(): # There is nothing new to write.
            return False
        elif not self.isSignificantTree(p): # There is noting of value to write.
            g.es_print(p.h,'not written:',color='red')
            g.es_print('no children and less than 10 characters (excluding directives)',color='red')
            return False
        else: # The @auto tree is dirty and contains significant info.
            return True
    #@-node:ekr.20090225080846.6:shouldWriteAtEditNode
    #@-node:ekr.20090225080846.5:writeOneAtEditNode
    #@+node:ekr.20080711093251.3:writeAtShadowdNodes &amp; writeDirtyAtShadowNodes (atFile) &amp; helpers
    def writeAtShadowNodes (self,event=None):

        '''Write all @shadow nodes in the selected outline.'''

        at = self
        return at.writeAtShadowNodesHelper(writeDirtyOnly=False)

    def writeDirtyAtShadowNodes (self,event=None):

        '''Write all dirty @shadow nodes in the selected outline.'''

        at = self
        return at.writeAtShadowNodesHelper(writeDirtyOnly=True)
    #@nonl
    #@+node:ekr.20080711093251.4:writeAtShadowNodesHelper
    def writeAtShadowNodesHelper(self,toString=False,writeDirtyOnly=True):

        """Write @shadow nodes in the selected outline"""

        at = self ; c = at.c
        p = c.p ; after = p.nodeAfterTree()
        found = False

        while p and p != after:
            if p.atShadowFileNodeName() and not p.isAtIgnoreNode() and (p.isDirty() or not writeDirtyOnly):
                ok = at.writeOneAtShadowNode(p,toString=toString,force=True)
                if ok:
                    found = True
                    g.es('wrote %s' % p.atShadowFileNodeName(),color='blue')
                    p.moveToNodeAfterTree()
                else:
                    p.moveToThreadNext()
            else:
                p.moveToThreadNext()

        if found:
            g.es("finished")
        elif writeDirtyOnly:
            g.es("no dirty @shadow nodes in the selected tree")
        else:
            g.es("no @shadow nodes in the selected tree")

        return found
    #@-node:ekr.20080711093251.4:writeAtShadowNodesHelper
    #@+node:ekr.20080711093251.5:writeOneAtShadowNode &amp; helpers &amp; tests
    def writeOneAtShadowNode(self,p,toString,force):

        '''Write p, an @shadow node.

        File indices *must* have already been assigned.'''

        trace = False and not g.unitTesting
        at = self ; c = at.c ; root = p.copy() ; x = c.shadowController

        fn = p.atShadowFileNodeName()
        if not fn:
            g.es_print('can not happen: not an @shadow node',p.h,color='red')
            return False

        # A hack to support unknown extensions.
        self.adjustTargetLanguage(fn) # May set c.target_language.

        fn = at.fullPath(p)
        at.default_directory = g.os_path_dirname(fn)
        exists = g.os_path_exists(fn)
        if trace: g.trace('exists %s fn %s' % (exists,fn))

        if not toString and not self.shouldWriteAtShadowNode(p,exists,force,fn):
            if trace: g.trace('ignoring',fn)
            return False

        c.endEditing() # Capture the current headline.
        at.initWriteIvars(root,targetFileName=None, # Not used.
            atShadow=True,
            nosentinels=None, # set below.  Affects only error messages (sometimes).
            thinFile=True, # New in Leo 4.5 b2: private files are thin files.
            scriptWrite=False,
            toString=False, # True: create a fileLikeObject.  This is done below.
            forcePythonSentinels=True) # A hack to suppress an error message.
                # The actual sentinels will be set below.

        # Bug fix: Leo 4.5.1: use x.markerFromFileName to force the delim to match
        #                     what is used in x.propegate changes.
        marker = x.markerFromFileName(fn)
        at.startSentinelComment,at.endSentinelComment=marker.getDelims()

        if g.app.unitTesting: ivars_dict = g.getIvarsDict(at)

        # Write the public and private files to public_s and private_s strings.
        data = []
        for sentinels in (False,True):
            theFile = at.openStringFile(fn)
            at.sentinels = sentinels
            at.writeOpenFile(root,
                nosentinels=not sentinels,toString=False)
                # nosentinels only affects error messages, and then only if atAuto is True.
            s = at.closeStringFile(theFile)
            data.append(s)

        # Set these new ivars for unit tests.
        at.public_s, at.private_s = data

        if g.app.unitTesting:
            exceptions = ('public_s','private_s','sentinels','stringOutput')
            assert g.checkUnchangedIvars(at,ivars_dict,exceptions)

        if at.errors == 0 and not toString:
            # Write the public and private files.
            private_fn = x.shadowPathName(fn)
            x.makeShadowDirectory(fn) # makeShadowDirectory takes a *public* file name.
            at.replaceFileWithString(private_fn,at.private_s)
            at.replaceFileWithString(fn,at.public_s)

        self.checkPythonCode(root,s=at.private_s,targetFn=fn)

        if at.errors == 0:
            root.clearOrphan()
            root.clearDirty()
        else:
            g.es("not written:",at.outputFileName,color='red')
            root.setDirty() # New in Leo 4.4.8.

        return at.errors == 0
    #@+node:ekr.20080711093251.6:shouldWriteAtShadowNode
    #@+at 
    #@nonl
    # Much thought went into this decision tree:
    # 
    # - We do not want decisions to depend on past history.  That's too 
    # confusing.
    # - We must ensure that the file will be written if the user does 
    # significant work.
    # - We must ensure that the user can create an @shadow x node at any time
    #   without risk of of replacing x with empty or insignificant 
    # information.
    # - We want the user to be able to create an @shadow node which will be 
    # populated the next time the .leo file is opened.
    # - We don't want minor import imperfections to be written to the @shadow 
    # file.
    # - The explicit commands that read and write @shadow trees must always be 
    # honored.
    #@-at
    #@@c

    def shouldWriteAtShadowNode (self,p,exists,force,fn):

        '''Return True if we should write the @shadow node at p.'''

        at = self ; x = at.c.shadowController

        if force: # We are executing write-at-shadow-node or write-dirty-at-shadow-nodes.
            return True
        elif not exists: # We can write a non-existent file without danger.
            return True
        elif not p.isDirty(): # There is nothing new to write.
            return False
        elif not self.isSignificantTree(p): # There is noting of value to write.
            g.es_print(p.h,'not written:',color='red')
            g.es_print('no children and less than 10 characters (excluding directives)',color='red')
            return False
        else: # The @shadow tree is dirty and contains significant info.
            return True
    #@-node:ekr.20080711093251.6:shouldWriteAtShadowNode
    #@+node:ekr.20080819075811.13:adjustTargetLanguage
    def adjustTargetLanguage (self,fn):

        """Use the language implied by fn's extension if
        there is a conflict between it and c.target_language."""

        at = self ; c = at.c

        if c.target_language:
            junk,target_ext = g.os_path_splitext(fn)  
        else:
            target_ext = ''

        junk,ext = g.os_path_splitext(fn)

        if ext:
            if ext.startswith('.'): ext = ext[1:]

            language = g.app.extension_dict.get(ext)
            if language:
                c.target_language = language
            else:
                # An unknown language.
                pass # Use the default language, **not** 'unknown_language'
    #@-node:ekr.20080819075811.13:adjustTargetLanguage
    #@-node:ekr.20080711093251.5:writeOneAtShadowNode &amp; helpers &amp; tests
    #@-node:ekr.20080711093251.3:writeAtShadowdNodes &amp; writeDirtyAtShadowNodes (atFile) &amp; helpers
    #@+node:ekr.20050506084734:writeFromString
    # This is at.write specialized for scripting.

    def writeFromString(self,root,s,forcePythonSentinels=True,useSentinels=True):

        """Write a 4.x derived file from a string.

        This is used by the scripting logic."""

        at = self ; c = at.c
        c.endEditing() # Capture the current headline, but don't change the focus!

        at.initWriteIvars(root,"&lt;string-file&gt;",
            nosentinels=not useSentinels,thinFile=False,scriptWrite=True,toString=True,
            forcePythonSentinels=forcePythonSentinels)

        try:
            ok = at.openFileForWriting(root,at.targetFileName,toString=True)
            if g.app.unitTesting: assert ok # string writes never fail.
            # Simulate writing the entire file so error recovery works.
            at.writeOpenFile(root,nosentinels=not useSentinels,toString=True,fromString=s)
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            if root:
                root.v.t.tnodeList = []
                root.v.t._p_changed = True
        except Exception:
            at.exception("exception preprocessing script")

        return at.stringOutput
    #@-node:ekr.20050506084734:writeFromString
    #@+node:ekr.20041005105605.151:writeMissing
    def writeMissing(self,p,toString=False):

        at = self ; c = at.c
        writtenFiles = False ; changedFiles = False

        p = p.copy()
        after = p.nodeAfterTree()
        while p and p != after: # Don't use iterator.
            if p.isAtAsisFileNode() or (p.isAnyAtFileNode() and not p.isAtIgnoreNode()):
                at.targetFileName = p.anyAtFileNodeName()
                if at.targetFileName:
                    at.targetFileName = c.os_path_finalize_join(
                        self.default_directory,at.targetFileName)
                    if not g.os_path_exists(at.targetFileName):
                        ok = at.openFileForWriting(p,at.targetFileName,toString)
                        # openFileForWriting calls p.setDirty() if there are errors.
                        if ok:
                            #@                        &lt;&lt; write the @file node &gt;&gt;
                            #@+node:ekr.20041005105605.152:&lt;&lt; write the @file node &gt;&gt;
                            if p.isAtAsisFileNode():
                                at.asisWrite(p)
                            elif p.isAtNorefFileNode():
                                at.norefWrite(p)
                            elif p.isAtNoSentFileNode():
                                at.write(p,nosentinels=True)
                            elif p.isAtFileNode():
                                at.write(p)
                            else: assert(0)

                            writtenFiles = True

                            if at.fileChangedFlag: # Set by replaceTargetFileIfDifferent.
                                changedFiles = True
                            #@-node:ekr.20041005105605.152:&lt;&lt; write the @file node &gt;&gt;
                            #@nl
                            at.closeWriteFile()
                p.moveToNodeAfterTree()
            elif p.isAtIgnoreNode():
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()

        if writtenFiles &gt; 0:
            g.es("finished")
        else:
            g.es("no @file node in the selected tree")

        return changedFiles # So caller knows whether to do an auto-save.
    #@-node:ekr.20041005105605.151:writeMissing
    #@-node:ekr.20041005105605.134:Don't override in plugins
    #@+node:ekr.20041005105605.153:Override in plugins...
    #@+at
    # 
    # All writing eventually goes through the asisWrite or writeOpenFile 
    # methods, so
    # plugins should need only to override these two methods.
    # 
    # In particular, plugins should not need to override the write, writeAll 
    # or
    # writeMissing methods.
    #@-at
    #@+node:ekr.20041005105605.154:asisWrite
    def asisWrite(self,root,toString=False):

        at = self ; c = at.c
        c.endEditing() # Capture the current headline.

        try:
            targetFileName = root.atAsisFileNodeName()
            at.initWriteIvars(root,targetFileName,toString=toString)
            if at.errors: return
            if not at.openFileForWriting(root,targetFileName,toString):
                # openFileForWriting calls root.setDirty() if there are errors.
                return
            for p in root.self_and_subtree_iter():
                #@            &lt;&lt; Write p's headline if it starts with @@ &gt;&gt;
                #@+node:ekr.20041005105605.155:&lt;&lt; Write p's headline if it starts with @@ &gt;&gt;
                s = p.h

                if g.match(s,0,"@@"):
                    s = s[2:]
                    if s and len(s) &gt; 0:
                        s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
                        at.outputFile.write(s)
                #@-node:ekr.20041005105605.155:&lt;&lt; Write p's headline if it starts with @@ &gt;&gt;
                #@nl
                #@            &lt;&lt; Write p's body &gt;&gt;
                #@+node:ekr.20041005105605.156:&lt;&lt; Write p's body &gt;&gt;
                s = p.b

                if s:
                    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
                    at.outputStringWithLineEndings(s)
                #@-node:ekr.20041005105605.156:&lt;&lt; Write p's body &gt;&gt;
                #@nl
            at.closeWriteFile()
            at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
        except Exception:
            at.writeException(root) # Sets dirty and orphan bits.

    silentWrite = asisWrite # Compatibility with old scripts.
    #@-node:ekr.20041005105605.154:asisWrite
    #@+node:ekr.20041005105605.157:writeOpenFile
    # New in 4.3: must be inited before calling this method.
    # New in 4.3 b2: support for writing from a string.

    def writeOpenFile(self,root,
        nosentinels=False,toString=False,fromString=''):

        """Do all writes except asis writes."""

        at = self ; s = g.choose(fromString,fromString,root.v.t._bodyString)

        root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
        root.clearVisitedInTree()

        at.putAtFirstLines(s)
        at.putOpenLeoSentinel("@+leo-ver=4")
        at.putInitialComment()
        at.putOpenNodeSentinel(root)
        at.putBody(root,fromString=fromString)
        at.putCloseNodeSentinel(root)
        at.putSentinel("@-leo")
        root.setVisited()
        at.putAtLastLines(s)

        if self.atAuto or (not toString and not nosentinels):
            at.warnAboutOrphandAndIgnoredNodes()
    #@-node:ekr.20041005105605.157:writeOpenFile
    #@-node:ekr.20041005105605.153:Override in plugins...
    #@-node:ekr.20041005105605.133:Writing (top level)
    #@+node:ekr.20041005105605.160:Writing 4.x
    #@+node:ekr.20041005105605.161:putBody
    # oneNodeOnly is no longer used, but it might be used in the future?

    def putBody(self,p,oneNodeOnly=False,fromString=''):

        """ Generate the body enclosed in sentinel lines."""

        at = self

        # New in 4.3 b2: get s from fromString if possible.
        s = g.choose(fromString,fromString,p.b)

        p.v.t.setVisited() # Suppress orphans check.
        p.v.setVisited() # Make sure v is never expanded again.
        if not at.thinFile:
            p.v.t.setWriteBit() # Mark the tnode to be written.
        if not at.thinFile and not s: return

        inCode = True
        #@    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
        #@+node:ekr.20041005105605.162:&lt;&lt; Make sure all lines end in a newline &gt;&gt;
        #@+at
        # 
        # If we add a trailing newline, we'll generate an @nonl sentinel 
        # below.
        # 
        # - We always ensure a newline in @file and @thin trees.
        # - This code is not used used in @asis trees.
        # - New in Leo 4.4.3 b1: We add a newline in @nosent trees unless
        #   @bool force_newlines_in_at_nosent_bodies = False
        #@-at
        #@@c

        if s:
            trailingNewlineFlag = s[-1] == '\n'
            if not trailingNewlineFlag:
                if (at.sentinels or 
                    (not at.atAuto and at.force_newlines_in_at_nosent_bodies)
                ):
                    # g.trace('Added newline',repr(s))
                    s = s + '\n'
        else:
            trailingNewlineFlag = True # don't need to generate an @nonl
        #@-node:ekr.20041005105605.162:&lt;&lt; Make sure all lines end in a newline &gt;&gt;
        #@nl
        s = self.cleanLines(p,s)
        i = 0
        while i &lt; len(s):
            next_i = g.skip_line(s,i)
            assert(next_i &gt; i)
            kind = at.directiveKind4(s,i)
            #@        &lt;&lt; handle line at s[i] &gt;&gt;
            #@+node:ekr.20041005105605.163:&lt;&lt; handle line at s[i]  &gt;&gt;
            # g.trace(kind,repr(s[i:next_i]))

            if kind == at.noDirective:
                if not oneNodeOnly:
                    if inCode:
                        hasRef,n1,n2 = at.findSectionName(s,i)
                        if hasRef and not at.raw:
                            at.putRefLine(s,i,n1,n2,p)
                        else:
                            at.putCodeLine(s,i)
                    else:
                        at.putDocLine(s,i)
            elif kind in (at.docDirective,at.atDirective):
                assert(not at.pending)
                if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
                    at.putEndDocLine() 
                at.putStartDocLine(s,i,kind)
                inCode = False
            elif kind in (at.cDirective,at.codeDirective):
                # Only @c and @code end a doc part.
                if not inCode:
                    at.putEndDocLine() 
                at.putDirective(s,i)
                inCode = True
            elif kind == at.allDirective:
                if not oneNodeOnly:
                    if inCode: at.putAtAllLine(s,i,p)
                    else: at.putDocLine(s,i)
            elif kind == at.othersDirective:
                if not oneNodeOnly:
                    if inCode: at.putAtOthersLine(s,i,p)
                    else: at.putDocLine(s,i)
            elif kind == at.rawDirective:
                at.raw = True
                at.putSentinel("@@raw")
            elif kind == at.endRawDirective:
                at.raw = False
                at.putSentinel("@@end_raw")
                i = g.skip_line(s,i)
            elif kind == at.startVerbatim:
                at.putSentinel("@verbatim")
                at.putIndent(at.indent)
                i = next_i
                next_i = g.skip_line(s,i)
                at.os(s[i:next_i])
            elif kind == at.miscDirective:
                # g.trace('miscDirective')
                at.putDirective(s,i)
            else:
                assert(0) # Unknown directive.
            #@-node:ekr.20041005105605.163:&lt;&lt; handle line at s[i]  &gt;&gt;
            #@nl
            i = next_i
        if not inCode:
            at.putEndDocLine()
        if not trailingNewlineFlag:
            if at.sentinels:
                at.putSentinel("@nonl")
            elif at.atAuto and not at.atEdit:
                # New in Leo 4.6 rc1: ensure all @auto nodes end in a newline!
                at.onl()

    #@-node:ekr.20041005105605.161:putBody
    #@+node:ekr.20041005105605.164:writing code lines...
    #@+node:ekr.20041005105605.165:@all
    #@+node:ekr.20041005105605.166:putAtAllLine
    def putAtAllLine (self,s,i,p):

        """Put the expansion of @others."""

        at = self
        j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
        at.putLeadInSentinel(s,i,j,delta)

        at.indent += delta
        if at.leadingWs:
            at.putSentinel("@" + at.leadingWs + "@+all")
        else:
            at.putSentinel("@+all")

        for child in p.children_iter():
            at.putAtAllChild(child)

        at.putSentinel("@-all")
        at.indent -= delta
    #@-node:ekr.20041005105605.166:putAtAllLine
    #@+node:ekr.20041005105605.167:putatAllBody
    def putAtAllBody(self,p):

        """ Generate the body enclosed in sentinel lines."""

        at = self ; s = p.b

        p.v.setVisited()   # Make sure v is never expanded again.
        p.v.t.setVisited() # Use the tnode for the orphans check.
        if not at.thinFile and not s: return
        inCode = True
        #@    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
        #@+node:ekr.20041005105605.168:&lt;&lt; Make sure all lines end in a newline &gt;&gt;
        # 11/20/03: except in nosentinel mode.
        # 1/30/04: and especially in scripting mode.
        # If we add a trailing newline, we'll generate an @nonl sentinel below.

        if s:
            trailingNewlineFlag = s and s[-1] == '\n'
            if at.sentinels and not trailingNewlineFlag:
                s = s + '\n'
        else:
            trailingNewlineFlag = True # don't need to generate an @nonl
        #@-node:ekr.20041005105605.168:&lt;&lt; Make sure all lines end in a newline &gt;&gt;
        #@nl
        i = 0
        while i &lt; len(s):
            next_i = g.skip_line(s,i)
            assert(next_i &gt; i)
            if inCode:
                # Use verbatim sentinels to write all directives.
                at.putCodeLine(s,i)
            else:
                at.putDocLine(s,i)
            i = next_i

        if not inCode:
            at.putEndDocLine()
        if at.sentinels and not trailingNewlineFlag:
            at.putSentinel("@nonl")
    #@-node:ekr.20041005105605.167:putatAllBody
    #@+node:ekr.20041005105605.169:putAtAllChild
    #@+at
    # This code puts only the first of two or more cloned siblings, preceding 
    # the
    # clone with an @clone n sentinel.
    # 
    # This is a debatable choice: the cloned tree appears only once in the 
    # derived
    # file. This should be benign; the text created by @all is likely to be 
    # used only
    # for recreating the outline in Leo. The representation in the derived 
    # file
    # doesn't matter much.
    #@-at
    #@@c

    def putAtAllChild(self,p):

        at = self

        parent_v = p._parentVnode()
        clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(parent_v,p.v)
        if clonedSibs &gt; 1:
            if thisClonedSibIndex == 1:
                at.putSentinel("@clone %d" % (clonedSibs))
            else: return # Don't write second or greater trees.

        at.putOpenNodeSentinel(p,inAtAll=True) # Suppress warnings about @file nodes.
        at.putAtAllBody(p) 

        for child in p.children_iter():
            at.putAtAllChild(child)

        at.putCloseNodeSentinel(p)
    #@-node:ekr.20041005105605.169:putAtAllChild
    #@-node:ekr.20041005105605.165:@all
    #@+node:ekr.20041005105605.170:@others
    #@+node:ekr.20041005105605.171:inAtOthers
    def inAtOthers(self,p):

        """Returns True if p should be included in the expansion of the at-others directive

        in the body text of p's parent."""

        # Return False if this has been expanded previously.
        if  p.v.isVisited():
            # g.trace("previously visited",p.v)
            return False

        # Return False if this is a definition node.
        h = p.h ; i = g.skip_ws(h,0)
        isSection,junk = self.isSectionName(h,i)
        if isSection:
            # g.trace("is section",p)
            return False

        # Return False if p's body contains an @ignore directive.
        if p.isAtIgnoreNode():
            # g.trace("is @ignore",p)
            return False
        else:
            # g.trace("ok",p)
            return True
    #@-node:ekr.20041005105605.171:inAtOthers
    #@+node:ekr.20041005105605.172:putAtOthersChild
    def putAtOthersChild(self,p):

        at = self

        parent_v = p._parentVnode()
        clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(parent_v,p.v)
        if clonedSibs &gt; 1 and thisClonedSibIndex == 1:
            at.writeError("Cloned siblings are not valid in @thin trees")

        at.putOpenNodeSentinel(p)
        at.putBody(p) 

        # Insert expansions of all children.
        for child in p.children_iter():
            if at.inAtOthers(child):
                at.putAtOthersChild(child)

        at.putCloseNodeSentinel(p)
    #@-node:ekr.20041005105605.172:putAtOthersChild
    #@+node:ekr.20041005105605.173:putAtOthersLine
    def putAtOthersLine (self,s,i,p):

        """Put the expansion of @others."""

        at = self
        j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
        at.putLeadInSentinel(s,i,j,delta)

        at.indent += delta
        if at.leadingWs:
            at.putSentinel("@" + at.leadingWs + "@+others")
        else:
            at.putSentinel("@+others")

        for child in p.children_iter():
            if at.inAtOthers(child):
                at.putAtOthersChild(child)

        at.putSentinel("@-others")
        at.indent -= delta
    #@-node:ekr.20041005105605.173:putAtOthersLine
    #@-node:ekr.20041005105605.170:@others
    #@+node:ekr.20041005105605.174:putCodeLine (leoAtFile)
    def putCodeLine (self,s,i):

        '''Put a normal code line.'''

        trace = False and not g.unitTesting
        at = self

        # Put @verbatim sentinel if required.
        k = g.skip_ws(s,i)
        if g.match(s,k,self.startSentinelComment + '@'):
            self.putSentinel('@verbatim')

        j = g.skip_line(s,i)
        line = s[i:j]

        if trace: g.trace(self.atShadow,repr(line))

        # Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent,line)

            if line[-1:]=='\n':
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace('Can not happen: completely empty line')

    #@-node:ekr.20041005105605.174:putCodeLine (leoAtFile)
    #@+node:ekr.20041005105605.175:putRefLine &amp; allies
    #@+node:ekr.20041005105605.176:putRefLine
    def putRefLine(self,s,i,n1,n2,p):

        """Put a line containing one or more references."""

        at = self

        # Compute delta only once.
        delta = self.putRefAt(s,i,n1,n2,p,delta=None)
        if delta is None: return # 11/23/03

        while 1:
            i = n2 + 2
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef:
                self.putAfterMiddleRef(s,i,n1,delta)
                self.putRefAt(s,n1,n1,n2,p,delta)
            else:
                break

        self.putAfterLastRef(s,i,delta)
    #@-node:ekr.20041005105605.176:putRefLine
    #@+node:ekr.20041005105605.177:putRefAt
    def putRefAt (self,s,i,n1,n2,p,delta):

        """Put a reference at s[n1:n2+2] from p."""

        at = self ; c = at.c ; name = s[n1:n2+2]

        ref = g.findReference(c,name,p)
        if not ref:
            if not g.unitTesting:
                at.writeError(
                    "undefined section: %s\n\treferenced from: %s" %
                        ( name,p.h))
            return None

        # Expand the ref.
        if not delta:
            junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

        at.putLeadInSentinel(s,i,n1,delta)

        inBetween = []
        if at.thinFile: # @+-middle used only in thin files.
            parent = ref.parent()
            while parent != p:
                inBetween.append(parent)
                parent = parent.parent()

        at.indent += delta

        if at.leadingWs:
            at.putSentinel("@" + at.leadingWs + name)
        else:
            at.putSentinel("@" + name)

        if inBetween:
            # Bug fix: reverse the +middle sentinels, not the -middle sentinels.
            inBetween.reverse()
            for p2 in inBetween:
                at.putOpenNodeSentinel(p2,middle=True)

        at.putOpenNodeSentinel(ref)
        at.putBody(ref)
        at.putCloseNodeSentinel(ref)

        if inBetween:
            inBetween.reverse()
            for p2 in inBetween:
                at.putCloseNodeSentinel(p2,middle=True)

        at.indent -= delta

        return delta
    #@-node:ekr.20041005105605.177:putRefAt
    #@+node:ekr.20041005105605.178:putAfterLastRef
    def putAfterLastRef (self,s,start,delta):

        """Handle whatever follows the last ref of a line."""

        at = self

        j = g.skip_ws(s,start)

        if j &lt; len(s) and s[j] != '\n':
            end = g.skip_line(s,start)
            after = s[start:end] # Ends with a newline only if the line did.
            # Temporarily readjust delta to make @afterref look better.
            at.indent += delta
            at.putSentinel("@afterref")
            at.os(after)
            if at.sentinels and after and after[-1] != '\n':
                at.onl() # Add a newline if the line didn't end with one.
            at.indent -= delta
        else:
            # Temporarily readjust delta to make @nl look better.
            at.indent += delta
            at.putSentinel("@nl")
            at.indent -= delta
    #@-node:ekr.20041005105605.178:putAfterLastRef
    #@+node:ekr.20041005105605.179:putAfterMiddleef
    def putAfterMiddleRef (self,s,start,end,delta):

        """Handle whatever follows a ref that is not the last ref of a line."""

        at = self

        if start &lt; end:
            after = s[start:end]
            at.indent += delta
            at.putSentinel("@afterref")
            at.os(after) ; at.onl_sent() # Not a real newline.
            at.putSentinel("@nonl")
            at.indent -= delta
    #@-node:ekr.20041005105605.179:putAfterMiddleef
    #@-node:ekr.20041005105605.175:putRefLine &amp; allies
    #@-node:ekr.20041005105605.164:writing code lines...
    #@+node:ekr.20041005105605.180:writing doc lines...
    #@+node:ekr.20041005105605.181:putBlankDocLine
    def putBlankDocLine (self):

        at = self

        at.putPending(split=False)

        if not at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.oblank()

        at.onl()
    #@-node:ekr.20041005105605.181:putBlankDocLine
    #@+node:ekr.20041005105605.182:putStartDocLine
    def putStartDocLine (self,s,i,kind):

        """Write the start of a doc part."""

        at = self ; at.docKind = kind

        sentinel = g.choose(kind == at.docDirective,"@+doc","@+at")
        directive = g.choose(kind == at.docDirective,"@doc","@")

        if 0: # New code: put whatever follows the directive in the sentinel
            # Skip past the directive.
            i += len(directive)
            j = g.skip_to_end_of_line(s,i)
            follow = s[i:j]

            # Put the opening @+doc or @-doc sentinel, including whatever follows the directive.
            at.putSentinel(sentinel + follow)

            # Put the opening comment if we are using block comments.
            if at.endSentinelComment:
                at.putIndent(at.indent)
                at.os(at.startSentinelComment) ; at.onl()
        else: # old code.
            # Skip past the directive.
            i += len(directive)

            # Get the trailing whitespace.
            j = g.skip_ws(s,i)
            ws = s[i:j]

            # Put the opening @+doc or @-doc sentinel, including trailing whitespace.
            at.putSentinel(sentinel + ws)

            # Put the opening comment.
            if at.endSentinelComment:
                at.putIndent(at.indent)
                at.os(at.startSentinelComment) ; at.onl()

            # Put an @nonl sentinel if there is significant text following @doc or @.
            if not g.is_nl(s,j):
                # Doesn't work if we are using block comments.
                at.putSentinel("@nonl")
                at.putDocLine(s,j)
    #@-node:ekr.20041005105605.182:putStartDocLine
    #@+node:ekr.20041005105605.183:putDocLine
    def putDocLine (self,s,i):

        """Handle one line of a doc part.

        Output complete lines and split long lines and queue pending lines.
        Inserted newlines are always preceded by whitespace."""

        at = self
        j = g.skip_line(s,i)
        s = s[i:j]

        if at.endSentinelComment:
            leading = at.indent
        else:
            leading = at.indent + len(at.startSentinelComment) + 1

        if not s or s[0] == '\n':
            # A blank line.
            at.putBlankDocLine()
        else:
            #@        &lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;
            #@+node:ekr.20041005105605.184:&lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;
            #@+at 
            #@nonl
            # All inserted newlines are preceeded by whitespace:
            # we remove trailing whitespace from lines that have not been 
            # split.
            #@-at
            #@@c

            i = 0
            while i &lt; len(s):

                # Scan to the next word.
                word1 = i # Start of the current word.
                word2 = i = g.skip_ws(s,i)
                while i &lt; len(s) and s[i] not in (' ','\t'):
                    i += 1
                word3 = i = g.skip_ws(s,i)
                # g.trace(s[word1:i])

                if leading + word3 - word1 + len(''.join(at.pending)) &gt;= at.page_width:
                    if at.pending:
                        # g.trace("splitting long line.")
                        # Ouput the pending line, and start a new line.
                        at.putPending(split=True)
                        at.pending = [s[word2:word3]]
                    else:
                        # Output a long word on a line by itself.
                        # g.trace("long word:",s[word2:word3])
                        at.pending = [s[word2:word3]]
                        at.putPending(split=True)
                else:
                    # Append the entire word to the pending line.
                    # g.trace("appending",s[word1:word3])
                    at.pending.append(s[word1:word3])

            # Output the remaining line: no more is left.
            at.putPending(split=False)
            #@-node:ekr.20041005105605.184:&lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;
            #@nl
    #@-node:ekr.20041005105605.183:putDocLine
    #@+node:ekr.20041005105605.185:putEndDocLine
    def putEndDocLine (self):

        """Write the conclusion of a doc part."""

        at = self

        at.putPending(split=False)

        # Put the closing delimiter if we are using block comments.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.endSentinelComment)
            at.onl() # Note: no trailing whitespace.

        sentinel = g.choose(at.docKind == at.docDirective,"@-doc","@-at")
        at.putSentinel(sentinel)
    #@-node:ekr.20041005105605.185:putEndDocLine
    #@+node:ekr.20041005105605.186:putPending
    def putPending (self,split):

        """Write the pending part of a doc part.

        We retain trailing whitespace iff the split flag is True."""

        at = self ; s = ''.join(at.pending) ; at.pending = []

        # g.trace("split",s)

        # Remove trailing newline temporarily.  We'll add it back later.
        if s and s[-1] == '\n':
            s = s[:-1]

        if not split:
            s = s.rstrip()
            if not s:
                return

        at.putIndent(at.indent)

        if not at.endSentinelComment:
            at.os(at.startSentinelComment) ; at.oblank()

        at.os(s) ; at.onl()
    #@-node:ekr.20041005105605.186:putPending
    #@-node:ekr.20041005105605.180:writing doc lines...
    #@-node:ekr.20041005105605.160:Writing 4.x
    #@+node:ekr.20041005105605.187:Writing 4,x sentinels...
    #@+node:ekr.20041005105605.188:nodeSentinelText 4.x
    def nodeSentinelText(self,p):

        """Return the text of a @+node or @-node sentinel for p."""

        at = self ; h = p.h
        #@    &lt;&lt; remove comment delims from h if necessary &gt;&gt;
        #@+node:ekr.20041005105605.189:&lt;&lt; remove comment delims from h if necessary &gt;&gt;
        #@+at 
        #@nonl
        # Bug fix 1/24/03:
        # 
        # If the present @language/@comment settings do not specify a 
        # single-line comment we remove all block comment delims from h.  This 
        # prevents headline text from interfering with the parsing of node 
        # sentinels.
        #@-at
        #@@c

        start = at.startSentinelComment
        end = at.endSentinelComment

        if end and len(end) &gt; 0:
            h = h.replace(start,"")
            h = h.replace(end,"")
        #@-node:ekr.20041005105605.189:&lt;&lt; remove comment delims from h if necessary &gt;&gt;
        #@nl

        if at.thinFile:
            if not p.v.t.fileIndex:
                p.v.t.fileIndex = g.app.nodeIndices.getNewIndex()
            gnx = g.app.nodeIndices.toString(p.v.t.fileIndex)
            return "%s:%s" % (gnx,h)
        else:
            return h
    #@-node:ekr.20041005105605.188:nodeSentinelText 4.x
    #@+node:ekr.20041005105605.190:putLeadInSentinel 4.x
    def putLeadInSentinel (self,s,i,j,delta):

        """Generate @nonl sentinels as needed to ensure a newline before a group of sentinels.

        Set at.leadingWs as needed for @+others and @+&lt;&lt; sentinels.

        i points at the start of a line.
        j points at @others or a section reference.
        delta is the change in at.indent that is about to happen and hasn't happened yet."""

        at = self
        at.leadingWs = "" # Set the default.
        if i == j:
            return # The @others or ref starts a line.

        k = g.skip_ws(s,i)
        if j == k:
            # Only whitespace before the @others or ref.
            at.leadingWs = s[i:j] # Remember the leading whitespace, including its spelling.
        else:
            # g.trace("indent",self.indent)
            self.putIndent(self.indent) # 1/29/04: fix bug reported by Dan Winkler.
            at.os(s[i:j]) ; at.onl_sent() # 10/21/03
            at.indent += delta # Align the @nonl with the following line.
            at.putSentinel("@nonl")
            at.indent -= delta # Let the caller set at.indent permanently.
    #@-node:ekr.20041005105605.190:putLeadInSentinel 4.x
    #@+node:ekr.20041005105605.191:putCloseNodeSentinel 4.x
    def putCloseNodeSentinel(self,p,middle=False):

        at = self

        s = self.nodeSentinelText(p)

        if middle:
            at.putSentinel("@-middle:" + s)
        else:
            at.putSentinel("@-node:" + s)
    #@-node:ekr.20041005105605.191:putCloseNodeSentinel 4.x
    #@+node:ekr.20041005105605.192:putOpenLeoSentinel 4.x
    def putOpenLeoSentinel(self,s):

        """Write @+leo sentinel."""

        at = self

        if not at.sentinels:
            return # Handle @nosentinelsfile.

        if at.thinFile:
            s = s + "-thin"

        encoding = at.encoding.lower()
        if encoding != "utf-8":
            # New in 4.2: encoding fields end in ",."
            s = s + "-encoding=%s,." % (encoding)

        at.putSentinel(s)
    #@-node:ekr.20041005105605.192:putOpenLeoSentinel 4.x
    #@+node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
    def putOpenNodeSentinel(self,p,inAtAll=False,middle=False):

        """Write @+node sentinel for p."""

        at = self

        if not inAtAll and p.isAtFileNode() and p != at.root:
            at.writeError("@file not valid in: " + p.h)
            return

        # g.trace(at.thinFile,p)

        s = at.nodeSentinelText(p)

        if middle:
            at.putSentinel("@+middle:" + s)
        else:
            at.putSentinel("@+node:" + s)

        if not at.thinFile:
            # Append the n'th tnode to the root's tnode list.
            # It may not exist when executing scripts.
            try:
                t = at.root.v.t
                t.tnodeList.append(p.v.t)
                t._p_changed = True
            except AttributeError:
                pass # Do nothing.  We are creating a script.
    #@-node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
    #@+node:ekr.20041005105605.194:putSentinel (applies cweb hack) 4.x
    # This method outputs all sentinels.

    def putSentinel(self,s):

        "Write a sentinel whose text is s, applying the CWEB hack if needed."

        at = self

        if not at.sentinels:
            return # Handle @file-nosent

        at.putIndent(at.indent)
        at.os(at.startSentinelComment)
        #@    &lt;&lt; apply the cweb hack to s &gt;&gt;
        #@+node:ekr.20041005105605.195:&lt;&lt; apply the cweb hack to s &gt;&gt;
        #@+at 
        #@nonl
        # The cweb hack:
        # 
        # If the opening comment delim ends in '@', double all '@' signs 
        # except the first, which is "doubled" by the trailing '@' in the 
        # opening comment delimiter.
        #@-at
        #@@c

        start = at.startSentinelComment
        if start and start[-1] == '@':
            assert(s and s[0]=='@')
            s = s.replace('@','@@')[1:]
        #@-node:ekr.20041005105605.195:&lt;&lt; apply the cweb hack to s &gt;&gt;
        #@nl
        at.os(s)
        if at.endSentinelComment:
            at.os(at.endSentinelComment)
        at.onl()
    #@-node:ekr.20041005105605.194:putSentinel (applies cweb hack) 4.x
    #@-node:ekr.20041005105605.187:Writing 4,x sentinels...
    #@+node:ekr.20041005105605.196:Writing 4.x utils...
    #@+node:ekr.20090514111518.5661:checkPythonCode (leoAtFile) &amp; helpers
    def checkPythonCode (self,root,s=None,targetFn=None):

        c = self.c

        if not targetFn: targetFn = self.targetFileName

        if targetFn and targetFn.endswith('.py') and self.checkPythonCodeOnWrite:
            try:
                if not s: s = open(self.outputFileName).read()
            except IOError:
                g.trace('can not happen',g.callers(4))
                return

            # It's too slow to check each node separately.
            ok = self.checkPythonSyntax(root,s)

            # Syntax checking catches most indentation problems.
            if False and ok: self.tabNannyNode(root,s)
    #@nonl
    #@+node:ekr.20090514111518.5663:checkPythonSyntax (leoAtFile)
    def checkPythonSyntax (self,p,body):

        import compiler,parser

        try:
            ok = True
            compiler.parse(body + '\n')
        except (parser.ParserError,SyntaxError):
            self.syntaxError(p,body)
            # p.setMarked()
            ok = False
        except Exception:
            g.trace("unexpected exception")
            g.es_exception()
            ok = False

        return ok
    #@+node:ekr.20090514111518.5666:syntaxError &amp; test
    def syntaxError(self,p,body):

        g.es_print("Syntax error in: %s" % (p.h),color="red")
        typ,val,tb = sys.exc_info()
        message = hasattr(val,'message') and val.message
        if message: g.es_print(message)
        lines = g.splitLines(body)
        n = val.lineno
        if n is None:
            # for z in dir(val): print z,repr(getattr(val,z))
            return
        i = val.lineno-1
        for j in range(max(0,i-3),min(i+3,len(lines)-1)):
            g.es_print('%5s:%s %s' % (
                j,g.choose(j==i,'*',' '),lines[j].rstrip()))
            if j == i:
                g.es_print(' '*(7+val.offset)+'^')
    #@nonl
    #@+node:ekr.20090620121836.6073:syntaxErrorTest
    def syntaxErrorTest():

        '''Used to test Leo's handling of the following syntax error'''

        # g.app.gui.toUnicode(c=None,'whatever')
    #@nonl
    #@-node:ekr.20090620121836.6073:syntaxErrorTest
    #@-node:ekr.20090514111518.5666:syntaxError &amp; test
    #@-node:ekr.20090514111518.5663:checkPythonSyntax (leoAtFile)
    #@+node:ekr.20090514111518.5665:tabNannyNode (leoAtFile)
    def tabNannyNode (self,p,body):

        import parser,tabnanny,tokenize

        try:
            readline = g.readLinesClass(body).next
            tabnanny.process_tokens(tokenize.generate_tokens(readline))
        except parser.ParserError:
            junk, msg, junk = sys.exc_info()
            g.es("ParserError in",p.h,color="red")
            g.es('',str(msg))
            p.setMarked()
        except tokenize.TokenError:
            junk, msg, junk = sys.exc_info()
            g.es("TokenError in",p.h,color="red")
            g.es('',str(msg))
            p.setMarked()
        except tabnanny.NannyNag:
            junk, nag, junk = sys.exc_info()
            badline = nag.get_lineno()
            line    = nag.get_line()
            message = nag.get_msg()
            g.es("indentation error in",p.h,"line",badline,color="red")
            g.es(message)
            line2 = repr(str(line))[1:-1]
            g.es("offending line:\n",line2)
            p.setMarked()
        except Exception:
            g.trace("unexpected exception")
            g.es_exception()
    #@nonl
    #@-node:ekr.20090514111518.5665:tabNannyNode (leoAtFile)
    #@-node:ekr.20090514111518.5661:checkPythonCode (leoAtFile) &amp; helpers
    #@+node:ekr.20080712150045.3:closeStringFile
    def closeStringFile (self,theFile):

        at = self

        if theFile:
            theFile.flush()
            s = at.stringOutput = theFile.get()
            theFile.close()
            at.outputFile = None

            # at.outputFileName = u''
            if g.isPython3:
                at.outputFileName = ''
            else:
                at.outputFileName = unicode('')

            at.shortFileName = ''
            at.targetFileName = None
            return s
        else:
            return None
    #@-node:ekr.20080712150045.3:closeStringFile
    #@+node:ekr.20041005105605.135:closeWriteFile
    # 4.0: Don't use newline-pending logic.

    def closeWriteFile (self):

        at = self

        if at.outputFile:
            # g.trace('**closing',at.outputFileName,at.outputFile)
            at.outputFile.flush()
            if at.toString:
                at.stringOutput = self.outputFile.get()
            at.outputFile.close()
            at.outputFile = None
            return at.stringOutput
        else:
            return None
    #@-node:ekr.20041005105605.135:closeWriteFile
    #@+node:ekr.20041005105605.197:compareFiles
    # This routine is needed to handle cvs stupidities.

    def compareFiles (self,path1,path2,ignoreLineEndings):

        """Compare two text files ignoring line endings."""

        try:
            # Opening both files in text mode converts all line endings to '\n'.
            mode = g.choose(ignoreLineEndings,"r","rb")
            f1 = open(path1,mode)
            f2 = open(path2,mode)
            equal = f1.read() == f2.read()
            f1.close() ; f2.close()
            return equal
        except IOError:
            return False # Should never happen
    #@-node:ekr.20041005105605.197:compareFiles
    #@+node:ekr.20041005105605.198:directiveKind4
    def directiveKind4(self,s,i):

        """Return the kind of at-directive or noDirective."""

        at = self
        n = len(s)
        if i &gt;= n or s[i] != '@':
            j = g.skip_ws(s,i)
            if g.match_word(s,j,"@others"):
                return at.othersDirective
            elif g.match_word(s,j,"@all"):
                return at.allDirective
            else:
                return at.noDirective

        table = (
            ("@all",at.allDirective),
            ("@c",at.cDirective),
            ("@code",at.codeDirective),
            ("@doc",at.docDirective),
            ("@end_raw",at.endRawDirective),
            ("@others",at.othersDirective),
            ("@raw",at.rawDirective),
            ("@verbatim",at.startVerbatim))

        # Rewritten 6/8/2005.
        if i+1 &gt;= n or s[i+1] in (' ','\t','\n'):
            # Bare '@' not recognized in cweb mode.
            return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
        if not s[i+1].isalpha():
            return at.noDirective # Bug fix: do NOT return miscDirective here!
        if at.language=="cweb" and g.match_word(s,i,'@c'):
            return at.noDirective

        for name,directive in table:
            if g.match_word(s,i,name):
                return directive

        # New in Leo 4.4.3: add support for add_directives plugin.
        for name in g.globalDirectiveList:
            if g.match_word(s,i+1,name):
                return at.miscDirective

        return at.noDirective
    #@-node:ekr.20041005105605.198:directiveKind4
    #@+node:ekr.20041005105605.199:hasSectionName
    def findSectionName(self,s,i):

        end = s.find('\n',i)
        if end == -1:
            n1 = s.find("&lt;&lt;",i)
            n2 = s.find("&gt;&gt;",i)
        else:
            n1 = s.find("&lt;&lt;",i,end)
            n2 = s.find("&gt;&gt;",i,end)

        ok = -1 &lt; n1 &lt; n2

        # New in Leo 4.4.3: warn on extra brackets.
        if ok:
            for ch,j in (('&lt;',n1+2),('&gt;',n2+2)):
                if g.match(s,j,ch):
                    line = g.get_line(s,i)
                    g.es('dubious brackets in',line)
                    break

        return ok, n1, n2
    #@-node:ekr.20041005105605.199:hasSectionName
    #@+node:ekr.20041005105605.200:isSectionName
    # returns (flag, end). end is the index of the character after the section name.

    def isSectionName(self,s,i):

        if not g.match(s,i,"&lt;&lt;"):
            return False, -1
        i = g.find_on_line(s,i,"&gt;&gt;")
        if i:
            return True, i + 2
        else:
            return False, -1
    #@-node:ekr.20041005105605.200:isSectionName
    #@+node:ekr.20070909103844:isSignificantTree
    def isSignificantTree (self,p):

        '''Return True if p's tree has a significant amount of information.'''

        s = p.b

        # Remove all blank lines and all Leo directives.
        lines = []
        for line in g.splitLines(s):
            if not line.strip():
                pass
            elif line.startswith('@'):
                i = 1 ; j = g.skip_id(line,i,chars='-')
                word = s[i:j]
                if not (word and word in g.globalDirectiveList):
                    lines.append(line)
            else:
                lines.append(line)

        s2 = ''.join(lines)
        # g.trace('s2',s2)

        return p.hasChildren() or len(s2.strip()) &gt;= 10
    #@-node:ekr.20070909103844:isSignificantTree
    #@+node:ekr.20080712150045.2:openStringFile
    def openStringFile (self,fn):

        at = self

        at.shortFileName = g.shortFileName(fn)
        at.outputFileName = "&lt;string: %s&gt;" % at.shortFileName
        at.outputFile = g.fileLikeObject()
        at.targetFileName = "&lt;string-file&gt;"

        return at.outputFile
    #@-node:ekr.20080712150045.2:openStringFile
    #@+node:ekr.20041005105605.201:os and allies
    # Note:  self.outputFile may be either a fileLikeObject or a real file.
    #@+node:ekr.20041005105605.202:oblank, oblanks &amp; otabs
    def oblank(self):
        self.os(' ')

    def oblanks (self,n):
        self.os(' ' * abs(n))

    def otabs(self,n):
        self.os('\t' * abs(n))
    #@-node:ekr.20041005105605.202:oblank, oblanks &amp; otabs
    #@+node:ekr.20041005105605.203:onl &amp; onl_sent
    def onl(self):

        """Write a newline to the output stream."""

        self.os(self.output_newline)

    def onl_sent(self):

        """Write a newline to the output stream, provided we are outputting sentinels."""

        if self.sentinels:
            self.onl()
    #@-node:ekr.20041005105605.203:onl &amp; onl_sent
    #@+node:ekr.20041005105605.204:os
    def os (self,s):

        """Write a string to the output stream.

        All output produced by leoAtFile module goes here."""

        trace = False
        at = self ; tag = self.underindentEscapeString
        f = at.outputFile

        if s and f:
            try:
                if trace: g.trace(repr(s),g.callers(4))
                if s.startswith(tag):
                    junk,s = self.parseUnderindentTag(s)
                # Bug fix: this must be done last.
                s = g.toEncodedString(s,at.encoding,reportErrors=True)
                f.write(s)
            except Exception:
                at.exception("exception writing:" + s)
    #@-node:ekr.20041005105605.204:os
    #@-node:ekr.20041005105605.201:os and allies
    #@+node:ekr.20041005105605.205:outputStringWithLineEndings
    # Write the string s as-is except that we replace '\n' with the proper line ending.

    def outputStringWithLineEndings (self,s):

        # Calling self.onl() runs afoul of queued newlines.
        self.os(s.replace('\n',self.output_newline))
    #@-node:ekr.20041005105605.205:outputStringWithLineEndings
    #@+node:ekr.20050506090446.1:putAtFirstLines
    def putAtFirstLines (self,s):

        '''Write any @firstlines from string s.
        These lines are converted to @verbatim lines,
        so the read logic simply ignores lines preceding the @+leo sentinel.'''

        at = self ; tag = "@first"

        i = 0
        while g.match(s,i,tag):
            i += len(tag)
            i = g.skip_ws(s,i)
            j = i
            i = g.skip_to_end_of_line(s,i)
            # Write @first line, whether empty or not
            line = s[j:i]
            at.os(line) ; at.onl()
            i = g.skip_nl(s,i)
    #@-node:ekr.20050506090446.1:putAtFirstLines
    #@+node:ekr.20050506090955:putAtLastLines
    def putAtLastLines (self,s):

        '''Write any @last lines from string s.
        These lines are converted to @verbatim lines,
        so the read logic simply ignores lines following the @-leo sentinel.'''

        at = self ; tag = "@last"

        # Use g.splitLines to preserve trailing newlines.
        lines = g.splitLines(s)
        n = len(lines) ; j = k = n - 1

        # Scan backwards for @last directives.
        while j &gt;= 0:
            line = lines[j]
            if g.match(line,0,tag): j -= 1
            elif not line.strip():
                j -= 1
            else: break

        # Write the @last lines.
        for line in lines[j+1:k+1]:
            if g.match(line,0,tag):
                i = len(tag) ; i = g.skip_ws(line,i)
                at.os(line[i:])
    #@-node:ekr.20050506090955:putAtLastLines
    #@+node:ekr.20071117152308:putBuffered
    def putBuffered (self,s):

        '''Put s, converting all tabs to blanks as necessary.'''

        if not s: return

        w = self.tab_width
        if w &lt; 0:
            result = []
            lines = s.split('\n')
            for line in lines:
                line2 = [] ; j = 0
                for ch in line:
                    j += 1
                    if ch == '\t':
                        w2 = g.computeWidth(s[:j],w)
                        w3 = (abs(w) - (w2 % abs(w)))
                        line2.append(' ' * w3)
                    else:
                        line2.append(ch)
                result.append(''.join(line2))
            s = '\n'.join(result)

        self.os(s)
    #@-node:ekr.20071117152308:putBuffered
    #@+node:ekr.20041005105605.206:putDirective  (handles @delims,@comment,@language) 4.x
    #@+at 
    #@nonl
    # It is important for PHP and other situations that @first and @last 
    # directives get translated to verbatim lines that do _not_ include what 
    # follows the @first &amp; @last directives.
    #@-at
    #@@c

    def putDirective(self,s,i):

        """Output a sentinel a directive or reference s."""

        tag = "@delims"
        assert(i &lt; len(s) and s[i] == '@')
        k = i
        j = g.skip_to_end_of_line(s,i)
        directive = s[i:j]

        if g.match_word(s,k,"@delims"):
            #@        &lt;&lt; handle @delims &gt;&gt;
            #@+node:ekr.20041005105605.207:&lt;&lt; handle @delims &gt;&gt;
            # Put a space to protect the last delim.
            self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

            # Skip the keyword and whitespace.
            j = i = g.skip_ws(s,k+len(tag))

            # Get the first delim.
            while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
                i += 1
            if j &lt; i:
                self.startSentinelComment = s[j:i]
                # Get the optional second delim.
                j = i = g.skip_ws(s,i)
                while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
                    i += 1
                self.endSentinelComment = g.choose(j&lt;i, s[j:i], "")
            else:
                self.writeError("Bad @delims directive")
            #@-node:ekr.20041005105605.207:&lt;&lt; handle @delims &gt;&gt;
            #@nl
        elif g.match_word(s,k,"@language"):
            #@        &lt;&lt; handle @language &gt;&gt;
            #@+node:ekr.20041005105605.208:&lt;&lt; handle @language &gt;&gt;
            self.putSentinel("@" + directive)

            if 0: # Bug fix: Leo 4.4.1
                # Do not scan the @language directive here!
                # These ivars have already been scanned by the init code.

                # Skip the keyword and whitespace.
                i = k + len("@language")
                i = g.skip_ws(s,i)
                j = g.skip_c_id(s,i)
                language = s[i:j]

                delim1,delim2,delim3 = g.set_delims_from_language(language)

                # g.trace(delim1,delim2,delim3)

                # Returns a tuple (single,start,end) of comment delims
                if delim1:
                    self.startSentinelComment = delim1
                    self.endSentinelComment = ""
                elif delim2 and delim3:
                    self.startSentinelComment = delim2
                    self.endSentinelComment = delim3
                else:
                    line = g.get_line(s,i)
                    g.es("ignoring bad @language directive:",line,color="blue")
            #@-node:ekr.20041005105605.208:&lt;&lt; handle @language &gt;&gt;
            #@nl
        elif g.match_word(s,k,"@comment"):
            #@        &lt;&lt; handle @comment &gt;&gt;
            #@+node:ekr.20041005105605.209:&lt;&lt; handle @comment &gt;&gt;
            self.putSentinel("@" + directive)

            if 0: # Bug fix: Leo 4.4.1
                # Do not scan the @comment directive here!
                # These ivars have already been scanned by the init code.

                # g.trace(delim1,delim2,delim3)

                j = g.skip_line(s,i)
                line = s[i:j]
                delim1,delim2,delim3 = g.set_delims_from_string(line)

                # Returns a tuple (single,start,end) of comment delims
                if delim1:
                    self.startSentinelComment = delim1
                    self.endSentinelComment = None
                elif delim2 and delim3:
                    self.startSentinelComment = delim2
                    self.endSentinelComment = delim3
                else:
                    g.es("ignoring bad @comment directive:",line,color="blue")
            #@-node:ekr.20041005105605.209:&lt;&lt; handle @comment &gt;&gt;
            #@nl
        elif g.match_word(s,k,"@last"):
            self.putSentinel("@@last") # 10/27/03: Convert to an verbatim line _without_ anything else.
        elif g.match_word(s,k,"@first"):
            self.putSentinel("@@first") # 10/27/03: Convert to an verbatim line _without_ anything else.
        else:
            self.putSentinel("@" + directive)

        i = g.skip_line(s,k)
        return i
    #@-node:ekr.20041005105605.206:putDirective  (handles @delims,@comment,@language) 4.x
    #@+node:ekr.20041005105605.210:putIndent
    def putIndent(self,n,s=''):

        """Put tabs and spaces corresponding to n spaces,
        assuming that we are at the start of a line.

        Remove extra blanks if the line starts with the underindentEscapeString"""

        # g.trace(repr(s))
        tag = self.underindentEscapeString

        if s.startswith(tag):
            n2,s2 = self.parseUnderindentTag(s)
            if n2 &gt;= n: return
            elif n &gt; 0: n -= n2
            else:       n += n2

        if n != 0:
            w = self.tab_width
            if w &gt; 1:
                q,r = divmod(n,w) 
                self.otabs(q) 
                self.oblanks(r)
            else:
                self.oblanks(n)
    #@-node:ekr.20041005105605.210:putIndent
    #@+node:ekr.20041005105605.211:putInitialComment
    def putInitialComment (self):

        c = self.c
        s2 = c.config.output_initial_comment
        if s2:
            lines = s2.split("\\n")
            for line in lines:
                line = line.replace("@date",time.asctime())
                if len(line)&gt; 0:
                    self.putSentinel("@comment " + line)
    #@-node:ekr.20041005105605.211:putInitialComment
    #@+node:ekr.20080712150045.1:replaceFileWithString (atFile)
    def replaceFileWithString (self,fn,s):

        '''Replace the file with s if s is different from theFile's contents.

        Return True if theFile was changed.
        '''

        at = self ; testing = g.app.unitTesting

        # g.trace('fn',fn,'s','\n',s)
        # g.trace(g.callers())

        exists = g.os_path_exists(fn)

        if exists: # Read the file.  Return if it is the same.
            try:
                f = open(fn,'rb')
                s2 = f.read()
                f.close()
            except IOError:
                at.error('unexpected exception creating %s' % fn)
                g.es_exception()
                return False
            if s == s2:
                if not testing: g.es('unchanged:',fn)
                return False

        # Issue warning if directory does not exist.
        theDir = g.os_path_dirname(fn)
        if theDir and not g.os_path_exists(theDir):
            if not g.unitTesting:
                g.es('not written: %s directory not found' % fn,color='red')
            return False

        # Replace
        try:
            f = open(fn,'wb')
            f.write(s)
            f.close()
            if not testing:
                if exists:
                    g.es('wrote:    ',fn)
                else:
                    # g.trace('created:',fn,g.callers())
                    g.es('created:  ',fn)
            return True
        except IOError:
            at.error('unexpected exception writing file: %s' % (fn))
            g.es_exception()
            return False
    #@+node:ekr.20090530055015.6873:@test at.replaceFileWithString
    if g.unitTesting:

        c,p = g.getTestVars()
        at = c.atFileCommands

        fn = 'does/not/exist'
        assert not g.os_path_exists(fn)
        assert not at.replaceFileWithString (fn,'abc')
    #@-node:ekr.20090530055015.6873:@test at.replaceFileWithString
    #@-node:ekr.20080712150045.1:replaceFileWithString (atFile)
    #@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent
    def replaceTargetFileIfDifferent (self,root):

        '''Create target file as follows:
        1. If target file does not exist, rename output file to target file.
        2. If target file is identical to output file, remove the output file.
        3. If target file is different from output file,
           remove target file, then rename output file to be target file.

        Return True if the original file was changed.
        '''

        trace = False and not g.unitTesting
        c = self.c

        assert(self.outputFile is None)

        if self.toString:
            # Do *not* change the actual file or set any dirty flag.
            self.fileChangedFlag = False
            return False

        if root:
            # The default: may be changed later.
            root.clearOrphan()
            root.clearDirty()

        if trace: g.trace(self.outputFileName,self.targetFileName)

        if g.os_path_exists(self.targetFileName):
            if self.compareFiles(self.outputFileName,self.targetFileName,not self.explicitLineEnding):
                # Files are identical.
                ok = self.remove(self.outputFileName)
                g.es('unchanged:',self.shortFileName)
                if not ok:
                    # self.remove gives the error.
                    if root: root.setDirty() # New in 4.4.8.
                self.fileChangedFlag = False
                return False
            else:
                self.checkPythonCode(root)
                #@            &lt;&lt; report if the files differ only in line endings &gt;&gt;
                #@+node:ekr.20041019090322:&lt;&lt; report if the files differ only in line endings &gt;&gt;
                if (
                    self.explicitLineEnding and
                    self.compareFiles(
                        self.outputFileName,
                        self.targetFileName,
                        ignoreLineEndings=True)):

                    g.es("correcting line endings in:",self.targetFileName,color="blue")
                #@-node:ekr.20041019090322:&lt;&lt; report if the files differ only in line endings &gt;&gt;
                #@nl
                mode = self.stat(self.targetFileName)
                ok = self.rename(self.outputFileName,self.targetFileName,mode)
                if ok:
                    c.setFileTimeStamp(self.targetFileName)
                    g.es('wrote:    ',self.shortFileName)
                else:
                    # self.rename gives the error.
                    g.es('unchanged:',self.shortFileName)
                    if root: root.setDirty() # New in 4.4.8.

                self.fileChangedFlag = ok
                return ok
        else:
            # Rename the output file.
            ok = self.rename(self.outputFileName,self.targetFileName)
            if ok:
                c.setFileTimeStamp(self.targetFileName)
                g.es('created:  ',self.targetFileName)
            else:
                # self.rename gives the error.
                if root: root.setDirty() # New in 4.4.8.

            # No original file to change. Return value tested by a unit test.
            self.fileChangedFlag = False 
            return False
    #@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent
    #@+node:ekr.20041005105605.216:warnAboutOrpanAndIgnoredNodes
    # Called from writeOpenFile.

    def warnAboutOrphandAndIgnoredNodes (self):

        # Always warn, even when language=="cweb"
        at = self ; root = at.root

        for p in root.self_and_subtree_iter():
            if not p.v.t.isVisited(): # Check tnode bit, not vnode bit.
                at.writeError("Orphan node:  " + p.h)
                if p.hasParent():
                    g.es("parent node:",p.parent().h,color="blue")
                if not at.thinFile and p.isAtIgnoreNode():
                    at.writeError("@ignore node: " + p.h)

        if at.thinFile:
            p = root.copy() ; after = p.nodeAfterTree()
            while p and p != after:
                if p.isAtAllNode():
                    p.moveToNodeAfterTree()
                else:
                    if p.isAtIgnoreNode():
                        at.writeError("@ignore node: " + p.h)
                    p.moveToThreadNext()
    #@-node:ekr.20041005105605.216:warnAboutOrpanAndIgnoredNodes
    #@+node:ekr.20041005105605.217:writeError
    def writeError(self,message=None):

        if self.errors == 0:
            g.es_error("errors writing: " + self.targetFileName)

        self.error(message)
        self.root.setOrphan()
        self.root.setDirty()
    #@-node:ekr.20041005105605.217:writeError
    #@+node:ekr.20041005105605.218:writeException
    def writeException (self,root=None):

        g.es("exception writing:",self.targetFileName,color="red")
        g.es_exception()

        if self.outputFile:
            self.outputFile.flush()
            self.outputFile.close()
            self.outputFile = None

        if self.outputFileName:
            self.remove(self.outputFileName)

        if root:
            # Make sure we try to rewrite this file.
            root.setOrphan()
            root.setDirty()
    #@-node:ekr.20041005105605.218:writeException
    #@-node:ekr.20041005105605.196:Writing 4.x utils...
    #@-node:ekr.20041005105605.132:at.Writing
    #@+node:ekr.20041005105605.219:at.Utilites
    #@+node:ekr.20041005105605.220:atFile.error &amp; printError
    def error(self,*args):

        at = self

        if args:
            at.printError(*args)

        at.errors += 1

    def printError (self,*args):

        '''Print an error message that may contain non-ascii characters.'''

        at = self

        keys = {'color': g.choose(at.errors,'blue','red')}

        g.es_print_error(*args,**keys)
    #@-node:ekr.20041005105605.220:atFile.error &amp; printError
    #@+node:ekr.20080923070954.4:atFile.scanAllDirectives &amp; test
    def scanAllDirectives(self,p,
        scripting=False,importing=False,
        reading=False,forcePythonSentinels=False,
        createPath=True,
    ):

        '''Scan p and p's ancestors looking for directives,
        setting corresponding atFile ivars.'''

        trace = False and not g.unitTesting
        at = self ; c = self.c
        #@    &lt;&lt; set ivars &gt;&gt;
        #@+node:ekr.20080923070954.14:&lt;&lt; Set ivars &gt;&gt;
        self.page_width = self.c.page_width
        self.tab_width  = self.c.tab_width

        self.default_directory = None # 8/2: will be set later.

        # g.trace(c.target_language)

        if c.target_language:
            c.target_language = c.target_language.lower()

        delims = g.set_delims_from_language(c.target_language)
        at.language = c.target_language

        at.encoding = c.config.default_derived_file_encoding
        at.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
        #@-node:ekr.20080923070954.14:&lt;&lt; Set ivars &gt;&gt;
        #@nl
        lang_dict = {'language':at.language,'delims':delims,}
        table = (
            ('encoding',    at.encoding,    g.scanAtEncodingDirectives),
            ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
            ('lineending',  None,           g.scanAtLineendingDirectives),
            ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
            ('path',        None,           c.scanAtPathDirectives),
            ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
        )

        # Set d by scanning all directives.
        aList = g.get_directives_dict_list(p)
        d = {}
        for key,default,func in table:
            val = func(aList)
            d[key] = g.choose(val is None,default,val)

        # Post process.
        lang_dict       = d.get('lang-dict')
        delims          = lang_dict.get('delims')
        lineending      = d.get('lineending')
        if lineending:
            at.explicitLineEnding = True
            at.output_newline = lineending
        else:
            at.output_newline = g.getOutputNewline(c=c) # Init from config settings.

        at.encoding             = d.get('encoding')
        at.language             = lang_dict.get('language')
        at.page_width           = d.get('pagewidth')
        at.default_directory    = d.get('path')
        at.tab_width            = d.get('tabwidth')

        if not importing and not reading:
            # Don't override comment delims when reading!
            #@        &lt;&lt; set comment strings from delims &gt;&gt;
            #@+node:ekr.20080923070954.13:&lt;&lt; Set comment strings from delims &gt;&gt;
            if forcePythonSentinels:
                # Force Python language.
                delim1,delim2,delim3 = g.set_delims_from_language("python")
                self.language = "python"
            else:
                delim1,delim2,delim3 = delims

            # Use single-line comments if we have a choice.
            # delim1,delim2,delim3 now correspond to line,start,end
            if delim1:
                at.startSentinelComment = delim1
                at.endSentinelComment = "" # Must not be None.
            elif delim2 and delim3:
                at.startSentinelComment = delim2
                at.endSentinelComment = delim3
            else: # Emergency!
                # assert(0)
                if not g.app.unitTesting:
                    g.es_print("unknown language: using Python comment delimiters")
                    g.es_print("c.target_language:",c.target_language)
                    g.es_print('','delim1,delim2,delim3:','',delim1,'',delim2,'',delim3)
                at.startSentinelComment = "#" # This should never happen!
                at.endSentinelComment = ""

            # g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
            #@-node:ekr.20080923070954.13:&lt;&lt; Set comment strings from delims &gt;&gt;
            #@nl

        # For unit testing.
        d = {
            "encoding"  : at.encoding,
            "language"  : at.language,
            "lineending": at.output_newline,
            "pagewidth" : at.page_width,
            "path"      : at.default_directory,
            "tabwidth"  : at.tab_width,
        }
        if trace: g.trace(d)
        return d
    #@+node:ekr.20090530055015.6069:@test at.scanAllDirectives
    if g.unitTesting:

        c,p = g.getTestVars()
        at = c.atFileCommands
        d = at.scanAllDirectives(p)
    #@-node:ekr.20090530055015.6069:@test at.scanAllDirectives
    #@-node:ekr.20080923070954.4:atFile.scanAllDirectives &amp; test
    #@+node:ekr.20070529083836:cleanLines
    def cleanLines (self,p,s):

        '''Return a copy of s, with all trailing whitespace removed.
        If a change was made, update p's body text and set c dirty.'''

        c = self.c ; cleanLines = [] ; changed = False
        lines = g.splitLines(s)
        for line in lines:
            if line.strip():
                cleanLines.append(line)
            elif line.endswith('\n'):
                cleanLines.append('\n')
                if line != '\n': changed = True
            else:
                cleanLines.append('')
                if line != '': changed = True
        s = g.joinLines(cleanLines)

        if changed and not g.app.unitTesting:
            p.setBodyString(s)
            c.setChanged(True)

        return s
    #@nonl
    #@-node:ekr.20070529083836:cleanLines
    #@+node:ekr.20041005105605.221:exception
    def exception (self,message):

        self.error(message)
        g.es_exception()
    #@-node:ekr.20041005105605.221:exception
    #@+node:ekr.20050104131929:file operations...
    #@+at 
    #@nonl
    # The difference, if any, between these methods and the corresponding 
    # g.utils_x
    # functions is that these methods may call self.error.
    #@-at
    #@+node:ekr.20050104131820:chmod
    def chmod (self,fileName,mode):

        # Do _not_ call self.error here.
        return g.utils_chmod(fileName,mode)
    #@-node:ekr.20050104131820:chmod
    #@+node:ekr.20050104131929.1:atFile.rename
    #@&lt;&lt; about os.rename &gt;&gt;
    #@+node:ekr.20050104131929.2:&lt;&lt; about os.rename &gt;&gt;
    #@+at 
    #@nonl
    # Here is the Python 2.4 documentation for rename (same as Python 2.3)
    # 
    # Rename the file or directory src to dst.  If dst is a directory, OSError 
    # will be raised.
    # 
    # On Unix, if dst exists and is a file, it will be removed silently if the 
    # user
    # has permission. The operation may fail on some Unix flavors if src and 
    # dst are
    # on different filesystems. If successful, the renaming will be an atomic
    # operation (this is a POSIX requirement).
    # 
    # On Windows, if dst already exists, OSError will be raised even if it is 
    # a file;
    # there may be no way to implement an atomic rename when dst names an 
    # existing
    # file.
    #@-at
    #@-node:ekr.20050104131929.2:&lt;&lt; about os.rename &gt;&gt;
    #@nl

    def rename (self,src,dst,mode=None,verbose=True):

        '''remove dst if it exists, then rename src to dst.

        Change the mode of the renamed file if mode is given.

        Return True if all went well.'''

        c = self.c
        head,junk=g.os_path_split(dst)
        if head and len(head) &gt; 0:
            g.makeAllNonExistentDirectories(head,c=c)

        if g.os_path_exists(dst):
            if not self.remove(dst,verbose=verbose):
                return False

        try:
            os.rename(src,dst)
            if mode != None:
                self.chmod(dst,mode)
            return True
        except Exception:
            if verbose:
                self.error("exception renaming: %s to: %s" % (
                    self.outputFileName,self.targetFileName))
                g.es_exception()
            return False
    #@-node:ekr.20050104131929.1:atFile.rename
    #@+node:ekr.20050104132018:atFile.remove
    def remove (self,fileName,verbose=True):

        try:
            os.remove(fileName)
            return True
        except Exception:
            if verbose:
                self.error("exception removing: %s" % fileName)
                g.es_exception()
                g.trace(g.callers(5))
            return False
    #@-node:ekr.20050104132018:atFile.remove
    #@+node:ekr.20050104132026:stat
    def stat (self,fileName):

        '''Return the access mode of named file, removing any setuid, setgid, and sticky bits.'''

        # Do _not_ call self.error here.
        return g.utils_stat(fileName)
    #@-node:ekr.20050104132026:stat
    #@-node:ekr.20050104131929:file operations...
    #@+node:ekr.20090530055015.6050:fullPath (leoAtFile) &amp; test
    def fullPath (self,p,simulate=False):

        '''Return the full path (including fileName) in effect at p.

        Neither the path nor the fileName will be created if it does not exist.
        '''

        at = self ; c = at.c
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList,createPath=False)
        if simulate: # for unit tests.
            fn = p.h
        else:
            fn = p.anyAtFileNodeName()
        if fn:
            path = g.os_path_finalize_join(path,fn)
        else:
            g.trace('can not happen: not an @&lt;file&gt; node:',g.callers(4))
            for p2 in p.self_and_parents_iter():
                g.trace(p2.h)
            path = ''

        # g.trace(p.h,repr(path))
        return path
    #@+node:ekr.20090530055015.6051:@test fullDirectoryPath
    if g.unitTesting:

        c,p = g.getTestVars()
        at = c.atFileCommands

        p2 = p.firstChild().firstChild()
        path = at.fullPath(p2,simulate=True)
        end = g.os_path_normpath('abc/xyz')
        assert path.endswith(end),repr(path)

    #@+node:ekr.20090530055015.6146:@path abc
    #@+node:ekr.20090530055015.6147:xyz
    #@-node:ekr.20090530055015.6147:xyz
    #@-node:ekr.20090530055015.6146:@path abc
    #@-node:ekr.20090530055015.6051:@test fullDirectoryPath
    #@-node:ekr.20090530055015.6050:fullPath (leoAtFile) &amp; test
    #@+node:ekr.20090530055015.6023:get/setPathUa (leoAtFile) &amp; tests
    def getPathUa (self,p):

        if hasattr(p.v.t,'tempAttributes'):
            d = p.v.t.tempAttributes.get('read-path',{})
            return d.get('path')
        else:
            return ''

    def setPathUa (self,p,path):

        if not hasattr(p.v.t,'tempAttributes'):
            p.v.t.tempAttributes = {}

        d = p.v.t.tempAttributes.get('read-path',{})
        d['path'] = path
        p.v.t.tempAttributes ['read-path'] = d
    #@+node:ekr.20090530055015.6024:@test at.get/setPathUa
    if g.unitTesting:

        c,p = g.getTestVars()
        at = c.atFileCommands

        at.setPathUa(p,'abc')
        d = p.v.t.tempAttributes
        d2 = d.get('read-path')
        val1 = d2.get('path')
        val2 = at.getPathUa(p)

        table = (
            ('d2.get',val1),
            ('at.getPathUa',val2),
        )
        for kind,val in table:
            assert val == 'abc','kind %s expected %s got %s' % (
                kind,'abc',val)
    #@-node:ekr.20090530055015.6024:@test at.get/setPathUa
    #@-node:ekr.20090530055015.6023:get/setPathUa (leoAtFile) &amp; tests
    #@+node:ekr.20081216090156.4:parseUnderindentTag
    def parseUnderindentTag (self,s):

        tag = self.underindentEscapeString
        s2 = s[len(tag):]

        # To be valid, the escape must be followed by at least one digit.
        i = 0
        while i &lt; len(s2) and s2[i].isdigit():
            i += 1

        if i &gt; 0:
            n = int(s2[:i])
            return n,s2[i:]
        else:
            return 0,s
    #@-node:ekr.20081216090156.4:parseUnderindentTag
    #@+node:ekr.20041005105605.236:scanDefaultDirectory (leoAtFile)
    def scanDefaultDirectory(self,p,importing=False):

        """Set the default_directory ivar by looking for @path directives."""

        at = self ; c = at.c

        at.default_directory,error = g.setDefaultDirectory(c,p,importing)

        if error: at.error(error)
    #@-node:ekr.20041005105605.236:scanDefaultDirectory (leoAtFile)
    #@+node:ekr.20041005105605.242:scanForClonedSibs (reading &amp; writing)
    def scanForClonedSibs (self,parent_v,v):

        """Scan the siblings of vnode v looking for clones of v.
        Return the number of cloned sibs and n where p is the n'th cloned sibling."""

        clonedSibs = 0 # The number of cloned siblings of p, including p.
        thisClonedSibIndex = 0 # Position of p in list of cloned siblings.

        if v and v.isCloned():
            sibs = parent_v.t.children
            for sib in sibs:
                if sib.t == v.t:
                    clonedSibs += 1
                    if sib == v:
                        thisClonedSibIndex = clonedSibs

        # if v and v.isCloned():
            # sib = v
            # while sib.back():
                # sib = sib.back()
            # while sib:
                # if sib.t == v.t:
                    # clonedSibs += 1
                    # if sib == v:
                        # thisClonedSibIndex = clonedSibs
                # sib = sib.next()

        # g.trace(clonedSibs,thisClonedSibIndex)

        return clonedSibs,thisClonedSibIndex
    #@-node:ekr.20041005105605.242:scanForClonedSibs (reading &amp; writing)
    #@+node:ekr.20041005105605.243:sentinelName
    # Returns the name of the sentinel for warnings.

    def sentinelName(self, kind):

        at = self

        sentinelNameDict = {
            at.noSentinel:    "&lt;no sentinel&gt;",
            at.startAt:       "@+at",     at.endAt:     "@-at",
            at.startBody:     "@+body",   at.endBody:   "@-body", # 3.x only.
            at.startDoc:      "@+doc",    at.endDoc:    "@-doc",
            at.startLeo:      "@+leo",    at.endLeo:    "@-leo",
            at.startNode:     "@+node",   at.endNode:   "@-node",
            at.startOthers:   "@+others", at.endOthers: "@-others",
            at.startAll:      "@+all",    at.endAll:    "@-all", # 4.x
            at.startMiddle:   "@+middle", at.endMiddle: "@-middle", # 4.x
            at.startAfterRef: "@afterref", # 4.x
            at.startComment:  "@comment",
            at.startDelims:   "@delims",
            at.startDirective:"@@",
            at.startNl:       "@nl",   # 4.x
            at.startNonl:     "@nonl", # 4.x
            at.startClone:    "@clone", # 4.2
            at.startRef:      "@&lt;&lt;",
            at.startVerbatim: "@verbatim",
            at.startVerbatimAfterRef: "@verbatimAfterRef" } # 3.x only.

        return sentinelNameDict.get(kind,"&lt;unknown sentinel!&gt;")
    #@-node:ekr.20041005105605.243:sentinelName
    #@+node:ekr.20041005105605.20:warnOnReadOnlyFile
    def warnOnReadOnlyFile (self,fn):

        # os.access() may not exist on all platforms.
        try:
            read_only = not os.access(fn,os.W_OK)
        except AttributeError:
            read_only = False 

        if read_only:
            g.es("read only:",fn,color="red")
    #@-node:ekr.20041005105605.20:warnOnReadOnlyFile
    #@-node:ekr.20041005105605.219:at.Utilites
    #@-others
#@-node:ekr.20041005105605.1:@thin leoAtFile.py
#@-leo
</t>
<t tx="ekr.20090629105832.1790"></t>
<t tx="ekr.20090629193234.1790">This is a undefinedReference_.

</t>
<t tx="ekr.20090629193234.6122">@language rest
</t>
</tnodes>
</leo_file>
