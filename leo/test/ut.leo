<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.490613266583">
	<global_window_position top="69" left="327" height="779" width="927"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070920113956"><vh>@chapters</vh></v>
<v t="ekr.20060301122644"><vh>Buttons</vh>
<v t="ekr.20060301122618"><vh>@button Unit Test @key=Alt-4</vh></v>
<v t="ekr.20060301122644.1"><vh>@button Save</vh></v>
<v t="ekr.20060626085103"><vh>Disabled buttons</vh>
<v t="ekr.20060626085103.1"><vh>Run tcl script</vh>
<v t="ekr.20060626085103.2"><vh>@@button Run tcl  script</vh></v>
<v t="ekr.20060626085103.3"><vh>My first tcl script</vh></v>
<v t="ekr.20060626085103.4"><vh>My second tcl scrip, organized with noweb markup</vh>
<v t="ekr.20060626085103.5"><vh>the actual script</vh></v>
</v>
</v>
<v t="ekr.20060626085103.6"><vh>@@ button pydoc</vh></v>
<v t="ekr.20060626085103.7"><vh>@@ button jython</vh></v>
<v t="ekr.20060626085103.8"><vh>@@button Ipython</vh></v>
<v t="ekr.20060626085103.9"><vh>@@button Lines Up</vh>
<v t="ekr.20060626085103.10"><vh>moveLinesUp</vh></v>
</v>
<v t="ekr.20060626085103.11"><vh>@@button Lines Down</vh>
<v t="ekr.20060626085103.12"><vh>moveLinesDown</vh></v>
</v>
<v t="ekr.20060626085103.13"><vh>@@button outlineToClipboard</vh></v>
<v t="ekr.20060626085103.14"><vh>@@command dbl-click @key = Alt-Shift-C</vh></v>
<v t="ekr.20060626085103.15"><vh>@@button shorten-lines</vh>
<v t="ekr.20060626085103.16"><vh>to do</vh></v>
<v t="ekr.20060626085103.17"><vh>splitLongLine</vh></v>
<v t="ekr.20060626085103.18"><vh>chooseBreakPoint</vh></v>
</v>
<v t="ekr.20060626085103.19"><vh>@@button file-mode</vh></v>
<v t="ekr.20060626085103.20"><vh>@@button Free-Tree</vh></v>
<v t="ekr.20060626085103.21"><vh>@@button *new-obj</vh></v>
<v t="ekr.20060626085103.22"><vh>@@button New-obj</vh></v>
<v t="ekr.20060626085103.23"><vh>@@button Gc</vh></v>
<v t="ekr.20060626085103.24"><vh>@@button No-Gc</vh></v>
<v t="ekr.20060626085103.25"><vh>@@button All-obj</vh></v>
<v t="ekr.20060626085103.26"><vh>@@button run timer</vh></v>
<v t="ekr.20060626085103.27"><vh>@@button Stats</vh></v>
<v t="ekr.20060626085103.28"><vh>@@button scripts.leo</vh></v>
<v t="ekr.20060626085103.29"><vh>@@button updateSettings</vh>
<v t="ekr.20060626085103.30"><vh>&lt;&lt;docstring&gt;&gt;</vh></v>
<v t="ekr.20060626085103.31"><vh>class updateParser (parserBaseClass)</vh>
<v t="ekr.20060626085103.32"><vh>ctor</vh></v>
<v t="ekr.20060626085103.33"><vh>visitNode</vh></v>
<v t="ekr.20060626085103.34"><vh>kind handlers (overrides only)</vh>
<v t="ekr.20060626085103.35"><vh>doFont</vh></v>
<v t="ekr.20060626085103.36"><vh>doShortcut</vh></v>
<v t="ekr.20060626085103.37"><vh>doShortcuts</vh></v>
</v>
<v t="ekr.20060626085103.38"><vh>set</vh></v>
</v>
<v t="ekr.20060626085103.39"><vh>class updateClass</vh>
<v t="ekr.20060626085103.40"><vh> ctor</vh></v>
<v t="ekr.20060626085103.41"><vh>add</vh></v>
<v t="ekr.20060626085103.42"><vh>change</vh></v>
<v t="ekr.20060626085103.43"><vh>error, message &amp; warning</vh></v>
<v t="ekr.20060626085103.44"><vh>open</vh></v>
<v t="ekr.20060626085103.45"><vh>update</vh></v>
</v>
</v>
<v t="ekr.20060626085103.46"><vh>@@button open-outline-by-name</vh></v>
<v t="ekr.20060626085103.47"><vh>@@button Show other clones</vh>
<v t="ekr.20060626085103.48"><vh>class cloneNavigator</vh>
<v t="ekr.20060626085103.49"><vh>init</vh></v>
<v t="ekr.20060626085103.50"><vh>getAllClones</vh></v>
<v t="ekr.20060626085103.51"><vh>displayClones</vh>
<v t="ekr.20060626085103.52"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060626085103.53"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060626085246"><vh>@@button Unit Test</vh></v>
<v t="ekr.20060626085103.55"><vh>@@button dt</vh></v>
<v t="ekr.20060626085103.56"><vh>@@button debug-leo</vh></v>
<v t="ekr.20060626085103.57"><vh>@@button debug</vh></v>
<v t="ekr.20060626085103.58"><vh>@@button del-ed</vh></v>
<v t="ekr.20060626085103.59"><vh>@@button cycle-ed</vh></v>
<v t="ekr.20060626085103.60"><vh>@@button add-ed</vh></v>
<v t="ekr.20060626085103.61"><vh>@@button rst3</vh></v>
</v>
</v>
<v t="ekr.20051208082927"><vh>ut.leo</vh>
<v t="ekr.20051208083135"><vh>@asis ut.bat</vh></v>
<v t="ekr.20060124103819"><vh>@asis utw.bat</vh></v>
<v t="ekr.20051208084010"><vh>@thin ut.py</vh></v>
</v>
<v t="ekr.20060129090836"><vh>@ignore</vh>
<v t="ekr.20051208085841.1"><vh>@test assert False</vh></v>
<v t="ekr.20060129185431"><vh>@test k.strokeFromEvent and k.strokeFromSetting</vh></v>
<v t="ekr.20051208085841"><vh>@test 1</vh></v>
<v t="ekr.20060208071636"><vh>Test headline abc</vh></v>
</v>
<v t="ekr.20060914121042"><vh>Plugin-specific unit tests</vh>
<v t="ekr.20060914121042.1"><vh>@test leo_to_html</vh></v>
<v t="ekr.20060914123717"><vh>@test leo_to_rtf</vh></v>
<v t="ekr.20060914123949"><vh>@test chapter_hoist</vh></v>
<v t="ekr.20060914125424"><vh>@test mod_scripting</vh></v>
<v t="ekr.20060914125710"><vh>@test open_with</vh></v>
<v t="ekr.20060914130213"><vh>@test rst3</vh></v>
<v t="ekr.20060914130545"><vh>@test UNL</vh></v>
<v t="ekr.20060914130924"><vh>@test paste_as_headlines</vh></v>
</v>
<v t="ekr.20060626084629"><vh>To do: convert to unit tests</vh>
<v t="ekr.20060626084629.11"><vh>remove-blank-lines</vh>
<v t="ekr.20060626084629.13"><vh>data</vh></v>
</v>
<v t="ekr.20060626084629.12"><vh>indent-relative</vh></v>
<v t="ekr.20060626084629.15"><vh>autocompleter test</vh></v>
<v t="ekr.20060626084629.17"><vh>testClass (for test of self completion)</vh>
<v t="ekr.20060626084629.18"><vh>ctor</vh></v>
<v t="ekr.20060626084629.19"><vh>spam</vh></v>
<v t="ekr.20060626084629.20"><vh>eggs</vh></v>
<v t="ekr.20060626084629.21"><vh>bad</vh></v>
<v t="ekr.20060626084629.22"><vh>test of self</vh></v>
</v>
<v t="ekr.20060626084629.49"><vh>test g.cantImportDialog</vh>
<v t="ekr.20060626084629.50"><vh>createFrame</vh></v>
<v t="ekr.20060626084629.51"><vh>createButtons</vh></v>
</v>
<v t="ekr.20060626084629.52"><vh>test of clear-selected-text</vh></v>
<v t="ekr.20060626084629.53"><vh>test of clean-lines</vh></v>
<v t="ekr.20060626084629.55"><vh>Move lines up/down</vh>
<v t="ekr.20060626084629.56"><vh>add/remove tests</vh></v>
<v t="ekr.20060626084629.57"><vh>@@button move-lines-down</vh></v>
<v t="ekr.20060626084629.58"><vh>@@button move-lines-up</vh></v>
<v t="ekr.20060626084629.59"><vh>@@button toggle-show-invisibles</vh></v>
<v t="ekr.20060626084629.60"><vh>before</vh></v>
<v t="ekr.20060626084629.61"><vh>move test</vh></v>
<v t="ekr.20060626084629.62"><vh>after</vh></v>
</v>
<v t="ekr.20060626084629.63"><vh>Incremental searches</vh>
<v t="ekr.20060626084629.64"><vh>@@button isearch-forward</vh></v>
<v t="ekr.20060626084629.65"><vh>@@button isearch-backward</vh></v>
<v t="ekr.20060626084629.66"><vh>Node 1</vh></v>
<v t="ekr.20060626084629.67"><vh>Node 2</vh></v>
</v>
<v t="ekr.20060626084629.69"><vh>open-name </vh></v>
<v t="ekr.20060626084629.75"><vh>@image c:/prog/test/PythonPowered.gif</vh></v>
<v t="ekr.20060626084629.89"><vh>call g.makeScriptButton</vh></v>
<v t="ekr.20060626084629.90"><vh>Indentation error</vh></v>
<v t="ekr.20060626084629.91"><vh>Test removeSentinelLines</vh>
<v t="ekr.20060626084629.92"><vh>@@file testRemoveSentinels.py</vh>
<v t="ekr.20060626084629.93"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060626084629.94"><vh>spam</vh></v>
</v>
</v>
</v>
<v t="ekr.20061023080533" a="TV"><vh>Scripts that make unit tests</vh>
<v t="ekr.20061023080533.1"><vh>@command make-test @key=Ctrl-1</vh></v>
<v t="ekr.20061023080533.2"><vh>@command do-before @key=Ctrl-2</vh>
<v t="ekr.20061023080533.3"><vh>getSel</vh></v>
<v t="ekr.20061023080533.4"><vh>findNodes</vh></v>
<v t="ekr.20061023080533.5"><vh>putSelectionInHeadline</vh></v>
</v>
<v t="ekr.20061023080533.6"><vh>@command do-after @key=Ctrl-3</vh>
<v t="ekr.20061023080533.7"><vh>getSel</vh></v>
<v t="ekr.20061023080533.8"><vh>findNodes</vh></v>
<v t="ekr.20061023080533.9"><vh>putSelectionInHeadline</vh></v>
</v>
<v t="ekr.20061023080533.10"><vh>@test kill-line</vh>
<v t="ekr.20061023080533.11"><vh>work</vh></v>
<v t="ekr.20061023080533.12"><vh>before sel=2.0,2.6</vh></v>
<v t="ekr.20061023080533.13"><vh>after sel=2.0,2.0</vh></v>
</v>
<v t="ekr.20061023111426"><vh>create test buttons from list</vh>
<v t="ekr.20061023111426.1"><vh>&lt;&lt; define aList &gt;&gt;</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20051208082927">@ This file is called from ut.batch.

It should contain quick unit tests to be run in Leo's batch mode.

It also defines ut.bat itself.</t>
<t tx="ekr.20051208083135">cd c:\prog\leoCVS\leo\test
python ..\src\leo.py -script ..\test\ut.py</t>
<t tx="ekr.20051208085841">assert True</t>
<t tx="ekr.20051208085841.1">assert False,'This should fail'</t>
<t tx="ekr.20060124103819">cd c:\prog\leoCVS\leo\test
python ..\src\leo.py -script-window ..\test\ut.py</t>
<t tx="ekr.20060129090836"></t>
<t tx="ekr.20060129185431">import string
k = c.k ; key = 0 ; shift = 1 ; ctrl = 4 ; alt = 0x20000

prefixes = (
    ('',0),('Alt-',alt),('Ctrl-',ctrl),
    ('Shift-',shift),('Alt-Shift-',alt+shift),('Alt-Ctrl-',alt+ctrl),
)

for prefix,state in prefixes:
    for ch in string.printable:
        if prefix.find('Shift-') &gt; -1 and ch not in string.letters:
            continue # The shift would be ignored.
        ch2 = k.tkBindNamesDict.get(ch) or ch
        setting = prefix + ch2
        stroke = k.strokeFromSetting(setting)
        if not stroke: continue
        if (shift &amp; state) != 0: ch = ch.upper()
        event = g.Bunch(char=ch,keysym=ch,state=state)
        stroke2 = k.strokeFromEvent(event)
        assert stroke2==stroke,\
            'strokefromSetting: %s, strokeFromEvent: %s' % (repr(stroke),repr(stroke2))</t>
<t tx="ekr.20060208071636"></t>
<t tx="ekr.20060301122618"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.doTests(c,all=False)</t>
<t tx="ekr.20060301122644"></t>
<t tx="ekr.20060301122644.1">c.save()
c.redraw_now() # Must be done here.</t>
<t tx="ekr.20060626084629"></t>
<t tx="ekr.20060626084629.11">c.executeMinibufferCommand('remove-blank-lines')</t>
<t tx="ekr.20060626084629.12">c.executeMinibufferCommand('indent-relative')</t>
<t tx="ekr.20060626084629.13">a
 
b

c
d

e

This is a test of navigation.
</t>
<t tx="ekr.20060626084629.15">@others

print '-' * 20

for s in (
    'a bc',
    'a.bc',
    'abc ',
    ' abc',
):
    print 's',repr(s), repr(reverseFindWhitespace(s))</t>
<t tx="ekr.20060626084629.17">class testClass:
    
    '''A class to test the forgiving parser.'''
    
    @others</t>
<t tx="ekr.20060626084629.18">def __init__ (self,c):
    self.c = c
    self.d = '1'
    self.e = '2'</t>
<t tx="ekr.20060626084629.19">def spam (self,s,p,a,m=[]):
    pass</t>
<t tx="ekr.20060626084629.20">def eggs(self,e,g,s):
    pass</t>
<t tx="ekr.20060626084629.21">def bad (self):
    self = </t>
<t tx="ekr.20060626084629.22">self.</t>
<t tx="ekr.20060626084629.49">g.cantImportDialog("Leo's core",'xyzzy')</t>
<t tx="ekr.20060626084629.50">def createFrame(root,title,message):
    
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    top = Tk.Toplevel(root)
    top.title(title)
    
    def onKey(event,top=top):
        if event.char.lower() in ('\n','\r'):
            top.destroy()
    top.bind("&lt;Key&gt;",onKey)

    f = Tk.Frame(top)
    f.pack(side="top",expand=1,fill="both")
    
    label = Tk.Label(f,text=message)
    label.pack(pady=10)
    
    def okButton(top=top):
        top.destroy()
    
    buttons = {"text":'OK',"command":okButton,"default":True}, # Singleton tuple.
    createButtons(top,buttons)
    
    # top.protocol("WM_DELETE_WINDOW",onClose)
    
    # Attach the icon at idle time.
    def attachIconCallback(top=top):
        g.app.gui.attachLeoIcon(top)
    top.after_idle(attachIconCallback)
    return top</t>
<t tx="ekr.20060626084629.51">def createButtons (top,buttons):
    
    """Create a row of buttons.
    
    buttons is a list of dictionaries containing the properties of each button."""
    
    f = Tk.Frame(top)
    f.pack(side="top",padx=30)

    buttonList = []
    for d in buttons:
        text = d.get("text","&lt;missing button name&gt;")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)</t>
<t tx="ekr.20060626084629.52">abc
xyz
pdq</t>
<t tx="ekr.20060626084629.53">before
first
    
b   
    c
        
last
after</t>
<t tx="ekr.20060626084629.55"></t>
<t tx="ekr.20060626084629.56">a
   b
c
 abcde
e
f</t>
<t tx="ekr.20060626084629.57">event = g.Bunch(widget = g.app.gui.get_focus(c))
c.editCommands.moveLinesDown(event)</t>
<t tx="ekr.20060626084629.58">event = g.Bunch(widget = g.app.gui.get_focus(c))
c.editCommands.moveLinesUp(event)</t>
<t tx="ekr.20060626084629.59">c.viewAllCharacters()</t>
<t tx="ekr.20060626084629.60">before1
before2</t>
<t tx="ekr.20060626084629.61">start1
start2
line a   xxx
line b   y
line c      z
end
end2</t>
<t tx="ekr.20060626084629.62">after1
after2</t>
<t tx="ekr.20060626084629.63"></t>
<t tx="ekr.20060626084629.64">event = g.Bunch(widget=g.app.gui.get_focus(c),char='',keysym='')

c.searchCommands.isearchForward(event)</t>
<t tx="ekr.20060626084629.65">event = g.Bunch(widget=g.app.gui.get_focus(c),char='',keysym='')

c.searchCommands.isearchBackward(event)</t>
<t tx="ekr.20060626084629.66">abcde</t>
<t tx="ekr.20060626084629.67">abzde</t>
<t tx="ekr.20060626084629.69">c.editFileCommands.openOutlineByName(event=None)</t>
<t tx="ekr.20060626084629.75"></t>
<t tx="ekr.20060626084629.89"># g.makeScriptButton(c,p=p)

g.makeScriptButton(c,buttonText='HelloWorld',script="g.es_print('Hello World',color='red')")</t>
<t tx="ekr.20060626084629.90">if 1:
    print c.k.mb_history
  #indentation error
  print 'oops'</t>
<t tx="ekr.20060626084629.91">f = file('testRemoveSentinels.py')
s = f.read()
f.close()

result = c.importCommands.removeSentinelLines(s,'#',None,None)
print '-' * 40
print s
print '-' * 40
print result</t>
<t tx="ekr.20060626084629.92"># Important: the execute-script command will insert @verbatim sentinels
# before anything that looks like a sentinel, so the test requires an external file.
'''docstring'''
&lt;&lt; imports &gt;&gt;
@others
# end</t>
<t tx="ekr.20060626084629.93">import sys</t>
<t tx="ekr.20060626084629.94">def spam ():
    pass</t>
<t tx="ekr.20060626085103"></t>
<t tx="ekr.20060626085103.1">@language tcltk</t>
<t tx="ekr.20060626085103.2"># To use this script, you must make this a script button, either with the
# 'Script Button' button or by making this an @button node.

# Executes body text of selected node as a tcl script.
# For more information, see http://wiki.tcl.tk/6878

# This statement allows you to organize your scripts using noweb markup.
s = g.getScript(c,p,forcePythonSentinels=False)
g.es(g.app.root.tk.eval(s))</t>
<t tx="ekr.20060626085103.3"># This is a comment
set x 50
return [expr $x*10]</t>
<t tx="ekr.20060626085103.4">@others</t>
<t tx="ekr.20060626085103.5"># This is a comment
set x 50 +
return [expr $x*10]</t>
<t tx="ekr.20060626085103.6">import os, sys, threading

python = sys.executable
pythonDir,junk = g.os_path_split(python)
pydoc = g.os_path_join(pythonDir,'Lib','pydoc.py')
command = '%s %s -g' % (python,pydoc)

# Execute the command in a separate thread.
def go():
    os.system(command)
    
threading.Thread(target=go).start()</t>
<t tx="ekr.20060626085103.7"># **** Change these as needed ***
import os, sys

tempFileName = g.os_path_abspath(
    g.os_path_join(g.app.testDir,'jythonScript.py'))

if sys.platform == 'win32':
    jython = r'C:\Jython-21\jython.bat'
    command = '%s "%s"' % (jython,tempFileName) 
else:
    jython = r'cd ~/jython-2.1 ; ./jython'
    command = '%s "%s" &amp;' % (jython,tempFileName)

script = g.getScript(c,p).strip()
if not script:
    s = "no script in %s" % p.headString()
    g.es(s) ; print s
else:
    f = file(tempFileName,'w')
    f.write(script + '\n')
    f.close()
    print command
    os.system(command)
</t>
<t tx="ekr.20060626085103.8">from IPython.Shell import IPShellEmbed

ipshell = IPShellEmbed()
ipshell()</t>
<t tx="ekr.20060626085103.9"># Move selected text of the body up one line.

@others

moveLinesUp(c,p)</t>
<t tx="ekr.20060626085103.10">def moveLinesUp(c,p):
    
    undoType = 'Move Lines Up'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not head or not lines: return
    # A slight adjustment: lines doesn't end in '\n'.
    head = g.splitLines(head)
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines up.
    lines.append(head[-1])
    head = head[:-1]
    # Convert back to strings.
    head = ''.join(head)
    lines = ''.join(lines)[:-1] # Undo the adjustment above.
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)-1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)-1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20060626085103.11"># Move selected text of the body down one line.

@others

moveLinesDown(c,p)</t>
<t tx="ekr.20060626085103.12">def moveLinesDown(c,p):
    
    undoType = 'Move Lines Down'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not tail or not lines: return
    tail = g.splitLines(tail)[1:]
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines down.
    lines.insert(0,tail[0])
    tail = tail[1:]
    if not tail: lines.insert(1,'\n')
    # Convert back to strings.
    tail = ''.join(tail)
    lines = ''.join(lines)
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)+1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)+1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20060626085103.13">result = []
firstLevel = p.level()

for p in p.self_and_subtree_iter():
    head = p.moreHead(firstLevel)
    head = g.toEncodedString(head,'ascii',reportErrors=True)
    result.append(head)
    body = p.moreBody() # Inserts escapes for '+' and '-' characters.
    if body:
        body = g.toEncodedString(body,'ascii',reportErrors=True)
        result.append(body)

result = '\n'.join(result) + '\n'
# print result
w = c.frame.body.bodyCtrl
w.clipboard_clear()
w.clipboard_append(result)</t>
<t tx="ekr.20060626085103.14">c.frame.tree.OnIconDoubleClick(p)
</t>
<t tx="ekr.20060626085103.15">@others

d = g.scanDirectives(c,p)
w = d.get('pagewidth',100)
tab_width = d.get('tabwidth',4)

print '*' * 60

if d.get('language','').lower() == 'python':
    result = [] ; inComment = False ; inString = False
    for line in g.splitlines(p.bodyString()):
        i,junk = g.skip_leading_ws_with_indent(line,0,tab_width)
        lws = line[:i]
        # g.trace('lws',repr(lws))
        result.extend(splitLongLine(line,lws,w,tab_width,inComment,inString))
    
    print ''.join(result)
else:
    print 'Not Python code'</t>
<t tx="ekr.20060626085103.16">@

Bug: can't split after opening quote.
* Handle-triple-quote strings properly.
** Skip @doc parts.
- Handle tabs properly when splitting.</t>
<t tx="ekr.20060626085103.17">def splitLongLine(s,lws,w,tab_width,inComment,inString):

    if not s or g.computeWidth (s,tab_width) &lt; w:
        return [s]
        
    i,inComment,inString,backslash = chooseBreakPoint(s,w,tab_width,inComment,inString)
    if i is None: return [s]

    if inComment:
        tab = ''
    else:
        tab = g.choose(tab_width &lt; 0,' ' * abs(tab_width),'\t')
    comment = g.choose(inComment,'# ','')
    list1 = [s[:i+1]]
    list2 = splitLongLine(s[i+1:],lws+tab,w,tab_width,inComment,inString)
    list1.append('%s\n%s%s%s' % (backslash,lws,comment,tab))
    list1.extend(list2)
    return list1</t>
<t tx="ekr.20060626085103.18">def chooseBreakPoint (s,w,tab_width,inComment,inString):
    
    '''Return (i,inComment,inString,backSlash) where::
    - i is the index at which to break the line.
    - inComment is True if we are in a comment.
    - inString is True if we are in a string.
    - backslash is '\\' if the broken line must end in a backslash'''

    i, i2 = -1,-1 # The index of the rightmost valid breakpoint.
    for k in xrange(len(s)):
        ch = s[k]
        if k &gt;= w and i &gt; -1:
            break
        elif inComment:
            if ch in (' ','\t'): i = k
        elif ch in ('"',"'"):
            inString = not inString
            if not inString:
                i = max(0,k-1) ; i2 = -1
        elif inString:
            if ch in (' ','\t'): i = k
        else:
            if ch in ('(','[')  and g.skip_ws(s,k+1) &gt; abs(tab_width):
                i = k ;  g.trace(k,repr(ch),repr(s))
            if ch in (' ','\t') and g.skip_ws(s,k) &gt; abs(tab_width):
                i2 = k ;  g.trace(k,repr(ch),repr(s))
            if ch == '#':
                inComment = True ; inString = False; i = k ; i2 = -1

    if i == -1 and i2 == -1:
        return None,inComment,inString,'' # No break is possible.
    elif i == -1:
        # Break at a blank.
        i2 = max(i2,g.skip_ws(s,i2)-1)
        return i2,inComment,inString,'\\'
    elif inComment:
        i = max(i,g.skip_ws(s,i)-1)
        return i,True,False,''
    elif inString:
        i = max(i,g.skip_ws(s,i)-1)
        return i,False,True,'\\'
    else:
        # Break at a bracket.
        i = max(i,g.skip_ws(s,i+1)-1)
        return i,False,False,''</t>
<t tx="ekr.20060626085103.19">c.keyHandler.simulateCommand('enter-file-mode')</t>
<t tx="ekr.20060626085103.20">c.debugCommands.freeTreeWidgets()</t>
<t tx="ekr.20060626085103.21">c.debugCommands.verboseDumpObjects()</t>
<t tx="ekr.20060626085103.22">c.debugCommands.dumpNewObjects()</t>
<t tx="ekr.20060626085103.23">c.debugCommands.enableGcTrace()
g.collectGarbage()</t>
<t tx="ekr.20060626085103.24">g.app.trace_gc = False</t>
<t tx="ekr.20060626085103.25">c.debugCommands.dumpAllObjects()</t>
<t tx="ekr.20060626085103.26">import leoTest
leoTest.runTimerOnNode(c,p,count=100)</t>
<t tx="ekr.20060626085103.27">c.debugCommands.printStats()</t>
<t tx="ekr.20060626085103.28">name = "scripts.leo"
fileName = g.os_path_join(g.app.loadDir,"..","scripts",name)
ok,frame = g.openWithFileName(fileName,c)
if not ok:
    g.es("not found: %s" % name)</t>
<t tx="ekr.20060626085103.29">&lt;&lt; docstring &gt;&gt;

import leoConfig

# The user's previous (and preferred) leoSettings.leo file.
path1 = r'c:\prog\leoCVS\leo\config\leoSettings.leo'

# The new distribution leoSettings.leo file.
path2 = r'c:\prog\leoCVS\leo\config\leoSettings2.leo'

@others

# print '*' * 40

updateClass(c,path1,path2).update()</t>
<t tx="ekr.20060626085103.30">'''Here is a **preliminary** script that updates a new leoSettings.leo file
(path2) from the settings in a previous leoSettings.leo file (path1).
Presumably, the path2 file is the leoSettings.leo file from a new distribution,
and the path1 file a leoSettings.leo file containing settings that you have
modified.  You must specify the full path of both files in the top-level @button node.

**Warning**: This script modifies the path2 file. Make sure that you don't mind
modifying this file.

**Warning**: This script is unsophisticated in its update algorithm. If if finds
corresponding nodes (node with the same settings name) in both outlines it simply
replaces the node in the path2 file with the node in the path1 file. In
particular, it does not keep track of individual shortcuts: it repaces the body
of one @shortcuts node with the body of the corresponding @shortcuts node.

**Note**: If the path1 file contains a settings node not in the path2 file it
attempts to create a new node in the corresponding place in the path2 file. If
this is not possible, say because the structures of the files are different, the
script places the new node as the last child of the @settings node in the path2
file. '''</t>
<t tx="ekr.20060626085103.31">class updateParser (leoConfig.parserBaseClass):
    
    '''A settings parser that returns bunches used for updates.'''
    
    @others</t>
<t tx="ekr.20060626085103.32">def __init__ (self,c,tag):

    # Init the base class.
    leoConfig.parserBaseClass.__init__(self,c)
    self.tag = tag</t>
<t tx="ekr.20060626085103.33">def visitNode (self,p):
    
        """Init any settings found in node p."""
        
        munge = g.app.config.munge
    
        kind,name,val = self.parseHeadline(p.headString())
        kind = munge(kind)
    
        if kind == "settings":
            pass
        elif kind not in self.control_types and val in (u'None',u'none','None','none','',None):
            # None is valid for all data types.
            self.set(p.copy(),kind,name,None)
        elif kind in self.control_types or kind in self.basic_types:
            kindHandler = self.dispatchDict.get(kind)
            try:
                return kindHandler(p.copy(),kind,name,val)
            except TypeError:
                g.es_exception()
                print "*** no handler",kind
        elif name:
            # self.error("unknown type %s for setting %s" % (kind,name))
            # Just assume the type is a string.
            self.set(p.copy(),kind,name,val)
        
        return None</t>
<t tx="ekr.20060626085103.34"></t>
<t tx="ekr.20060626085103.35">def doFont (self,p,kind,name,val):
    
    self.set(p,kind,name,val)</t>
<t tx="ekr.20060626085103.36">def doShortcut(self,p,kind,name,val):

    self.set(p,kind,name,val)</t>
<t tx="ekr.20060626085103.37">def doShortcuts(self,p,kind,name,val):
    
    self.set(p,kind,name,val)</t>
<t tx="ekr.20060626085103.38"># Unlike in Leo's core, p and p.c are stable.

def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""

    c = self.c ; d = self.settingsDict 
    if not kind: return
    
    key = self.munge(name)
    if d.get(key):
        # This is a user error, and should be corrected before merging.
        g.es('*** ignoring duplicate setting for %s in %s' % (
            name,c.fileName()))
    else:
        d[key] = g.Bunch(p=p,kind=kind,name=name,val=val)
        if 0:
            if kind.startswith('strings'): kind = 'strings[]'
            g.trace('%s %10s %45s %s' %(self.tag,kind,name,val))
</t>
<t tx="ekr.20060626085103.39">class updateClass:
    
    '''Update path2 (distribution) leoSettings.leo from path1 (user's) leoSettings.leo file.'''
    
    @others</t>
<t tx="ekr.20060626085103.40">def __init__ (self,c,path1,path2):
    
    self.c = c
    self.path1 = path1 # The user's previous (and preferred) leoSettings.leo file.
    self.path2 = path2 # The new distribution leoSettings.leo file.</t>
<t tx="ekr.20060626085103.41">def add (self,bunch1,c1,c2):

    '''Add a node to c2 in the same position as bunch.p in c1.
    
    If this is not possible, put the node at the end of @settings tree.'''

    p1 = bunch1.p
    parent1 = p1.parent() # Must exist because p is in an @settings tree.
    n = p1.childIndex()
    h = parent1.headString()
    settings2 = g.findNodeAnywhere(c2,'@settings') 
    assert (settings2) # This has already been checked.

    # Create the node.
    if h.startswith('@settings'):
        p2 = parent2 = settings2.insertAsLastChild()
    else:
        parent2 = g.findNodeInTree(c2,settings2,h)
        if parent2:
            p2 = parent2.insertAsNthChild(n)
        else:
            self.warning('no corresponding parent node for %s' % h)
            p2 = settings2.insertAsLastChild()
            
    # Copy the head and body strings.
    p2.setBodyString(p1.bodyString())
    p2.setHeadString(p1.headString())</t>
<t tx="ekr.20060626085103.42">def change (self,bunch1,bunch2):
    
    '''Change the bunch2.p to match bunch1.p.'''

    p1 = bunch1.p ; p2 = bunch2.p
    p2.setBodyString(p1.bodyString())
    p2.setHeadString(p1.headString())</t>
<t tx="ekr.20060626085103.43">def error (self,s):
    
    g.es_print(s, color='red')
    
def message (self,s):
    
    g.es_print(s, color='blue')

def warning (self,s):
    
    g.es_print(s, color='red')</t>
<t tx="ekr.20060626085103.44">def open (self, path):
    
    if not g.os_path_exists(path):
        self.error('does not exist: %s' % s)
        return None
    
    c = g.app.config.openSettingsFile(path)

    if not c:
        return None
    elif g.findNodeAnywhere(c,'@settings'):
        return c
    else:
        self.error('no @settings node in %s' % path)
        return None</t>
<t tx="ekr.20060626085103.45">def update (self):

    c = self.c
    c1 = self.open(self.path1)
    c2 = self.open(self.path2)
    g.app.log = c.frame.log
    if not c1 or not c2: return
    # Update c2 from settings in c1.
    d1 = updateParser(c1,'1').traverse()
    d2 = updateParser(c2,'2').traverse()
    changed = False
    for key in d1.keys():
        b1 = d1.get(key) # A bunch created by set or None.
        b2 = d2.get(key) # A bunch created by set or None.
        if key not in d2.keys():
            self.message('%7s %s = %s' % ('added',b1.name,b1.val))
            self.add(b1,c1,c2) ; changed = True
        elif b1.val == b2.val:
            pass # ; self.message('%7s %40s %s' % ('equal',b1.name,b1.val))
        else:
            self.message('%7s %s from %s to %s' % ('changed',b1.name,b2.val,b1.val))
            self.change(b1,b2) ; changed = True
    if changed:
        c2.save()
    self.message('update settings done')</t>
<t tx="ekr.20060626085103.46">event = g.Bunch(widget=g.app.gui.get_focus(c),char='',keysym='')

c.editFileCommands.openOutlineByName(event)</t>
<t tx="ekr.20060626085103.47">import Tkinter as Tk
@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)</t>
<t tx="ekr.20060626085103.48">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others</t>
<t tx="ekr.20060626085103.49">def __init__ (self,c):
    self.c = c
    
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")</t>
<t tx="ekr.20060626085103.50">def getAllClones(self,p):

    return [p2.copy() for p2 in self.c.allNodes_iter() if p2.v.t == p.v.t]</t>
<t tx="ekr.20060626085103.51">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.currentPosition()
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.headString())
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060626085103.52"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().headString()
    else:
        text = "&lt;top level&gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)</t>
<t tx="ekr.20060626085103.53"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):

    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return

self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20060626085103.55">import doctest
import os

# create temporary file and write this node subtree to it
file, filename = g.create_temp_file()
c.importCommands.flattenOutline(filename)
# the file is now created and closed

# prepare content for testing
# strip trailing whitespace, an annoying source of doctest failures
text = open(filename).readlines()
text = [line.strip() for line in text]
text = "\n".join(text)

# run doctest on temporary file
file.write(text)
file.close()
# g.es(filename)
failures, tests = doctest.testfile(filename, module_relative = False)
os.remove(filename)

# report summary of results in Leo
if failures == 0:
    g.es("%s tests run successfully" % tests, color="blue")
if failures == 1:
    g.es("There was one failure in %s tests" % tests, color="red")    
if failures &gt; 1:
    g.es("%s failures in %s tests" % (failures, tests), color="red")</t>
<t tx="ekr.20060626085103.56">target = r'c:\prog\tigris-cvs\leo\src\leo.py'

c.debugCommands.debug(target=target)</t>
<t tx="ekr.20060626085103.57">c.debugCommands.debug()</t>
<t tx="ekr.20060626085103.58"># Delete a body pane editor.

c.frame.body.deleteEditor()</t>
<t tx="ekr.20060626085103.59"># Cycle focus through body pane editors.

c.frame.body.cycleEditorFocus()
g.app.gui.set_focus(c,c.frame.body.bodyCtrl)</t>
<t tx="ekr.20060626085103.60"># Add a body editor.

c.frame.body.addEditor()
g.app.gui.set_focus(c,c.frame.body.bodyCtrl)</t>
<t tx="ekr.20060626085103.61">import leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    controller = rst3.controllers.get(c)
    if controller:
        controller.processTopTree(p)
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True</t>
<t tx="ekr.20060626085246"># You can run all tests by selecting the Unit Test headline.

import leoTest

leoTest.doTests(c,all=False)</t>
<t tx="ekr.20060914121042">chapter_hoist.py
cleo.py
vim.py
word_export.py
xemacs.py</t>
<t tx="ekr.20060914121042.1">import leoPlugins

plugin = leoPlugins.loadOnePlugin ('leo_to_html')

plugin.export_html(c)</t>
<t tx="ekr.20060914123717">import leoPlugins

plugin = leoPlugins.loadOnePlugin ('leo_to_rtf')

plugin.export_rtf(c)</t>
<t tx="ekr.20060914123949">import leoPlugins

if not leoPlugins.isLoaded('chapter_hoist'):

    plugin = leoPlugins.loadOnePlugin ('chapter_hoist',verbose=True)
    plugin.onCreate(tag='unit-test',keys={'c':c})
</t>
<t tx="ekr.20060914125424">import leoPlugins

if not leoPlugins.isLoaded('mod_scripting'):

    plugin = leoPlugins.loadOnePlugin ('mod_scripting',verbose=True)
    plugin.onCreate(tag='unit-test',keys={'c':c})</t>
<t tx="ekr.20060914125710">import leoPlugins

if not leoPlugins.isLoaded('open_with'):

    plugin = leoPlugins.loadOnePlugin ('open_with',verbose=True)
    plugin.create_open_with_menu(tag='unit-test',keyswords={'c':c})</t>
<t tx="ekr.20060914130213">import leoPlugins

if not leoPlugins.isLoaded('rst3'):

    plugin = leoPlugins.loadOnePlugin ('rst3',verbose=True)
    plugin.onCreate(tag='unit-test',keywords={'c':c})</t>
<t tx="ekr.20060914130545">import leoPlugins

if not leoPlugins.isLoaded('UNL'):

    plugin = leoPlugins.loadOnePlugin ('UNL',verbose=True)
    plugin.createStatusLine(tag='unit-test',keywords={'c':c})</t>
<t tx="ekr.20060914130924">import leoPlugins

if not leoPlugins.isLoaded('paste_as_headlines'):

    plugin = leoPlugins.loadOnePlugin ('paste_as_headlines',verbose=True)
    plugin.createPasteAsHeadlinesMenu(tag='unit-test',keywords={'c':c})</t>
<t tx="ekr.20061023080533"></t>
<t tx="ekr.20061023080533.1">workBody = '''first line
line 1
    line a
        line b
line c
last line
'''

c.beginUpdate()
try:
    p1 = p.insertAfter()
    c.setHeadString(p1,'@test ')
    body = 'import leoTest\nleoTest.runEditCommandTest(c,p)'
    c.setBodyString(p1,body)
    for s in ('work','before','after'):
        p2 = p1.insertAsLastChild()
        c.setHeadString(p2,s)
        if s == 'work':
            c.setBodyString(p2,workBody)
    p1.expand()
finally:
    c.endUpdate()
    c.editPosition(p1)</t>
<t tx="ekr.20061023080533.2">@
p should be in tree whose root is a @test node containing 'work', 'before' and
'after' children. The work node should have body text. If all is as expected,
copy the body text the work node to the before node, and represent the selection
range of the work in the headline of the before node.
@c

@others

sel = getSel(c)
top,work,before,after = findNodes(p)
if top and work.bodyString():
    c.beginUpdate()
    try:
        c.setBodyString(before,work.bodyString())
        c.setBodyString(after,'')
        putSelectionInHeadline(c,before,'before',sel)
    finally:
        c.endUpdate()
else:
    g.es_print('do-before: not in a proper @test tree')</t>
<t tx="ekr.20061023080533.3">def getSel(c):
    
    w = c.frame.body.bodyCtrl
    sel = g.app.gui.getSelectionRange(w)
    if not sel:
        i = g.app.gui.getInsertPoint(w)
        sel = (i,i)
    return sel</t>
<t tx="ekr.20061023080533.4">def findNodes(p):
    
    '''Find the top, work, before and after nodes.
    p should be in tree whose root is a @test node containing
    'work', 'before' and 'after' children.'''
    
    for p in p.self_and_parents_iter():
        if p.headString().startswith('@test '):
            break
    top    = p and p.copy()
    work   = top and top.firstChild() 
    before = work and work.next()     
    after  = before and before.next()
    if (
        work   and work.headString().startswith('work') and
        before and before.headString().startswith('before') and
        after  and after.headString().startswith('after')
    ):
        return top,work,before,after
    else:
        return None,None,None,None</t>
<t tx="ekr.20061023080533.5">def putSelectionInHeadline (c,p,prefix,sel):
    
    # g.trace(p.headString(),repr(sel))
    
    if not sel:
        sel = ('1.0','1.0')

    s = '%s sel=%s,%s' % (prefix,sel[0],sel[1])

    c.setHeadString(p,s)
    
    </t>
<t tx="ekr.20061023080533.6">@
p should be in tree whose root is a @test node containing 'work', 'before' and
'after' children. If all is as expected, copy the work node to the after node,
and represent the selection range of the work node in the headline of the after node.
@c

@others

sel = getSel(c)
top,work,before,after = findNodes(p)
if top:
    c.beginUpdate()
    try:
        c.setBodyString(after,work.bodyString())
        putSelectionInHeadline(c,after,'after',sel)
    finally:
        c.endUpdate()
else:
    g.es_print('do-after: not in @test tree')</t>
<t tx="ekr.20061023080533.7">def getSel(c):
    
    w = c.frame.body.bodyCtrl
    sel = g.app.gui.getSelectionRange(w)
    if not sel:
        i = g.app.gui.getInsertPoint(w)
        sel = (i,i)
    return sel</t>
<t tx="ekr.20061023080533.8">def findNodes(p):
    
    '''Find the top, work, before and after nodes.
    p should be in tree whose root is a @test node containing
    'work', 'before' and 'after' children.'''
    
    for p in p.self_and_parents_iter():
        if p.headString().startswith('@test '):
            break
    top    = p and p.copy()
    work   = top and top.firstChild()
    before = work and work.next()
    after  = before and before.next()
    if (
        work   and work.headString().startswith('work') and
        before and before.headString().startswith('before') and
        after  and after.headString().startswith('after')
    ):
        return top,work,before,after
    else:
        return None,None,None,None</t>
<t tx="ekr.20061023080533.9">def putSelectionInHeadline (c,p,prefix,sel):
    
    # g.trace(p.headString(),repr(sel))
    
    if not sel:
        sel = ('1.0','1.0')

    s = '%s sel=%s,%s' % (prefix,sel[0],sel[1])

    c.setHeadString(p,s)
    
    </t>
<t tx="ekr.20061023080533.10">import leoTest
leoTest.runEditCommandTest(c,p)</t>
<t tx="ekr.20061023080533.11">line 1
line 3</t>
<t tx="ekr.20061023080533.12">line 1
line 2
line 3</t>
<t tx="ekr.20061023080533.13">line 1
line 3</t>
<t tx="ekr.20061023111426">&lt;&lt; define aList &gt;&gt;

workBody = '''first line
line 1
    line a
        line b
line c
last line
'''

c.beginUpdate()
try:
    for h in aList:
        p1 = p.insertAfter()
        c.setHeadString(p1,'@test %s' % (h))
        body = 'import leoTest\nleoTest.runEditCommandTest(c,p)'
        c.setBodyString(p1,body)
        for s in ('work','before','after'):
            p2 = p1.insertAsLastChild()
            c.setHeadString(p2,s)
            if s == 'work':
                c.setBodyString(p2,workBody)
        # p1.expand()
finally:
    c.endUpdate()
    # c.editPosition(p1)</t>
<t tx="ekr.20061023111426.1">aList = (
    'back-char',
    'back-char-extend-selection',
    'back-paragraph',
    'back-paragraph-extend-selection',
    'back-sentence',
    'back-sentence-extend-selection',
    'back-word',
    'back-word-extend-selection',
    'backward-delete-char',
    'backward-kill-paragraph',
    'backward-find-character',
    'backward-find-character-extend-selection',
    'beginning-of-buffer',
    'beginning-of-buffer-extend-selection',
    'beginning-of-line',
    'beginning-of-line-extend-selection',
    'capitalize-word',
    'center-line',
    'center-region',
    'clean-lines',
    'clear-selected-text',
    'count-region',
    'dabbrev-completion',
    'dabbrev-expands',
    'delete-char',
    'delete-editor',
    'delete-indentation',
    'delete-spaces',
    'do-nothing',
    'downcase-region',
    'downcase-word',
    'end-of-buffer',
    'end-of-buffer-extend-selection',
    'end-of-line',
    'end-of-line-extend-selection',
    'exchange-point-mark',
    'extend-to-line',
    'extend-to-paragraph',
    'extend-to-sentence',
    'extend-to-word',
    'fill-paragraph',
    'fill-region',
    'fill-region-as-paragraph',
    'flush-lines',
    'forward-char',
    'forward-char-extend-selection',
    'forward-paragraph',
    'forward-paragraph-extend-selection',
    'forward-sentence',
    'forward-sentence-extend-selection',
    'forward-word',
    'forward-word-extend-selection',
    'goto-char',
    'how-many',
    'indent-relative',
    'indent-rigidly',
    'indent-to-comment-column',
    'insert-newline',
    'insert-parentheses',
    'keep-lines',
    'kill-paragraph',
    'move-lines-down',
    'move-lines-up',
    'move-past-close',
    'move-past-close-extend-selection',
    'newline-and-indent',
    'next-line',
    'next-line-extend-selection',
    'previous-line',
    'previous-line-extend-selection',
    'remove-blank-lines',
    'remove-space-from-lines',
    'remove-tab-from-lines',
    'reverse-region',
    'sort-columns',
    'sort-fields',
    'sort-lines',
    'split-line',
    'tabify',
    'transpose-chars',
    'transpose-lines',
    'transpose-words',
    'untabify',
    'upcase-region',
    'upcase-word',
)</t>
<t tx="ekr.20070920113956"></t>
</tnodes>
</leo_file>
