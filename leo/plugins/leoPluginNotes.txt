#@+leo-ver=5-thin
#@+node:ekr.20090430075506.3: * @file leoPluginNotes.txt
#@+all
#@+node:ekr.20120302043834.12029: ** Projects
#@+node:ekr.20120301114648.9929: *3* Define @command foo and foo as alt-x commands
#@+node:ekr.20060929135558: *4* cleanButtonText
def cleanButtonText (self,s,minimal=False):

    '''Clean the text following @button or @command so that it is a valid name of a minibuffer command.'''

    # 2011/10/16: Delete {tag}
    s = s.strip()
    i,j = s.find('{'),s.find('}')
    if -1 < i < j:
        s = s[:i] + s[j+1:]
        s = s.strip()
    if minimal:
        return s.lower()

    for tag in ('@key','@args',):
        i = s.find(tag)
        if i > -1:
            j = s.find('@',i+1)
            if i < j:
                s = s[:i] + s[j+1:]
            else:
                s = s[:i]
            s = s.strip()
    if 1: # Not great, but spaces, etc. interfere with tab completion.
        # 2011/10/16 *do* allow '@' sign.
        chars = g.toUnicode(string.ascii_letters + string.digits + '@')
        aList = [g.choose(ch in chars,ch,'-') for ch in g.toUnicode(s)]
        s = ''.join(aList)
        s = s.replace('--','-')
    while s.startswith('-'):
        s = s[1:]
    while s.endswith('-'):
        s = s[:-1]
    return s.lower()
#@+node:ekr.20060328125248.16: *4* getShortcut
def getShortcut(self,h):

    '''Returns the keyboard shortcut from the given headline string'''

    shortcut = None
    i = h.find('@key')

    if i > -1:
        j = g.skip_ws(h,i+len('@key'))
        if g.match(h,j,'='): j += 1
        shortcut = h[j:].strip()

    return shortcut
#@+node:ekr.20120301114648.9932: *4* registerTwoCommands
def registerTwoCommands(self,h,func,pane,tag):

    trace = False and not g.unitTesting
    k = self.c.k

    shortcut = self.getShortcut(h)
    s = self.cleanButtonText(h)

    if trace: g.trace(s)

    k.registerCommand(s,func=func,
        pane=pane,shortcut=shortcut,verbose=trace)
        
    for tag in ('@button-','@command-'):
        if s.startswith(tag):
            command = s[len(tag):].strip()
            # Create a *second* func, to avoid collision in c.commandsDict.
            if tag == '@button':
                def atButtonCallBack(event=None,func=func):
                    func()
                cb = atButtonCallBack
            else:
                def atCommandCallBack(event=None,func=func):
                    func()
                cb = atCommandCallBack
            if trace: g.trace('second',command)
            k.registerCommand(command,func=cb,
                pane=pane,shortcut=None,verbose=trace)
#@+node:ekr.20120301114648.9931: *4* Found: registerCommand
#@+node:ekr.20070926085149: *5* createAtButtonFromSettingHelper & callback
def createAtButtonFromSettingHelper (self,h,script,statusLine,bg='LightSteelBlue2'):

    '''Create a button from an @button node.

    - Calls createIconButton to do all standard button creation tasks.
    - Binds button presses to a callback that executes the script.
    '''
    
    c = self.c

    # We must define the callback *after* defining b,
    # so set both command and shortcut to None here.
    b = self.createIconButton(text=h,
        command=None,statusLine=statusLine,bg=bg)
    if not b: return None

    # Now that b is defined we can define the callback.
    # Yes, the callback *does* use b (to delete b if requested by the script).
    args = self.getArgs(h)
    buttonText = self.cleanButtonText(h)
    
    def atSettingButtonCallback (event=None,
        self=self,args=args,b=b,c=c,script=script,buttonText=buttonText
    ):
        self.executeScriptFromSettingButton (args,b,script,buttonText)
        if c.exists: c.outerUpdate()

    self.iconBar.setCommandForButton(b,atSettingButtonCallback)

    # At last we can define the command.
    self.registerTwoCommands(h,func=atSettingButtonCallback,
        pane='button',tag='@button')

    return b
#@+node:ekr.20070926085149.1: *6* executeScriptFromSettingButton (mod_scripting)
def executeScriptFromSettingButton (self,args,b,script,buttonText):

    '''Called from callbacks to execute the script in node p.'''

    c = self.c

    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
    else:
        g.app.scriptDict = {}
        c.executeScript(args=args,script=script,silent=True)
        # Remove the button if the script asks to be removed.
        if g.app.scriptDict.get('removeMe'):
            g.es("Removing '%s' button at its request" % buttonText)
            self.deleteButton(b)

    if 0: # Do *not* set focus here: the script may have changed the focus.
        c.frame.bodyWantsFocus()
#@+node:ekr.20080312071248.2: *5* createCommonCommands (mod_scripting)
def createCommonCommands (self):

    c = self.c ; k = c.k

    # trace = True and not g.app.unitTesting # and not g.app.batchMode
    aList = c.config.getCommands()
    if aList:
        for z in aList:
            h,script = z
            args = self.getArgs(h)
    
            def commonCommandCallback (event=None,script=script):
                c.executeScript(args=args,script=script,silent=True)
                
            self.registerTwoCommands(h,func=commonCommandCallback,
                pane='all',tag='global @command')
#@+node:ekr.20060328125248.10: *5* handleAtCommandNode @command (mod_scripting)
def handleAtCommandNode (self,p):

    '''Handle @command name [@key[=]shortcut].'''

    # trace = True and not g.app.unitTesting # and not g.app.batchMode

    c = self.c ; k = c.keyHandler ; h = p.h
    if not h.strip(): return

    args = self.getArgs(h)

    def atCommandCallback (event=None,args=args,c=c,p=p.copy()):
        c.executeScript(args=args,p=p,silent=True)
        
    self.registerTwoCommands(h,func=atCommandCallback,
        pane='all',tag='local @command')
#@+node:ekr.20060328125248.24: *5* createAtButtonHelper & callback
def createAtButtonHelper (self,p,h,statusLine,bg='LightSteelBlue1',verbose=True):

    '''Create a button from an @button node.

    - Calls createIconButton to do all standard button creation tasks.
    - Binds button presses to a callback that executes the script in node p.
    '''
    
    # trace = True and not g.unitTesting
    c = self.c ; k = c.k
    
    buttonText = self.cleanButtonText(h,minimal=True)

    # We must define the callback *after* defining b,
    # so set both command and shortcut to None here.
    b = self.createIconButton(text=h,command=None,statusLine=statusLine,bg=bg)
    if not b: return None

    # Now that b is defined we can define the callback.
    # Yes, executeScriptFromButton *does* use b (to delete b if requested by the script).
    # 20100518 - TNB replace callback function with callable class instance
    #   so qt gui can add 'Goto Script' command to context menu for button
    class atButtonCallback(object):
        def __init__(self,controller,p,b,c,buttonText):
            self.controller = controller
            self.p = p.copy()
            self.b = b
            self.c = c
            self.buttonText = buttonText

        def __call__(self, event=None):
            self.controller.executeScriptFromButton(self.p,self.b,self.buttonText)
            if self.c.exists: self.c.outerUpdate()
            
        # 2011/10/17: Add support for docstrings.
        def docstring(self):
            return g.getDocString(self.p.b)

    cb = atButtonCallback(controller=self,
        p=p.copy(),b=b,c=c,buttonText=buttonText)

    self.iconBar.setCommandForButton(b,cb)

    # At last we can define the command and use the shortcut.
    self.registerTwoCommands(h,func=cb,pane='button',tag='local @button')

    return b
#@+node:ekr.20060328125248.28: *6* executeScriptFromButton (mod_scripting)
def executeScriptFromButton (self,p,b,buttonText):

    '''Called from callbacks to execute the script in node p.'''

    c = self.c

    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
    else:
        g.app.scriptDict = {}
        h = p.h
        args = self.getArgs(h)
        c.executeScript(args=args,p=p,silent=True)
        # Remove the button if the script asks to be removed.
        if g.app.scriptDict.get('removeMe'):
            g.es("Removing '%s' button at its request" % buttonText)
            self.deleteButton(b)

    if 0: # Do *not* set focus here: the script may have changed the focus.
        c.frame.bodyWantsFocus()
#@+node:ekr.20060328125248.17: *5* createIconButton
def createIconButton (self,text,command,statusLine,bg):

    '''Create an icon button.  All icon buttons get created using this utility.

    - Creates the actual button and its balloon.
    - Adds the button to buttonsDict.
    - Registers command with the shortcut.
    - Creates x amd delete-x-button commands, where x is the cleaned button name.
    - Binds a right-click in the button to a callback that deletes the button.'''

    c = self.c ; k = c.k

    # Create the button and add it to the buttons dict.
    commandName = self.cleanButtonText(text)

    # Truncate only the text of the button, not the command name.
    truncatedText = self.truncateButtonText(commandName)
    if not truncatedText.strip():
        g.es_print('%s ignored: no cleaned text' % (text.strip() or ''),color='red')
        return None

    # Command may be None.
    b = self.iconBar.add(text=truncatedText,command=command,bg=bg)
    if not b: return None

    self.buttonsDict[b] = truncatedText

    if statusLine:
        self.createBalloon(b,statusLine)

    # Register the command name if it exists.
    if command:
        self.registerTwoCommands(text,func=command,
            pane='button',tag='icon button')

    # Define the callback used to delete the button.
    def deleteButtonCallback(event=None,self=self,b=b):
        self.deleteButton(b, event=event)

    # Register the delete-x-button command.
    deleteCommandName= 'delete-%s-button' % commandName
    k.registerCommand(deleteCommandName,shortcut=None,
        func=deleteButtonCallback,pane='button',verbose=False)
        # Reporting this command is way too annoying.

    return b
#@-all
#@-leo
