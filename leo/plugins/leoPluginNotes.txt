#@+leo-ver=5-thin
#@+node:ekr.20090430075506.3: * @file leoPluginNotes.txt
#@+all
#@+node:ekr.20090430075506.6: ** To do
#@+node:ekr.20090430102730.3: *3* Add expand_noweb_references for rst3 plugin
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/3cd5cb06d32264d

> What would work for me is if named sections in a @rst subtree
> would work exactly as they work for other derived files: they
> get inserted at the place where they are referenced.

- Add support for the following options:
    - expand_noweb_references: default False for compatibility.
    - ignore_noweb definitions: default False for compatibility.

- When expand_noweb_references is True, definitions (typically clones)
  must be descendants of the referencing node (in the @rst tree)
#@+node:ekr.20090430120622.2: *4* post
@nocolor-node

I want to write the documentation for the source program in a @rst3 subtree. In
this @rst3 subtree I want to refer to fragments of the program, like:

In the following code fragment::

  <<code fragment>>

Unfortunately, <<code fragment>> will not be expanded. Furthermore, in order to
get to this work, I should have <<code fragment>> under the @rst3 subtree as
well, but this is then also treated as @rst3 input (which in this case, is not
what I want).
#@+node:ekr.20050811101550.1: *4* writeBody & helpers
def writeBody (self,p):

    # remove trailing cruft and split into lines.
    lines = p.b.rstrip().split('\n') 

    if self.getOption('code_mode'):
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    s = '\n'.join(lines).strip()
    if s:
        self.write('%s\n\n' % s)
#@+node:ekr.20050811150541: *5* handleCodeMode & helper
def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    result = [] ; n = 0 ; code = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or
            (self.getOption('show_doc_parts_as_paragraphs') and self.isSpecialDocPart(s,None))
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        elif not code: # Start the code block.
            result.append('')
            result.append(self.code_block_string)
            code.append(s)
        else: # Continue the code block.
            code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []
    return self.rstripList(result)
#@+node:ekr.20050811152104: *6* formatCodeModeLine
def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
#@+node:ekr.20050813155021: *6* rstripList
def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    s = '\n'.join(theList).rstrip()
    return s.split('\n')
#@+node:ekr.20050813160208: *6* finishCodePart
def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
#@+node:ekr.20060608094815: *5* handleDocOnlyMode
def handleDocOnlyMode (self,p,lines):

    '''Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.'''

    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.h)
            self.writeHeadlineHelper(p)
    return result
#@+node:ekr.20060608094815.1: *5* isAnyDocPart
def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()
#@+node:ekr.20050811153208: *5* isSpecialDocPart
def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) > 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    return result
#@+node:ekr.20050811163802: *5* isAnySpecialDocPart
def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
#@+node:ekr.20050811105438: *5* removeLeoDirectives
def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,0,key):
                    # g.trace('removing %s' % s)
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
#@+node:ekr.20050811105438.1: *5* handleSpecialDocParts
def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    # g.trace(kind,g.listToString(lines))

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
#@+node:ekr.20050805162550.30: *5* replaceCodeBlockDirectives
def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result
#@+node:ekr.20110317080650.14388: ** Unused code
#@+node:leohag.20081203143921.18: *3* show (not used from scrolledmessage)
def show(self):
    
    g.trace(g.callers())
    
    self.ui.show()
#@+node:ekr.20110321072702.14506: *3* Unused viewrendered commands
#@+node:tbrown.20101127112443.14856: *4* g.command('viewrendered-html') (not used)
# @g.command('viewrendered-html')
# def viewrendered(event):
    # """Open view of html which would be rendered"""

    # c = event.get('c')
    # if c:
        # pc = controllers.get(c.hash())
        # if pc: pc.view('html')
#@+node:tbrown.20101127112443.14854: *4* g.command('viewrendered-big') (not used)
# @g.command('viewrendered-big')
# def viewrendered(event):
    # """Open render view for commander, with big text

    # (useful for presentations)

    # """

    # c = event.get('c')
    # if c:
        # pc = controllers.get(c.hash())
        # if pc:
            # w = pc.w
            # pc.view('big')
            # w.zoomIn(4)
#@+node:ekr.20110317080650.14383: *4* g.command('hide-rendering-pane') (not used)
# @g.command('hide-rendering-pane')
# def hide_rendering_pane(event):
    
    # '''Hide the rendering pane, but do not delete it.'''

    # c = event.get('c')
    # if c:
        # pc = controllers.get(c.hash())
        # if pc: pc.hide()
#@+node:ekr.20110929074744.15497: *3* Unused Tk stuff from plugins_menu.py
if 0:
    @others
#@+node:EKR.20040517080555.10: *4* class TkPropertiesDialog
class TkPropertiesDialog:

    """A class to create and run a Properties dialog"""

    @others
#@+node:bob.20071208030419: *5* __init__
def __init__(self, title, data, callback=None, buttons=[]):
    << docstring >>

    if buttons is None:
        buttons = []

    self.entries = []
    self.title = title
    self.callback = callback
    self.buttons = buttons
    self.data = data

    << create the frame from the configuration data >>
#@+node:bob.20071208211442: *6* << docstring >>
""" Initializes and shows a Properties dialog.

    'buttons' should be a list of names for buttons.

    'callback' should be None or a function of the form:

        def cb(name, data)
            ...
            return 'close' # or anything other than 'close'

    where name is the name of the button clicked and data is
    a data structure representing the current state of the dialog.

    If a callback is provided then when a button (other than
    'OK' or 'Cancel') is clicked then the callback will be called
    with name and data as parameters.

        If the literal string 'close' is returned from the callback
        the dialog will be closed and self.result will be set to a
        tuple (button, data).

        If anything other than the literal string 'close' is returned
        from the callback, the dialog will continue to be displayed.

    If no callback is provided then when a button is clicked the
    dialog will be closed and self.result set to  (button, data).

    The 'ok' and 'cancel' buttons (which are always provided) behave as
    if no callback was supplied.

"""
#@+node:bob.20071208030419.2: *6* << Create the frame from the configuration data >>
root = g.app.root

<< Create the top level and the main frame >>
<< Create widgets for each section and option >>
<< Create the buttons >>

g.app.gui.center_dialog(top) # Do this after packing.
top.grab_set() # Make the dialog a modal dialog.
top.focus_force() # Get all keystrokes.

self.result = ('Cancel', '')

root.wait_window(top)
#@+node:bob.20071208030419.3: *7* << Create the top level and the main frame >>
self.top = top = Tk.Toplevel(root)
g.app.gui.attachLeoIcon(self.top)
#top.title("Properties of "+ plugin.name)
top.title(title)

top.resizable(0,0) # neither height or width is resizable.

self.frame = frame = Tk.Frame(top)
frame.pack(side="top")
#@+node:bob.20071208030419.4: *7* << Create widgets for each section and option >>
# Create all the entry boxes on the screen to allow the user to edit the properties

sections = data.keys()
sections.sort()

for section in sections:

    # Create a frame for the section.
    f = Tk.Frame(top, relief="groove",bd=2)
    f.pack(side="top",padx=5,pady=5)
    Tk.Label(f, text=section.capitalize()).pack(side="top")

    # Create an inner frame for the options.
    b = Tk.Frame(f)
    b.pack(side="top",padx=2,pady=2)

    options = data[section].keys()
    options.sort()

    row = 0
    # Create a Tk.Label and Tk.Entry for each option.
    for option in options:
        e = Tk.Entry(b)
        e.insert(0, data[section][option])
        Tk.Label(b, text=option).grid(row=row, column=0, sticky="e", pady=4)
        e.grid(row=row, column=1, sticky="ew", pady = 4)
        row += 1
        self.entries.append((section, option, e))
#@+node:bob.20071208030419.5: *7* << Create the buttons >>
box = Tk.Frame(top, borderwidth=5)
box.pack(side="bottom")

buttons.extend(("OK", "Cancel"))

for name in buttons:
    Tk.Button(box,
        text=name,
        width=6,
        command=lambda self=self, name=name: self.onButton(name)
    ).pack(side="left",padx=5)

#@+node:EKR.20040517080555.17: *5* Event Handlers

def onButton(self, name):
    """Event handler for all button clicks."""

    data = self.getData()
    self.result = (name, data)

    if name in ('OK', 'Cancel'):
        self.top.destroy()
        return

    if self.callback:
        retval = self.callback(name, data)
        if retval == 'close':
            self.top.destroy()
        else:
            self.result = ('Cancel', None)


#@+node:EKR.20040517080555.18: *5* getData
def getData(self):
    """Return the modified configuration."""

    data = {}
    for section, option, entry in self.entries:
        if section not in data:
            data[section] = {}
        s = entry.get()
        s = g.toEncodedString(s,"ascii",reportErrors=True) # Config params had better be ascii.
        data[section][option] = s

    return data


#@+node:EKR.20040517080555.19: *4* class TkScrolledMessageDialog
class TkScrolledMessageDialog:

    """A class to create and run a Scrolled Message dialog for Tk"""

    default_buttons = ["Text to HTML", "RST to HTML", "Close"]

    @others
#@+node:EKR.20040517080555.20: *5* __init__
def __init__(self, title='Message', label= '', msg='', callback=None, buttons=None):

    """Create and run a modal dialog showing 'msg' in a scrollable window."""

    if buttons is None:
        buttons = []

    self.callback = callback
    self.title = title
    self.label = label
    self.msg = msg

    self.buttons = buttons or []

    self.buttons.extend(self.default_buttons)

    self.result = ('Cancel', None)

    root = g.app.root
    self.top = top = Tk.Toplevel(root)
    g.app.gui.attachLeoIcon(self.top)

    top.title(title)
    top.resizable(1,1) # height and width is resizable.

    frame = Tk.Frame(top)
    frame.pack(side="top", expand=True, fill='both')

    << Create the contents of the about box >>

    self.create_the_buttons(top, self.buttons)

    g.app.gui.center_dialog(top) # Do this after packing.
    top.grab_set() # Make the dialog a modal dialog.
    top.focus_force() # Get all keystrokes.

    root.wait_window(top)
#@+node:EKR.20040517080555.21: *6* << Create the contents of the about box >>
#Tk.Label(frame,text="Version " + version).pack()

if label:
    Tk.Label(frame, text=label).pack()

body = w = g.app.gui.plainTextWidget(
    frame,name='body-pane',
    bd=2,bg="white",relief="flat",setgrid=0,wrap='word')
w.insert(0,msg)
if 0: # prevents arrow keys from being visible.
    w.configure(state='disabled')
w.setInsertPoint(0)
w.see(0)

bodyBar = Tk.Scrollbar(frame,name='bodyBar')
body['yscrollcommand'] = bodyBar.set
bodyBar['command'] = body.yview

bodyBar.pack(side="right", fill="y")
body.pack(expand=1,fill="both")

def destroyCallback(event=None,top=top):
    self.result = ('Cancel', None)
    top.destroy()

body.bind('<Return>',destroyCallback)

g.app.gui.set_focus(None,body)
#@+node:bobjack.20080320174907.4: *5* create_the_buttons
def create_the_buttons(self, parent, buttons):

    """
    Create the TK buttons and pack them in a button box.
    """

    box = Tk.Frame(parent, borderwidth=5)
    box.pack(side="bottom")

    for name in buttons:
        Tk.Button(box,
            text=name,
            command=lambda self=self, name=name: self.onButton(name)
        ).pack(side="left",padx=5)
#@+node:bobjack.20080320193548.2: *5* get_default_buttons
#@+node:bob.20071209110304.1: *5* Event Handlers

def onButton(self, name):
    """Event handler for all button clicks."""

    retval = ''

    if name in self.default_buttons:

        if name in ('Close'):
            self.top.destroy()
            return

        retval = self.show_message_as_html(name)

    elif self.callback:

        retval = self.callback(name) or ''

    if retval.lower() == 'close':
        self.top.destroy()
    else:
        self.result = ('Cancel', None)


#@+node:bobjack.20080317174956.3: *5* show_message_as_html
def show_message_as_html(self, name):

    try:
        import leo.plugins.leo_to_html as leo_to_html
    except ImportError:
        g.es('Can not import leo.plugins.leo_to_html as leo_to_html', color='red')
        return

    oHTML = leo_to_html.Leo_to_HTML(c=None) # no need for a commander

    oHTML.loadConfig()
    oHTML.silent = True 
    oHTML.myFileName = oHTML.title = self.title + ' ' + self.label

    if name.lower().startswith('text'):
        retval = self.show_text_message(oHTML)
    elif name.lower().startswith('rst'):
        retval = self.show_rst_message(oHTML)
    else:
        return

    return retval
#@+node:bobjack.20080320174907.2: *5* show_rst_message
def show_rst_message(self, oHTML):

    try:
        from docutils import core
    except ImportError:
        g.es('Can not import docutils', color='red')
        return

    overrides = {
        'doctitle_xform': False,
        'initial_header_level': 1
    }

    parts = core.publish_parts(
        source=self.msg,
        writer_name='html',
        settings_overrides=overrides
    )

    oHTML.xhtml = parts['whole']
    oHTML.show()

    return 'close'
#@+node:bobjack.20080320174907.3: *5* show_text_message
def show_text_message(self, oHTML):

    oHTML.xhtml = '<pre>' + self.msg + '</pre>'
    oHTML.applyTemplate()
    oHTML.show()

    return 'close'
#@+node:bob.20071208211442.1: *4* runPropertiesDialog
def runPropertiesDialog(title='Properties', data={}, callback=None, buttons=None):
    """Dispay a modal TkPropertiesDialog"""


    dialog = TkPropertiesDialog(title, data, callback, buttons)

    return dialog.result 
#@+node:bob.20071209110304: *4* runScrolledMessageDialog
def runScrolledMessageDialog(title='Message', label= '', msg='', callback=None, buttons=None, **kw):
    """Display a modal TkScrolledMessageDialog."""

    dialog = TkScrolledMessageDialog(title, label, msg, callback, buttons)

    return dialog.result
#@+node:ekr.20110526083709.18343: ** Supported auto-hide in viewrendered plugin
#@-all
#@-leo
