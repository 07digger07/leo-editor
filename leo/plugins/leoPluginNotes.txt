#@+leo-ver=5-thin
#@+node:ekr.20090430075506.3: * @file leoPluginNotes.txt
#@+all
#@+node:ekr.20120302043834.12029: ** Projects
#@+node:ekr.20120301114648.9929: *3* Define @command foo and foo as alt-x commands
#@+node:ekr.20060929135558: *4* cleanButtonText
def cleanButtonText (self,s,minimal=False):

    '''Clean the text following @button or @command so that it is a valid name of a minibuffer command.'''

    # 2011/10/16: Delete {tag}
    s = s.strip()
    i,j = s.find('{'),s.find('}')
    if -1 < i < j:
        s = s[:i] + s[j+1:]
        s = s.strip()
    if minimal:
        return s.lower()

    for tag in ('@key','@args',):
        i = s.find(tag)
        if i > -1:
            j = s.find('@',i+1)
            if i < j:
                s = s[:i] + s[j+1:]
            else:
                s = s[:i]
            s = s.strip()
    if 1: # Not great, but spaces, etc. interfere with tab completion.
        # 2011/10/16 *do* allow '@' sign.
        chars = g.toUnicode(string.ascii_letters + string.digits + '@')
        aList = [g.choose(ch in chars,ch,'-') for ch in g.toUnicode(s)]
        s = ''.join(aList)
        s = s.replace('--','-')
    while s.startswith('-'):
        s = s[1:]
    while s.endswith('-'):
        s = s[:-1]
    return s.lower()
#@+node:ekr.20060328125248.16: *4* getShortcut
def getShortcut(self,h):

    '''Returns the keyboard shortcut from the given headline string'''

    shortcut = None
    i = h.find('@key')

    if i > -1:
        j = g.skip_ws(h,i+len('@key'))
        if g.match(h,j,'='): j += 1
        shortcut = h[j:].strip()

    return shortcut
#@+node:ekr.20120301114648.9932: *4* registerTwoCommands
def registerTwoCommands(self,h,func,pane,tag):

    trace = False and not g.unitTesting
    k = self.c.k

    shortcut = self.getShortcut(h)
    s = self.cleanButtonText(h)

    if trace: g.trace(s)

    k.registerCommand(s,func=func,
        pane=pane,shortcut=shortcut,verbose=trace)
        
    for tag in ('@button-','@command-'):
        if s.startswith(tag):
            command = s[len(tag):].strip()
            # Create a *second* func, to avoid collision in c.commandsDict.
            if tag == '@button':
                def atButtonCallBack(event=None,func=func):
                    func()
                cb = atButtonCallBack
            else:
                def atCommandCallBack(event=None,func=func):
                    func()
                cb = atCommandCallBack
            if trace: g.trace('second',command)
            k.registerCommand(command,func=cb,
                pane=pane,shortcut=None,verbose=trace)
#@+node:ekr.20120301114648.9931: *4* Found: registerCommand
#@+node:ekr.20070926085149: *5* createAtButtonFromSettingHelper & callback
def createAtButtonFromSettingHelper (self,h,script,statusLine,bg='LightSteelBlue2'):

    '''Create a button from an @button node.

    - Calls createIconButton to do all standard button creation tasks.
    - Binds button presses to a callback that executes the script.
    '''
    
    c = self.c

    # We must define the callback *after* defining b,
    # so set both command and shortcut to None here.
    b = self.createIconButton(text=h,
        command=None,statusLine=statusLine,bg=bg)
    if not b: return None

    # Now that b is defined we can define the callback.
    # Yes, the callback *does* use b (to delete b if requested by the script).
    args = self.getArgs(h)
    buttonText = self.cleanButtonText(h)
    
    def atSettingButtonCallback (event=None,
        self=self,args=args,b=b,c=c,script=script,buttonText=buttonText
    ):
        self.executeScriptFromSettingButton (args,b,script,buttonText)
        if c.exists: c.outerUpdate()

    self.iconBar.setCommandForButton(b,atSettingButtonCallback)

    # At last we can define the command.
    self.registerTwoCommands(h,func=atSettingButtonCallback,
        pane='button',tag='@button')

    return b
#@+node:ekr.20070926085149.1: *6* executeScriptFromSettingButton (mod_scripting)
def executeScriptFromSettingButton (self,args,b,script,buttonText):

    '''Called from callbacks to execute the script in node p.'''

    c = self.c

    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
    else:
        g.app.scriptDict = {}
        c.executeScript(args=args,script=script,silent=True)
        # Remove the button if the script asks to be removed.
        if g.app.scriptDict.get('removeMe'):
            g.es("Removing '%s' button at its request" % buttonText)
            self.deleteButton(b)

    if 0: # Do *not* set focus here: the script may have changed the focus.
        c.frame.bodyWantsFocus()
#@+node:ekr.20080312071248.2: *5* createCommonCommands (mod_scripting)
def createCommonCommands (self):

    c = self.c ; k = c.k

    # trace = True and not g.app.unitTesting # and not g.app.batchMode
    aList = c.config.getCommands()
    if aList:
        for z in aList:
            h,script = z
            args = self.getArgs(h)
    
            def commonCommandCallback (event=None,script=script):
                c.executeScript(args=args,script=script,silent=True)
                
            self.registerTwoCommands(h,func=commonCommandCallback,
                pane='all',tag='global @command')
#@+node:ekr.20060328125248.10: *5* handleAtCommandNode @command (mod_scripting)
def handleAtCommandNode (self,p):

    '''Handle @command name [@key[=]shortcut].'''

    # trace = True and not g.app.unitTesting # and not g.app.batchMode

    c = self.c ; k = c.keyHandler ; h = p.h
    if not h.strip(): return

    args = self.getArgs(h)

    def atCommandCallback (event=None,args=args,c=c,p=p.copy()):
        c.executeScript(args=args,p=p,silent=True)
        
    self.registerTwoCommands(h,func=atCommandCallback,
        pane='all',tag='local @command')
#@+node:ekr.20060328125248.24: *5* createAtButtonHelper & callback
def createAtButtonHelper (self,p,h,statusLine,bg='LightSteelBlue1',verbose=True):

    '''Create a button from an @button node.

    - Calls createIconButton to do all standard button creation tasks.
    - Binds button presses to a callback that executes the script in node p.
    '''
    
    # trace = True and not g.unitTesting
    c = self.c ; k = c.k
    
    buttonText = self.cleanButtonText(h,minimal=True)

    # We must define the callback *after* defining b,
    # so set both command and shortcut to None here.
    b = self.createIconButton(text=h,command=None,statusLine=statusLine,bg=bg)
    if not b: return None

    # Now that b is defined we can define the callback.
    # Yes, executeScriptFromButton *does* use b (to delete b if requested by the script).
    # 20100518 - TNB replace callback function with callable class instance
    #   so qt gui can add 'Goto Script' command to context menu for button
    class atButtonCallback(object):
        def __init__(self,controller,p,b,c,buttonText):
            self.controller = controller
            self.p = p.copy()
            self.b = b
            self.c = c
            self.buttonText = buttonText

        def __call__(self, event=None):
            self.controller.executeScriptFromButton(self.p,self.b,self.buttonText)
            if self.c.exists: self.c.outerUpdate()
            
        # 2011/10/17: Add support for docstrings.
        def docstring(self):
            return g.getDocString(self.p.b)

    cb = atButtonCallback(controller=self,
        p=p.copy(),b=b,c=c,buttonText=buttonText)

    self.iconBar.setCommandForButton(b,cb)

    # At last we can define the command and use the shortcut.
    self.registerTwoCommands(h,func=cb,pane='button',tag='local @button')

    return b
#@+node:ekr.20060328125248.28: *6* executeScriptFromButton (mod_scripting)
def executeScriptFromButton (self,p,b,buttonText):

    '''Called from callbacks to execute the script in node p.'''

    c = self.c

    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
    else:
        g.app.scriptDict = {}
        h = p.h
        args = self.getArgs(h)
        c.executeScript(args=args,p=p,silent=True)
        # Remove the button if the script asks to be removed.
        if g.app.scriptDict.get('removeMe'):
            g.es("Removing '%s' button at its request" % buttonText)
            self.deleteButton(b)

    if 0: # Do *not* set focus here: the script may have changed the focus.
        c.frame.bodyWantsFocus()
#@+node:ekr.20060328125248.17: *5* createIconButton
def createIconButton (self,text,command,statusLine,bg):

    '''Create an icon button.  All icon buttons get created using this utility.

    - Creates the actual button and its balloon.
    - Adds the button to buttonsDict.
    - Registers command with the shortcut.
    - Creates x amd delete-x-button commands, where x is the cleaned button name.
    - Binds a right-click in the button to a callback that deletes the button.'''

    c = self.c ; k = c.k

    # Create the button and add it to the buttons dict.
    commandName = self.cleanButtonText(text)

    # Truncate only the text of the button, not the command name.
    truncatedText = self.truncateButtonText(commandName)
    if not truncatedText.strip():
        g.es_print('%s ignored: no cleaned text' % (text.strip() or ''),color='red')
        return None

    # Command may be None.
    b = self.iconBar.add(text=truncatedText,command=command,bg=bg)
    if not b: return None

    self.buttonsDict[b] = truncatedText

    if statusLine:
        self.createBalloon(b,statusLine)

    # Register the command name if it exists.
    if command:
        self.registerTwoCommands(text,func=command,
            pane='button',tag='icon button')

    # Define the callback used to delete the button.
    def deleteButtonCallback(event=None,self=self,b=b):
        self.deleteButton(b, event=event)

    # Register the delete-x-button command.
    deleteCommandName= 'delete-%s-button' % commandName
    k.registerCommand(deleteCommandName,shortcut=None,
        func=deleteButtonCallback,pane='button',verbose=False)
        # Reporting this command is way too annoying.

    return b
#@+node:ekr.20120302043834.9936: *3* Found: .openWith
#@+node:ville.20090701110830.10215: *4* editnode_rclick
def editnode_rclick(c,p, menu):
    """ Provide "edit in EDITOR" context menu item """

    editor = g.guessExternalEditor()
    if not editor:
        return
    action = menu.addAction("Edit in " + editor)

    def editnode_rclick_cb():
        # c.openWith(data = ('subprocess.Popen', [editor], None))
        d = {'kind':'subprocess.Popen','args':[editor],'ext':None}
        c.openWith(d=d)

    action.connect(action, QtCore.SIGNAL("triggered()"), editnode_rclick_cb)
#@+node:ville.20090701224704.9805: *4* << Add commands >>
# cm is 'contextmenu' prefix
@g.command('cm-external-editor')
def cm_external_editor_f(event):    
    """ Open node in external editor 

    Set LEO_EDITOR/EDITOR environment variable to get the editor you want.
    """
    c = event['c']
    pos = c.currentPosition()
    editor = g.guessExternalEditor()

    # c.openWith(data = ('subprocess.Popen', editor, None))
    d = {'kind':'subprocess.Popen','args':[editor],'ext':None}
    c.openWith(d=d)








#@+node:ekr.20040331071919.32: *4* << Open_Tree Plugin >>
@language python
@tabwidth-4
@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:14 CST 2004  michael@redpriest _OpenTree_Plugin__140660268.py"

This is a module that creates an "Open With" menu item that opens
Leo outline nodes in the tree below the current Leo node in the
XEmacs editor.I frequently have a small tree of Leo nodes which
contain code that is usually edited in the same session.

NOTE: I use the "gnuclient-noshow" selection to load the temporary
open_with file in the background.Leo calls a command with the
temporary file name at the end of the command, but the gnuclient
command needs to receive it enclosed in quotes and parentheses.The
solution is a small intermediary bash shell script called
"gnuclient-noshow":

- - -
#!/bin/bash
gnuclient- eval "(find-file-noselect \"${1}\")"
- - -

I would rather have this operate in the background, but Leo ' s
openWith always operates on the current node, and openWith has much
good error checking that I want to use.So the fast solution was to
have OpenTreeInXEmacs visibly traverse the tree.

@ascskip on
@root "other/xemacs/mod_xemacsopentree.py"
<< Open_Tree Plugin >>
@code

def OpenTreeInXEmacs (c):
    import leo.core.leoCommands as leoCommands
    #XEmacsCommand = "/usr/bin/gnuclient -q "
    XEmacsCommand = "/mrc2/linux-bin/gnuclient-noshow "
    vnode = c.currentVnode() # get the current vnode.
    stopHere = vnode.nodeAfterTree()
    v = vnode
    while v != stopHere:
        # c.openWith(data=("os.system",XEmacsCommand,None))
        d = {'kind':'subprocess.Popen','args':[XEmacsCommand],'ext':None}
        c.openWith(d=d)
        v = v.threadNext()
        if (not v) or (v==stopHere):
            break
        c.selectVnode(v)
    c.selectVnode(vnode)


def CreateOpenTreeMenu (tag,keywords):

    """Create the 'Xemacs: Open Tree' menu item in the Open With menu."""


    if (tag=="menu2" or
        (tag=="start2") or
        (tag=="command2" and keywords.get("label")=="new")):

        c = keyword.get('c')
        exportMenu = c.frame.menu.getMenu('Open With')
        newEntries = (
            ("-",None,None),
            ("XEmacs: Open nodes in sub-tree","None",OpenTreeInXEmacs),
        )
        c.frame.menu.createMenuEntries(exportMenu,newEntries,dynamicMenu=True)

if 1:
    g.registerHandler(("start2","menu2","command2"),CreateOpenTreeMenu)

    __version__ = ".4" # Set version for the plugin handler.
    g.plugin_signon(__name__)
@doc


@code
#@+node:EKR.20040517075715.11: *4* open_in_vim
contextmenu_message_given = False

def open_in_vim (tag,keywords):

    if g.unitTesting: return

    c = keywords.get('c')
    p2 = keywords.get('old_p')
    if not c: return
    
    # Load contextmenu plugin if required.
    contextMenu = g.loadOnePlugin('contextmenu.py',verbose=True)
    if not contextMenu:
        if not contextmenu_message_given:
            contextmenu_message_given = True
            g.trace('can not load contextmenu.py')
        return
    
    p = c.p

    if tag.startswith('select') and p == p2:
        return

    if p.h.find('file-ref') == 1: # Must be at 2nd position
        return

    #URL nodes
    openURLNodes = c.config.getBool('vim_plugin_opens_url_nodes')
    if not openURLNodes and p.h.startswith('@url'):
        return # Avoid conflicts with @url nodes.
    v = p.v

    vim_cmd = c.config.getString('vim_cmd') or _vim_cmd
    vim_exe = c.config.getString('vim_exe') or _vim_exe

    global locationMessageGiven

    if not locationMessageGiven:
        locationMessageGiven = True
        print('vim_cmd: %s' % vim_cmd)
        print('vim_exe: %s' % vim_exe)

    #Cursor positioning
    Lnum = ""
    if c.config.getBool('vim_plugin_positions_cursor'):    
        #Line number - start at same line as Leo cursor
        #  get node's body text
        bodyCtrl = c.frame.body.bodyCtrl
        s = bodyCtrl.getAllText()    
        #  Get cursors row & column number
        index = bodyCtrl.getInsertPoint()
        row,col = g.convertPythonIndexToRowCol(s,index)
        #  Build gVim command line parameter for setting cursor row
        Lnum = "+" + str(row + 1)

    #Vim's tab card stack
    useTabs = ""

    if c.config.getBool('vim_plugin_uses_tab_feature'):    
        useTabs = "-tab"

    # Search g.app.openWithFiles for a file corresponding to v.
    for d in g.app.openWithFiles:
        if d.get('v') == id(v):
            path = d.get('path','') ; break
    else: path = ''

    # if the body has changed we need to open a new 
    # temp file containing the new body in vim
    if (
        not g.os_path_exists(path) or 
        not hasattr(v,'OpenWithOldBody') or
        v.b != v.OpenWithOldBody
    ):
        # Open a new temp file.
        if path:
            # Remove the old file and the entry in g.app.openWithFiles.
            os.remove(path)
            g.app.openWithFiles = [d for d in g.app.openWithFiles if d.get('path') != path]
            os.system(vim_cmd+"--remote-send '<C-\\><C-N>:bd "+path+"<CR>'")

        v.OpenWithOldBody=v.b # Remember the previous contents.
    
        # New code by Jim Sizemore. TL: added support for gVim tabs.
        args = [vim_exe,"--servername","LEO","--remote"+useTabs+"-silent",Lnum]
        d = {'kind':'subprocess.Popen','args':args,'ext':None}
        c.openWith(d=d)
    else:
        # Reopen the old temp file.
        os.system(vim_cmd+"--remote-send '<C-\\><C-N>:e "+path+"<CR>'")

    # return val
#@+node:ekr.20050313071202: *4* open_in_emacs
contextmenu_message_given = False

def open_in_emacs (tag,keywords):

    c = keywords.get('c')
    p = keywords.get('p')
    if not c or not p: return
    
    # Load contextmenu plugin if required.
    contextMenu = g.loadOnePlugin('contextmenu.py',verbose=True)
    if not contextMenu:
        if not contextmenu_message_given:
            contextmenu_message_given = True
            g.trace('can not load contextmenu.py')
        return

    v = p.v

    # Search g.app.openWithFiles for a file corresponding to v.
    for d in g.app.openWithFiles:
        if d.get('v') == id(v):
            path = d.get('path','') ; break
    else: path = ''

    # g.trace('config',c.config.getString('xemacs_exe'))
    emacs_cmd = c.config.getString('xemacs_exe') or _emacs_cmd # 2010/01/18: found by pylint.

    if (
        not g.os_path_exists(path) or
        not hasattr(v,'OpenWithOldBody') or
        v.b != v.OpenWithOldBody
    ):
        # Open a new temp file.
        if path:
            # Remove the old file and the entry in g.app.openWithFiles.
            os.remove(path)
            g.app.openWithFiles = [d for d in g.app.openWithFiles
                if d.get('path') != path]
            os.system(emacs_cmd)
        v.OpenWithOldBody=v.b # Remember the old contents

        # open the node in emacs (note the space after _emacs_cmd)
        # data = "os.spawnl", emacs_cmd, None
        d = {'kind':'os.spawnl','args':[emacs_cmd],'ext':None}
        c.openWith(d=d)
    else:
        # Reopen the old temp file.
        os.system(emacs_cmd)

def open_in_emacs_return_true(tag,keywords):
    open_in_emacs(tag,keywords)
    return True
#@-all
#@-leo
