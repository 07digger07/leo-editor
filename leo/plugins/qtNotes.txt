#@+leo-ver=4-thin
#@+node:ekr.20081121105001.147:@thin qtNotes.txt
#@+all
#@+node:ekr.20081121105001.148: qt To do
#@+node:ekr.20090429101847.10:Support canvas widgets in all panes
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/9ac06147e75fc042

add-canvas: Like add-editor, but it creates a canvas area, not a text area.
#@nonl
#@-node:ekr.20090429101847.10:Support canvas widgets in all panes
#@+node:ekr.20081215074704.21:Add drag and drop
#@-node:ekr.20081215074704.21:Add drag and drop
#@+node:ekr.20090418064921.12:Qt, vim bindings
http://groups.google.com/group/leo-editor/browse_thread/thread/7285ac185355efb1
#@nonl
#@-node:ekr.20090418064921.12:Qt, vim bindings
#@+node:ekr.20081215162017.4:Allow coloring of script buttons
@nocolor-node

Use @string qt-button-color = lightSteelBlue

The following does *not* work in @data qt-gui-plugin-style-sheet::

    QPushButton {
        background-color: red;
    }
#@+node:ekr.20090406111739.12:setWidgetColor (qtGui)
badWidgetColors = []

def setWidgetColor (self,w,widgetKind,selector,colorName):

    if not colorName: return

    # g.trace(widgetKind,selector,colorName,g.callers(4))

    # A bit of a hack: Qt color names do not end with a digit.
    # Remove them to avoid annoying qt color warnings.
    if colorName[-1].isdigit():
        colorName = colorName[:-1]

    if colorName in self.badWidgetColors:
        pass
    elif QtGui.QColor(colorName).isValid():
        g.app.gui.setStyleSetting(w,widgetKind,selector,colorName)
    else:
        self.badWidgetColors.append(colorName)
        g.es_print('bad widget color %s for %s' % (
            colorName,widgetKind),color='blue')
#@-node:ekr.20090406111739.12:setWidgetColor (qtGui)
#@+node:ekr.20090406111739.13:setStyleSetting (qtGui)
def setStyleSetting(self,w,widgetKind,selector,val):

    '''Set the styleSheet for w to
       "%s { %s: %s; }  % (widgetKind,selector,val)"
    '''

    s = '%s { %s: %s; }' % (widgetKind,selector,val)

    try:
        w.setStyleSheet(s)
    except Exception:
        g.es_print('bad style sheet: %s' % s)
        g.es_exception()
#@-node:ekr.20090406111739.13:setStyleSetting (qtGui)
#@+node:ekr.20081121105001.266:class qtIconBarClass
class qtIconBarClass:

    '''A class representing the singleton Icon bar'''

    @others
#@+node:ekr.20081121105001.267: ctor
def __init__ (self,c,parentFrame):

    self.c = c
    self.parentFrame = parentFrame
    self.toolbar = self
    self.w = c.frame.top.iconBar # A QToolBar.
    self.actions = []

    # Options
    self.buttonColor = c.config.getString('qt-button-color')

    # g.app.iconWidgetCount = 0
#@-node:ekr.20081121105001.267: ctor
#@+node:ekr.20081121105001.268: do-nothings
def addRow(self,height=None):   pass
def getFrame (self):            return None
def getNewFrame (self):         return None
def pack (self):                pass
def unpack (self):              pass

hide = unpack
show = pack
#@-node:ekr.20081121105001.268: do-nothings
#@+node:ekr.20081121105001.269:add
def add(self,*args,**keys):

    '''Add a button to the icon bar.'''

    c = self.c
    command = keys.get('command')
    text = keys.get('text')
    # able to specify low-level QAction directly (QPushButton not forced)
    qaction = keys.get('qaction')

    if not text and not qaction:
        g.es('bad toolbar item')

    bg = keys.get('bg') or self.toolbar.buttonColor

    # imagefile = keys.get('imagefile')
    # image = keys.get('image')

    class leoIconBarButton (QtGui.QWidgetAction):
        def __init__ (self,parent,text,toolbar):
            QtGui.QWidgetAction.__init__(self,parent)
            self.button = None # set below
            self.text = text
            self.toolbar = toolbar
        def createWidget (self,parent):
            # g.trace('leoIconBarButton',self.toolbar.buttonColor)
            self.button = b = QtGui.QPushButton(self.text,parent)
            g.app.gui.setWidgetColor(b,
                widgetKind='QPushButton',
                selector='background-color',
                colorName = bg)
            return b

    if qaction is None:
        action = leoIconBarButton(parent=self.w,text=text,toolbar=self)
    else:
        action = qaction

    self.w.addAction(action)

    self.actions.append(action)
    b = self.w.widgetForAction(action)

    b.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)

    def delete_callback(action=action,):
        self.w.removeAction(action)

    b.leo_removeAction = rb = QtGui.QAction('Remove Button' ,b)

    b.addAction(rb)
    rb.connect(rb, QtCore.SIGNAL("triggered()"), delete_callback)

    if command:
        def button_callback(c=c,command=command):
            # g.trace('command',command.__name__)
            val = command()
            if c.exists:
                # c.bodyWantsFocus()
                c.outerUpdate()
            return val

        self.w.connect(b,
            QtCore.SIGNAL("clicked()"),
            button_callback)

    return action
#@-node:ekr.20081121105001.269:add
#@+node:ekr.20081121105001.270:addRowIfNeeded
def addRowIfNeeded (self):

    '''Add a new icon row if there are too many widgets.'''

    # n = g.app.iconWidgetCount

    # if n >= self.widgets_per_row:
        # g.app.iconWidgetCount = 0
        # self.addRow()

    # g.app.iconWidgetCount += 1
#@-node:ekr.20081121105001.270:addRowIfNeeded
#@+node:ekr.20081121105001.271:addWidget
def addWidget (self,w):

    self.w.addWidget(w)
#@-node:ekr.20081121105001.271:addWidget
#@+node:ekr.20081121105001.272:clear
def clear(self):

    """Destroy all the widgets in the icon bar"""

    self.w.clear()
    self.actions = []

    g.app.iconWidgetCount = 0
#@-node:ekr.20081121105001.272:clear
#@+node:ekr.20081121105001.273:deleteButton
def deleteButton (self,w):
    """ w is button """

    #g.trace(w, '##')    

    self.w.removeAction(w)

    self.c.bodyWantsFocus()
    self.c.outerUpdate()
#@-node:ekr.20081121105001.273:deleteButton
#@+node:ekr.20081121105001.274:setCommandForButton
def setCommandForButton(self,button,command):

    if command:
        # button is a leoIconBarButton.
        QtCore.QObject.connect(button.button,
            QtCore.SIGNAL("clicked()"),command)
#@-node:ekr.20081121105001.274:setCommandForButton
#@-node:ekr.20081121105001.266:class qtIconBarClass
#@-node:ekr.20081215162017.4:Allow coloring of script buttons
#@+node:ekr.20081124094918.1:Fix problems with scim
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/59c1e5d6acaf4de0

I've some more information about the problems with accent previously
reported:
- I can confirm that they are caused by the interaction scim+leo (with
and without the qt plugin). If scim is not started leo works fine. If
scim is running the problems appear and are slightly different with
and without the qt plugin. The workaround is obvious: don't use leo
and scim at the same time :-)
- accents are not working in the qt plugin when scintilla is used. If
qt-use-scintilla=False I can write this:

àáä (the same for the rest of vowels)

but if qt-use-scintilla=True when I enter the same sequence in the
keyboard I get:

`aaa (the same for the rest of vowels)

- the problem with the ñ character (reported previously too) is only
present in the qt plugin (both with and without scintilla)
#@-node:ekr.20081124094918.1:Fix problems with scim
#@+node:ekr.20090406111739.10:Let gui handle hard part of next/prev-line commands
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/ef04b185f74f4926

This is a little difficult to describe in words, but trying it out
should, I hope make the issue clear enough.

(1) Start by setting body_pane_wraps to true.

(2) Create a very long line of e.g. 500 characters, which is wrapped
around on the body pane. (E.g. paste in a paragraph from a Word
document). This text will then be wrapped onscreen into roughly 8
lines of 70 characters.

(3) The up and down arrows do not behave as expected.

I'd expect that in this scenario, pressing the down arrow key should
go to go to the next line down as it currently appears *onscreen* --
so in this example, I'd expect to have to press the down arrow several
times to get to the end of the paragraph.  This is the way that Emacs
works when it is in word wrap mode, and is of course is the way that
all word processors work. However, Leo does not play this way, and
takes you right to the end of the line (i.e. to the last of the 500
characters) when you press the down key once. This makes editing plain
text (e.g. using Leo as an outliner) rather more tricky than it ought
to be. Would it be possible to change the effect of Previous-Line and
Next-Line when in word wrap mode, so that they behave as other text
editors and word processors do?

============================

This is a long-standing problem.  It's tricky to fix in a straightforward
way.

However, I just realized that there might be a clever way: the commands
could let the gui handle the hard part of the command (the actual move) and
then the commands could detect the resulting row/col numbers as they must.

I've been putting this off, I'll see if this more clever way will work soon. 
#@nonl
#@-node:ekr.20090406111739.10:Let gui handle hard part of next/prev-line commands
#@-node:ekr.20081121105001.148: qt To do
#@+node:ekr.20090717095154.3729:Leo 4.7 devel projects
#@+node:ekr.20090813101852.3644:Features
#@+node:ekr.20090718070434.3640:Removed signon code from guis
@nocolor-node

This is now done in app.computeSignon and app.writeWaitingLog.
#@nonl
#@-node:ekr.20090718070434.3640:Removed signon code from guis
#@+node:ekr.20090812211903.3642:Added support for iconclick hooks
#@+node:ekr.20090812211903.3641:onItemClicked (nativeTree) (New in Leo 4.7)
def onItemClicked (self,item,col):

    trace = False and not g.unitTesting
    verbose = False

    if self.busy(): return

    c = self.c

    if trace: g.trace(col,self.traceItem(item),g.callers(4))

    try:
        self.selecting = True

        p = self.item2position(item)
        if p:
            event = None
            g.doHook("iconclick1",c=c,p=p,v=p,event=event)
#@verbatim
            #@ c.frame.tree.OnIconDoubleClick(p) # Call the base class method.
            g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        else:
            g.trace('*** no p')

        c.outerUpdate()
    finally:
        self.selecting = False
#@-node:ekr.20090812211903.3641:onItemClicked (nativeTree) (New in Leo 4.7)
#@+node:ekr.20090124174652.120:qtTree.initAfterLoad
def initAfterLoad (self):

    '''Do late-state inits.'''

    # Called by Leo's core.

    c = self.c ; frame = c.frame
    w = c.frame.top ; tw = self.treeWidget

    if not leoQtTree.callbacksInjected:
        leoQtTree.callbacksInjected = True
        self.injectCallbacks() # A base class method.

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemDoubleClicked(QTreeWidgetItem*, int)"),
        self.onItemDoubleClicked)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemClicked(QTreeWidgetItem*, int)"),
        self.onItemClicked)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemSelectionChanged()"),
        self.onTreeSelect)

    # We don't need this.  Hooray!
    # w.connect(self.treeWidget,QtCore.SIGNAL(
            # "itemChanged(QTreeWidgetItem*, int)"),
        # self.onItemChanged)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemCollapsed(QTreeWidgetItem*)"),
        self.onItemCollapsed)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemExpanded(QTreeWidgetItem*)"),
        self.onItemExpanded)

    w.connect(self.treeWidget, QtCore.SIGNAL(
            "customContextMenuRequested(QPoint)"),
        self.onContextMenu)    

    self.ev_filter = leoQtEventFilter(c,w=self,tag='tree')
    tw.installEventFilter(self.ev_filter)

    c.setChanged(False)
#@-node:ekr.20090124174652.120:qtTree.initAfterLoad
#@-node:ekr.20090812211903.3642:Added support for iconclick hooks
#@+node:ekr.20091006164957.3701:Select all text if headline is newHeadline
#@+node:ekr.20090129062500.13:editLabelHelper (leoQtTree)
def editLabelHelper (self,item,selectAll=False,selection=None):

    '''Called by nativeTree.editLabel to do
    gui-specific stuff.'''

    w = self.treeWidget
    w.setCurrentItem(item) # Must do this first.
    w.editItem(item)
        # Generates focus-in event that tree doesn't report.
    e = w.itemWidget(item,0) # A QLineEdit.

    if e:
        s = e.text() ; len_s = len(s)
        if s == 'newHeadline': selectAll=True
        if selection:
            i,j,ins = selection
            start,n = i,abs(i-j)
                # Not right for backward searches.
        elif selectAll: start,n,ins = 0,len_s,len_s
        else:           start,n,ins = len_s,0,len_s
        e.setObjectName('headline')
        e.setSelection(start,n)
        # e.setCursorPosition(ins) # Does not work.
        e.setFocus()
        self.connectEditorWidget(e,item) # Hook up the widget.

    return e
#@-node:ekr.20090129062500.13:editLabelHelper (leoQtTree)
#@-node:ekr.20091006164957.3701:Select all text if headline is newHeadline
#@+node:ekr.20100107060708.3717:Added option to disable multiple tree selections
#@+node:ekr.20090426083450.15:createTreeWidget (DynamicWindow)
def createTreeWidget (self,parent,name):

    c = self.c
    w = QtGui.QTreeWidget(parent)
    self.setSizePolicy(w)

    # 12/01/07: add new config setting.
    multiple_selection = c.config.getBool('qt-tree-multiple-selection',default=True)
    if multiple_selection:
        w.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)
        w.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows)
    else:
        w.setSelectionMode(QtGui.QAbstractItemView.SingleSelection)
        w.setSelectionBehavior(QtGui.QAbstractItemView.SelectItems)
    w.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    w.setHeaderHidden(False)
    self.setName(w,name)
    return w
#@-node:ekr.20090426083450.15:createTreeWidget (DynamicWindow)
#@-node:ekr.20100107060708.3717:Added option to disable multiple tree selections
#@-node:ekr.20090813101852.3644:Features
#@+node:ekr.20090813101852.3643:Bugs
#@+node:ekr.20090718070434.3641:Fixed file-open focus problem
#@+node:ekr.20081121105001.317:Qt bindings... (qtFrame)
def bringToFront (self):
    self.lift()
def deiconify (self):
    if self.top.isMinimized(): # Bug fix: 400739.
        self.lift()
def getFocus(self):
    return g.app.gui.get_focus(self.c) # Bug fix: 2009/6/30.
def get_window_info(self):
    rect = self.top.geometry()
    topLeft = rect.topLeft()
    x,y = topLeft.x(),topLeft.y()
    w,h = rect.width(),rect.height()
    # g.trace(w,h,x,y)
    return w,h,x,y
def iconify(self):
    self.top.showMinimized()
def lift (self):
    # g.trace(self.c,'\n',g.callers(9))
    if self.top.isMinimized(): # Bug 379141
        self.top.showNormal()
    self.top.activateWindow()
    self.top.raise_()
def update (self):
    pass
def getTitle (self):
    s = g.u(self.top.windowTitle())
    # g.trace('qtFrame',repr(s))
    return s
def setTitle (self,s):
    # g.trace('qtFrame',repr(s))
    # self.top.c.frame.title = s
    self.top.setWindowTitle(s)
def setTopGeometry(self,w,h,x,y,adjustSize=True):
    # g.trace(x,y,w,y,g.callers(5))
    self.top.setGeometry(QtCore.QRect(x,y,w,h))
#@-node:ekr.20081121105001.317:Qt bindings... (qtFrame)
#@-node:ekr.20090718070434.3641:Fixed file-open focus problem
#@+node:ekr.20090813101852.3642:Eliminate double close prompt
#@+node:ekr.20081121105001.202:closeEvent (DynanicWindow)
def closeEvent (self,event):

    trace = False and not g.unitTesting
    c = self.c

    if not c.exists:
        # Fixes double-prompt bug on Linux.
        if trace: g.trace('destroyed')
        event.accept()
        return

    if c.inCommand:
        if trace: g.trace('in command')
        c.requestCloseWindow = True
    else:
        if trace: g.trace('closing')
        ok = g.app.closeLeoWindow(c.frame)
        if ok:
            event.accept()
        else:
            event.ignore()
#@-node:ekr.20081121105001.202:closeEvent (DynanicWindow)
#@-node:ekr.20090813101852.3642:Eliminate double close prompt
#@+node:ekr.20090818115409.3645:Fixed scrolling problem with multiple editors
#@-node:ekr.20090818115409.3645:Fixed scrolling problem with multiple editors
#@+node:ekr.20091006123049.3699:Fixed crash in quicksearch plugin
#@+node:ekr.20081121105001.330:createTab
def createTab (self,tabName,widget=None,wrap='none'):
    """ Create a new tab in tab widget

    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """

    trace = False and not g.unitTesting
    if trace: g.trace(tabName,g.callers(4))

    c = self.c ; w = self.tabWidget

    # Important. Not called during startup.

    if widget is None:
        # widget = QtGui.QTextBrowser()
        widget = QTextBrowserSubclass(parent=None,c=c,wrapper=self)
        contents = leoQTextEditWidget(widget=widget,name='log',c=c)
        widget.leo_log_wrapper = contents # Inject an ivar.
        if trace: g.trace('** creating',tabName,contents,widget,'\n',g.callers(9))
        widget.setWordWrapMode(QtGui.QTextOption.NoWrap)
        widget.setReadOnly(False) # Allow edits.
        self.logDict[tabName] = widget
        if tabName == 'Log':
            self.logCtrl = contents
            widget.setObjectName('log-widget')
            theFilter = leoQtEventFilter(c,w=self,tag='log')
            self.eventFilters.append(theFilter) # Needed!
            widget.installEventFilter(theFilter)
        self.contentsDict[tabName] = widget
        w.addTab(widget,tabName)
    else:
        contents = widget
        # Bug fix: 2009/10/06
        widget.leo_log_wrapper = contents # Inject an ivar.
        # if trace: g.trace('** using',tabName,contents)
        self.contentsDict[tabName] = contents
        w.addTab(contents,tabName)

    return contents
#@-node:ekr.20081121105001.330:createTab
#@-node:ekr.20091006123049.3699:Fixed crash in quicksearch plugin
#@+node:ekr.20091006142109.3700:Fixed @nosent dirty bug
# Note: changing a headline as *no effect* on an @nosent file!
# The only bug was that redraw_after_head_changed must update icons.
#@nonl
#@+node:ekr.20090124174652.59:onHeadChanged (nativeTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None,e=None):

    '''Officially change a headline.'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; u = c.undoer
    if not p:
        if trace: g.trace('** no p')
        return

    item = self.getCurrentItem()
    if not item:
        if trace and verbose: g.trace('** no item')
        return
    if not e:
        e = self.getTreeEditorForItem(item)
    if not e:
        if trace and verbose: g.trace('** not editing')
        return

    s = g.u(e.text())

    if g.doHook("headkey1",c=c,p=c.p,v=c.p,s=s):
        return

    self.closeEditorHelper(e,item)
    oldHead = p.h
    changed = s != oldHead
    if changed:
        if trace: g.trace('new',repr(s),'old',p.h,g.callers())
        p.initHeadString(s)
        item.setText(0,s) # Required to avoid full redraw.
        undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)

    g.doHook("headkey2",c=c,p=c.p,v=c.p,s=s)

    # This is a crucial shortcut.
    if g.unitTesting: return

    if changed:
        self.redraw_after_head_changed()

    if 0: # Don't do this: it interferes with clicks, and is not needed.
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()

    c.outerUpdate()
#@-node:ekr.20090124174652.59:onHeadChanged (nativeTree)
#@+node:ekr.20090124174652.15:Drawing... (nativeTree)
#@+node:ekr.20090124174652.17:full_redraw & helpers
# forceDraw not used. It is used in the Tk code.

def full_redraw (self,p=None,scroll=True,forceDraw=False):

    '''Redraw all visible nodes of the tree.

    Preserve the vertical scrolling unless scroll is True.'''

    trace = False and not g.app.unitTesting
    verbose = False
    c = self.c

    if self.busy():
        return g.trace('*** full_redraw: busy!',g.callers(5))

    if p is None:   p = c.currentPosition()
    else:           c.setCurrentPosition(p)

    # if trace: g.trace(p.isExpanded(),p.h)

    self.redrawCount += 1
    if trace: t1 = g.getTime()
    self.initData()
    self.nodeDrawCount = 0
    try:
        self.redrawing = True
        self.drawTopTree(p)
    finally:
        self.redrawing = False

    self.setItemForCurrentPosition(scroll=scroll)
    c.requestRedrawFlag= False

    if trace:
        theTime = g.timeSince(t1)
        callers = g.choose(verbose,g.callers(5),'')
        g.trace('*** %s: scroll %5s drew %3s nodes in %s' % (
            self.redrawCount,scroll,self.nodeDrawCount,theTime),callers)

# Compatibility
redraw = full_redraw 
redraw_now = full_redraw
#@+node:ekr.20090124174652.19:drawChildren
def drawChildren (self,p,parent_item):

    trace = False and not g.unitTesting

    if trace: g.trace('children? %5s expanded? %5s %s' % (
        p.hasChildren(),p.isExpanded(),p.h))

    if not p:
        return g.trace('can not happen: no p')

    if p.hasChildren():
        if p.isExpanded():
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child,parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child,parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
#@-node:ekr.20090124174652.19:drawChildren
#@+node:ekr.20090124174652.20:drawNode
def drawNode (self,p,parent_item):

    trace = False
    c = self.c 
    self.nodeDrawCount += 1

    # Allocate the item.
    item = self.createTreeItem(p,parent_item) 

    # Do this now, so self.isValidItem will be true in setItemIcon.
    self.rememberItem(p,item)

    # Set the headline and maybe the icon.
    self.setItemText(item,p.h)
    if p:
        self.drawItemIcon(p,item)

    if trace: g.trace(self.traceItem(item))

    return item
#@-node:ekr.20090124174652.20:drawNode
#@+node:ekr.20090129062500.12:drawTopTree
def drawTopTree (self,p):

    c = self.c
    hPos,vPos = self.getScroll()
    self.clear()
    # Draw all top-level nodes and their visible descendants.
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p ; h = p.h
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            while p:
                self.drawTree(p)
                p.moveToNext()
        else:
            self.drawTree(p)
    else:
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()

    # This method always retains previous scroll position.
    self.setHScroll(hPos)
    self.setVScroll(vPos)

    self.repaint()
#@nonl
#@-node:ekr.20090129062500.12:drawTopTree
#@+node:ekr.20090124174652.21:drawTree
def drawTree (self,p,parent_item=None):

    # Draw the (visible) parent node.
    item = self.drawNode(p,parent_item)

    # Draw all the visible children.
    self.drawChildren(p,parent_item=item)
#@-node:ekr.20090124174652.21:drawTree
#@+node:ekr.20090124174652.22:initData
def initData (self):

    # g.trace('*****')

    self.item2positionDict = {}
    self.item2vnodeDict = {}
    self.position2itemDict = {}
    self.vnode2itemsDict = {}
    self.editWidgetsDict = {}
#@-node:ekr.20090124174652.22:initData
#@+node:ekr.20090124174652.23:rememberItem
def rememberItem (self,p,item):

    trace = False and not g.unitTesting
    if trace: g.trace(id(item),p.h)

    v = p.v

    # Update position dicts.
    itemHash = self.itemHash(item)
    self.position2itemDict[p.key()] = item
    self.item2positionDict[itemHash] = p.copy() # was item

    # Update item2vnodeDict.
    self.item2vnodeDict[itemHash] = v # was item

    # Update vnode2itemsDict.
    d = self.vnode2itemsDict
    aList = d.get(v,[])
    if item in aList:
        g.trace('*** ERROR *** item already in list: %s, %s' % (item,aList))
    else:
        aList.append(item)
    d[v] = aList
#@-node:ekr.20090124174652.23:rememberItem
#@-node:ekr.20090124174652.17:full_redraw & helpers
#@+node:ekr.20090124174652.24:redraw_after_contract
def redraw_after_contract (self,p=None):

    trace = False and not g.unitTesting

    if self.redrawing:
        return

    item = self.position2item(p)

    if item:
        if trace: g.trace('contracting item',item,p and p.h or '<no p>')
        self.contractItem(item)
    else:
        # This is not an error.
        # We may have contracted a node that was not, in fact, visible.
        if trace: g.trace('***full redraw',p and p.h or '<no p>')
        self.full_redraw(scroll=False)
#@-node:ekr.20090124174652.24:redraw_after_contract
#@+node:ekr.20090124174652.25:redraw_after_expand
def redraw_after_expand (self,p=None):

    # Important, setting scrolling to False makes the problem *worse*
    self.full_redraw (p,scroll=True)
#@-node:ekr.20090124174652.25:redraw_after_expand
#@+node:ekr.20090124174652.26:redraw_after_head_changed
def redraw_after_head_changed (self):

    trace = False and not g.unitTesting

    if self.busy(): return

    c = self.c ; p = c.currentPosition()
    ew = self.edit_widget(p)

    if trace: g.trace(p.h)

    currentItem = self.getCurrentItem()

    if p:
        for item in self.vnode2items(p.v):
            if self.isValidItem(item):
                self.setItemText(item,p.h)

    # Bug fix: 2009/10/06
    self.redraw_after_icons_changed()
#@-node:ekr.20090124174652.26:redraw_after_head_changed
#@+node:ekr.20090124174652.27:redraw_after_icons_changed
def redraw_after_icons_changed (self):

    trace = False and not g.unitTesting

    if self.busy(): return

    self.redrawCount += 1 # To keep a unit test happy.

    c = self.c

    if trace: g.trace(c.p.h,g.callers(4))

    # Suppress call to setHeadString in onItemChanged!
    self.redrawing = True
    try:
        item = self.getCurrentItem()
        for p in c.rootPosition().self_and_siblings():
            # Updates icons in p and all visible descendants of p.
            self.updateVisibleIcons(p)
    finally:
        self.redrawing = False
#@-node:ekr.20090124174652.27:redraw_after_icons_changed
#@+node:ekr.20090124174652.28:redraw_after_select
# Important: this can not replace before/afterSelectHint.

def redraw_after_select (self,p=None):

    '''Redraw the entire tree when an invisible node
    is selected.'''

    trace = False and not g.unitTesting

    if trace: g.trace('(leoQtTree) busy? %s %s' % (
        self.busy(),p and p.h or '<no p>'),g.callers(4))

    # Prevent the selecting lockout from disabling the redraw.
    oldSelecting = self.selecting
    self.selecting = False
    try:
        if not self.busy():
            self.full_redraw(p,scroll=False)
    finally:
        self.selecting = oldSelecting

    # c.redraw_after_select calls tree.select indirectly.
    # Do not call it again here.
#@-node:ekr.20090124174652.28:redraw_after_select
#@-node:ekr.20090124174652.15:Drawing... (nativeTree)
#@-node:ekr.20091006142109.3700:Fixed @nosent dirty bug
#@+node:ekr.20091219172504.3642:Remove shift from shift-(, etc.
# The fix was a hack to tkKey.
#@nonl
#@+node:ekr.20081121105001.166:class leoQtEventFilter
class leoQtEventFilter(QtCore.QObject):

    << about internal bindings >>

    @others
#@+node:ekr.20081121105001.167:<< about internal bindings >>
@nocolor-node
@

Here are the rules for translating key bindings (in leoSettings.leo) into keys for k.bindingsDict:

1.  The case of plain letters is significant:  a is not A.

2. The Shift- prefix can be applied *only* to letters. Leo will ignore (with a
warning) the shift prefix applied to any other binding, e.g., Ctrl-Shift-(

3. The case of letters prefixed by Ctrl-, Alt-, Key- or Shift- is *not*
significant. Thus, the Shift- prefix is required if you want an upper-case
letter (with the exception of 'bare' uppercase letters.)

The following table illustrates these rules. In each row, the first entry is the
key (for k.bindingsDict) and the other entries are equivalents that the user may
specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
!, Key-!,Key-exclam,exclam

This table is consistent with how Leo already works (because it is consistent
with Tk's key-event specifiers). It is also, I think, the least confusing set of
rules.
#@nonl
#@-node:ekr.20081121105001.167:<< about internal bindings >>
#@+node:ekr.20081121105001.180: ctor
def __init__(self,c,w,tag=''):

    # g.trace('leoQtEventFilter',tag,w)

    # Init the base class.
    QtCore.QObject.__init__(self)

    self.c = c
    self.w = w      # A leoQtX object, *not* a Qt object.
    self.tag = tag

    # Debugging.
    self.keyIsActive = False

    # Pretend there is a binding for these characters.
    close_flashers = c.config.getString('close_flash_brackets') or ''
    open_flashers  = c.config.getString('open_flash_brackets') or ''
    self.flashers = open_flashers + close_flashers


#@-node:ekr.20081121105001.180: ctor
#@+node:ekr.20090407101640.10:char2tkName
char2tkNameDict = {
    # Part 1: same as k.guiBindNamesDict
    "&" : "ampersand",
    "^" : "asciicircum",
    "~" : "asciitilde",
    "*" : "asterisk",
    "@" : "at",
    "\\": "backslash",
    "|" : "bar",
    "{" : "braceleft",
    "}" : "braceright",
    "[" : "bracketleft",
    "]" : "bracketright",
    ":" : "colon",  
    "," : "comma",
    "$" : "dollar",
    "=" : "equal",
    "!" : "exclam",
    ">" : "greater",
    "<" : "less",
    "-" : "minus",
    "#" : "numbersign",
    '"' : "quotedbl",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright", 
    "%" : "percent",
    "." : "period",     
    "+" : "plus",
    "?" : "question",
    "`" : "quoteleft",
    ";" : "semicolon",
    "/" : "slash",
    " " : "space",      
    "_" : "underscore",
    # Part 2: special Qt translations.
    'Backspace':'BackSpace',
    'Backtab':  'Tab', # The shift mod will convert to 'Shift+Tab',
    'Esc':      'Escape',
    'Del':      'Delete',
    'Ins':      'Insert', # was 'Return',
    # Comment these out to pass the key to the QTextWidget.
    # Use these to enable Leo's page-up/down commands.
    'PgDown':    'Next',
    'PgUp':      'Prior',
    # New entries.  These simplify code.
    'Down':'Down','Left':'Left','Right':'Right','Up':'Up',
    'End':'End',
    'F1':'F1','F2':'F2','F3':'F3','F4':'F4','F5':'F5',
    'F6':'F6','F7':'F7','F8':'F8','F9':'F9',
    'F10':'F10','F11':'F11','F12':'F12',
    'Home':'Home',
    # 'Insert':'Insert',
    'Return':'Return',
    # 'Tab':'Tab',
    'Tab':'\t', # A hack for QLineEdit.
    # Unused: Break, Caps_Lock,Linefeed,Num_lock
}

def char2tkName (self,ch):
    val = self.char2tkNameDict.get(ch)
    # g.trace(repr(ch),repr(val))
    return val
#@-node:ekr.20090407101640.10:char2tkName
#@+node:ekr.20081121105001.168:eventFilter
def eventFilter(self, obj, event):

    trace = True and not g.unitTesting
    verbose = True
    traceEvent = False
    traceKey = True
    traceFocus = False
    c = self.c ; k = c.k
    eventType = event.type()
    ev = QtCore.QEvent
    gui = g.app.gui
    aList = []

    kinds = [ev.ShortcutOverride,ev.KeyPress,ev.KeyRelease]

    if trace and traceFocus: self.traceFocus(eventType,obj)

    # A hack. QLineEdit generates ev.KeyRelease only.
    if eventType in (ev.KeyPress,ev.KeyRelease):
        p = c.currentPosition()
        isEditWidget = obj == c.frame.tree.edit_widget(p)
        self.keyIsActive = g.choose(
            isEditWidget,
            eventType == ev.KeyRelease,
            eventType == ev.KeyPress)
    else:
        self.keyIsActive = False

    if eventType == ev.WindowActivate:
        gui.onActivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType == ev.WindowDeactivate:
        gui.onDeactivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType in kinds:
        tkKey,ch,ignore = self.toTkKey(event)
        aList = c.k.masterGuiBindingsDict.get('<%s>' %tkKey,[])
        if ignore:
            override = False
        #### This is extremely bad.  At present, it is needed to handle tab properly.
        elif self.isSpecialOverride(tkKey,ch):
            override = True
        elif k.inState():
            override = not ignore # allow all keystrokes.
        else:
            override = len(aList) > 0
        g.trace(tkKey,len(aList),'ignore',ignore,'override',override)
    else:
        override = False ; tkKey = '<no key>'
        if self.tag == 'body':
            if eventType == ev.FocusIn:
                c.frame.body.onFocusIn(obj)
            elif eventType == ev.FocusOut:
                c.frame.body.onFocusOut(obj)

    if self.keyIsActive:
        stroke = self.toStroke(tkKey,ch)
        if override:
            if trace and traceKey and not ignore:
                g.trace('bound',repr(stroke)) # repr(aList))
            w = self.w # Pass the wrapper class, not the wrapped widget.
            leoEvent = leoKeyEvent(event,c,w,ch,tkKey,stroke)
            ret = k.masterKeyHandler(leoEvent,stroke=stroke)
            c.outerUpdate()
        else:
            if trace and traceKey and verbose:
                g.trace(self.tag,'unbound',tkKey,stroke)

    if trace and traceEvent: self.traceEvent(obj,event,tkKey,override)

    return override
#@-node:ekr.20081121105001.168:eventFilter
#@+node:ekr.20081121105001.182:isSpecialOverride (simplified)
def isSpecialOverride (self,tkKey,ch):

    '''Return True if tkKey is a special Tk key name.
    '''

    return tkKey or ch in self.flashers
#@-node:ekr.20081121105001.182:isSpecialOverride (simplified)
#@+node:ekr.20081121105001.172:qtKey
def qtKey (self,event):

    '''Return the components of a Qt key event.'''

    trace = False and not g.unitTesting
    keynum = event.key()
    text   = event.text() # This is the unicode text.
    toString = QtGui.QKeySequence(keynum).toString()

    try:
        ch1 = chr(keynum)
    except ValueError:
        ch1 = ''

    try:
        ch = g.u(ch1)
    except UnicodeError:
        ch = ch1

    text     = g.u(text)
    toString = g.u(toString)

    if trace and self.keyIsActive: g.trace(
        'keynum %s ch %s ch1 %s toString %s' % (
            repr(keynum),repr(ch),repr(ch1),repr(toString)))

    return keynum,text,toString,ch
#@-node:ekr.20081121105001.172:qtKey
#@+node:ekr.20081121105001.173:qtMods
def qtMods (self,event):

    modifiers = event.modifiers()

    # The order of this table is significant.
    # It must the order of modifiers in bindings
    # in k.masterGuiBindingsDict

    table = (
        (QtCore.Qt.AltModifier,     'Alt'),
        (QtCore.Qt.ControlModifier, 'Control'),
        (QtCore.Qt.MetaModifier,    'Meta'),
        (QtCore.Qt.ShiftModifier,   'Shift'),
    )

    mods = [b for a,b in table if (modifiers & a)]

    return mods
#@-node:ekr.20081121105001.173:qtMods
#@+node:ekr.20081121105001.174:tkKey
def tkKey (self,event,mods,keynum,text,toString,ch):

    '''Carefully convert the Qt key to a 
    Tk-style binding compatible with Leo's core
    binding dictionaries.'''

    trace = False and not g.unitTesting
    ch1 = ch # For tracing.
    use_shift = (
        'Home','End','Tab',
        'Up','Down','Left','Right',
        # Dubious...
        # 'Backspace','Delete','Ins',
        # 'F1',...'F12',
    )

    # Convert '&' to 'ampersand', etc.
    # *Do* allow shift-bracketleft, etc.
    ch2 = self.char2tkName(ch or toString)
    if ch2: ch = ch2 
    if not ch: ch = ''

    if 'Shift' in mods:
        if trace: g.trace(repr(ch))
        if len(ch) == 1 and ch.isalpha():
            mods.remove('Shift')
            ch = ch.upper()
        elif len(ch) > 1 and ch not in use_shift:
            # Experimental!
            mods.remove('Shift')
        # 2009/12/19: Speculative.
        # if ch in ('parenright','parenleft','braceright','braceleft'):
            # mods.remove('Shift')
    elif len(ch) == 1:
        ch = ch.lower()

    if ('Alt' in mods or 'Control' in mods) and ch and ch in string.digits:
        mods.append('Key')

    # *Do* allow bare mod keys, so they won't be passed on.
    tkKey = '%s%s%s' % ('-'.join(mods),mods and '-' or '',ch)

    if trace: g.trace(
        'text: %s toString: %s ch1: %s ch: %s' % (
        repr(text),repr(toString),repr(ch1),repr(ch)))

    ignore = not ch # Essential
    ch = text or toString
    return tkKey,ch,ignore
#@-node:ekr.20081121105001.174:tkKey
#@+node:ekr.20081121105001.169:toStroke
def toStroke (self,tkKey,ch):

    trace = False and not g.unitTesting
    k = self.c.k ; s = tkKey

    special = ('Alt','Ctrl','Control',)
    isSpecial = [True for z in special if s.find(z) > -1]

    if 0:
        if isSpecial:
            pass # s = s.replace('Key-','')
        else:
            # Keep the Tk spellings for special keys.
            ch2 = k.guiBindNamesDict.get(ch)
            if trace: g.trace('ch',repr(ch),'ch2',repr(ch2))
            if ch2: s = s.replace(ch,ch2)

    table = (
        ('Alt-','Alt+'),
        ('Ctrl-','Ctrl+'),
        ('Control-','Ctrl+'),
        # Use Alt+Key-1, etc.  Sheesh.
        # ('Key-','Key+'),
        ('Shift-','Shift+')
    )
    for a,b in table:
        s = s.replace(a,b)

    if trace: g.trace('tkKey',tkKey,'-->',s)
    return s
#@-node:ekr.20081121105001.169:toStroke
#@+node:ekr.20081121105001.170:toTkKey
def toTkKey (self,event):

    mods = self.qtMods(event)

    keynum,text,toString,ch = self.qtKey(event)

    tkKey,ch,ignore = self.tkKey(
        event,mods,keynum,text,toString,ch)

    return tkKey,ch,ignore
#@-node:ekr.20081121105001.170:toTkKey
#@+node:ekr.20081121105001.179:traceEvent
def traceEvent (self,obj,event,tkKey,override):

    if g.unitTesting: return

    c = self.c ; e = QtCore.QEvent
    keys = True ; traceAll = True 
    eventType = event.type()

    show = [
        # (e.Enter,'enter'),(e.Leave,'leave'),
        (e.FocusIn,'focus-in'),(e.FocusOut,'focus-out'),
        # (e.MouseMove,'mouse-move'),
        (e.MouseButtonPress,'mouse-dn'),
        (e.MouseButtonRelease,'mouse-up'),
    ]

    if keys:
        show2 = [
            (e.KeyPress,'key-press'),
            (e.KeyRelease,'key-release'),
            (e.ShortcutOverride,'shortcut-override'),
        ]
        show.extend(show2)

    ignore = (
        1,16,67,70,
        e.ChildPolished,
        e.DeferredDelete,
        e.DynamicPropertyChange,
        e.Enter,e.Leave,
        e.FocusIn,e.FocusOut,
        e.FontChange,
        e.Hide,e.HideToParent,
        e.HoverEnter,e.HoverLeave,e.HoverMove,
        e.LayoutRequest,
        e.MetaCall,e.Move,e.Paint,e.Resize,
        # e.MouseMove,e.MouseButtonPress,e.MouseButtonRelease,
        e.PaletteChange,
        e.ParentChange,
        e.Polish,e.PolishRequest,
        e.Show,e.ShowToParent,
        e.StyleChange,
        e.ToolTip,
        e.WindowActivate,e.WindowDeactivate,
        e.WindowBlocked,e.WindowUnblocked,
        e.ZOrderChange,
    )

    for val,kind in show:
        if eventType == val:
            g.trace(
                '%5s %18s in-state: %5s key: %s override: %s' % (
                self.tag,kind,repr(c.k.inState()),tkKey,override))
            return

    if traceAll and eventType not in ignore:
        g.trace('%3s:%s' % (eventType,'unknown'))
#@-node:ekr.20081121105001.179:traceEvent
#@+node:ekr.20090407080217.1:traceFocus
def traceFocus (self,eventType,obj):

    ev = QtCore.QEvent

    table = (
        (ev.FocusIn,        'focus-in'),
        (ev.FocusOut,       'focus-out'),
        (ev.WindowActivate, 'activate'),
        (ev.WindowDeactivate,'deactivate'),
    )

    for evKind,kind in table:
        if eventType == evKind:
            g.trace('%11s %s %s %s' % (
                (kind,id(obj),
                # event.reason(),
                obj.objectName(),obj)))
                # g.app.gui.widget_name(obj) or obj)))

    # else: g.trace('unknown kind: %s' % eventType)
#@-node:ekr.20090407080217.1:traceFocus
#@-node:ekr.20081121105001.166:class leoQtEventFilter
#@+node:ekr.20081121105001.174:tkKey
def tkKey (self,event,mods,keynum,text,toString,ch):

    '''Carefully convert the Qt key to a 
    Tk-style binding compatible with Leo's core
    binding dictionaries.'''

    trace = False and not g.unitTesting
    ch1 = ch # For tracing.
    use_shift = (
        'Home','End','Tab',
        'Up','Down','Left','Right',
        # Dubious...
        # 'Backspace','Delete','Ins',
        # 'F1',...'F12',
    )

    # Convert '&' to 'ampersand', etc.
    # *Do* allow shift-bracketleft, etc.
    ch2 = self.char2tkName(ch or toString)
    if ch2: ch = ch2 
    if not ch: ch = ''

    if 'Shift' in mods:
        if trace: g.trace(repr(ch))
        if len(ch) == 1 and ch.isalpha():
            mods.remove('Shift')
            ch = ch.upper()
        elif len(ch) > 1 and ch not in use_shift:
            # Experimental!
            mods.remove('Shift')
        # 2009/12/19: Speculative.
        # if ch in ('parenright','parenleft','braceright','braceleft'):
            # mods.remove('Shift')
    elif len(ch) == 1:
        ch = ch.lower()

    if ('Alt' in mods or 'Control' in mods) and ch and ch in string.digits:
        mods.append('Key')

    # *Do* allow bare mod keys, so they won't be passed on.
    tkKey = '%s%s%s' % ('-'.join(mods),mods and '-' or '',ch)

    if trace: g.trace(
        'text: %s toString: %s ch1: %s ch: %s' % (
        repr(text),repr(toString),repr(ch1),repr(ch)))

    ignore = not ch # Essential
    ch = text or toString
    return tkKey,ch,ignore
#@-node:ekr.20081121105001.174:tkKey
#@+node:ekr.20081121105001.168:eventFilter
def eventFilter(self, obj, event):

    trace = True and not g.unitTesting
    verbose = True
    traceEvent = False
    traceKey = True
    traceFocus = False
    c = self.c ; k = c.k
    eventType = event.type()
    ev = QtCore.QEvent
    gui = g.app.gui
    aList = []

    kinds = [ev.ShortcutOverride,ev.KeyPress,ev.KeyRelease]

    if trace and traceFocus: self.traceFocus(eventType,obj)

    # A hack. QLineEdit generates ev.KeyRelease only.
    if eventType in (ev.KeyPress,ev.KeyRelease):
        p = c.currentPosition()
        isEditWidget = obj == c.frame.tree.edit_widget(p)
        self.keyIsActive = g.choose(
            isEditWidget,
            eventType == ev.KeyRelease,
            eventType == ev.KeyPress)
    else:
        self.keyIsActive = False

    if eventType == ev.WindowActivate:
        gui.onActivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType == ev.WindowDeactivate:
        gui.onDeactivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType in kinds:
        tkKey,ch,ignore = self.toTkKey(event)
        aList = c.k.masterGuiBindingsDict.get('<%s>' %tkKey,[])
        if ignore:
            override = False
        #### This is extremely bad.  At present, it is needed to handle tab properly.
        elif self.isSpecialOverride(tkKey,ch):
            override = True
        elif k.inState():
            override = not ignore # allow all keystrokes.
        else:
            override = len(aList) > 0
        g.trace(tkKey,len(aList),'ignore',ignore,'override',override)
    else:
        override = False ; tkKey = '<no key>'
        if self.tag == 'body':
            if eventType == ev.FocusIn:
                c.frame.body.onFocusIn(obj)
            elif eventType == ev.FocusOut:
                c.frame.body.onFocusOut(obj)

    if self.keyIsActive:
        stroke = self.toStroke(tkKey,ch)
        if override:
            if trace and traceKey and not ignore:
                g.trace('bound',repr(stroke)) # repr(aList))
            w = self.w # Pass the wrapper class, not the wrapped widget.
            leoEvent = leoKeyEvent(event,c,w,ch,tkKey,stroke)
            ret = k.masterKeyHandler(leoEvent,stroke=stroke)
            c.outerUpdate()
        else:
            if trace and traceKey and verbose:
                g.trace(self.tag,'unbound',tkKey,stroke)

    if trace and traceEvent: self.traceEvent(obj,event,tkKey,override)

    return override
#@-node:ekr.20081121105001.168:eventFilter
#@-node:ekr.20091219172504.3642:Remove shift from shift-(, etc.
#@+node:ekr.20091221122450.3656:Allow horizontal scrolling in QtTree
#@+node:ekr.20081121105001.400:class leoQtTree (baseNativeTree)
class leoQtTree (baseNativeTree.baseNativeTreeWidget):

    """Leo qt tree class, a subclass of baseNativeTreeWidget."""

    callbacksInjected = False # A class var.

    @others
#@+node:ekr.20090124174652.118: Birth (leoQtTree)
#@+node:ekr.20090124174652.119:ctor
def __init__(self,c,frame):

    # Init the base class.
    baseNativeTree.baseNativeTreeWidget.__init__(self,c,frame)

    # Components.
    self.headlineWrapper = leoQtHeadlineWidget # This is a class.
    self.treeWidget = w = frame.top.ui.treeWidget # An internal ivar.

    # Early inits...
    try: w.headerItem().setHidden(True)
    except Exception: pass

    w.setIconSize(QtCore.QSize(160,16))
#@-node:ekr.20090124174652.119:ctor
#@+node:ekr.20090124174652.120:qtTree.initAfterLoad
def initAfterLoad (self):

    '''Do late-state inits.'''

    # Called by Leo's core.

    c = self.c ; frame = c.frame
    w = c.frame.top ; tw = self.treeWidget

    if not leoQtTree.callbacksInjected:
        leoQtTree.callbacksInjected = True
        self.injectCallbacks() # A base class method.

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemDoubleClicked(QTreeWidgetItem*, int)"),
        self.onItemDoubleClicked)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemClicked(QTreeWidgetItem*, int)"),
        self.onItemClicked)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemSelectionChanged()"),
        self.onTreeSelect)

    # We don't need this.  Hooray!
    # w.connect(self.treeWidget,QtCore.SIGNAL(
            # "itemChanged(QTreeWidgetItem*, int)"),
        # self.onItemChanged)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemCollapsed(QTreeWidgetItem*)"),
        self.onItemCollapsed)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemExpanded(QTreeWidgetItem*)"),
        self.onItemExpanded)

    w.connect(self.treeWidget, QtCore.SIGNAL(
            "customContextMenuRequested(QPoint)"),
        self.onContextMenu)    

    self.ev_filter = leoQtEventFilter(c,w=self,tag='tree')
    tw.installEventFilter(self.ev_filter)

    c.setChanged(False)
#@-node:ekr.20090124174652.120:qtTree.initAfterLoad
#@-node:ekr.20090124174652.118: Birth (leoQtTree)
#@+node:ekr.20090124174652.102:Widget-dependent helpers (leoQtTree)
#@+node:ekr.20090126120517.11:Drawing
def clear (self):
    '''Clear all widgets in the tree.'''
    w = self.treeWidget
    w.clear()

def repaint (self):
    '''Repaint the widget.'''
    w = self.treeWidget
    w.repaint()
    w.resizeColumnToContents(0) # 2009/12/22
#@nonl
#@-node:ekr.20090126120517.11:Drawing
#@+node:ekr.20090124174652.109:Icons (qtTree)
#@+node:ekr.20090124174652.110:drawIcon
def drawIcon (self,p):

    '''Redraw the icon at p.'''

    w = self.treeWidget
    itemOrTree = self.position2item(p) or w
    item = QtGui.QTreeWidgetItem(itemOrTree)
    icon = self.getIcon(p)
    self.setItemIcon(item,icon)

#@-node:ekr.20090124174652.110:drawIcon
#@+node:ekr.20090124174652.111:getIcon & helper (qtTree)
def getIcon(self,p):

    '''Return the proper icon for position p.'''

    p.v.iconVal = val = p.v.computeIcon()
    return self.getCompositeIconImage(p,val)
#@+node:ekr.20090701122113.3736:getCompositeIconImage
def getCompositeIconImage(self,p,val):

    trace = False and not g.unitTesting
    userIcons = self.c.editCommands.getIconList(p)
    if not userIcons:
        return self.getStatusIconImage(p)

    hash = [i['file'] for i in userIcons if i['where'] == 'beforeIcon']
    hash.append(str(val))
    hash.extend([i['file'] for i in userIcons if i['where'] == 'beforeHeadline'])
    hash = ':'.join(hash)

    if hash in g.app.gui.iconimages:
        icon = g.app.gui.iconimages[hash]
        if trace: g.trace('cached %s' % (icon))
        return icon

    images = [g.app.gui.getImageImage(i['file']) for i in userIcons
             if i['where'] == 'beforeIcon']
    images.append(g.app.gui.getImageImage("box%02d.GIF" % val))
    images.extend([g.app.gui.getImageImage(i['file']) for i in userIcons
                  if i['where'] == 'beforeHeadline'])
    width = sum([i.width() for i in images])
    height = max([i.height() for i in images])

    pix = QtGui.QPixmap(width,height)
    pix.fill()
    pix.setAlphaChannel(pix)
    painter = QtGui.QPainter(pix)
    x = 0
    for i in images:
        painter.drawPixmap(x,(height-i.height())//2,i)
        x += i.width()
    painter.end()

    icon = QtGui.QIcon(pix)
    g.app.gui.iconimages[hash] = icon
    if trace: g.trace('new %s' % (icon))
    return icon
#@-node:ekr.20090701122113.3736:getCompositeIconImage
#@-node:ekr.20090124174652.111:getIcon & helper (qtTree)
#@+node:ekr.20090124174652.112:setItemIconHelper (qtTree)
def setItemIconHelper (self,item,icon):

    # Generates an item-changed event.
    # g.trace(id(icon))
    if item:
        item.setIcon(0,icon)
#@-node:ekr.20090124174652.112:setItemIconHelper (qtTree)
#@-node:ekr.20090124174652.109:Icons (qtTree)
#@+node:ekr.20090124174652.115:Items
#@+node:ekr.20090124174652.67:childIndexOfItem
def childIndexOfItem (self,item):

    parent = item and item.parent()

    if parent:
        n = parent.indexOfChild(item)
    else:
        w = self.treeWidget
        n = w.indexOfTopLevelItem(item)

    return n

#@-node:ekr.20090124174652.67:childIndexOfItem
#@+node:ekr.20090124174652.66:childItems
def childItems (self,parent_item):

    '''Return the list of child items of the parent item,
    or the top-level items if parent_item is None.'''

    if parent_item:
        n = parent_item.childCount()
        items = [parent_item.child(z) for z in range(n)]
    else:
        w = self.treeWidget
        n = w.topLevelItemCount()
        items = [w.topLevelItem(z) for z in range(n)]

    return items
#@-node:ekr.20090124174652.66:childItems
#@+node:ekr.20090303095630.15:closeEditorHelper (leoQtTree)
def closeEditorHelper (self,e,item):

    w = self.treeWidget

    if e:
        w.closeEditor(e,QtGui.QAbstractItemDelegate.NoHint)
        w.setCurrentItem(item)
#@-node:ekr.20090303095630.15:closeEditorHelper (leoQtTree)
#@+node:ekr.20090322190318.10:connectEditorWidget & helper
def connectEditorWidget(self,e,item):

    c = self.c ; w = self.treeWidget

    if not e: return g.trace('can not happen: no e')

    wrapper = self.getWrapper(e,item)

    # Hook up the widget.
    def editingFinishedCallback(e=e,item=item,self=self,wrapper=wrapper):
        # g.trace(wrapper,g.callers(5))
        c = self.c ; w = self.treeWidget
        self.onHeadChanged(p=c.p,e=e)
        w.setCurrentItem(item)

    e.connect(e,QtCore.SIGNAL(
        "editingFinished()"),
        editingFinishedCallback)
#@nonl
#@-node:ekr.20090322190318.10:connectEditorWidget & helper
#@+node:ekr.20090124174652.18:contractItem & expandItem
def contractItem (self,item):

    # g.trace(g.callers(4))

    self.treeWidget.collapseItem(item)

def expandItem (self,item):

    # g.trace(g.callers(4))

    self.treeWidget.expandItem(item)
#@-node:ekr.20090124174652.18:contractItem & expandItem
#@+node:ekr.20090124174652.104:createTreeEditorForItem (leoQtTree)
def createTreeEditorForItem(self,item):

    trace = False and not g.unitTesting

    w = self.treeWidget
    w.setCurrentItem(item) # Must do this first.
    w.editItem(item)
    e = w.itemWidget(item,0)
    e.setObjectName('headline')
    self.connectEditorWidget(e,item)

    return e
#@nonl
#@-node:ekr.20090124174652.104:createTreeEditorForItem (leoQtTree)
#@+node:ekr.20090124174652.103:createTreeItem
def createTreeItem(self,p,parent_item):

    trace = False and not g.unitTesting

    w = self.treeWidget
    itemOrTree = parent_item or w
    item = QtGui.QTreeWidgetItem(itemOrTree)
    item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)

    if trace: g.trace(id(item),p.h,g.callers(4))
    try:
        g.visit_tree_item(self.c, p, item)
    except leoPlugins.TryNext:
        pass
    #print "item",item
    return item
#@-node:ekr.20090124174652.103:createTreeItem
#@+node:ekr.20090129062500.13:editLabelHelper (leoQtTree)
def editLabelHelper (self,item,selectAll=False,selection=None):

    '''Called by nativeTree.editLabel to do
    gui-specific stuff.'''

    w = self.treeWidget
    w.setCurrentItem(item) # Must do this first.
    w.editItem(item)
        # Generates focus-in event that tree doesn't report.
    e = w.itemWidget(item,0) # A QLineEdit.

    if e:
        s = e.text() ; len_s = len(s)
        if s == 'newHeadline': selectAll=True
        if selection:
            i,j,ins = selection
            start,n = i,abs(i-j)
                # Not right for backward searches.
        elif selectAll: start,n,ins = 0,len_s,len_s
        else:           start,n,ins = len_s,0,len_s
        e.setObjectName('headline')
        e.setSelection(start,n)
        # e.setCursorPosition(ins) # Does not work.
        e.setFocus()
        self.connectEditorWidget(e,item) # Hook up the widget.

    return e
#@-node:ekr.20090129062500.13:editLabelHelper (leoQtTree)
#@+node:ekr.20090124174652.105:getCurrentItem
def getCurrentItem (self):

    w = self.treeWidget
    return w.currentItem()
#@-node:ekr.20090124174652.105:getCurrentItem
#@+node:ekr.20090126120517.22:getItemText
def getItemText (self,item):

    '''Return the text of the item.'''

    if item:
        return g.u(item.text(0))
    else:
        return '<no item>'
#@nonl
#@-node:ekr.20090126120517.22:getItemText
#@+node:ekr.20090126120517.19:getParentItem
def getParentItem(self,item):

    return item and item.parent()
#@nonl
#@-node:ekr.20090126120517.19:getParentItem
#@+node:ville.20090525205736.3927:getSelectedItems
def getSelectedItems(self):
    w = self.treeWidget    
    return w.selectedItems()
#@nonl
#@-node:ville.20090525205736.3927:getSelectedItems
#@+node:ekr.20090124174652.106:getTreeEditorForItem (leoQtTree)
def getTreeEditorForItem(self,item):

    '''Return the edit widget if it exists.
    Do *not* create one if it does not exist.'''

    w = self.treeWidget
    e = w.itemWidget(item,0)
    return e
#@-node:ekr.20090124174652.106:getTreeEditorForItem (leoQtTree)
#@+node:ekr.20090602083443.3817:getWrapper (leoQtTree)
def getWrapper (self,e,item):

    '''Return headlineWrapper that wraps e (a QLineEdit).'''

    c = self.c

    if e:
        wrapper = self.editWidgetsDict.get(e)
        if not wrapper:
            wrapper = self.headlineWrapper(c,item,name='head',widget=e)
            self.editWidgetsDict[e] = wrapper

        return wrapper
    else:
        return None
#@-node:ekr.20090602083443.3817:getWrapper (leoQtTree)
#@+node:ekr.20090124174652.69:nthChildItem
def nthChildItem (self,n,parent_item):

    children = self.childItems(parent_item)

    if n < len(children):
        item = children[n]
    else:
        # This is **not* an error.
        # It simply means that we need to redraw the tree.
        item = None

    return item
#@-node:ekr.20090124174652.69:nthChildItem
#@+node:ekr.20090201080444.12:scrollToItem
def scrollToItem (self,item):

    w = self.treeWidget

    # g.trace(self.traceItem(item),g.callers(4))

    hPos,vPos = self.getScroll()

    w.scrollToItem(item,w.PositionAtCenter)

    self.setHScroll(0)
#@-node:ekr.20090201080444.12:scrollToItem
#@+node:ekr.20090124174652.107:setCurrentItemHelper (leoQtTree)
def setCurrentItemHelper(self,item):

    w = self.treeWidget
    w.setCurrentItem(item)
#@-node:ekr.20090124174652.107:setCurrentItemHelper (leoQtTree)
#@+node:ekr.20090124174652.108:setItemText
def setItemText (self,item,s):

    if item:
        item.setText(0,s)
#@-node:ekr.20090124174652.108:setItemText
#@-node:ekr.20090124174652.115:Items
#@+node:ekr.20090124174652.122:Scroll bars (leoQtTree)
#@+node:ekr.20090531084925.3779:getSCroll
def getScroll (self):

    '''Return the hPos,vPos for the tree's scrollbars.'''

    w = self.treeWidget
    hScroll = w.horizontalScrollBar()
    vScroll = w.verticalScrollBar()
    hPos = hScroll.sliderPosition()
    vPos = vScroll.sliderPosition()
    return hPos,vPos
#@-node:ekr.20090531084925.3779:getSCroll
#@+node:ekr.20090531084925.3780:setH/VScroll
def setHScroll (self,hPos):
    w = self.treeWidget
    hScroll = w.horizontalScrollBar()
    hScroll.setValue(hPos)

def setVScroll (self,vPos):
    # g.trace(vPos)
    w = self.treeWidget
    vScroll = w.verticalScrollBar()
    vScroll.setValue(vPos)
#@nonl
#@-node:ekr.20090531084925.3780:setH/VScroll
#@+node:ekr.20090531084925.3774:scrollDelegate (leoQtTree)
def scrollDelegate (self,kind):

    '''Scroll a QTreeWidget up or down.
    kind is in ('down-line','down-page','up-line','up-page')
    '''
    c = self.c ; w = self.treeWidget
    vScroll = w.verticalScrollBar()
    h = w.size().height()
    lineSpacing = w.fontMetrics().lineSpacing()
    n = h/lineSpacing
    if   kind == 'down-half-page': delta = n/2
    elif kind == 'down-line':      delta = 1
    elif kind == 'down-page':      delta = n
    elif kind == 'up-half-page':   delta = -n/2
    elif kind == 'up-line':        delta = -1
    elif kind == 'up-page':        delta = -n
    else:
        delta = 0 ; g.trace('bad kind:',kind)
    val = vScroll.value()
    # g.trace(kind,n,h,lineSpacing,delta,val)
    vScroll.setValue(val+delta)
    c.treeWantsFocus()
#@-node:ekr.20090531084925.3774:scrollDelegate (leoQtTree)
#@-node:ekr.20090124174652.122:Scroll bars (leoQtTree)
#@+node:ville.20090630151546.3969:onContextMenu (leoQtTree)
def onContextMenu(self, point):
    c = self.c
    w = self.treeWidget
    handlers = g.tree_popup_handlers    
    menu = QtGui.QMenu()
    menuPos = w.mapToGlobal(point)
    if not handlers:
        menu.addAction("No popup handlers")

    p = c.currentPosition().copy()
    done = set()
    for h in handlers:
        # every handler has to add it's QActions by itself
        if h in done:
            # do not run the same handler twice
            continue
        h(c,p,menu)

    a = menu.popup(menuPos)
    self._contextmenu = menu
#@-node:ville.20090630151546.3969:onContextMenu (leoQtTree)
#@-node:ekr.20090124174652.102:Widget-dependent helpers (leoQtTree)
#@-node:ekr.20081121105001.400:class leoQtTree (baseNativeTree)
#@+node:ekr.20090126120517.11:Drawing
def clear (self):
    '''Clear all widgets in the tree.'''
    w = self.treeWidget
    w.clear()

def repaint (self):
    '''Repaint the widget.'''
    w = self.treeWidget
    w.repaint()
    w.resizeColumnToContents(0) # 2009/12/22
#@nonl
#@-node:ekr.20090126120517.11:Drawing
#@-node:ekr.20091221122450.3656:Allow horizontal scrolling in QtTree
#@+node:ekr.20091221161510.3679:Undo bugs
#@+node:ekr.20091221161510.3680:Changes
#@+node:ekr.20081121110412.472:tree.redraw_now & helper (tkTree)
# New in 4.4b2: suppress scrolling by default.
# New in 4.6: enable scrolling by default.

def redraw_now (self,p=None,scroll=True,forceDraw=False):

    '''Redraw immediately.
    forceDraw is used to eliminate draws while dragging.'''

    trace = False and not g.unitTesting
    c = self.c

    if g.app.quitting or self.frame not in g.app.windowList:
        return
    if self.drag_p and not forceDraw:
        return

    if p is None:
        p = c.currentPosition()
    else:
        c.setCurrentPosition(p)

    if trace: g.trace(self.redrawCount,g.callers(8))

    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary()
        if self.trace_redraw or self.trace_alloc:
            # g.trace(self.redrawCount,g.callers())
            # g.trace(c.rootPosition().h,'canvas:',id(self.canvas),g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()

    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    if 0: #### A major change.
        self.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            self.endUpdate(False)

    # Do the actual redraw. (c.redraw has called c.expandAllAncestors.)
    if self.idle_redraw:
        def idleRedrawCallback(event=None,self=self,scroll=scroll):
            self.redrawHelper(scroll=scroll,forceDraw=forceDraw)
        self.canvas.after_idle(idleRedrawCallback)
    else:
        self.redrawHelper(scroll=scroll,forceDraw=forceDraw)

    if g.app.unitTesting:
        self.canvas.update_idletasks() # Important for unit tests.

redraw = redraw_now # Compatibility
#@+node:ekr.20081121110412.473:redrawHelper
def redrawHelper (self,scroll=True,forceDraw=False):

    # This can be called at idle time, so there are shutdown issues.
    if g.app.quitting or self.frame not in g.app.windowList:
        return
    if self.drag_p and not forceDraw:
        return
    if not hasattr(self,'c'):
        return

    c = self.c ; trace = False
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):

        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        bbox = self.canvas.bbox('all')
        if trace: g.trace('bbox',bbox,g.callers())
        if bbox is None:
            x0,y0,x1,y1 = 0,0,100,100
        else:
            x0, y0, x1, y1 = bbox
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()

    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@-node:ekr.20081121110412.473:redrawHelper
#@-node:ekr.20081121110412.472:tree.redraw_now & helper (tkTree)
#@-node:ekr.20091221161510.3680:Changes
#@+node:ekr.20090124174652.59:onHeadChanged (nativeTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None,e=None):

    '''Officially change a headline.'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; u = c.undoer
    if not p:
        if trace: g.trace('** no p')
        return

    item = self.getCurrentItem()
    if not item:
        if trace and verbose: g.trace('** no item')
        return
    if not e:
        e = self.getTreeEditorForItem(item)
    if not e:
        if trace and verbose: g.trace('** not editing')
        return

    s = g.u(e.text())

    if g.doHook("headkey1",c=c,p=c.p,v=c.p,s=s):
        return

    self.closeEditorHelper(e,item)
    oldHead = p.h
    changed = s != oldHead
    if changed:
        if trace: g.trace('new',repr(s),'old',p.h,g.callers())
        p.initHeadString(s)
        item.setText(0,s) # Required to avoid full redraw.
        undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)

    g.doHook("headkey2",c=c,p=c.p,v=c.p,s=s)

    # This is a crucial shortcut.
    if g.unitTesting: return

    if changed:
        self.redraw_after_head_changed()

    if 0: # Don't do this: it interferes with clicks, and is not needed.
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()

    c.outerUpdate()
#@-node:ekr.20090124174652.59:onHeadChanged (nativeTree)
#@+node:ekr.20081121110412.435:class leoTkinterTree
class leoTkinterTree (leoFrame.leoTree):

    """Leo tkinter tree class."""

    callbacksInjected = False

    << about drawing >>

    @others
#@+node:ekr.20081121110412.436:  << About drawing >>
@

New in Leo 4.5: The 'Newest World Order':

- Redrawing the screen and setting focus only happen in c.outerUpdate.
- c.redraw only requests a redraw.
- c.redraw_now is equivalent to c.redraw() followed by c.outerUpdate.
- c.beginUpdate does nothing.  c.endUpdate(False) does nothing.
- c.endUpdate() is equivalent to c.redraw()
- There is no longer any need to ensure c.endUpdate is called for every c.beginUpdate.
  Thus, there is no need for the associated try/finally statements.
#@-node:ekr.20081121110412.436:  << About drawing >>
#@+node:ekr.20081121110412.438:  Notes
@killcolor
#@+node:ekr.20081121110412.439:Changes made since first update
@

- disabled drawing of user icons.  They weren't being hidden, which messed up scrolling.

- Expanded clickBox so all clicks fall inside it.

- Added binding for plugBox so it doesn't interfere with the clickBox.  Another weirdness.

- Re-enabled code in drawText that sets the headline state.

- eventToPosition now returns p.copy, which means that nobody can change the list.

- Likewise, clear self.iconIds so old icon id's don't confuse findVnodeWithIconId.

- All drawing methods must do p = p.copy() at the beginning if they make any changes to p.
    - This ensures neither they nor their allies can change the caller's position.
    - In fact, though, only drawTree changes position.  It makes a copy before calling drawNode.
    *** Therefore, all positions in the drawing code are immutable!

- Fixed the race conditions that caused drawing sometimes to fail.  The essential idea is that we must not call w.config if we are about to do a redraw.  For full details, see the Notes node in the Race Conditions section.
#@-node:ekr.20081121110412.439:Changes made since first update
#@+node:ekr.20081121110412.440:Changes made since second update
@

- Removed duplicate code in tree.select.  The following code was being called twice (!!):
    self.endEditLabel()
    self.setUnselectedLabelState(old_p)

- Add p.copy() instead of p when inserting nodes into data structures in select.

- Fixed a _major_ bug in Leo's core.  c.setCurrentPosition must COPY the position given to it!  It's _not_ enough to return a copy of position: it may already have changed!!

- Fixed a another (lesser??) bug in Leo's core.  handleUserClick should also make a copy.

- Fixed bug in mod_scripting.py.  The callback was failing if the script was empty.

- Put in the self.recycle ivar AND THE CODE STILL FAILS.
    It seems to me that this shows there is a bug in my code somewhere, but where ???????????????????
#@-node:ekr.20081121110412.440:Changes made since second update
#@+node:ekr.20081121110412.441:Most recent changes
@

- Added generation count.
    - Incremented on each redraw.
    - Potentially a barrior to race conditions, but it never seemed to do anything.
    - This code is a candidate for elimination.

- Used vnodes rather than positions in several places.
    - I actually don't think this was involved in the real problem, and it doesn't hurt.

- Added much better traces: the beginning of the end for the bugs :-)
    - Added self.verbose option.
    - Added align keyword option to g.trace.
    - Separate each set of traces by a blank line.
        - This makes clear the grouping of id's.

- Defensive code: Disable dragging at start of redraw code.
    - This protects against race conditions.

- Fixed blunder 1: Fixed a number of bugs in the dragging code.
    - I had never looked at this code!
    - Eliminating false drags greatly simplifies matters.

- Fixed blunder 2: Added the following to eventToPosition:
        x = canvas.canvasx(x)
        y = canvas.canvasy(y)
    - Apparently this was the cause of false associations between icons and id's.
    - It's amazing that the code didn't fail earlier without these!

- Converted all module-level constants to ivars.

- Lines no longer interfere with eventToPosition.
    - The problem was that find_nearest or find_overlapping don't depend on stacking order!
    - Added p param to horizontal lines, but not vertical lines.
    - EventToPosition adds 1 to the x coordinate of vertical lines, then recomputes the id.

- Compute indentation only in forceDrawNode.  Removed child_indent constant.

- Simplified drawTree to use indentation returned from forceDrawNode.

- setHeadlineText now ensures that state is "normal" before attempting to set the text.
    - This is the robust way.

7/31/04: newText must call setHeadlineText for all nodes allocated, even if p matches.
#@-node:ekr.20081121110412.441:Most recent changes
#@-node:ekr.20081121110412.438:  Notes
#@+node:ekr.20081121110412.442: Birth... (tkTree)
#@+node:ekr.20081121110412.443:__init__ (tkTree)
def __init__(self,c,frame,canvas):

    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Configuration and debugging settings.
    # These must be defined here to eliminate memory leaks.
    self.allow_clone_drags          = c.config.getBool('allow_clone_drags')
    self.center_selected_tree_node  = c.config.getBool('center_selected_tree_node')
    self.enable_drag_messages       = c.config.getBool("enable_drag_messages")
    self.expanded_click_area        = c.config.getBool('expanded_click_area')
    self.gc_before_redraw           = c.config.getBool('gc_before_redraw')

    self.headline_text_editing_foreground_color = c.config.getColor(
        'headline_text_editing_foreground_color')
    self.headline_text_editing_background_color = c.config.getColor(
        'headline_text_editing_background_color')
    self.headline_text_editing_selection_foreground_color = c.config.getColor(
        'headline_text_editing_selection_foreground_color')
    self.headline_text_editing_selection_background_color = c.config.getColor(
        'headline_text_editing_selection_background_color')
    self.headline_text_selected_foreground_color = c.config.getColor(
        "headline_text_selected_foreground_color")
    self.headline_text_selected_background_color = c.config.getColor(
        "headline_text_selected_background_color")
    self.headline_text_editing_selection_foreground_color = c.config.getColor(
        "headline_text_editing_selection_foreground_color")
    self.headline_text_editing_selection_background_color = c.config.getColor(
        "headline_text_editing_selection_background_color")
    self.headline_text_unselected_foreground_color = c.config.getColor(
        'headline_text_unselected_foreground_color')
    self.headline_text_unselected_background_color = c.config.getColor(
        'headline_text_unselected_background_color')

    self.idle_redraw = c.config.getBool('idle_redraw')
    self.initialClickExpandsOrContractsNode = c.config.getBool(
        'initialClickExpandsOrContractsNode')
    self.look_for_control_drag_on_mouse_down = c.config.getBool(
        'look_for_control_drag_on_mouse_down')
    self.select_all_text_when_editing_headlines = c.config.getBool(
        'select_all_text_when_editing_headlines')

    self.stayInTree     = c.config.getBool('stayInTreeAfterSelect')
    self.trace          = c.config.getBool('trace_tree')
    self.trace_alloc    = c.config.getBool('trace_tree_alloc')
    self.trace_chapters = c.config.getBool('trace_chapters')
    self.trace_edit     = c.config.getBool('trace_tree_edit')
    self.trace_gc       = c.config.getBool('trace_tree_gc')
    self.trace_redraw   = c.config.getBool('trace_tree_redraw')
    self.trace_select   = c.config.getBool('trace_select')
    self.trace_stats    = c.config.getBool('show_tree_stats')
    self.use_chapters   = c.config.getBool('use_chapters')

    # Objects associated with this tree.
    self.canvas = canvas

    << define drawing constants >>
    << old ivars >>
    << inject callbacks into the position class >>

    self.dragging = False
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.

    # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.updateCount = 0 # Drawing is enabled only if self.updateCount <= 0
    self.verbose = True

    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()

    # Keys are id's, values are positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {}
        # Pre 4.4b2: Keys are vnodes, values are Tk.Text widgets.
        #     4.4b2: Keys are p.key(), values are Tk.Text widgets.
    self.visibleUserIcons = []

    # Dictionaries of free, hidden widgets...
    # Keys are id's, values are widgets.
    self.freeBoxes = {}
    self.freeClickBoxes = {}
    self.freeIcons = {}
    self.freeLines = {}
    self.freeText = {} # New in 4.4b2: a list of free Tk.Text widgets

    self.freeUserIcons = {}

    self._block_canvas_menu = False
#@nonl
#@+node:ekr.20081121110412.444:<< define drawing constants >>
self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height
#@-node:ekr.20081121110412.444:<< define drawing constants >>
#@+node:ekr.20081121110412.445:<< old ivars >>
# Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if present headline is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = 0.0
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    c.bind(self.frame.bar1,"<Button-1-ButtonRelease>", self.redraw_now)
#@-node:ekr.20081121110412.445:<< old ivars >>
#@+node:ekr.20081121110412.446:<< inject callbacks into the position class >>
# The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()
#@-node:ekr.20081121110412.446:<< inject callbacks into the position class >>
#@-node:ekr.20081121110412.443:__init__ (tkTree)
#@+node:ekr.20081121110412.447:tkTtree.setBindings & helper
def setBindings (self,):

    '''Create master bindings for all headlines.'''

    tree = self ; k = self.c.k

    # g.trace('self',self,'canvas',self.canvas)

    tree.setBindingsHelper()

    tree.setCanvasBindings(self.canvas)

    k.completeAllBindingsForWidget(self.canvas)

    k.completeAllBindingsForWidget(self.bindingWidget)

#@+node:ekr.20081121110412.448:tkTree.setBindingsHelper
def setBindingsHelper (self):

    tree = self ; c = tree.c ; k = c.k

    self.bindingWidget = w = g.app.gui.plainTextWidget(
        self.canvas,name='bindingWidget')

    c.bind(w,'<Key>',k.masterKeyHandler)

    table = [
        ('<Button-1>',       k.masterClickHandler,          tree.onHeadlineClick),
        ('<Button-3>',       k.masterClick3Handler,         tree.onHeadlineRightClick),
        ('<Double-Button-1>',k.masterDoubleClickHandler,    tree.onHeadlineClick),
        ('<Double-Button-3>',k.masterDoubleClick3Handler,   tree.onHeadlineRightClick),
    ]

    for a,handler,func in table:
        def treeBindingCallback(event,handler=handler,func=func):
            # g.trace('func',func)
            return handler(event,func)
        c.bind(w,a,treeBindingCallback)

    self.textBindings = w.bindtags()
#@-node:ekr.20081121110412.448:tkTree.setBindingsHelper
#@-node:ekr.20081121110412.447:tkTtree.setBindings & helper
#@+node:ekr.20081121110412.449:tkTree.setCanvasBindings
def setCanvasBindings (self,canvas):

    c = self.c ; k = c.k

    c.bind(canvas,'<Key>',k.masterKeyHandler)
    c.bind(canvas,'<Button-1>',self.onTreeClick)
    c.bind(canvas,'<Button-3>',self.onTreeRightClick)
    # c.bind(canvas,'<FocusIn>',self.onFocusIn)

    << make bindings for tagged items on the canvas >>
    << create baloon bindings for tagged items on the canvas >>
#@nonl
#@+node:ekr.20081121110412.450:<< make bindings for tagged items on the canvas >>
where = g.choose(self.expanded_click_area,'clickBox','plusBox')

table = (
    (where,    '<Button-1>',self.onClickBoxClick),
    ('iconBox','<Button-1>',self.onIconBoxClick),
    ('iconBox','<Double-1>',self.onIconBoxDoubleClick),
    ('iconBox','<Button-3>',self.onIconBoxRightClick),
    ('iconBox','<Double-3>',self.onIconBoxRightClick),
    ('iconBox','<B1-Motion>',self.onDrag),
    ('iconBox','<Any-ButtonRelease-1>',self.onEndDrag),

    ('plusBox','<Button-3>', self.onPlusBoxRightClick),
    ('plusBox','<Button-1>', self.onClickBoxClick),
    ('clickBox','<Button-3>',  self.onClickBoxRightClick),
)
for tag,event_kind,callback in table:
    c.tag_bind(canvas,tag,event_kind,callback)
#@-node:ekr.20081121110412.450:<< make bindings for tagged items on the canvas >>
#@+node:ekr.20081121110412.451:<< create baloon bindings for tagged items on the canvas >>
if 0: # I find these very irritating.
    for tag,text in (
        # ('plusBox','plusBox'),
        ('iconBox','Icon Box'),
        ('selectBox','Click to select'),
        ('clickBox','Click to expand or contract'),
        # ('textBox','Headline'),
    ):
        # A fairly long wait is best.
        balloon = Pmw.Balloon(self.canvas,initwait=700)
        balloon.tagbind(self.canvas,tag,balloonHelp=text)
#@-node:ekr.20081121110412.451:<< create baloon bindings for tagged items on the canvas >>
#@-node:ekr.20081121110412.449:tkTree.setCanvasBindings
#@-node:ekr.20081121110412.442: Birth... (tkTree)
#@+node:ekr.20081121110412.452:Allocation...
#@+node:ekr.20081121110412.453:newBox
def newBox (self,p,x,y,image):

    canvas = self.canvas ; tag = "plusBox"

    if self.freeBoxes:
        # theId = self.freeBoxes.pop(0)
        d = self.freeBoxes ; theId = d.keys()[0] ; del d[theId]
        canvas.coords(theId,x,y)
        canvas.itemconfigure(theId,image=image)
    else:
        theId = canvas.create_image(x,y,image=image,tag=tag)
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.h),align=-20)

    if theId not in self.visibleBoxes: 
        self.visibleBoxes.append(theId)

    if p:
        self.ids[theId] = p

    return theId
#@-node:ekr.20081121110412.453:newBox
#@+node:ekr.20081121110412.454:newClickBox
def newClickBox (self,p,x1,y1,x2,y2):

    canvas = self.canvas ; defaultColor = ""
    tag = g.choose(p.hasChildren(),'clickBox','selectBox')

    if self.freeClickBoxes:
        # theId = self.freeClickBoxes.pop(0)
        d = self.freeClickBoxes ; theId = d.keys()[0] ; del d[theId]
        canvas.coords(theId,x1,y1,x2,y2)
        canvas.itemconfig(theId,tag=tag)
    else:
        theId = self.canvas.create_rectangle(x1,y1,x2,y2,tag=tag)
        canvas.itemconfig(theId,fill=defaultColor,outline=defaultColor)
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.h),align=-20)

    if theId not in self.visibleClickBoxes:
        self.visibleClickBoxes.append(theId)
    if p:
        self.ids[theId] = p

    return theId
#@-node:ekr.20081121110412.454:newClickBox
#@+node:ekr.20081121110412.455:newIcon
def newIcon (self,p,x,y,image):

    canvas = self.canvas ; tag = "iconBox"

    if self.freeIcons:
        # theId = self.freeIcons.pop(0)
        d = self.freeIcons ; theId = d.keys()[0] ; del d[theId]
        canvas.itemconfigure(theId,image=image)
        canvas.coords(theId,x,y)
    else:
        theId = canvas.create_image(x,y,image=image,anchor="nw",tag=tag)
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.h),align=-20)

    if theId not in self.visibleIcons:
        self.visibleIcons.append(theId)

    if p:
        data = p,self.generation
        self.iconIds[theId] = data # Remember which vnode belongs to the icon.
        self.ids[theId] = p

    return theId
#@-node:ekr.20081121110412.455:newIcon
#@+node:ekr.20081121110412.456:newLine
def newLine (self,p,x1,y1,x2,y2):

    canvas = self.canvas

    if self.freeLines:
        # theId = self.freeLines.pop(0)
        d = self.freeLines ; theId = d.keys()[0] ; del d[theId]
        canvas.coords(theId,x1,y1,x2,y2)
    else:
        theId = canvas.create_line(x1,y1,x2,y2,tag="lines",fill="gray50") # stipple="gray25")
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.h),align=-20)

    if p:
        self.ids[theId] = p

    if theId not in self.visibleLines:
        self.visibleLines.append(theId)

    return theId
#@-node:ekr.20081121110412.456:newLine
#@+node:ekr.20081121110412.457:newText (tkTree) and helper
def newText (self,p,x,y):

    canvas = self.canvas ; tag = "textBox"
    c = self.c ;  k = c.k
    if self.freeText:
        # w,theId = self.freeText.pop()
        d = self.freeText ; data = d.keys()[0] ; w,theId = data ; del d[data]
        canvas.coords(theId,x,y) # Make the window visible again.
            # theId is the id of the *window* not the text.
    else:
        # Tags are not valid in Tk.Text widgets.
        self.textNumber += 1
        w = g.app.gui.plainTextWidget(
            canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
        w.bindtags(self.textBindings) # Set the bindings for this widget.

        if 0: # Crashes on XP.
            << patch by Maciej Kalisiak to handle scroll-wheel events >>

        theId = canvas.create_window(x,y,anchor="nw",window=w,tag=tag)
        w.leo_window_id = theId # Never changes.

        if self.trace_alloc: g.trace('%3d %6s' % (theId,id(w)),align=-20)

    # Common configuration.
    if 0: # Doesn't seem to work.
        balloon = Pmw.Balloon(canvas,initwait=700)
        balloon.tagbind(canvas,theId,balloonHelp='Headline')

    if p:
        self.ids[theId] = p # Add the id of the *window*
        self.setHeadlineText(theId,w,p.h)
        w.configure(width=self.headWidth(p=p))
        w.leo_position = p # This p never changes.
            # *Required*: onHeadlineClick uses w.leo_position to get p.

        # Keys are p.key().  Entries are (w,theId)
        self.visibleText [p.key()] = w,theId
    else:
        g.trace('**** can not happen.  No p')

    return w
#@+node:ekr.20081121110412.458:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
def PropagateButton4(e):
    canvas.event_generate("<Button-4>")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("<Button-5>")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("<MouseWheel>")
    return "break"

instance_tag = w.bindtags()[0]
w.bind_class(instance_tag, "<Button-4>", PropagateButton4)
w.bind_class(instance_tag, "<Button-5>", PropagateButton5)
w.bind_class(instance_tag, "<MouseWheel>",PropagateMouseWheel)
#@-node:ekr.20081121110412.458:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
#@+node:ekr.20081121110412.459:tree.setHeadlineText
def setHeadlineText (self,theId,w,s):

    """All changes to text widgets should come here."""

    # if self.trace_alloc: g.trace('%4d %6s %s' % (theId,self.textAddr(w),s),align=-20)

    state = w.cget("state")
    if state != "normal":
        w.configure(state="normal")
    w.delete(0,"end")
    # Important: do not allow newlines in headlines.
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]
    w.insert("end",s)
    # g.trace(repr(s))
    if state != "normal":
        w.configure(state=state)
#@-node:ekr.20081121110412.459:tree.setHeadlineText
#@-node:ekr.20081121110412.457:newText (tkTree) and helper
#@+node:ekr.20081121110412.460:recycleWidgets
def recycleWidgets (self):

    canvas = self.canvas

    for theId in self.visibleBoxes:
        # if theId not in self.freeBoxes:
            # self.freeBoxes.append(theId)
        self.freeBoxes[theId] = theId
        canvas.coords(theId,-100,-100)
    self.visibleBoxes = []

    for theId in self.visibleClickBoxes:
        # if theId not in self.freeClickBoxes:
            # self.freeClickBoxes.append(theId)
        self.freeClickBoxes[theId] = theId
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleClickBoxes = []

    for theId in self.visibleIcons:
        # if theId not in self.freeIcons:
            # self.freeIcons.append(theId)
        self.freeIcons[theId] = theId
        canvas.coords(theId,-100,-100)
    self.visibleIcons = []

    for theId in self.visibleLines:
        # if theId not in self.freeLines:
            # self.freeLines.append(theId)
        self.freeLines[theId] = theId
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleLines = []

    aList = self.visibleText.values()
    for data in aList:
        w,theId = data
        # assert theId == w.leo_window_id
        canvas.coords(theId,-100,-100)
        w.leo_position = None # Allow the position to be freed.
        # if data not in self.freeText:
            # self.freeText.append(data)
        self.freeText[data] = data
    self.visibleText = {}

    # g.trace('deleting visible user icons!')
    for theId in self.visibleUserIcons:
        # The present code does not recycle user Icons.
        self.canvas.delete(theId)
    self.visibleUserIcons = []
#@-node:ekr.20081121110412.460:recycleWidgets
#@+node:ekr.20081121110412.461:destroyWidgets
def destroyWidgets (self):

    self.ids = {}

    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleUserIcons = []

    self.visibleText = {}

    self.freeText = {}
    self.freeBoxes = {}
    self.freeClickBoxes = {}
    self.freeIcons = {}
    self.freeLines = {}

    self.canvas.delete("all")
#@-node:ekr.20081121110412.461:destroyWidgets
#@+node:ekr.20081121110412.462:showStats
def showStats (self):

    z = []
    for kind,a,b in (
        ('boxes',self.visibleBoxes,self.freeBoxes),
        ('clickBoxes',self.visibleClickBoxes,self.freeClickBoxes),
        ('icons',self.visibleIcons,self.freeIcons),
        ('lines',self.visibleLines,self.freeLines),
        ('tesxt',self.visibleText.values(),self.freeText),
    ):
        z.append('%10s used: %4d free: %4d' % (kind,len(a),len(b)))

    s = '\n' + '\n'.join(z)
    g.es_print('',s)
#@-node:ekr.20081121110412.462:showStats
#@-node:ekr.20081121110412.452:Allocation...
#@+node:ekr.20081121110412.463:Config & Measuring...
#@+node:ekr.20081121110412.464:tree.getFont,setFont,setFontFromConfig
def getFont (self):

    return self.font

def setFont (self,font=None, fontName=None):

    # ESSENTIAL: retain a link to font.
    if fontName:
        self.fontName = fontName
        self.font = tkFont.Font(font=fontName)
    else:
        self.fontName = None
        self.font = font

    self.setLineHeight(self.font)

# Called by ctor and when config params are reloaded.
def setFontFromConfig (self):
    c = self.c
    # g.trace()
    font = c.config.getFontFromParams(
        "headline_text_font_family", "headline_text_font_size",
        "headline_text_font_slant",  "headline_text_font_weight",
        c.config.defaultTreeFontSize)

    self.setFont(font)
#@-node:ekr.20081121110412.464:tree.getFont,setFont,setFontFromConfig
#@+node:ekr.20081121110412.465:headWidth & widthInPixels
def headWidth(self,p=None,s=''):

    """Returns the proper width of the entry widget for the headline."""

    if p: s = p.h

    return self.font.measure(s)/self.font.measure('0')+1


def widthInPixels(self,s):

    s = g.toEncodedString(s,g.app.tkEncoding)

    return self.font.measure(s)
#@-node:ekr.20081121110412.465:headWidth & widthInPixels
#@+node:ekr.20081121110412.466:setLineHeight
def setLineHeight (self,font):

    try:
        metrics = font.metrics()
        linespace = metrics ["linespace"]
        self.line_height = linespace + 5 # Same as before for the default font on Windows.
        # g.pr(metrics)
    except:
        self.line_height = self.default_line_height
        g.es("exception setting outline line height")
        g.es_exception()
#@-node:ekr.20081121110412.466:setLineHeight
#@-node:ekr.20081121110412.463:Config & Measuring...
#@+node:ekr.20081121110412.467:Debugging...
#@+node:ekr.20081121110412.468:textAddr
def textAddr(self,w):

    """Return the address part of repr(Tk.Text)."""

    s = repr(w)
    i = s.find('id: ')
    if i != -1:
        return s[i+4:i+12].lower()
    else:
        return s
#@-node:ekr.20081121110412.468:textAddr
#@+node:ekr.20081121110412.469:traceIds (Not used)
# Verbose tracing is much more useful than this because we can see the recent past.

def traceIds (self,full=False):

    tree = self

    for theDict,tag,flag in ((tree.ids,"ids",True),(tree.iconIds,"icon ids",False)):
        g.pr('=' * 60)
        g.pr("\n%s..." % tag)
        for key in sorted(theDict):
            p = tree.ids.get(key)
            if p is None: # For lines.
                g.pr("%3d None" % key)
            else:
                g.pr("%3d" % key,p.h)
        if flag and full:
            g.pr('-' * 40)
            seenValues = {}
            for key in sorted(theDict):
                value = theDict.get(key)
                if value not in seenValues:
                    seenValues[value]=True
                    for item in theDict.items():
                        key,val = item
                        if val and val == value:
                            g.pr("%3d" % key,val.h)
#@-node:ekr.20081121110412.469:traceIds (Not used)
#@-node:ekr.20081121110412.467:Debugging...
#@+node:ekr.20081121110412.470:Drawing... (tkTree)
#@+node:ekr.20090110073024.10:Entry points (tkTree)
#@+node:ekr.20081121110412.471:tree.begin/endUpdate
def beginUpdate (self):

    self.updateCount += 1
    # g.trace('tree',id(self),self.updateCount,g.callers())

def endUpdate (self,flag,scroll=False):

    self.updateCount -= 1
    # g.trace(self.updateCount,'scroll',scroll,g.callers())

    if self.updateCount <= 0:
        if flag:
            self.redraw_now(scroll=scroll)
        if self.updateCount < 0:
            g.trace("Can't happen: negative updateCount",g.callers())
#@-node:ekr.20081121110412.471:tree.begin/endUpdate
#@+node:ekr.20081121110412.472:tree.redraw_now & helper (tkTree)
# New in 4.4b2: suppress scrolling by default.
# New in 4.6: enable scrolling by default.

def redraw_now (self,p=None,scroll=True,forceDraw=False):

    '''Redraw immediately.
    forceDraw is used to eliminate draws while dragging.'''

    trace = False and not g.unitTesting
    c = self.c

    if g.app.quitting or self.frame not in g.app.windowList:
        return
    if self.drag_p and not forceDraw:
        return

    if p is None:
        p = c.currentPosition()
    else:
        c.setCurrentPosition(p)

    if trace: g.trace(self.redrawCount,g.callers(8))

    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary()
        if self.trace_redraw or self.trace_alloc:
            # g.trace(self.redrawCount,g.callers())
            # g.trace(c.rootPosition().h,'canvas:',id(self.canvas),g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()

    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    if 0: #### A major change.
        self.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            self.endUpdate(False)

    # Do the actual redraw. (c.redraw has called c.expandAllAncestors.)
    if self.idle_redraw:
        def idleRedrawCallback(event=None,self=self,scroll=scroll):
            self.redrawHelper(scroll=scroll,forceDraw=forceDraw)
        self.canvas.after_idle(idleRedrawCallback)
    else:
        self.redrawHelper(scroll=scroll,forceDraw=forceDraw)

    if g.app.unitTesting:
        self.canvas.update_idletasks() # Important for unit tests.

redraw = redraw_now # Compatibility
#@+node:ekr.20081121110412.473:redrawHelper
def redrawHelper (self,scroll=True,forceDraw=False):

    # This can be called at idle time, so there are shutdown issues.
    if g.app.quitting or self.frame not in g.app.windowList:
        return
    if self.drag_p and not forceDraw:
        return
    if not hasattr(self,'c'):
        return

    c = self.c ; trace = False
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):

        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        bbox = self.canvas.bbox('all')
        if trace: g.trace('bbox',bbox,g.callers())
        if bbox is None:
            x0,y0,x1,y1 = 0,0,100,100
        else:
            x0, y0, x1, y1 = bbox
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()

    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@-node:ekr.20081121110412.473:redrawHelper
#@-node:ekr.20081121110412.472:tree.redraw_now & helper (tkTree)
#@+node:ekr.20090110134111.11:redraw_after_contract
def redraw_after_contract (self,p):

    self.redraw_now()
#@-node:ekr.20090110134111.11:redraw_after_contract
#@+node:ekr.20090110073024.11:redraw_after_head_changed
def redraw_after_head_changed (self):

    pass
#@-node:ekr.20090110073024.11:redraw_after_head_changed
#@+node:ekr.20090110073024.13:redraw_after_icons_changed
def redraw_after_icons_changed (self,all=False):

    if g.unitTesting:
        # A terrible hack.  Don't switch edit widget.
        self.redrawCount += 1
    else:
        self.redraw_now()
#@-node:ekr.20090110073024.13:redraw_after_icons_changed
#@+node:ekr.20090110073024.12:redraw_after_select
def redraw_after_select (self,p,edit=False,editAll=False):

    self.redraw_now()
#@-node:ekr.20090110073024.12:redraw_after_select
#@-node:ekr.20090110073024.10:Entry points (tkTree)
#@+node:ekr.20081121110412.474:idle_second_redraw
def idle_second_redraw (self):

    c = self.c

    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)

    if 0:
        self.canvas.delete("all")

    self.drawTopTree()

    if self.trace:
        g.trace(self.redrawCount)
#@-node:ekr.20081121110412.474:idle_second_redraw
#@+node:ekr.20081121110412.475:drawX...
#@+node:ekr.20081121110412.476:drawBox
def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7

    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)

    if theId is None:
        # if self.trace_gc: g.printNewObjects(tag='box 1')
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        # if self.trace_gc: g.printNewObjects(tag='box 2')
        return theId
    else:
        return theId
#@-node:ekr.20081121110412.476:drawBox
#@+node:ekr.20081121110412.477:drawClickBox
def drawClickBox (self,p,y):

    h = self.line_height

    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
#@-node:ekr.20081121110412.477:drawClickBox
#@+node:ekr.20081121110412.478:drawIcon
def drawIcon(self,p,x=None,y=None):

    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    # if self.trace_gc: g.printNewObjects(tag='icon 1')

    c = self.c ; v = p.v
    << compute x,y and iconVal >>
    v.iconVal = val

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)

    return 0,self.icon_width # dummy icon height,width
#@+node:ekr.20081121110412.479:<< compute x,y and iconVal >>
if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.computeIcon()
assert(0 <= val <= 15)
# g.trace(v,val)
#@nonl
#@-node:ekr.20081121110412.479:<< compute x,y and iconVal >>
#@-node:ekr.20081121110412.478:drawIcon
#@+node:ekr.20081121110412.480:drawLine
def drawLine (self,p,x1,y1,x2,y2):

    theId = self.newLine(p,x1,y1,x2,y2)

    return theId
#@-node:ekr.20081121110412.480:drawLine
#@+node:ekr.20081121110412.481:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):

    c = self.c

    # g.trace(x,y,p,id(self.canvas))

    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v,"unknownAttributes"):
            self.lineyoffset = p.v.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0

    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)

    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@+node:ekr.20081121110412.482:force_draw_node
def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.

    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2

    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.h)

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)

    self.drawClickBox(p,y)

    return h,indent
#@-node:ekr.20081121110412.482:force_draw_node
#@-node:ekr.20081121110412.481:drawNode & force_draw_node (good trace)
#@+node:ekr.20081121110412.483:drawText
def drawText(self,p,x,y):

    """draw text for position p at nominal coordinates x,y."""

    assert(p)

    c = self.c
    x += self.text_indent

    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data

    self.newText(p,x,y+self.lineyoffset)

    self.configureTextState(p)

    return self.line_height
#@-node:ekr.20081121110412.483:drawText
#@+node:ekr.20081121110412.484:drawUserIcons & helper
def drawUserIcons(self,p,where,x,y):

    """Draw any icons specified by p.v.unknownAttributes["icons"]."""

    h,w = 0,0

    com = self.c.editCommands
    iconsList = com.getIconList(p)
    if not iconsList:
        return h,w

    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()

    # g.trace(where,h,w)
    return h,w
#@+node:ekr.20081121110412.485:drawUserIcon
def drawUserIcon (self,p,where,x,y,w2,theDict):

    c = self.c ; h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # if self.trace_gc: g.printNewObjects(tag='userIcon 1')

    # g.trace(where,x,y,theDict)

    << set offsets and pads >>
    theType = theDict.get("type")
    if theType == "icon":
        ### not ready yet.
        # s = theDict.get("icon")
        pass
    elif theType == "file":
        theFile = theDict.get("file")
        relPath = theDict.get('relPath')
        << draw the icon at file >>
    elif theType == "url":
        ## url = theDict.get("url")
        << draw the icon at url >>

    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    # if self.trace_gc: g.printNewObjects(tag='userIcon 2')

    return h,w
#@+node:ekr.20081121110412.486:<< set offsets and pads >>
xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@-node:ekr.20081121110412.486:<< set offsets and pads >>
#@+node:ekr.20081121110412.487:<< draw the icon at file >>
if relPath:
    fullname = g.os_path_join(g.app.loadDir,"..","Icons",relPath)
else:
    fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
fullname = g.os_path_normpath(fullname)

# Bug fix: the key must include distinguish nodes.
key = (fullname,p.v)
image = self.iconimages.get(key)

if not image:
    try:
        from PIL import Image, ImageTk
        image1 = Image.open(fullname)
        image = ImageTk.PhotoImage(image1)
        self.iconimages[key] = image
    except Exception:
        #g.es_exception()
        image = None

if not image:
    try:
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[key] = image
    except Exception:
        #g.es_exception()
        image = None

if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image)

    tag='userIcon-%s' % theId
    self.canvas.itemconfigure(theId,tag=(tag,'userIcon')) #BJ
    self.ids[theId] = p.copy()

    def deleteButtonCallback(event=None,c=c,p=p,fullname=fullname,relPath=relPath):
        #g.trace()
        c.editCommands.deleteIconByName(p,fullname,relPath)
        self._block_canvas_menu = True
        return 'break'

    c.tag_bind(self.canvas,tag,'<3>',deleteButtonCallback)

    # assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad
#@-node:ekr.20081121110412.487:<< draw the icon at file >>
#@+node:ekr.20081121110412.488:<< draw the icon at url >>
pass
#@-node:ekr.20081121110412.488:<< draw the icon at url >>
#@-node:ekr.20081121110412.485:drawUserIcon
#@-node:ekr.20081121110412.484:drawUserIcons & helper
#@+node:ekr.20081121110412.489:drawTopTree (tk)
def drawTopTree (self):

    """Draws the top-level tree, taking into account the hoist state."""

    c = self.c ; canvas = self.canvas
    trace = False or self.trace or self.trace_redraw

    self.redrawing = True

    # Recycle all widgets and clear all widget lists.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.redrawCount += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if trace:
        g.trace('redrawCount',self.redrawCount,g.callers(5))
            # 'len(c.hoistStack)',len(c.hoistStack))
        if 0:
            delta = g.app.positions - self.prevPositions
            g.trace("**** gen: %-3d positions: %5d +%4d" % (
                self.generation,g.app.positions,delta),g.callers())

    self.prevPositions = g.app.positions
    if self.trace_gc: g.printNewObjects(tag='top 1')

    hoistFlag = c.hoistStack
    if c.hoistStack:
        bunch = c.hoistStack[-1] ; p = bunch.p
        h = p.h
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            hoistFlag = False
    else:
        p = c.rootPosition()

    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)

    if self.trace_gc: g.printNewObjects(tag='top 2')
    if self.trace_stats: self.showStats()

    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.

    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest. BJ:Not now
    canvas.lift("plusBox")
    canvas.lift("userIcon")
    self.redrawing = False
#@-node:ekr.20081121110412.489:drawTopTree (tk)
#@+node:ekr.20081121110412.490:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y ; h1 = None
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data

    while p: # Do not use iterator.
        # This is the ONLY copy of p that needs to be made;
        # no other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h # Set h1 *after* calling drawNode.
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
    # Draw the vertical line.
    if h1 is None: h1 = h
    y2 = g.choose(level==0,yfirst+(h1-1)/2,yfirst-h1/2-1)
    self.drawLine(None,x,y2,x,ylast+self.hline_y-h)
    return y
#@-node:ekr.20081121110412.490:drawTree
#@-node:ekr.20081121110412.475:drawX...
#@+node:ekr.20081121110412.491:Helpers...
#@+node:ekr.20081121110412.492:getIconImage
def getIconImage (self, name):

    # Return the image from the cache if possible.
    if name in self.iconimages:
        return self.iconimages[name]

    # g.trace(name)

    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("exception loading:",fullname)
        g.es_exception()
        return None
#@-node:ekr.20081121110412.492:getIconImage
#@+node:ekr.20081121110412.493:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):

    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 >= vis1 and y1 <= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.

def inExpandedVisibleArea (self,y1):

    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 >= vis1 and y1 <= vis2
    else:
        return False
#@-node:ekr.20081121110412.493:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20081121110412.494:numberOfVisibleNodes
def numberOfVisibleNodes(self):

    c = self.c

    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext(c)
    return n
#@-node:ekr.20081121110412.494:numberOfVisibleNodes
#@+node:ekr.20081121110412.495:scrollTo
def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""

    # This can be called at idle time, so there are shutdown issues.
    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
    if not hasattr(self,'c'):
        return

    c = self.c ; frame = c.frame ; trace = False
    if not p or not c.positionExists(p):
        p = c.currentPosition()
        if trace: g.trace('*** current position',p,p.stack)
    if not p or not c.positionExists(p):
        if trace: g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not c.positionExists(p):
        if trace: g.trace('no position')
        return
    try:
        if trace: g.trace('***',p,p.stack,'exists',c.positionExists(p))
        h1 = self.yoffset(p)
        if self.center_selected_tree_node: # New in Leo 4.4.3.
            << compute frac0 >>
            delta = abs(self.prevMoveToFrac-frac0)
            if trace: g.trace('delta',delta)
            if delta > 0.0:
                self.prevMoveToFrac = frac0
                self.canvas.yview("moveto",frac0)
                if trace: g.trace("frac0 %1.2f h1 %3d htot %3d wtot %3d" % (
                    frac0,h1,htot,wtot),g.callers())
        else:
            last = c.lastVisible()
            nextToLast = last.visBack(c)
            h2 = self.yoffset(last)
            << compute approximate line height >>
            << Compute the fractions to scroll down/up >>
            if frac <= lo: # frac is for scrolling down.
                if self.prevMoveToFrac != frac:
                    self.prevMoveToFrac = frac
                    self.canvas.yview("moveto",frac)
                    if trace: g.trace("frac  %1.2f h1 %3d h2 %3d lo %1.2f hi %1.2f" % (
                        frac, h1,h2,lo,hi),g.callers())
            elif frac2 + (hi - lo) >= hi: # frac2 is for scrolling up.
                if self.prevMoveToFrac != frac2:
                    self.prevMoveToFrac = frac2
                    self.canvas.yview("moveto",frac2)
                    if trace: g.trace("frac2 %1.2f h1 %3d h2 %3d lo %1.2f hi %1.2f" % (
                        frac2,h1,h2,lo,hi),g.callers())

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)

        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.

    except:
        g.es_exception()

idle_scrollTo = scrollTo # For compatibility.
#@+node:ekr.20081121110412.496:<< compute frac0 >>
# frac0 attempt to put the 
scrollRegion = self.canvas.cget('scrollregion')
geom = self.canvas.winfo_geometry()

if scrollRegion and geom:
    scrollRegion = scrollRegion.split(' ')
    # if trace: g.trace('scrollRegion',repr(scrollRegion))
    htot = int(scrollRegion[3])
    wh,junk,junk = geom.split('+')
    junk,h = wh.split('x')
    if h: wtot = int(h)
    else: wtot = 500
    # if trace: g.trace('geom',geom,'wtot',wtot,'htot',htot)
    if htot > 0.1:
        frac0 = float(h1-wtot/2)/float(htot)
        frac0 = max(min(frac0,1.0),0.0)
    else:
        frac0 = 0.0
else:
    frac0 = 0.0 ; htot = wtot = 0
#@-node:ekr.20081121110412.496:<< compute frac0 >>
#@+node:ekr.20081121110412.497:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@-node:ekr.20081121110412.497:<< compute approximate line height >>
#@+node:ekr.20081121110412.498:<< Compute the fractions to scroll down/up >>
data = frame.canvas.leo_treeBar.get() # Get the previous values of the scrollbar.
try: lo, hi = data
except: lo,hi = 0.0,1.0

# h1 and h2 are the y offsets of the present and last nodes.
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.

frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20081121110412.498:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20081121110412.495:scrollTo
#@+node:ekr.20081121110412.499:yoffset (tkTree)
@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): g.pr("yoffset not visible:",p1)
    if not p1: return 0
    c = self.c
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        root = bunch.p.copy()
    else:
        root = self.c.rootPosition()
    if root:
        h,flag = self.yoffsetTree(root,p1,isTop=True)
        # flag can be False during initialization.
        # if not flag: g.pr("*** yoffset fails:",'root',root,'p1',p1,'returns',h)
        return h
    else:
        return 0

def yoffsetTree(self,p,p1,isTop):
    c = self.c ; h = 0 ; trace = False ; verbose = True
    if trace: g.trace('entry','root',p,p.stack,'target',p1,p1.stack)
    if not c.positionExists(p):
        if trace: g.trace('*** does not exist',p.h)
        return h,False # An extra precaution.
    p = p.copy()
    if trace and verbose and isTop and c.hoistStack:
        g.trace('c.hoistStack',c.hoistStack[-1].p.h)
    if isTop and c.hoistStack:
        if p.firstChild():  theIter = [p.firstChild()]
        else:               theIter = []
    else:
        theIter = p.self_and_siblings()

    for p2 in theIter:
        if trace and p1.h == p2.h:
            g.trace('loop',p1,p2)
            g.trace(p1.stack,p2.stack)
        if p2 == p1:
            if trace and verbose: g.trace('returns',h,p1.h)
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            if trace and verbose: g.trace('recursive call')
            h2, flag = self.yoffsetTree(child,p1,isTop=False)
            h += h2
            if flag:
                if trace and verbose: g.trace('returns',h,p1.h)
                return h, True

    if trace: g.trace('not found',h,p1.h)
    return h, False
#@-node:ekr.20081121110412.499:yoffset (tkTree)
#@-node:ekr.20081121110412.491:Helpers...
#@+node:ekr.20081121110412.500:tree.edraw_after methods (new)
# We now use the definitions in the base leoTree class.

# redraw_after_icons_changed  = redraw
# redraw_after_clone          = redraw
# redraw_after_contract       = redraw
# redraw_after_delete         = redraw
# redraw_after_expand         = redraw
# redraw_after_insert         = redraw
# redraw_after_move_down      = redraw
# redraw_after_move_left      = redraw
# redraw_after_move_right     = redraw
# redraw_after_move_up        = redraw
# redraw_after_select         = redraw
#@-node:ekr.20081121110412.500:tree.edraw_after methods (new)
#@-node:ekr.20081121110412.470:Drawing... (tkTree)
#@+node:ekr.20081121110412.501:Event handlers (tkTree)
#@+node:ekr.20081121110412.502:Helpers
#@+node:ekr.20081121110412.503:checkWidgetList
def checkWidgetList (self,tag):

    return True # This will fail when the headline actually changes!
#@-node:ekr.20081121110412.503:checkWidgetList
#@+node:ekr.20081121110412.504:dumpWidgetList
def dumpWidgetList (self,tag):

    g.pr("\ncheckWidgetList: %s" % tag)

    for w in self.visibleText:

        p = w.leo_position
        if p:
            s = w.getAllText().strip()
            h = p.h.strip()

            addr = self.textAddr(w)
            g.pr("p:",addr,h)
            if h != s:
                g.pr("w:",'*' * len(addr),s)
        else:
            g.pr("w.leo_position == None",w)
#@-node:ekr.20081121110412.504:dumpWidgetList
#@+node:ekr.20081121110412.505:tree.edit_widget
def edit_widget (self,p):

    """Returns the Tk.Edit widget for position p."""

    return self.findEditWidget(p)
#@nonl
#@-node:ekr.20081121110412.505:tree.edit_widget
#@+node:ekr.20081121110412.506:eventToPosition
def eventToPosition (self,event):

    canvas = self.canvas
    x,y = event.x,event.y
    x = canvas.canvasx(x) 
    y = canvas.canvasy(y)
    if self.trace: g.trace(x,y)
    item = canvas.find_overlapping(x,y,x,y)
    if not item: return None

    # Item may be a tuple, possibly empty.
    try:    theId = item[0]
    except: theId = item
    if not theId: return None

    p = self.ids.get(theId)

    # A kludge: p will be None for vertical lines.
    if not p:
        item = canvas.find_overlapping(x+1,y,x+1,y)
        try:    theId = item[0]
        except: theId = item
        if not theId:
            g.es_print('oops:','eventToPosition','failed')
            return None
        p = self.ids.get(theId)
        # g.trace("was vertical line",p)

    if self.trace and self.verbose:
        if p:
            w = self.findEditWidget(p)
            g.trace("%3d %3d %3d %d" % (theId,x,y,id(w)),p.h)
        else:
            g.trace("%3d %3d %3d" % (theId,x,y),None)

    # defensive programming: this copy is not needed.
    if p: return p.copy() # Make _sure_ nobody changes this table!
    else: return None
#@-node:ekr.20081121110412.506:eventToPosition
#@+node:ekr.20081121110412.507:findEditWidget (tkTree)
def findEditWidget (self,p):

    """Return the Tk.Text item corresponding to p."""

    c = self.c ; trace = False

    # if trace: g.trace(g.callers())

    if p and c:
        # if trace: g.trace('h',p.h,'key',p.key())
        aTuple = self.visibleText.get(p.key())
        if aTuple:
            w,theId = aTuple
            # if trace: g.trace('id(p.v):',id(p.v),'%4d' % (theId),self.textAddr(w),p.h)
            return w
        else:
            if trace: g.trace('oops: not found',p,g.callers())
            return None

    if trace: g.trace('not found',p and p.h)
    return None
#@-node:ekr.20081121110412.507:findEditWidget (tkTree)
#@+node:ekr.20081121110412.508:findVnodeWithIconId
def findPositionWithIconId (self,theId):

    # Due to an old bug, theId may be a tuple.
    try:
        data = self.iconIds.get(theId[0])
    except:
        data = self.iconIds.get(theId)

    if data:
        p,generation = data
        if generation==self.generation:
            if self.trace and self.verbose:
                g.trace(theId,p.h)
            return p
        else:
            if self.trace and self.verbose:
                g.trace("*** wrong generation: %d ***" % theId)
            return None
    else:
        if self.trace and self.verbose: g.trace(theId,None)
        return None
#@-node:ekr.20081121110412.508:findVnodeWithIconId
#@-node:ekr.20081121110412.502:Helpers
#@+node:ekr.20081121110412.509:Click Box...
#@+node:ekr.20081121110412.510:onClickBoxClick
def onClickBoxClick (self,event,p=None):

    c = self.c ; p1 = c.currentPosition()

    if not p: p = self.eventToPosition(event)
    if not p: return

    c.setLog()

    if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
        c.endEditing()
        if p == p1 or self.initialClickExpandsOrContractsNode:
            if p.isExpanded(): p.contract()
            else:              p.expand()
        self.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    c.redraw()

    c.outerUpdate()
#@-node:ekr.20081121110412.510:onClickBoxClick
#@+node:ekr.20081121110412.511:onClickBoxRightClick
def onClickBoxRightClick(self, event, p=None):
    #g.trace()
    return 'break'
#@nonl
#@-node:ekr.20081121110412.511:onClickBoxRightClick
#@+node:ekr.20081121110412.512:onPlusBoxRightClick
def onPlusBoxRightClick (self,event,p=None):

    c = self.c

    self._block_canvas_menu = True

    if not p: p = self.eventToPosition(event)
    if not p: return

    self.OnActivateHeadline(p)
    self.endEditLabel()

    g.doHook('rclick-popup',c=c,p=p,event=event,context_menu='plusbox')

    c.outerUpdate()

    return 'break'
#@-node:ekr.20081121110412.512:onPlusBoxRightClick
#@-node:ekr.20081121110412.509:Click Box...
#@+node:ekr.20081121110412.513:Dragging (tkTree)
#@+node:ekr.20081121110412.514:endDrag
def endDrag (self,event):

    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    << set vdrag, childFlag >>
    if self.allow_clone_drags:
        if not self.look_for_control_drag_on_mouse_down:
            self.controlDrag = c.frame.controlKeyIsDown

    redrawFlag = vdrag and vdrag.v != p.v
    if redrawFlag: # Disallow drag to joined node.
        << drag p to vdrag >>
    elif self.trace and self.verbose:
        g.trace("Cancel drag")

    # Reset the old cursor by brute force.
    self.canvas['cursor'] = "arrow"
    self.dragging = False
    self.drag_p = None

    # Must set self.drag_p = None first.
    if redrawFlag:
        c.redraw_now()
    c.recolor_now() # Dragging can affect coloring.

    # g.trace(redrawFlag)
#@+node:ekr.20081121110412.515:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@-node:ekr.20081121110412.515:<< set vdrag, childFlag >>
#@+node:ekr.20081121110412.516:<< drag p to vdrag >>
# g.trace("*** end drag   ***",theId,x,y,p.h,vdrag.h)

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        p = c.dragToNthChildOf(p,vdrag,0)
    else:
        p = c.dragAfter(p,vdrag)
#@-node:ekr.20081121110412.516:<< drag p to vdrag >>
#@-node:ekr.20081121110412.514:endDrag
#@+node:ekr.20081121110412.517:startDrag
# This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event,p=None):

    """The official helper of the onDrag event handler."""

    c = self.c ; canvas = self.canvas

    if not p:
        assert(not self.drag_p)
        x = canvas.canvasx(event.x)
        y = canvas.canvasy(event.y)
        theId = canvas.find_closest(x,y)
        # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if theId is None: return
        try: theId = theId[0]
        except: pass
        p = self.ids.get(theId)
    if not p: return
    c.setLog()
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.h)
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    # g.trace('self.controlDrag',self.controlDrag)
    if self.allow_clone_drags:
        self.controlDrag = c.frame.controlKeyIsDown
        if self.look_for_control_drag_on_mouse_down:
            if self.enable_drag_messages:
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
#@-node:ekr.20081121110412.517:startDrag
#@+node:ekr.20081121110412.518:onContinueDrag
def onContinueDrag(self,event):

    c = self.c ; p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            << scroll the canvas as needed >>
    except:
        g.es_event_exception("continue drag")
#@+node:ekr.20081121110412.519:<< scroll the canvas as needed >>
# Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y < 0 or y > h:
    lo, hi = frame.canvas.leo_treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y < 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    canvas.yview("moveto", frac)

    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.canvas.leo_treeBar.get()
    if (y < 0 and lo > 0.1) or (y > h and hi < 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
#@-node:ekr.20081121110412.519:<< scroll the canvas as needed >>
#@-node:ekr.20081121110412.518:onContinueDrag
#@+node:ekr.20081121110412.520:onDrag
def onDrag(self,event):

    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()

    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)

    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
#@-node:ekr.20081121110412.520:onDrag
#@+node:ekr.20081121110412.521:onEndDrag
def onEndDrag(self,event):

    """Tree end-of-drag handler called from vnode event handler."""

    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()

    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
#@-node:ekr.20081121110412.521:onEndDrag
#@-node:ekr.20081121110412.513:Dragging (tkTree)
#@+node:ekr.20081121110412.522:Icon Box...
#@+node:ekr.20081121110412.523:onIconBoxClick
def onIconBoxClick (self,event,p=None):

    c = self.c ; tree = self

    if not p: p = self.eventToPosition(event)
    if not p:
        return

    c.setLog()

    if self.trace and self.verbose: g.trace()

    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel()
        tree.select(p,scroll=False)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)

    return "break" # disable expanded box handling.
#@-node:ekr.20081121110412.523:onIconBoxClick
#@+node:ekr.20081121110412.524:onIconBoxRightClick
def onIconBoxRightClick (self,event,p=None):

    """Handle a right click in any outline widget."""

    #g.trace()

    c = self.c

    if not p: p = self.eventToPosition(event)
    if not p:
        c.outerUpdate()
        return

    c.setLog()

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            if not g.doHook('rclick-popup', c=c, p=p, event=event, context_menu='iconbox'):
                self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")

    self._block_canvas_menu = True

    c.outerUpdate()
    return 'break'
#@-node:ekr.20081121110412.524:onIconBoxRightClick
#@+node:ekr.20081121110412.525:onIconBoxDoubleClick
def onIconBoxDoubleClick (self,event,p=None):

    c = self.c

    if not p: p = self.eventToPosition(event)
    if not p:
        c.outerUpdate()
        return

    c.setLog()

    if self.trace and self.verbose: g.trace()

    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")

    c.outerUpdate()
    return 'break'
#@-node:ekr.20081121110412.525:onIconBoxDoubleClick
#@-node:ekr.20081121110412.522:Icon Box...
#@+node:ekr.20081121110412.526:OnActivateHeadline (tkTree)
def OnActivateHeadline (self,p,event=None):

    '''Handle common process when any part of a headline is clicked.'''

    # g.trace(p.h)

    returnVal = 'break' # Default: do nothing more.
    trace = False

    try:
        c = self.c
        c.setLog()
        << activate this window >>
    except:
        g.es_event_exception("activate tree")

    return returnVal
#@+node:ekr.20081121110412.527:<< activate this window >>
if p == c.currentPosition():

    if trace: g.trace('current','active',self.active)
    self.editLabel(p) # sets focus.
    # If we are active, pass the event along so the click gets handled.
    # Otherwise, do *not* pass the event along so the focus stays the same.
    returnVal = g.choose(self.active,'continue','break')
    self.active = True
else:
    if trace: g.trace("not current")
    self.select(p)
    w  = c.frame.body.bodyCtrl
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.insertSpot != None:
        spot = p.v.insertSpot
        w.setInsertPoint(spot)
        w.see(spot)
    else:
        w.setInsertPoint(0)
    # An important detail.
    # The *canvas* (not the headline) gets the focus so that
    # tree bindings take priority over text bindings.
    c.treeWantsFocusNow() # Now. New in Leo 4.5.
    c.outerUpdate()
    self.active = False
    returnVal = 'break'
#@nonl
#@-node:ekr.20081121110412.527:<< activate this window >>
#@-node:ekr.20081121110412.526:OnActivateHeadline (tkTree)
#@+node:ekr.20081121110412.528:Text Box...
#@+node:ekr.20081121110412.529:configureTextState
def configureTextState (self,p):

    c = self.c

    if not p: return

    # g.trace(c.isCurrentPosition(p),self.c._currentPosition,p)

    if c.isCurrentPosition(p):
        if p == self.editPosition():
            self.setEditLabelState(p) # selected, editing.
        else:
            self.setSelectedLabelState(p) # selected, not editing.
    else:
        self.setUnselectedLabelState(p) # unselected
#@-node:ekr.20081121110412.529:configureTextState
#@+node:ekr.20081121110412.530:onCtontrolT
# This works around an apparent Tk bug.

def onControlT (self,event=None):

    # If we don't inhibit further processing the Tx.Text widget switches characters!
    return "break"
#@-node:ekr.20081121110412.530:onCtontrolT
#@+node:ekr.20081121110412.531:onHeadlineClick
def onHeadlineClick (self,event,p=None):

    # g.trace('p',p)
    c = self.c ; w = event.widget

    if not p:
        try:
            p = w.leo_position
        except AttributeError:
            g.trace('*'*20,'oops')
    if not p: return 'break'

    # g.trace(g.app.gui.widget_name(w),p and p.h)

    c.setLog()

    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            returnVal = self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        returnVal = 'break'
        g.es_event_exception("headclick")

    # 'continue' is sometimes correct here.
    # 'break' would make it impossible to unselect the headline text.
    # g.trace('returnVal',returnVal,'stayInTree',self.stayInTree)
    return returnVal
#@-node:ekr.20081121110412.531:onHeadlineClick
#@+node:ekr.20081121110412.532:onHeadlineRightClick
def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget

    try:
        p = w.leo_position
    except AttributeError:
        g.trace('*'*20,'oops')
        return 'break'

    c.setLog()

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            if not g.doHook('rclick-popup', c=c, p=p, event=event, context_menu='headline'):
                self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")

    # 'continue' *is* correct here.
    # 'break' would make it impossible to unselect the headline text.

    return 'continue'
#@-node:ekr.20081121110412.532:onHeadlineRightClick
#@-node:ekr.20081121110412.528:Text Box...
#@+node:ekr.20081121110412.533:tree.OnDeactivate
def OnDeactivate (self,event=None):

    """Deactivate the tree pane, dimming any headline being edited."""

    tree = self ; c = self.c

    tree.endEditLabel()
    tree.dimEditLabel()
    c.outerUpdate()
#@-node:ekr.20081121110412.533:tree.OnDeactivate
#@+node:ekr.20081121110412.534:tree.OnPopup & allies
def OnPopup (self,p,event):

    """Handle right-clicks in the outline.

    This is *not* an event handler: it is called from other event handlers."""

    # Note: "headrclick" hooks handled by vnode callback routine.

    if event != None:
        c = self.c
        c.setLog()

        if not g.doHook("create-popup-menu",c=c,p=p,v=p,event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items",c=c,p=p,v=p,event=event):
            self.enablePopupMenuItems(p,event)
        if not g.doHook("show-popup-menu",c=c,p=p,v=p,event=event):
            self.showPopupMenu(event)

    return "break"
#@+node:ekr.20081121110412.535:OnPopupFocusLost
@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the <FocusOut> event and explicitly unpost.  In order to process the <FocusOut> event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):

    self.popupMenu.unpost()
#@-node:ekr.20081121110412.535:OnPopupFocusLost
#@+node:ekr.20081121110412.536:createPopupMenu
def createPopupMenu (self,event):

    c = self.c ; frame = c.frame


    self.popupMenu = menu = Tk.Menu(g.app.root, tearoff=0)

    # Add the Open With entries if they exist.
    if g.app.openWithTable:
        frame.menu.createOpenWithMenuItemsFromTable(menu,g.app.openWithTable)
        table = (("-",None,None),)
        frame.menu.createMenuEntries(menu,table)

    << Create the menu table >>

    # New in 4.4.  There is no need for a dontBind argument because
    # Bindings from tables are ignored.
    frame.menu.createMenuEntries(menu,table)
#@+node:ekr.20081121110412.537:<< Create the menu table >>
table = (
    ("&Read @file Nodes",c.readAtFileNodes),
    ("&Write @file Nodes",c.fileCommands.writeAtFileNodes),
    ("-",None),
    ("&Tangle",c.tangle),
    ("&Untangle",c.untangle),
    ("-",None),
    ("Toggle Angle &Brackets",c.toggleAngleBrackets),
    ("-",None),
    ("Cut Node",c.cutOutline),
    ("Copy Node",c.copyOutline),
    ("&Paste Node",c.pasteOutline),
    ("&Delete Node",c.deleteOutline),
    ("-",None),
    ("&Insert Node",c.insertHeadline),
    ("&Clone Node",c.clone),
    ("Sort C&hildren",c.sortChildren),
    ("&Sort Siblings",c.sortSiblings),
    ("-",None),
    ("Contract Parent",c.contractParent),
)
#@-node:ekr.20081121110412.537:<< Create the menu table >>
#@-node:ekr.20081121110412.536:createPopupMenu
#@+node:ekr.20081121110412.538:enablePopupMenuItems
def enablePopupMenuItems (self,v,event):

    """Enable and disable items in the popup menu."""

    c = self.c ; menu = self.popupMenu

    << set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
    isAtFile = g.choose(isAtFile,1,0)
    isAtRoot = g.choose(isAtRoot,1,0)
    canContract = v.parent() != None
    canContract = g.choose(canContract,1,0)

    enable = self.frame.menu.enableMenu

    for name in ("Read @file Nodes", "Write @file Nodes"):
        enable(menu,name,isAtFile)
    for name in ("Tangle", "Untangle"):
        enable(menu,name,isAtRoot)

    enable(menu,"Cut Node",c.canCutOutline())
    enable(menu,"Delete Node",c.canDeleteHeadline())
    enable(menu,"Paste Node",c.canPasteOutline())
    enable(menu,"Sort Children",c.canSortChildren())
    enable(menu,"Sort Siblings",c.canSortSiblings())
    enable(menu,"Contract Parent",c.canContractParent())
#@+node:ekr.20081121110412.539:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
isAtFile = False
isAtRoot = False

for v2 in v.self_and_subtree():
    if isAtFile and isAtRoot:
        break
    if (v2.isAtFileNode() or
        v2.isAtNorefFileNode() or
        v2.isAtAsisFileNode() or
        v2.isAtNoSentFileNode()
    ):
        isAtFile = True

    isRoot,junk = g.is_special(v2.bodyString(),0,"@root")
    if isRoot:
        isAtRoot = True
#@-node:ekr.20081121110412.539:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
#@-node:ekr.20081121110412.538:enablePopupMenuItems
#@+node:ekr.20081121110412.540:showPopupMenu
def showPopupMenu (self,event):

    """Show a popup menu."""

    c = self.c ; menu = self.popupMenu

    g.app.gui.postPopupMenu(c, menu, event.x_root, event.y_root)

    self.popupMenu = None

    # Set the focus immediately so we know when we lose it.
    #c.widgetWantsFocus(menu)
#@-node:ekr.20081121110412.540:showPopupMenu
#@-node:ekr.20081121110412.534:tree.OnPopup & allies
#@+node:ekr.20081121110412.541:onTreeClick
def onTreeClick (self,event=None):

    '''Handle an event in the tree canvas, outside of any tree widget.'''

    c = self.c

    # New in Leo 4.4.2: a kludge: disable later event handling after a double-click.
    # This allows focus to stick in newly-opened files opened by double-clicking an @url node.
    if c.doubleClickFlag:
        c.doubleClickFlag = False
    else:
        c.treeWantsFocusNow()

    g.app.gui.killPopupMenu()
    c.outerUpdate()

    return 'break'
#@-node:ekr.20081121110412.541:onTreeClick
#@+node:ekr.20081121110412.542:onTreeRightClick
def onTreeRightClick (self,event=None):

    c = self.c

    if not c.exists: return

    if self._block_canvas_menu:
        self._block_canvas_menu = False
        return 'break'

    g.doHook('rclick-popup',c=c,event=event,context_menu='canvas')

    c.outerUpdate()
    return 'break'
#@-node:ekr.20081121110412.542:onTreeRightClick
#@-node:ekr.20081121110412.501:Event handlers (tkTree)
#@+node:ekr.20081121110412.543:Incremental drawing...
#@+node:ekr.20081121110412.544:allocateNodes
def allocateNodes(self,where,lines):

    """Allocate Tk widgets in nodes that will become visible as the result of an upcoming scroll"""

    assert(where in ("above","below"))

    # g.pr("allocateNodes: %d lines %s visible area" % (lines,where))

    # Expand the visible area: a little extra delta is safer.
    delta = lines * (self.line_height + 4)
    y1,y2 = self.visibleArea

    if where == "below":
        y2 += delta
    else:
        y1 = max(0.0,y1-delta)

    self.expandedVisibleArea=y1,y2
    # g.pr("expandedArea:   %5.1f %5.1f" % (y1,y2))

    # Allocate all nodes in expanded visible area.
    self.updatedNodeCount = 0
    self.updateTree(self.c.rootPosition(),self.root_left,self.root_top,0,0)
    # if self.updatedNodeCount: g.pr("updatedNodeCount:", self.updatedNodeCount)
#@-node:ekr.20081121110412.544:allocateNodes
#@+node:ekr.20081121110412.545:allocateNodesBeforeScrolling
def allocateNodesBeforeScrolling (self, args):

    """Calculate the nodes that will become visible as the result of an upcoming scroll.

    args is the tuple passed to the Tk.Canvas.yview method"""

    if not self.allocateOnlyVisibleNodes: return

    # g.pr("allocateNodesBeforeScrolling:",self.redrawCount,args)

    assert(self.visibleArea)
    assert(len(args)==2 or len(args)==3)
    kind = args[0] ; n = args[1]
    lines = 2 # Update by 2 lines to account for rounding.
    if len(args) == 2:
        assert(kind=="moveto")
        frac1,frac2 = args
        if float(n) != frac1:
            where = g.choose(n<frac1,"above","below")
            self.allocateNodes(where=where,lines=lines)
    else:
        assert(kind=="scroll")
        linesPerPage = self.canvas.winfo_height()/self.line_height + 2
        n = int(n) ; assert(abs(n)==1)
        where = g.choose(n == 1,"below","above")
        lines = g.choose(args[2] == "pages",linesPerPage,lines)
        self.allocateNodes(where=where,lines=lines)
#@-node:ekr.20081121110412.545:allocateNodesBeforeScrolling
#@+node:ekr.20081121110412.546:updateNode
def updateNode (self,p,x,y):

    """Draw a node that may have become visible as a result of a scrolling operation"""

    c = self.c

    if self.inExpandedVisibleArea(y):
        # This check is a major optimization.
        if not c.edit_widget(p):
            return self.force_draw_node(p,x,y)
        else:
            return self.line_height

    return self.line_height
#@-node:ekr.20081121110412.546:updateNode
#@+node:ekr.20081121110412.547:setVisibleAreaToFullCanvas
def setVisibleAreaToFullCanvas(self):

    if self.visibleArea:
        y1,y2 = self.visibleArea
        y2 = max(y2,y1 + self.canvas.winfo_height())
        self.visibleArea = y1,y2
#@-node:ekr.20081121110412.547:setVisibleAreaToFullCanvas
#@+node:ekr.20081121110412.548:setVisibleArea
def setVisibleArea (self,args):

    r1,r2 = args
    r1,r2 = float(r1),float(r2)
    # g.pr("scroll ratios:",r1,r2)

    try:
        s = self.canvas.cget("scrollregion")
        x1,y1,x2,y2 = g.scanf(s,"%d %d %d %d")
        x1,y1,x2,y2 = int(x1),int(y1),int(x2),int(y2)
    except:
        self.visibleArea = None
        return

    scroll_h = y2-y1
    # g.pr("height of scrollregion:", scroll_h)

    vy1 = y1 + (scroll_h*r1)
    vy2 = y1 + (scroll_h*r2)
    self.visibleArea = vy1,vy2
    # g.pr("setVisibleArea: %5.1f %5.1f" % (vy1,vy2))
#@-node:ekr.20081121110412.548:setVisibleArea
#@+node:ekr.20081121110412.549:tree.updateTree
def updateTree (self,v,x,y,h,level):

    yfirst = y
    if level==0: yfirst += 10
    while v:
        # g.trace(x,y,v)
        h,indent = self.updateNode(v,x,y)
        y += h
        if v.isExpanded() and v.firstChild():
            y = self.updateTree(v.firstChild(),x+indent,y,h,level+1)
        v = v.next()
    return y
#@-node:ekr.20081121110412.549:tree.updateTree
#@-node:ekr.20081121110412.543:Incremental drawing...
#@+node:ekr.20081121110412.550:Selecting & editing... (tkTree)
#@+node:ekr.20081121110412.551:dimEditLabel, undimEditLabel
# Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)
#@-node:ekr.20081121110412.551:dimEditLabel, undimEditLabel
#@+node:ekr.20081121110412.552:tree.editLabel (tkTree)
def editLabel (self,p,selectAll=False,selection=None):

    """Start editing p's headline."""

    trace = (False or self.trace_edit) and g.unitTesting
    c = self.c

    if p and p != self.editPosition():

        self.endEditLabel()
        # This redraw was formerly needed so that c.edit_widget(p)
        # would exist.  However, Leo's core now guarantees a redraw
        # before each call to c.editPosition.
        if 0:
            c.redraw()
            c.outerUpdate()

    self.setEditPosition(p) # That is, self._editPosition = p
    w = c.edit_widget(p)

    if p and w:
        if trace: g.trace('w',w,p)
        self.revertHeadline = p.h # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll,selection=selection)
            # Sets the focus immediately.
        c.widgetWantsFocus(w)
        c.k.showStateAndMode(w)
    else:
        if trace: g.trace('*** Error: no edit widget for %s' % p)
#@nonl
#@-node:ekr.20081121110412.552:tree.editLabel (tkTree)
#@+node:ekr.20081121110412.553:tree.set...LabelState
#@+node:ekr.20081121110412.554:setEditLabelState
def setEditLabelState (self,p,selectAll=False,selection=None): # selected, editing

    c = self.c ; w = c.edit_widget(p)

    if p and w:
        c.widgetWantsFocusNow(w)
        self.setEditHeadlineColors(p)
        selectAll = selectAll or self.select_all_text_when_editing_headlines
        if selection:
            i,j,ins = selection
            w.setSelectionRange(i,j,insert=ins)
        elif selectAll:
            w.setSelectionRange(0,'end',insert='end')
        else:
            w.setInsertPoint('end') # Clears insert point.
    else:
        g.trace('no edit_widget')

setNormalLabelState = setEditLabelState # For compatibility.
#@-node:ekr.20081121110412.554:setEditLabelState
#@+node:ekr.20081121110412.555:setSelectedLabelState
trace_n = 0

def setSelectedLabelState (self,p): # selected, disabled

    c = self.c

    # g.trace(p,c.edit_widget(p))


    if p and c.edit_widget(p):

        if 0:
            g.trace(self.trace_n,c.edit_widget(p),p)
            # g.trace(g.callers(6))
            self.trace_n += 1

        self.setDisabledHeadlineColors(p)
#@-node:ekr.20081121110412.555:setSelectedLabelState
#@+node:ekr.20081121110412.556:setUnselectedLabelState
def setUnselectedLabelState (self,p): # not selected.

    c = self.c

    if p and c.edit_widget(p):
        self.setUnselectedHeadlineColors(p)
#@-node:ekr.20081121110412.556:setUnselectedLabelState
#@+node:ekr.20081121110412.557:setDisabledHeadlineColors
def setDisabledHeadlineColors (self,p):

    c = self.c ; w = c.edit_widget(p)

    if False or (self.trace and self.verbose):
        g.trace("%10s %d %s" % ("disabled",id(w),p.h))
        # import traceback ; traceback.print_stack(limit=6)

    fg = self.headline_text_selected_foreground_color or 'black'
    bg = self.headline_text_selected_background_color or 'grey80'
    selfg = self.headline_text_editing_selection_foreground_color
    selbg = self.headline_text_editing_selection_background_color

    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()
#@-node:ekr.20081121110412.557:setDisabledHeadlineColors
#@+node:ekr.20081121110412.558:setEditHeadlineColors
def setEditHeadlineColors (self,p):

    c = self.c ; w = c.edit_widget(p)

    if self.trace and self.verbose:
        if not self.redrawing:
            g.pr("%10s %d %s" % ("edit",id(2),p.h))

    fg    = self.headline_text_editing_foreground_color or 'black'
    bg    = self.headline_text_editing_background_color or 'white'
    selfg = self.headline_text_editing_selection_foreground_color or 'white'
    selbg = self.headline_text_editing_selection_background_color or 'black'

    try: # Use system defaults for selection foreground/background
        w.configure(state="normal",highlightthickness=1,
        fg=fg,bg=bg,selectforeground=selfg,selectbackground=selbg)
    except:
        g.es_exception()
#@-node:ekr.20081121110412.558:setEditHeadlineColors
#@+node:ekr.20081121110412.559:setUnselectedHeadlineColors
def setUnselectedHeadlineColors (self,p):

    c = self.c ; w = c.edit_widget(p)

    if self.trace and self.verbose:
        if not self.redrawing:
            g.pr("%10s %d %s" % ("unselect",id(w),p.h))
            # import traceback ; traceback.print_stack(limit=6)

    fg = self.headline_text_unselected_foreground_color or 'black'
    bg = self.headline_text_unselected_background_color or 'white'

    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()
#@-node:ekr.20081121110412.559:setUnselectedHeadlineColors
#@-node:ekr.20081121110412.553:tree.set...LabelState
#@+node:ekr.20081121110412.560:tree.setHeadline (tkTree)
def setHeadline (self,p,s):

    '''Set the actual text of the headline widget.

    This is called from unit tests to restore the text before redrawing.'''

    w = self.edit_widget(p)
    if w:
        w.configure(state='normal')
        w.delete(0,'end')
        if s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        w.insert(0,s)
        self.revertHeadline = s

    # else: g.trace('-'*20,'oops')
#@-node:ekr.20081121110412.560:tree.setHeadline (tkTree)
#@-node:ekr.20081121110412.550:Selecting & editing... (tkTree)
#@-node:ekr.20081121110412.435:class leoTkinterTree
#@+node:ekr.20081121105001.536:onTextChanged (qtText)
def onTextChanged (self):

    '''Update Leo after the body has been changed.

    self.selecting is guaranteed to be True during
    the entire selection process.'''

    # Important: usually w.changingText is True.
    # This method very seldom does anything.
    trace = False and not g.unitTesting
    verbose = True
    c = self.c ; p = c.p
    tree = c.frame.tree ; w = self

    if w.changingText: 
        if trace and verbose: g.trace('already changing')
        return
    if tree.tree_select_lockout:
        if trace and verbose: g.trace('selecting lockout')
        return
    if tree.selecting:
        if trace and verbose: g.trace('selecting')
        return
    if tree.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if not p:
        return g.trace('*** no p')

    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText() # Converts to unicode.

    # Get the previous values from the vnode.
    oldText = g.app.gui.toUnicode(p.v._bodyString)
    if oldText == newText:
        # This can happen as the result of undo.
        # g.trace('*** unexpected non-change',color="red")
        return

    # g.trace('**',len(newText),p.h,'\n',g.callers(8))

    oldIns  = p.v.insertSpot
    i,j = p.v.selectionStart,p.v.selectionLength
    oldSel  = (i,i+j)
    if trace: g.trace('oldSel',oldSel,'newSel',newSel)
    oldYview = None
    undoType = 'Typing'
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,
        oldSel=oldSel,newSel=newSel,oldYview=oldYview)

    # Update the vnode.
    p.v.setBodyString(newText)
    if True:
        p.v.insertSpot = newInsert
        i,j = newSel
        i,j = self.toGuiIndex(i),self.toGuiIndex(j)
        if i > j: i,j = j,i
        p.v.selectionStart,p.v.selectionLength = (i,j-i)

    # No need to redraw the screen.
    if not self.useScintilla:
        c.recolor()

    if g.app.qt_use_tabs:
        if trace: g.trace(c.frame.top)

    if not c.changed and c.frame.initComplete:
        c.setChanged(True)

    c.frame.body.updateEditors()
    c.frame.tree.updateIcon(p)

    if 1: # This works, and is probably better.
        # Set a hook for the old jEdit colorer.
        colorer = c.frame.body.colorizer.highlighter.colorer
        colorer.initFlag = True
    else:
        # Allow incremental recoloring.
        c.incrementalRecolorFlag = True
        c.outerUpdate()
#@-node:ekr.20081121105001.536:onTextChanged (qtText)
#@-node:ekr.20091221161510.3679:Undo bugs
#@+node:ekr.20091228111211.3647:Correct binding of insert key
@nocolor-node

Insert key is equivalent to enter key. It's obvious why it behaves like this
(when looking at event filter code, it's mapped to enter).

It should either do nothing, or do something useful (e.g. ctrl+I)

BTW, Numpad enter should be mapped to Return too. alt+ g + number + numpad enter
doesn't work otherwise.
#@+node:ekr.20081121105001.536:onTextChanged (qtText)
def onTextChanged (self):

    '''Update Leo after the body has been changed.

    self.selecting is guaranteed to be True during
    the entire selection process.'''

    # Important: usually w.changingText is True.
    # This method very seldom does anything.
    trace = False and not g.unitTesting
    verbose = True
    c = self.c ; p = c.p
    tree = c.frame.tree ; w = self

    if w.changingText: 
        if trace and verbose: g.trace('already changing')
        return
    if tree.tree_select_lockout:
        if trace and verbose: g.trace('selecting lockout')
        return
    if tree.selecting:
        if trace and verbose: g.trace('selecting')
        return
    if tree.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if not p:
        return g.trace('*** no p')

    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText() # Converts to unicode.

    # Get the previous values from the vnode.
    oldText = g.app.gui.toUnicode(p.v._bodyString)
    if oldText == newText:
        # This can happen as the result of undo.
        # g.trace('*** unexpected non-change',color="red")
        return

    # g.trace('**',len(newText),p.h,'\n',g.callers(8))

    oldIns  = p.v.insertSpot
    i,j = p.v.selectionStart,p.v.selectionLength
    oldSel  = (i,i+j)
    if trace: g.trace('oldSel',oldSel,'newSel',newSel)
    oldYview = None
    undoType = 'Typing'
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,
        oldSel=oldSel,newSel=newSel,oldYview=oldYview)

    # Update the vnode.
    p.v.setBodyString(newText)
    if True:
        p.v.insertSpot = newInsert
        i,j = newSel
        i,j = self.toGuiIndex(i),self.toGuiIndex(j)
        if i > j: i,j = j,i
        p.v.selectionStart,p.v.selectionLength = (i,j-i)

    # No need to redraw the screen.
    if not self.useScintilla:
        c.recolor()

    if g.app.qt_use_tabs:
        if trace: g.trace(c.frame.top)

    if not c.changed and c.frame.initComplete:
        c.setChanged(True)

    c.frame.body.updateEditors()
    c.frame.tree.updateIcon(p)

    if 1: # This works, and is probably better.
        # Set a hook for the old jEdit colorer.
        colorer = c.frame.body.colorizer.highlighter.colorer
        colorer.initFlag = True
    else:
        # Allow incremental recoloring.
        c.incrementalRecolorFlag = True
        c.outerUpdate()
#@-node:ekr.20081121105001.536:onTextChanged (qtText)
#@+node:ekr.20081121105001.166:class leoQtEventFilter
class leoQtEventFilter(QtCore.QObject):

    << about internal bindings >>

    @others
#@+node:ekr.20081121105001.167:<< about internal bindings >>
@nocolor-node
@

Here are the rules for translating key bindings (in leoSettings.leo) into keys for k.bindingsDict:

1.  The case of plain letters is significant:  a is not A.

2. The Shift- prefix can be applied *only* to letters. Leo will ignore (with a
warning) the shift prefix applied to any other binding, e.g., Ctrl-Shift-(

3. The case of letters prefixed by Ctrl-, Alt-, Key- or Shift- is *not*
significant. Thus, the Shift- prefix is required if you want an upper-case
letter (with the exception of 'bare' uppercase letters.)

The following table illustrates these rules. In each row, the first entry is the
key (for k.bindingsDict) and the other entries are equivalents that the user may
specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
!, Key-!,Key-exclam,exclam

This table is consistent with how Leo already works (because it is consistent
with Tk's key-event specifiers). It is also, I think, the least confusing set of
rules.
#@nonl
#@-node:ekr.20081121105001.167:<< about internal bindings >>
#@+node:ekr.20081121105001.180: ctor
def __init__(self,c,w,tag=''):

    # g.trace('leoQtEventFilter',tag,w)

    # Init the base class.
    QtCore.QObject.__init__(self)

    self.c = c
    self.w = w      # A leoQtX object, *not* a Qt object.
    self.tag = tag

    # Debugging.
    self.keyIsActive = False

    # Pretend there is a binding for these characters.
    close_flashers = c.config.getString('close_flash_brackets') or ''
    open_flashers  = c.config.getString('open_flash_brackets') or ''
    self.flashers = open_flashers + close_flashers


#@-node:ekr.20081121105001.180: ctor
#@+node:ekr.20090407101640.10:char2tkName
char2tkNameDict = {
    # Part 1: same as k.guiBindNamesDict
    "&" : "ampersand",
    "^" : "asciicircum",
    "~" : "asciitilde",
    "*" : "asterisk",
    "@" : "at",
    "\\": "backslash",
    "|" : "bar",
    "{" : "braceleft",
    "}" : "braceright",
    "[" : "bracketleft",
    "]" : "bracketright",
    ":" : "colon",  
    "," : "comma",
    "$" : "dollar",
    "=" : "equal",
    "!" : "exclam",
    ">" : "greater",
    "<" : "less",
    "-" : "minus",
    "#" : "numbersign",
    '"' : "quotedbl",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright", 
    "%" : "percent",
    "." : "period",     
    "+" : "plus",
    "?" : "question",
    "`" : "quoteleft",
    ";" : "semicolon",
    "/" : "slash",
    " " : "space",      
    "_" : "underscore",
    # Part 2: special Qt translations.
    'Backspace':'BackSpace',
    'Backtab':  'Tab', # The shift mod will convert to 'Shift+Tab',
    'Esc':      'Escape',
    'Del':      'Delete',
    'Ins':      'Insert', # was 'Return',
    # Comment these out to pass the key to the QTextWidget.
    # Use these to enable Leo's page-up/down commands.
    'PgDown':    'Next',
    'PgUp':      'Prior',
    # New entries.  These simplify code.
    'Down':'Down','Left':'Left','Right':'Right','Up':'Up',
    'End':'End',
    'F1':'F1','F2':'F2','F3':'F3','F4':'F4','F5':'F5',
    'F6':'F6','F7':'F7','F8':'F8','F9':'F9',
    'F10':'F10','F11':'F11','F12':'F12',
    'Home':'Home',
    # 'Insert':'Insert',
    'Return':'Return',
    # 'Tab':'Tab',
    'Tab':'\t', # A hack for QLineEdit.
    # Unused: Break, Caps_Lock,Linefeed,Num_lock
}

def char2tkName (self,ch):
    val = self.char2tkNameDict.get(ch)
    # g.trace(repr(ch),repr(val))
    return val
#@-node:ekr.20090407101640.10:char2tkName
#@+node:ekr.20081121105001.168:eventFilter
def eventFilter(self, obj, event):

    trace = True and not g.unitTesting
    verbose = True
    traceEvent = False
    traceKey = True
    traceFocus = False
    c = self.c ; k = c.k
    eventType = event.type()
    ev = QtCore.QEvent
    gui = g.app.gui
    aList = []

    kinds = [ev.ShortcutOverride,ev.KeyPress,ev.KeyRelease]

    if trace and traceFocus: self.traceFocus(eventType,obj)

    # A hack. QLineEdit generates ev.KeyRelease only.
    if eventType in (ev.KeyPress,ev.KeyRelease):
        p = c.currentPosition()
        isEditWidget = obj == c.frame.tree.edit_widget(p)
        self.keyIsActive = g.choose(
            isEditWidget,
            eventType == ev.KeyRelease,
            eventType == ev.KeyPress)
    else:
        self.keyIsActive = False

    if eventType == ev.WindowActivate:
        gui.onActivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType == ev.WindowDeactivate:
        gui.onDeactivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType in kinds:
        tkKey,ch,ignore = self.toTkKey(event)
        aList = c.k.masterGuiBindingsDict.get('<%s>' %tkKey,[])
        if ignore:
            override = False
        #### This is extremely bad.  At present, it is needed to handle tab properly.
        elif self.isSpecialOverride(tkKey,ch):
            override = True
        elif k.inState():
            override = not ignore # allow all keystrokes.
        else:
            override = len(aList) > 0
        g.trace(tkKey,len(aList),'ignore',ignore,'override',override)
    else:
        override = False ; tkKey = '<no key>'
        if self.tag == 'body':
            if eventType == ev.FocusIn:
                c.frame.body.onFocusIn(obj)
            elif eventType == ev.FocusOut:
                c.frame.body.onFocusOut(obj)

    if self.keyIsActive:
        stroke = self.toStroke(tkKey,ch)
        if override:
            if trace and traceKey and not ignore:
                g.trace('bound',repr(stroke)) # repr(aList))
            w = self.w # Pass the wrapper class, not the wrapped widget.
            leoEvent = leoKeyEvent(event,c,w,ch,tkKey,stroke)
            ret = k.masterKeyHandler(leoEvent,stroke=stroke)
            c.outerUpdate()
        else:
            if trace and traceKey and verbose:
                g.trace(self.tag,'unbound',tkKey,stroke)

    if trace and traceEvent: self.traceEvent(obj,event,tkKey,override)

    return override
#@-node:ekr.20081121105001.168:eventFilter
#@+node:ekr.20081121105001.182:isSpecialOverride (simplified)
def isSpecialOverride (self,tkKey,ch):

    '''Return True if tkKey is a special Tk key name.
    '''

    return tkKey or ch in self.flashers
#@-node:ekr.20081121105001.182:isSpecialOverride (simplified)
#@+node:ekr.20081121105001.172:qtKey
def qtKey (self,event):

    '''Return the components of a Qt key event.'''

    trace = False and not g.unitTesting
    keynum = event.key()
    text   = event.text() # This is the unicode text.
    toString = QtGui.QKeySequence(keynum).toString()

    try:
        ch1 = chr(keynum)
    except ValueError:
        ch1 = ''

    try:
        ch = g.u(ch1)
    except UnicodeError:
        ch = ch1

    text     = g.u(text)
    toString = g.u(toString)

    if trace and self.keyIsActive: g.trace(
        'keynum %s ch %s ch1 %s toString %s' % (
            repr(keynum),repr(ch),repr(ch1),repr(toString)))

    return keynum,text,toString,ch
#@-node:ekr.20081121105001.172:qtKey
#@+node:ekr.20081121105001.173:qtMods
def qtMods (self,event):

    modifiers = event.modifiers()

    # The order of this table is significant.
    # It must the order of modifiers in bindings
    # in k.masterGuiBindingsDict

    table = (
        (QtCore.Qt.AltModifier,     'Alt'),
        (QtCore.Qt.ControlModifier, 'Control'),
        (QtCore.Qt.MetaModifier,    'Meta'),
        (QtCore.Qt.ShiftModifier,   'Shift'),
    )

    mods = [b for a,b in table if (modifiers & a)]

    return mods
#@-node:ekr.20081121105001.173:qtMods
#@+node:ekr.20081121105001.174:tkKey
def tkKey (self,event,mods,keynum,text,toString,ch):

    '''Carefully convert the Qt key to a 
    Tk-style binding compatible with Leo's core
    binding dictionaries.'''

    trace = False and not g.unitTesting
    ch1 = ch # For tracing.
    use_shift = (
        'Home','End','Tab',
        'Up','Down','Left','Right',
        # Dubious...
        # 'Backspace','Delete','Ins',
        # 'F1',...'F12',
    )

    # Convert '&' to 'ampersand', etc.
    # *Do* allow shift-bracketleft, etc.
    ch2 = self.char2tkName(ch or toString)
    if ch2: ch = ch2 
    if not ch: ch = ''

    if 'Shift' in mods:
        if trace: g.trace(repr(ch))
        if len(ch) == 1 and ch.isalpha():
            mods.remove('Shift')
            ch = ch.upper()
        elif len(ch) > 1 and ch not in use_shift:
            # Experimental!
            mods.remove('Shift')
        # 2009/12/19: Speculative.
        # if ch in ('parenright','parenleft','braceright','braceleft'):
            # mods.remove('Shift')
    elif len(ch) == 1:
        ch = ch.lower()

    if ('Alt' in mods or 'Control' in mods) and ch and ch in string.digits:
        mods.append('Key')

    # *Do* allow bare mod keys, so they won't be passed on.
    tkKey = '%s%s%s' % ('-'.join(mods),mods and '-' or '',ch)

    if trace: g.trace(
        'text: %s toString: %s ch1: %s ch: %s' % (
        repr(text),repr(toString),repr(ch1),repr(ch)))

    ignore = not ch # Essential
    ch = text or toString
    return tkKey,ch,ignore
#@-node:ekr.20081121105001.174:tkKey
#@+node:ekr.20081121105001.169:toStroke
def toStroke (self,tkKey,ch):

    trace = False and not g.unitTesting
    k = self.c.k ; s = tkKey

    special = ('Alt','Ctrl','Control',)
    isSpecial = [True for z in special if s.find(z) > -1]

    if 0:
        if isSpecial:
            pass # s = s.replace('Key-','')
        else:
            # Keep the Tk spellings for special keys.
            ch2 = k.guiBindNamesDict.get(ch)
            if trace: g.trace('ch',repr(ch),'ch2',repr(ch2))
            if ch2: s = s.replace(ch,ch2)

    table = (
        ('Alt-','Alt+'),
        ('Ctrl-','Ctrl+'),
        ('Control-','Ctrl+'),
        # Use Alt+Key-1, etc.  Sheesh.
        # ('Key-','Key+'),
        ('Shift-','Shift+')
    )
    for a,b in table:
        s = s.replace(a,b)

    if trace: g.trace('tkKey',tkKey,'-->',s)
    return s
#@-node:ekr.20081121105001.169:toStroke
#@+node:ekr.20081121105001.170:toTkKey
def toTkKey (self,event):

    mods = self.qtMods(event)

    keynum,text,toString,ch = self.qtKey(event)

    tkKey,ch,ignore = self.tkKey(
        event,mods,keynum,text,toString,ch)

    return tkKey,ch,ignore
#@-node:ekr.20081121105001.170:toTkKey
#@+node:ekr.20081121105001.179:traceEvent
def traceEvent (self,obj,event,tkKey,override):

    if g.unitTesting: return

    c = self.c ; e = QtCore.QEvent
    keys = True ; traceAll = True 
    eventType = event.type()

    show = [
        # (e.Enter,'enter'),(e.Leave,'leave'),
        (e.FocusIn,'focus-in'),(e.FocusOut,'focus-out'),
        # (e.MouseMove,'mouse-move'),
        (e.MouseButtonPress,'mouse-dn'),
        (e.MouseButtonRelease,'mouse-up'),
    ]

    if keys:
        show2 = [
            (e.KeyPress,'key-press'),
            (e.KeyRelease,'key-release'),
            (e.ShortcutOverride,'shortcut-override'),
        ]
        show.extend(show2)

    ignore = (
        1,16,67,70,
        e.ChildPolished,
        e.DeferredDelete,
        e.DynamicPropertyChange,
        e.Enter,e.Leave,
        e.FocusIn,e.FocusOut,
        e.FontChange,
        e.Hide,e.HideToParent,
        e.HoverEnter,e.HoverLeave,e.HoverMove,
        e.LayoutRequest,
        e.MetaCall,e.Move,e.Paint,e.Resize,
        # e.MouseMove,e.MouseButtonPress,e.MouseButtonRelease,
        e.PaletteChange,
        e.ParentChange,
        e.Polish,e.PolishRequest,
        e.Show,e.ShowToParent,
        e.StyleChange,
        e.ToolTip,
        e.WindowActivate,e.WindowDeactivate,
        e.WindowBlocked,e.WindowUnblocked,
        e.ZOrderChange,
    )

    for val,kind in show:
        if eventType == val:
            g.trace(
                '%5s %18s in-state: %5s key: %s override: %s' % (
                self.tag,kind,repr(c.k.inState()),tkKey,override))
            return

    if traceAll and eventType not in ignore:
        g.trace('%3s:%s' % (eventType,'unknown'))
#@-node:ekr.20081121105001.179:traceEvent
#@+node:ekr.20090407080217.1:traceFocus
def traceFocus (self,eventType,obj):

    ev = QtCore.QEvent

    table = (
        (ev.FocusIn,        'focus-in'),
        (ev.FocusOut,       'focus-out'),
        (ev.WindowActivate, 'activate'),
        (ev.WindowDeactivate,'deactivate'),
    )

    for evKind,kind in table:
        if eventType == evKind:
            g.trace('%11s %s %s %s' % (
                (kind,id(obj),
                # event.reason(),
                obj.objectName(),obj)))
                # g.app.gui.widget_name(obj) or obj)))

    # else: g.trace('unknown kind: %s' % eventType)
#@-node:ekr.20090407080217.1:traceFocus
#@-node:ekr.20081121105001.166:class leoQtEventFilter
#@-node:ekr.20091228111211.3647:Correct binding of insert key
#@+node:ekr.20100101104934.3657:Update tab names when the commander is dirty
# The call to c.setChanged usually happens in onBodyChanged,
# *not* in onTextChanged.
#@nonl
#@+node:ekr.20081121105001.474: qtGui.__init__
def __init__ (self):

    # Initialize the base class.
    leoGui.leoGui.__init__(self,'qt')

    self.qtApp = app = QtGui.QApplication(sys.argv)
    self.bodyTextWidget  = leoQtBaseTextWidget
    self.plainTextWidget = leoQtBaseTextWidget
    self.iconimages = {} # Image cache set by getIconImage().
    self.mGuiName = 'qt'
    self.defaultEncoding = None # Set by toUnicode as needed.    

    if g.app.qt_use_tabs:    
        self.frameFactory = TabbedFrameFactory()
    else:
        self.frameFactory = SDIFrameFactory()
#@-node:ekr.20081121105001.474: qtGui.__init__
#@+node:ekr.20081121105001.254:qtFrame.finishCreate & helpers
def finishCreate (self,c):

    f = self ; f.c = c

    # g.trace('***qtFrame')

    # self.bigTree         = c.config.getBool('big_outline_pane')
    self.trace_status_line = c.config.getBool('trace_status_line')
    self.use_chapters      = c.config.getBool('use_chapters')
    self.use_chapter_tabs  = c.config.getBool('use_chapter_tabs')

    # returns DynamicWindow
    f.top = g.app.gui.frameFactory.createFrame(f)

    # hiding would remove flicker, but doesn't work with all
    # window managers

    f.createIconBar() # A base class method.
    f.createSplitterComponents()
    f.createStatusLine() # A base class method.
    f.createFirstTreeNode() # Call the base-class method.
    f.menu = leoQtMenu(f)
    c.setLog()
    g.app.windowList.append(f)
    f.miniBufferWidget = leoQtMinibuffer(c)
    c.bodyWantsFocusNow()
#@+node:ekr.20081121105001.255:createSplitterComponents (qtFrame)
def createSplitterComponents (self):

    f = self ; c = f.c

    f.tree  = leoQtTree(c,f)
    f.log   = leoQtLog(f,None)
    f.body  = leoQtBody(f,None)

    if f.use_chapters:
        c.chapterController = cc = leoChapters.chapterController(c)

    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.resizePanesToRatio(f.ratio,f.secondary_ratio)
#@-node:ekr.20081121105001.255:createSplitterComponents (qtFrame)
#@-node:ekr.20081121105001.254:qtFrame.finishCreate & helpers
#@+node:ekr.20081121105001.536:onTextChanged (qtText)
def onTextChanged (self):

    '''Update Leo after the body has been changed.

    self.selecting is guaranteed to be True during
    the entire selection process.'''

    # Important: usually w.changingText is True.
    # This method very seldom does anything.
    trace = False and not g.unitTesting
    verbose = True
    c = self.c ; p = c.p
    tree = c.frame.tree ; w = self

    if w.changingText: 
        if trace and verbose: g.trace('already changing')
        return
    if tree.tree_select_lockout:
        if trace and verbose: g.trace('selecting lockout')
        return
    if tree.selecting:
        if trace and verbose: g.trace('selecting')
        return
    if tree.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if not p:
        return g.trace('*** no p')

    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText() # Converts to unicode.

    # Get the previous values from the vnode.
    oldText = g.app.gui.toUnicode(p.v._bodyString)
    if oldText == newText:
        # This can happen as the result of undo.
        # g.trace('*** unexpected non-change',color="red")
        return

    # g.trace('**',len(newText),p.h,'\n',g.callers(8))

    oldIns  = p.v.insertSpot
    i,j = p.v.selectionStart,p.v.selectionLength
    oldSel  = (i,i+j)
    if trace: g.trace('oldSel',oldSel,'newSel',newSel)
    oldYview = None
    undoType = 'Typing'
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,
        oldSel=oldSel,newSel=newSel,oldYview=oldYview)

    # Update the vnode.
    p.v.setBodyString(newText)
    if True:
        p.v.insertSpot = newInsert
        i,j = newSel
        i,j = self.toGuiIndex(i),self.toGuiIndex(j)
        if i > j: i,j = j,i
        p.v.selectionStart,p.v.selectionLength = (i,j-i)

    # No need to redraw the screen.
    if not self.useScintilla:
        c.recolor()

    if g.app.qt_use_tabs:
        if trace: g.trace(c.frame.top)

    if not c.changed and c.frame.initComplete:
        c.setChanged(True)

    c.frame.body.updateEditors()
    c.frame.tree.updateIcon(p)

    if 1: # This works, and is probably better.
        # Set a hook for the old jEdit colorer.
        colorer = c.frame.body.colorizer.highlighter.colorer
        colorer.initFlag = True
    else:
        # Allow incremental recoloring.
        c.incrementalRecolorFlag = True
        c.outerUpdate()
#@-node:ekr.20081121105001.536:onTextChanged (qtText)
#@+node:ville.20090803130409.3679:class SDIFrameFactory
class SDIFrameFactory:
    """ 'Toplevel' frame builder 

    This only deals with Qt level widgets, not Leo wrappers
    """

    @others
#@+node:ville.20090803130409.3680:frame creation & null deletion
def createFrame(self, leoFrame):

    c = leoFrame.c
    dw = DynamicWindow(c)    
    dw.construct()
    g.app.gui.attachLeoIcon(dw)
    dw.setWindowTitle(leoFrame.title)
    dw.show()
    return dw

def deleteFrame(self, wdg):
    pass

#@-node:ville.20090803130409.3680:frame creation & null deletion
#@-node:ville.20090803130409.3679:class SDIFrameFactory
#@+node:ville.20090803130409.3685:class TabbedFrameFactory
class TabbedFrameFactory:
    """ 'Toplevel' frame builder for tabbed toplevel interface

    This causes Leo to maintain only one toplevel window,
    with multiple tabs for documents
    """

    @others
#@+node:ville.20090803132402.3685:ctor
def __init__(self):    
    # will be created when first frame appears    

    # DynamicWindow => Leo frame map
    self.alwaysShowTabs = True
        # Set to true to workaround a problem
        # setting the window title when tabs are shown.
    self.leoFrames = {} 
    self.masterFrame = None
    self.createTabCommands()
#@-node:ville.20090803132402.3685:ctor
#@+node:ekr.20100101104934.3658:createFrame
def createFrame(self, leoFrame):

    c = leoFrame.c
    if self.masterFrame is None:
        self.createMaster()
    tabw = self.masterFrame
    dw = DynamicWindow(c,tabw)
    self.leoFrames[dw] = leoFrame

    # Shorten the title.
    fname = c.mFileName
    if fname:
        title = os.path.basename(fname)
    else:
        title = leoFrame.title
    tip = leoFrame.title
    # g.trace('title',title,'tip',tip)

    dw.setWindowTitle(tip) # 2010/1/1
    idx = tabw.addTab(dw, title)
    if tip: tabw.setTabToolTip(idx, tip)

    dw.construct(master=tabw)
    tabw.setCurrentIndex(idx)            

    # Work around the problem with missing dirty indicator
    # by always showing the tab.
    tabw.tabBar().setVisible(
        self.alwaysShowTabs or tabw.count() > 1)

    dw.show()
    tabw.show()
    return dw
#@-node:ekr.20100101104934.3658:createFrame
#@+node:ekr.20100101104934.3659:deleteFrame
def deleteFrame(self, wdg):
    if wdg not in self.leoFrames:
        # probably detached tab
        return
    tabw = self.masterFrame
    idx = tabw.indexOf(wdg)
    tabw.removeTab(idx)
    del self.leoFrames[wdg]
    tabw.tabBar().setVisible(
        self.alwaysShowTabs or tabw.count() > 1)
#@-node:ekr.20100101104934.3659:deleteFrame
#@+node:ville.20090803132402.3684:createMaster
def createMaster(self):
    mf = self.masterFrame = LeoTabbedTopLevel()
    mf.resize(1000, 700)
    g.app.gui.attachLeoIcon(mf)
    tabbar = mf.tabBar()

    try:
        tabbar.setTabsClosable(True)
        tabbar.connect(tabbar,
            QtCore.SIGNAL('tabCloseRequested(int)'),
            self.slotCloseRequest)
    except AttributeError:
        pass # Qt 4.4 does not support setTabsClosable

    mf.connect(mf,
        QtCore.SIGNAL('currentChanged(int)'),
        self.slotCurrentChanged)
    mf.show()
#@-node:ville.20090803132402.3684:createMaster
#@+node:ekr.20100101104934.3660:signal handlers
def slotCloseRequest(self,idx):
    tabw = self.masterFrame
    w = tabw.widget(idx)
    f = self.leoFrames[w]
    c = f.c
    c.close()

def slotCurrentChanged(self, idx):
    tabw = self.masterFrame
    w = tabw.widget(idx)
    f = self.leoFrames.get(w)
    if f:
        # g.trace(f and f.title or '<no frame>')
        tabw.setWindowTitle(f.title)
#@-node:ekr.20100101104934.3660:signal handlers
#@+node:ville.20090803201708.3694:utilities
def focusCurrentBody(self):
    """ Focus body control of current tab """
    tabw = self.masterFrame
    w = tabw.currentWidget()
    w.setFocus()

    f = self.leoFrames[w]
    c = f.c
    c.bodyWantsFocusNow()
#@-node:ville.20090803201708.3694:utilities
#@+node:ville.20090803164510.3688:createTabCommands
def detachTab(self, wdg):
    """ Detach specified tab as individual toplevel window """

    del self.leoFrames[wdg]
    wdg.setParent(None)
    wdg.show()

def createTabCommands(self):
    << Commands for tabs >>




#@+node:ville.20090803184912.3685:<< Commands for tabs >>
@g.command('tab-detach')
def tab_detach(event):
    """ Detach current tab from tab bar """
    if len(self.leoFrames) < 2:
        g.es_print_error("Can't detach last tab")
        return

    c = event['c']
    f = c.frame
    self.detachTab(f.top)
    f.top.setWindowTitle(f.title + ' [D]')

# this is actually not tab-specific, move elsewhere?
@g.command('close-others')
def close_others(event):
    myc = event['c']
    for c in g.app.commanders():
        if c is not myc:
            c.close()

def tab_cycle(offset):
    tabw = self.masterFrame
    cur = tabw.currentIndex()
    count = tabw.count()
    cur += offset
    if cur < 0:
        cur = count -1
    if cur == count:
        cur = 0
    tabw.setCurrentIndex(cur)
    self.focusCurrentBody()

@g.command('tab-cycle-next')
def tab_cycle_next(event):
    """ Cycle to next tab """
    tab_cycle(1)

@g.command('tab-cycle-previous')
def tab_cycle_previous(event):
    """ Cycle to next tab """
    tab_cycle(-1)
#@-node:ville.20090803184912.3685:<< Commands for tabs >>
#@-node:ville.20090803164510.3688:createTabCommands
#@-node:ville.20090803130409.3685:class TabbedFrameFactory
#@+node:ville.20090804182114.8400:class LeoTabbedTopLevel (QtGui.QTabWidget)
class LeoTabbedTopLevel(QtGui.QTabWidget):
    """ Toplevel frame for tabbed ui """

    @others




#@+node:ekr.20100101104934.3662:setChanged
def setChanged (self,c,changed):

    i = self.currentIndex()
    if i < 0: return

    s = self.tabText(i)
    s = g.u(s)
    # g.trace('LeoTabbedTopLevel',changed,repr(s))

    if len(s) > 2:
        if changed:
            if not s.startswith('* '):
                title = "* " + s
                self.setTabText(i,title)
        else:
            if s.startswith('* '):
                title = s[2:]
                self.setTabText(i,title)
#@-node:ekr.20100101104934.3662:setChanged
#@+node:ville.20090804182114.8401:closeEvent (leoTabbedTopLevel)
def closeEvent(self, event):

    noclose = False
    for c in g.app.commanders():
        res = c.exists and g.app.closeLeoWindow(c.frame)
        if not res:
            noclose = True

    if noclose:
        event.ignore()
    else:            
        event.accept()
#@-node:ville.20090804182114.8401:closeEvent (leoTabbedTopLevel)
#@-node:ville.20090804182114.8400:class LeoTabbedTopLevel (QtGui.QTabWidget)
#@+node:ekr.20081121105001.200:class  DynamicWindow (QtGui.QMainWindow)
from PyQt4 import uic

class DynamicWindow(QtGui.QMainWindow):

    '''A class representing all parts of the main Qt window
    as created by Designer.

    c.frame.top is a DynamciWindow object.

    All leoQtX classes use the ivars of this Window class to
    support operations requested by Leo's core.
    '''

    @others

#@+node:ekr.20081121105001.201: ctor (DynamicWindow)
# Called from leoQtFrame.finishCreate.

def __init__(self,c,parent=None):

    '''Create Leo's main window, c.frame.top'''

    QtGui.QMainWindow.__init__(self,parent)
    self.c = c
#@-node:ekr.20081121105001.201: ctor (DynamicWindow)
#@+node:ville.20090806213440.3689:construct
def construct(self,master=None):
    """ Factor 'heavy duty' code out from ctor """

    c = self.c; top = c.frame.top
    self.master=master # Exists for tabbed windows.
    # print('DynamicWindow.__init__ %s' % c)

    # Init the base class.
    ui_file_name = c.config.getString('qt_ui_file_name')
    if not ui_file_name:
        ui_file_name = 'qt_main.ui'

    ui_description_file = g.app.loadDir + "/../plugins/" + ui_file_name
    # g.pr('DynamicWindw.__init__,ui_description_file)
    assert g.os_path_exists(ui_description_file)

    self.bigTree = c.config.getBool('big_outline_pane')

    if useUI:  
        self.ui = uic.loadUi(ui_description_file, self)
    else:
        self.createMainWindow()

    self.iconBar = self.addToolBar("IconBar")
    self.menubar = self.menuBar()
    self.statusBar = QtGui.QStatusBar()
    self.setStatusBar(self.statusBar)

    orientation = c.config.getString('initial_split_orientation')
    self.setSplitDirection(orientation)
    self.setStyleSheets()
    #self.setLeoWindowIcon()
#@-node:ville.20090806213440.3689:construct
#@+node:ekr.20081121105001.202:closeEvent (DynanicWindow)
def closeEvent (self,event):

    trace = False and not g.unitTesting
    c = self.c

    if not c.exists:
        # Fixes double-prompt bug on Linux.
        if trace: g.trace('destroyed')
        event.accept()
        return

    if c.inCommand:
        if trace: g.trace('in command')
        c.requestCloseWindow = True
    else:
        if trace: g.trace('closing')
        ok = g.app.closeLeoWindow(c.frame)
        if ok:
            event.accept()
        else:
            event.ignore()
#@-node:ekr.20081121105001.202:closeEvent (DynanicWindow)
#@+node:ekr.20090423070717.14:createMainWindow & helpers
# Called instead of uic.loadUi(ui_description_file, self)

def createMainWindow (self):

    '''Create the component ivars of the main window.

    Copied/adapted from qt_main.py'''

    MainWindow = self
    self.ui = self

    self.setMainWindowOptions()
    self.createCentralWidget()
    self.createMainLayout(self.centralwidget)
        # Creates .verticalLayout, .splitter and .splitter_2.
    if self.bigTree:
        self.createBodyPane(self.splitter)
        self.createLogPane(self.splitter)
        treeFrame = self.createOutlinePane(self.splitter_2)
        self.splitter_2.addWidget(treeFrame)
        self.splitter_2.addWidget(self.splitter)
    else:
        self.createOutlinePane(self.splitter)
        self.createLogPane(self.splitter)
        self.createBodyPane(self.splitter_2)
    self.createMiniBuffer(self.centralwidget)
    self.createMenuBar()
    self.createStatusBar(MainWindow)

    # Signals
    QtCore.QMetaObject.connectSlotsByName(MainWindow)
#@+node:ekr.20090426183711.10:top-level
#@+node:ekr.20090424085523.43:createBodyPane
def createBodyPane (self,parent):

    # Create widgets.
    bodyFrame = self.createFrame(parent,'bodyFrame')
    innerFrame = self.createFrame(bodyFrame,'innerBodyFrame',
        hPolicy=QtGui.QSizePolicy.Expanding)
    sw = self.createStackedWidget(innerFrame,'bodyStackedWidget')
    page2 = QtGui.QWidget()
    self.setName(page2,'bodyPage2')
    body = self.createText(page2,'richTextEdit')

    # Pack.
    vLayout = self.createVLayout(page2,'bodyVLayout',spacing=6)
    grid = self.createGrid(bodyFrame,'bodyGrid')
    innerGrid = self.createGrid(innerFrame,'bodyInnerGrid')
    vLayout.addWidget(body)
    sw.addWidget(page2)
    innerGrid.addWidget(sw, 0, 0, 1, 1)
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    self.verticalLayout.addWidget(parent)

    # Official ivars
    self.stackedWidget = sw # used by leoQtBody
    self.richTextEdit = body
    self.leo_body_frame = bodyFrame
    self.leo_body_inner_frame = innerFrame
    # self.leo_body_grid = grid
    # self.grid = innerGrid
    # self.page_2 = page2
    # self.verticalBodyLayout= vLayout
#@-node:ekr.20090424085523.43:createBodyPane
#@+node:ekr.20090425072841.12:createCentralWidget
def createCentralWidget (self):

    MainWindow = self

    w = QtGui.QWidget(MainWindow)
    w.setObjectName("centralwidget")

    MainWindow.setCentralWidget(w)

    # Official ivars.
    self.centralwidget = w
#@-node:ekr.20090425072841.12:createCentralWidget
#@+node:ekr.20090424085523.42:createLogPane
def createLogPane (self,parent):

    # Create widgets.
    logFrame = self.createFrame(parent,'logFrame',
        vPolicy = QtGui.QSizePolicy.Minimum)
    innerFrame = self.createFrame(logFrame,'logInnerFrame',
        hPolicy=QtGui.QSizePolicy.Preferred,
        vPolicy=QtGui.QSizePolicy.Expanding)
    tabWidget = self.createTabWidget(innerFrame,'logTabWidget')

    # Pack.
    innerGrid = self.createGrid(innerFrame,'logInnerGrid')
    innerGrid.addWidget(tabWidget, 0, 0, 1, 1)
    outerGrid = self.createGrid(logFrame,'logGrid')
    outerGrid.addWidget(innerFrame, 0, 0, 1, 1)

    findTab = QtGui.QWidget()
    findTab.setObjectName('findTab')
    tabWidget.addTab(findTab,'Find')
    self.createFindTab(findTab)

    spellTab = QtGui.QWidget()
    spellTab.setObjectName('spellTab')
    tabWidget.addTab(spellTab,'Spell')
    self.createSpellTab(spellTab)

    tabWidget.setCurrentIndex(1)

    # Official ivars
    self.tabWidget = tabWidget # Used by leoQtLog.
    # self.leo_log_frame = logFrame
    # self.leo_log_grid = outerGrid
    # self.findTab = findTab
    # self.spellTab = spellTab
    # self.leo_log_inner_frame = innerFrame
    # self.leo_log_inner_grid = innerGrid
#@-node:ekr.20090424085523.42:createLogPane
#@+node:ekr.20090424085523.41:createMainLayout (DynamicWindow)
def createMainLayout (self,parent):

    vLayout = self.createVLayout(parent,'mainVLayout',margin=3)

    # Splitter two is the "main" splitter, containing splitter.
    splitter2 = QtGui.QSplitter(parent)
    splitter2.setOrientation(QtCore.Qt.Vertical)
    splitter2.setObjectName("splitter_2")

    splitter = QtGui.QSplitter(splitter2)
    splitter.setOrientation(QtCore.Qt.Horizontal)
    splitter.setObjectName("splitter")

    # g.trace('splitter %s splitter2 %s' % (id(splitter),id(splitter2)))

    # Official ivars
    self.verticalLayout = vLayout
    self.splitter = splitter
    self.splitter_2 = splitter2

    self.setSizePolicy(self.splitter)
    self.verticalLayout.addWidget(self.splitter_2)
#@-node:ekr.20090424085523.41:createMainLayout (DynamicWindow)
#@+node:ekr.20090424085523.45:createMenuBar
def createMenuBar (self):

    MainWindow = self

    w = QtGui.QMenuBar(MainWindow)
    w.setGeometry(QtCore.QRect(0, 0, 957, 22))
    w.setObjectName("menubar")

    MainWindow.setMenuBar(w)

    # Official ivars.
    self.menubar = w
#@-node:ekr.20090424085523.45:createMenuBar
#@+node:ekr.20090424085523.44:createMiniBuffer
def createMiniBuffer (self,parent):

    # Create widgets.
    frame = self.createFrame(self.centralwidget,'minibufferFrame',
        hPolicy = QtGui.QSizePolicy.MinimumExpanding,
        vPolicy = QtGui.QSizePolicy.Fixed)
    frame.setMinimumSize(QtCore.QSize(100, 0))
    label = self.createLabel(frame,'minibufferLabel','Minibuffer:')
    lineEdit = QtGui.QLineEdit(frame)
    lineEdit.setObjectName('lineEdit') # name important.

    # Pack.
    hLayout = self.createHLayout(frame,'minibufferHLayout',spacing=4)
    hLayout.setContentsMargins(3, 2, 2, 0)
    hLayout.addWidget(label)
    hLayout.addWidget(lineEdit)
    self.verticalLayout.addWidget(frame)
    label.setBuddy(lineEdit)

    # Official ivars.
    self.lineEdit = lineEdit
    # self.leo_minibuffer_frame = frame
    # self.leo_minibuffer_layout = layout
#@-node:ekr.20090424085523.44:createMiniBuffer
#@+node:ekr.20090424085523.47:createOutlinePane
def createOutlinePane (self,parent):

    # Create widgets.
    treeFrame = self.createFrame(parent,'outlineFrame',
        vPolicy = QtGui.QSizePolicy.Expanding)
    innerFrame = self.createFrame(treeFrame,'outlineInnerFrame',
        hPolicy = QtGui.QSizePolicy.Preferred)

    treeWidget = self.createTreeWidget(innerFrame,'treeWidget')

    grid = self.createGrid(treeFrame,'outlineGrid')
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    innerGrid = self.createGrid(innerFrame,'outlineInnerGrid')
    innerGrid.addWidget(treeWidget, 0, 0, 1, 1)

    # Official ivars...
    self.treeWidget = treeWidget
    # self.leo_outline_frame = treeFrame
    # self.leo_outline_grid = grid
    # self.leo_outline_inner_frame = innerFrame

    return treeFrame
#@-node:ekr.20090424085523.47:createOutlinePane
#@+node:ekr.20090424085523.46:createStatusBar
def createStatusBar (self,parent):

    w = QtGui.QStatusBar(parent)
    w.setObjectName("statusbar")
    parent.setStatusBar(w)

    # Official ivars.
    self.statusBar = w
#@-node:ekr.20090424085523.46:createStatusBar
#@+node:ekr.20090425072841.2:setMainWindowOptions
def setMainWindowOptions (self):

    MainWindow = self

    MainWindow.setObjectName("MainWindow")
    MainWindow.resize(691, 635)
    MainWindow.setDockNestingEnabled(False)
    MainWindow.setDockOptions(
        QtGui.QMainWindow.AllowTabbedDocks |
        QtGui.QMainWindow.AnimatedDocks)
#@-node:ekr.20090425072841.2:setMainWindowOptions
#@-node:ekr.20090426183711.10:top-level
#@+node:ekr.20090426183711.11:widgets
#@+node:ekr.20090424085523.51:createButton
def createButton (self,parent,name,label):

    w = QtGui.QPushButton(parent)
    w.setObjectName(name)
    w.setText(self.tr(label))
    return w
#@nonl
#@-node:ekr.20090424085523.51:createButton
#@+node:ekr.20090424085523.39:createCheckBox
def createCheckBox (self,parent,name,label):

    w = QtGui.QCheckBox(parent)
    self.setName(w,name)
    w.setText(self.tr(label))
    return w
#@nonl
#@-node:ekr.20090424085523.39:createCheckBox
#@+node:ekr.20090426083450.10:createContainer (to do)
def createContainer (self,parent):

    pass
#@nonl
#@-node:ekr.20090426083450.10:createContainer (to do)
#@+node:ekr.20090426083450.11:createFrame
def createFrame (self,parent,name,
    hPolicy=None,vPolicy=None,
    lineWidth = 1,
    shadow = QtGui.QFrame.Plain,
    shape = QtGui.QFrame.NoFrame,
):

    w = QtGui.QFrame(parent)
    self.setSizePolicy(w,kind1=hPolicy,kind2=vPolicy)
    w.setFrameShape(shape)
    w.setFrameShadow(shadow)
    w.setLineWidth(lineWidth)
    self.setName(w,name)
    return w
#@-node:ekr.20090426083450.11:createFrame
#@+node:ekr.20090426083450.12:createGrid
def createGrid (self,parent,name,margin=0,spacing=0):

    w = QtGui.QGridLayout(parent)
    w.setMargin(margin)
    w.setSpacing(spacing)
    self.setName(w,name)
    return w
#@nonl
#@-node:ekr.20090426083450.12:createGrid
#@+node:ekr.20090426083450.19:createHLayout & createVLayout
def createHLayout (self,parent,name,margin=0,spacing=0):

    hLayout = QtGui.QHBoxLayout(parent)
    hLayout.setSpacing(spacing)
    hLayout.setMargin(margin)
    self.setName(hLayout,name)
    return hLayout

def createVLayout (self,parent,name,margin=0,spacing=0):

    vLayout = QtGui.QVBoxLayout(parent)
    vLayout.setSpacing(spacing)
    vLayout.setMargin(margin)
    self.setName(vLayout,name)
    return vLayout
#@-node:ekr.20090426083450.19:createHLayout & createVLayout
#@+node:ekr.20090426083450.14:createLabel
def createLabel (self,parent,name,label):

    w = QtGui.QLabel(parent)
    self.setName(w,name)
    w.setText(self.tr(label))
    return w
#@-node:ekr.20090426083450.14:createLabel
#@+node:ekr.20090424085523.40:createLineEdit
def createLineEdit (self,parent,name):

    w = QtGui.QLineEdit(parent)
    w.setObjectName(name)
    return w
#@-node:ekr.20090424085523.40:createLineEdit
#@+node:ekr.20090427060355.11:createRadioButton
def createRadioButton (self,parent,name,label):

    w = QtGui.QRadioButton(parent)
    self.setName(w,name)
    w.setText(self.tr(label))
    return w
#@nonl
#@-node:ekr.20090427060355.11:createRadioButton
#@+node:ekr.20090426083450.18:createStackedWidget
def createStackedWidget (self,parent,name,
    lineWidth = 1,
    hPolicy=None,vPolicy=None,
):

    w = QtGui.QStackedWidget(parent)
    self.setSizePolicy(w,kind1=hPolicy,kind2=vPolicy)
    w.setAcceptDrops(True)
    w.setLineWidth(1)
    self.setName(w,name)
    return w
#@-node:ekr.20090426083450.18:createStackedWidget
#@+node:ekr.20090426083450.17:createTabWidget
def createTabWidget (self,parent,name,hPolicy=None,vPolicy=None):

    w = QtGui.QTabWidget(parent)
    self.setSizePolicy(w,kind1=hPolicy,kind2=vPolicy)
    self.setName(w,name)
    return w
#@-node:ekr.20090426083450.17:createTabWidget
#@+node:ekr.20090426083450.16:createText
def createText (self,parent,name,
    # hPolicy=None,vPolicy=None,
    lineWidth = 0,
    shadow = QtGui.QFrame.Plain,
    shape = QtGui.QFrame.NoFrame,
):

    # w = QtGui.QTextBrowser(parent)
    c = self.c
    w = QTextBrowserSubclass(parent,c,None)
    # self.setSizePolicy(w,kind1=hPolicy,kind2=vPolicy)
    w.setFrameShape(shape)
    w.setFrameShadow(shadow)
    w.setLineWidth(lineWidth)
    self.setName(w,name)
    return w
#@-node:ekr.20090426083450.16:createText
#@+node:ekr.20090426083450.15:createTreeWidget (DynamicWindow)
def createTreeWidget (self,parent,name):

    c = self.c
    w = QtGui.QTreeWidget(parent)
    self.setSizePolicy(w)

    # 12/01/07: add new config setting.
    multiple_selection = c.config.getBool('qt-tree-multiple-selection',default=True)
    if multiple_selection:
        w.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)
        w.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows)
    else:
        w.setSelectionMode(QtGui.QAbstractItemView.SingleSelection)
        w.setSelectionBehavior(QtGui.QAbstractItemView.SelectItems)
    w.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    w.setHeaderHidden(False)
    self.setName(w,name)
    return w
#@-node:ekr.20090426083450.15:createTreeWidget (DynamicWindow)
#@-node:ekr.20090426183711.11:widgets
#@+node:ekr.20090426183711.12:log tabs
#@+node:ekr.20090424085523.38:createFindTab
def createFindTab (self,parent):

    grid = self.createGrid(parent,'findGrid',margin=10,spacing=2)

    # Labels.
    lab2 = self.createLabel(parent,'findLabel','Find:')
    lab3 = self.createLabel(parent,'changeLabel','Change:')
    grid.addWidget(lab2,0,0)
    grid.addWidget(lab3,1,0)

    # Text areas.
    findPattern = self.createLineEdit(parent,'findPattern')
    findChange  = self.createLineEdit(parent,'findChange')
    grid.addWidget(findPattern,0,1)
    grid.addWidget(findChange,1,1)

    # Check boxes and radio buttons.
    # Radio buttons are mutually exclusive because they have the same parent.
    def mungeName(name):
        # The value returned here is significant: it creates an ivar.
        return 'checkBox%s' % label.replace(' ','').replace('&','')

    table = (
        ('box', 'Whole &Word',      2,0),
        ('rb',  '&Entire Outline',  2,1),
        ('box', '&Ignore Case',     3,0),
        ('rb',  '&Suboutline Only', 3,1),
        ('box', 'Wrap &Around',     4,0),
        ('rb',  '&Node Only',       4,1),
        ('box', '&Reverse',         5,0),
        ('box', 'Search &Headline', 5,1),
        ('box', 'Rege&xp',          6,0),
        ('box', 'Search &Body',     6,1),
        ('box', 'Mark &Finds',      7,0),
        ('box', 'Mark &Changes',    7,1))
        # a,b,c,e,f,h,i,n,rs,w

    for kind,label,row,col in table:

        name = mungeName(label)
        func = g.choose(kind=='box',
            self.createCheckBox,self.createRadioButton)
        w = func(parent,name,label)
        grid.addWidget(w,row,col)
        setattr(self,name,w)

    # Official ivars (in addition to setattr ivars).
    self.findPattern = findPattern
    self.findChange = findChange
#@-node:ekr.20090424085523.38:createFindTab
#@+node:ekr.20090424085523.50:createSpellTab
def createSpellTab (self,parent):

    MainWindow = self

    vLayout = self.createVLayout(parent,'spellVLayout',margin=2)
    spellFrame = self.createFrame(parent,'spellFrame')
    vLayout2 = self.createVLayout(spellFrame,'spellVLayout')
    grid = self.createGrid(None,'spellGrid',spacing=2)

    table = (
        ('Add',     'Add',          2,1),
        ('Find',    'Find',         2,0),
        ('Change',  'Change',       3,0),
        ('FindChange','Change,Find',3,1),
        ('Ignore',  'Ignore',       4,0),
        ('Hide',    'Hide',         4,1),
    )
    for (ivar,label,row,col) in table:
        name = 'spell_%s_button' % label
        button = self.createButton(spellFrame,name,label)
        grid.addWidget(button,row,col)
        func = getattr(self,'do_leo_spell_btn_%s' % ivar)
        QtCore.QObject.connect(button,QtCore.SIGNAL("clicked()"),func)
        # This name is significant.
        setattr(self,'leo_spell_btn_%s' % (ivar),button)

    self.leo_spell_btn_Hide.setCheckable(False)

    spacerItem = QtGui.QSpacerItem(20, 40,
        QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)

    grid.addItem(spacerItem, 5, 0, 1, 1)

    listBox = QtGui.QListWidget(spellFrame)
    self.setSizePolicy(listBox,
        kind1 = QtGui.QSizePolicy.MinimumExpanding,
        kind2 = QtGui.QSizePolicy.Expanding)
    listBox.setMinimumSize(QtCore.QSize(0, 0))
    listBox.setMaximumSize(QtCore.QSize(150, 150))
    listBox.setObjectName("leo_spell_listBox")

    grid.addWidget(listBox, 1, 0, 1, 2)

    spacerItem1 = QtGui.QSpacerItem(40, 20,
        QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
    grid.addItem(spacerItem1, 2, 2, 1, 1)

    lab = self.createLabel(spellFrame,'spellLabel','spellLabel')

    grid.addWidget(lab, 0, 0, 1, 2)
    vLayout2.addLayout(grid)
    vLayout.addWidget(spellFrame)

    QtCore.QObject.connect(listBox,
        QtCore.SIGNAL("itemDoubleClicked(QListWidgetItem*)"),
        self.do_leo_spell_btn_FindChange)

    # Official ivars.
    self.spellFrame = spellFrame
    self.spellGrid = grid
    self.leo_spell_listBox = listBox # Must exist
    self.leo_spell_label = lab # Must exist (!!)
#@-node:ekr.20090424085523.50:createSpellTab
#@-node:ekr.20090426183711.12:log tabs
#@+node:ekr.20090426183711.13:utils
#@+node:ekr.20090426083450.13:setName
def setName (self,widget,name):

    if name:
        # if not name.startswith('leo_'):
            # name = 'leo_' + name
        widget.setObjectName(name)
#@-node:ekr.20090426083450.13:setName
#@+node:ekr.20090425072841.14:setSizePolicy
def setSizePolicy (self,widget,kind1=None,kind2=None):

    if kind1 is None: kind1 = QtGui.QSizePolicy.Ignored
    if kind2 is None: kind2 = QtGui.QSizePolicy.Ignored

    sizePolicy = QtGui.QSizePolicy(kind1,kind2)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)

    sizePolicy.setHeightForWidth(
        widget.sizePolicy().hasHeightForWidth())

    widget.setSizePolicy(sizePolicy)
#@-node:ekr.20090425072841.14:setSizePolicy
#@+node:ekr.20090424085523.48:tr
def tr(self,s):

    return QtGui.QApplication.translate(
        'MainWindow',s,None,QtGui.QApplication.UnicodeUTF8)
#@nonl
#@-node:ekr.20090424085523.48:tr
#@-node:ekr.20090426183711.13:utils
#@-node:ekr.20090423070717.14:createMainWindow & helpers
#@+node:leohag.20081203210510.17:do_leo_spell_btn_*
def doSpellBtn(self, btn):
    getattr(self.c.spellCommands.handler.tab, btn)() 

def do_leo_spell_btn_Add(self):
    self.doSpellBtn('onAddButton')

def do_leo_spell_btn_Change(self):
    self.doSpellBtn('onChangeButton')

def do_leo_spell_btn_Find(self):
    self.doSpellBtn('onFindButton')

def do_leo_spell_btn_FindChange(self):
    self.doSpellBtn('onChangeThenFindButton')

def do_leo_spell_btn_Hide(self):
    self.doSpellBtn('onHideButton')

def do_leo_spell_btn_Ignore(self):
    self.doSpellBtn('onIgnoreButton')
#@-node:leohag.20081203210510.17:do_leo_spell_btn_*
#@+node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
def setSplitDirection (self,orientation='vertical'):

    vert = orientation and orientation.lower().startswith('v')
    h,v = QtCore.Qt.Horizontal,QtCore.Qt.Vertical

    orientation1 = g.choose(vert,h,v)
    orientation2 = g.choose(vert,v,h)

    self.splitter.setOrientation(orientation1)
    self.splitter_2.setOrientation(orientation2)

    # g.trace('vert',vert)

#@-node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
#@+node:ekr.20081121105001.203:setStyleSheets & helper
styleSheet_inited = False

def setStyleSheets(self):

    trace = False
    c = self.c

    sheet = c.config.getData('qt-gui-plugin-style-sheet')
    if sheet:
        sheet = '\n'.join(sheet)
        if trace: g.trace(len(sheet))
        self.ui.setStyleSheet(sheet or self.default_sheet())
    else:
        if trace: g.trace('no style sheet')
#@+node:ekr.20081121105001.204:defaultStyleSheet
def defaultStyleSheet (self):

    '''Return a reasonable default style sheet.'''

    # Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords
    return '''\

/* A QWidget: supports only background attributes.*/
QSplitter::handle {

    background-color: #CAE1FF; /* Leo's traditional lightSteelBlue1 */
}
QSplitter {
    border-color: white;
    background-color: white;
    border-width: 3px;
    border-style: solid;
}
QTreeWidget {
    background-color: #ffffec; /* Leo's traditional tree color */
}
/* Not supported. */
QsciScintilla {
    background-color: pink;
}
'''
#@-node:ekr.20081121105001.204:defaultStyleSheet
#@-node:ekr.20081121105001.203:setStyleSheets & helper
#@+node:ville.20090702214819.4211:setLeoWindowIcon
def setLeoWindowIcon(self):
    """ Set icon visible in title bar and task bar """
    # xxx do not use 
    self.setWindowIcon(QtGui.QIcon(g.app.leoDir + "/Icons/leoapp32.png"))
#@nonl
#@-node:ville.20090702214819.4211:setLeoWindowIcon
#@-node:ekr.20081121105001.200:class  DynamicWindow (QtGui.QMainWindow)
#@+node:ekr.20100101104934.3661:Changed
#@+node:ekr.20081121105001.317:Qt bindings... (qtFrame)
def bringToFront (self):
    self.lift()
def deiconify (self):
    if self.top.isMinimized(): # Bug fix: 400739.
        self.lift()
def getFocus(self):
    return g.app.gui.get_focus(self.c) # Bug fix: 2009/6/30.
def get_window_info(self):
    rect = self.top.geometry()
    topLeft = rect.topLeft()
    x,y = topLeft.x(),topLeft.y()
    w,h = rect.width(),rect.height()
    # g.trace(w,h,x,y)
    return w,h,x,y
def iconify(self):
    self.top.showMinimized()
def lift (self):
    # g.trace(self.c,'\n',g.callers(9))
    if self.top.isMinimized(): # Bug 379141
        self.top.showNormal()
    self.top.activateWindow()
    self.top.raise_()
def update (self):
    pass
def getTitle (self):
    s = g.u(self.top.windowTitle())
    # g.trace('qtFrame',repr(s))
    return s
def setTitle (self,s):
    # g.trace('qtFrame',repr(s))
    # self.top.c.frame.title = s
    self.top.setWindowTitle(s)
def setTopGeometry(self,w,h,x,y,adjustSize=True):
    # g.trace(x,y,w,y,g.callers(5))
    self.top.setGeometry(QtCore.QRect(x,y,w,h))
#@-node:ekr.20081121105001.317:Qt bindings... (qtFrame)
#@+node:ville.20090806213440.3689:construct
def construct(self,master=None):
    """ Factor 'heavy duty' code out from ctor """

    c = self.c; top = c.frame.top
    self.master=master # Exists for tabbed windows.
    # print('DynamicWindow.__init__ %s' % c)

    # Init the base class.
    ui_file_name = c.config.getString('qt_ui_file_name')
    if not ui_file_name:
        ui_file_name = 'qt_main.ui'

    ui_description_file = g.app.loadDir + "/../plugins/" + ui_file_name
    # g.pr('DynamicWindw.__init__,ui_description_file)
    assert g.os_path_exists(ui_description_file)

    self.bigTree = c.config.getBool('big_outline_pane')

    if useUI:  
        self.ui = uic.loadUi(ui_description_file, self)
    else:
        self.createMainWindow()

    self.iconBar = self.addToolBar("IconBar")
    self.menubar = self.menuBar()
    self.statusBar = QtGui.QStatusBar()
    self.setStatusBar(self.statusBar)

    orientation = c.config.getString('initial_split_orientation')
    self.setSplitDirection(orientation)
    self.setStyleSheets()
    #self.setLeoWindowIcon()
#@-node:ville.20090806213440.3689:construct
#@+node:ekr.20100101104934.3662:setChanged
def setChanged (self,c,changed):

    i = self.currentIndex()
    if i < 0: return

    s = self.tabText(i)
    s = g.u(s)
    # g.trace('LeoTabbedTopLevel',changed,repr(s))

    if len(s) > 2:
        if changed:
            if not s.startswith('* '):
                title = "* " + s
                self.setTabText(i,title)
        else:
            if s.startswith('* '):
                title = s[2:]
                self.setTabText(i,title)
#@-node:ekr.20100101104934.3662:setChanged
#@-node:ekr.20100101104934.3661:Changed
#@-node:ekr.20100101104934.3657:Update tab names when the commander is dirty
#@+node:ekr.20100101172327.3660:Made @nowrap work
#@+node:ekr.20081121105001.207: ctor (qtBody)
def __init__ (self,frame,parentFrame):

    trace = False and not g.unitTesting

    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)

    c = self.c
    assert c.frame == frame and frame.c == c

    self.useScintilla = c.config.getBool('qt-use-scintilla')
    self.selectedBackgroundColor = c.config.getString('selected-background-color')
    self.unselectedBackgroundColor = c.config.getString('unselected-background-color')

    # Set the actual gui widget.
    if self.useScintilla:
        self.widget = w = leoQScintillaWidget(
            c.frame.top.textEdit,
            name='body',c=c)
        self.bodyCtrl = w # The widget as seen from Leo's core.
        self.colorizer = leoColor.nullColorizer(c)
    else:
        top = c.frame.top
        sw = top.ui.stackedWidget
        qtWidget = top.ui.richTextEdit # A QTextEdit or QTextBrowser.
        # g.trace(qtWidget)
        sw.setCurrentIndex(1)
        self.widget = w = leoQTextEditWidget(
            qtWidget,name = 'body',c=c)
        self.bodyCtrl = w # The widget as seen from Leo's core.

        # Hook up the QSyntaxHighlighter
        self.colorizer = leoQtColorizer(c,w.widget)
        qtWidget.setAcceptRichText(False)

    # Config stuff.
    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    self.setWrap(c.p)

    # For multiple body editors.
    self.editor_name = None
    self.editor_v = None
    self.numberOfEditors = 1
    self.totalNumberOfEditors = 1

    if trace: print('qtBody.__init__ %s' % self.widget)
#@+node:ekr.20100101172327.3661:setWrap (qtBody)
def setWrap (self,p):

    if not p: return
    if self.useScintilla: return

    c = self.c
    w = c.frame.body.widget.widget
    d = c.scanAllDirectives(p)
    if d is None: return
    wrap = d.get('wrap')
    w.setWordWrapMode(
        g.choose(wrap,
            QtGui.QTextOption.WordWrap,
            QtGui.QTextOption.NoWrap))
#@-node:ekr.20100101172327.3661:setWrap (qtBody)
#@+node:ekr.20081121105001.208:createBindings (qtBody)
def createBindings (self,w=None):

    '''(qtBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''

    # frame = self.frame ; c = self.c ; k = c.k
    # if not w: w = self.widget

    # c.bind(w,'<Key>', k.masterKeyHandler)

    # table = [
        # ('<Button-1>',  frame.OnBodyClick,          k.masterClickHandler),
        # ('<Button-3>',  frame.OnBodyRClick,         k.masterClick3Handler),
        # ('<Double-1>',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        # ('<Double-3>',  None,                       k.masterDoubleClick3Handler),
        # ('<Button-2>',  frame.OnPaste,              k.masterClickHandler),
    # ]

    # table2 = (
        # ('<Button-2>',  frame.OnPaste,              k.masterClickHandler),
    # )

    # if c.config.getBool('allow_middle_button_paste'):
        # table.extend(table2)

    # for kind,func,handler in table:
        # def bodyClickCallback(event,handler=handler,func=func):
            # return handler(event,func)

        # c.bind(w,kind,bodyClickCallback)
#@-node:ekr.20081121105001.208:createBindings (qtBody)
#@+node:ekr.20081121105001.209:get_name
def getName (self):

    return 'body-widget'
#@-node:ekr.20081121105001.209:get_name
#@-node:ekr.20081121105001.207: ctor (qtBody)
#@+node:ekr.20081121105001.285:setWrap (qtFrame)
def setWrap (self,p):

    self.c.frame.body.setWrap(p)
#@-node:ekr.20081121105001.285:setWrap (qtFrame)
#@-node:ekr.20100101172327.3660:Made @nowrap work
#@-node:ekr.20090813101852.3643:Bugs
#@-node:ekr.20090717095154.3729:Leo 4.7 devel projects
#@-all
#@nonl
#@-node:ekr.20081121105001.147:@thin qtNotes.txt
#@-leo
