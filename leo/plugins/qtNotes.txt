#@+leo-ver=4-thin
#@+node:ekr.20081121105001.147:@thin qtNotes.txt
#@+all
#@+node:ekr.20081121105001.148: qt To do
@nocolor-node

First:

- Add traces for focus.
    - Is the "cute hack" causing problems?

- Support hoist in redraw code.

- Change background color of body pane depending on focus.
  Set focus in/out events.
http://groups.google.com/group/leo-editor/browse_thread/thread/1cce885a697d0236/5aea5d0587b47b92?lnk=gst&q=command+and+insert#5aea5d0587b47b92

Next:
- DnD nodes.
- Can key strokes be handled in log pane?
- Disabling searches of body pane can cause hard crashes.
    - initInteractiveCommands expects c.edit_widget(p)to exist.
- Allow coloring of icon bar buttons.
- Support multiple body editors.


#@+node:ekr.20081124094918.1:Fix problems with scim
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/59c1e5d6acaf4de0

I've some more information about the problems with accent previously
reported:
- I can confirm that they are caused by the interaction scim+leo (with
and without the qt plugin). If scim is not started leo works fine. If
scim is running the problems appear and are slightly different with
and without the qt plugin. The workaround is obvious: don't use leo
and scim at the same time :-)
- accents are not working in the qt plugin when scintilla is used. If
qt-use-scintilla=False I can write this:

àáä (the same for the rest of vowels)

but if qt-use-scintilla=True when I enter the same sequence in the
keyboard I get:

`aaa (the same for the rest of vowels)

- the problem with the ñ character (reported previously too) is only
present in the qt plugin (both with and without scintilla)
#@-node:ekr.20081124094918.1:Fix problems with scim
#@+node:ekr.20081121105001.151:Finally/maybe
- Can style sheets really do the job?
- Flash characters without changing the selection?
- Remove old-style Leo settings?
- Add stylesheets for dialogs.
    - Set font for dummy widget in style sheet, then copy that font.
#@+node:ekr.20081121105001.150:QScintilla stuff
- Check event handling with QScintilla.
- Experiment with sending <shift-tab> directly to QScintilla.
- Call setLexer(0) for nocolor nodes.
- Add settings for syntax coloring.
- Make Scintilla handle Leo markup.
- Install new Qt version and play with QScintilla.
    From QScintilla change log:
    2008/10/12 14:32:05  phil
    QsciScintilla::setSelection() is now implemented using SCI_SETSEL so that the
    carat can be left at either the start or the end of the selection.
    Exposed QsciScintilla::positionFromLineIndex() and
    QsciScintilla::lineIndexFromPosition().
    - Fix problem with accented characters: see child node for notes.
#@nonl
#@-node:ekr.20081121105001.150:QScintilla stuff
#@-node:ekr.20081121105001.151:Finally/maybe
#@-node:ekr.20081121105001.148: qt To do
#@+node:ekr.20081121105001.185:Scripts
#@+node:ekr.20081121105001.186:Script to display Qt font database
import PyQt4.QtGui as QtGui

db = QtGui.QFontDatabase()
for family in db.families():
    print family
    for style in db.styles(family):
        print '\t',style,db.smoothSizes(family,style)
#@-node:ekr.20081121105001.186:Script to display Qt font database
#@+node:ekr.20081121105001.187:dump guiBindNamesInverseDict
print g.dictToString(c.k.guiBindNamesInverseDict)

@
   BackSpace: 'BackSpace'
       Begin: 'Begin'
       Break: 'Break'
   Caps_Lock: 'Caps_Lock'
       Clear: 'Clear'
      Delete: 'Delete'
        Down: 'Down'
         End: 'End'
      Escape: 'Escape'
          F1: 'F1'
         F10: 'F10'
         F11: 'F11'
         F12: 'F12'
          F2: 'F2'
          F3: 'F3'
          F4: 'F4'
          F5: 'F5'
          F6: 'F6'
          F7: 'F7'
          F8: 'F8'
          F9: 'F9'
        Home: 'Home'
        Left: 'Left'
    Linefeed: 'Linefeed'
        Next: 'Next'
    Num_Lock: 'Num_Lock'
       Prior: 'Prior'
      Return: 'Return'
       Right: 'Right'
         Tab: 'Tab'
          Up: 'Up'
   ampersand: '&'
 asciicircum: '^'
  asciitilde: '~'
    asterisk: '*'
          at: '@'
   backslash: '\\'
         bar: '|'
   braceleft: '{'
  braceright: '}'
 bracketleft: '['
bracketright: ']'
       colon: ':'
       comma: ','
      dollar: '$'
       equal: '='
      exclam: '!'
     greater: '>'
        less: '<'
       minus: '-'
  numbersign: '#'
   parenleft: '('
  parenright: ')'
     percent: '%'
      period: '.'
        plus: '+'
    question: '?'
    quotedbl: '"'
   quoteleft: '`'
  quoteright: "'"
   semicolon: ';'
       slash: '/'
       space: ' '
  underscore: '_'
#@nonl
#@-node:ekr.20081121105001.187:dump guiBindNamesInverseDict
#@-node:ekr.20081121105001.185:Scripts
#@+node:ekr.20081208155215.12:Unused
#@+node:ekr.20081121105001.423:removeFromDicts (not needed!)
if 0: # not needed if we recompute all dicts.

    def removeFromDicts (self,p,item):

        '''Remove all items associated with p from the drawing dicts.'''

        # Remove entries from item dicts.
        if item:
            table = (
                self.item2parentItemDict,
                self.item2tnodeDict,
                self.item2vnodeDict,
                self.item2positionDict)

            for d in table:
                if item in d:
                    del d[item]

        # Remove positions from vnode/tnode dicts.
        if p:
            table = (
                (p.v.t,self.tnode2dataDict),
                (p.v  ,self.vnode2dataDict))

            for key,d in table:
                aList = d.get(key,[])
                if aList:
                    aList = [z for p2,item in aList if p2 != p]
                    d[key] = aList
#@-node:ekr.20081121105001.423:removeFromDicts (not needed!)
#@+node:ekr.20081209211810.12:updateTreeDicts (not needed!)
if 0: # Not needed: we never process an entire tree at once.

    def updateTreeDicts (self,p,parent_item,item):

        '''Update the dicts for unchanged/moved parts of the tree.'''

        self.updateDicts(p,parent_item,item)

        child_items = self.childItems(parent_item)
        chilren = [z for z in p.children_iter()]

        if len(child_items)== len(children):
            for p2,item2 in zip(children,child_items):
                self.updateTreeDicts(p2,item,item2)
        else:
            self.oops('len(child_items): %s, len(chilren): %s' % (
                len(child_items),len(chilren)))




#@-node:ekr.20081209211810.12:updateTreeDicts (not needed!)
#@+node:ekr.20081208072750.20:redraw_after... (not used)
if 0:
    @others
#@nonl
#@+node:ekr.20081121105001.419:redraw_after_clone
def redraw_after_clone (self):

    self.full_redraw()
#@-node:ekr.20081121105001.419:redraw_after_clone
#@+node:ekr.20081121105001.420:redraw_after_contract
def redraw_after_contract (self):

    self.full_redraw()
#@-node:ekr.20081121105001.420:redraw_after_contract
#@+node:ekr.20081121105001.421:redraw_after_delete
def redraw_after_delete (self):

    self.full_redraw()


#@-node:ekr.20081121105001.421:redraw_after_delete
#@+node:ekr.20081121105001.422:redraw_after_expand & helper
def redraw_after_expand (self):

    # This is reasonable now that we only allocate
    # one dummy node in collapsed trees.
    return self.full_redraw()
#@-node:ekr.20081121105001.422:redraw_after_expand & helper
#@+node:ekr.20081121105001.424:redraw_after_icons_changed
def redraw_after_icons_changed (self,all=False):

    g.trace('should not be called',g.callers(4))

    pass

    # c = self.c ; p = c.currentPosition()

    # if all:
        # self.full_redraw()
    # else:
        # self.updateIcon(p)


#@-node:ekr.20081121105001.424:redraw_after_icons_changed
#@+node:ekr.20081121105001.425:redraw_after_insert
def redraw_after_insert (self):

    self.full_redraw()
#@-node:ekr.20081121105001.425:redraw_after_insert
#@+node:ekr.20081121105001.426:redraw_after_move_down
def redraw_after_move_down (self):

    self.full_redraw()
#@nonl
#@-node:ekr.20081121105001.426:redraw_after_move_down
#@+node:ekr.20081121105001.427:redraw_after_move_left
def redraw_after_move_left (self):

    self.full_redraw()
#@nonl
#@-node:ekr.20081121105001.427:redraw_after_move_left
#@+node:ekr.20081121105001.428:redraw_after_move_right
def redraw_after_move_right (self):

    self.full_redraw()
#@-node:ekr.20081121105001.428:redraw_after_move_right
#@+node:ekr.20081121105001.429:redraw_after_move_up
def redraw_after_move_up (self):

    self.full_redraw()
#@-node:ekr.20081121105001.429:redraw_after_move_up
#@+node:ekr.20081121105001.430:redraw_after_select
def redraw_after_select (self):

    '''Redraw the screen after selecting a node.'''

    pass # It is quite wrong to do an automatic redraw after select.
#@-node:ekr.20081121105001.430:redraw_after_select
#@-node:ekr.20081208072750.20:redraw_after... (not used)
#@+node:ekr.20081209064740.14:partial_redraw_stub
def partial_redraw_stub (self):

    '''Print what partial_redraw would do if it were functional.'''

    # Called from full_redraw.
    # initData and expandAllAncestors have already been called.

    c = self.c ; p = c.rootPosition()

    if not use_partial_redraw: return

    self.updateTree(p,parent_item=None)
#@-node:ekr.20081209064740.14:partial_redraw_stub
#@+node:ekr.20081209064740.17:createDummyChildItem (not used)
def createDummyChildItem (self,p,parent_item):

    '''Create a dummy child item if the parent item does not have children.

    This ensures the parent's expansion box is correctly set.'''

    trace = False
    h = 'dummy child of %s' % p.headString()
    n = parent_item.childCount()

    if trace: g.trace(n,h)

    if n == 0:
        p2 = p.copy()
        p2.setHeadString(h)
        self.drawNode(p2,parent_item,dummy=True)

#@-node:ekr.20081209064740.17:createDummyChildItem (not used)
#@+node:ekr.20081211060950.17:rememberPosition
def rememberPosition (self,p,item):

    # The following dicts are used only by event handlers.
    # They are *not* to be used by the incremental drawing code!

    # Remember the position, vnode and tnode of each item.
    self.item2positionDict[item] = p.copy()

    # Remember list of all (p,item) for each v.
    aList = self.vnode2dataDict.get(p.v,[])
    data = p.copy(),item
    aList.append(data)
    self.vnode2dataDict[p.v] = aList

    # Remember list all (p,item) for each t.
    aList = self.tnode2dataDict.get(p.v.t,[])
    data = p.copy(),item
    aList.append(data)
    self.tnode2dataDict[p.v.t] = aList
#@-node:ekr.20081211060950.17:rememberPosition
#@+node:ekr.20081209210556.2:updateDicts (was used in full_redraw)
def updateDicts (self,p,parent_item,item):

    # Important: the item2vnodeDict is *not* cleared by initData.
    # Entries in this dict are persistent.

    self.item2vnodeDict[item] = p.v

    # Important: the following dicts are used only by event handlers.
    # They are *not* to be used by the incremental drawing code!

    # Remember the position, vnode and tnode of each item.
    self.item2positionDict[item] = p.copy()

    # Remember list of all (p,item) for each v.
    aList = self.vnode2dataDict.get(p.v,[])
    data = p.copy(),item
    aList.append(data)
    self.vnode2dataDict[p.v] = aList

    # Remember list all (p,item) for each t.
    aList = self.tnode2dataDict.get(p.v.t,[])
    data = p.copy(),item
    aList.append(data)
    self.tnode2dataDict[p.v.t] = aList
#@-node:ekr.20081209210556.2:updateDicts (was used in full_redraw)
#@+node:ekr.20081213093110.17:position2item (old)
def position2item (self,p):
    '''Return the unique item associated with position p.'''
    aList = self.vnode2dataDict.get(p.v,[])
    for p2,item2 in aList:
        if p == p2:
            item = item2 ; break
    else:
        item = None
    return item
#@-node:ekr.20081213093110.17:position2item (old)
#@-node:ekr.20081208155215.12:Unused
#@-all
#@nonl
#@-node:ekr.20081121105001.147:@thin qtNotes.txt
#@-leo
