#@+leo-ver=5-thin
#@+node:ekr.20081121105001.147: * @file qtNotes.txt
#@+all
#@+node:ekr.20081121105001.148: **  qt To do
#@+node:ekr.20101101111704.3761: *3* Remove or complete x.createBindings
#@+node:ekr.20100223133144.3680: *3* Create color picker
createColorPicker
#@+node:ekr.20100223114506.3699: *3* Support cascade menu
leoQtFrame.cascade.
#@+node:ekr.20081121105001.306: *4* cascade
def cascade (self,event=None):

    '''Cascade all Leo windows.'''

    x,y,delta = 50,50,50
    for frame in g.app.windowList:

        w = frame and frame.top
        if w:
            r = w.geometry() # a Qt.Rect
            w.setGeometry(x,y,r.width(),r.height())

            # Compute the new offsets.
            x += 30 ; y += 30
            if x > 200:
                x = 10 + delta ; y = 40 + delta
                delta += 10
#@+node:ekr.20100223114506.3698: *3* Should leoQtMenu.index do something?
#@+node:ekr.20081215162017.4: *3* Allow coloring of script buttons
@nocolor-node

Use @string qt-button-color = lightSteelBlue

The following does *not* work in @data qt-gui-plugin-style-sheet::

    QPushButton {
        background-color: red;
    }
#@+node:ekr.20081124094918.1: *3* Fix problems with scim
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/59c1e5d6acaf4de0

I've some more information about the problems with accent previously
reported:
- I can confirm that they are caused by the interaction scim+leo (with
and without the qt plugin). If scim is not started leo works fine. If
scim is running the problems appear and are slightly different with
and without the qt plugin. The workaround is obvious: don't use leo
and scim at the same time :-)
- accents are not working in the qt plugin when scintilla is used. If
qt-use-scintilla=False I can write this:

àáä (the same for the rest of vowels)

but if qt-use-scintilla=True when I enter the same sequence in the
keyboard I get:

`aaa (the same for the rest of vowels)

- the problem with the ñ character (reported previously too) is only
present in the qt plugin (both with and without scintilla)
#@+node:ekr.20110119065600.3895: ** Leo 4.9 devel
#@+node:ekr.20110117083659.3792: *3* Allow multiple @language directives
@nocolor-node

Added match_at_language.
#@+node:ekr.20110117083659.3791: *4* match_at_language
def match_at_language (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    seq = '@language'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        j = i + len(seq)
        j = g.skip_ws(s,j)
        k = g.skip_c_id(s,j)
        name = s[j:k]
        ok = self.init_mode(name)
        # g.trace(ok,name)
        if ok:
            self.colorRangeWithTag(s,i,k,'leoKeyword')
        else:
            self.colorRangeWithTag(s,i,j,'leoKeyword')
        self.clearState()
        return k - i
    else:
        return 0
#@+node:ekr.20110120112425.12505: *3* Remember size of tabbed frame
@nocolor-node

For --gui==qttabs:
    
c.frame.top             is a DynamicWindow
c.frame.top.master      is a LeoTabbedTopLevel
g.app.gui.frameFactory  is a TabbedFrameFactory
#@+node:ville.20090804182114.8400: *4* class LeoTabbedTopLevel (QtGui.QTabWidget)
class LeoTabbedTopLevel(QtGui.QTabWidget):
    """ Toplevel frame for tabbed ui """

    @others
#@+node:tbrown.20110219092516.15291: *5* __init__
def __init__(self, *args, **kwargs):
    
    self.factory = kwargs['factory']
    del kwargs['factory']
    QtGui.QTabWidget.__init__(self)
    self.detached = []
    
    self.setMovable(True)
    
    def tabContextMenu(point):
        index = self.tabBar().tabAt(point)
        if index < 0 or (self.count() < 2 and not self.detached):
            return
        
        menu = QtGui.QMenu()
    
        if self.count() > 1:
            a = menu.addAction("Detach")
            a.connect(a, QtCore.SIGNAL("triggered()"), lambda: self.detach(index))
        if self.detached:
            a = menu.addAction("Re-attach All")
            a.connect(a, QtCore.SIGNAL("triggered()"), self.reattach_all)
        
        menu.exec_(self.mapToGlobal(point))
    
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.connect(self,
        QtCore.SIGNAL("customContextMenuRequested(QPoint)"), tabContextMenu)
#@+node:tbrown.20110219092516.19433: *5* detach
def detach(self, index):
    """detach tab (from tab's context menu)"""
    w = self.widget(index)
    self.detached.append((self.tabText(index), w))
    self.factory.detachTab(w)
#@+node:tbrown.20110219092516.19434: *5* reattach_all
def reattach_all(self):
    """reattach all detached tabs"""
    for name, w in self.detached:
        self.addTab(w, name)
        self.factory.leoFrames[w] = w.leo_c.frame
    self.detached = []
#@+node:tbrown.20110219092516.19435: *5* delete
def delete(self, w):
    """called by TabbedFrameFactory to tell us a detached tab
    has been deleted"""
    self.detached = [i for i in self.detached if i[1] != w]
#@+node:ekr.20100101104934.3662: *5* setChanged
def setChanged (self,c,changed):
    
    # 2011/03/01: Find the tab corresponding to c.
    dw = c.frame.top # A DynamicWindow
    i = self.indexOf(dw)
    if i < 0: return

    s = self.tabText(i)
    s = g.u(s)
    # g.trace('LeoTabbedTopLevel',changed,repr(s),g.callers(5))

    if len(s) > 2:
        if changed:
            if not s.startswith('* '):
                title = "* " + s
                self.setTabText(i,title)
        else:
            if s.startswith('* '):
                title = s[2:]
                self.setTabText(i,title)
#@+node:ekr.20100119113742.3714: *5* setTabName (LeoTabbedTopLevel)
def setTabName (self,c,fileName):

    '''Set the tab name for c's tab to fileName.'''

    # Find the tab corresponding to c.
    dw = c.frame.top # A DynamicWindow
    i = self.indexOf(dw)
    if i > -1:
        self.setTabText(i,g.shortFileName(fileName))
#@+node:ville.20090804182114.8401: *5* closeEvent (leoTabbedTopLevel)
def closeEvent(self, event):

    noclose = False
    for c in g.app.commanders():
        res = c.exists and g.app.closeLeoWindow(c.frame)
        if not res:
            noclose = True

    if noclose:
        event.ignore()
    else:            
        event.accept()
#@+node:ekr.20110301080146.13980: *5* select (leoTabbedTopLevel)
def select (self,c):

    '''Select the tab for c.'''
    
    dw = c.frame.top # A DynamicWindow
    i = self.indexOf(dw)
    self.setCurrentIndex(i)
    # g.trace(i,dw)
#@+node:ekr.20110122055506.12568: *5* setLeoWindowSize (LeoTabbedTopLevel)
def setLeoWindowSize (self,rect):
    
    if not hasattr(self,'leo_inited'):
        # g.trace('(LeoTabbedTopLevel)',rect)
        self.leo_inited = True
        self.setGeometry(rect)
#@+node:ville.20090803130409.3685: *4* class TabbedFrameFactory
class TabbedFrameFactory:
    """ 'Toplevel' frame builder for tabbed toplevel interface

    This causes Leo to maintain only one toplevel window,
    with multiple tabs for documents
    """

    @others
#@+node:ville.20090803132402.3685: *5* ctor (TabbedFrameFactory)
def __init__(self):

    # will be created when first frame appears 

    # DynamicWindow => Leo frame map
    self.alwaysShowTabs = True
        # Set to true to workaround a problem
        # setting the window title when tabs are shown.
    self.leoFrames = {}
        # Keys are DynamicWindows, values are frames.
    self.masterFrame = None
    self.createTabCommands()
    
    # g.trace('(TabbedFrameFactory)',g.callers())
#@+node:ekr.20100101104934.3658: *5* createFrame (TabbedFrameFactory)
def createFrame(self, leoFrame):

    # g.trace('(TabbedFrameFactory)')

    c = leoFrame.c
    if self.masterFrame is None:
        self.createMaster()
    tabw = self.masterFrame
    dw = DynamicWindow(c,tabw)
    self.leoFrames[dw] = leoFrame

    # Shorten the title.
    fname = c.mFileName
    if fname:
        title = os.path.basename(fname)
    else:
        title = leoFrame.title
    tip = leoFrame.title

    dw.setWindowTitle(tip) # 2010/1/1
    idx = tabw.addTab(dw, title)
    if tip: tabw.setTabToolTip(idx, tip)

    dw.construct(master=tabw)
    tabw.setCurrentIndex(idx)            

    # Work around the problem with missing dirty indicator
    # by always showing the tab.
    tabw.tabBar().setVisible(
        self.alwaysShowTabs or tabw.count() > 1)

    dw.show()
    tabw.show()
    return dw
#@+node:ekr.20100101104934.3659: *5* deleteFrame
def deleteFrame(self, wdg):    
    if wdg not in self.leoFrames:
        # probably detached tab
        self.masterFrame.delete(wdg)
        return
    tabw = self.masterFrame
    idx = tabw.indexOf(wdg)
    tabw.removeTab(idx)
    del self.leoFrames[wdg]
    tabw.tabBar().setVisible(
        self.alwaysShowTabs or tabw.count() > 1)
#@+node:ville.20090803132402.3684: *5* createMaster (TabbedFrameFactory)
def createMaster(self):
    mf = self.masterFrame = LeoTabbedTopLevel(factory=self)
    #g.trace('(TabbedFrameFactory) (sets tabbed geom)')
    g.app.gui.attachLeoIcon(mf)
    tabbar = mf.tabBar()

    try:
        tabbar.setTabsClosable(True)
        tabbar.connect(tabbar,
            QtCore.SIGNAL('tabCloseRequested(int)'),
            self.slotCloseRequest)
    except AttributeError:
        pass # Qt 4.4 does not support setTabsClosable

    mf.connect(mf,
        QtCore.SIGNAL('currentChanged(int)'),
        self.slotCurrentChanged)

    if g.app.start_minimized:
        mf.showMinimized()
    elif g.app.start_maximized:
        mf.showMaximized()
    elif g.app.start_fullscreen:
        mf.showFullScreen()
    else:
        mf.show()
#@+node:ekr.20110123112957.12593: *5* setTabForCommander (TabbedFrameFactory)
def setTabForCommander (self,c):
    
    tabw = self.masterFrame # a QTabWidget
    for dw in self.leoFrames: # A dict whose keys are DynamicWindows.
        if dw.leo_c == c:
            for i in range(tabw.count()):
                if tabw.widget(i) == dw:
                    tabw.setCurrentIndex(i)
                    break
            break
            
#@+node:ekr.20100101104934.3660: *5* signal handlers
def slotCloseRequest(self,idx):
    tabw = self.masterFrame
    w = tabw.widget(idx)
    f = self.leoFrames[w]
    c = f.c
    c.close()

def slotCurrentChanged(self, idx):
    tabw = self.masterFrame
    w = tabw.widget(idx)
    f = self.leoFrames.get(w)
    if f:
        # g.trace(f and f.title or '<no frame>')
        tabw.setWindowTitle(f.title)
#@+node:ville.20090803201708.3694: *5* focusCurrentBody
def focusCurrentBody(self):
    """ Focus body control of current tab """
    tabw = self.masterFrame
    w = tabw.currentWidget()
    w.setFocus()
    f = self.leoFrames[w]
    c = f.c
    c.bodyWantsFocusNow()
    # Fix bug 690260: correct the log.
    g.app.log = f.log
#@+node:ville.20090803164510.3688: *5* createTabCommands
def detachTab(self, wdg):
    """ Detach specified tab as individual toplevel window """

    del self.leoFrames[wdg]
    wdg.setParent(None)
    wdg.show()

def createTabCommands(self):
    << Commands for tabs >>




#@+node:ville.20090803184912.3685: *6* << Commands for tabs >>
@g.command('tab-detach')
def tab_detach(event):
    """ Detach current tab from tab bar """
    if len(self.leoFrames) < 2:
        g.es_print_error("Can't detach last tab")
        return

    c = event['c']
    f = c.frame
    self.detachTab(f.top)
    f.top.setWindowTitle(f.title + ' [D]')

# this is actually not tab-specific, move elsewhere?
@g.command('close-others')
def close_others(event):
    myc = event['c']
    for c in g.app.commanders():
        if c is not myc:
            c.close()

def tab_cycle(offset):
    tabw = self.masterFrame
    cur = tabw.currentIndex()
    count = tabw.count()
    # g.es("cur: %s, count: %s, offset: %s" % (cur,count,offset))
    cur += offset
    if cur < 0:
        cur = count -1
    elif cur >= count:
        cur = 0
    tabw.setCurrentIndex(cur)
    self.focusCurrentBody()

@g.command('tab-cycle-next')
def tab_cycle_next(event):
    """ Cycle to next tab """
    tab_cycle(1)

@g.command('tab-cycle-previous')
def tab_cycle_previous(event):
    """ Cycle to next tab """
    tab_cycle(-1)
#@+node:ekr.20081121105001.200: *4* class  DynamicWindow (QtGui.QMainWindow)
from PyQt4 import uic

class DynamicWindow(QtGui.QMainWindow):

    '''A class representing all parts of the main Qt window
    as created by Designer.

    c.frame.top is a DynamciWindow object.

    For --gui==qttabs:
        c.frame.top.parent is a TabbedFrameFactory
        c.frame.top.master is a LeoTabbedTopLevel

    All leoQtX classes use the ivars of this Window class to
    support operations requested by Leo's core.
    '''

    @others

#@+node:ekr.20081121105001.201: *5*  ctor (DynamicWindow)
# Called from leoQtFrame.finishCreate.

def __init__(self,c,parent=None):

    '''Create Leo's main window, c.frame.top'''
    
    # For qttabs gui, parent is a LeoTabbedTopLevel.

    # g.trace('(DynamicWindow)',g.callers())

    QtGui.QMainWindow.__init__(self,parent)

    self.leo_c = c
#@+node:ville.20090806213440.3689: *5* construct (DynamicWindow)
def construct(self,master=None):
    """ Factor 'heavy duty' code out from ctor """

    c = self.leo_c; top = c.frame.top
    self.master=master # A LeoTabbedTopLevel for tabbed windows.
    # g.trace('(DynamicWindow)',g.callers())

    # Init the base class.
    ui_file_name = c.config.getString('qt_ui_file_name')
    if not ui_file_name:
        ui_file_name = 'qt_main.ui'

    ui_description_file = g.app.loadDir + "/../plugins/" + ui_file_name
    # g.pr('DynamicWindw.__init__,ui_description_file)
    assert g.os_path_exists(ui_description_file)

    self.bigTree = c.config.getBool('big_outline_pane')

    if useUI:  
        self.ui = uic.loadUi(ui_description_file, self)
    else:
        self.createMainWindow()


    self.iconBar = self.addToolBar("IconBar")

    # Set orientation if requested.
    d = {
        'bottom':QtCore.Qt.BottomToolBarArea,
        'left':QtCore.Qt.LeftToolBarArea,
        'right':QtCore.Qt.RightToolBarArea,
        'top':QtCore.Qt.TopToolBarArea,
    }
    where = c.config.getString('qt-toolbar-location')
    # g.trace(where)
    if where:
        where = d.get(where)
        if where: self.addToolBar(where,self.iconBar)
    self.menubar = self.menuBar()
    self.statusBar = QtGui.QStatusBar()
    self.setStatusBar(self.statusBar)

    orientation = c.config.getString('initial_split_orientation')
    self.setSplitDirection(orientation)
    self.setStyleSheets()
    #self.setLeoWindowIcon()
#@+node:ekr.20081121105001.202: *5* closeEvent (DynanicWindow)
def closeEvent (self,event):

    trace = False and not g.unitTesting
    c = self.leo_c

    if not c.exists:
        # Fixes double-prompt bug on Linux.
        if trace: g.trace('destroyed')
        event.accept()
        return

    if c.inCommand:
        if trace: g.trace('in command')
        c.requestCloseWindow = True
    else:
        if trace: g.trace('closing')
        ok = g.app.closeLeoWindow(c.frame)
        if ok:
            event.accept()
        else:
            event.ignore()
#@+node:ekr.20090423070717.14: *5* createMainWindow & helpers
# Called instead of uic.loadUi(ui_description_file, self)

def createMainWindow (self):

    '''Create the component ivars of the main window.

    Copied/adapted from qt_main.py'''

    MainWindow = self
    self.ui = self

    self.setMainWindowOptions()
    self.createCentralWidget()
    self.createMainLayout(self.centralwidget)
        # Creates .verticalLayout, .splitter and .splitter_2.
    # g.trace(self.bigTree)
    if self.bigTree:
        self.createBodyPane(self.splitter)
        self.createLogPane(self.splitter)
        treeFrame = self.createOutlinePane(self.splitter_2)
        self.splitter_2.addWidget(treeFrame)
        self.splitter_2.addWidget(self.splitter)
    else:
        self.createOutlinePane(self.splitter)
        self.createLogPane(self.splitter)
        self.createBodyPane(self.splitter_2)
    self.createMiniBuffer(self.centralwidget)
    self.createMenuBar()
    self.createStatusBar(MainWindow)

    # Signals
    QtCore.QMetaObject.connectSlotsByName(MainWindow)
#@+node:ekr.20090426183711.10: *6* top-level
#@+node:ekr.20090424085523.43: *7* createBodyPane
def createBodyPane (self,parent):

    # Create widgets.
    bodyFrame = self.createFrame(parent,'bodyFrame')
    innerFrame = self.createFrame(bodyFrame,'innerBodyFrame',
        hPolicy=QtGui.QSizePolicy.Expanding)
    sw = self.createStackedWidget(innerFrame,'bodyStackedWidget')
    page2 = QtGui.QWidget()
    self.setName(page2,'bodyPage2')
    body = self.createText(page2,'richTextEdit')

    # Pack.
    vLayout = self.createVLayout(page2,'bodyVLayout',spacing=6)
    grid = self.createGrid(bodyFrame,'bodyGrid')
    innerGrid = self.createGrid(innerFrame,'bodyInnerGrid')
    vLayout.addWidget(body)
    sw.addWidget(page2)
    innerGrid.addWidget(sw, 0, 0, 1, 1)
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    self.verticalLayout.addWidget(parent)

    # Official ivars
    self.text_page = page2
    self.stackedWidget = sw # used by leoQtBody
    self.richTextEdit = body
    self.leo_body_frame = bodyFrame
    self.leo_body_inner_frame = innerFrame
    # self.leo_body_grid = grid
    # self.grid = innerGrid
    # self.page_2 = page2
    # self.verticalBodyLayout= vLayout
#@+node:ekr.20090425072841.12: *7* createCentralWidget
def createCentralWidget (self):

    MainWindow = self

    w = QtGui.QWidget(MainWindow)
    w.setObjectName("centralwidget")

    MainWindow.setCentralWidget(w)

    # Official ivars.
    self.centralwidget = w
#@+node:ekr.20090424085523.42: *7* createLogPane
def createLogPane (self,parent):

    # Create widgets.
    logFrame = self.createFrame(parent,'logFrame',
        vPolicy = QtGui.QSizePolicy.Minimum)
    innerFrame = self.createFrame(logFrame,'logInnerFrame',
        hPolicy=QtGui.QSizePolicy.Preferred,
        vPolicy=QtGui.QSizePolicy.Expanding)
    tabWidget = self.createTabWidget(innerFrame,'logTabWidget')

    # Pack.
    innerGrid = self.createGrid(innerFrame,'logInnerGrid')
    innerGrid.addWidget(tabWidget, 0, 0, 1, 1)
    outerGrid = self.createGrid(logFrame,'logGrid')
    outerGrid.addWidget(innerFrame, 0, 0, 1, 1)

    findTab = QtGui.QWidget()
    findTab.setObjectName('findTab')
    tabWidget.addTab(findTab,'Find')
    self.createFindTab(findTab)

    spellTab = QtGui.QWidget()
    spellTab.setObjectName('spellTab')
    tabWidget.addTab(spellTab,'Spell')
    self.createSpellTab(spellTab)

    tabWidget.setCurrentIndex(1)

    # Official ivars
    self.tabWidget = tabWidget # Used by leoQtLog.
    # self.leo_log_frame = logFrame
    # self.leo_log_grid = outerGrid
    # self.findTab = findTab
    # self.spellTab = spellTab
    # self.leo_log_inner_frame = innerFrame
    # self.leo_log_inner_grid = innerGrid
#@+node:ekr.20090424085523.41: *7* createMainLayout (DynamicWindow)
def createMainLayout (self,parent):

    c = self.leo_c

    vLayout = self.createVLayout(parent,'mainVLayout',margin=3)

    # Splitter two is the "main" splitter, containing splitter.
    splitter2 = splitter_class(parent)
    splitter2.setOrientation(QtCore.Qt.Vertical)
    splitter2.setObjectName("splitter_2")

    splitter2.connect(splitter2,
        QtCore.SIGNAL("splitterMoved(int,int)"),
        self.onSplitter2Moved)

    splitter = splitter_class(splitter2)
    splitter.setOrientation(QtCore.Qt.Horizontal)
    splitter.setObjectName("splitter")

    splitter.connect(splitter,
        QtCore.SIGNAL("splitterMoved(int,int)"),
        self.onSplitter1Moved)

    # g.trace('splitter %s splitter2 %s' % (id(splitter),id(splitter2)))

    # Official ivars
    self.verticalLayout = vLayout
    self.splitter = splitter
    self.splitter_2 = splitter2

    self.setSizePolicy(self.splitter)
    self.verticalLayout.addWidget(self.splitter_2)
#@+node:ekr.20090424085523.45: *7* createMenuBar
def createMenuBar (self):

    MainWindow = self

    w = QtGui.QMenuBar(MainWindow)
    w.setGeometry(QtCore.QRect(0, 0, 957, 22))
    w.setObjectName("menubar")

    MainWindow.setMenuBar(w)

    # Official ivars.
    self.menubar = w
#@+node:ekr.20090424085523.44: *7* createMiniBuffer
def createMiniBuffer (self,parent):

    # Create widgets.
    frame = self.createFrame(self.centralwidget,'minibufferFrame',
        hPolicy = QtGui.QSizePolicy.MinimumExpanding,
        vPolicy = QtGui.QSizePolicy.Fixed)
    frame.setMinimumSize(QtCore.QSize(100, 0))
    label = self.createLabel(frame,'minibufferLabel','Minibuffer:')
    lineEdit = QtGui.QLineEdit(frame)
    lineEdit.setObjectName('lineEdit') # name important.

    # Pack.
    hLayout = self.createHLayout(frame,'minibufferHLayout',spacing=4)
    hLayout.setContentsMargins(3, 2, 2, 0)
    hLayout.addWidget(label)
    hLayout.addWidget(lineEdit)
    self.verticalLayout.addWidget(frame)
    label.setBuddy(lineEdit)

    # Official ivars.
    self.lineEdit = lineEdit
    # self.leo_minibuffer_frame = frame
    # self.leo_minibuffer_layout = layout
#@+node:ekr.20090424085523.47: *7* createOutlinePane
def createOutlinePane (self,parent):

    # Create widgets.
    treeFrame = self.createFrame(parent,'outlineFrame',
        vPolicy = QtGui.QSizePolicy.Expanding)
    innerFrame = self.createFrame(treeFrame,'outlineInnerFrame',
        hPolicy = QtGui.QSizePolicy.Preferred)

    treeWidget = self.createTreeWidget(innerFrame,'treeWidget')

    grid = self.createGrid(treeFrame,'outlineGrid')
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    innerGrid = self.createGrid(innerFrame,'outlineInnerGrid')
    innerGrid.addWidget(treeWidget, 0, 0, 1, 1)

    # Official ivars...
    self.treeWidget = treeWidget
    # self.leo_outline_frame = treeFrame
    # self.leo_outline_grid = grid
    # self.leo_outline_inner_frame = innerFrame

    return treeFrame
#@+node:ekr.20090424085523.46: *7* createStatusBar
def createStatusBar (self,parent):

    w = QtGui.QStatusBar(parent)
    w.setObjectName("statusbar")
    parent.setStatusBar(w)

    # Official ivars.
    self.statusBar = w
#@+node:ekr.20090425072841.2: *7* setMainWindowOptions
def setMainWindowOptions (self):

    MainWindow = self

    MainWindow.setObjectName("MainWindow")
    MainWindow.resize(691, 635)
    MainWindow.setDockNestingEnabled(False)
    MainWindow.setDockOptions(
        QtGui.QMainWindow.AllowTabbedDocks |
        QtGui.QMainWindow.AnimatedDocks)
#@+node:ekr.20090426183711.11: *6* widgets (DynamicWindow)
#@+node:ekr.20090424085523.51: *7* createButton
def createButton (self,parent,name,label):

    w = QtGui.QPushButton(parent)
    w.setObjectName(name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20090424085523.39: *7* createCheckBox
def createCheckBox (self,parent,name,label):

    w = QtGui.QCheckBox(parent)
    self.setName(w,name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20090426083450.10: *7* createContainer (to do)
def createContainer (self,parent):

    pass
#@+node:ekr.20090426083450.11: *7* createFrame
def createFrame (self,parent,name,
    hPolicy=None,vPolicy=None,
    lineWidth = 1,
    shadow = QtGui.QFrame.Plain,
    shape = QtGui.QFrame.NoFrame,
):

    # g.trace(name)
    w = QtGui.QFrame(parent)
    self.setSizePolicy(w,kind1=hPolicy,kind2=vPolicy)
    w.setFrameShape(shape)
    w.setFrameShadow(shadow)
    w.setLineWidth(lineWidth)
    self.setName(w,name)
    return w
#@+node:ekr.20090426083450.12: *7* createGrid
def createGrid (self,parent,name,margin=0,spacing=0):

    w = QtGui.QGridLayout(parent)
    w.setMargin(margin)
    w.setSpacing(spacing)
    self.setName(w,name)
    return w
#@+node:ekr.20090426083450.19: *7* createHLayout & createVLayout
def createHLayout (self,parent,name,margin=0,spacing=0):

    hLayout = QtGui.QHBoxLayout(parent)
    hLayout.setSpacing(spacing)
    hLayout.setMargin(margin)
    self.setName(hLayout,name)
    return hLayout

def createVLayout (self,parent,name,margin=0,spacing=0):

    vLayout = QtGui.QVBoxLayout(parent)
    vLayout.setSpacing(spacing)
    vLayout.setMargin(margin)
    self.setName(vLayout,name)
    return vLayout
#@+node:ekr.20090426083450.14: *7* createLabel
def createLabel (self,parent,name,label):

    w = QtGui.QLabel(parent)
    self.setName(w,name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20090424085523.40: *7* createLineEdit
def createLineEdit (self,parent,name):

    w = QtGui.QLineEdit(parent)
    w.setObjectName(name)
    return w
#@+node:ekr.20090427060355.11: *7* createRadioButton
def createRadioButton (self,parent,name,label):

    w = QtGui.QRadioButton(parent)
    self.setName(w,name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20090426083450.18: *7* createStackedWidget
def createStackedWidget (self,parent,name,
    lineWidth = 1,
    hPolicy=None,vPolicy=None,
):

    w = QtGui.QStackedWidget(parent)
    self.setSizePolicy(w,kind1=hPolicy,kind2=vPolicy)
    w.setAcceptDrops(True)
    w.setLineWidth(1)
    self.setName(w,name)
    return w
#@+node:ekr.20090426083450.17: *7* createTabWidget
def createTabWidget (self,parent,name,hPolicy=None,vPolicy=None):

    w = QtGui.QTabWidget(parent)
    self.setSizePolicy(w,kind1=hPolicy,kind2=vPolicy)
    self.setName(w,name)
    return w
#@+node:ekr.20090426083450.16: *7* createText
def createText (self,parent,name,
    # hPolicy=None,vPolicy=None,
    lineWidth = 0,
    shadow = QtGui.QFrame.Plain,
    shape = QtGui.QFrame.NoFrame,
):

    # w = QtGui.QTextBrowser(parent)
    c = self.leo_c
    w = LeoQTextBrowser(parent,c,None)
    # self.setSizePolicy(w,kind1=hPolicy,kind2=vPolicy)
    w.setFrameShape(shape)
    w.setFrameShadow(shadow)
    w.setLineWidth(lineWidth)
    self.setName(w,name)
    return w
#@+node:ekr.20090426083450.15: *7* createTreeWidget (DynamicWindow)
def createTreeWidget (self,parent,name):

    c = self.leo_c
    # w = QtGui.QTreeWidget(parent)
    w = LeoQTreeWidget(c,parent)
    self.setSizePolicy(w)

    # 12/01/07: add new config setting.
    multiple_selection = c.config.getBool('qt-tree-multiple-selection',default=True)
    if multiple_selection:
        w.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)
        w.setSelectionBehavior(QtGui.QAbstractItemView.SelectRows)
    else:
        w.setSelectionMode(QtGui.QAbstractItemView.SingleSelection)
        w.setSelectionBehavior(QtGui.QAbstractItemView.SelectItems)
    w.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    w.setHeaderHidden(False)
    self.setName(w,name)
    return w
#@+node:ekr.20090426183711.12: *6* log tabs
#@+node:ekr.20090424085523.38: *7* createFindTab
def createFindTab (self,parent):

    grid = self.createGrid(parent,'findGrid',margin=10,spacing=2)

    # Labels.
    lab2 = self.createLabel(parent,'findLabel','Find:')
    lab3 = self.createLabel(parent,'changeLabel','Change:')
    grid.addWidget(lab2,0,0)
    grid.addWidget(lab3,1,0)

    # Text areas.
    findPattern = self.createLineEdit(parent,'findPattern')
    findChange  = self.createLineEdit(parent,'findChange')
    grid.addWidget(findPattern,0,1)
    grid.addWidget(findChange,1,1)

    # Check boxes and radio buttons.
    # Radio buttons are mutually exclusive because they have the same parent.
    def mungeName(name):
        # The value returned here is significant: it creates an ivar.
        return 'checkBox%s' % label.replace(' ','').replace('&','')

    table = (
        ('box', 'Whole &Word',      2,0),
        ('rb',  '&Entire Outline',  2,1),
        ('box', '&Ignore Case',     3,0),
        ('rb',  '&Suboutline Only', 3,1),
        ('box', 'Wrap &Around',     4,0),
        ('rb',  '&Node Only',       4,1),
        ('box', '&Reverse',         5,0),
        ('box', 'Search &Headline', 5,1),
        ('box', 'Rege&xp',          6,0),
        ('box', 'Search &Body',     6,1),
        ('box', 'Mark &Finds',      7,0),
        ('box', 'Mark &Changes',    7,1))
        # a,b,c,e,f,h,i,n,rs,w

    for kind,label,row,col in table:

        name = mungeName(label)
        func = g.choose(kind=='box',
            self.createCheckBox,self.createRadioButton)
        w = func(parent,name,label)
        grid.addWidget(w,row,col)
        setattr(self,name,w)

    # Official ivars (in addition to setattr ivars).
    self.findPattern = findPattern
    self.findChange = findChange
#@+node:ekr.20090424085523.50: *7* createSpellTab
def createSpellTab (self,parent):

    MainWindow = self

    vLayout = self.createVLayout(parent,'spellVLayout',margin=2)
    spellFrame = self.createFrame(parent,'spellFrame')
    vLayout2 = self.createVLayout(spellFrame,'spellVLayout')
    grid = self.createGrid(None,'spellGrid',spacing=2)

    table = (
        ('Add',     'Add',          2,1),
        ('Find',    'Find',         2,0),
        ('Change',  'Change',       3,0),
        ('FindChange','Change,Find',3,1),
        ('Ignore',  'Ignore',       4,0),
        ('Hide',    'Hide',         4,1),
    )
    for (ivar,label,row,col) in table:
        name = 'spell_%s_button' % label
        button = self.createButton(spellFrame,name,label)
        grid.addWidget(button,row,col)
        func = getattr(self,'do_leo_spell_btn_%s' % ivar)
        QtCore.QObject.connect(button,QtCore.SIGNAL("clicked()"),func)
        # This name is significant.
        setattr(self,'leo_spell_btn_%s' % (ivar),button)

    self.leo_spell_btn_Hide.setCheckable(False)

    spacerItem = QtGui.QSpacerItem(20, 40,
        QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)

    grid.addItem(spacerItem, 5, 0, 1, 1)

    listBox = QtGui.QListWidget(spellFrame)
    self.setSizePolicy(listBox,
        kind1 = QtGui.QSizePolicy.MinimumExpanding,
        kind2 = QtGui.QSizePolicy.Expanding)
    listBox.setMinimumSize(QtCore.QSize(0, 0))
    listBox.setMaximumSize(QtCore.QSize(150, 150))
    listBox.setObjectName("leo_spell_listBox")

    grid.addWidget(listBox, 1, 0, 1, 2)

    spacerItem1 = QtGui.QSpacerItem(40, 20,
        QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
    grid.addItem(spacerItem1, 2, 2, 1, 1)

    lab = self.createLabel(spellFrame,'spellLabel','spellLabel')

    grid.addWidget(lab, 0, 0, 1, 2)
    vLayout2.addLayout(grid)
    vLayout.addWidget(spellFrame)

    QtCore.QObject.connect(listBox,
        QtCore.SIGNAL("itemDoubleClicked(QListWidgetItem*)"),
        self.do_leo_spell_btn_FindChange)

    # Official ivars.
    self.spellFrame = spellFrame
    self.spellGrid = grid
    self.leo_spell_listBox = listBox # Must exist
    self.leo_spell_label = lab # Must exist (!!)
#@+node:ekr.20090426183711.13: *6* utils
#@+node:ekr.20090426083450.13: *7* setName
def setName (self,widget,name):

    if name:
        # if not name.startswith('leo_'):
            # name = 'leo_' + name
        widget.setObjectName(name)
#@+node:ekr.20090425072841.14: *7* setSizePolicy
def setSizePolicy (self,widget,kind1=None,kind2=None):

    if kind1 is None: kind1 = QtGui.QSizePolicy.Ignored
    if kind2 is None: kind2 = QtGui.QSizePolicy.Ignored

    sizePolicy = QtGui.QSizePolicy(kind1,kind2)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)

    sizePolicy.setHeightForWidth(
        widget.sizePolicy().hasHeightForWidth())

    widget.setSizePolicy(sizePolicy)
#@+node:ekr.20090424085523.48: *7* tr
def tr(self,s):

    return QtGui.QApplication.translate(
        'MainWindow',s,None,QtGui.QApplication.UnicodeUTF8)
#@+node:leohag.20081203210510.17: *5* do_leo_spell_btn_*
def doSpellBtn(self, btn):
    getattr(self.leo_c.spellCommands.handler.tab, btn)() 

def do_leo_spell_btn_Add(self):
    self.doSpellBtn('onAddButton')

def do_leo_spell_btn_Change(self):
    self.doSpellBtn('onChangeButton')

def do_leo_spell_btn_Find(self):
    self.doSpellBtn('onFindButton')

def do_leo_spell_btn_FindChange(self):
    self.doSpellBtn('onChangeThenFindButton')

def do_leo_spell_btn_Hide(self):
    self.doSpellBtn('onHideButton')

def do_leo_spell_btn_Ignore(self):
    self.doSpellBtn('onIgnoreButton')
#@+node:ekr.20110301080146.13982: *5* select (DynamicWindow)
def select (self,c):
    
    '''Select the window or tab for c.'''
    
    if self.master:
        # A LeoTabbedTopLevel.
        self.master.select(c)
    else:
        w = c.frame.body.bodyCtrl
        g.app.gui.set_focus(c,w)
    
#@+node:edward.20081129091117.1: *5* setSplitDirection (DynamicWindow)
def setSplitDirection (self,orientation='vertical'):

    vert = orientation and orientation.lower().startswith('v')
    h,v = QtCore.Qt.Horizontal,QtCore.Qt.Vertical

    orientation1 = g.choose(vert,h,v)
    orientation2 = g.choose(vert,v,h)

    self.splitter.setOrientation(orientation1)
    self.splitter_2.setOrientation(orientation2)

    # g.trace('vert',vert)

#@+node:ekr.20081121105001.203: *5* setStyleSheets & helper
styleSheet_inited = False

def setStyleSheets(self):

    trace = False
    c = self.leo_c

    sheet = c.config.getData('qt-gui-plugin-style-sheet')
    if sheet:
        sheet = '\n'.join(sheet)
        if trace: g.trace(len(sheet))
        self.ui.setStyleSheet(sheet or self.default_sheet())
    else:
        if trace: g.trace('no style sheet')
#@+node:ekr.20081121105001.204: *6* defaultStyleSheet
def defaultStyleSheet (self):

    '''Return a reasonable default style sheet.'''

    # Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords
    return '''\

/* A QWidget: supports only background attributes.*/
QSplitter::handle {

    background-color: #CAE1FF; /* Leo's traditional lightSteelBlue1 */
}
QSplitter {
    border-color: white;
    background-color: white;
    border-width: 3px;
    border-style: solid;
}
QTreeWidget {
    background-color: #ffffec; /* Leo's traditional tree color */
}
/* Not supported. */
QsciScintilla {
    background-color: pink;
}
'''
#@+node:ville.20090702214819.4211: *5* setLeoWindowIcon
def setLeoWindowIcon(self):
    """ Set icon visible in title bar and task bar """
    # xxx do not use 
    self.setWindowIcon(QtGui.QIcon(g.app.leoDir + "/Icons/leoapp32.png"))
#@+node:ekr.20110122055506.12567: *5* setGeometry (DynamicWindow)
def setGeometry (self,rect):
    
    # g.trace('(DynamicWindow)',rect)
        
    if hasattr(self,'master') and self.master:
        # master is a LeoTabbedTopLevel
        self.master.setLeoWindowSize(rect)
    
    # Always the base-class method.
    QtGui.QMainWindow.setGeometry(self,rect)
#@+node:ekr.20100111143038.3727: *5* splitter event handlers
def onSplitter1Moved (self,pos,index):

    c = self.leo_c
    c.frame.secondary_ratio = self.splitterMovedHelper(
        self.splitter,pos,index)

def onSplitter2Moved (self,pos,index):

    c = self.leo_c
    c.frame.ratio = self.splitterMovedHelper(
        self.splitter_2,pos,index)

def splitterMovedHelper(self,splitter,pos,index):

    i,j = splitter.getRange(index)
    ratio = float(pos)/float(j-i)
    # g.trace(pos,j,ratio)
    return ratio
#@+node:ekr.20110122055506.12566: *4* Ctor related...
@nocolor-node

app.newLeoCommanderAndFrame
    frame.finishCreate(c)
        f.top = g.app.gui.frameFactory.createFrame(f)

qtGui ctor
    TabbedFrameFactory ctor
        DynamicWindow ctor
#@+node:ekr.20081121105001.474: *5*  qtGui.__init__
def __init__ (self):

    # Initialize the base class.
    leoGui.leoGui.__init__(self,'qt')

    self.qtApp = app = QtGui.QApplication(sys.argv)
    self.bodyTextWidget  = leoQtBaseTextWidget
    self.plainTextWidget = leoQtBaseTextWidget
    self.iconimages = {} # Image cache set by getIconImage().
    self.mGuiName = 'qt'  

    if g.app.qt_use_tabs:    
        self.frameFactory = TabbedFrameFactory()
    else:
        self.frameFactory = SDIFrameFactory()
#@+node:ville.20090803132402.3685: *5* ctor (TabbedFrameFactory)
def __init__(self):

    # will be created when first frame appears 

    # DynamicWindow => Leo frame map
    self.alwaysShowTabs = True
        # Set to true to workaround a problem
        # setting the window title when tabs are shown.
    self.leoFrames = {}
        # Keys are DynamicWindows, values are frames.
    self.masterFrame = None
    self.createTabCommands()
    
    # g.trace('(TabbedFrameFactory)',g.callers())
#@+node:ekr.20081121105001.201: *5*  ctor (DynamicWindow)
# Called from leoQtFrame.finishCreate.

def __init__(self,c,parent=None):

    '''Create Leo's main window, c.frame.top'''
    
    # For qttabs gui, parent is a LeoTabbedTopLevel.

    # g.trace('(DynamicWindow)',g.callers())

    QtGui.QMainWindow.__init__(self,parent)

    self.leo_c = c
#@+node:ekr.20081121105001.254: *5* qtFrame.finishCreate & helpers
# Called from newLeoCommanderAndFrame

def finishCreate (self,c):

    f = self ; f.c = c

    # g.trace('(qtFrame)')

    # self.bigTree         = c.config.getBool('big_outline_pane')
    self.trace_status_line = c.config.getBool('trace_status_line')
    self.use_chapters      = c.config.getBool('use_chapters')
    self.use_chapter_tabs  = c.config.getBool('use_chapter_tabs')

    # returns DynamicWindow
    f.top = g.app.gui.frameFactory.createFrame(f)
    # g.trace('(leoQtFrame)',f.top)

    # hiding would remove flicker, but doesn't work with all
    # window managers

    f.createIconBar() # A base class method.
    f.createSplitterComponents()
    cc = c.chapterController
    # g.trace(cc,cc.findChaptersNode())
    if 0: # 2010/06/17: Now done in cc.createChaptersNode.
        if f.use_chapters and f.use_chapter_tabs: # and cc and cc.findChaptersNode():
            cc.tt = leoQtTreeTab(c,f.iconBar)
    f.createStatusLine() # A base class method.
    f.createFirstTreeNode() # Call the base-class method.
    f.menu = leoQtMenu(f)
    #### c.setLog()
    g.app.windowList.append(f)
    f.miniBufferWidget = leoQtMinibuffer(c)
    c.bodyWantsFocus()
#@+node:ekr.20081121105001.255: *6* createSplitterComponents (qtFrame)
def createSplitterComponents (self):

    f = self ; c = f.c

    f.tree  = leoQtTree(c,f)
    f.log   = leoQtLog(f,None)
    f.body  = leoQtBody(f,None)

    if f.use_chapters:
        c.chapterController = cc = leoChapters.chapterController(c)

    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.resizePanesToRatio(f.ratio,f.secondary_ratio)
#@+node:ekr.20100101104934.3658: *5* createFrame (TabbedFrameFactory)
def createFrame(self, leoFrame):

    # g.trace('(TabbedFrameFactory)')

    c = leoFrame.c
    if self.masterFrame is None:
        self.createMaster()
    tabw = self.masterFrame
    dw = DynamicWindow(c,tabw)
    self.leoFrames[dw] = leoFrame

    # Shorten the title.
    fname = c.mFileName
    if fname:
        title = os.path.basename(fname)
    else:
        title = leoFrame.title
    tip = leoFrame.title

    dw.setWindowTitle(tip) # 2010/1/1
    idx = tabw.addTab(dw, title)
    if tip: tabw.setTabToolTip(idx, tip)

    dw.construct(master=tabw)
    tabw.setCurrentIndex(idx)            

    # Work around the problem with missing dirty indicator
    # by always showing the tab.
    tabw.tabBar().setVisible(
        self.alwaysShowTabs or tabw.count() > 1)

    dw.show()
    tabw.show()
    return dw
#@+node:ville.20090806213440.3689: *5* construct (DynamicWindow)
def construct(self,master=None):
    """ Factor 'heavy duty' code out from ctor """

    c = self.leo_c; top = c.frame.top
    self.master=master # A LeoTabbedTopLevel for tabbed windows.
    # g.trace('(DynamicWindow)',g.callers())

    # Init the base class.
    ui_file_name = c.config.getString('qt_ui_file_name')
    if not ui_file_name:
        ui_file_name = 'qt_main.ui'

    ui_description_file = g.app.loadDir + "/../plugins/" + ui_file_name
    # g.pr('DynamicWindw.__init__,ui_description_file)
    assert g.os_path_exists(ui_description_file)

    self.bigTree = c.config.getBool('big_outline_pane')

    if useUI:  
        self.ui = uic.loadUi(ui_description_file, self)
    else:
        self.createMainWindow()


    self.iconBar = self.addToolBar("IconBar")

    # Set orientation if requested.
    d = {
        'bottom':QtCore.Qt.BottomToolBarArea,
        'left':QtCore.Qt.LeftToolBarArea,
        'right':QtCore.Qt.RightToolBarArea,
        'top':QtCore.Qt.TopToolBarArea,
    }
    where = c.config.getString('qt-toolbar-location')
    # g.trace(where)
    if where:
        where = d.get(where)
        if where: self.addToolBar(where,self.iconBar)
    self.menubar = self.menuBar()
    self.statusBar = QtGui.QStatusBar()
    self.setStatusBar(self.statusBar)

    orientation = c.config.getString('initial_split_orientation')
    self.setSplitDirection(orientation)
    self.setStyleSheets()
    #self.setLeoWindowIcon()
#@+node:ekr.20110122055506.12565: *4* Size related...
#@+node:ekr.20081121105001.283: *5* setInitialWindowGeometry (qtFrame)
def setInitialWindowGeometry(self):

    """Set the position and size of the frame to config params."""

    c = self.c

    h = c.config.getInt("initial_window_height") or 500
    w = c.config.getInt("initial_window_width") or 600
    x = c.config.getInt("initial_window_left") or 10
    y = c.config.getInt("initial_window_top") or 10

    # g.trace(h,w,x,y)

    if h and w and x and y:
        self.setTopGeometry(w,h,x,y)
#@+node:ekr.20081121105001.317: *5* Qt bindings... (qtFrame)
def bringToFront (self):
    self.lift()
def deiconify (self):
    if self.top.isMinimized(): # Bug fix: 400739.
        self.lift()
def getFocus(self):
    return g.app.gui.get_focus(self.c) # Bug fix: 2009/6/30.
def get_window_info(self):
    if hasattr(self.top,'master') and self.top.master:
        f = self.top.master
    else:
        f = self.top
    rect = f.geometry()
    topLeft = rect.topLeft()
    x,y = topLeft.x(),topLeft.y()
    w,h = rect.width(),rect.height()
    # g.trace(w,h,x,y)
    return w,h,x,y
def iconify(self):
    self.top.showMinimized()
def lift (self):
    # g.trace(self.c,'\n',g.callers(9))
    if self.top.isMinimized(): # Bug 379141
        self.top.showNormal()
    self.top.activateWindow()
    self.top.raise_()
def update (self):
    pass
def getTitle (self):
    s = g.u(self.top.windowTitle())
    # g.trace('(qtFrame)',repr(s))
    return s
def setTitle (self,s):
    # g.trace('(qtFrame)',repr(s))
    self.top.setWindowTitle(s)
def setTopGeometry(self,w,h,x,y,adjustSize=True):
    # self.top is a DynamicWindow.
    # g.trace('(qtFrame)',x,y,w,h,self.top)
    self.top.setGeometry(QtCore.QRect(x,y,w,h))
#@+node:ville.20090803132402.3684: *5* createMaster (TabbedFrameFactory)
def createMaster(self):
    mf = self.masterFrame = LeoTabbedTopLevel(factory=self)
    #g.trace('(TabbedFrameFactory) (sets tabbed geom)')
    g.app.gui.attachLeoIcon(mf)
    tabbar = mf.tabBar()

    try:
        tabbar.setTabsClosable(True)
        tabbar.connect(tabbar,
            QtCore.SIGNAL('tabCloseRequested(int)'),
            self.slotCloseRequest)
    except AttributeError:
        pass # Qt 4.4 does not support setTabsClosable

    mf.connect(mf,
        QtCore.SIGNAL('currentChanged(int)'),
        self.slotCurrentChanged)

    if g.app.start_minimized:
        mf.showMinimized()
    elif g.app.start_maximized:
        mf.showMaximized()
    elif g.app.start_fullscreen:
        mf.showFullScreen()
    else:
        mf.show()
#@+node:ekr.20090425072841.2: *5* setMainWindowOptions
def setMainWindowOptions (self):

    MainWindow = self

    MainWindow.setObjectName("MainWindow")
    MainWindow.resize(691, 635)
    MainWindow.setDockNestingEnabled(False)
    MainWindow.setDockOptions(
        QtGui.QMainWindow.AllowTabbedDocks |
        QtGui.QMainWindow.AnimatedDocks)
#@+node:ekr.20110122055506.12567: *5* setGeometry (DynamicWindow)
def setGeometry (self,rect):
    
    # g.trace('(DynamicWindow)',rect)
        
    if hasattr(self,'master') and self.master:
        # master is a LeoTabbedTopLevel
        self.master.setLeoWindowSize(rect)
    
    # Always the base-class method.
    QtGui.QMainWindow.setGeometry(self,rect)
#@+node:ekr.20110122055506.12568: *5* setLeoWindowSize (LeoTabbedTopLevel)
def setLeoWindowSize (self,rect):
    
    if not hasattr(self,'leo_inited'):
        # g.trace('(LeoTabbedTopLevel)',rect)
        self.leo_inited = True
        self.setGeometry(rect)
#@+node:ekr.20110227193706.15354: *3* Mark external file dirty when dragging node
#@+node:ekr.20100830205422.3715: *4* dragEnter
def dragEnterEvent(self,ev):

    '''Export c.p's tree as a Leo mime-data.'''

    trace = False and not g.unitTesting
    c = self.c ; tree = c.frame.tree
    if not ev:
        g.trace('no event!')
        return

    md = ev.mimeData()
    if not md:
        g.trace('No mimeData!') ; return

    c.endEditing()
    if g.app.dragging:
        if trace or self.trace: g.trace('** already dragging')
    else:
        g.app.dragging = True
        g.app.drag_source = c, c.p
        if self.trace: g.trace('set g.app.dragging')
        self.setText(md)
        if self.trace: self.dump(ev,c.p,'enter')

    # Always accept the drag, even if we are already dragging.
    ev.accept()
#@+node:ekr.20100830205422.3716: *4* dropEvent & helpers
def dropEvent(self,ev):

    trace = False and not g.unitTesting
    if not ev: return
    c = self.c ; tree = c.frame.tree ; u = c.undoer

    # Always clear the dragging flag, no matter what happens.
    g.app.dragging = False
    if self.trace: g.trace('clear g.app.dragging')

    # Set p to the target of the drop.
    item = self.itemAt(ev.pos())
    if not item: return
    itemHash = tree.itemHash(item)
    p = tree.item2positionDict.get(itemHash)
    if not p:
        if trace or self.trace: g.trace('no p!')
        return


    md = ev.mimeData()
    #print "drop md",mdl
    if not md:
        g.trace('no mimeData!') ; return

    #print "t",str(md.text())
    #print "h", str(md.html())
    formats = set(str(f) for f in md.formats())
    #print formats

    ev.setDropAction(QtCore.Qt.IgnoreAction)
    ev.accept()

    hookres = g.doHook("outlinedrop", c=c, p=p, dropevent = ev, formats = formats)

    if hookres:
        # True => plugins handled the drop already
        return

    if trace or self.trace: self.dump(ev,p,'drop ')

    if md.hasUrls():
        self.urlDrop(ev,p)
    else:
        self.outlineDrop(ev,p)
#@+node:ekr.20100830205422.3720: *5* outlineDrop & helpers
def outlineDrop (self,ev,p):

    trace = False and not g.unitTesting
    c = self.c ; tree = c.frame.tree
    mods = ev.keyboardModifiers()
    md = ev.mimeData()

    fn,s = self.parseText(md)
    if not s or not fn:
        if trace or self.trace: g.trace('no fn or no s')
        return

    if fn == self.fileName():
        if p and p == c.p:
            if trace or self.trace: g.trace('same node')
        else:
            cloneDrag = (int(mods) & QtCore.Qt.ControlModifier) != 0
            self.intraFileDrop(cloneDrag,fn,c.p,p)
    else:
        # Clone dragging between files is not allowed.
        self.interFileDrop(fn,p,s)
#@+node:ekr.20100830205422.3718: *6* interFileDrop
def interFileDrop (self,fn,p,s):

    '''Paste the mime data after (or as the first child of) p.'''

    c = self.c ; tree = c.frame.tree
    u = c.undoer ; undoType = 'Drag Outline'

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    if not isLeo: return

    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s,reassignIndices=True)
    if not pasted: return
    
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
            
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")

    undoData = u.beforeInsertNode(p,
        pasteAsClone=False,copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back,0)
    # c.setRootPosition(c.findRootPosition(pasted))

    u.afterInsertNode(pasted,undoType,undoData)
    c.redraw_now(pasted)
    c.recolor()
#@+node:ekr.20100830205422.3719: *6* intraFileDrop
def intraFileDrop (self,cloneDrag,fn,p1,p2):

    '''Move p1 after (or as the first child of) p2.'''

    c = self.c ; u = c.undoer
    c.selectPosition(p1)

    if p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        parent = p2
        def move(p1,p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2,0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1
    else:
        # Attempt to move p1 after p2.
        parent = p2.parent()
        def move(p1,p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = c.checkMoveWithParentWithWarning(p1,parent,True)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1,p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1,'Drag',undoData,dirtyVnodeList)
        c.redraw_now(p1)
    else:
        g.trace('** move failed')
#@+node:ekr.20100830205422.3721: *5* urlDrop & helpers
def urlDrop (self,ev,p):

    c = self.c ; u = c.undoer ; undoType = 'Drag Urls'
    md = ev.mimeData()
    urls = md.urls()
    if not urls: return

    c.undoer.beforeChangeGroup(c.p,undoType)

    changed = False
    for z in urls:
        url = QtCore.QUrl(z)
        scheme = url.scheme()
        if scheme == 'file':
            changed |= self.doFileUrl(p,url)
        elif scheme in ('http',): # 'ftp','mailto',
            changed |= self.doHttpUrl(p,url)
        # else: g.trace(url.scheme(),url)

    if changed:
        c.setChanged(True)
        u.afterChangeGroup(c.p,undoType,reportFlag=False,dirtyVnodeList=[])
        c.redraw_now()
#@+node:ekr.20100830205422.3722: *6* doFileUrl & helper
def doFileUrl (self,p,url):

    fn = str(url.path())
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]

    changed = False
    if os.path.isdir(fn):
        self.doPathUrlHelper(fn,p)
        return True

    if g.os_path_exists(fn):
        try:
            f = open(fn,'r')
        except IOError:
            f = None
        if f:
            s = f.read()
            f.close()
            self.doFileUrlHelper(fn,p,s)
            return True

    g.es_print('not found: %s' % (fn))
    return False
#@+node:ekr.20100830205422.3723: *7* doFileUrlHelper & helper
def doFileUrlHelper (self,fn,p,s):

    '''Insert s in an @file, @auto or @edit node after p.'''

    c = self.c ; u = c.undoer ; undoType = 'Drag File'

    undoData = u.beforeInsertNode(p,pasteAsClone=False,copiedBunchList=[])

    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()

    self.createAtFileNode(fn,p2,s)

    u.afterInsertNode(p2,undoType,undoData)

    c.selectPosition(p2)
#@+node:ekr.20100902095952.3740: *8* createAtFileNode & helpers
def createAtFileNode (self,fn,p,s):

    '''Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @auto node.

    Give a warning if a node with the same headline already exists.
    '''

    c = self.c ; d = c.importCommands.importDispatchDict
    if self.isThinFile(fn,s):
        self.createAtFileTree(fn,p,s)
    elif self.isAutoFile(fn,s):
        self.createAtAutoTree(fn,p,s)
    else:
        self.createAtEditNode(fn,p,s)
    self.warnIfNodeExists(p)
#@+node:ekr.20100902095952.3744: *9* createAtAutoTree
def createAtAutoTree (self,fn,p,s):

    '''Make p an @auto node and create the tree using
    s, the file's contents.
    '''

    c = self.c ; at = c.atFileCommands

    p.h = '@auto %s' % (fn)

    at.readOneAtAutoNode(fn,p)

    # No error recovery should be needed here.

    p.clearDirty() # Don't automatically rewrite this node.
#@+node:ekr.20100902165040.3738: *9* createAtEditNode
def createAtEditNode(self,fn,p,s):

    c = self.c ; at = c.atFileCommands

    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn,p)
    p.h = '@edit %s' % (fn)
    p.clearDirty() # Don't automatically rewrite this node.
#@+node:ekr.20100902095952.3743: *9* createAtFileTree
def createAtFileTree (self,fn,p,s):

    '''Make p an @file node and create the tree using
    s, the file's contents.
    '''

    c = self.c ; at = c.atFileCommands

    p.h = '@file %s' % (fn)

    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True) # Disable caching.

    if not ok:
        g.es_print('Error reading',fn,color='red')
        p.b = '' # Safe: will not cause a write later.
        p.clearDirty() # Don't automatically rewrite this node.
#@+node:ekr.20100902095952.3741: *9* isThinFile
def isThinFile (self,fn,s):

    '''Return true if the file whose contents is s
    was created from an @thin or @file tree.'''

    c = self. c ; at = c.atFileCommands

    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    else:
        # Like at.isFileLike.
        j,k = g.getLine(s,i)
        line = s[j:k]
        valid,new_df,start,end,isThin = at.parseLeoSentinel(line)
        # g.trace('valid',valid,'new_df',new_df,'isThin',isThin)
        return valid and new_df and isThin
#@+node:ekr.20100902095952.3742: *9* isAutoFile
def isAutoFile (self,fn,unused_s):

    '''Return true if the file whose name is fn
    can be parsed with an @auto parser.
    '''

    c = self.c
    d = c.importCommands.importDispatchDict
    junk,ext = g.os_path_splitext(fn)
    return d.get(ext)
#@+node:ekr.20100902095952.3745: *9* warnIfNodeExists
def warnIfNodeExists (self,p):

    c = self.c ; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.es('Warning: duplicate node:',h,color='blue')
            break
#@+node:ville.20110113151525.11644: *7* doPathUrlHelper
def doPathUrlHelper (self,fn,p):

    '''Insert s in an @file, @auto or @edit node after p.'''

    c = self.c ; u = c.undoer ; undoType = 'Drag File'

    undoData = u.beforeInsertNode(p,pasteAsClone=False,copiedBunchList=[])

    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()

    p2.h = '@path ' + fn

    u.afterInsertNode(p2,undoType,undoData)

    c.selectPosition(p2)
#@+node:ekr.20100830205422.3724: *6* doHttpUrl
def doHttpUrl (self,p,url):

    '''Insert the url in an @url node after p.'''

    c = self.c ; u = c.undoer ; undoType = 'Drag Url'

    s = str(url.toString()).strip()
    if not s: return False

    undoData = u.beforeInsertNode(p,pasteAsClone=False,copiedBunchList=[])

    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()

    # p2.h,p2.b = '@url %s' % (s),''
    p2.h = '@url'
    p2.b = s
    p2.clearDirty() # Don't automatically rewrite this node.

    u.afterInsertNode(p2,undoType,undoData)
    return True
#@+node:ekr.20100830205422.3720: *4* outlineDrop & helpers
def outlineDrop (self,ev,p):

    trace = False and not g.unitTesting
    c = self.c ; tree = c.frame.tree
    mods = ev.keyboardModifiers()
    md = ev.mimeData()

    fn,s = self.parseText(md)
    if not s or not fn:
        if trace or self.trace: g.trace('no fn or no s')
        return

    if fn == self.fileName():
        if p and p == c.p:
            if trace or self.trace: g.trace('same node')
        else:
            cloneDrag = (int(mods) & QtCore.Qt.ControlModifier) != 0
            self.intraFileDrop(cloneDrag,fn,c.p,p)
    else:
        # Clone dragging between files is not allowed.
        self.interFileDrop(fn,p,s)
#@+node:ekr.20100830205422.3718: *5* interFileDrop
def interFileDrop (self,fn,p,s):

    '''Paste the mime data after (or as the first child of) p.'''

    c = self.c ; tree = c.frame.tree
    u = c.undoer ; undoType = 'Drag Outline'

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    if not isLeo: return

    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(
        s,reassignIndices=True)
    if not pasted: return
    
    if c.config.getBool('inter_outline_drag_moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
            
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged(True)
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")

    undoData = u.beforeInsertNode(p,
        pasteAsClone=False,copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    pasted.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
    c.setChanged(True)
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back,0)
    # c.setRootPosition(c.findRootPosition(pasted))

    u.afterInsertNode(pasted,undoType,undoData)
    c.redraw_now(pasted)
    c.recolor()
#@+node:ekr.20100830205422.3719: *5* intraFileDrop
def intraFileDrop (self,cloneDrag,fn,p1,p2):

    '''Move p1 after (or as the first child of) p2.'''

    c = self.c ; u = c.undoer
    c.selectPosition(p1)

    if p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        parent = p2
        def move(p1,p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveToNthChildOf(p2,0)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1
    else:
        # Attempt to move p1 after p2.
        parent = p2.parent()
        def move(p1,p2):
            if cloneDrag: p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            p1.setAllAncestorAtFileNodesDirty() # 2011/02/27: Fix bug 690467.
            return p1

    ok = c.checkMoveWithParentWithWarning(p1,parent,True)
    if ok:
        undoData = u.beforeMoveNode(p1)
        dirtyVnodeList = p1.setAllAncestorAtFileNodesDirty()
        p1 = move(p1,p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            # Note: the setDescendentsDirty flag does not do what we want.
            for z in p1.self_and_subtree():
                z.setAllAncestorAtFileNodesDirty(
                    setDescendentsDirty=False)
        c.setChanged(True)
        u.afterMoveNode(p1,'Drag',undoData,dirtyVnodeList)
        c.redraw_now(p1)
    else:
        g.trace('** move failed')
#@+node:ekr.20110304061301.14036: *3* Colorized & handled url's
#@+node:ekr.20090614134853.3637: *4* class jeditColorizer
# This is c.frame.body.colorizer.highlighter.colorer

class jEditColorizer:

    '''This class contains jEdit pattern matchers adapted
    for use with QSyntaxHighlighter.'''

    << about the line-oriented jEdit colorizer >>

    @others
#@+node:ekr.20090624080405.3856: *5* << about the line-oriented jEdit colorizer >>
@nocolor-node
@

The aha behind the line-oriented jEdit colorizer is that we can define one or
more *restarter* methods for each pattern matcher that could possibly match
across line boundaries. I say "one or more" because we need a separate restarter
method for all combinations of arguments that can be passed to the jEdit pattern
matchers. In effect, these restarters are lambda bindings for the generic
restarter methods.

In actuality, very few restarters are needed. For example, for Python, we need
restarters for that look for continued strings, and both flavors of continued
triple-quoted strings. For python, these turn out to be three separate lambda
bindings for restart_match_span.

When a jEdit pattern matcher partially succeeds, it creates the lambda binding
for its restarter and calls setRestart to set the ending state of the present
line to an integer representing the bound restarter. setRestart calls
computeState to create a *string* representing the lambda binding of the
restarter. setRestart then calls stateNameToStateNumber to convert that string
to an integer state number that then gets passed to Qt's setCurrentBlockState.
The string is useful for debugging; Qt only uses the corresponding number.
#@+node:ekr.20090614134853.3696: *5*  Birth & init
#@+node:ekr.20090614134853.3697: *6* __init__ (jeditColorizer)
def __init__(self,c,colorizer,highlighter,w):

    # Basic data...
    self.c = c
    self.colorizer = colorizer
    self.highlighter = highlighter # a QSyntaxHighlighter
    self.p = None
    self.w = w
    assert(w == self.c.frame.body.bodyCtrl)

    # Used by recolor and helpers...
    self.actualColorDict = {} # Used only by setTag.
    self.hyperCount = 0
    self.defaultState = 'default-state:' # The name of the default state.
    self.nextState = 1 # Dont use 0.
    self.restartDict = {} # Keys are state numbers, values are restart functions.
    self.stateDict = {} # Keys are state numbers, values state names.
    self.stateNameDict = {} # Keys are state names, values are state numbers.

    # Attributes dict ivars: defaults are as shown...
    self.default = 'null'
    self.digit_re = ''
    self.escape = ''
    self.highlight_digits = True
    self.ignore_case = True
    self.no_word_sep = ''
    # Config settings...
    self.showInvisibles = c.config.getBool("show_invisibles_by_default")
    self.colorizer.showInvisibles = self.showInvisibles
    # g.trace(self.showInvisibles)
        # Also set in init().
    self.underline_undefined = c.config.getBool("underline_undefined_section_names")
    self.use_hyperlinks = c.config.getBool("use_hyperlinks")
    # Debugging...
    self.count = 0 # For unit testing.
    self.allow_mark_prev = True # The new colorizer tolerates this nonsense :-)
    self.tagCount = 0
    self.trace = False or c.config.getBool('trace_colorizer')
    self.trace_leo_matches = False
    self.trace_match_flag = False # (Useful) True: trace all matching methods.
    self.verbose = False
    # Profiling...
    self.recolorCount = 0 # Total calls to recolor
    self.stateCount = 0 # Total calls to setCurrentState
    self.totalChars = 0 # The total number of characters examined by recolor.
    self.totalStates = 0
    self.maxStateNumber = 0
    self.totalKeywordsCalls = 0
    self.totalLeoKeywordsCalls = 0
    # Mode data...
    self.defaultRulesList = []
    self.importedRulesets = {}
    self.prev = None # The previous token.
    self.fonts = {} # Keys are config names.  Values are actual fonts.
    self.keywords = {} # Keys are keywords, values are 0..5.
    self.last_language = None # The language for which configuration tags are valid.
    self.modes = {} # Keys are languages, values are modes.
    self.mode = None # The mode object for the present language.
    self.modeBunch = None # A bunch fully describing a mode.
    self.modeStack = []
    self.rulesDict = {}
    # self.defineAndExtendForthWords()
    self.word_chars = {} # Inited by init_keywords().
    self.setFontFromConfig()
    self.tags = [
        "blank","comment","cwebName","docPart","keyword","leoKeyword",
        "latexModeBackground","latexModeKeyword",
        "latexBackground","latexKeyword",
        "link","name","nameBrackets","pp","string",
        "elide","bold","bolditalic","italic", # new for wiki styling.
        "tab",
        # Leo jEdit tags...
        '@color', '@nocolor', 'doc_part', 'section_ref',
        # jEdit tags.
        'bracketRange',
        'comment1','comment2','comment3','comment4',
        'function',
        'keyword1','keyword2','keyword3','keyword4',
        'label','literal1','literal2','literal3','literal4',
        'markup','operator',
    ]

    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
#@+node:ekr.20090614134853.3698: *7* defineLeoKeywordsDict
def defineLeoKeywordsDict(self):

    self.leoKeywordsDict = {}

    for key in g.globalDirectiveList:
        self.leoKeywordsDict [key] = 'leoKeyword'
#@+node:ekr.20090614134853.3699: *7* defineDefaultColorsDict
def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {
        # tag name       :(     option name,           default color),
        'blank'          :('blank_color',                 'black'), # 2010/1/2
        'tab'            :('tab_color',                   'black'), # 2010/1/2
        'comment'        :('comment_color',               'red'),
        'cwebName'       :('cweb_section_name_color',     'red'),
        'pp'             :('directive_color',             'blue'),
        'docPart'        :('doc_part_color',              'red'),
        'keyword'        :('keyword_color',               'blue'),
        'leoKeyword'     :('leo_keyword_color',           'blue'),
        'link'           :('section_name_color',          'red'),
        'nameBrackets'   :('section_name_brackets_color', 'blue'),
        'string'         :('string_color',                '#00aa00'), # Used by IDLE.
        'name'           :('undefined_section_name_color','red'),
        'latexBackground':('latex_background_color',      'white'),
        'url'            :('url_color',                   'purple'),

        # Tags used by forth.
        'bracketRange'   :('bracket_range_color','orange'),

        # jEdit tags.
        'comment1'       :('comment1_color', 'red'),
        'comment2'       :('comment2_color', 'red'),
        'comment3'       :('comment3_color', 'red'),
        'comment4'       :('comment4_color', 'red'),
        'function'       :('function_color', 'black'),
        'keyword1'       :('keyword1_color', 'blue'),
        'keyword2'       :('keyword2_color', 'blue'),
        'keyword3'       :('keyword3_color', 'blue'),
        'keyword4'       :('keyword4_color', 'blue'),
        'keyword5'       :('keyword5_color', 'blue'),
        'label'          :('label_color',    'black'),
        'literal1'       :('literal1_color', '#00aa00'),
        'literal2'       :('literal2_color', '#00aa00'),
        'literal3'       :('literal3_color', '#00aa00'),
        'literal4'       :('literal4_color', '#00aa00'),
        'markup'         :('markup_color',   'red'),
        'null'           :('null_color',     'black'),
        'operator'       :('operator_color', 'black'),
    }
#@+node:ekr.20090614134853.3700: *7* defineDefaultFontDict
def defineDefaultFontDict (self):

    self.default_font_dict = {
        # tag name      : option name
        'comment'       :'comment_font',
        'cwebName'      :'cweb_section_name_font',
        'pp'            :'directive_font',
        'docPart'       :'doc_part_font',
        'keyword'       :'keyword_font',
        'leoKeyword'    :'leo_keyword_font',
        'link'          :'section_name_font',
        'nameBrackets'  :'section_name_brackets_font',
        'string'        :'string_font',
        'name'          :'undefined_section_name_font',
        'latexBackground':'latex_background_font',
        'tab'           : 'tab_font',
        'url'           : 'url_font',

        # Tags used by forth.
        'bracketRange'   :'bracketRange_font',

         # jEdit tags.
        'comment1'      :'comment1_font',
        'comment2'      :'comment2_font',
        'comment3'      :'comment3_font',
        'comment4'      :'comment4_font',
        'function'      :'function_font',
        'keyword1'      :'keyword1_font',
        'keyword2'      :'keyword2_font',
        'keyword3'      :'keyword3_font',
        'keyword4'      :'keyword4_font',
        'keyword5'      :'keyword5_font',
        'label'         :'label_font',
        'literal1'      :'literal1_font',
        'literal2'      :'literal2_font',
        'literal3'      :'literal3_font',
        'literal4'      :'literal4_font',
        'markup'        :'markup_font',
        # 'nocolor' This tag is used, but never generates code.
        'null'          :'null_font',
        'operator'      :'operator_font',
    }
#@+node:ekr.20090614134853.3701: *6* addImportedRules
def addImportedRules (self,mode,rulesDict,rulesetName):

    '''Append any imported rules at the end of the rulesets specified in mode.importDict'''

    if self.importedRulesets.get(rulesetName):
        return
    else:
        self.importedRulesets [rulesetName] = True

    names = hasattr(mode,'importDict') and mode.importDict.get(rulesetName,[]) or []

    for name in names:
        savedBunch = self.modeBunch
        ok = self.init_mode(name)
        if ok:
            rulesDict2 = self.rulesDict
            for key in rulesDict2.keys():
                aList = self.rulesDict.get(key,[])
                aList2 = rulesDict2.get(key)
                if aList2:
                    # Don't add the standard rules again.
                    rules = [z for z in aList2 if z not in aList]
                    if rules:
                        # g.trace([z.__name__ for z in rules])
                        aList.extend(rules)
                        self.rulesDict [key] = aList
        # g.trace('***** added rules for %s from %s' % (name,rulesetName))
        self.initModeFromBunch(savedBunch)
#@+node:ekr.20090614134853.3702: *6* addLeoRules
def addLeoRules (self,theDict):

    '''Put Leo-specific rules to theList.'''

    table = (
        # Rules added at front are added in **reverse** order.
        ('@',  self.match_leo_keywords,True), # Called after all other Leo matchers.
            # Debatable: Leo keywords override langauge keywords.
        ('@',  self.match_at_color,    True),
        ('@',  self.match_at_killcolor,True),
        ('@',  self.match_at_language, True), # 2011/01/17
        ('@',  self.match_at_nocolor,  True),
        ('@',  self.match_at_nocolor_node,True),
        ('@',  self.match_doc_part,    True),
        ('f',  self.match_url_f,        True),
        ('h',  self.match_url_h,       True),
        ('<',  self.match_section_ref, True), # Called **first**.
        # Rules added at back are added in normal order.
        (' ',  self.match_blanks,      False),
        ('\t', self.match_tabs,        False),
    )

    for ch, rule, atFront, in table:

        # Replace the bound method by an unbound method.

        if g.isPython3:
            rule = rule.__func__
        else:
            rule = rule.im_func
        # g.trace(rule)

        theList = theDict.get(ch,[])
        if rule not in theList:
            if atFront:
                theList.insert(0,rule)
            else:
                theList.append(rule)
            theDict [ch] = theList

    # g.trace(g.listToString(theDict.get('@')))
#@+node:ekr.20090614134853.3703: *6* configure_tags
def configure_tags (self):

    trace = False and not g.unitTesting
    verbose = False
    traceColor = False
    traceFonts = True
    c = self.c ; w = self.w
    isQt = g.app.gui.guiName().startswith('qt')

    if trace: g.trace(self.colorizer.language) # ,g.callers(5))

    # The stated default is 40, but apparently it must be set explicitly.
    tabWidth = c.config.getInt('qt-tab-width') or 40
    w.widget.setTabStopWidth(tabWidth)

    if w and hasattr(w,'start_tag_configure'):
        w.start_tag_configure()

    # Get the default body font.
    defaultBodyfont = self.fonts.get('default_body_font')
    if not defaultBodyfont:
        defaultBodyfont = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize)
        self.fonts['default_body_font'] = defaultBodyfont

    # Configure fonts.
    keys = list(self.default_font_dict.keys()) ; keys.sort()
    for key in keys:
        option_name = self.default_font_dict[key]
        # First, look for the language-specific setting, then the general setting.
        for name in ('%s_%s' % (self.colorizer.language,option_name),(option_name)):
            if trace: g.trace(name)
            font = self.fonts.get(name)
            if font:
                if trace and traceFonts:
                    g.trace('**found',name,id(font))
                w.tag_config(key,font=font)
                break
            else:
                family = c.config.get(name + '_family','family')
                size   = c.config.get(name + '_size',  'size')   
                slant  = c.config.get(name + '_slant', 'slant')
                weight = c.config.get(name + '_weight','weight')
                if family or slant or weight or size:
                    family = family or g.app.config.defaultFontFamily
                    size   = size or c.config.defaultBodyFontSize
                    slant  = slant or 'roman'
                    weight = weight or 'normal'
                    font = g.app.gui.getFontFromParams(family,size,slant,weight)
                    # Save a reference to the font so it 'sticks'.
                    self.fonts[key] = font
                    if trace and traceFonts:
                        g.trace('**found',key,name,family,size,slant,weight,id(font))
                    w.tag_config(key,font=font)
                    break

        else: # Neither the general setting nor the language-specific setting exists.
            if list(self.fonts.keys()): # Restore the default font.
                if trace and traceFonts:
                    g.trace('default',key,font)
                self.fonts[key] = font # 2010/02/19: Essential
                w.tag_config(key,font=defaultBodyfont)
            else:
                if trace and traceFonts:
                    g.trace('no fonts')
                    
        if isQt and key == 'url' and font:
            font.setUnderline(True) # 2011/03/04

    keys = list(self.default_colors_dict.keys()) ; keys.sort()
    for name in keys:
        option_name,default_color = self.default_colors_dict[name]
        color = (
            c.config.getColor('%s_%s' % (self.colorizer.language,option_name)) or
            c.config.getColor(option_name) or
            default_color
        )
        if trace and traceColor: g.trace(option_name,color)

        # Must use foreground, not fg.
        try:
            w.tag_configure(name, foreground=color)
        except: # Recover after a user error.
            g.es_exception()
            w.tag_configure(name, foreground=default_color)

    # underline=var doesn't seem to work.
    if 0: # self.use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
        w.tag_configure("link",underline=1) # defined
        w.tag_configure("name",underline=0) # undefined
    else:
        w.tag_configure("link",underline=0)
        if self.underline_undefined:
            w.tag_configure("name",underline=1)
        else:
            w.tag_configure("name",underline=0)

    self.configure_variable_tags()

    # Colors for latex characters.  Should be user options...

    if 1: # Alas, the selection doesn't show if a background color is specified.
        w.tag_configure("latexModeBackground",foreground="black")
        w.tag_configure("latexModeKeyword",foreground="blue")
        w.tag_configure("latexBackground",foreground="black")
        w.tag_configure("latexKeyword",foreground="blue")
    else: # Looks cool, and good for debugging.
        w.tag_configure("latexModeBackground",foreground="black",background="seashell1")
        w.tag_configure("latexModeKeyword",foreground="blue",background="seashell1")
        w.tag_configure("latexBackground",foreground="black",background="white")
        w.tag_configure("latexKeyword",foreground="blue",background="white")

    # Tags for wiki coloring.
    w.tag_configure("bold",font=self.bold_font)
    w.tag_configure("italic",font=self.italic_font)
    w.tag_configure("bolditalic",font=self.bolditalic_font)
    for name in self.color_tags_list:
        w.tag_configure(name,foreground=name)

    try:
        w.end_tag_configure()
    except AttributeError:
        pass
#@+node:ekr.20090614134853.3704: *6* configure_variable_tags
def configure_variable_tags (self):

    c = self.c ; w = self.w

    # g.trace()

    for name,option_name,default_color in (
        ("blank","show_invisibles_space_background_color","Gray90"),
        ("tab",  "show_invisibles_tab_background_color",  "Gray80"),
        ("elide", None,                                   "yellow"),
    ):
        if self.showInvisibles:
            color = option_name and c.config.getColor(option_name) or default_color
        else:
            option_name,default_color = self.default_colors_dict.get(name,(None,None),)
            color = option_name and c.config.getColor(option_name) or ''
        try:
            w.tag_configure(name,background=color)
        except: # A user error.
            w.tag_configure(name,background=default_color)

    # Special case:
    if not self.showInvisibles:
        w.tag_configure("elide",elide="1")
#@+node:ekr.20090614134853.3705: *6* init (jeditColorizer)
def init (self,p,s):

    trace = False and not g.unitTesting

    if p: self.p = p.copy()
    self.all_s = s or ''

    if trace: g.trace('='*20,self.colorizer.language) #,g.callers(4))

    # State info.
    self.all_s = s
    self.global_i,self.global_j = 0,0
    self.global_offset = 0

    # These *must* be recomputed.
    self.nextState = 1 # Dont use 0.
    self.stateDict = {}
    self.stateNameDict = {}
    self.restartDict = {}
    self.init_mode(self.colorizer.language)
    self.clearState()
    self.showInvisibles = self.colorizer.showInvisibles
        # The show/hide-invisible commands changes this.

    # Used by matchers.
    self.prev = None
    if self.last_language != self.colorizer.language:
        # Must be done to support per-language @font/@color settings.
        self.configure_tags()
        self.last_language = self.colorizer.language
#@+node:ekr.20090614134853.3706: *6* init_mode & helpers
def init_mode (self,name):

    '''Name may be a language name or a delegate name.'''

    trace = False and not g.unitTesting
    if not name: return False
    h = self.highlighter
    language,rulesetName = self.nameToRulesetName(name)
    # if trace: g.trace(name,list(self.modes.keys()))
    bunch = self.modes.get(rulesetName)
    if bunch:
        if trace: g.trace('found',language,rulesetName,g.callers(2))
        self.initModeFromBunch(bunch)
        return True
    else:
        if trace: g.trace(language,rulesetName)
        path = g.os_path_join(g.app.loadDir,'..','modes')
        # Bug fix: 2008/2/10: Don't try to import a non-existent language.
        fileName = g.os_path_join(path,'%s.py' % (language))
        if g.os_path_exists(fileName):
            mode = g.importFromPath (language,path)
        else: mode = None

        if mode:
            # A hack to give modes/forth.py access to c.
            if hasattr(mode,'pre_init_mode'):
                mode.pre_init_mode(self.c)
        else:
            # Create a dummy bunch to limit recursion.
            self.modes [rulesetName] = self.modeBunch = g.Bunch(
                attributesDict  = {},
                defaultColor    = None,
                keywordsDict    = {},
                language        = language,
                mode            = mode,
                properties      = {},
                rulesDict       = {},
                rulesetName     = rulesetName,
            )
            if trace: g.trace('***** No colorizer file: %s.py' % language)
            self.rulesetName = rulesetName
            return False
        self.colorizer.language = language
        self.rulesetName = rulesetName
        self.properties = hasattr(mode,'properties') and mode.properties or {}
        self.keywordsDict = hasattr(mode,'keywordsDictDict') and mode.keywordsDictDict.get(rulesetName,{}) or {}
        self.setKeywords()
        self.attributesDict = hasattr(mode,'attributesDictDict') and mode.attributesDictDict.get(rulesetName) or {}
        # g.trace('*******',rulesetName,self.attributesDict)
        self.setModeAttributes()
        self.rulesDict = hasattr(mode,'rulesDictDict') and mode.rulesDictDict.get(rulesetName) or {}
        self.addLeoRules(self.rulesDict)

        self.defaultColor = 'null'
        self.mode = mode
        self.modes [rulesetName] = self.modeBunch = g.Bunch(
            attributesDict  = self.attributesDict,
            defaultColor    = self.defaultColor,
            keywordsDict    = self.keywordsDict,
            language        = self.colorizer.language,
            mode            = self.mode,
            properties      = self.properties,
            rulesDict       = self.rulesDict,
            rulesetName     = self.rulesetName,
        )
        # Do this after 'officially' initing the mode, to limit recursion.
        self.addImportedRules(mode,self.rulesDict,rulesetName)
        self.updateDelimsTables()
        initialDelegate = self.properties.get('initialModeDelegate')
        if initialDelegate:
            if trace: g.trace('initialDelegate',initialDelegate)
            # Replace the original mode by the delegate mode.
            self.init_mode(initialDelegate)
            language2,rulesetName2 = self.nameToRulesetName(initialDelegate)
            self.modes[rulesetName] = self.modes.get(rulesetName2)
        return True
#@+node:ekr.20090614134853.3707: *7* nameToRulesetName
def nameToRulesetName (self,name):

    '''Compute language and rulesetName from name, which is either a language or a delegate name.'''

    if not name: return ''

    i = name.find('::')
    if i == -1:
        language = name
        rulesetName = '%s_main' % (language)
    else:
        language = name[:i]
        delegate = name[i+2:]
        rulesetName = self.munge('%s_%s' % (language,delegate))

    # if rulesetName == 'php_main': rulesetName = 'php_php'

    # g.trace(name,language,rulesetName)
    return language,rulesetName
#@+node:ekr.20090614134853.3708: *7* setKeywords
def setKeywords (self):

    '''Initialize the keywords for the present language.

     Set self.word_chars ivar to string.letters + string.digits
     plus any other character appearing in any keyword.'''

    # Add any new user keywords to leoKeywordsDict.
    d = self.keywordsDict
    keys = list(d.keys())
    for s in g.globalDirectiveList:
        key = '@' + s
        if key not in keys:
            d [key] = 'leoKeyword'

    # Create a temporary chars list.  It will be converted to a dict later.
    chars = [g.toUnicode(ch) for ch in (string.ascii_letters + string.digits)]

    for key in list(d.keys()):
        for ch in key:
            if ch not in chars:
                chars.append(g.toUnicode(ch))

    # jEdit2Py now does this check, so this isn't really needed.
    # But it is needed for forth.py.
    for ch in (' ', '\t'):
        if ch in chars:
            # g.es_print('removing %s from word_chars' % (repr(ch)))
            chars.remove(ch)

    # g.trace(self.colorizer.language,[str(z) for z in chars])

    # Convert chars to a dict for faster access.
    self.word_chars = {}
    for z in chars:
        self.word_chars[z] = z
#@+node:ekr.20090614134853.3709: *7* setModeAttributes
def setModeAttributes (self):

    '''Set the ivars from self.attributesDict,
    converting 'true'/'false' to True and False.'''

    d = self.attributesDict
    aList = (
        ('default',         'null'),
	    ('digit_re',        ''),
        ('escape',          ''), # New in Leo 4.4.2.
	    ('highlight_digits',True),
	    ('ignore_case',     True),
	    ('no_word_sep',     ''),
    )

    # g.trace(d)

    for key, default in aList:
        val = d.get(key,default)
        if val in ('true','True'): val = True
        if val in ('false','False'): val = False
        setattr(self,key,val)
        # g.trace(key,val)
#@+node:ekr.20090614134853.3710: *7* initModeFromBunch
def initModeFromBunch (self,bunch):

    self.modeBunch = bunch
    self.attributesDict = bunch.attributesDict
    self.setModeAttributes()
    self.defaultColor   = bunch.defaultColor
    self.keywordsDict   = bunch.keywordsDict
    self.colorizer.language = bunch.language
    self.mode           = bunch.mode
    self.properties     = bunch.properties
    self.rulesDict      = bunch.rulesDict
    self.rulesetName    = bunch.rulesetName

    # State stuff.
    # h = self.highlighter
    # h.setCurrentBlockState(bunch.currentState)
    # self.nextState      = bunch.nextState
    # self.restartDict    = bunch.restartDict
    # self.stateDict      = bunch.stateDict
    # self.stateNameDict  = bunch.stateNameDict

    # self.clearState()

    # g.trace(self.rulesetName)

#@+node:ekr.20090614134853.3711: *7* updateDelimsTables
def updateDelimsTables (self):

    '''Update g.app.language_delims_dict if no entry for the language exists.'''

    d = self.properties
    lineComment = d.get('lineComment')
    startComment = d.get('commentStart')
    endComment = d.get('commentEnd')

    if lineComment and startComment and endComment:
        delims = '%s %s %s' % (lineComment,startComment,endComment)
    elif startComment and endComment:
        delims = '%s %s' % (startComment,endComment)
    elif lineComment:
        delims = '%s' % lineComment
    else:
        delims = None

    if delims:
        d = g.app.language_delims_dict
        if not d.get(self.colorizer.language):
            d [self.colorizer.language] = delims
            # g.trace(self.colorizer.language,'delims:',repr(delims))
#@+node:ekr.20090614134853.3712: *6* munge
def munge(self,s):

    '''Munge a mode name so that it is a valid python id.'''

    valid = string.ascii_letters + string.digits + '_'

    return ''.join([g.choose(ch in valid,ch.lower(),'_') for ch in s])
#@+node:ekr.20090614134853.3713: *6* setFontFromConfig
def setFontFromConfig (self):

    c = self.c
    # isQt = g.app.gui.guiName() == 'qt'

    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize) # , tag = "colorer bold")

    # if self.bold_font and not isQt:
        # self.bold_font.configure(weight="bold")

    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize) # , tag = "colorer italic")

    # if self.italic_font and not isQt:
        # self.italic_font.configure(slant="italic",weight="normal")

    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize) # , tag = "colorer bold italic")

    # if self.bolditalic_font and not isQt:
        # self.bolditalic_font.configure(weight="bold",slant="italic")

    self.color_tags_list = []
    # self.image_references = []
#@+node:ekr.20090614134853.3715: *5*  Pattern matchers
#@+node:ekr.20090614134853.3816: *6*  About the pattern matchers
@nocolor-node
@

The following jEdit matcher methods return the length of the matched text if the
match succeeds, and zero otherwise. In most cases, these methods colorize all
the matched text.

The following arguments affect matching:

- at_line_start         True: sequence must start the line.
- at_whitespace_end     True: sequence must be first non-whitespace text of the line.
- at_word_start         True: sequence must start a word.
- hash_char             The first character that must match in a regular expression.
- no_escape:            True: ignore an 'end' string if it is preceded by
                        the ruleset's escape character.
- no_line_break         True: the match will not succeed across line breaks.
- no_word_break:        True: the match will not cross word breaks.

The following arguments affect coloring when a match succeeds:

- delegate              A ruleset name. The matched text will be colored recursively
                        by the indicated ruleset.
- exclude_match         If True, the actual text that matched will not be colored.
- kind                  The color tag to be applied to colored text.
#@+node:ekr.20090614134853.3716: *6* dump
def dump (self,s):

    if s.find('\n') == -1:
        return s
    else:
        return '\n' + s + '\n'
#@+node:ekr.20090614134853.3717: *6* Leo rule functions
#@+node:ekr.20090614134853.3718: *7* match_at_color
def match_at_color (self,s,i):

    if self.trace_leo_matches: g.trace()

    seq = '@color'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        self.colorizer.flag = True # Enable coloring.
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,'leoKeyword')
        self.clearState()
        return j - i
    else:
        return 0
#@+node:ekr.20110117083659.3791: *7* match_at_language
def match_at_language (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    seq = '@language'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        j = i + len(seq)
        j = g.skip_ws(s,j)
        k = g.skip_c_id(s,j)
        name = s[j:k]
        ok = self.init_mode(name)
        # g.trace(ok,name)
        if ok:
            self.colorRangeWithTag(s,i,k,'leoKeyword')
        else:
            self.colorRangeWithTag(s,i,j,'leoKeyword')
        self.clearState()
        return k - i
    else:
        return 0
#@+node:ekr.20090614134853.3719: *7* match_at_nocolor & restarter
def match_at_nocolor (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    # Only matches at start of line.
    if i == 0 and not g.match(s,i,'@nocolor-') and g.match_word(s,i,'@nocolor'):
        self.setRestart(self.restartNoColor)
        return len(s) # Match everything.
    else:
        return 0
#@+node:ekr.20090614213243.3838: *8* restartNoColor
def restartNoColor (self,s):

    if self.trace_leo_matches: g.trace(repr(s))

    if g.match_word(s,0,'@color'):
        self.clearState()
    else:
        self.setRestart(self.restartNoColor)

    return len(s) # Always match everything.
#@+node:ekr.20090614134853.3720: *7* match_at_killcolor & restarter
def match_at_killcolor (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@killcolor'

    if g.match_word(s,i,tag):
        self.setRestart(self.restartKillColor)
        return len(s) # Match everything.
    else:
        return 0

#@+node:ekr.20090614190437.3833: *8* restartKillColor
def restartKillColor(self,s):

    self.setRestart(self.restartKillColor)
    return len(s)+1
#@+node:ekr.20090614134853.3721: *7* match_at_nocolor_node & restarter
def match_at_nocolor_node (self,s,i):

    if self.trace_leo_matches: g.trace()

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@nocolor-node'

    if g.match_word(s,i,tag):
        self.setRestart(self.restartNoColorNode)
        return len(s) # Match everything.
    else:
        return 0
#@+node:ekr.20090614213243.3836: *8* restartNoColorNode
def restartNoColorNode(self,s):

    self.setRestart(self.restartNoColorNode)
    return len(s)+1
#@+node:ekr.20090614134853.3722: *7* match_blanks
def match_blanks (self,s,i):

    if not self.showInvisibles:
        return 0

    j = i ; n = len(s)

    while j < n and s[j] == ' ':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'blank')
        return j - i
    else:
        return 0
#@+node:ekr.20090614134853.3723: *7* match_doc_part & restarter
def match_doc_part (self,s,i):

    # New in Leo 4.5: only matches at start of line.
    if i != 0:
        return 0
    elif g.match_word(s,i,'@doc'):
        j = i + 4
    elif g.match(s,i,'@') and (i+1 >= len(s) or s[i+1] in (' ','\t','\n')):
        j = i + 1
    else:
        return 0

    self.colorRangeWithTag(s,i,j,'leoKeyword')
    self.colorRangeWithTag(s,j,len(s),'docPart')
    self.setRestart(self.restartDocPart)

    return len(s)
#@+node:ekr.20090614213243.3837: *8* restartDocPart
def restartDocPart (self,s):

    for tag in ('@c','@code'):
        if g.match_word(s,0,tag):
            j = len(tag)
            self.colorRangeWithTag(s,0,j,'leoKeyword') # 'docPart')
            self.clearState()
            return j
    else:
        self.setRestart(self.restartDocPart)
        self.colorRangeWithTag(s,0,len(s),'docPart')

        return len(s)
#@+node:ekr.20090614134853.3724: *7* match_leo_keywords
def match_leo_keywords(self,s,i):

    '''Succeed if s[i:] is a Leo keyword.'''

    # g.trace(i,g.get_line(s,i))

    self.totalLeoKeywordsCalls += 1

    if s[i] != '@':
        return 0

    # fail if something besides whitespace precedes the word on the line.
    i2 = i-1
    while i2 >= 0:
        ch = s[i2]
        if ch == '\n':
            break
        elif ch in (' ','\t'):
            i2 -= 1
        else:
            # g.trace('not a word 1',repr(ch))
            return 0

    # Get the word as quickly as possible.
    j = i+1
    while j < len(s) and s[j] in self.word_chars:
        j += 1
    word = s[i+1:j] # entries in leoKeywordsDict do not start with '@'.

    if j < len(s) and s[j] not in (' ','\t','\n'):
        # g.trace('not a word 2',repr(word))
        return 0 # Fail, but allow a rescan, as in objective_c.

    if self.leoKeywordsDict.get(word):
        kind = 'leoKeyword'
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j-i+1 # Bug fix: skip the last character.
        self.trace_match(kind,s,i,j)
        # g.trace('*** match',repr(s))
        return result
    else:
        # 2010/10/20: also check the keywords dict here.
        # This allows for objective_c keywords starting with '@'
        # This will not slow down Leo, because it is called
        # for things that look like Leo directives.
        word = '@' + word
        kind = self.keywordsDict.get(word)
        if kind:
            self.colorRangeWithTag(s,i,j,kind)
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            # g.trace('found',word)
            return j-i
        else:
            # g.trace('fail',repr(word),repr(self.word_chars))
            return -(j-i+1) # An important optimization.
#@+node:ekr.20090614134853.3725: *7* match_section_ref
def match_section_ref (self,s,i):

    if self.trace_leo_matches: g.trace()
    c = self.c ; p = c.currentPosition()
    w = self.w

    if not g.match(s,i,'<<'):
        return 0
    k = g.find_on_line(s,i+2,'>>')
    if k is not None:
        j = k + 2
        self.colorRangeWithTag(s,i,i+2,'nameBrackets')
        ref = g.findReference(c,s[i:j],p)
        if ref:
            if self.use_hyperlinks:
                << set the hyperlink >>
            else:
                self.colorRangeWithTag(s,i+2,k,'link')
        else:
            self.colorRangeWithTag(s,i+2,k,'name')
        self.colorRangeWithTag(s,k,j,'nameBrackets')
        return j - i
    else:
        return 0
#@+node:ekr.20090614134853.3726: *8* << set the hyperlink >>
# Set the bindings to vnode callbacks.
# Create the tag.
# Create the tag name.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
w.tag_delete(tagName)
w.tag_add(tagName,i+2,j)

ref.tagName = tagName
c.tag_bind(w,tagName,"<Control-1>",ref.OnHyperLinkControlClick)
c.tag_bind(w,tagName,"<Any-Enter>",ref.OnHyperLinkEnter)
c.tag_bind(w,tagName,"<Any-Leave>",ref.OnHyperLinkLeave)
#@+node:ekr.20090614134853.3727: *7* match_tabs
def match_tabs (self,s,i):

    if not self.showInvisibles:
        return 0

    if self.trace_leo_matches: g.trace()

    j = i ; n = len(s)

    while j < n and s[j] == '\t':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'tab')
        return j - i
    else:
        return 0
#@+node:ekr.20110304061301.14037: *7* match_url_any/f/h  (new)
url_regex_f = re.compile(r"""(file|ftp)://[^\s'"]+[\w=/]""")
url_regex_h = re.compile(r"""(http|https)://[^\s'"]+[\w=/]""")
url_regex   = re.compile(r"""(file|ftp|http|https)://[^\s'"]+[\w=/]""")

def match_any_url(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):

def match_url_f(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_f)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):
    
def match_url_h(self,s,i):
    
     return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_h)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):
#@+node:ekr.20110304061301.14040: *6* match_compiled_regexp (new)
def match_compiled_regexp (self,s,i,kind,regexp,delegate=''):

    '''Succeed if the compiled regular expression regexp matches at s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

    # if at_line_start and i != 0 and s[i-1] != '\n': return 0
    # if at_whitespace_end and i != g.skip_ws(s,0): return 0
    # if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0

    n = self.match_compiled_regexp_helper(s,i,regexp)
    if n > 0:
        j = i + n
        assert (j-i == n)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    else:
        return 0
#@+node:ekr.20110304061301.14041: *7* match_compiled_regexp_helper
def match_compiled_regexp_helper (self,s,i,regex):
    
    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = regex.match(s,i) # re_obj.search(s,i) 

    if mo is None:
        return 0
    start, end = mo.start(), mo.end()
    if start != i:
        return 0
    # if trace:
        # g.trace('pattern',pattern)
        # g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
        # g.trace('groups',mo.groups())
    return end - start
#@+node:ekr.20090614134853.3728: *6* match_eol_span
def match_eol_span (self,s,i,
    kind=None,seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if seq matches s[i:]'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        return 0

    if g.match(s,i,seq):
        j = len(s)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j # (was j-1) With a delegate, this could clear state.
    else:
        return 0
#@+node:ekr.20090614134853.3729: *6* match_eol_span_regexp
def match_eol_span_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if the regular expression regex matches s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,regexp)
    if n > 0:
        j = len(s)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    else:
        return 0
#@+node:ekr.20100330091222.3702: *6* match_everything
# def match_everything (self,s,i,kind=None,delegate='',exclude_match=False):

    # '''Match the entire rest of the string.'''

    # j = len(s)
    # self.colorRangeWithTag(s,i,j,kind,delegate=delegate)

    # return j
#@+node:ekr.20090614134853.3730: *6* match_keywords
# This is a time-critical method.
def match_keywords (self,s,i):

    '''Succeed if s[i:] is a keyword.'''

    # trace = False
    self.totalKeywordsCalls += 1

    # Important.  Return -len(word) for failure greatly reduces
    # the number of times this method is called.

    # We must be at the start of a word.
    if i > 0 and s[i-1] in self.word_chars:
        # if trace: g.trace('not at word start',s[i-1])
        return 0

    # Get the word as quickly as possible.
    j = i ; n = len(s) ; chars = self.word_chars
    while j < n and s[j] in chars:
        j += 1

    word = s[i:j]
    if self.ignore_case: word = word.lower()
    kind = self.keywordsDict.get(word)
    if kind:
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j - i
        # if trace: g.trace('success',word,kind,j-i)
        self.trace_match(kind,s,i,j)
        return result
    else:
        # if trace: g.trace('fail',word,kind)
        return -len(word) # An important new optimization.
#@+node:ekr.20101024205622.3754: *6* match_line
def match_line (self,s,i,kind=None,delegate='',exclude_match=False):

    '''Match the rest of the line.'''

    j = g.skip_to_end_of_line(s,i)

    self.colorRangeWithTag(s,i,j,kind,delegate=delegate)

    return j-i
#@+node:ekr.20090614134853.3731: *6* match_mark_following & getNextToken
def match_mark_following (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    if not self.allow_mark_prev: return 0

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(pattern) + 1 < len(s) and s[i+len(pattern)] in self.word_chars:
        return 0 # 7/5/2008

    if g.match(s,i,pattern):
        j = i + len(pattern)
        self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
        k = self.getNextToken(s,j)
        if k > j:
            self.colorRangeWithTag(s,j,k,kind,exclude_match=False)
            j = k
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    else:
        return 0
#@+node:ekr.20090614134853.3732: *7* getNextToken
def getNextToken (self,s,i):

    '''Return the index of the end of the next token for match_mark_following.

    The jEdit docs are not clear about what a 'token' is, but experiments with jEdit
    show that token means a word, as defined by word_chars.'''

    while i < len(s) and s[i] in self.word_chars:
        i += 1

    return min(len(s),i+1)
#@+node:ekr.20090614134853.3733: *6* match_mark_previous
def match_mark_previous (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Return the length of a matched SEQ or 0 if no match.

    'at_line_start':    True: sequence must start the line.
    'at_whitespace_end':True: sequence must be first non-whitespace text of the line.
    'at_word_start':    True: sequence must start a word.'''

    # This match was causing most of the syntax-color problems.
    return 0 # 2009/6/23
#@+node:ekr.20090614134853.3734: *6* match_regexp_helper
def match_regexp_helper (self,s,i,pattern):

    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

    trace = False and not g.unitTesting
    if trace: g.trace('%-10s %-20s %s' % (
        self.colorizer.language,pattern,s)) # g.callers(1)

    try:
        flags = re.MULTILINE
        if self.ignore_case: flags|= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        # Do not call g.es here!
        g.trace('Invalid regular expression: %s' % (pattern))
        return 0

    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = re_obj.match(s,i) # re_obj.search(s,i) 

    if mo is None:
        return 0
    else:
        start, end = mo.start(), mo.end()
        if start != i: # Bug fix 2007-12-18: no match at i
            return 0
        if trace:
            g.trace('pattern',pattern)
            g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
            g.trace('groups',mo.groups())
        return end - start
#@+node:ekr.20090614134853.3735: *6* match_seq
def match_seq (self,s,i,
    kind='',seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if s[:] mathces seq.'''

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars:  # 7/5/2008
        j = i
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        j = i # 7/5/2008
    elif g.match(s,i,seq):
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
    else:
        j = i
    return j - i
#@+node:ekr.20090614134853.3736: *6* match_seq_regexp
def match_seq_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if the regular expression regexp matches at s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0

    n = self.match_regexp_helper(s,i,regexp)
    j = i + n
    assert (j-i == n)
    self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
    self.prev = (i,j,kind)
    self.trace_match(kind,s,i,j)
    return j - i
#@+node:ekr.20090614134853.3737: *6* match_span & helper & restarter
def match_span (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False,no_word_break=False):

    '''Succeed if s[i:] starts with 'begin' and contains a following 'end'.'''

    trace = False and not g.unitTesting
    if i >= len(s): return 0

    # g.trace(begin,end,no_escape,no_line_break,no_word_break)

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars:
        j = i
    elif at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        j = i
    elif not g.match(s,i,begin):
        j = i
    else:
        # We have matched the start of the span.
        j = self.match_span_helper(s,i+len(begin),end,
            no_escape,no_line_break,no_word_break=no_word_break)
        # g.trace('** helper returns',j,len(s))
        if j == -1:
            j = i # A real failure.
        else:
            # A match
            i2 = i + len(begin) ; j2 = j + len(end)
            if delegate:
                self.colorRangeWithTag(s,i,i2,kind,delegate=None,    exclude_match=exclude_match)
                self.colorRangeWithTag(s,i2,j,kind,delegate=delegate,exclude_match=exclude_match)
                self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
            else:
                self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
            j = j2
            self.prev = (i,j,kind)

    self.trace_match(kind,s,i,j)

    if j > len(s):
        j = len(s) + 1
        def boundRestartMatchSpan(s):
            # Note: bindings are frozen by this def.
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate,end,exclude_match,kind,
                no_escape,no_line_break,no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keywords args.
            delegate=delegate,end=end,
            exclude_match=exclude_match,
            kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)

        if trace: g.trace('***Continuing',kind,i,j,len(s))
    elif j != i:
        if trace: g.trace('***Ending',kind,i,j,s[i:j])
        self.clearState()

    return j - i # Correct, whatever j is.
#@+node:ekr.20090614134853.3738: *7* match_span_helper
def match_span_helper (self,s,i,pattern,no_escape,no_line_break,no_word_break):

    '''Return n >= 0 if s[i] ends with a non-escaped 'end' string.'''

    esc = self.escape

    while 1:
        j = s.find(pattern,i)
        # g.trace(no_line_break,j,len(s))
        if j == -1:
            # Match to end of text if not found and no_line_break is False
            if no_line_break:
                return -1
            else:
                return len(s)+1
        elif no_word_break and j > 0 and s[j-1] in self.word_chars:
            return -1 # New in Leo 4.5.
        elif no_line_break and '\n' in s[i:j]:
            return -1
        elif esc and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == esc:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # Continue searching past the escaped pattern string.
                i = j + len(pattern) # Bug fix: 7/25/07.
                # g.trace('escapes',escapes,repr(s[i:]))
            else:
                return j
        else:
            return j
#@+node:ekr.20090614134853.3821: *7* restart_match_span
def restart_match_span (self,s,
    delegate,end,exclude_match,kind,
    no_escape,no_line_break,no_word_break):

    '''Remain in this state until 'end' is seen.'''

    trace = False and not g.unitTesting

    i = 0
    j = self.match_span_helper(s,i,end,no_escape,no_line_break,no_word_break)
    if j == -1:
        j2 = len(s)+1
    elif j > len(s):
        j2 = j
    else:
        j2 = j + len(end)

    if delegate:
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
    else: # avoid having to merge ranges in addTagsToList.
        self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
    j = j2

    self.trace_match(kind,s,i,j)

    if j > len(s):
        def boundRestartMatchSpan(s):
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate,end,exclude_match,kind,
                no_escape,no_line_break,no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keywords args.
            delegate=delegate,end=end,kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)

        if trace: g.trace('***Re-continuing',i,j,len(s),s,g.callers(5))
    else:
        if trace: g.trace('***ending',i,j,len(s),s)
        self.clearState()

    return j # Return the new i, *not* the length of the match.
#@+node:ekr.20090614134853.3739: *6* match_span_regexp
def match_span_regexp (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False, no_word_break=False,
):

    '''Succeed if s[i:] starts with 'begin' (a regular expression) and contains a following 'end'.'''

    if self.verbose: g.trace('begin',repr(begin),'end',repr(end),self.dump(s[i:]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,begin)
    # We may have to allow $n here, in which case we must use a regex object?
    if n > 0:
        j = i + n
        j2 = s.find(end,j)
        if j2 == -1: return 0
        if self.escape and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == self.escape:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # An escaped end **aborts the entire match**:
                # there is no way to 'restart' the regex.
                return 0
        i2 = j2 - len(end)
        if delegate:
            self.colorRangeWithTag(s,i,j,kind, delegate=None,     exclude_match=exclude_match)
            self.colorRangeWithTag(s,j,i2,kind, delegate=delegate,exclude_match=False)
            self.colorRangeWithTag(s,i2,j2,kind,delegate=None,    exclude_match=exclude_match)
        else: # avoid having to merge ranges in addTagsToList.
            self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j2)
        return j2 - i
    else: return 0
#@+node:ekr.20090614134853.3740: *6* match_word_and_regexp
def match_word_and_regexp (self,s,i,
    kind1='',word='',
    kind2='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    if not self.allow_mark_prev: return 0

    if (False or self.verbose): g.trace(i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0
    if at_word_start and i + len(word) + 1 < len(s) and s[i+len(word)] in self.word_chars:
        j = i

    if not g.match(s,i,word):
        return 0

    j = i + len(word)
    n = self.match_regexp_helper(s,j,pattern)
    if n == 0:
        return 0
    self.colorRangeWithTag(s,i,j,kind1,exclude_match=exclude_match)
    k = j + n
    self.colorRangeWithTag(s,j,k,kind2,exclude_match=False)    
    self.prev = (j,k,kind2)
    self.trace_match(kind1,s,i,j)
    self.trace_match(kind2,s,j,k)
    return k - i
#@+node:ekr.20090614134853.3741: *6* skip_line
def skip_line (self,s,i):

    if self.escape:
        escape = self.escape + '\n'
        n = len(escape)
        while i < len(s):
            j = g.skip_line(s,i)
            if not g.match(s,j-n,escape):
                return j
            # g.trace('escape',s[i:j])
            i = j
        return i
    else:
        return g.skip_line(s,i)
            # Include the newline so we don't get a flash at the end of the line.
#@+node:ekr.20090614134853.3742: *6* trace_match
def trace_match(self,kind,s,i,j):

    if j != i and self.trace_match_flag:
        g.trace(kind,i,j,g.callers(2),self.dump(s[i:j]))
#@+node:ekr.20090614134853.3828: *5*  State methods
#@+node:ekr.20090625061310.3860: *6* clearState
def clearState (self):

    self.setState(-1)
#@+node:ekr.20090614134853.3825: *6* computeState
def computeState (self,f,keys):

    '''Compute the state name associated with f and all the keys.

    Return a unique int n representing that state.'''

    # Abbreviate arg names.
    d = {
        'delegate':'del:',
        'end':'end',
        'at_line_start':'line-start',
        'at_whitespace_end':'ws-end',
        'exclude_match':'exc-match',
        'no_escape':'no-esc',
        'no_line_break':'no-brk',
        'no_word_break':'no-word-brk',
    }
    result = [
        f.__name__,
        self.colorizer.language,
        self.rulesetName]
    for key in keys:
        keyVal = keys.get(key)
        val = d.get(key)
        if val is None:
            val = keys.get(key)
            result.append('%s=%s' % (key,val))
        elif keyVal is True:
            result.append('%s' % val)
        elif keyVal is False:
            pass
        elif keyVal not in (None,''):
            result.append('%s=%s' % (key,keyVal))
    state = ';'.join(result)

    n = self.stateNameToStateNumber(f,state)
    return n
#@+node:ekr.20090625061310.3863: *6* currentState and prevState
def currentState(self):

    return self.highlighter.currentBlockState()

def prevState(self):

    return self.highlighter.previousBlockState()
#@+node:ekr.20090614134853.3824: *6* setRestart
def setRestart (self,f,**keys):

    n = self.computeState(f,keys)
    self.setState(n)
#@+node:ekr.20090625061310.3861: *6* setState
def setState (self,n):

    trace = False and not g.unitTesting

    self.highlighter.setCurrentBlockState(n)

    if trace:
        stateName = self.showState(n)
        g.trace(stateName,g.callers(4))
#@+node:ekr.20090625061310.3862: *6* showState & showCurrentState
def showState (self,n):

    if n == -1: 
        return 'default-state'
    else:
        return self.stateDict.get(n,'<no state>')

def showCurrentState(self):

    n = self.currentState()
    return self.showState(n)

def showPrevState(self):

    n = self.prevState()
    return self.showState(n)
#@+node:ekr.20090614134853.3826: *6* stateNameToStateNumber
def stateNameToStateNumber (self,f,stateName):

    # stateDict:     Keys are state numbers, values state names.
    # stateNameDict: Keys are state names, values are state numbers.
    # restartDict:   Keys are state numbers, values are restart functions

    n = self.stateNameDict.get(stateName)
    if n is None:
        n = self.nextState
        self.stateNameDict[stateName] = n
        self.stateDict[n] = stateName
        self.restartDict[n] = f
        self.nextState += 1
        # g.trace('========',n,stateName)

    return n
#@+node:ekr.20090614134853.3714: *5* colorRangeWithTag
def colorRangeWithTag (self,s,i,j,tag,delegate='',exclude_match=False):

    '''Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.'''

    trace = False and not g.unitTesting

    # Pattern matcher may set the .flag ivar.
    if self.colorizer.killColorFlag or not self.colorizer.flag:
        if trace: g.trace('disabled')
        return

    if delegate:
        if trace: g.trace('delegate %-12s %3s %3s %10s %s' % (
            delegate,i,j,tag,s[i:j])) # ,g.callers(2))
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        # Color everything now, using the same indices as the caller.
        while 0 <= i < j and i < len(s):
            progress = i
            assert j >= 0,j
            for f in self.rulesDict.get(s[i],[]):
                n = f(self,s,i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n > 0:
                    # if trace: g.trace('delegate',delegate,i,n,f.__name__,repr(s[i:i+n]))
                    i += n ; break
            else:
                # New in Leo 4.6: Use the default chars for everything else.
                # New in Leo 4.8 devel: use the *delegate's* default characters if possible.
                default_tag = self.attributesDict.get('default')
                # g.trace(default_tag)
                self.setTag(default_tag or tag,s,i,i+1)
                i += 1
            assert i > progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        if trace: g.trace(tag,s,i,j)
        self.setTag(tag,s,i,j)
        
    if tag != 'url':
        # Allow URL's *everywhere*.
        j = min(j,len(s))
        while i < j:
            if s[i].lower() in 'fh': # file|ftp|http|https
                n = self.match_any_url(s,i)
                i += max(1,n)
            else:
                i += 1
#@+node:ekr.20090614134853.3754: *5* mainLoop & restart
def mainLoop(self,n,s):

    '''Colorize string s, starting in state n.'''

    trace = False and not g.unitTesting
    traceMatch = True ; traceState = True ; verbose = True

    if trace and traceState: g.trace('** start',self.showState(n),s)

    i = 0
    if n > -1:
        i = self.restart(n,s,trace and traceMatch)
    if i == 0:
        self.setState(self.prevState())

    while i < len(s):
        progress = i
        functions = self.rulesDict.get(s[i],[])
        for f in functions:
            n = f(self,s,i)
            if n is None:
                g.trace('Can not happen: n is None',repr(f))
                break
            elif n > 0: # Success.
                if trace and traceMatch and f.__name__!='match_blanks':
                    g.trace('match: %20s %s' % (
                        f.__name__,s[i:i+n]))
                i += n
                break # Stop searching the functions.
            elif n < 0: # Fail and skip n chars.
                if trace and traceMatch and verbose:
                    g.trace('fail: %20s %s' % (
                        f.__name__,s[i:i+n]))
                i += -n
                break # Stop searching the functions.
            else: # Fail. Try the next function.
                pass # Do not break or change i!
        else:
            i += 1
        assert i > progress

    # Don't even *think* about clearing state here.
    # We remain in the starting state unless a match happens.
    if trace and traceState:
        g.trace('** end',self.showCurrentState(),s)
#@+node:ekr.20090625061310.3864: *6* restart
def restart (self,n,s,traceMatch):

    f = self.restartDict.get(n)
    if f:
        i = f(s)
        fname = f.__name__
        if traceMatch:
            if i > 0:
                g.trace('** restart match',fname,s[:i])
            else:
                g.trace('** restart fail',fname,s)
    else:
        g.trace('**** no restart f')
        i = 0

    return i
#@+node:ekr.20090614134853.3753: *5* recolor
def recolor (self,s):

    '''Recolor line s.'''

    trace = False and not g.unitTesting
    callers = False ; line = True ; state = False

    # Update the counts.
    self.recolorCount += 1
    self.totalChars += len(s)

    if self.colorizer.changingText:
        return
    if not self.colorizer.flag:
        return

    # Get the previous state.
    n = self.prevState() # The state at the end of the previous line.
    if trace:
        if line and state:
            g.trace('%2s %-50s %s' % (n,self.showState(n),s))
        elif line:
            g.trace('%2s %s' % (n,s))
        if callers: g.trace(g.callers())

    if s.strip():
        self.mainLoop(n,s)
    else:
        self.setState(n) # Required
#@+node:ekr.20090614134853.3813: *5* setTag
def setTag (self,tag,s,i,j):

    trace = False and not g.unitTesting

    if i == j:
        if trace: g.trace('empty range')
        return

    w = self.w
    colorName = w.configDict.get(tag)

    # Munge the color name.
    if not colorName:
        if trace: g.trace('no color for %s' % tag)
        return

    if colorName[-1].isdigit() and colorName[0] != '#':
        colorName = colorName[:-1]

    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name',colorName)

    underline = w.configUnderlineDict.get(tag)

    format = QtGui.QTextCharFormat()

    font = self.fonts.get(tag)
    if font:
        format.setFont(font)

    if trace:
        self.tagCount += 1
        g.trace(
            '%3s %3s %3s %9s %7s' % (i,j,len(s),font and id(font) or '<no font>',colorName),
            '%-10s %-25s' % (tag,s[i:j]),g.callers(2))

    if tag in ('blank','tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setFontUnderline(True)
    else:
        format.setForeground(color)

    self.highlighter.setFormat (i,j-i,format)

#@+node:ekr.20090614134853.3697: *4* __init__ (jeditColorizer)
def __init__(self,c,colorizer,highlighter,w):

    # Basic data...
    self.c = c
    self.colorizer = colorizer
    self.highlighter = highlighter # a QSyntaxHighlighter
    self.p = None
    self.w = w
    assert(w == self.c.frame.body.bodyCtrl)

    # Used by recolor and helpers...
    self.actualColorDict = {} # Used only by setTag.
    self.hyperCount = 0
    self.defaultState = 'default-state:' # The name of the default state.
    self.nextState = 1 # Dont use 0.
    self.restartDict = {} # Keys are state numbers, values are restart functions.
    self.stateDict = {} # Keys are state numbers, values state names.
    self.stateNameDict = {} # Keys are state names, values are state numbers.

    # Attributes dict ivars: defaults are as shown...
    self.default = 'null'
    self.digit_re = ''
    self.escape = ''
    self.highlight_digits = True
    self.ignore_case = True
    self.no_word_sep = ''
    # Config settings...
    self.showInvisibles = c.config.getBool("show_invisibles_by_default")
    self.colorizer.showInvisibles = self.showInvisibles
    # g.trace(self.showInvisibles)
        # Also set in init().
    self.underline_undefined = c.config.getBool("underline_undefined_section_names")
    self.use_hyperlinks = c.config.getBool("use_hyperlinks")
    # Debugging...
    self.count = 0 # For unit testing.
    self.allow_mark_prev = True # The new colorizer tolerates this nonsense :-)
    self.tagCount = 0
    self.trace = False or c.config.getBool('trace_colorizer')
    self.trace_leo_matches = False
    self.trace_match_flag = False # (Useful) True: trace all matching methods.
    self.verbose = False
    # Profiling...
    self.recolorCount = 0 # Total calls to recolor
    self.stateCount = 0 # Total calls to setCurrentState
    self.totalChars = 0 # The total number of characters examined by recolor.
    self.totalStates = 0
    self.maxStateNumber = 0
    self.totalKeywordsCalls = 0
    self.totalLeoKeywordsCalls = 0
    # Mode data...
    self.defaultRulesList = []
    self.importedRulesets = {}
    self.prev = None # The previous token.
    self.fonts = {} # Keys are config names.  Values are actual fonts.
    self.keywords = {} # Keys are keywords, values are 0..5.
    self.last_language = None # The language for which configuration tags are valid.
    self.modes = {} # Keys are languages, values are modes.
    self.mode = None # The mode object for the present language.
    self.modeBunch = None # A bunch fully describing a mode.
    self.modeStack = []
    self.rulesDict = {}
    # self.defineAndExtendForthWords()
    self.word_chars = {} # Inited by init_keywords().
    self.setFontFromConfig()
    self.tags = [
        "blank","comment","cwebName","docPart","keyword","leoKeyword",
        "latexModeBackground","latexModeKeyword",
        "latexBackground","latexKeyword",
        "link","name","nameBrackets","pp","string",
        "elide","bold","bolditalic","italic", # new for wiki styling.
        "tab",
        # Leo jEdit tags...
        '@color', '@nocolor', 'doc_part', 'section_ref',
        # jEdit tags.
        'bracketRange',
        'comment1','comment2','comment3','comment4',
        'function',
        'keyword1','keyword2','keyword3','keyword4',
        'label','literal1','literal2','literal3','literal4',
        'markup','operator',
    ]

    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
#@+node:ekr.20090614134853.3698: *5* defineLeoKeywordsDict
def defineLeoKeywordsDict(self):

    self.leoKeywordsDict = {}

    for key in g.globalDirectiveList:
        self.leoKeywordsDict [key] = 'leoKeyword'
#@+node:ekr.20090614134853.3699: *5* defineDefaultColorsDict
def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {
        # tag name       :(     option name,           default color),
        'blank'          :('blank_color',                 'black'), # 2010/1/2
        'tab'            :('tab_color',                   'black'), # 2010/1/2
        'comment'        :('comment_color',               'red'),
        'cwebName'       :('cweb_section_name_color',     'red'),
        'pp'             :('directive_color',             'blue'),
        'docPart'        :('doc_part_color',              'red'),
        'keyword'        :('keyword_color',               'blue'),
        'leoKeyword'     :('leo_keyword_color',           'blue'),
        'link'           :('section_name_color',          'red'),
        'nameBrackets'   :('section_name_brackets_color', 'blue'),
        'string'         :('string_color',                '#00aa00'), # Used by IDLE.
        'name'           :('undefined_section_name_color','red'),
        'latexBackground':('latex_background_color',      'white'),
        'url'            :('url_color',                   'purple'),

        # Tags used by forth.
        'bracketRange'   :('bracket_range_color','orange'),

        # jEdit tags.
        'comment1'       :('comment1_color', 'red'),
        'comment2'       :('comment2_color', 'red'),
        'comment3'       :('comment3_color', 'red'),
        'comment4'       :('comment4_color', 'red'),
        'function'       :('function_color', 'black'),
        'keyword1'       :('keyword1_color', 'blue'),
        'keyword2'       :('keyword2_color', 'blue'),
        'keyword3'       :('keyword3_color', 'blue'),
        'keyword4'       :('keyword4_color', 'blue'),
        'keyword5'       :('keyword5_color', 'blue'),
        'label'          :('label_color',    'black'),
        'literal1'       :('literal1_color', '#00aa00'),
        'literal2'       :('literal2_color', '#00aa00'),
        'literal3'       :('literal3_color', '#00aa00'),
        'literal4'       :('literal4_color', '#00aa00'),
        'markup'         :('markup_color',   'red'),
        'null'           :('null_color',     'black'),
        'operator'       :('operator_color', 'black'),
    }
#@+node:ekr.20090614134853.3700: *5* defineDefaultFontDict
def defineDefaultFontDict (self):

    self.default_font_dict = {
        # tag name      : option name
        'comment'       :'comment_font',
        'cwebName'      :'cweb_section_name_font',
        'pp'            :'directive_font',
        'docPart'       :'doc_part_font',
        'keyword'       :'keyword_font',
        'leoKeyword'    :'leo_keyword_font',
        'link'          :'section_name_font',
        'nameBrackets'  :'section_name_brackets_font',
        'string'        :'string_font',
        'name'          :'undefined_section_name_font',
        'latexBackground':'latex_background_font',
        'tab'           : 'tab_font',
        'url'           : 'url_font',

        # Tags used by forth.
        'bracketRange'   :'bracketRange_font',

         # jEdit tags.
        'comment1'      :'comment1_font',
        'comment2'      :'comment2_font',
        'comment3'      :'comment3_font',
        'comment4'      :'comment4_font',
        'function'      :'function_font',
        'keyword1'      :'keyword1_font',
        'keyword2'      :'keyword2_font',
        'keyword3'      :'keyword3_font',
        'keyword4'      :'keyword4_font',
        'keyword5'      :'keyword5_font',
        'label'         :'label_font',
        'literal1'      :'literal1_font',
        'literal2'      :'literal2_font',
        'literal3'      :'literal3_font',
        'literal4'      :'literal4_font',
        'markup'        :'markup_font',
        # 'nocolor' This tag is used, but never generates code.
        'null'          :'null_font',
        'operator'      :'operator_font',
    }
#@+node:ekr.20090614134853.3703: *4* configure_tags
def configure_tags (self):

    trace = False and not g.unitTesting
    verbose = False
    traceColor = False
    traceFonts = True
    c = self.c ; w = self.w
    isQt = g.app.gui.guiName().startswith('qt')

    if trace: g.trace(self.colorizer.language) # ,g.callers(5))

    # The stated default is 40, but apparently it must be set explicitly.
    tabWidth = c.config.getInt('qt-tab-width') or 40
    w.widget.setTabStopWidth(tabWidth)

    if w and hasattr(w,'start_tag_configure'):
        w.start_tag_configure()

    # Get the default body font.
    defaultBodyfont = self.fonts.get('default_body_font')
    if not defaultBodyfont:
        defaultBodyfont = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize)
        self.fonts['default_body_font'] = defaultBodyfont

    # Configure fonts.
    keys = list(self.default_font_dict.keys()) ; keys.sort()
    for key in keys:
        option_name = self.default_font_dict[key]
        # First, look for the language-specific setting, then the general setting.
        for name in ('%s_%s' % (self.colorizer.language,option_name),(option_name)):
            if trace: g.trace(name)
            font = self.fonts.get(name)
            if font:
                if trace and traceFonts:
                    g.trace('**found',name,id(font))
                w.tag_config(key,font=font)
                break
            else:
                family = c.config.get(name + '_family','family')
                size   = c.config.get(name + '_size',  'size')   
                slant  = c.config.get(name + '_slant', 'slant')
                weight = c.config.get(name + '_weight','weight')
                if family or slant or weight or size:
                    family = family or g.app.config.defaultFontFamily
                    size   = size or c.config.defaultBodyFontSize
                    slant  = slant or 'roman'
                    weight = weight or 'normal'
                    font = g.app.gui.getFontFromParams(family,size,slant,weight)
                    # Save a reference to the font so it 'sticks'.
                    self.fonts[key] = font
                    if trace and traceFonts:
                        g.trace('**found',key,name,family,size,slant,weight,id(font))
                    w.tag_config(key,font=font)
                    break

        else: # Neither the general setting nor the language-specific setting exists.
            if list(self.fonts.keys()): # Restore the default font.
                if trace and traceFonts:
                    g.trace('default',key,font)
                self.fonts[key] = font # 2010/02/19: Essential
                w.tag_config(key,font=defaultBodyfont)
            else:
                if trace and traceFonts:
                    g.trace('no fonts')
                    
        if isQt and key == 'url' and font:
            font.setUnderline(True) # 2011/03/04

    keys = list(self.default_colors_dict.keys()) ; keys.sort()
    for name in keys:
        option_name,default_color = self.default_colors_dict[name]
        color = (
            c.config.getColor('%s_%s' % (self.colorizer.language,option_name)) or
            c.config.getColor(option_name) or
            default_color
        )
        if trace and traceColor: g.trace(option_name,color)

        # Must use foreground, not fg.
        try:
            w.tag_configure(name, foreground=color)
        except: # Recover after a user error.
            g.es_exception()
            w.tag_configure(name, foreground=default_color)

    # underline=var doesn't seem to work.
    if 0: # self.use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
        w.tag_configure("link",underline=1) # defined
        w.tag_configure("name",underline=0) # undefined
    else:
        w.tag_configure("link",underline=0)
        if self.underline_undefined:
            w.tag_configure("name",underline=1)
        else:
            w.tag_configure("name",underline=0)

    self.configure_variable_tags()

    # Colors for latex characters.  Should be user options...

    if 1: # Alas, the selection doesn't show if a background color is specified.
        w.tag_configure("latexModeBackground",foreground="black")
        w.tag_configure("latexModeKeyword",foreground="blue")
        w.tag_configure("latexBackground",foreground="black")
        w.tag_configure("latexKeyword",foreground="blue")
    else: # Looks cool, and good for debugging.
        w.tag_configure("latexModeBackground",foreground="black",background="seashell1")
        w.tag_configure("latexModeKeyword",foreground="blue",background="seashell1")
        w.tag_configure("latexBackground",foreground="black",background="white")
        w.tag_configure("latexKeyword",foreground="blue",background="white")

    # Tags for wiki coloring.
    w.tag_configure("bold",font=self.bold_font)
    w.tag_configure("italic",font=self.italic_font)
    w.tag_configure("bolditalic",font=self.bolditalic_font)
    for name in self.color_tags_list:
        w.tag_configure(name,foreground=name)

    try:
        w.end_tag_configure()
    except AttributeError:
        pass
#@+node:ekr.20110304061301.14044: *4* openURL()
@g.command('open-url')
def openURL(event):
    c = event.get('c')
    w = c.frame.body.bodyCtrl
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    if i != j: return # So find doesn't open the url.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    i,j = g.getLine(s,ins)
    line = s[i:j]
    url_regex = re.compile(r"""(file|ftp|http|https)://[^\s'"]+[\w=/]""")
    for match in url_regex.finditer(line):
        if match.start() <= col < match.end(): # Don't open if we click after the url.
            url = match.group()
            if not g.app.unitTesting:
                try:
                    import webbrowser
                    webbrowser.open(url)
                except:
                    g.es("exception opening " + url)
                    g.es_exception()
            return url
#@+node:ekr.20110304100725.14066: *4* onMouseUp
def onMouseUp(self,event=None):

    # Open the url on a control-click.
    if QtCore.Qt.ControlModifier & event.modifiers():
        event = {'c':self.leo_c}
        openURL(event)
#@+node:ekr.20110307195735.14242: *3* Can clicking select the current position?
#@+node:ekr.20090124174652.120: *4* qtTree.initAfterLoad
def initAfterLoad (self):

    '''Do late-state inits.'''

    # Called by Leo's core.

    c = self.c ; frame = c.frame
    w = c.frame.top ; tw = self.treeWidget

    if not leoQtTree.callbacksInjected:
        leoQtTree.callbacksInjected = True
        self.injectCallbacks() # A base class method.

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemDoubleClicked(QTreeWidgetItem*, int)"),
        self.onItemDoubleClicked)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemClicked(QTreeWidgetItem*, int)"),
        self.onItemClicked)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemSelectionChanged()"),
        self.onTreeSelect)

    # We don't need this.  Hooray!
    # w.connect(self.treeWidget,QtCore.SIGNAL(
            # "itemChanged(QTreeWidgetItem*, int)"),
        # self.onItemChanged)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemCollapsed(QTreeWidgetItem*)"),
        self.onItemCollapsed)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemExpanded(QTreeWidgetItem*)"),
        self.onItemExpanded)

    w.connect(self.treeWidget, QtCore.SIGNAL(
            "customContextMenuRequested(QPoint)"),
        self.onContextMenu)    

    self.ev_filter = leoQtEventFilter(c,w=self,tag='tree')
    tw.installEventFilter(self.ev_filter)

    # 2010/01/24: Do not set this here.
    # The read logic sets c.changed to indicate nodes have changed.
    # c.setChanged(False)
#@+node:ekr.20090812211903.3641: *4* onItemClicked (nativeTree) (New in Leo 4.7)
def onItemClicked (self,item,col):

    trace = False and not g.unitTesting
    verbose = False

    if self.busy(): return

    c = self.c

    if trace: g.trace(col,self.traceItem(item),g.callers(4))

    try:
        self.selecting = True

        p = self.item2position(item)
        if p:
            event = None
            g.doHook("iconclick1",c=c,p=p,v=p,event=event)
            # if c.positionExists(p): c.selectPosition(p) # 2011/03/07
#@verbatim
            #@ c.frame.tree.OnIconDoubleClick(p) # Call the base class method.
            g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        else:
            g.trace('*** no p')

        c.outerUpdate()
    finally:
        self.selecting = False
#@+node:ekr.20090124174652.43: *4* onTreeSelect (nativeTree)
def onTreeSelect(self):

    '''Select the proper position when a tree node is selected.'''

    trace = False and not g.unitTesting
    verbose = False

    if self.busy(): return

    c = self.c

    item = self.getCurrentItem()
    p = self.item2position(item)

    if p:
        # Important: do not set lockouts here.
        # Only methods that actually generate events should set lockouts.
        if trace: g.trace(self.traceItem(item))
        self.select(p) # Calls before/afterSelectHint.
    else:
        self.error('no p for item: %s' % item)

    c.outerUpdate()
#@+node:ekr.20110315083610.14366: *3* Create renderer panes in the body
#@+node:ekr.20081121105001.212: *4* Editors (qtBody)
#@+node:ekr.20081121105001.215: *5* entries
#@+node:ekr.20081121105001.216: *6* addEditor & helper (qtBody)
# An override of leoFrame.addEditor.

def addEditor (self,event=None):

    '''Add another editor to the body pane.'''

    trace = False and not g.unitTesting
    bodyCtrl = self.c.frame.body.bodyCtrl # A leoQTextEditWidget
    self.editorWidgets['1'] = bodyCtrl
    c = self.c ; p = c.p
    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1

    if self.totalNumberOfEditors == 2:
        # Pack the original body editor.
        w = bodyCtrl.widget
        self.packLabel(w,n=1)

    name = '%d' % self.totalNumberOfEditors
    f,wrapper = self.createEditor(name)
    w = wrapper.widget
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w
    assert isinstance(f,QtGui.QFrame),f
    self.editorWidgets[name] = wrapper

    if trace: g.trace('name %s wrapper %s w %s' % (
        name,id(wrapper),id(w)))

    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        # The name of the last editor need not be '1'
        d = self.editorWidgets ; keys = list(d.keys())
        old_name = keys[0]
        old_wrapper = d.get(old_name)
        old_w = old_wrapper.widget
        self.injectIvars(f,old_name,p,old_wrapper)
        self.updateInjectedIvars (old_w,p)
        self.selectLabel(old_wrapper) # Immediately create the label in the old editor.

    # Switch editors.
    c.frame.body.bodyCtrl = wrapper
    self.selectLabel(wrapper)
    self.selectEditor(wrapper)
    self.updateEditors()
    c.bodyWantsFocus()
#@+node:ekr.20081121105001.213: *7* createEditor
def createEditor (self,name):

    c = self.c ; p = c.p
    f = c.frame.top.ui.leo_body_inner_frame
        # Valid regardless of qtGui.useUI
    n = self.numberOfEditors

    # Step 1: create the editor.
    # w = QtGui.QTextBrowser(f)
    w = LeoQTextBrowser(f,c,self)
    w.setObjectName('richTextEdit') # Will be changed later.
    wrapper = leoQTextEditWidget(w,name='body',c=c)
    self.packLabel(w)

    # Step 2: inject ivars, set bindings, etc.
    self.injectIvars(f,name,p,wrapper)
    self.updateInjectedIvars(w,p)
    wrapper.setAllText(p.b)
    wrapper.see(0)
    self.createBindings(w=wrapper)
    c.k.completeAllBindingsForWidget(wrapper)
    self.recolorWidget(p,wrapper)

    return f,wrapper
#@+node:ekr.20081121105001.218: *6* assignPositionToEditor
def assignPositionToEditor (self,p):

    '''Called *only* from tree.select to select the present body editor.'''

    c = self.c ; cc = c.chapterController
    wrapper = c.frame.body.bodyCtrl
    w = wrapper.widget

    self.updateInjectedIvars(w,p)
    self.selectLabel(wrapper)

    # g.trace('===',id(w),w.leo_chapter,w.leo_p.h)
#@+node:ekr.20081121105001.219: *6* cycleEditorFocus
def cycleEditorFocus (self,event=None):

    '''Cycle keyboard focus between the body text editors.'''

    c = self.c ; d = self.editorWidgets
    w = c.frame.body.bodyCtrl
    values = list(d.values())
    if len(values) > 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = d.values()[i]
        assert(w!=w2)
        self.selectEditor(w2)
        c.frame.body.bodyCtrl = w2
        # g.trace('***',g.app.gui.widget_name(w2),id(w2))
#@+node:ekr.20081121105001.220: *6* deleteEditor
def deleteEditor (self,event=None):

    '''Delete the presently selected body text editor.'''

    trace = False and not g.unitTesting
    c = self.c ; d = self.editorWidgets
    wrapper = c.frame.body.bodyCtrl
    w = wrapper.widget
    name = w.leo_name
    assert name
    assert wrapper == d.get(name),'wrong wrapper'
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w

    if len(list(d.keys())) <= 1: return

    # At present, can not delete the first column.
    if name == '1':
        g.es('can not delete leftmost editor',color='blue')
        return

    # Actually delete the widget.
    if trace: g.trace('**delete name %s id(wrapper) %s id(w) %s' % (
        name,id(wrapper),id(w)))

    del d [name]
    f = c.frame.top.ui.leo_body_inner_frame
    layout = f.layout()
    for z in (w,w.leo_label):
        self.unpackWidget(layout,z)

    # Select another editor.
    new_wrapper = list(d.values())[0]
    if trace: g.trace(wrapper,new_wrapper)
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        self.unpackWidget(layout,w.leo_label)

    self.selectEditor(new_wrapper)
#@+node:ekr.20081121105001.221: *6* findEditorForChapter (leoBody)
def findEditorForChapter (self,chapter,p):

    '''Return an editor to be assigned to chapter.'''

    trace = False and not g.unitTesting
    c = self.c ; d = self.editorWidgets
    values = list(d.values())

    # First, try to match both the chapter and position.
    if p:
        for w in values:
            if (
                hasattr(w,'leo_chapter') and w.leo_chapter == chapter and
                hasattr(w,'leo_p') and w.leo_p and w.leo_p == p
            ):
                if trace: g.trace('***',id(w),'match chapter and p',p.h)
                return w

    # Next, try to match just the chapter.
    for w in values:
        if hasattr(w,'leo_chapter') and w.leo_chapter == chapter:
            if trace: g.trace('***',id(w),'match only chapter',p.h)
            return w

    # As a last resort, return the present editor widget.
    if trace: g.trace('***',id(self.bodyCtrl),'no match',p.h)
    return c.frame.body.bodyCtrl
#@+node:ekr.20081121105001.222: *6* select/unselectLabel (leoBody)
def unselectLabel (self,wrapper):

    pass
    # self.createChapterIvar(wrapper)

def selectLabel (self,wrapper):

    c = self.c
    w = wrapper.widget
    lab = hasattr(w,'leo_label') and w.leo_label

    if lab:
        lab.setEnabled(True)
        lab.setText(c.p.h)
        lab.setEnabled(False)
#@+node:ekr.20081121105001.223: *6* selectEditor & helpers
selectEditorLockout = False

def selectEditor(self,wrapper):

    '''Select editor w and node w.leo_p.'''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; bodyCtrl = c.frame.body.bodyCtrl

    if not wrapper: return bodyCtrl
    if self.selectEditorLockout:
        if trace: g.trace('**busy')
        return

    w = wrapper.widget
    # g.trace('widget',w)
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w

    def report(s):
        g.trace('*** %9s wrapper %s w %s %s' % (
            s,id(wrapper),id(w),c.p.h))

    if wrapper and wrapper == bodyCtrl:
        self.deactivateEditors(wrapper)
        if hasattr(w,'leo_p') and w.leo_p and w.leo_p != c.p:
            if trace: report('select')
            c.selectPosition(w.leo_p)
            c.bodyWantsFocus()
        elif trace and verbose: report('no change')
        return

    try:
        val = None
        self.selectEditorLockout = True
        val = self.selectEditorHelper(wrapper)
    finally:
        self.selectEditorLockout = False

    return val # Don't put a return in a finally clause.
#@+node:ekr.20081121105001.224: *7* selectEditorHelper
def selectEditorHelper (self,wrapper):

    trace = False and not g.unitTesting
    c = self.c ; cc = c.chapterController
    d = self.editorWidgets
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    w = wrapper.widget
    assert isinstance(w,QtGui.QTextEdit),w

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    # The actual switch.
    self.deactivateEditors(wrapper)
    self.recolorWidget (w.leo_p,wrapper) # switches colorizers.
    # g.trace('c.frame.body',c.frame.body)
    # g.trace('c.frame.body.bodyCtrl',c.frame.body.bodyCtrl)
    # g.trace('wrapper',wrapper)
    c.frame.body.bodyCtrl = wrapper
    c.frame.body.widget = wrapper # Major bug fix: 2011/04/06
    w.leo_active = True

    self.switchToChapter(wrapper)
    self.selectLabel(wrapper)

    if not self.ensurePositionExists(w):
        return g.trace('***** no position editor!')
    if not (hasattr(w,'leo_p') and w.leo_p):
        return g.trace('***** no w.leo_p',w)
        
    # if not (hasattr(w,'leo_chapter') and w.leo_chapter):
        # return g.trace('***** no w.leo_chapter',w)

    p = w.leo_p
    assert p,p

    if trace: g.trace('wrapper %s chapter %s old %s p %s' % (
        id(wrapper),w.leo_chapter,c.p.h,p.h))

    c.expandAllAncestors(p)
    c.selectPosition(p) # Calls assignPositionToEditor.
    c.redraw()
    c.recolor_now()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocus()
#@+node:ekr.20081121105001.225: *8* << restore the selection, insertion point and the scrollbar >>
# g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if hasattr(w,'leo_insertSpot') and w.leo_insertSpot:
    wrapper.setInsertPoint(w.leo_insertSpot)
else:
    wrapper.setInsertPoint(0)

if hasattr(w,'leo_scrollBarSpot') and w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    wrapper.see(first)
else:
    wrapper.seeInsertPoint()

if hasattr(w,'leo_selection') and w.leo_selection:
    try:
        start,end = w.leo_selection
        wrapper.setSelectionRange(start,end)
    except Exception:
        pass
#@+node:ekr.20081121105001.226: *6* updateEditors
# Called from addEditor and assignPositionToEditor

def updateEditors (self):

    c = self.c ; p = c.p ; body = p.b
    d = self.editorWidgets
    if len(list(d.keys())) < 2: return # There is only the main widget

    w0 = c.frame.body.bodyCtrl
    i,j = w0.getSelectionRange()
    ins = w0.getInsertPoint()
    sb0 = w0.widget.verticalScrollBar()
    pos0 = sb0.sliderPosition()
    for key in d:
        wrapper = d.get(key)
        w = wrapper.widget
        v = hasattr(w,'leo_p') and w.leo_p.v
        if v and v == p.v and w != w0:
            sb = w.verticalScrollBar()
            pos = sb.sliderPosition()
            wrapper.setAllText(body)
            self.recolorWidget(p,wrapper)
            sb.setSliderPosition(pos)

    c.bodyWantsFocus()
    w0.setSelectionRange(i,j,ins=ins)
    sb0.setSliderPosition(pos0)
#@+node:ekr.20081121105001.227: *5* utils
#@+node:ekr.20081121105001.228: *6* computeLabel
def computeLabel (self,w):

    if hasattr(w,'leo_label'):
        s = w.leo_label.text()
    else:
        s = ''

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        s = '%s: %s' % (w.leo_chapter,s)

    return s
#@+node:ekr.20081121105001.229: *6* createChapterIvar
def createChapterIvar (self,w):

    c = self.c ; cc = c.chapterController

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        pass
    elif cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None
#@+node:ekr.20081121105001.231: *6* deactivateEditors
def deactivateEditors(self,wrapper):

    '''Deactivate all editors except wrapper's editor.'''

    trace = False and not g.unitTesting
    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        wrapper2 = d.get(key)
        w2 = wrapper2.widget
        if hasattr(w2,'leo_active'):
            active = w2.leo_active
        else:
            active = True
        if wrapper2 != wrapper and active:
            w2.leo_active = False
            self.unselectLabel(wrapper2)
            w2.leo_scrollBarSpot = wrapper2.getYScrollPosition()
            w2.leo_insertSpot = wrapper2.getInsertPoint()
            w2.leo_selection = wrapper2.getSelectionRange()
            if trace: g.trace('**deactivate wrapper %s w %s' % (
                id(wrapper2),id(w2)))
            self.onFocusOut(w2)
#@+node:ekr.20081121105001.230: *6* ensurePositionExists
def ensurePositionExists(self,w):

    '''Return True if w.leo_p exists or can be reconstituted.'''

    trace = False and not g.unitTesting
    c = self.c

    if c.positionExists(w.leo_p):
        return True
    else:
        if trace: g.trace('***** does not exist',w.leo_name)
        for p2 in c.all_unique_positions():
            if p2.v and p2.v == w.leo_p.v:
                if trace: g.trace(p2.h)
                w.leo_p = p2.copy()
                return True
        else:
            # This *can* happen when selecting a deleted node.
            w.leo_p = c.p.copy()
            return False
#@+node:ekr.20090318091009.14: *6* injectIvars
def injectIvars (self,parentFrame,name,p,wrapper):

    trace = False and not g.unitTesting

    w = wrapper.widget
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w

    if trace: g.trace(w)

    # Inject ivars
    if name == '1':
        w.leo_p = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()

    w.leo_active = True
    w.leo_bodyBar = None
    w.leo_bodyXBar = None
    w.leo_chapter = None
    # w.leo_colorizer = None # Set in leoQtColorizer ctor.
    w.leo_frame = parentFrame
    w.leo_insertSpot = None
    # w.leo_label = None # Injected by packLabel.
    w.leo_name = name
    # w.leo_on_focus_in = onFocusInCallback
    w.leo_scrollBarSpot = None
    w.leo_selection = None
    w.leo_wrapper = wrapper
#@+node:ekr.20090613111747.3633: *6* packLabel
def packLabel (self,w,n=None):

    c = self.c
    f = c.frame.top.ui.leo_body_inner_frame
        # Valid regardless of qtGui.useUI

    if n is None:n = self.numberOfEditors
    layout = f.layout()
    f.setObjectName('editorFrame')

    # Create the text: to do: use stylesheet to set font, height.
    lab = QtGui.QLineEdit(f)
    lab.setObjectName('editorLabel')
    lab.setText(c.p.h)

    # Pack the label and the text widget.
    # layout.setHorizontalSpacing(4)
    layout.addWidget(lab,0,max(0,n-1),QtCore.Qt.AlignVCenter)
    layout.addWidget(w,1,max(0,n-1))
    layout.setRowStretch(0,0)
    layout.setRowStretch(1,1) # Give row 1 as much as possible.

    w.leo_label = lab # Inject the ivar.
#@+node:ekr.20081121105001.232: *6* recolorWidget
def recolorWidget (self,p,wrapper):

    trace = False and not g.unitTesting
    c = self.c

    # Save.
    old_wrapper = c.frame.body.bodyCtrl
    c.frame.body.bodyCtrl = wrapper
    w = wrapper.widget

    if not hasattr(w,'leo_colorizer'):
        if trace: g.trace('*** creating colorizer for',w)
        leoQtColorizer(c,w) # injects w.leo_colorizer
        assert hasattr(w,'leo_colorizer'),w

    c.frame.body.colorizer = w.leo_colorizer
    if trace: g.trace(w,c.frame.body.colorizer)

    try:
        # c.recolor_now(interruptable=False) # Force a complete recoloring.
        c.frame.body.colorizer.colorize(p,incremental=False,interruptable=False)
    finally:
        # Restore.
        c.frame.body.bodyCtrl = old_wrapper
#@+node:ekr.20081121105001.233: *6* switchToChapter (leoBody)
def switchToChapter (self,w):

    '''select w.leo_chapter.'''

    trace = True and not g.unitTesting
    c = self.c ; cc = c.chapterController

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        chapter = w.leo_chapter
        name = chapter and chapter.name
        oldChapter = cc.getSelectedChapter()
        if chapter != oldChapter:
            if trace: g.trace('***old',oldChapter.name,'new',name,w.leo_p)
            cc.selectChapterByName(name)
            c.bodyWantsFocus()
#@+node:ekr.20081121105001.234: *6* updateInjectedIvars
def updateInjectedIvars (self,w,p):

    trace = False and not g.unitTesting
    if trace: g.trace('w %s len(p.b) %s %s' % (
        id(w),len(p.b),p.h),g.callers(5))

    c = self.c ; cc = c.chapterController
    assert isinstance(w,QtGui.QTextEdit),w

    if cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None

    w.leo_p = p.copy()
#@+node:ekr.20090614060655.3660: *6* unpackWidget
def unpackWidget (self,layout,w):

    index = layout.indexOf(w)
    item = layout.itemAt(index)
    item.setGeometry(QtCore.QRect(0,0,0,0))
    layout.removeItem(item)
#@+node:ekr.20081121105001.207: *4*  ctor (qtBody)
def __init__ (self,frame,parentFrame):

    trace = False and not g.unitTesting

    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)

    c = self.c
    assert c.frame == frame and frame.c == c

    self.useScintilla = c.config.getBool('qt-use-scintilla')
    
    self.unselectedBackgroundColor = c.config.getColor(
        # 'unselected-background-color')
        'unselected_body_bg_color')
        
    # 2011/03/14
    self.unselectedForegroundColor = c.config.getColor(
        'unselected_body_fg_color')

    # Set the actual gui widget.
    if self.useScintilla:
        self.widget = w = leoQScintillaWidget(
            c.frame.top.textEdit,
            name='body',c=c)
        self.bodyCtrl = w # The widget as seen from Leo's core.
        self.colorizer = leoColor.nullColorizer(c)
    else:
        top = c.frame.top
        sw = top.ui.stackedWidget
        qtWidget = top.ui.richTextEdit # A LeoQTextBrowser
        # g.trace('(qtBody)',qtWidget)
        sw.setCurrentIndex(1)
        self.widget = w = leoQTextEditWidget(
            qtWidget,name = 'body',c=c)
            # Sets w.widget = qtWidget.
        self.bodyCtrl = w # The widget as seen from Leo's core.

        # Hook up the QSyntaxHighlighter
        self.colorizer = leoQtColorizer(c,w.widget)
        qtWidget.setAcceptRichText(False)
        
    # g.trace('(leoQtBody)',self,'self.widget',self.widget)

    # Config stuff.
    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    self.setWrap(c.p)

    # For multiple body editors.
    self.editor_name = None
    self.editor_v = None
    self.numberOfEditors = 1
    self.totalNumberOfEditors = 1
    
    # For renderer panes.
    self.canvasRenderer = None
    self.canvasRendererLabel = None
    self.canvasRendererVisible = False
    self.textRenderer = None
    self.textRendererLabel = None
    self.textRendererVisible = False
    self.textRendererWrapper = None

    if trace: print('qtBody.__init__ %s' % self.widget)
#@+node:ekr.20100101172327.3661: *5* setWrap (qtBody)
def setWrap (self,p):

    if not p: return
    if self.useScintilla: return

    c = self.c
    w = c.frame.body.widget.widget
    if 1:
        # Quicker, more self-contained.
        wrap = g.scanAllAtWrapDirectives(c,p)
    else:
        d = c.scanAllDirectives(p)
        if d is None: return
        wrap = d.get('wrap')
    w.setWordWrapMode(
        g.choose(wrap,
            QtGui.QTextOption.WordWrap,
            QtGui.QTextOption.NoWrap))
#@+node:ekr.20081121105001.208: *5* createBindings (qtBody)
def createBindings (self,w=None):

    '''(qtBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''

    # frame = self.frame ; c = self.c ; k = c.k
    # if not w: w = self.widget

    # c.bind(w,'<Key>', k.masterKeyHandler)

    # table = [
        # ('<Button-1>',  frame.OnBodyClick,          k.masterClickHandler),
        # ('<Button-3>',  frame.OnBodyRClick,         k.masterClick3Handler),
        # ('<Double-1>',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        # ('<Double-3>',  None,                       k.masterDoubleClick3Handler),
        # ('<Button-2>',  frame.OnPaste,              k.masterClickHandler),
    # ]

    # table2 = (
        # ('<Button-2>',  frame.OnPaste,              k.masterClickHandler),
    # )

    # if c.config.getBool('allow_middle_button_paste'):
        # table.extend(table2)

    # for kind,func,handler in table:
        # def bodyClickCallback(event,handler=handler,func=func):
            # return handler(event,func)

        # c.bind(w,kind,bodyClickCallback)
#@+node:ekr.20081121105001.209: *5* get_name
def getName (self):

    return 'body-widget'
#@+node:ekr.20110315083610.14341: *4* Renderer panes (qtBody)
#@+node:ekr.20110315083610.14347: *5* hideCanvasRenderer
def hideCanvasRenderer (self,event=None):

    '''Hide canvas pane.'''

    trace = False and not g.unitTesting
    c = self.c ; d = self.editorWidgets
    wrapper = c.frame.body.bodyCtrl
    w = wrapper.widget
    name = w.leo_name
    assert name
    assert wrapper == d.get(name),'wrong wrapper'
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w

    if len(list(d.keys())) <= 1: return

    # At present, can not delete the first column.
    if name == '1':
        g.es('can not delete leftmost editor',color='blue')
        return

    # Actually delete the widget.
    if trace: g.trace('**delete name %s id(wrapper) %s id(w) %s' % (
        name,id(wrapper),id(w)))

    del d [name]
    f = c.frame.top.ui.leo_body_inner_frame
    layout = f.layout()
    for z in (w,w.leo_label):
        self.unpackWidget(layout,z)

    # Select another editor.
    new_wrapper = list(d.values())[0]
    if trace: g.trace(wrapper,new_wrapper)
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        self.unpackWidget(layout,w.leo_label)

    self.selectEditor(new_wrapper)
#@+node:ekr.20110315083610.14369: *5* hideTextRenderer
def hideCanvas (self,event=None):

    '''Hide canvas pane.'''

    trace = False and not g.unitTesting
    c = self.c ; d = self.editorWidgets
    wrapper = c.frame.body.bodyCtrl
    w = wrapper.widget
    name = w.leo_name
    assert name
    assert wrapper == d.get(name),'wrong wrapper'
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w

    if len(list(d.keys())) <= 1: return

    # At present, can not delete the first column.
    if name == '1':
        g.es('can not delete leftmost editor',color='blue')
        return

    # Actually delete the widget.
    if trace: g.trace('**delete name %s id(wrapper) %s id(w) %s' % (
        name,id(wrapper),id(w)))

    del d [name]
    f = c.frame.top.ui.leo_body_inner_frame
    layout = f.layout()
    for z in (w,w.leo_label):
        self.unpackWidget(layout,z)

    # Select another editor.
    new_wrapper = list(d.values())[0]
    if trace: g.trace(wrapper,new_wrapper)
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        self.unpackWidget(layout,w.leo_label)

    self.selectEditor(new_wrapper)
#@+node:ekr.20110315083610.14360: *5* packRenderer
def packRenderer (self,f,name,w):

    c = self.c ; n = max(1,self.numberOfEditors)
    assert isinstance(f,QtGui.QFrame),f

    layout = f.layout()
    f.setObjectName('%s Frame' % name)

    # Create the text: to do: use stylesheet to set font, height.
    lab = QtGui.QLineEdit(f)
    lab.setObjectName('%s Label' % name)
    lab.setText(name)

    # Pack the label and the widget.
    layout.addWidget(lab,0,max(0,n-1),QtCore.Qt.AlignVCenter)
    layout.addWidget(w,1,max(0,n-1))
    layout.setRowStretch(0,0)
    layout.setRowStretch(1,1) # Give row 1 as much as possible.
    
    return lab

#@+node:ekr.20110315083610.14343: *5* showCanvasRenderer
# An override of leoFrame.addEditor.

def showCanvasRenderer (self,event=None):

    '''Show the canvas area in the body pane, creating it if necessary.'''

    trace = False and not g.unitTesting
    
    bodyCtrl = self.c.frame.body.bodyCtrl # A leoQTextEditWidget

    c = self.c
    f = c.frame.top.ui.leo_body_inner_frame
    assert isinstance(f,QtGui.QFrame),f

    if not self.canvasRenderer:
        name = 'Graphics Renderer'
        self.canvasRenderer = w = QtGui.QGraphicsView(f)
        w.setObjectName(name)
    
    if not self.canvasRendererVisible:
        self.canvasRendererLabel = self.packRenderer(f,name,w)
        self.canvasRendererVisible = True
    
    # self.editorWidgets[name] = wrapper

    # if self.numberOfEditors == 2:
        # # Inject the ivars into the first editor.
        # # The name of the last editor need not be '1'
        # d = self.editorWidgets ; keys = list(d.keys())
        # old_name = keys[0]
        # old_wrapper = d.get(old_name)
        # old_w = old_wrapper.widget
        # self.injectIvars(f,old_name,p,old_wrapper)
        # self.updateInjectedIvars (old_w,p)
        # self.selectLabel(old_wrapper) # Immediately create the label in the old editor.

    # # Switch editors.
    # c.frame.body.bodyCtrl = wrapper
    # self.selectLabel(wrapper)
    # self.selectEditor(wrapper)
    # self.updateEditors()
    # c.bodyWantsFocus()
#@+node:ekr.20110315083610.14372: *5* showTextRenderer
# An override of leoFrame.addEditor.

def showTextRenderer (self,event=None):

    '''Show the canvas area in the body pane, creating it if necessary.'''

    c = self.c
    f = c.frame.top.ui.leo_body_inner_frame
    assert isinstance(f,QtGui.QFrame),f

    if not self.textRenderer:
        name = 'Text Renderer'
        self.textRenderer = w = LeoQTextBrowser(f,c,self)
        w.setObjectName(name)
        self.textRendererWrapper = leoQTextEditWidget(
            w,name='text-renderer',c=c)
            
    if not self.textRendererVisible:
        self.textRendererLabel = self.packRenderer(f,name,w)
        self.textRendererVisible = True
        
    # bodyCtrl = self.c.frame.body.bodyCtrl # A leoQTextEditWidget
    # p = c.p

    # if self.numberOfEditors == 2:
        # # Inject the ivars into the first editor.
        # # The name of the last editor need not be '1'
        # d = self.editorWidgets ; keys = list(d.keys())
        # old_name = keys[0]
        # old_wrapper = d.get(old_name)
        # old_w = old_wrapper.widget
        # self.injectIvars(f,old_name,p,old_wrapper)
        # self.updateInjectedIvars (old_w,p)
        # self.selectLabel(old_wrapper) # Immediately create the label in the old editor.

    # # Switch editors.
    # c.frame.body.bodyCtrl = wrapper
    # self.selectLabel(wrapper)
    # self.selectEditor(wrapper)
    # self.updateEditors()
    # c.bodyWantsFocus()
#@+node:edward.20110330154504.3866: *3* Fixed MacOS Command-C bug
# k.masterMenuHandler is called instead of k.masterKeyHandler.
#@+node:edward.20110330105340.3843: *4* wrapQLineEdit (nativeTree)
def wrapQLineEdit (self,w):
    
    '''A wretched kludge for MacOs k.masterMenuHandler.'''
    c = self.c
    
    if isinstance(w,QtGui.QLineEdit):
        wrapper = self.edit_widget(c.p)
    else:
        wrapper = w
        
    # g.trace(wrapper)
    return wrapper
        
#@+node:ekr.20110406082808.18155: *3* Fixed focus problems
#@+node:ekr.20081121105001.317: *4* Qt bindings... (qtFrame)
def bringToFront (self):
    self.lift()
def deiconify (self):
    if self.top.isMinimized(): # Bug fix: 400739.
        self.lift()
def getFocus(self):
    return g.app.gui.get_focus(self.c) # Bug fix: 2009/6/30.
def get_window_info(self):
    if hasattr(self.top,'master') and self.top.master:
        f = self.top.master
    else:
        f = self.top
    rect = f.geometry()
    topLeft = rect.topLeft()
    x,y = topLeft.x(),topLeft.y()
    w,h = rect.width(),rect.height()
    # g.trace(w,h,x,y)
    return w,h,x,y
def iconify(self):
    self.top.showMinimized()
def lift (self):
    # g.trace(self.c,'\n',g.callers(9))
    if self.top.isMinimized(): # Bug 379141
        self.top.showNormal()
    self.top.activateWindow()
    self.top.raise_()
def update (self):
    pass
def getTitle (self):
    s = g.u(self.top.windowTitle())
    # g.trace('(qtFrame)',repr(s))
    return s
def setTitle (self,s):
    # g.trace('(qtFrame)',repr(s))
    self.top.setWindowTitle(s)
def setTopGeometry(self,w,h,x,y,adjustSize=True):
    # self.top is a DynamicWindow.
    # g.trace('(qtFrame)',x,y,w,h,self.top)
    self.top.setGeometry(QtCore.QRect(x,y,w,h))
#@+node:ekr.20090406071640.13: *4* Event handlers (qtBody)
def onFocusIn (self,obj):

    '''Handle a focus-in event in the body pane.'''

    trace = False and not g.unitTesting

    c = self.c
    if trace: g.trace(c.p.h) # obj,obj.objectName())

    # 2010/08/01: Update the history only on focus in events.
    # 2011/04/02: Update history only in leoframe.tree.select.
    # c.nodeHistory.update(c.p)

    if obj.objectName() == 'richTextEdit':
        wrapper = hasattr(obj,'leo_wrapper') and obj.leo_wrapper
        if wrapper and wrapper != self.bodyCtrl:
            self.selectEditor(wrapper)
        self.onFocusColorHelper('focus-in',obj)
        obj.setReadOnly(False)
        obj.setFocus() # Weird, but apparently necessary.

def onFocusOut (self,obj):

    '''Handle a focus-out event in the body pane.'''

    if obj.objectName() == 'richTextEdit':
        self.onFocusColorHelper('focus-out',obj)
        obj.setReadOnly(True)
#@+node:ekr.20090608052916.3810: *5* onFocusColorHelper (qtBody)
badFocusColors = []

def onFocusColorHelper(self,kind,obj):

    trace = False and not g.unitTesting
    
    c = self.c
    
    if kind == 'focus-in':
        # if trace: g.trace('%9s' % (kind),'calling c.k.showStateColors()')
        c.k.showStateColors(inOutline=False,w=self.widget)
    else:
        # 2011/03/14: Also set the foreground color.
        colorName = self.unselectedForegroundColor
        if trace: g.trace('%9s' % (kind),colorName)
        self.setForegroundColorHelper(colorName,obj)
        
        colorName = self.unselectedBackgroundColor
        if trace: g.trace('%9s' % (kind),colorName)
        self.setBackgroundColorHelper(colorName,obj)
#@+node:ekr.20110406082808.18156: *3* Fixed major problem with multiple body editors
@nocolor-node

The high-level interface uses c.frame.body.widget instead of c.frame.body.bodyCtrl,
so selectionEditorHelper must set *both* ivars.
#@+node:ekr.20081121105001.207: *4*  ctor (qtBody)
def __init__ (self,frame,parentFrame):

    trace = False and not g.unitTesting

    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)

    c = self.c
    assert c.frame == frame and frame.c == c

    self.useScintilla = c.config.getBool('qt-use-scintilla')
    
    self.unselectedBackgroundColor = c.config.getColor(
        # 'unselected-background-color')
        'unselected_body_bg_color')
        
    # 2011/03/14
    self.unselectedForegroundColor = c.config.getColor(
        'unselected_body_fg_color')

    # Set the actual gui widget.
    if self.useScintilla:
        self.widget = w = leoQScintillaWidget(
            c.frame.top.textEdit,
            name='body',c=c)
        self.bodyCtrl = w # The widget as seen from Leo's core.
        self.colorizer = leoColor.nullColorizer(c)
    else:
        top = c.frame.top
        sw = top.ui.stackedWidget
        qtWidget = top.ui.richTextEdit # A LeoQTextBrowser
        # g.trace('(qtBody)',qtWidget)
        sw.setCurrentIndex(1)
        self.widget = w = leoQTextEditWidget(
            qtWidget,name = 'body',c=c)
            # Sets w.widget = qtWidget.
        self.bodyCtrl = w # The widget as seen from Leo's core.

        # Hook up the QSyntaxHighlighter
        self.colorizer = leoQtColorizer(c,w.widget)
        qtWidget.setAcceptRichText(False)
        
    # g.trace('(leoQtBody)',self,'self.widget',self.widget)

    # Config stuff.
    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    self.setWrap(c.p)

    # For multiple body editors.
    self.editor_name = None
    self.editor_v = None
    self.numberOfEditors = 1
    self.totalNumberOfEditors = 1
    
    # For renderer panes.
    self.canvasRenderer = None
    self.canvasRendererLabel = None
    self.canvasRendererVisible = False
    self.textRenderer = None
    self.textRendererLabel = None
    self.textRendererVisible = False
    self.textRendererWrapper = None

    if trace: print('qtBody.__init__ %s' % self.widget)
#@+node:ekr.20100101172327.3661: *5* setWrap (qtBody)
def setWrap (self,p):

    if not p: return
    if self.useScintilla: return

    c = self.c
    w = c.frame.body.widget.widget
    if 1:
        # Quicker, more self-contained.
        wrap = g.scanAllAtWrapDirectives(c,p)
    else:
        d = c.scanAllDirectives(p)
        if d is None: return
        wrap = d.get('wrap')
    w.setWordWrapMode(
        g.choose(wrap,
            QtGui.QTextOption.WordWrap,
            QtGui.QTextOption.NoWrap))
#@+node:ekr.20081121105001.208: *5* createBindings (qtBody)
def createBindings (self,w=None):

    '''(qtBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''

    # frame = self.frame ; c = self.c ; k = c.k
    # if not w: w = self.widget

    # c.bind(w,'<Key>', k.masterKeyHandler)

    # table = [
        # ('<Button-1>',  frame.OnBodyClick,          k.masterClickHandler),
        # ('<Button-3>',  frame.OnBodyRClick,         k.masterClick3Handler),
        # ('<Double-1>',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        # ('<Double-3>',  None,                       k.masterDoubleClick3Handler),
        # ('<Button-2>',  frame.OnPaste,              k.masterClickHandler),
    # ]

    # table2 = (
        # ('<Button-2>',  frame.OnPaste,              k.masterClickHandler),
    # )

    # if c.config.getBool('allow_middle_button_paste'):
        # table.extend(table2)

    # for kind,func,handler in table:
        # def bodyClickCallback(event,handler=handler,func=func):
            # return handler(event,func)

        # c.bind(w,kind,bodyClickCallback)
#@+node:ekr.20081121105001.209: *5* get_name
def getName (self):

    return 'body-widget'
#@+node:ekr.20081121105001.211: *4* High-level interface (qtBody)
# Part 1: Corresponding to mustBeDefinedInSubclasses.
def appendText (self,s):            return self.widget.appendText(s)
def delete(self,i,j=None):          self.widget.delete(i,j)
def insert(self,i,s):               return self.widget.insert(i,s)
def get(self,i,j=None):             return self.widget.get(i,j)
def getAllText (self):              return self.widget.getAllText()
def getFocus (self):                return self.widget.getFocus()
def getInsertPoint(self):           return self.widget.getInsertPoint()
def getSelectedText (self):         return self.widget.getSelectedText()
def getSelectionRange(self):        return self.widget.getSelectionRange()
def getYScrollPosition (self):      return self.widget.getYScrollPosition()
def hasSelection (self):            return self.widget.hasSelection()
def scrollLines (self,n):           return self.widget.scrollLines(n)
def see(self,index):                return self.widget.see(index)
def seeInsertPoint(self):           return self.widget.seeInsertPoint()
def setAllText (self,s,new_p=None): return self.widget.setAllText(s,new_p=new_p)
def setBackgroundColor (self,color):return self.widget.setBackgroundColor(color)
def setFocus (self):                return self.widget.setFocus()
set_focus = setFocus
def setForegroundColor (self,color):return self.widget.setForegroundColor(color)
def setInsertPoint (self,pos):      return self.widget.setInsertPoint(pos)
def setSelectionRange(self,*args,**keys):
    self.widget.setSelectionRange(*args,**keys)
def setYScrollPosition (self,i):    return self.widget.setYScrollPosition(i)

# Part 2: corresponding to mustBeDefinedInBaseClass.
def clipboard_append(self,s):   return self.widget.clipboard_append(s)
def clipboard_clear(self):      return self.widget.clipboard_append()
def onChar (self, event):       return self.widget.onChar(event)

# Part 3: do-nothings in mayBeDefinedInSubclasses.
def bind (self,kind,*args,**keys):          return self.widget.bind(kind,*args,**keys)
def event_generate(self,stroke):            pass
def getWidth (self):                        return 0
def mark_set(self,markName,i):              pass
def setWidth (self,width):                  pass
def tag_add(self,tagName,i,j=None,*args):   pass
def tag_config (self,colorName,**keys):     pass
def tag_configure (self,colorName,**keys):  pass
def tag_delete (self,tagName,*args,**keys): pass
def tag_names (self, *args):                return []
def tag_ranges(self,tagName):               return tuple()
def tag_remove(self,tagName,i,j=None,*args):pass
def update (self,*args,**keys):             pass
def update_idletasks (self,*args,**keys):   pass
def xyToPythonIndex (self,x,y):             return 0
def yview (self,*args):                     return 0,0

# Part 4: corresponding to mayBeDefinedInSubclasses.

def deleteTextSelection (self): return self.widget.deleteTextSelection()

def indexIsVisible(self,i):  # Added: 2009/7/9.
    return self.widget.indexIsVisible(i)

def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75):
    return self.widget(i,bg,fg,flashes,delay)

def replace (self,i,j,s):               self.widget.replace (i,j,s)
def rowColToGuiIndex (self,s,row,col):  return self.widget.rowColToGuiIndex(s,row,col)
def selectAllText (self,insert=None):   self.widget.selectAllText(insert)
def toPythonIndex (self,index):         return self.widget.toPythonIndex(index)
toGuiIndex = toPythonIndex
def toPythonIndexRowCol(self,index):    return self.widget.toPythonIndexRowCol(index)
#@+node:ekr.20081121105001.223: *4* selectEditor & helpers
selectEditorLockout = False

def selectEditor(self,wrapper):

    '''Select editor w and node w.leo_p.'''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; bodyCtrl = c.frame.body.bodyCtrl

    if not wrapper: return bodyCtrl
    if self.selectEditorLockout:
        if trace: g.trace('**busy')
        return

    w = wrapper.widget
    # g.trace('widget',w)
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w

    def report(s):
        g.trace('*** %9s wrapper %s w %s %s' % (
            s,id(wrapper),id(w),c.p.h))

    if wrapper and wrapper == bodyCtrl:
        self.deactivateEditors(wrapper)
        if hasattr(w,'leo_p') and w.leo_p and w.leo_p != c.p:
            if trace: report('select')
            c.selectPosition(w.leo_p)
            c.bodyWantsFocus()
        elif trace and verbose: report('no change')
        return

    try:
        val = None
        self.selectEditorLockout = True
        val = self.selectEditorHelper(wrapper)
    finally:
        self.selectEditorLockout = False

    return val # Don't put a return in a finally clause.
#@+node:ekr.20081121105001.224: *5* selectEditorHelper
def selectEditorHelper (self,wrapper):

    trace = False and not g.unitTesting
    c = self.c ; cc = c.chapterController
    d = self.editorWidgets
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    w = wrapper.widget
    assert isinstance(w,QtGui.QTextEdit),w

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    # The actual switch.
    self.deactivateEditors(wrapper)
    self.recolorWidget (w.leo_p,wrapper) # switches colorizers.
    # g.trace('c.frame.body',c.frame.body)
    # g.trace('c.frame.body.bodyCtrl',c.frame.body.bodyCtrl)
    # g.trace('wrapper',wrapper)
    c.frame.body.bodyCtrl = wrapper
    c.frame.body.widget = wrapper # Major bug fix: 2011/04/06
    w.leo_active = True

    self.switchToChapter(wrapper)
    self.selectLabel(wrapper)

    if not self.ensurePositionExists(w):
        return g.trace('***** no position editor!')
    if not (hasattr(w,'leo_p') and w.leo_p):
        return g.trace('***** no w.leo_p',w)
        
    # if not (hasattr(w,'leo_chapter') and w.leo_chapter):
        # return g.trace('***** no w.leo_chapter',w)

    p = w.leo_p
    assert p,p

    if trace: g.trace('wrapper %s chapter %s old %s p %s' % (
        id(wrapper),w.leo_chapter,c.p.h,p.h))

    c.expandAllAncestors(p)
    c.selectPosition(p) # Calls assignPositionToEditor.
    c.redraw()
    c.recolor_now()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocus()
#@+node:ekr.20081121105001.225: *6* << restore the selection, insertion point and the scrollbar >>
# g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if hasattr(w,'leo_insertSpot') and w.leo_insertSpot:
    wrapper.setInsertPoint(w.leo_insertSpot)
else:
    wrapper.setInsertPoint(0)

if hasattr(w,'leo_scrollBarSpot') and w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    wrapper.see(first)
else:
    wrapper.seeInsertPoint()

if hasattr(w,'leo_selection') and w.leo_selection:
    try:
        start,end = w.leo_selection
        wrapper.setSelectionRange(start,end)
    except Exception:
        pass
#@+node:ekr.20110325185230.14517: ** Unused code
#@+node:vivainio.20091223153142.4072: *3* Completer (qtBody)
def showCompleter(self, alternatives, selected_cb):
    """ Show 'autocompleter' widget in body

    For example::

        w.showCompleter(['hello', 'helloworld'], mycallback )

    Here, 'hello' and 'helloworld' are the presented options.

    selected_cb should typically insert the selected text (it receives as arg) to 
    the body

    """
    wdg = self.widget.widget

    # wdg:QTextEdit

    cpl = self.completer = QtGui.QCompleter(alternatives)
    cpl.setWidget(wdg)
    f = selected_cb
    cpl.connect(cpl, QtCore.SIGNAL("activated(QString)"), f)    
    cpl.complete()
    return cpl
#@+node:ekr.20110315083610.14365: *3*  Not used (qtBody renderer panes)
if 0:
    
    @others
#@+node:ekr.20110315083610.14345: *4* assignPositionToEditor
def assignPositionToEditor (self,p):

    '''Called *only* from tree.select to select the present body editor.'''

    c = self.c ; cc = c.chapterController
    wrapper = c.frame.body.bodyCtrl
    w = wrapper.widget

    self.updateInjectedIvars(w,p)
    self.selectLabel(wrapper)

    # g.trace('===',id(w),w.leo_chapter,w.leo_p.h)
#@+node:ekr.20110315083610.14346: *4* cycleEditorFocus
def cycleEditorFocus (self,event=None):

    '''Cycle keyboard focus between the body text editors.'''

    c = self.c ; d = self.editorWidgets
    w = c.frame.body.bodyCtrl
    values = list(d.values())
    if len(values) > 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = d.values()[i]
        assert(w!=w2)
        self.selectEditor(w2)
        c.frame.body.bodyCtrl = w2
        # g.trace('***',g.app.gui.widget_name(w2),id(w2))
#@+node:ekr.20110315083610.14348: *4* findEditorForChapter (leoBody)
def findEditorForChapter (self,chapter,p):

    '''Return an editor to be assigned to chapter.'''

    trace = False and not g.unitTesting
    c = self.c ; d = self.editorWidgets
    values = list(d.values())

    # First, try to match both the chapter and position.
    if p:
        for w in values:
            if (
                hasattr(w,'leo_chapter') and w.leo_chapter == chapter and
                hasattr(w,'leo_p') and w.leo_p and w.leo_p == p
            ):
                if trace: g.trace('***',id(w),'match chapter and p',p.h)
                return w

    # Next, try to match just the chapter.
    for w in values:
        if hasattr(w,'leo_chapter') and w.leo_chapter == chapter:
            if trace: g.trace('***',id(w),'match only chapter',p.h)
            return w

    # As a last resort, return the present editor widget.
    if trace: g.trace('***',id(self.bodyCtrl),'no match',p.h)
    return c.frame.body.bodyCtrl
#@+node:ekr.20110315083610.14349: *4* select/unselectLabel (leoBody)
def unselectLabel (self,wrapper):

    pass
    # self.createChapterIvar(wrapper)

def selectLabel (self,wrapper):

    c = self.c
    w = wrapper.widget
    lab = hasattr(w,'leo_label') and w.leo_label

    if lab:
        lab.setEnabled(True)
        lab.setText(c.p.h)
        lab.setEnabled(False)
#@+node:ekr.20110315083610.14354: *4* utils
#@+node:ekr.20110315083610.14355: *5* computeLabel
def computeLabel (self,w):

    if hasattr(w,'leo_label'):
        s = w.leo_label.text()
    else:
        s = ''

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        s = '%s: %s' % (w.leo_chapter.name,s)

    return s
#@+node:ekr.20110315083610.14356: *5* createChapterIvar
def createChapterIvar (self,w):

    c = self.c ; cc = c.chapterController

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        pass
    elif cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None
#@+node:ekr.20110315083610.14357: *5* deactivateEditors
def deactivateEditors(self,wrapper):

    '''Deactivate all editors except wrapper's editor.'''

    trace = False and not g.unitTesting
    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        wrapper2 = d.get(key)
        w2 = wrapper2.widget
        if hasattr(w2,'leo_active'):
            active = w2.leo_active
        else:
            active = True
        if wrapper2 != wrapper and active:
            w2.leo_active = False
            self.unselectLabel(wrapper2)
            w2.leo_scrollBarSpot = wrapper2.getYScrollPosition()
            w2.leo_insertSpot = wrapper2.getInsertPoint()
            w2.leo_selection = wrapper2.getSelectionRange()
            if trace: g.trace('**deactivate wrapper %s w %s' % (
                id(wrapper2),id(w2)))
            self.onFocusOut(w2)
#@+node:ekr.20110315083610.14358: *5* ensurePositionExists
def ensurePositionExists(self,w):

    '''Return True if w.leo_p exists or can be reconstituted.'''

    trace = True and not g.unitTesting
    c = self.c

    if c.positionExists(w.leo_p):
        return True
    else:
        if trace: g.trace('***** does not exist',w.leo_name)
        for p2 in c.all_unique_positions():
            if p2.v and p2.v == w.leo_p.v:
                if trace: g.trace(p2.h)
                w.leo_p = p2.copy()
                return True
        else:
            # This *can* happen when selecting a deleted node.
            if trace: g.trace(p2.h)
            w.leo_p = c.p.copy()
            return False
#@+node:ekr.20110315083610.14359: *5* injectIvars
def injectIvars (self,parentFrame,name,p,wrapper):

    trace = False and not g.unitTesting

    w = wrapper.widget
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w

    if trace: g.trace(w)

    # Inject ivars
    if name == '1':
        w.leo_p = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()

    w.leo_active = True
    w.leo_bodyBar = None
    w.leo_bodyXBar = None
    w.leo_chapter = None
    # w.leo_colorizer = None # Set in leoQtColorizer ctor.
    w.leo_frame = parentFrame
    w.leo_insertSpot = None
    # w.leo_label = None # Injected by packLabel.
    w.leo_name = name
    # w.leo_on_focus_in = onFocusInCallback
    w.leo_scrollBarSpot = None
    w.leo_selection = None
    w.leo_wrapper = wrapper
#@+node:ekr.20110315083610.14361: *5* recolorWidget
def recolorWidget (self,p,wrapper):

    trace = False and not g.unitTesting
    c = self.c

    # Save.
    old_wrapper = c.frame.body.bodyCtrl
    c.frame.body.bodyCtrl = wrapper
    w = wrapper.widget

    if not hasattr(w,'leo_colorizer'):
        if trace: g.trace('*** creating colorizer for',w)
        leoQtColorizer(c,w) # injects w.leo_colorizer
        assert hasattr(w,'leo_colorizer'),w

    c.frame.body.colorizer = w.leo_colorizer
    if trace: g.trace(w,c.frame.body.colorizer)

    try:
        # c.recolor_now(interruptable=False) # Force a complete recoloring.
        c.frame.body.colorizer.colorize(p,incremental=False,interruptable=False)
    finally:
        # Restore.
        c.frame.body.bodyCtrl = old_wrapper
#@+node:ekr.20110315083610.14350: *5* selectRenderer & helper
### selectCanvasLockout = False

def selectRenderer(self,wrapper):

    '''Select editor w and node w.leo_p.'''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; bodyCtrl = c.frame.body.bodyCtrl

    if not wrapper: return bodyCtrl
    if self.selectEditorLockout:
        if trace: g.trace('**busy')
        return

    w = wrapper.widget
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w

    def report(s):
        g.trace('*** %9s wrapper %s w %s %s' % (
            s,id(wrapper),id(w),c.p.h))

    if wrapper and wrapper == bodyCtrl:
        self.deactivateEditors(wrapper)
        if hasattr(w,'leo_p') and w.leo_p and w.leo_p != c.p:
            if trace: report('select')
            c.selectPosition(w.leo_p)
            c.bodyWantsFocus()
        elif trace and verbose: report('no change')
        return

    try:
        val = None
        self.selectEditorLockout = True
        val = self.selectEditorHelper(wrapper)
    finally:
        self.selectEditorLockout = False

    return val # Don't put a return in a finally clause.
#@+node:ekr.20110315083610.14351: *6* selectRendererHelper
def selectRendererHelper (self,wrapper):

    trace = False and not g.unitTesting
    c = self.c ; cc = c.chapterController
    d = self.editorWidgets
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    w = wrapper.widget
    assert isinstance(w,QtGui.QTextEdit),w

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    # The actual switch.
    self.deactivateEditors(wrapper)
    self.recolorWidget (w.leo_p,wrapper) # switches colorizers.
    c.frame.body.bodyCtrl = wrapper
    w.leo_active = True

    self.switchToChapter(wrapper)
    self.selectLabel(wrapper)

    if not self.ensurePositionExists(w):
        return g.trace('***** no position editor!')
    if not (hasattr(w,'leo_p') and w.leo_p):
        return g.trace('***** no w.leo_p',w)

    # if not (hasattr(w,'leo_chapter') and w.leo_chapter):
        # return g.trace('***** no w.leo_chapter',w)

    p = w.leo_p
    assert p,p

    if trace: g.trace('wrapper %s chapter %s old %s p %s' % (
        id(wrapper),w.leo_chapter and w.leo_chapter.name,c.p.h,p.h))

    c.expandAllAncestors(p)
    c.selectPosition(p) # Calls assignPositionToEditor.
    c.redraw()
    c.recolor_now()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocus()
#@+node:ekr.20110315083610.14352: *7* << restore the selection, insertion point and the scrollbar >>
# g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if hasattr(w,'leo_insertSpot') and w.leo_insertSpot:
    wrapper.setInsertPoint(w.leo_insertSpot)
else:
    wrapper.setInsertPoint(0)

if hasattr(w,'leo_scrollBarSpot') and w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    wrapper.see(first)
else:
    wrapper.seeInsertPoint()

if hasattr(w,'leo_selection') and w.leo_selection:
    try:
        start,end = w.leo_selection
        wrapper.setSelectionRange(start,end)
    except Exception:
        pass
#@+node:ekr.20110315083610.14362: *5* switchToChapter (leoBody)
def switchToChapter (self,w):

    '''select w.leo_chapter.'''

    trace = True and not g.unitTesting
    c = self.c ; cc = c.chapterController

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        chapter = w.leo_chapter
        name = chapter and chapter.name
        oldChapter = cc.getSelectedChapter()
        if chapter != oldChapter:
            if trace: g.trace('***old',oldChapter.name,'new',name,w.leo_p)
            cc.selectChapterByName(name)
            c.bodyWantsFocus()
#@+node:ekr.20110315083610.14364: *5* unpackWidget
def unpackWidget (self,layout,w):

    index = layout.indexOf(w)
    item = layout.itemAt(index)
    item.setGeometry(QtCore.QRect(0,0,0,0))
    layout.removeItem(item)
#@+node:ekr.20110315083610.14353: *5* updateEditor
# Called from addEditor and assignPositionToEditor

def updateEditor (self):

    c = self.c ; p = c.p ; body = p.b
    d = self.editorWidgets
    if len(list(d.keys())) < 2: return # There is only the main widget

    w0 = c.frame.body.bodyCtrl
    i,j = w0.getSelectionRange()
    ins = w0.getInsertPoint()
    sb0 = w0.widget.verticalScrollBar()
    pos0 = sb0.sliderPosition()
    for key in d:
        wrapper = d.get(key)
        w = wrapper.widget
        v = hasattr(w,'leo_p') and w.leo_p.v
        if v and v == p.v and w != w0:
            sb = w.verticalScrollBar()
            pos = sb.sliderPosition()
            wrapper.setAllText(body)
            self.recolorWidget(p,wrapper)
            sb.setSliderPosition(pos)

    c.bodyWantsFocus()
    w0.setSelectionRange(i,j,ins=ins)
    sb0.setSliderPosition(pos0)
#@+node:ekr.20110315083610.14363: *5* updateInjectedIvars
def updateInjectedIvars (self,w,p):

    trace = False and not g.unitTesting
    if trace: g.trace('w %s len(p.b) %s %s' % (
        id(w),len(p.b),p.h),g.callers(5))

    c = self.c ; cc = c.chapterController
    assert isinstance(w,QtGui.QTextEdit),w

    if cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None

    w.leo_p = p.copy()
#@-all
#@-leo
