#@+leo-ver=4-thin
#@+node:ekr.20081121105001.147:@thin qtNotes.txt
#@+all
#@+node:ekr.20081121105001.148: qt To do
@nocolor-node

First:
- Support hoist in redraw code.
- Optimize tree updates.

Next:
- Can key strokes be handled in log pane?
- Disabling searches of body pane can cause hard crashes.
    - initInteractiveCommands expects c.edit_widget(p)to exist.
- Allow coloring of icon bar buttons.
- Support multiple body editors.


#@+node:ekr.20081124094918.1:Fix problems with scim
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/59c1e5d6acaf4de0

I've some more information about the problems with accent previously
reported:
- I can confirm that they are caused by the interaction scim+leo (with
and without the qt plugin). If scim is not started leo works fine. If
scim is running the problems appear and are slightly different with
and without the qt plugin. The workaround is obvious: don't use leo
and scim at the same time :-)
- accents are not working in the qt plugin when scintilla is used. If
qt-use-scintilla=False I can write this:

àáä (the same for the rest of vowels)

but if qt-use-scintilla=True when I enter the same sequence in the
keyboard I get:

`aaa (the same for the rest of vowels)

- the problem with the ñ character (reported previously too) is only
present in the qt plugin (both with and without scintilla)
#@-node:ekr.20081124094918.1:Fix problems with scim
#@+node:ekr.20081121105001.151:Finally/maybe
- Can style sheets really do the job?
- Flash characters without changing the selection?
- Remove old-style Leo settings?
- Add stylesheets for dialogs.
    - Set font for dummy widget in style sheet, then copy that font.
#@+node:ekr.20081121105001.150:QScintilla stuff
- Check event handling with QScintilla.
- Experiment with sending <shift-tab> directly to QScintilla.
- Call setLexer(0) for nocolor nodes.
- Add settings for syntax coloring.
- Make Scintilla handle Leo markup.
- Install new Qt version and play with QScintilla.
    From QScintilla change log:
    2008/10/12 14:32:05  phil
    QsciScintilla::setSelection() is now implemented using SCI_SETSEL so that the
    carat can be left at either the start or the end of the selection.
    Exposed QsciScintilla::positionFromLineIndex() and
    QsciScintilla::lineIndexFromPosition().
    - Fix problem with accented characters: see child node for notes.
#@nonl
#@-node:ekr.20081121105001.150:QScintilla stuff
#@-node:ekr.20081121105001.151:Finally/maybe
#@-node:ekr.20081121105001.148: qt To do
#@+node:ekr.20081121105001.185:Scripts
#@+node:ekr.20081121105001.186:Script to display Qt font database
import PyQt4.QtGui as QtGui

db = QtGui.QFontDatabase()
for family in db.families():
    print family
    for style in db.styles(family):
        print '\t',style,db.smoothSizes(family,style)
#@-node:ekr.20081121105001.186:Script to display Qt font database
#@+node:ekr.20081121105001.187:dump guiBindNamesInverseDict
print g.dictToString(c.k.guiBindNamesInverseDict)

@
   BackSpace: 'BackSpace'
       Begin: 'Begin'
       Break: 'Break'
   Caps_Lock: 'Caps_Lock'
       Clear: 'Clear'
      Delete: 'Delete'
        Down: 'Down'
         End: 'End'
      Escape: 'Escape'
          F1: 'F1'
         F10: 'F10'
         F11: 'F11'
         F12: 'F12'
          F2: 'F2'
          F3: 'F3'
          F4: 'F4'
          F5: 'F5'
          F6: 'F6'
          F7: 'F7'
          F8: 'F8'
          F9: 'F9'
        Home: 'Home'
        Left: 'Left'
    Linefeed: 'Linefeed'
        Next: 'Next'
    Num_Lock: 'Num_Lock'
       Prior: 'Prior'
      Return: 'Return'
       Right: 'Right'
         Tab: 'Tab'
          Up: 'Up'
   ampersand: '&'
 asciicircum: '^'
  asciitilde: '~'
    asterisk: '*'
          at: '@'
   backslash: '\\'
         bar: '|'
   braceleft: '{'
  braceright: '}'
 bracketleft: '['
bracketright: ']'
       colon: ':'
       comma: ','
      dollar: '$'
       equal: '='
      exclam: '!'
     greater: '>'
        less: '<'
       minus: '-'
  numbersign: '#'
   parenleft: '('
  parenright: ')'
     percent: '%'
      period: '.'
        plus: '+'
    question: '?'
    quotedbl: '"'
   quoteleft: '`'
  quoteright: "'"
   semicolon: ';'
       slash: '/'
       space: ' '
  underscore: '_'
#@nonl
#@-node:ekr.20081121105001.187:dump guiBindNamesInverseDict
#@-node:ekr.20081121105001.185:Scripts
#@+node:ekr.20081208072750.21:New redraw code
#@+node:ekr.20081208072750.10:partial_redraw & helpers
def partial_redraw (self,scroll=False,forceDraw=False): # forceDraw not used.

    '''Redraw the tree, minimizing the actual changes made to the tree.'''

    trace = True; verbose = False
    c = self.c ; w = self.treeWidget
    if not w: return
    if self.redrawing:
        if trace: g.trace('***** already drawing',g.callers(5))
        return

    self.redrawCount += 1
    if trace and verbose: tstart()

    # Init the data structures.
    ### self.initData()
    self.nodeDrawCount = 0
    self.redrawing = True
    try:
        self.expandAllAncestors(c.currentPosition())
        p = c.rootPosition()
        while p:
            self.updateSibs(p,parentItem=None)
            p.moveToNext()
    finally:
        if not self.selecting:
            item = self.setCurrentItem()
            if p and not item:
                g.trace('Error: no current item: %s' % (p.headString()))

        ### w.repaint() # To draw the tree initially.
        c.requestRedrawFlag= False
        self.redrawing = False
        if trace and verbose: tstop()
        if trace: g.trace('%s: drew %3s nodes' % (
            self.redrawCount,self.nodeDrawCount))

# redraw = full_redraw # Compatibility
# redraw_now = full_redraw
#@-node:ekr.20081208072750.10:partial_redraw & helpers
#@+node:ekr.20081208072750.15:update_sibs
def update_sibs (self,p,parent_item)

    w = self.widget

    data = self.getSibs(p,parent_item)
    children, child_items, child_vnodes = data

#@-node:ekr.20081208072750.15:update_sibs
#@+node:ekr.20081208072750.19:redraw_after_x
redraw_after_clone = partial_redraw
redraw_after_contract = partial_redraw
redraw_after_delete = partial_redraw
redraw_after_expand = partial_redraw
redraw_after_insert = partial_redraw
redraw_after_move_down = partial_redraw
redraw_after_move_left = partial_redraw
redraw_after_move_right = partial_redraw
redraw_after_move_up = partial_redraw

def redraw_after_icons_changed (self,all=False):
    g.trace('should not be called',g.callers(4))

def redraw_after_select (self):
    pass # Don't redraw!
#@nonl
#@-node:ekr.20081208072750.19:redraw_after_x
#@+node:ekr.20081208072750.16:getSibs
def getSibs (self,parent,parent_item):

    '''Return (children,items,item_vnodes):

    children:   list of new child positions of the parent position.
    items:      list of old child items of parent_item.
    item_vnodes:list of vnodes associated with items.
    len(items) == len(item_vnodes)
    len(children) can be greater, less or equal to len(items).'''

    w = self.widget

    children = [z for z in p.self_and_siblings_iter()]

    if parent_item:
        items = parent_item.children()
    else:
        n = w.topLevelItemCount()
        items = [w.topLevelItem(z) for z in range(n)]

    def itemVnode(item)
        p = self.itemsDict.get(item)
        return p and p.v or None

    item_vnodes = [itemVnode(z) for z in items]

    # We use vnodes to match children with items.
    return children, items, item_vnodes
#@nonl
#@-node:ekr.20081208072750.16:getSibs
#@+node:ekr.20081208072750.17:utilities
def item2vnode (self,item):
    return self.item2vnodeDict.get(item)

def vnode2item (self,v):
    return self.vnode2itemDict.get(v)

def isValidItem (self,item):
    return item in self.item2vnodeDict
#@nonl
#@-node:ekr.20081208072750.17:utilities
#@+node:ekr.20081208072750.18:deleteItemTree
def deleteItemTree (self,parent_item,item):

    w = self.treeWidget

    while True:
        child = item.child(0)
        if child: self.deleteItem(parent_item,n,child)
        else: break

    if parent


    w.delete

def deleteItem (self,item)
#@nonl
#@-node:ekr.20081208072750.18:deleteItemTree
#@-node:ekr.20081208072750.21:New redraw code
#@+node:ekr.20081208155215.12:Unused
#@+node:ekr.20081121105001.423:removeFromDicts (not used)
def removeFromDicts (self,p):

    # Important: items do not necessarily exist.

    # Remove position from item2positionDict.
    p2 = self.item2positionDict.get(it)
    if p2 == p: del self.item2positionDict[it]

    # Remove items from vnode2dataDict
    aList = self.vnode2dataDict.get(p.v,[])
    aList = [z for z in aList if z[0] != p]
    self.vnode2dataDict[p.v] = aList

    # Remove items from tnode2dataDict
    aList = self.tnode2dataDict.get(p.v.t,[])
    # aList = [z for z in aList if z[1] != it] # Wrong
    aList = [z for z in aList if z[0] != p]
    self.tnode2dataDict[p.v.t] = aList
#@-node:ekr.20081121105001.423:removeFromDicts (not used)
#@-node:ekr.20081208155215.12:Unused
#@-all
#@nonl
#@-node:ekr.20081121105001.147:@thin qtNotes.txt
#@-leo
