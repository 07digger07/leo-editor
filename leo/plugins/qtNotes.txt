#@+leo-ver=4-thin
#@+node:ekr.20081121105001.147:@thin qtNotes.txt
#@+all
#@+node:ekr.20081121105001.148: qt To do
@nocolor-node

First:

- Make sure cut/paste always works.
- Get rClick plugin working.
#@+node:ekr.20081215074704.13:Bugs
* Disabling searches of body pane can cause hard crashes.
    - initInteractiveCommands expects c.edit_widget(p)to exist.
#@nonl
#@+node:ekr.20081215074704.14:** Fix flash characters problems
Ask Qt people.
#@nonl
#@-node:ekr.20081215074704.14:** Fix flash characters problems
#@+node:ekr.20081215074704.15:** Cut/paste work erratically
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/58af715355227ec

I'm observing the following strange behavior when copy and paste text
using the qt plugin. The behavior is erratic and I cannot reproduce it
systematically so I'll try to give you a general picture.

When I select and copy text in the body pane of a node SOMETIMES I see
the following message in the console

QClipboard::setData: Cannot set X11 selection owner for CLIPBOARD

When I try to paste the copied text:
- sometimes it works fine
- sometimes nothing happens (and the Paste entry of the body pane
context menu is disabled)
- sometimes the pasted text is not the last copied text (i.e. some
copy operations fail)

I know this is confusing and I've done my best trying to get a pattern
for these facts but with no luck.

Vicent 
#@nonl
#@-node:ekr.20081215074704.15:** Cut/paste work erratically
#@+node:ekr.20090123073723.11:Fix image plugin with qt gui
@nocolor-node

After the qt-plugin merge (rev 1251 ), the image plugin no longer works. I
couldn't find any mention of gsimage in the diff.

 # Erase image if it was previously displayed
             a = g.app ; c = keywords.get("c")

-            if a.gsimage:
+            if getattr(a, 'gsimage', None):
                 try:
                     c.frame.body.bodyCtrl.delete(a.gsimage)
                 except:
#@-node:ekr.20090123073723.11:Fix image plugin with qt gui
#@+node:ekr.20090123073723.12:Fix php section coloring
http://groups.google.com/group/leo-editor/browse_thread/thread/41870d58718b7b7a#
#@nonl
#@-node:ekr.20090123073723.12:Fix php section coloring
#@+node:ekr.20081215074704.16:Mark finds doesn't work in Qt gui plugin
http://groups.google.com/group/leo-editor/browse_thread/thread/b2af78fbb36d3590
#@nonl
#@-node:ekr.20081215074704.16:Mark finds doesn't work in Qt gui plugin
#@+node:ekr.20081124094918.1:Fix problems with scim
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/59c1e5d6acaf4de0

I've some more information about the problems with accent previously
reported:
- I can confirm that they are caused by the interaction scim+leo (with
and without the qt plugin). If scim is not started leo works fine. If
scim is running the problems appear and are slightly different with
and without the qt plugin. The workaround is obvious: don't use leo
and scim at the same time :-)
- accents are not working in the qt plugin when scintilla is used. If
qt-use-scintilla=False I can write this:

àáä (the same for the rest of vowels)

but if qt-use-scintilla=True when I enter the same sequence in the
keyboard I get:

`aaa (the same for the rest of vowels)

- the problem with the ñ character (reported previously too) is only
present in the qt plugin (both with and without scintilla)
#@-node:ekr.20081124094918.1:Fix problems with scim
#@+node:ekr.20081215074704.18:Finish qt gui delete_range method
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/51edf3b44d6a587e

revno: 1259.1.10
revision-id: terry_n_brown@yahoo.com-20081130181632-ci0ioaksewdvc257

I added code so that this no longer derails the initialization process,
i.e. just catch the exception and continue.  I don't know what's wrong
except I first noticed it after a tkinter update from Ubuntu.  I
think.  Anyway, that's my story :)

When I added the "clean recent files" menu option long before this
traceback showed up I had a heap of trouble deleting just the file
entries on the recent files menu.  It was originally hardwired that the
menu have a "Clear list" item, and then the file entries, but I wanted
to make it get it's command entries from @menu @settings and add the
files afterward and that was a lot of fiddling.  I.e. originally it
deleted everything and added the "Clear list" item before rebuilding
the file list, now it either tries to delete only the file entries, or
stores the entries before the files (from @menu) and adds them back
before the files each time, I forget which finally worked.

What's my point?  It would be nice if delete_range "just worked".  It's
a 'pass' in qt, and I would guess recent files is the only thing in the
entire code base that uses it.

The menu tree seems to me to be "write only", i.e. not readable, at
least from the Leo API, of course you can walk it in a gui specific
way.  Not necessarily a problem, but would be nice if it was more
robustly dynamic.  Or maybe I'm missing something, but I've only seen
functions which find a menu based on knowing it exists before hand.
#@nonl
#@-node:ekr.20081215074704.18:Finish qt gui delete_range method
#@-node:ekr.20081215074704.13:Bugs
#@+node:ekr.20081215074704.19:Features 5
#@+node:ekr.20081215162017.4:Allow coloring of script buttons
#@-node:ekr.20081215162017.4:Allow coloring of script buttons
#@+node:ekr.20081215162017.5:Support multiple body editors
#@-node:ekr.20081215162017.5:Support multiple body editors
#@+node:ekr.20081215074704.20:Change background color of body pane depending on focus
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/1cce885a697d0236/5aea5d0587b47b92?lnk=gst&q=command+and+insert#5aea5d0587b47b92

Set focus in/out events.
#@nonl
#@-node:ekr.20081215074704.20:Change background color of body pane depending on focus
#@+node:ekr.20081215074704.21:Add drag and drop
#@-node:ekr.20081215074704.21:Add drag and drop
#@+node:ekr.20081121105001.151:Clean up settings
- Can style sheets really do the job?

- Remove old-style Leo settings?

- Add stylesheets for dialogs.
    - Set font for dummy widget in style sheet, then copy that font.
#@+node:ekr.20081121105001.150:QScintilla stuff
- Check event handling with QScintilla.
- Experiment with sending <shift-tab> directly to QScintilla.
- Call setLexer(0) for nocolor nodes.
- Add settings for syntax coloring.
- Make Scintilla handle Leo markup.
- Install new Qt version and play with QScintilla.
    From QScintilla change log:
    2008/10/12 14:32:05  phil
    QsciScintilla::setSelection() is now implemented using SCI_SETSEL so that the
    carat can be left at either the start or the end of the selection.
    Exposed QsciScintilla::positionFromLineIndex() and
    QsciScintilla::lineIndexFromPosition().
    - Fix problem with accented characters: see child node for notes.
#@nonl
#@-node:ekr.20081121105001.150:QScintilla stuff
#@-node:ekr.20081121105001.151:Clean up settings
#@-node:ekr.20081215074704.19:Features 5
#@-node:ekr.20081121105001.148: qt To do
#@+node:ekr.20081121105001.185:Scripts
#@+node:ekr.20081121105001.186:Script to display Qt font database
import PyQt4.QtGui as QtGui

db = QtGui.QFontDatabase()
for family in db.families():
    print family
    for style in db.styles(family):
        print '\t',style,db.smoothSizes(family,style)
#@-node:ekr.20081121105001.186:Script to display Qt font database
#@+node:ekr.20081121105001.187:dump guiBindNamesInverseDict
print g.dictToString(c.k.guiBindNamesInverseDict)

@
   BackSpace: 'BackSpace'
       Begin: 'Begin'
       Break: 'Break'
   Caps_Lock: 'Caps_Lock'
       Clear: 'Clear'
      Delete: 'Delete'
        Down: 'Down'
         End: 'End'
      Escape: 'Escape'
          F1: 'F1'
         F10: 'F10'
         F11: 'F11'
         F12: 'F12'
          F2: 'F2'
          F3: 'F3'
          F4: 'F4'
          F5: 'F5'
          F6: 'F6'
          F7: 'F7'
          F8: 'F8'
          F9: 'F9'
        Home: 'Home'
        Left: 'Left'
    Linefeed: 'Linefeed'
        Next: 'Next'
    Num_Lock: 'Num_Lock'
       Prior: 'Prior'
      Return: 'Return'
       Right: 'Right'
         Tab: 'Tab'
          Up: 'Up'
   ampersand: '&'
 asciicircum: '^'
  asciitilde: '~'
    asterisk: '*'
          at: '@'
   backslash: '\\'
         bar: '|'
   braceleft: '{'
  braceright: '}'
 bracketleft: '['
bracketright: ']'
       colon: ':'
       comma: ','
      dollar: '$'
       equal: '='
      exclam: '!'
     greater: '>'
        less: '<'
       minus: '-'
  numbersign: '#'
   parenleft: '('
  parenright: ')'
     percent: '%'
      period: '.'
        plus: '+'
    question: '?'
    quotedbl: '"'
   quoteleft: '`'
  quoteright: "'"
   semicolon: ';'
       slash: '/'
       space: ' '
  underscore: '_'
#@nonl
#@-node:ekr.20081121105001.187:dump guiBindNamesInverseDict
#@-node:ekr.20081121105001.185:Scripts
#@+node:ekr.20090124101344.1:Recent
#@+node:ekr.20090123073723.13:Set focus in window activate events
#@+node:ekr.20081121105001.168:eventFilter
def eventFilter(self, obj, event):

    trace = False ; verbose = True
    traceFocus = False and not g.unitTesting
    c = self.c ; k = c.k
    eventType = event.type()
    ev = QtCore.QEvent
    kinds = [ev.ShortcutOverride,ev.KeyPress,ev.KeyRelease]
    if traceFocus:
        table = (
            (ev.FocusIn,        'focus-in '),
            (ev.FocusOut,       'focus-out'),
            (ev.WindowActivate, 'activate '))
        for evKind,kind in table:
            if eventType == evKind:
                g.trace('%s %s %s' % (
                    (kind,id(obj),
                    # event.reason(),
                    g.app.gui.widget_name(obj) or obj)))
        # else: g.trace('unknown kind: %s' % eventType)

    if eventType == ev.WindowActivate:
        g.app.gui.onActivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
        # g.trace(g.app.gui.get_focus(c))
    elif eventType in kinds:
        tkKey,ch,ignore = self.toTkKey(event)
        aList = c.k.masterGuiBindingsDict.get('<%s>' %tkKey,[])

        if ignore:
            override = False
        elif self.isSpecialOverride(tkKey,ch):
            override = True
        elif k.inState():
            override = not ignore # allow all keystrokes.
        elif safe_mode:
            override = len(aList) > 0 and not self.isDangerous(tkKey,ch)
        else:
            override = len(aList) > 0
    else:
        override = False ; tkKey = '<no key>'

    # A hack. QLineEdit generates ev.KeyRelease only.
    if eventType in (ev.KeyPress,ev.KeyRelease):
        p = c.currentPosition()
        isEditWidget = obj == c.frame.tree.edit_widget(p)
        keyIsActive = g.choose(
            isEditWidget,
            eventType == ev.KeyRelease,
            eventType == ev.KeyPress)
    else:
        keyIsActive = False

    if keyIsActive:
        if override:
            w = self.w # Pass the wrapper class, not the wrapped widget.
            stroke = self.toStroke(tkKey,ch)
            leoEvent = leoKeyEvent(event,c,w,ch) # ch was stroke
            ret = k.masterKeyHandler(leoEvent,stroke=stroke)
            c.outerUpdate()
        else:
            if trace: g.trace(self.tag,'unbound',tkKey)

    if trace: self.traceEvent(obj,event,tkKey,override)

    return override
#@-node:ekr.20081121105001.168:eventFilter
#@+node:ekr.20090123150451.11:onActivateEvent (qtGui)
def onActivateEvent (self,event,c,obj,tag):

    '''Put the focus in the body pane when the Leo window is
    activated, say as the result of an Alt-tab or click.'''

    # This is called several times for each window activation.
    # We only need to set the focus once.

    if c.exists and tag == 'body':

        # g.trace('Activate',tag,g.callers(5))

        # Putting focus in the body is clearest.
        c.bodyWantsFocus()
        c.outerUpdate()
#@-node:ekr.20090123150451.11:onActivateEvent (qtGui)
#@+node:ekr.20081121105001.330:createTab
def createTab (self,tabName,widget=None,wrap='none'):
    """ Create a new tab in tab widget

    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """
    c = self.c ; w = self.tabWidget

    if widget is None:
        contents = QtGui.QTextBrowser()
        contents.setWordWrapMode(QtGui.QTextOption.NoWrap)
        self.logDict[tabName] = contents
        if tabName == 'Log': self.logCtrl = contents
        theFilter = leoQtEventFilter(c,w=contents,tag='tab')
        contents.installEventFilter(theFilter)
    else:
        contents = widget

    self.contentsDict[tabName] = contents
    w.addTab(contents,tabName)
    return contents

#@-node:ekr.20081121105001.330:createTab
#@-node:ekr.20090123073723.13:Set focus in window activate events
#@+node:ekr.20090123181335.45:** BUG: cloned headlines not updated properly
#@+node:ekr.20081121105001.163:onHeadChanged (qtTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.'''

    trace = False ; verbose = True
    c = self.c ; u = c.undoer
    ew = self.edit_widget(p)
    if ew: e = ew.widget
    item = self.position2item(p)

    w = g.app.gui.get_focus()

    # These are not errors: onItemChanged may
    # have been called first.
    if trace and verbose:
        if not e:  g.trace('No e',g.callers(4))
        if e != w: g.trace('e != w',e,w,g.callers(4))
        if not p:  g.trace('No p')

    if e and e == w and item and p:
        s = e.text() ; len_s = len(s)
        s = g.app.gui.toUnicode(s)
        oldHead = p.headString()
        changed = s != oldHead
        if trace: g.trace('changed',changed,repr(s),g.callers(4))
        if changed:
            p.initHeadString(s)
            item.setText(0,s) # Required to avoid full redraw.
            undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
            if not c.changed: c.setChanged(True)
            # New in Leo 4.4.5: we must recolor the body because
            # the headline may contain directives.
            c.frame.body.recolor(p,incremental=True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)

    # This is a crucial shortcut.
    if g.unitTesting: return

    self.redraw_after_head_changed()

    if self.stayInTree:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()
    c.outerUpdate()
#@-node:ekr.20081121105001.163:onHeadChanged (qtTree)
#@+node:ekr.20090109110752.19:redraw_after_head_changed
def redraw_after_head_changed (self):

    # g.trace(g.callers(4))

    c = self.c ; p = c.currentPosition()

    if p:
        h = p.headString()
        for item in self.tnode2items(p.v.t):
            if self.isValidItem(item):
                item.setText(0,h)

    #### self.full_redraw()
#@nonl
#@-node:ekr.20090109110752.19:redraw_after_head_changed
#@-node:ekr.20090123181335.45:** BUG: cloned headlines not updated properly
#@-node:ekr.20090124101344.1:Recent
#@+node:ekr.20081208155215.12:Unused
#@+node:ekr.20090110154843.11:killEditing
def killEditing (self):

    trace = False

    if trace:
        c = self.c ; p = c.currentPosition()
        if p: g.trace(p.headString(),g.callers(4))

    # self._editItem = None
    # self._editWidgetPosition = None
    # self._editWidget = None
    # self._editWidgetWrapper = None
#@-node:ekr.20090110154843.11:killEditing
#@+node:ekr.20090124174652.101:class leoQtTree (leoTree)
class leoQtTree (leoTree):

    """Leo qt tree class, a subclass of baseNativeTreeWidget."""

    callbacksInjected = False # A class var.
    << class leoQtTree (baseNativeTree) >>
#@+node:ekr.20081121105001.401: Birth... (qt Tree)
#@+node:ekr.20081121105001.402:__init__ (qtTree)
def __init__(self,c,frame):

    # g.trace('*****qtTree')

    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Components.
    self.c = c
    self.canvas = self # An official ivar used by Leo's core.
    self.treeWidget = w = frame.top.ui.treeWidget # An internal ivar.

    try:
        w.headerItem().setHidden(True)
    except Exception:
        pass

    # w.setIconSize(QtCore.QSize(20,11))
    w.setIconSize(QtCore.QSize(160,16))
    # w.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)

    # Status ivars.
    self.dragging = False
    self.expanding = False
    self.prev_p = None
    self.redrawing = False
    self.redrawingIcons = False
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    self.selecting = False

    # Debugging.
    self.nodeDrawCount = 0

    # Associating items with vnodes...
    self.item2vnodeDict = {}
    self.tnode2itemsDict = {} # values are lists of items.
    self.vnode2itemsDict = {} # values are lists of items.

    self.setConfigIvars()
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
#@-node:ekr.20081121105001.402:__init__ (qtTree)
#@+node:ekr.20081121105001.159:qtTree.initAfterLoad
def initAfterLoad (self):

    c = self.c ; frame = c.frame
    w = c.frame.top ; tw = self.treeWidget

    if not leoQtTree.callbacksInjected:
        leoQtTree.callbacksInjected = True
        self.injectCallbacks() # A base class method.

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemDoubleClicked(QTreeWidgetItem*, int)"),
        self.onItemDoubleClicked)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemSelectionChanged()"),
        self.onTreeSelect)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemChanged(QTreeWidgetItem*, int)"),
        self.onItemChanged)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemCollapsed(QTreeWidgetItem*)"),
        self.onItemCollapsed)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemExpanded(QTreeWidgetItem*)"),
        self.onItemExpanded)

    self.ev_filter = leoQtEventFilter(c,w=self,tag='tree')
    tw.installEventFilter(self.ev_filter)

    c.setChanged(False)
#@-node:ekr.20081121105001.159:qtTree.initAfterLoad
#@+node:ekr.20081121105001.403:qtTree.setBindings & helper
def setBindings (self):

    '''Create master bindings for all headlines.'''

    pass
#@-node:ekr.20081121105001.403:qtTree.setBindings & helper
#@+node:ekr.20081121105001.405:qtTree.setCanvasBindings
def setCanvasBindings (self,canvas):

    pass
#@nonl
#@-node:ekr.20081121105001.405:qtTree.setCanvasBindings
#@+node:ekr.20081121105001.408:get_name (qtTree)
def getName (self):

    name = 'canvas(tree)' # Must start with canvas.

    return name
#@-node:ekr.20081121105001.408:get_name (qtTree)
#@-node:ekr.20081121105001.401: Birth... (qt Tree)
#@+node:ekr.20081121105001.409:Config... (qtTree)
#@+node:ekr.20081121105001.410:do-nothin config stuff
# These can be do-nothings, replaced by QTree settings.

def bind (self,*args,**keys):               pass

def headWidth(self,p=None,s=''):            return 0
def widthInPixels(self,s):                  return 0

def setEditLabelState (self,p,selectAll=False): pass # not called.

def setSelectedLabelState (self,p):         pass
def setUnselectedLabelState (self,p):       pass
def setDisabledHeadlineColors (self,p):     pass
def setEditHeadlineColors (self,p):         pass
def setUnselectedHeadlineColors (self,p):   pass

setNormalLabelState = setEditLabelState # For compatibility.
#@nonl
#@-node:ekr.20081121105001.410:do-nothin config stuff
#@+node:ekr.20081121105001.411:setConfigIvars
def setConfigIvars (self):

    c = self.c

    self.allow_clone_drags          = c.config.getBool('allow_clone_drags')
    self.enable_drag_messages       = c.config.getBool("enable_drag_messages")

    # self.center_selected_tree_node = c.config.getBool('center_selected_tree_node')

    # self.expanded_click_area  = c.config.getBool('expanded_click_area')
    # self.gc_before_redraw     = c.config.getBool('gc_before_redraw')

    # self.headline_text_editing_foreground_color = c.config.getColor(
        # 'headline_text_editing_foreground_color')
    # self.headline_text_editing_background_color = c.config.getColor(
        # 'headline_text_editing_background_color')
    # self.headline_text_editing_selection_foreground_color = c.config.getColor(
        # 'headline_text_editing_selection_foreground_color')
    # self.headline_text_editing_selection_background_color = c.config.getColor(
        # 'headline_text_editing_selection_background_color')
    # self.headline_text_selected_foreground_color = c.config.getColor(
        # "headline_text_selected_foreground_color")
    # self.headline_text_selected_background_color = c.config.getColor(
        # "headline_text_selected_background_color")
    # self.headline_text_editing_selection_foreground_color = c.config.getColor(
        # "headline_text_editing_selection_foreground_color")
    # self.headline_text_editing_selection_background_color = c.config.getColor(
        # "headline_text_editing_selection_background_color")
    # self.headline_text_unselected_foreground_color = c.config.getColor(
        # 'headline_text_unselected_foreground_color')
    # self.headline_text_unselected_background_color = c.config.getColor(
        # 'headline_text_unselected_background_color')

    # self.initialClickExpandsOrContractsNode = c.config.getBool(
        # 'initialClickExpandsOrContractsNode')
    # self.look_for_control_drag_on_mouse_down = c.config.getBool(
        # 'look_for_control_drag_on_mouse_down')

    self.select_all_text_when_editing_headlines = c.config.getBool(
        'select_all_text_when_editing_headlines')

    self.stayInTree     = c.config.getBool('stayInTreeAfterSelect')
    self.use_chapters   = c.config.getBool('use_chapters')
#@-node:ekr.20081121105001.411:setConfigIvars
#@-node:ekr.20081121105001.409:Config... (qtTree)
#@+node:ekr.20081121105001.412:Drawing... (qtTree)

#@+node:ekr.20090109110752.21:Entry points (qtTree)
#@+node:ekr.20081121105001.414:full_redraw & helpers
# forceDraw not used in Qt.  It is used in the Tk code.

def full_redraw (self,p=None,scroll=True,forceDraw=False):

    '''Redraw all visible nodes of the tree.

    Preserve the vertical scrolling unless scroll is True.'''

    trace = False
    c = self.c ; w = self.treeWidget
    if not w: return
    if self.redrawing:
        g.trace('***** already drawing',g.callers(5))
        return

    if p is None:
        p = c.currentPosition()
    else:
        c.setCurrentPosition(p)

    self.redrawCount += 1
    if trace:
        # g.trace(self.redrawCount,g.callers())
        tstart()

    # Init the data structures.
    self.initData()
    self.nodeDrawCount = 0
    self.redrawing = True
    try:
        hScroll = w.horizontalScrollBar()
        vScroll = w.verticalScrollBar()
        hPos = hScroll.sliderPosition()
        vPos = vScroll.sliderPosition()
        # g.trace(hPos,vPos)
        w.clear()
        # Draw all top-level nodes and their visible descendants.
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            p = bunch.p ; h = p.headString()
            if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
                p = p.firstChild()
                while p:
                    self.drawTree(p)
                    p.moveToNext()
            else:
                self.drawTree(p)
        else:
            p = c.rootPosition()
            while p:
                self.drawTree(p)
                p.moveToNext()
    finally:
        if not self.selecting:
            self.setCurrentItem()
        hScroll.setSliderPosition(hPos)
        if not scroll:
            vScroll.setSliderPosition(vPos)

        # Necessary to get the tree drawn initially.
        w.repaint()

        c.requestRedrawFlag= False
        self.redrawing = False
        if trace:
            theTime = tstop()
            if True and not g.app.unitTesting:
                g.trace('%s: scroll: %s, drew %3s nodes in %s' % (
                    self.redrawCount,scroll,self.nodeDrawCount,theTime),
                    g.callers(4))

# Compatibility
redraw = full_redraw 
redraw_now = full_redraw
#@+node:ekr.20081210075843.10:contractItem & expandItem
def contractItem (self,item):

    self.treeWidget.collapseItem(item)

def expandItem (self,item):

    self.treeWidget.expandItem(item)
#@-node:ekr.20081210075843.10:contractItem & expandItem
#@+node:ekr.20081209211810.1:drawChildren
def drawChildren (self,p,parent_item):

    if not p:
        return g.trace('can not happen: no p')

    if p.hasChildren():
        if p.isExpanded():
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child,parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child,parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
#@-node:ekr.20081209211810.1:drawChildren
#@+node:ekr.20081121105001.164:drawNode
def drawNode (self,p,parent_item):

    c = self.c ; w = self.treeWidget
    self.nodeDrawCount += 1

    # Allocate the QTreeWidget item.
    itemOrTree = parent_item or w
    item = QtGui.QTreeWidgetItem(itemOrTree)
    item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)

    # Do this now, so self.isValidItem will be true in setItemIcon.
    self.rememberItem(p,item)

    # Set the headline and maybe the icon.
    item.setText(0,p.headString())
    if p:
        icon = self.getIcon(p)
        self.setItemIcon(item,icon)

    return item
#@-node:ekr.20081121105001.164:drawNode
#@+node:ekr.20081121105001.416:drawTree
def drawTree (self,p,parent_item=None):

    # Draw the (visible) parent node.
    item = self.drawNode(p,parent_item)

    # Draw all the visible children.
    self.drawChildren(p,parent_item=item)


#@-node:ekr.20081121105001.416:drawTree
#@+node:ekr.20081121105001.415:initData
def initData (self):

    self.item2vnodeDict = {}
    self.tnode2itemsDict = {}
    self.vnode2itemsDict = {}
#@-node:ekr.20081121105001.415:initData
#@+node:ekr.20090110140239.1:rememberItem & rememberVnodeItem
def rememberItem (self,p,item):

    self.rememberVnodeItem(p.v,item)

def rememberVnodeItem (self,v,item):

    # Update item2vnodeDict.
    self.item2vnodeDict[item] = v

    # Update tnode2itemsDict & vnode2itemsDict.
    table = (
        (self.tnode2itemsDict,v.t),
        (self.vnode2itemsDict,v))

    for d,key in table:
        aList = d.get(key,[])
        if item in aList:
            g.trace('*** ERROR *** item already in list: %s, %s' % (item,aList))
        else:
            aList.append(item)
        d[key] = aList
#@-node:ekr.20090110140239.1:rememberItem & rememberVnodeItem
#@-node:ekr.20081121105001.414:full_redraw & helpers
#@+node:ekr.20090110133205.1:redraw_after_contract
def redraw_after_contract (self,p=None):

    if self.redrawing:
        return

    item = self.position2item(p)

    if item:
        self.contractItem(item)
    else:
        # This is not an error.
        # We may have contracted a node that was not, in fact, visible.
        self.full_redraw()
#@-node:ekr.20090110133205.1:redraw_after_contract
#@+node:ekr.20090112093625.10:redraw_after_expand
def redraw_after_expand (self,p=None):

    self.full_redraw (p,scroll=False)
#@-node:ekr.20090112093625.10:redraw_after_expand
#@+node:ekr.20090109110752.19:redraw_after_head_changed
def redraw_after_head_changed (self):

    # g.trace(g.callers(4))

    c = self.c ; p = c.currentPosition()

    if p:
        h = p.headString()
        for item in self.tnode2items(p.v.t):
            if self.isValidItem(item):
                item.setText(0,h)

    #### self.full_redraw()
#@nonl
#@-node:ekr.20090109110752.19:redraw_after_head_changed
#@+node:ekr.20090109110752.16:redraw_after_icons_changed
def redraw_after_icons_changed (self,all=False):

    if self.redrawing: return

    self.redrawCount += 1 # To keep a unit test happy.

    c = self.c

    # Suppress call to setHeadString in onItemChanged!
    self.redrawing = True
    try:
        if all:
            for p in c.rootPosition().self_and_siblings_iter():
                self.updateVisibleIcons(p)
        else:
            p = c.currentPosition()
            self.updateIcon(p,force=True)
    finally:
        self.redrawing = False

#@-node:ekr.20090109110752.16:redraw_after_icons_changed
#@+node:ekr.20081208072750.19:redraw_after_select
# Important: this can not replace before/afterSelectHint.

def redraw_after_select (self,p=None):

    if self.redrawing: return

    # g.trace(p.headString())

    # Don't set self.redrawing here.
    # It will be set by self.afterSelectHint.

    item = self.position2item(p)

    # It is not an error for position2item to fail.
    if not item:
        self.full_redraw(p)

    # c.redraw_after_select calls tree.select indirectly.
    # Do not call it again here.
#@nonl
#@-node:ekr.20081208072750.19:redraw_after_select
#@-node:ekr.20090109110752.21:Entry points (qtTree)
#@+node:ekr.20090109110752.23:Helpers (qtTree)
#@+node:ekr.20090109110752.24:Associating items and nodes
#@+node:ekr.20090110140239.11:item dict getters
def item2tnode (self,item):
    v = self.item2vnodeDict.get(item)
    return v and v.t

def item2vnode (self,item):
    return self.item2vnodeDict.get(item)

def tnode2items(self,t):
    return self.tnode2itemsDict.get(t,[])

def vnode2items(self,v):
    return self.vnode2itemsDict.get(v,[])

def isValidItem (self,item):
    return item in self.item2vnodeDict
#@-node:ekr.20090110140239.11:item dict getters
#@+node:ekr.20081213123819.10:item2position & position2item & helpers
@nocolor-node
@

These two methods allow the drawing code to avoid storing any positions,
a crucial simplification. Indeed, without the burden of keeping position
up-to-date, or worse, recalculating them all whenever the outline changes,
the tree code becomes straightforward.
#@nonl
#@+node:ekr.20081208072750.16:childItems
def childItems (self,parent_item):

    '''Return the list of child items of the parent item,
    or the top-level items if parent_item is None.'''

    if parent_item:
        n = parent_item.childCount()
        items = [parent_item.child(z) for z in range(n)]
    else:
        w = self.treeWidget
        n = w.topLevelItemCount()
        items = [w.topLevelItem(z) for z in range(n)]

    return items
#@-node:ekr.20081208072750.16:childItems
#@+node:ekr.20081212123717.23:childIndexOfItem
def childIndexOfItem (self,item):

    parent = item.parent()

    if parent:
        n = parent.indexOfChild(item)
    else:
        w = self.treeWidget
        n = w.indexOfTopLevelItem(item)

    return n

#@-node:ekr.20081212123717.23:childIndexOfItem
#@+node:ekr.20081212123717.24:item2position
def item2position (self,item):

    '''Reconstitute a position given an item.'''

    stack = []
    childIndex = self.childIndexOfItem(item)
    v = self.item2vnode(item)

    item = item.parent()
    while item:
        n2 = self.childIndexOfItem(item)
        v2 = self.item2vnode(item)
        data = v2,n2
        stack.insert(0,data)
        item = item.parent()

    p = leoNodes.position(v,childIndex,stack)

    if not p:
        self.oops('item2position failed. p: %s, v: %s, childIndex: %s stack: %s' % (
            p,v,childIndex,stack))

    return p
#@-node:ekr.20081212123717.24:item2position
#@+node:ekr.20081213055214.11:nthChildItem
def nthChildItem (self,n,parent_item):

    children = self.childItems(parent_item)

    if n < len(children):
        item = children[n]
    else:
        # self.oops('itemCount: %s, n: %s' % (len(children),n))

        # This is **not* an error.
        # It simply means that we need to redraw the tree.
        item = None

    return item
#@-node:ekr.20081213055214.11:nthChildItem
#@+node:ekr.20081213055214.10:position2item
def position2item (self,p):

    '''Return the unique tree item associated with position p.

    Return None if there no such tree item.  This is *not* an error.'''

    parent_item = None

    for v,n in p.stack:
        parent_item = self.nthChildItem(n,parent_item)

    item = self.nthChildItem(p.childIndex(),parent_item)

    return item
#@-node:ekr.20081213055214.10:position2item
#@-node:ekr.20081213123819.10:item2position & position2item & helpers
#@-node:ekr.20090109110752.24:Associating items and nodes
#@+node:ekr.20081209064740.2:Icons
#@+node:ekr.20081121105001.417:drawIcon
def drawIcon (self,p):

    '''Redraw the icon at p.'''

    w = self.treeWidget
    itemOrTree = self.position2item(p) or w
    item = QtGui.QTreeWidgetItem(itemOrTree)
    icon = self.getIcon(p)
    self.setItemIcon(item,icon)
#@nonl
#@-node:ekr.20081121105001.417:drawIcon
#@+node:ekr.20081211115412.12:drawItemIcon
def drawItemIcon (self,p,item):

    '''Set the item's icon to p's icon.'''

    icon = self.getIcon(p)
    self.setItemIcon(item,icon)
#@-node:ekr.20081211115412.12:drawItemIcon
#@+node:ekr.20081121105001.418:getIcon & getIconImage
def getIcon(self,p):

    '''Return the proper icon for position p.'''

    p.v.iconVal = val = p.v.computeIcon()

    return self.getCompositeIconImage(p, val)

def getVnodeIcon(self,p):

    '''Return the proper icon for position p.'''

    p.v.iconVal = val = p.v.computeIcon()
    return self.getIconImage(val)

def getIconImage(self,val):

    return g.app.gui.getIconImage(
        "box%02d.GIF" % val)

def getCompositeIconImage(self, p, val):

    userIcons = self.c.editCommands.getIconList(p)
    statusIcon = self.getIconImage(val)

    if not userIcons:
        return statusIcon

    hash = [i['file'] for i in userIcons if i['where'] == 'beforeIcon']
    hash.append(str(val))
    hash.extend([i['file'] for i in userIcons if i['where'] == 'beforeHeadline'])
    hash = ':'.join(hash)

    if hash in g.app.gui.iconimages:
        return g.app.gui.iconimages[hash]

    images = [g.app.gui.getImageImage(i['file']) for i in userIcons
             if i['where'] == 'beforeIcon']
    images.append(g.app.gui.getImageImage("box%02d.GIF" % val))
    images.extend([g.app.gui.getImageImage(i['file']) for i in userIcons
                  if i['where'] == 'beforeHeadline'])
    width = sum([i.width() for i in images])
    height = max([i.height() for i in images])

    pix = QtGui.QPixmap(width,height)
    pix.fill()
    pix.setAlphaChannel(pix)
    painter = QtGui.QPainter(pix)
    x = 0
    for i in images:
        painter.drawPixmap(x,(height-i.height())//2,i)
        x += i.width()
    painter.end()

    g.app.gui.iconimages[hash] = QtGui.QIcon(pix)

    return g.app.gui.iconimages[hash]
#@-node:ekr.20081121105001.418:getIcon & getIconImage
#@+node:ekr.20090121065245.10:setItemIcon
def setItemIcon (self,item,icon):

    trace = False

    valid = item and self.isValidItem(item)

    if icon and valid:
        try:
            # Suppress onItemChanged.
            self.redrawingIcons = True
            item.setIcon(0,icon)
        except Exception:
            self.redrawingIcons = False
    elif trace:
        # Apparently, icon can be None due to recent icon changes.
        # Also, item can be invalid when editing a headline.
        if icon:
            g.trace('** item %s, valid: %s, icon: %s' % (
                item and id(item) or '<no item>',valid,icon),
                g.callers(4))
#@-node:ekr.20090121065245.10:setItemIcon
#@+node:ekr.20081121105001.431:updateIcon
def updateIcon (self,p,force=False):

    '''Update p's icon.'''

    if not p: return

    val = p.v.computeIcon()

    # The force arg is needed:
    # Leo's core may have updated p.v.iconVal.
    if p.v.iconVal == val and not force:
        return

    p.v.iconVal = val
    icon = self.getIconImage(val)
    # Update all cloned/joined items.
    items = self.tnode2items(p.v.t)
    for item in items:
        self.setItemIcon(item,icon)
#@nonl
#@-node:ekr.20081121105001.431:updateIcon
#@+node:ekr.20090112065600.10:updateVisibleIcons
def updateVisibleIcons (self,p):

    '''Update the icon for p and the icons
    for all visible descendants of p.'''

    self.updateIcon(p,force=True)

    if p.hasChildren() and p.isExpanded():
        for child in p.children_iter():
            self.updateVisibleIcons(child)
#@-node:ekr.20090112065600.10:updateVisibleIcons
#@-node:ekr.20081209064740.2:Icons
#@-node:ekr.20090109110752.23:Helpers (qtTree)
#@-node:ekr.20081121105001.412:Drawing... (qtTree)
#@+node:ekr.20081121105001.432:Event handlers... (qtTree)
#@+node:ekr.20081121105001.433:Click Box...
#@+node:ekr.20081121105001.434:onClickBoxClick
def onClickBoxClick (self,event,p=None):

    c = self.c
    if self.redrawing or self.selecting: return

    g.doHook("boxclick1",c=c,p=p,v=p,event=event)
    g.doHook("boxclick2",c=c,p=p,v=p,event=event)

    c.outerUpdate()
#@-node:ekr.20081121105001.434:onClickBoxClick
#@+node:ekr.20081121105001.435:onClickBoxRightClick
def onClickBoxRightClick(self, event, p=None):

    c = self.c
    if self.redrawing or self.selecting: return

    g.doHook("boxrclick1",c=c,p=p,v=p,event=event)
    g.doHook("boxrclick2",c=c,p=p,v=p,event=event)

    c.outerUpdate()
#@-node:ekr.20081121105001.435:onClickBoxRightClick
#@+node:ekr.20081121105001.436:onPlusBoxRightClick
def onPlusBoxRightClick (self,event,p=None):

    c = self.c
    if self.redrawing or self.selecting: return

    g.doHook('rclick-popup',c=c,p=p,event=event,context_menu='plusbox')

    c.outerUpdate()
#@-node:ekr.20081121105001.436:onPlusBoxRightClick
#@-node:ekr.20081121105001.433:Click Box...
#@+node:ekr.20081121105001.437:findEditWidget
def findEditWidget (self,p):

    """Return the Qt.Text item corresponding to p."""

    # g.trace(p,g.callers(4))

    return None

#@-node:ekr.20081121105001.437:findEditWidget
#@+node:ekr.20081121105001.438:Icon Box...
#@+node:ekr.20081121105001.439:onIconBoxClick
def onIconBoxClick (self,event,p=None):

    c = self.c
    if self.redrawing or self.selecting: return

    g.doHook("iconclick1",c=c,p=p,v=p,event=event)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)

    c.outerUpdate()
#@-node:ekr.20081121105001.439:onIconBoxClick
#@+node:ekr.20081121105001.440:onIconBoxRightClick
def onIconBoxRightClick (self,event,p=None):

    """Handle a right click in any outline widget."""

    c = self.c
    if self.redrawing or self.selecting: return

    g.doHook("iconrclick1",c=c,p=p,v=p,event=event)
    g.doHook("iconrclick2",c=c,p=p,v=p,event=event)

    c.outerUpdate()
#@-node:ekr.20081121105001.440:onIconBoxRightClick
#@+node:ekr.20081121105001.441:onIconBoxDoubleClick
def onIconBoxDoubleClick (self,event,p=None):

    c = self.c
    if self.redrawing or self.selecting: return

    g.doHook("icondclick1",c=c,p=p,v=p,event=event)
    g.doHook("icondclick2",c=c,p=p,v=p,event=event)

    c.outerUpdate()
#@-node:ekr.20081121105001.441:onIconBoxDoubleClick
#@-node:ekr.20081121105001.438:Icon Box...
#@+node:ekr.20081121105001.443:onItemChanged
def onItemChanged(self, item, col):

    '''Handle a change event in a headline.
    This only gets called when the user hits return.'''

    c = self.c

    # Ignore changes when redrawing.
    if self.redrawing:
        return
    if self.redrawingIcons:
        return

    p = self.item2position(item)
    if p:
        # so far, col is always 0
        s = g.app.gui.toUnicode(item.text(col))
        p.setHeadString(s)
        p.setDirty()
        self.redraw_after_icons_changed(all=False)

    c.outerUpdate()
#@-node:ekr.20081121105001.443:onItemChanged
#@+node:ekr.20081121105001.444:onItemCollapsed
def onItemCollapsed (self,item):

    c = self.c ; p = c.currentPosition() ; w = self.treeWidget
    trace = False ; verbose = False

    # Ignore events generated by redraws.
    if self.redrawing:
        if trace and verbose: g.trace('already redrawing',g.callers(4))
        return
    if self.expanding:
        if trace and verbose: g.trace('already expanding',g.callers(4))
        return
    if self.selecting:
        if trace and verbose: g.trace('already selecting',g.callers(4))
        return

    if trace: g.trace(p.headString() or "<no p>",g.callers(4))

    p2 = self.item2position(item)
    if p2:
        p2.contract()
        c.frame.tree.select(p2)
        item = self.setCurrentItem()
    else:
        g.trace('Error: no p2')

    c.outerUpdate()
#@-node:ekr.20081121105001.444:onItemCollapsed
#@+node:ekr.20081121105001.161:onItemDoubleClicked
def onItemDoubleClicked (self,item,col):

    c = self.c ; w = self.treeWidget
    if self.redrawing or self.selecting: return

    w.setCurrentItem(item) # Must do this first.
    w.editItem(item)
    e = w.itemWidget(item,0)
    if not e:
        return g.trace('*** no e')
    p = self.item2position(item)
    if not p:
        return g.trace('*** no p')

    # Hook up the widget.
    e.connect(e,QtCore.SIGNAL(
        "textEdited(QTreeWidgetItem*,int)"),
        self.onHeadChanged)
    e.setObjectName('headline')
    c.outerUpdate()
#@-node:ekr.20081121105001.161:onItemDoubleClicked
#@+node:ekr.20081121105001.445:onItemExpanded
def onItemExpanded (self,item):

    '''Handle and tree-expansion event.'''

    # The difficult case is when the user clicks the expansion box.

    trace = False ; verbose = False
    c = self.c ; p = c.currentPosition() ; w = self.treeWidget

    # Ignore events generated by redraws.
    if self.redrawing:
        if trace and verbose: g.trace('already redrawing',g.callers(4))
        return
    if self.expanding:
        if trace and verbose: g.trace('already expanding',g.callers(4))
        return
    if self.selecting:
        if trace and verbose: g.trace('already selecting',g.callers(4))
        return

    if trace: g.trace(p.headString() or "<no p>",g.callers(4))

    try:
        self.expanding = True
        p2 = self.item2position(item)
        if p2:
            if not p2.isExpanded():
                p2.expand()
            c.frame.tree.select(p2) # same as self.select.
            self.full_redraw()
        else:
            g.trace('Error no p2')
    finally:
        self.expanding = False
        self.setCurrentItem()
        c.outerUpdate()
#@nonl
#@-node:ekr.20081121105001.445:onItemExpanded
#@+node:ekr.20081121105001.162:onTreeSelect
def onTreeSelect(self):

    '''Select the proper position when a tree node is selected.'''

    trace = False ; verbose = False
    c = self.c ; p = c.currentPosition()
    w = self.treeWidget 

    if self.selecting:
        if trace: g.trace('already selecting',p and p.headString())
        return
    if self.redrawing:
        if trace: g.trace('already drawing',p and p.headString())
        return

    item = w.currentItem()
    p = self.item2position(item)

    if p:
        if trace: g.trace(p and p.headString())
        c.frame.tree.select(p)
            # The crucial hook. Calls before/AfterSelectHint.
    else: # An error.
        g.trace('no p for item: %s' % item,g.callers(4))

    c.outerUpdate()
#@nonl
#@-node:ekr.20081121105001.162:onTreeSelect
#@+node:ekr.20081121105001.442:setCurrentItem
def setCurrentItem (self):

    trace = False ; verbose = False
    c = self.c ; p = c.currentPosition()
    w = self.treeWidget

    if self.expanding:
        if trace: g.trace('already expanding')
        return None
    if self.selecting:
        if trace: g.trace('already selecting')
        return None
    if not p:
        if trace: g.trace('** no p')
        return None

    item = self.position2item(p)

    if item:
        if trace: g.trace(p and p.headString())
    else:
        # This is not necessarily an error.
        # We often attempt to select an item before redrawing it.
        if trace: g.trace('** no item for',p)
        return None

    item2 = w.currentItem()
    if item != item2:
        if trace and verbose: g.trace('item',item,'old item',item2)
        self.selecting = True
        try:
            w.setCurrentItem(item)
        finally:
            self.selecting = False
    return item
#@-node:ekr.20081121105001.442:setCurrentItem
#@+node:ekr.20081121105001.446:tree.OnPopup & allies
def OnPopup (self,p,event):

    """Handle right-clicks in the outline.

    This is *not* an event handler: it is called from other event handlers."""

    # Note: "headrclick" hooks handled by vnode callback routine.

    if event != None:
        c = self.c
        c.setLog()

        if not g.doHook("create-popup-menu",c=c,p=p,v=p,event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items",c=c,p=p,v=p,event=event):
            self.enablePopupMenuItems(p,event)
        if not g.doHook("show-popup-menu",c=c,p=p,v=p,event=event):
            self.showPopupMenu(event)

    return "break"
#@+node:ekr.20081121105001.447:OnPopupFocusLost
@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the <FocusOut> event and explicitly unpost.  In order to process the <FocusOut> event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Qt tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):

    # self.popupMenu.unpost()
    pass
#@-node:ekr.20081121105001.447:OnPopupFocusLost
#@+node:ekr.20081121105001.448:createPopupMenu
def createPopupMenu (self,event):

    c = self.c ; frame = c.frame

    # self.popupMenu = menu = Qt.Menu(g.app.root, tearoff=0)

    # # Add the Open With entries if they exist.
    # if g.app.openWithTable:
        # frame.menu.createOpenWithMenuItemsFromTable(menu,g.app.openWithTable)
        # table = (("-",None,None),)
        # frame.menu.createMenuEntries(menu,table)

    << Create the menu table >>

    # # New in 4.4.  There is no need for a dontBind argument because
    # # Bindings from tables are ignored.
    # frame.menu.createMenuEntries(menu,table)
#@+node:ekr.20081121105001.449:<< Create the menu table >>
# table = (
    # ("&Read @file Nodes",c.readAtFileNodes),
    # ("&Write @file Nodes",c.fileCommands.writeAtFileNodes),
    # ("-",None),
    # ("&Tangle",c.tangle),
    # ("&Untangle",c.untangle),
    # ("-",None),
    # ("Toggle Angle &Brackets",c.toggleAngleBrackets),
    # ("-",None),
    # ("Cut Node",c.cutOutline),
    # ("Copy Node",c.copyOutline),
    # ("&Paste Node",c.pasteOutline),
    # ("&Delete Node",c.deleteOutline),
    # ("-",None),
    # ("&Insert Node",c.insertHeadline),
    # ("&Clone Node",c.clone),
    # ("Sort C&hildren",c.sortChildren),
    # ("&Sort Siblings",c.sortSiblings),
    # ("-",None),
    # ("Contract Parent",c.contractParent),
# )
#@-node:ekr.20081121105001.449:<< Create the menu table >>
#@-node:ekr.20081121105001.448:createPopupMenu
#@+node:ekr.20081121105001.450:enablePopupMenuItems
def enablePopupMenuItems (self,v,event):

    """Enable and disable items in the popup menu."""

    c = self.c 

    # menu = self.popupMenu

    << set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
    # isAtFile = g.choose(isAtFile,1,0)
    # isAtRoot = g.choose(isAtRoot,1,0)
    # canContract = v.parent() != None
    # canContract = g.choose(canContract,1,0)

    # enable = self.frame.menu.enableMenu

    # for name in ("Read @file Nodes", "Write @file Nodes"):
        # enable(menu,name,isAtFile)
    # for name in ("Tangle", "Untangle"):
        # enable(menu,name,isAtRoot)

    # enable(menu,"Cut Node",c.canCutOutline())
    # enable(menu,"Delete Node",c.canDeleteHeadline())
    # enable(menu,"Paste Node",c.canPasteOutline())
    # enable(menu,"Sort Children",c.canSortChildren())
    # enable(menu,"Sort Siblings",c.canSortSiblings())
    # enable(menu,"Contract Parent",c.canContractParent())
#@+node:ekr.20081121105001.451:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
# isAtFile = False
# isAtRoot = False

# for v2 in v.self_and_subtree_iter():
    # if isAtFile and isAtRoot:
        # break
    # if (v2.isAtFileNode() or
        # v2.isAtNorefFileNode() or
        # v2.isAtAsisFileNode() or
        # v2.isAtNoSentFileNode()
    # ):
        # isAtFile = True

    # isRoot,junk = g.is_special(v2.bodyString(),0,"@root")
    # if isRoot:
        # isAtRoot = True
#@-node:ekr.20081121105001.451:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
#@-node:ekr.20081121105001.450:enablePopupMenuItems
#@+node:ekr.20081121105001.452:showPopupMenu
def showPopupMenu (self,event):

    """Show a popup menu."""

    # c = self.c ; menu = self.popupMenu

    # g.app.gui.postPopupMenu(c, menu, event.x_root, event.y_root)

    # self.popupMenu = None

    # # Set the focus immediately so we know when we lose it.
    # #c.widgetWantsFocus(menu)
#@-node:ekr.20081121105001.452:showPopupMenu
#@-node:ekr.20081121105001.446:tree.OnPopup & allies
#@-node:ekr.20081121105001.432:Event handlers... (qtTree)
#@+node:ekr.20081121105001.453:Focus (qtTree)
def getFocus(self):

    # g.trace('leoQtTree',self.widget,g.callers(4))
    return g.app.gui.get_focus()

findFocus = getFocus

def hasFocus (self):

    val = self.treeWidget == g.app.gui.get_focus(self.c)
    # g.trace('leoQtTree returns',val,self.widget,g.callers(4))
    return val

def setFocus (self):

    # g.trace('leoQtTree',self.treeWidget,g.callers(4))
    g.app.gui.set_focus(self.c,self.treeWidget)
#@-node:ekr.20081121105001.453:Focus (qtTree)
#@+node:ekr.20081209103009.11:oops
def oops(self,s):
    if not g.app.unitTesting:
        g.trace('*** %s, %s' % (s,g.callers(4)))
#@-node:ekr.20081209103009.11:oops
#@+node:ekr.20081121105001.454:Selecting & editing... (qtTree)
#@+node:ekr.20081121105001.456:afterSelectHint
def afterSelectHint (self,p,old_p):

    trace = False
    c = self.c

    self.selecting = False

    if not p:
        return g.trace('Error: no p')
    if p != c.currentPosition():
        return g.trace('Error: p is not c.currentPosition()')
    if self.redrawing:
        return g.trace('Error: already redrawing')

    if trace: g.trace(p and p.headString(),g.callers(4))

    c.outerUpdate() # Bring the tree up to date.

    # setCurrentItem sets & clears .selecting ivar
    self.setCurrentItem()
#@-node:ekr.20081121105001.456:afterSelectHint
#@+node:ekr.20081121105001.455:beforeSelectHint
def beforeSelectHint (self,p,old_p):

    trace = False

    if self.selecting:
        return g.trace('*** Error: already selecting',g.callers(4))
    if self.redrawing:
        if trace: g.trace('already redrawing')
        return

    if trace: g.trace(p and p.headString())

    # Disable onTextChanged.
    self.selecting = True
#@nonl
#@-node:ekr.20081121105001.455:beforeSelectHint
#@+node:ekr.20081121105001.160:edit_widget
def edit_widget (self,p):

    """Returns the Qt.Edit widget for position p."""

    trace = False
    c = self.c ; treeWidget = self.treeWidget
    item = self.position2item(p)
    if item:
        e = treeWidget.itemWidget(item,0) # A QLineEdit
        if e:
            # Create a wrapper widget for Leo's core.
            w = leoQtHeadlineWidget(widget=e,name='head',c=c)
            if trace: g.trace(w,p and p.headString())
            return w
        else:
            # This is not an error
            if trace: g.trace('no e for %s' % (p),g.callers(4))
            return None
    else:
        if trace: g.trace('no item for %s' % (p),g.callers(4))
        return None
#@nonl
#@-node:ekr.20081121105001.160:edit_widget
#@+node:ekr.20081121105001.156:editLabel (override)
def editLabel (self,p,selectAll=False,selection=None):

    """Start editing p's headline."""

    trace = False ; verbose = False
    c = self.c ; w = self.treeWidget

    if self.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if trace: g.trace('***',p and p.headString(),g.callers(4))

    c.outerUpdate()
        # Do any scheduled redraw.
        # This won't do anything in the new redraw scheme.

    item = self.position2item(p)

    if item:
        w.setCurrentItem(item) # Must do this first.
        w.editItem(item)
            # Generates focus-in event that tree doesn't report.
        e = w.itemWidget(item,0) # A QLineEdit
        if e:
            s = e.text() ; len_s = len(s)
            if selection:
                i,j,ins = selection
                start,n = i,abs(i-j)
                    # Not right for backward searches.
            elif selectAll: start,n,ins = 0,len_s,len_s
            else:           start,n,ins = len_s,0,len_s
            e.setObjectName('headline')
            e.setSelection(start,n)
            # e.setCursorPosition(ins) # Does not work.
            e.setFocus()
        else: self.oops('no edit widget')
    else:
        e = None
        self.oops('no item: %s' % p)

    # A nice hack: just set the focus request.
    if e: c.requestedFocusWidget = e
#@-node:ekr.20081121105001.156:editLabel (override)
#@+node:ekr.20081124113700.11:editPosition
def editPosition(self):

    c = self.c ; p = c.currentPosition()
    ew = self.edit_widget(p)
    return ew and p or None
#@-node:ekr.20081124113700.11:editPosition
#@+node:ekr.20090114072115.12:endEditLabel
def endEditLabel (self):

    '''Override leoTree.endEditLabel.

    End editing of the presently-selected headline.'''

    c = self.c ; p = c.currentPosition()

    ew = self.edit_widget(p)
    e = ew and ew.widget

    if e:
        s = e.text()
        if s != p.headString():
            self.onHeadChanged(p)
#@-node:ekr.20090114072115.12:endEditLabel
#@+node:ekr.20081121105001.163:onHeadChanged (qtTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.'''

    trace = False ; verbose = True
    c = self.c ; u = c.undoer
    ew = self.edit_widget(p)
    if ew: e = ew.widget
    item = self.position2item(p)

    w = g.app.gui.get_focus()

    # These are not errors: onItemChanged may
    # have been called first.
    if trace and verbose:
        if not e:  g.trace('No e',g.callers(4))
        if e != w: g.trace('e != w',e,w,g.callers(4))
        if not p:  g.trace('No p')

    if e and e == w and item and p:
        s = e.text() ; len_s = len(s)
        s = g.app.gui.toUnicode(s)
        oldHead = p.headString()
        changed = s != oldHead
        if trace: g.trace('changed',changed,repr(s),g.callers(4))
        if changed:
            p.initHeadString(s)
            item.setText(0,s) # Required to avoid full redraw.
            undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
            if not c.changed: c.setChanged(True)
            # New in Leo 4.4.5: we must recolor the body because
            # the headline may contain directives.
            c.frame.body.recolor(p,incremental=True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)

    # This is a crucial shortcut.
    if g.unitTesting: return

    self.redraw_after_head_changed()

    if self.stayInTree:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()
    c.outerUpdate()
#@-node:ekr.20081121105001.163:onHeadChanged (qtTree)
#@+node:ekr.20081121105001.457:setHeadline (qtTree)
def setHeadline (self,p,s):

    '''Set the actual text of the headline widget.

    This is called from unit tests to change the text before redrawing.'''

    p.setHeadString(s)
    w = self.edit_widget(p)
    if w:
        w.setAllText(s)
#@-node:ekr.20081121105001.457:setHeadline (qtTree)
#@+node:ekr.20081214061352.10:traceSelect
def traceSelect (self):

    if 0:
        g.trace(self.selecting,g.callers(5))
#@-node:ekr.20081214061352.10:traceSelect
#@-node:ekr.20081121105001.454:Selecting & editing... (qtTree)
#@-node:ekr.20090124174652.101:class leoQtTree (leoTree)
#@+node:ekr.20090125123037.1:class editWidgetSafePointer
# A very bad idea.
# The proper thing to do is not to cache QLineEdit headline widgets.
# This can be done by overriding baseEditCommands.editWidget.

class editWidgetSafePointer (QtCore.QObject):

    '''A class to protect references to edit widgets.'''

    def __init__ (self,item,e,w):

        # g.trace('editWidgetSafePointer.__init__',w)
        self._item = item
        self._e = e
        self._w = w

    def __nonzero__ (self):

        item,e,w = self._item,self._e,self._w
        item2 = w.currentItem()
        e2 = w.itemWidget(item,0)
        val = item2 == item and e2 and e2 == e
        return g.choose(val,1,0)

    def __getattr__ (self,name):
        return getattr(self._e,name)

    def __setattr__ (self,name,val):
        if name in ('_item','_e','_w'): 
            QtCore.QObject.__setattr__(self, name, val)
        else:
            setattr(self._e,name,val)

#@-node:ekr.20090125123037.1:class editWidgetSafePointer
#@-node:ekr.20081208155215.12:Unused
#@-all
#@nonl
#@-node:ekr.20081121105001.147:@thin qtNotes.txt
#@-leo
