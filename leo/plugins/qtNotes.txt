#@+leo-ver=4-thin
#@+node:ekr.20081121105001.147:@thin qtNotes.txt
#@+all
#@+node:ekr.20081121105001.148: qt To do
@nocolor-node

First:

- Make sure cut/paste always works.
- Get rClick plugin working.
#@+node:ekr.20081215074704.13:Bugs
* Disabling searches of body pane can cause hard crashes.
    - initInteractiveCommands expects c.edit_widget(p)to exist.
#@nonl
#@+node:ekr.20081215074704.14:** Fix flash characters problems
Ask Qt people.
#@nonl
#@-node:ekr.20081215074704.14:** Fix flash characters problems
#@+node:ekr.20081215074704.15:** Cut/paste work erratically
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/58af715355227ec

I'm observing the following strange behavior when copy and paste text
using the qt plugin. The behavior is erratic and I cannot reproduce it
systematically so I'll try to give you a general picture.

When I select and copy text in the body pane of a node SOMETIMES I see
the following message in the console

QClipboard::setData: Cannot set X11 selection owner for CLIPBOARD

When I try to paste the copied text:
- sometimes it works fine
- sometimes nothing happens (and the Paste entry of the body pane
context menu is disabled)
- sometimes the pasted text is not the last copied text (i.e. some
copy operations fail)

I know this is confusing and I've done my best trying to get a pattern
for these facts but with no luck.

Vicent 
#@nonl
#@-node:ekr.20081215074704.15:** Cut/paste work erratically
#@+node:ekr.20090123073723.11:Fix image plugin with qt gui
@nocolor-node

After the qt-plugin merge (rev 1251 ), the image plugin no longer works. I
couldn't find any mention of gsimage in the diff.

 # Erase image if it was previously displayed
             a = g.app ; c = keywords.get("c")

-            if a.gsimage:
+            if getattr(a, 'gsimage', None):
                 try:
                     c.frame.body.bodyCtrl.delete(a.gsimage)
                 except:
#@-node:ekr.20090123073723.11:Fix image plugin with qt gui
#@+node:ekr.20090123073723.12:Fix php section coloring
http://groups.google.com/group/leo-editor/browse_thread/thread/41870d58718b7b7a#
#@nonl
#@-node:ekr.20090123073723.12:Fix php section coloring
#@+node:ekr.20081215074704.16:Mark finds doesn't work in Qt gui plugin
http://groups.google.com/group/leo-editor/browse_thread/thread/b2af78fbb36d3590
#@nonl
#@-node:ekr.20081215074704.16:Mark finds doesn't work in Qt gui plugin
#@+node:ekr.20081124094918.1:Fix problems with scim
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/59c1e5d6acaf4de0

I've some more information about the problems with accent previously
reported:
- I can confirm that they are caused by the interaction scim+leo (with
and without the qt plugin). If scim is not started leo works fine. If
scim is running the problems appear and are slightly different with
and without the qt plugin. The workaround is obvious: don't use leo
and scim at the same time :-)
- accents are not working in the qt plugin when scintilla is used. If
qt-use-scintilla=False I can write this:

àáä (the same for the rest of vowels)

but if qt-use-scintilla=True when I enter the same sequence in the
keyboard I get:

`aaa (the same for the rest of vowels)

- the problem with the ñ character (reported previously too) is only
present in the qt plugin (both with and without scintilla)
#@-node:ekr.20081124094918.1:Fix problems with scim
#@+node:ekr.20081215074704.18:Finish qt gui delete_range method
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/51edf3b44d6a587e

revno: 1259.1.10
revision-id: terry_n_brown@yahoo.com-20081130181632-ci0ioaksewdvc257

I added code so that this no longer derails the initialization process,
i.e. just catch the exception and continue.  I don't know what's wrong
except I first noticed it after a tkinter update from Ubuntu.  I
think.  Anyway, that's my story :)

When I added the "clean recent files" menu option long before this
traceback showed up I had a heap of trouble deleting just the file
entries on the recent files menu.  It was originally hardwired that the
menu have a "Clear list" item, and then the file entries, but I wanted
to make it get it's command entries from @menu @settings and add the
files afterward and that was a lot of fiddling.  I.e. originally it
deleted everything and added the "Clear list" item before rebuilding
the file list, now it either tries to delete only the file entries, or
stores the entries before the files (from @menu) and adds them back
before the files each time, I forget which finally worked.

What's my point?  It would be nice if delete_range "just worked".  It's
a 'pass' in qt, and I would guess recent files is the only thing in the
entire code base that uses it.

The menu tree seems to me to be "write only", i.e. not readable, at
least from the Leo API, of course you can walk it in a gui specific
way.  Not necessarily a problem, but would be nice if it was more
robustly dynamic.  Or maybe I'm missing something, but I've only seen
functions which find a menu based on knowing it exists before hand.
#@nonl
#@-node:ekr.20081215074704.18:Finish qt gui delete_range method
#@-node:ekr.20081215074704.13:Bugs
#@+node:ekr.20081215074704.19:Features 5
#@+node:ekr.20081215162017.4:Allow coloring of script buttons
#@-node:ekr.20081215162017.4:Allow coloring of script buttons
#@+node:ekr.20081215162017.5:Support multiple body editors
#@-node:ekr.20081215162017.5:Support multiple body editors
#@+node:ekr.20081215074704.20:Change background color of body pane depending on focus
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/1cce885a697d0236/5aea5d0587b47b92?lnk=gst&q=command+and+insert#5aea5d0587b47b92

Set focus in/out events.
#@nonl
#@-node:ekr.20081215074704.20:Change background color of body pane depending on focus
#@+node:ekr.20081215074704.21:Add drag and drop
#@-node:ekr.20081215074704.21:Add drag and drop
#@+node:ekr.20081121105001.151:Clean up settings
- Can style sheets really do the job?

- Remove old-style Leo settings?

- Add stylesheets for dialogs.
    - Set font for dummy widget in style sheet, then copy that font.
#@+node:ekr.20081121105001.150:QScintilla stuff
- Check event handling with QScintilla.
- Experiment with sending <shift-tab> directly to QScintilla.
- Call setLexer(0) for nocolor nodes.
- Add settings for syntax coloring.
- Make Scintilla handle Leo markup.
- Install new Qt version and play with QScintilla.
    From QScintilla change log:
    2008/10/12 14:32:05  phil
    QsciScintilla::setSelection() is now implemented using SCI_SETSEL so that the
    carat can be left at either the start or the end of the selection.
    Exposed QsciScintilla::positionFromLineIndex() and
    QsciScintilla::lineIndexFromPosition().
    - Fix problem with accented characters: see child node for notes.
#@nonl
#@-node:ekr.20081121105001.150:QScintilla stuff
#@-node:ekr.20081121105001.151:Clean up settings
#@-node:ekr.20081215074704.19:Features 5
#@-node:ekr.20081121105001.148: qt To do
#@+node:ekr.20081121105001.185:Scripts
#@+node:ekr.20081121105001.186:Script to display Qt font database
import PyQt4.QtGui as QtGui

db = QtGui.QFontDatabase()
for family in db.families():
    print family
    for style in db.styles(family):
        print '\t',style,db.smoothSizes(family,style)
#@-node:ekr.20081121105001.186:Script to display Qt font database
#@+node:ekr.20081121105001.187:dump guiBindNamesInverseDict
print g.dictToString(c.k.guiBindNamesInverseDict)

@
   BackSpace: 'BackSpace'
       Begin: 'Begin'
       Break: 'Break'
   Caps_Lock: 'Caps_Lock'
       Clear: 'Clear'
      Delete: 'Delete'
        Down: 'Down'
         End: 'End'
      Escape: 'Escape'
          F1: 'F1'
         F10: 'F10'
         F11: 'F11'
         F12: 'F12'
          F2: 'F2'
          F3: 'F3'
          F4: 'F4'
          F5: 'F5'
          F6: 'F6'
          F7: 'F7'
          F8: 'F8'
          F9: 'F9'
        Home: 'Home'
        Left: 'Left'
    Linefeed: 'Linefeed'
        Next: 'Next'
    Num_Lock: 'Num_Lock'
       Prior: 'Prior'
      Return: 'Return'
       Right: 'Right'
         Tab: 'Tab'
          Up: 'Up'
   ampersand: '&'
 asciicircum: '^'
  asciitilde: '~'
    asterisk: '*'
          at: '@'
   backslash: '\\'
         bar: '|'
   braceleft: '{'
  braceright: '}'
 bracketleft: '['
bracketright: ']'
       colon: ':'
       comma: ','
      dollar: '$'
       equal: '='
      exclam: '!'
     greater: '>'
        less: '<'
       minus: '-'
  numbersign: '#'
   parenleft: '('
  parenright: ')'
     percent: '%'
      period: '.'
        plus: '+'
    question: '?'
    quotedbl: '"'
   quoteleft: '`'
  quoteright: "'"
   semicolon: ';'
       slash: '/'
       space: ' '
  underscore: '_'
#@nonl
#@-node:ekr.20081121105001.187:dump guiBindNamesInverseDict
#@-node:ekr.20081121105001.185:Scripts
#@+node:ekr.20090124101344.1:Recent
#@+node:ekr.20090123073723.13:Set focus in window activate events
#@+node:ekr.20081121105001.168:eventFilter
def eventFilter(self, obj, event):

    trace = False ; verbose = True
    traceFocus = False and not g.unitTesting
    c = self.c ; k = c.k
    eventType = event.type()
    ev = QtCore.QEvent
    kinds = [ev.ShortcutOverride,ev.KeyPress,ev.KeyRelease]
    if traceFocus:
        table = (
            (ev.FocusIn,        'focus-in '),
            (ev.FocusOut,       'focus-out'),
            (ev.WindowActivate, 'activate '))
        for evKind,kind in table:
            if eventType == evKind:
                g.trace('%s %s %s' % (
                    (kind,id(obj),
                    # event.reason(),
                    g.app.gui.widget_name(obj) or obj)))
        # else: g.trace('unknown kind: %s' % eventType)

    if eventType == ev.WindowActivate:
        g.app.gui.onActivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
        # g.trace(g.app.gui.get_focus(c))
    elif eventType in kinds:
        tkKey,ch,ignore = self.toTkKey(event)
        aList = c.k.masterGuiBindingsDict.get('<%s>' %tkKey,[])

        if ignore:
            override = False
        elif self.isSpecialOverride(tkKey,ch):
            override = True
        elif k.inState():
            override = not ignore # allow all keystrokes.
        elif safe_mode:
            override = len(aList) > 0 and not self.isDangerous(tkKey,ch)
        else:
            override = len(aList) > 0
    else:
        override = False ; tkKey = '<no key>'

    # A hack. QLineEdit generates ev.KeyRelease only.
    if eventType in (ev.KeyPress,ev.KeyRelease):
        p = c.currentPosition()
        isEditWidget = obj == c.frame.tree.edit_widget(p)
        keyIsActive = g.choose(
            isEditWidget,
            eventType == ev.KeyRelease,
            eventType == ev.KeyPress)
    else:
        keyIsActive = False

    if keyIsActive:
        if override:
            w = self.w # Pass the wrapper class, not the wrapped widget.
            stroke = self.toStroke(tkKey,ch)
            leoEvent = leoKeyEvent(event,c,w,ch) # ch was stroke
            ret = k.masterKeyHandler(leoEvent,stroke=stroke)
            c.outerUpdate()
        else:
            if trace: g.trace(self.tag,'unbound',tkKey)

    if trace: self.traceEvent(obj,event,tkKey,override)

    return override
#@-node:ekr.20081121105001.168:eventFilter
#@+node:ekr.20090123150451.11:onActivateEvent (qtGui)
def onActivateEvent (self,event,c,obj,tag):

    '''Put the focus in the body pane when the Leo window is
    activated, say as the result of an Alt-tab or click.'''

    # This is called several times for each window activation.
    # We only need to set the focus once.

    if c.exists and tag == 'body':

        # g.trace('Activate',tag,g.callers(5))

        # Putting focus in the body is clearest.
        c.bodyWantsFocus()
        c.outerUpdate()
#@-node:ekr.20090123150451.11:onActivateEvent (qtGui)
#@+node:ekr.20081121105001.330:createTab
def createTab (self,tabName,widget=None,wrap='none'):
    """ Create a new tab in tab widget

    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """
    c = self.c ; w = self.tabWidget

    if widget is None:
        contents = QtGui.QTextBrowser()
        contents.setWordWrapMode(QtGui.QTextOption.NoWrap)
        self.logDict[tabName] = contents
        if tabName == 'Log': self.logCtrl = contents
        theFilter = leoQtEventFilter(c,w=contents,tag='tab')
        contents.installEventFilter(theFilter)
    else:
        contents = widget

    self.contentsDict[tabName] = contents
    w.addTab(contents,tabName)
    return contents

#@-node:ekr.20081121105001.330:createTab
#@-node:ekr.20090123073723.13:Set focus in window activate events
#@+node:ekr.20090123181335.45:** BUG: cloned headlines not updated properly
#@+node:ekr.20081121105001.163:onHeadChanged (qtTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.'''

    trace = False ; verbose = True
    c = self.c ; u = c.undoer
    ew = self.edit_widget(p)
    if ew: e = ew.widget
    item = self.position2item(p)

    w = g.app.gui.get_focus()

    # These are not errors: onItemChanged may
    # have been called first.
    if trace and verbose:
        if not e:  g.trace('No e',g.callers(4))
        if e != w: g.trace('e != w',e,w,g.callers(4))
        if not p:  g.trace('No p')

    if e and e == w and item and p:
        s = e.text() ; len_s = len(s)
        s = g.app.gui.toUnicode(s)
        oldHead = p.headString()
        changed = s != oldHead
        if trace: g.trace('changed',changed,repr(s),g.callers(4))
        if changed:
            p.initHeadString(s)
            item.setText(0,s) # Required to avoid full redraw.
            undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
            if not c.changed: c.setChanged(True)
            # New in Leo 4.4.5: we must recolor the body because
            # the headline may contain directives.
            c.frame.body.recolor(p,incremental=True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)

    # This is a crucial shortcut.
    if g.unitTesting: return

    self.redraw_after_head_changed()

    if self.stayInTree:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()
    c.outerUpdate()
#@-node:ekr.20081121105001.163:onHeadChanged (qtTree)
#@+node:ekr.20090109110752.19:redraw_after_head_changed
def redraw_after_head_changed (self):

    # g.trace(g.callers(4))

    c = self.c ; p = c.currentPosition()

    if p:
        h = p.headString()
        for item in self.tnode2items(p.v.t):
            if self.isValidItem(item):
                item.setText(0,h)

    #### self.full_redraw()
#@nonl
#@-node:ekr.20090109110752.19:redraw_after_head_changed
#@-node:ekr.20090123181335.45:** BUG: cloned headlines not updated properly
#@-node:ekr.20090124101344.1:Recent
#@+node:ekr.20081208155215.12:Unused
#@+node:ekr.20090125123037.1:class editWidgetSafePointer
# A very bad idea.
# The proper thing to do is not to cache QLineEdit headline widgets.
# This can be done by overriding baseEditCommands.editWidget.

class editWidgetSafePointer (QtCore.QObject):

    '''A class to protect references to edit widgets.'''

    def __init__ (self,item,e,w):

        # g.trace('editWidgetSafePointer.__init__',w)
        self._item = item
        self._e = e
        self._w = w

    def __nonzero__ (self):

        item,e,w = self._item,self._e,self._w
        item2 = w.currentItem()
        e2 = w.itemWidget(item,0)
        val = item2 == item and e2 and e2 == e
        return g.choose(val,1,0)

    def __getattr__ (self,name):
        return getattr(self._e,name)

    def __setattr__ (self,name,val):
        if name in ('_item','_e','_w'): 
            QtCore.QObject.__setattr__(self, name, val)
        else:
            setattr(self._e,name,val)

#@-node:ekr.20090125123037.1:class editWidgetSafePointer
#@+node:ekr.20090126093408.789:OLDwxLeoTree
class OLDwxLeoTree (leoFrame.leoTree):

    @others
#@nonl
#@+node:ekr.20090126093408.811:assignIcon
def assignIcon (self,p):

    val = p.v.computeIcon()
    assert(0 <= val <= 15)
    p.v.iconVal = val
    return val
#@-node:ekr.20090126093408.811:assignIcon
#@+node:ekr.20090126093408.801:cleverRedraw & helpers
initial_draw = True

def cleverRedraw (self):

    # g.trace('initial_redraw',self.initial_draw)

    if self.initial_draw:
        self.initial_draw = False
        self.partialRedraw()
    else:
        c = self.c ; tree = self.treeCtrl
        root_p = c.rootPosition()
        root_id = tree.GetRootItem()
        child_id,cookie = tree.GetFirstChild(root_id)
        self.update_siblings(root_id,child_id,root_p)
#@nonl
#@+node:ekr.20090126093408.802:insertTreeAfter
def insertTreeAfter (self,parent_id,prev_id,p):

    tree = self.treeCtrl
    ins_id = self.insert_node(parent_id,prev_id,p)
    # g.trace(p.headString())
    child = p.firstChild()
    while child:
        # Create the entire tree, regardless of expansion state.
        self.redraw_subtree(ins_id,child)
        child.moveToNext()
    return ins_id
#@-node:ekr.20090126093408.802:insertTreeAfter
#@+node:ekr.20090126093408.803:insert_node
def insert_node(self,parent_id,prev_id,p):

    tree = self.treeCtrl
    data = wx.TreeItemData(p.copy())
    image = self.assignIcon(p)

    node_id = tree.InsertItem(
        parent_id,
        prev_id,
        text=p.headString(),
        image=image,
        #selImage=image,
        data=data)

    # tree.SetItemFont(id,self.defaultFont)

    self.setEditWidget(p,node_id)
    assert (p == tree.GetItemData(node_id).GetData())

    self.expandAndSelect(node_id,p)

    return node_id
#@-node:ekr.20090126093408.803:insert_node
#@+node:ekr.20090126093408.804:update_node
def update_node(self,node_id,p):

    tree = self.treeCtrl

    # data = wx.TreeItemData(p.copy())
    # id = tree.AppendItem(
        # parent_id,
        # text=p.headString(),
        # image=image,
        # #selImage=image,
        # data=data)

    # update the data.
    new_h = p.headString() ; old_h = tree.GetItemText(node_id)
    if old_h != new_h:
        g.trace('old:',old_h,'new:',new_h)
        tree.SetItemText(node_id,new_h)
    image = self.assignIcon(p)
    if image != tree.GetItemImage(node_id):
        tree.SetItemImage(node_id,image)
    data = wx.TreeItemData(p.copy())
    tree.SetItemData(node_id,data)

    self.setEditWidget(p,node_id)
    assert (p == tree.GetItemData(node_id).GetData())
    return node_id
#@-node:ekr.20090126093408.804:update_node
#@+node:ekr.20090126093408.805:update_siblings
def update_siblings(self,parent_id,node_id,p):

    tree = self.treeCtrl ; trace = False
    first_id,first_p = node_id,p.copy()
    # Warning: we will visit each position only once even if the tree changes.
    for p in p.self_and_siblings_iter(copy=True):
        h = p.headString()
        if node_id.IsOk():
            data = tree.GetItemData(node_id)
            node_id2,p2 = data.GetId(),data.GetData()
            h2 = p2.headString()
            assert node_id == node_id2,'expected id: %s, got %s' % (node_id,node_id2)
            if p2 == p:
                # trace and g.trace('match at:',h,'next:',p.next() and p.next().headString())
                self.update_node(node_id,p)
                self.expandAndSelect(node_id,p)
                # Recursively update.
                if p.hasChildren():
                    child_id,cookie = tree.GetFirstChild(node_id)
                    self.update_siblings(node_id,child_id,p.firstChild())
                node_id = tree.GetNextSibling(node_id)
            elif p.hasNext() and p.next() == p2:
                # There is a node between p (in the new tree) and p2 (in the old tree).
                # Insert this node (before p2), then stay at (node_id == node_id2)
                prev_id = tree.GetPrevSibling(node_id)
                ins_id = self.insertTreeAfter(parent_id,prev_id,p.copy())
                trace and g.trace('at:',h,'insert before:',h2)
                trace and g.trace('prev id',id(node_id),'ins id',id(ins_id))
                # We will revisit node_id2 when we visit p.next()
                # But this is our last chance to visit ins_id.
                self.expandAndSelect(ins_id,p)
                node_id = tree.GetNextSibling(ins_id)
            elif p2.hasNext() and p2.next() == p.next():
                # The node p (in the new tree) is p2.next (in the old tree)
                # Delete p2 from the tree, and stay at node_id (for a later update)
                trace and g.trace('at:',h,'delete',h2)
                next_id = tree.GetNextSibling(node_id)
                tree.Delete(node_id)
                node_id = next_id
                self.expandAndSelect(node_id,p)
            else:
                trace and g.trace('*** mismatch at:',h,'next:',h2)
                prev_id = tree.GetPrevSibling(node_id)
                tree.Delete(node_id)
                ins_id = self.insertTreeAfter(parent_id,prev_id,p.copy())
                node_id = tree.GetNextSibling(ins_id)
        else:
            last_p = first_p.copy()
            while last_p.hasNext():
                last_p.moveToNext()
            prev_id = tree.GetLastChild(parent_id)
            trace and g.trace('*** insert at end after',last_p.headString())
            ins_id = self.insertTreeAfter(parent_id,prev_id,last_p)
            self.expandAndSelect(ins_id,p)
    while node_id.IsOk():
        trace and g.trace('delete at end')
        next_id = tree.GetNextSibling(node_id)
        tree.Delete(node_id)
        node_id = next_id
#@-node:ekr.20090126093408.805:update_siblings
#@+node:ekr.20090126093408.806:expandAndSelect
# This should be called after drawing so the +- box is drawn properly.

def expandAndSelect (self,node_id,p,force=False):

    c = self.c ; tree = self.treeCtrl

    # The calls to tree.Expand and tree.Collapse *will* generate events,
    # This is the reason the event handlers must be disabled while drawing.

    if p.isExpanded():  tree.Expand(node_id)
    else:               tree.Collapse(node_id)

    # Do this *after* drawing the children so as to ensure the +- box is drawn properly.
    if force:
        g.trace('force selection',p.headString())
        c.setCurrentPosition(p)
        tree.SelectItem(node_id) # Generates call to onTreeChanged.
    elif p == self.c.currentPosition():
        # g.trace('selecting',p.headString())
        tree.SelectItem(node_id) # Generates call to onTreeChanged.
#@-node:ekr.20090126093408.806:expandAndSelect
#@+node:ekr.20090126093408.807:redraw_subtree
def redraw_subtree(self,parent_id,p,trace=False):

    tree = self.treeCtrl
    node_id = self.redraw_node(parent_id,p)

    # Draw the entire tree, regardless of expansion state.
    child_p = p.firstChild()
    while child_p:
        self.redraw_subtree(node_id,child_p)
        child_p.moveToNext()

    # The calls to tree.Expand and tree.Collapse *will* generate events,
    # This is the reason the event handlers must be disabled while drawing.
    if p.isExpanded():
        tree.Expand(node_id)
    else:
        tree.Collapse(node_id)

    # Do this *after* drawing the children so as to ensure the +- box is drawn properly.
    if p == self.c.currentPosition():
        tree.SelectItem(node_id) # Generates call to onTreeChanged.
#@nonl
#@-node:ekr.20090126093408.807:redraw_subtree
#@-node:ekr.20090126093408.801:cleverRedraw & helpers
#@+node:ekr.20090126093408.839:do nothings
def headWidth (self,p=None,s=''): return 0

# Colors.
def setDisabledHeadlineColors (self,p):             pass
def setEditHeadlineColors (self,p):                 pass
def setUnselectedHeadlineColors (self,p):           pass

# State.
def setEditLabelState (self,p,selectAll=False):     pass
def setUnselectedLabelState (self,p):               pass

# Focus
def focus_get (self):   return self.FindFocus()
def setFocus (self):    self.treeCtrl.SetFocus()

SetFocus = setFocus

# For compatibility.
setNormalLabelState = setEditLabelState 
#@-node:ekr.20090126093408.839:do nothings
#@+node:ekr.20090126093408.814:Event handlers (wxTree)
# These event handlers work on both XP and Ubuntu.
#@+node:ekr.20090126093408.815:setSelectedLabelState
def setSelectedLabelState (self,p):

    c = self.c ; tree = self.treeCtrl
    if not p: return
    if self.frame.lockout: return

    tree_id = self.getIdDict(p)

    if tree_id and tree_id.IsOk():
        self.frame.lockout = True
        try:
            tree.SelectItem(tree_id)
            # tree.ScrollTo(tree_id)
        finally:
            self.frame.lockout = False
#@-node:ekr.20090126093408.815:setSelectedLabelState
#@+node:ekr.20090126093408.816:get_p
def get_p (self,event):

    '''Return the position associated with an event.
    Return None if the app or the frame has been killed.'''

    # Almost all event handlers call this method,
    # so this is a good place to make sure we still exist.
    if g.app.killed or self.c.frame.killed:
        # g.trace('killed')
        return None
    tree = self.treeCtrl
    id = event.GetItem()
    p = id.IsOk() and tree.GetItemData(id).GetData()

    if 0:
        g.trace(
            'lockout',self.frame.lockout,
            'drawing',self.drawing,
            'id.IsOk',id.IsOk(),
            'p',p and p.headString(),
            g.callers(9))

    if self.frame.lockout or self.drawing or not p:
        return None
    else:
        # g.trace(p.headString(),g.callers())
        return p
#@nonl
#@-node:ekr.20090126093408.816:get_p
#@+node:ekr.20090126093408.818:onHeadlineKey
# k.handleDefaultChar calls onHeadlineKey.
def onHeadlineKey (self,event):
    # g.trace(event)
    if g.app.killed or self.c.frame.killed: return
    if event and event.keysym:
        self.updateHead(event,event.widget)
#@-node:ekr.20090126093408.818:onHeadlineKey
#@+node:ekr.20090126093408.819:Clicks
#@+node:ekr.20090126093408.820:selectHelper
def selectHelper (self,event):

    '''Scroll so the presently selected node is in view.'''

    p = self.get_p(event)
    if not p: return

    # We can make this assertion because get_p has done the check.
    tree_id = event.GetItem()
    assert (tree_id.IsOk() and not self.frame.lockout)

    # g.trace(p.headString(),g.callers())
    tree = self.treeCtrl
    self.frame.lockout = True
    try:
        tree.SelectItem(tree_id)
        tree.ScrollTo(tree_id)
    finally:
        self.frame.lockout = False
#@-node:ekr.20090126093408.820:selectHelper
#@+node:ekr.20090126093408.821:Collapse...
def onTreeCollapsing(self,event):

    '''Handle a pre-collapse event due to a click in the +- box.'''

    p = self.get_p(event)
    if not p: return

    # p will be None while redrawing, so this is the outermost click event.
    # Set the selection before redrawing so the tree is drawn properly.
    c = self.c ; tree = self.treeCtrl
    c.selectPosition(p)
    p.contract()

def onTreeCollapsed(self,event):

    '''Handle a post-collapse event due to a click in the +- box.'''

    self.selectHelper(event)
#@-node:ekr.20090126093408.821:Collapse...
#@+node:ekr.20090126093408.822:Expand...
def onTreeExpanding (self,event):

    '''Handle a pre-expand event due to a click in the +- box.'''

    p = self.get_p(event)
    if not p: return

    # p will be None while redrawing, so this is the outermost click event.
    # Set the selection before redrawing so the tree is drawn properly.
    c = self.c ; tree = self.treeCtrl
    c.selectPosition(p)
    p.expand()

def onTreeExpanded (self,event):

    '''Handle a post-collapse event due to a click in the +- box.'''

    self.selectHelper(event)
#@-node:ekr.20090126093408.822:Expand...
#@+node:ekr.20090126093408.823:Change selection
def onTreeSelChanging(self,event):

    p = self.get_p(event)
    if not p: return

    # p will be None while redrawing, so this is the outermost click event.
    # Set the selection before redrawing so the tree is drawn properly.
    c = self.c
    c.selectPosition(p)

#@-node:ekr.20090126093408.823:Change selection
#@+node:ekr.20090126093408.824:onRightDown/Up
def onRightDown (self,event):

    if g.app.killed or self.c.frame.killed: return
    tree = self.treeCtrl
    pt = event.GetPosition()
    item, flags = tree.HitTest(pt)
    if item:
        tree.SelectItem(item)

def onRightUp (self,event):

    if g.app.killed or self.c.frame.killed: return
    tree = self.treeCtrl
    pt = event.GetPosition()
    item, flags = tree.HitTest(pt)
    if item:
        tree.EditLabel(item)
#@-node:ekr.20090126093408.824:onRightDown/Up
#@-node:ekr.20090126093408.819:Clicks
#@+node:ekr.20090126093408.825:Dragging
#@+node:ekr.20090126093408.826:onTreeBeginDrag
def onTreeBeginDrag(self,event):

    if g.app.killed or self.c.frame.killed: return

    g.trace() ; return

    if event.GetItem() != self.treeCtrl.GetRootItem():
        mDraggedItem = event.GetItem()
        event.Allow()
#@-node:ekr.20090126093408.826:onTreeBeginDrag
#@+node:ekr.20090126093408.827:onTreeEndDrag (NOT READY YET)
def onTreeEndDrag(self,event):

    if g.app.killed or self.c.frame.killed: return

    g.trace() ; return

    << Define onTreeEndDrag vars >>
    if  src == 0 or dst == 0:  return
    cookie = None
    if (
        # dst is the root
        not parent.IsOk()or
        # dst has visible children and dst isn't the first child.
        self.tree.ItemHasChildren(dst)and self.tree.IsExpanded(dst)and
        self.tree.GetFirstChild(dst,cookie) != src or
        # back(src)== dst(would otherwise be a do-nothing)
        self.tree.GetPrevSibling(src) == dst):
        << Insert src as the first child of dst >>
    else:
        # Not the root and no visible children.
        << Insert src after dst >>
    self.c.selectVnode(src_v)
    self.c.setChanged(True)
#@+node:ekr.20090126093408.828:<< Define onTreeEndDrag vars >>
assert(self.tree)
assert(self.c)

dst = event.GetItem()
src = mDraggedItem
mDraggedItem = 0

if not dst.IsOk() or not src.IsOk():
    return

src_v = self.tree.GetItemData(src)
if src_v == None:
    return

dst_v =self.tree.GetItemData(dst)
if dst_v == None:
    return

parent = self.tree.GetParent(dst)
parent_v = None
#@nonl
#@-node:ekr.20090126093408.828:<< Define onTreeEndDrag vars >>
#@+node:ekr.20090126093408.829:<< Insert src as the first child of dst >>
# Make sure the drag will be valid.
parent_v = self.tree.GetItemData(dst)

if not self.c.checkMoveWithParentWithWarning(src_v,parent_v,True):
    return

src_v.moveToNthChildOf(dst_v,0)
#@nonl
#@-node:ekr.20090126093408.829:<< Insert src as the first child of dst >>
#@+node:ekr.20090126093408.830:<< Insert src after dst >>
# Do nothing if dst is a child of src.
p = parent
while p.IsOk():
    if p == src:
        return
    p = self.tree.GetParent(p)

# Do nothing if dst is joined to src.
if dst_v.isJoinedTo(src_v):
    return

# Make sure the drag will be valid.
parent_v = self.tree.GetItemData(parent)
if not self.c.checkMoveWithParentWithWarning(src_v,parent_v,True):
    return

src_v.moveAfter(dst_v)
#@nonl
#@-node:ekr.20090126093408.830:<< Insert src after dst >>
#@-node:ekr.20090126093408.827:onTreeEndDrag (NOT READY YET)
#@-node:ekr.20090126093408.825:Dragging
#@+node:ekr.20090126093408.831:Editing labels
#@+node:ekr.20090126093408.832:onTreeBeginLabelEdit
# Editing is allowed only if this routine exists.

def onTreeBeginLabelEdit(self,event):

    if g.app.killed or self.c.frame.killed: return

    p = self.c.currentPosition()

    # Used by the base classes onHeadChanged method.
    self.revertHeadline = p.headString()
#@-node:ekr.20090126093408.832:onTreeBeginLabelEdit
#@+node:ekr.20090126093408.833:onTreeEndLabelEdit
# Editing will be allowed only if this routine exists.

def onTreeEndLabelEdit(self,event):

    if g.app.killed or self.c.frame.killed: return

    c = self.c ; tree = self.treeCtrl
    id = event.GetItem()
    s = event.GetLabel()
    p = self.treeCtrl.GetItemData(id).GetData()
    h = p.headString()

    # g.trace('old:',h,'new:',s)

    # Don't clear the headline by default.
    if s and s != h:
        # Call the base-class method.
        self.onHeadChanged (p,undoType='Typing',s=s)
#@nonl
#@-node:ekr.20090126093408.833:onTreeEndLabelEdit
#@-node:ekr.20090126093408.831:Editing labels
#@+node:ekr.20090126093408.820:selectHelper
def selectHelper (self,event):

    '''Scroll so the presently selected node is in view.'''

    p = self.get_p(event)
    if not p: return

    # We can make this assertion because get_p has done the check.
    tree_id = event.GetItem()
    assert (tree_id.IsOk() and not self.frame.lockout)

    # g.trace(p.headString(),g.callers())
    tree = self.treeCtrl
    self.frame.lockout = True
    try:
        tree.SelectItem(tree_id)
        tree.ScrollTo(tree_id)
    finally:
        self.frame.lockout = False
#@-node:ekr.20090126093408.820:selectHelper
#@-node:ekr.20090126093408.814:Event handlers (wxTree)
#@+node:ekr.20090126093408.817:onChar (wxTree)
standardTreeKeys = []
if sys.platform.startswith('win'):
    for mod in ('Alt+','Alt+Ctrl+','Ctrl+','',):
        for base in ('Right','Left','Up','Down'):
            standardTreeKeys.append(mod+base)
    for key in string.ascii_letters + string.digits + string.punctuation:
        standardTreeKeys.append(key)

def onChar (self,event):

    if g.app.killed or self.c.frame.killed: return

    c = self.c
    # Convert from tree event to key event.
    keyEvent = event.GetKeyEvent()
    keyEvent.leoWidget = self
    keysym = g.app.gui.eventKeysym(keyEvent)
    # if keysym: g.trace('keysym',repr(keysym))
    if keysym in self.standardTreeKeys:
        pass
        # g.trace('standard key',keysym)
    else:
        c.k.masterKeyHandler(keyEvent,stroke=keysym)
        # keyEvent.Skip(False) # Try to kill the default key handling.
#@-node:ekr.20090126093408.817:onChar (wxTree)
#@+node:ekr.20090126093408.809:partialRedraw & helpers
partialRedrawCount = 0

def partialRedraw (self):

    c = self.c ; p = c.rootPosition()
    tree = self.treeCtrl

    tree.DeleteAllItems()
    self.root_id = root_id = tree.AddRoot('Root Node')

    # g.trace('-' * 10,self.partialRedrawCount) ; self.partialRedrawCount += 1

    while p:
        self.redraw_partial_subtree(root_id,p,level=50)
        p.moveToNext()
#@nonl
#@+node:ekr.20090126093408.810:redraw_partial_subtree
def redraw_partial_subtree(self,parent_id,p,level,trace=False):

    c = self.c ; tree = self.treeCtrl
    node_id = self.redraw_node(parent_id,p)
    # g.trace('createChildren',createChildren,'p',p.headString())

    forceFull =  not sys.platform.startswith('win') # A terrible hack.

    if level > 0:
        # Create one more level of children.
        child_p = p.firstChild()
        while child_p:
            # Always draw the subtree so the child gets drawn.
            if forceFull:
                newLevel = level
            else:
                newLevel = g.choose(child_p.hasChildren(),level-1,0)
            self.redraw_partial_subtree(node_id,child_p,level=newLevel)
            child_p.moveToNext()

    # The calls to tree.Expand and tree.Collapse *will* generate events,
    # This is the reason the event handlers must be disabled while drawing.
    if level > 0 and p.hasChildren():
        if p.isExpanded():
            tree.Expand(node_id)
        else:
            # g.trace('collapsing:',p.headString())
            tree.Collapse(node_id)

    # Do this *after* drawing the children so as to ensure the +- box is drawn properly.
    if 1: # May be changed later, but useful here.
        if p == c.currentPosition():
            tree.SelectItem(node_id) # Generates call to onTreeChanged.
#@-node:ekr.20090126093408.810:redraw_partial_subtree
#@-node:ekr.20090126093408.809:partialRedraw & helpers
#@+node:ekr.20090126093408.800:redraw & redraw_now
redrawCount = 0

def redraw (self):
    c = self.c ;  tree = self.treeCtrl
    if c is None or self.drawing: return
    p = c.rootPosition()
    if not p: return

    self.redrawCount += 1
    # if True and not g.app.unitTesting: g.trace(self.redrawCount,g.callers())

    self.drawing = True # Disable event handlers.
    try:
        self.editWidgetDict = {} # Bug fix.
        self.idDict = {}
        self.expandAllAncestors(c.currentPosition())
        if sys.platform.startswith('win') and not g.app.unitTesting:
            self.cleverRedraw() # Slow, but eliminates flash.
        else:
            self.partialRedraw() # Essential for Linux.
    finally:
        self.drawing = False # Enable event handlers.
    # if True and not g.app.unitTesting: g.trace('done')

def redraw_now(self,scroll=True):
    self.redraw()
#@nonl
#@-node:ekr.20090126093408.800:redraw & redraw_now
#@+node:ekr.20090126093408.808:redraw_node
def redraw_node(self,parent_id,p):

    tree = self.treeCtrl
    data = wx.TreeItemData(p.copy())
    image = self.assignIcon(p)

    node_id = tree.AppendItem(
        parent_id,
        text=p.headString(),
        image=image,
        #selImage=image,
        data=data)

    # tree.SetItemFont(id,self.defaultFont)

    self.setEditWidget(p,node_id)
    assert (p == tree.GetItemData(node_id).GetData())
    return node_id
#@-node:ekr.20090126093408.808:redraw_node
#@+node:ekr.20090126093408.834:Selection (leoTree)
#@+node:ekr.20090126093408.835:editLabel
def editLabel (self,p,selectAll=False):

    '''The edit-label command.'''

    if g.app.killed or self.c.frame.killed: return

    c = self.c

    tree_id = self.getIdDict(p)
    # g.trace('editPosition',self.editPosition(),'id',id(tree_id))

    expandFlag = self.expandAllAncestors(p)
    idFlag = not tree_id or not tree_id.IsOk()
    switchFlag = p != self.editPosition()
    # g.trace('expand',expandFlag,'id',idFlag,'switch',switchFlag)

    # Eliminating switchFlag gets rid of most flashes.
    redrawFlag = expandFlag or idFlag

    self.endEditLabel()
    if redrawFlag: c.redraw()

    self.setEditPosition(p) # That is, self._editPosition = p
    tree_id = self.getIdDict(p)
    if not tree_id: return # Not an error.

    self.treeCtrl.EditLabel(tree_id)
    w = c.edit_widget(p)
    if p and w:
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        # Important: this sets the 'virtual' selection (so, e.g., unit tests will pass)
        # but it does *not* clear the actual selection (there is no way to do this programatically)
        selectAll = c.config.getBool('select_all_text_when_editing_headlines')
        if selectAll:
            w.setSelectionRange(0,'end',insert='end')
        else:
            w.setSelectionRange('end','end',insert='end')
        c.headlineWantsFocus(p) # Make sure the focus sticks.
#@-node:ekr.20090126093408.835:editLabel
#@+node:ekr.20090126093408.836:setEditWidget
# Called only from wxTree.redraw_node,
# so creating a new headlineWidget each time is correct.

def setEditWidget (self,p,tree_id):

    if g.app.killed or self.c.frame.killed: return

    self.setIdDict(p,tree_id)
    p.edit_widget = w = headlineWidget(self.c,self.treeCtrl,tree_id)
    self.editWidgetDict[p.v] = w

#@-node:ekr.20090126093408.836:setEditWidget
#@+node:ekr.20090126093408.837:get/setIdDict
def getIdDict (self,p):

    '''Return the unique wx.Tree id for position p.'''
    aList = self.idDict.get(p.v,[])
    for p2,tree_id in aList:
        if p.equal(p2):
            return tree_id
    else:
        # g.trace('No tree_id for position %s',p.headString()) # Not an error.
        return None

def setIdDict (self,p,tree_id):

    '''Associate the wx.Tree id with a position p.'''

    # Keys are vnodes, values are lists of position/tree_id pairs.
    aList = self.idDict.get(p.v,[])
    data = p.copy(),tree_id
    aList.append(data)
    self.idDict[p.v] = aList
#@-node:ekr.20090126093408.837:get/setIdDict
#@-node:ekr.20090126093408.834:Selection (leoTree)
#@+node:ekr.20090126093408.812:tree.edit_widget
def edit_widget (self,p):

    '''Return a widget (compatible with leoTextWidget) used for editing the headline.'''

    w = self.editWidgetDict.get(p.v)

    return w
#@-node:ekr.20090126093408.812:tree.edit_widget
#@+node:ekr.20090126093408.838:tree.setHeadline (new in 4.4b2)
def setHeadline (self,p,s):

    '''Set the actual text of the headline widget.

    This is called from the undo/redo logic to change the text before redrawing.'''

    w = self.c.edit_widget(p)
    if w:
        w.setAllText(s)
        self.revertHeadline = s
    elif g.app.killed or self.c.frame.killed:
        return
    else:
        g.trace('-'*20,'oops')
#@-node:ekr.20090126093408.838:tree.setHeadline (new in 4.4b2)
#@+node:ekr.20090126093408.813:updateVisibleIcons
def updateVisibleIcons (self,p):

    '''Update all visible icons joined to p.'''

    for p in self.c.rootPosition().self_and_siblings_iter():
        self.updateIconsInSubtree(p)

def updateIconsInSubtree (self,p):
    self.updateIcon(p)
    if p.hasChildren() and p.isExpanded():
        for child in p.firstChild().self_and_siblings_iter():
            self.updateIconsInSubtree(child)

def updateIcon(self,p):
    val = p.v.computeIcon()
    tree_id = self.getIdDict(p)
    if tree_id:
        self.treeCtrl.SetItemImage(tree_id,val)
    else:
        g.trace('can not happen: no id',p.headString())
#@-node:ekr.20090126093408.813:updateVisibleIcons
#@-node:ekr.20090126093408.789:OLDwxLeoTree
#@-node:ekr.20081208155215.12:Unused
#@-all
#@nonl
#@-node:ekr.20081121105001.147:@thin qtNotes.txt
#@-leo
