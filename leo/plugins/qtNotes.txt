#@+leo-ver=4-thin
#@+node:ekr.20081121105001.147:@thin qtNotes.txt
#@+all
#@+node:ekr.20081121105001.148: qt To do
@nocolor-node

- Support hoist in redraw code.
- Get rClick plugin working.

Bugs: See child nodes for details.
#@+node:ekr.20081215162017.1:Urgent bugs 4
#@+node:ekr.20081215162017.2:Headline doesn't stick after ctrl-L
#@-node:ekr.20081215162017.2:Headline doesn't stick after ctrl-L
#@+node:ekr.20081215074704.17:Fix focus problems
@nocolor-node

- Add traces for focus.
    - Is the "cute hack" causing problems?

- Can key strokes be handled in log pane?

Alt-tab sometimes loses focus

The focus doesn't go to any pane that supports key bindings.

This may be a result of the F-key lock not being down.  Or something.
#@nonl
#@-node:ekr.20081215074704.17:Fix focus problems
#@+node:ekr.20081215162017.3:Find can crash when search-headline is off
#@-node:ekr.20081215162017.3:Find can crash when search-headline is off
#@+node:ekr.20081215074704.15:Cut/paste work erratically
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/58af715355227ec

I'm observing the following strange behavior when copy and paste text
using the qt plugin. The behavior is erratic and I cannot reproduce it
systematically so I'll try to give you a general picture.

When I select and copy text in the body pane of a node SOMETIMES I see
the following message in the console

QClipboard::setData: Cannot set X11 selection owner for CLIPBOARD

When I try to paste the copied text:
- sometimes it works fine
- sometimes nothing happens (and the Paste entry of the body pane
context menu is disabled)
- sometimes the pasted text is not the last copied text (i.e. some
copy operations fail)

I know this is confusing and I've done my best trying to get a pattern
for these facts but with no luck.

Vicent 
#@nonl
#@-node:ekr.20081215074704.15:Cut/paste work erratically
#@-node:ekr.20081215162017.1:Urgent bugs 4
#@+node:ekr.20081215074704.13:Bugs 4
* Disabling searches of body pane can cause hard crashes.
    - initInteractiveCommands expects c.edit_widget(p)to exist.
#@nonl
#@+node:ekr.20081215074704.16:Mark finds doesn't work in Qt gui plugin
http://groups.google.com/group/leo-editor/browse_thread/thread/b2af78fbb36d3590
#@nonl
#@-node:ekr.20081215074704.16:Mark finds doesn't work in Qt gui plugin
#@+node:ekr.20081215074704.14:Fix flash characters problems
Ask Qt people.
#@nonl
#@-node:ekr.20081215074704.14:Fix flash characters problems
#@+node:ekr.20081124094918.1:Fix problems with scim
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/59c1e5d6acaf4de0

I've some more information about the problems with accent previously
reported:
- I can confirm that they are caused by the interaction scim+leo (with
and without the qt plugin). If scim is not started leo works fine. If
scim is running the problems appear and are slightly different with
and without the qt plugin. The workaround is obvious: don't use leo
and scim at the same time :-)
- accents are not working in the qt plugin when scintilla is used. If
qt-use-scintilla=False I can write this:

àáä (the same for the rest of vowels)

but if qt-use-scintilla=True when I enter the same sequence in the
keyboard I get:

`aaa (the same for the rest of vowels)

- the problem with the ñ character (reported previously too) is only
present in the qt plugin (both with and without scintilla)
#@-node:ekr.20081124094918.1:Fix problems with scim
#@+node:ekr.20081215074704.18:Finish qt gui delete_range method
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/51edf3b44d6a587e

revno: 1259.1.10
revision-id: terry_n_brown@yahoo.com-20081130181632-ci0ioaksewdvc257

I added code so that this no longer derails the initialization process,
i.e. just catch the exception and continue.  I don't know what's wrong
except I first noticed it after a tkinter update from Ubuntu.  I
think.  Anyway, that's my story :)

When I added the "clean recent files" menu option long before this
traceback showed up I had a heap of trouble deleting just the file
entries on the recent files menu.  It was originally hardwired that the
menu have a "Clear list" item, and then the file entries, but I wanted
to make it get it's command entries from @menu @settings and add the
files afterward and that was a lot of fiddling.  I.e. originally it
deleted everything and added the "Clear list" item before rebuilding
the file list, now it either tries to delete only the file entries, or
stores the entries before the files (from @menu) and adds them back
before the files each time, I forget which finally worked.

What's my point?  It would be nice if delete_range "just worked".  It's
a 'pass' in qt, and I would guess recent files is the only thing in the
entire code base that uses it.

The menu tree seems to me to be "write only", i.e. not readable, at
least from the Leo API, of course you can walk it in a gui specific
way.  Not necessarily a problem, but would be nice if it was more
robustly dynamic.  Or maybe I'm missing something, but I've only seen
functions which find a menu based on knowing it exists before hand.
#@nonl
#@-node:ekr.20081215074704.18:Finish qt gui delete_range method
#@-node:ekr.20081215074704.13:Bugs 4
#@+node:ekr.20081215074704.19:Features 5
#@+node:ekr.20081215162017.4:Allow coloring of script buttons
#@-node:ekr.20081215162017.4:Allow coloring of script buttons
#@+node:ekr.20081215162017.5:Support multiple body editors
#@-node:ekr.20081215162017.5:Support multiple body editors
#@+node:ekr.20081215074704.20:Change background color of body pane depending on focus
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/1cce885a697d0236/5aea5d0587b47b92?lnk=gst&q=command+and+insert#5aea5d0587b47b92

Set focus in/out events.
#@nonl
#@-node:ekr.20081215074704.20:Change background color of body pane depending on focus
#@+node:ekr.20081215074704.21:Add drag and drop
#@-node:ekr.20081215074704.21:Add drag and drop
#@+node:ekr.20081121105001.151:Clean up settings
- Can style sheets really do the job?

- Remove old-style Leo settings?

- Add stylesheets for dialogs.
    - Set font for dummy widget in style sheet, then copy that font.
#@+node:ekr.20081121105001.150:QScintilla stuff
- Check event handling with QScintilla.
- Experiment with sending <shift-tab> directly to QScintilla.
- Call setLexer(0) for nocolor nodes.
- Add settings for syntax coloring.
- Make Scintilla handle Leo markup.
- Install new Qt version and play with QScintilla.
    From QScintilla change log:
    2008/10/12 14:32:05  phil
    QsciScintilla::setSelection() is now implemented using SCI_SETSEL so that the
    carat can be left at either the start or the end of the selection.
    Exposed QsciScintilla::positionFromLineIndex() and
    QsciScintilla::lineIndexFromPosition().
    - Fix problem with accented characters: see child node for notes.
#@nonl
#@-node:ekr.20081121105001.150:QScintilla stuff
#@-node:ekr.20081121105001.151:Clean up settings
#@-node:ekr.20081215074704.19:Features 5
#@-node:ekr.20081121105001.148: qt To do
#@+node:ekr.20081121105001.185:Scripts
#@+node:ekr.20081121105001.186:Script to display Qt font database
import PyQt4.QtGui as QtGui

db = QtGui.QFontDatabase()
for family in db.families():
    print family
    for style in db.styles(family):
        print '\t',style,db.smoothSizes(family,style)
#@-node:ekr.20081121105001.186:Script to display Qt font database
#@+node:ekr.20081121105001.187:dump guiBindNamesInverseDict
print g.dictToString(c.k.guiBindNamesInverseDict)

@
   BackSpace: 'BackSpace'
       Begin: 'Begin'
       Break: 'Break'
   Caps_Lock: 'Caps_Lock'
       Clear: 'Clear'
      Delete: 'Delete'
        Down: 'Down'
         End: 'End'
      Escape: 'Escape'
          F1: 'F1'
         F10: 'F10'
         F11: 'F11'
         F12: 'F12'
          F2: 'F2'
          F3: 'F3'
          F4: 'F4'
          F5: 'F5'
          F6: 'F6'
          F7: 'F7'
          F8: 'F8'
          F9: 'F9'
        Home: 'Home'
        Left: 'Left'
    Linefeed: 'Linefeed'
        Next: 'Next'
    Num_Lock: 'Num_Lock'
       Prior: 'Prior'
      Return: 'Return'
       Right: 'Right'
         Tab: 'Tab'
          Up: 'Up'
   ampersand: '&'
 asciicircum: '^'
  asciitilde: '~'
    asterisk: '*'
          at: '@'
   backslash: '\\'
         bar: '|'
   braceleft: '{'
  braceright: '}'
 bracketleft: '['
bracketright: ']'
       colon: ':'
       comma: ','
      dollar: '$'
       equal: '='
      exclam: '!'
     greater: '>'
        less: '<'
       minus: '-'
  numbersign: '#'
   parenleft: '('
  parenright: ')'
     percent: '%'
      period: '.'
        plus: '+'
    question: '?'
    quotedbl: '"'
   quoteleft: '`'
  quoteright: "'"
   semicolon: ';'
       slash: '/'
       space: ' '
  underscore: '_'
#@nonl
#@-node:ekr.20081121105001.187:dump guiBindNamesInverseDict
#@-node:ekr.20081121105001.185:Scripts
#@+node:ekr.20081208155215.12:Unused
#@+node:ekr.20081212123717.10:Clever redraw
if 0: # Experimental.

    @others
#@nonl
#@+node:ekr.20081212123717.22:redrawEntireTree
def redrawEntireTree (self):

    '''Redraw the tree, minimizing the actual changes made to the tree.'''

    trace = True; verbose = False
    c = self.c ; w = self.treeWidget
    if not w: return
    if self.redrawing:
        if trace: g.trace('***** already drawing',g.callers(4))
        return

    self.redrawCount += 1
    if trace: tstart()

    self.nodeDrawCount = 0
    self.redrawing = True
    try:
        c.expandAllAncestors(c.currentPosition())
        self.initData()
        p = c.rootPosition()
        sibs = p.v.children
        for child in children:
            self.createVnodeTree(v,parent_item=None)
    finally:
        if not self.selecting:
            item = self.setCurrentItem()
            if p and not item and self.redrawCount > 1:
                if not g.app.unitTesting:
                    g.trace('Error: no current item: %s' % (
                        p.headString()))

        if 0: # Very slow for unit tests.
            w.repaint()
        c.requestRedrawFlag = False
        self.redrawing = False
        if trace:
            theTime = tstop()
            if self.nodeDrawCount and not g.app.unitTesting:
                g.trace('%s: drew %3s nodes in %s' % (
                    self.redrawCount,self.nodeDrawCount,theTime))

# Compatibility
if use_partial_redraw:
    redraw = partial_redraw 
    redraw_now = partial_redraw
    redraw_after_clone = partial_redraw
    redraw_after_contract = partial_redraw
    redraw_after_delete = partial_redraw
    redraw_after_expand = partial_redraw
    redraw_after_insert = partial_redraw
    redraw_after_move_down = partial_redraw
    redraw_after_move_left = partial_redraw
    redraw_after_move_right = partial_redraw
    redraw_after_move_up = partial_redraw
#@-node:ekr.20081212123717.22:redrawEntireTree
#@+node:ekr.20081212123717.11:redrawAfterInsert
def redrawAfterInsert (self,p):

    v = p.v ; childIndex = p.childIndex()

    parent_items = self.vnode2parentItemsDict(v)

    # A crucial constraint.
    assert len(v.parents) == len(parent_items)

    for parent_item in parent_items:

        item = self.createNthChildItem(v,childIndex,parent_item)

        self.createVnodeChildren(v,parent_item=item)
#@-node:ekr.20081212123717.11:redrawAfterInsert
#@+node:ekr.20081212123717.16:High-level helpers
#@+node:ekr.20081212123717.12:createVnodeTree (test)
def createVnodeTree (self,v):

    # Create the parent node.
    item = self.createVnodeItem(v,parent_item)

    # Create all the children.
    self.createVnodeChildren(v,parent_item=item)

    return item
#@-node:ekr.20081212123717.12:createVnodeTree (test)
#@+node:ekr.20081212123717.13:createVnodeChildren (test)
def createVnodeChildren (self,v,parent_item):

    children = v.children

    if children:
        self.expandItem(parent_item)
            # Will contract later if v is not expanded.

    # Create each child tree.
    for child in children:
        self.createVnodeTree(child,parent_item)

    if not children or not v.isExpanded:
        self.contractItem(parent_item)
#@-node:ekr.20081212123717.13:createVnodeChildren (test)
#@-node:ekr.20081212123717.16:High-level helpers
#@+node:ekr.20090109110752.22:Low-level helpers
#@+node:ekr.20081211060950.13:createItem
def createItem (self,p,parent_item):

    c = self.c ; w = self.treeWidget
    self.nodeDrawCount += 1

    # Allocate the QTreeWidget item.
    itemOrTree = parent_item or w
    item = QtGui.QTreeWidgetItem(itemOrTree)
    item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)

    # Set the headline and maybe the icon.
    item.setText(0,p and p.headString() or '<dummy headline>')
    if p:
        icon = self.getIcon(p)
        if icon: item.setIcon(0,icon)

    self.rememberItem(p,item)

    return item
#@-node:ekr.20081211060950.13:createItem
#@+node:ekr.20081209211810.2:createNthChildItem
def createNthChildItem(self,p,n,parent_item):

    '''Insert an item for p as the n'th child of parent_item.'''

    # Similar to createItem

    trace = False
    c = self.c ; w = self.treeWidget
    self.nodeDrawCount += 1

    # Allocate the QTreeWidget item.
    itemOrTree = parent_item or w
    item = QtGui.QTreeWidgetItem()
    item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)

    # Insert the item as the n'th child of the parent item.
    if trace: g.trace('parent_item: %s, item: %s' % (parent_item,item))
    if parent_item:
        parent_item.insertChild(n,item)
    else:
        w.insertTopLevelItem(n,item)

    # Set the headline and maybe the icon.
    item.setText(0,p and p.headString() or '<dummy headline>')
    if p:
        icon = self.getIcon(p)
        if icon: item.setIcon(0,icon)

    self.rememberItem(p,item)

    return item
#@-node:ekr.20081209211810.2:createNthChildItem
#@+node:ekr.20081212123717.18:createNthVnodeChildItem
def createNthChildItem(self,v,n,parent_item):

    '''Insert an item for v as the n'th child of parent_item.'''

    # Similar to createVnodeItem

    trace = False
    c = self.c ; w = self.treeWidget
    self.nodeDrawCount += 1

    # Allocate the QTreeWidget item.
    itemOrTree = parent_item or w
    item = QtGui.QTreeWidgetItem()
    item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)

    # Insert the item as the n'th child of the parent item.
    if trace: g.trace('parent_item: %s, item: %s' % (parent_item,item))

    if parent_item:
        parent_item.insertChild(n,item)
    else:
        w.insertTopLevelItem(n,item)

    # Set the headline and maybe the icon.
    item.setText(0,v.headString())
    icon = self.getVnodeIcon(v)
    if icon: item.setIcon(0,icon)

    self.rememberVnodeItem(v,item)

    return item
#@-node:ekr.20081212123717.18:createNthVnodeChildItem
#@+node:ekr.20081212123717.14:createVnodeItem
def createVnodeItem (self,v,parent_item):

    c = self.c ; w = self.treeWidget
    self.nodeDrawCount += 1

    # Allocate the QTreeWidget item.
    itemOrTree = parent_item or w
    item = QtGui.QTreeWidgetItem(itemOrTree)
    item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)

    # Set the headline and the icon.
    item.setText(0,v.headString())
    icon = self.getVnodeIcon(v)
    if icon: item.setIcon(0,icon)

    self.rememberVnodeItem(v,item)

    return item
#@-node:ekr.20081212123717.14:createVnodeItem
#@+node:ekr.20081208072750.18:deleteItem
def deleteItem (self,parent_item,item):

    '''Delete the item and forget all items in the entire tree.'''

    # Important: No p exists for the deleted item.
    # However an entry in item2vnodeDict does exist.

    # Remove the item and all its descendants from item2vnodeDict.
    self.forgetItem(item)

    if parent_item:
        parent_item.removeChild(item)
    else:
        child_items = self.childItems(parent_item)
        if item in child_items:
            w = self.treeWidget
            n = child_items.index(item)
            w.takeTopLevelItem(n)
        else:
            self.oops('item not in top level',item)
#@-node:ekr.20081208072750.18:deleteItem
#@+node:ekr.20081211060950.15:forgetItem
def forgetItem (self,item):

    '''Remove the item and all its descendant items
    from the item2vnodeDict.'''

    d = self.item2vnodeDict

    if item in d:
        v = d.get(item)
        aList = vnode2itemsDict.get(v)
        if item in aList:
            aList.remove(item)
        else:
            self.oops('not in vnode2itemsDict: %s' % item)
        del d[item]
    else:
        self.oops('not in item2vnodeDict: %s' % item)

    child_items = self.childItems(item)

    for child_item in child_items:

        self.forgetItem(child_item)
#@-node:ekr.20081211060950.15:forgetItem
#@+node:ekr.20081209103009.15:numberofChildItems
def numberOfChildItems (self,parent_item):

    '''Return the number child items of the parent item,
    or the number of top-level items if parent_item is None.'''

    if parent_item:
        n = parent_item.childCount()
    else:
        w = self.treeWidget
        n = w.topLevelItemCount()

    return n
#@-node:ekr.20081209103009.15:numberofChildItems
#@+node:ekr.20081209103009.19:swapNthItems
def swapNthItems(self,n,parent_item):

    '''Swap the n'th and n+1'st items.'''

    # g.trace(n,p)

    child_items = self.childItems(parent_item)

    if n + 1 < len(child_items):
        child1 = child_items[n]
        child2 = child_items[n+1]
        if parent_item:
            parent_item.removeChild(child1)
            parent_item.removeChild(child2)
            parent_item.insertChild(n,child2)
            parent_item.insertChild(n+1,child1)
        else:
            w = self.treeWidget
            w.takeTopLevelItem(n)
            w.takeTopLevelItem(n)
            w.insertTopLevelItem(n,child2)
            w.insertTopLevelItem(n+1,child1)
    else:
        self.oops('bad n: %s,len(child_items): %s' % (
            n,len(child_items)))
#@-node:ekr.20081209103009.19:swapNthItems
#@+node:ekr.20081211060950.19:updateHeadline
def updateHeadline (self,p,item):

    item.setText(0,p.headString())
#@-node:ekr.20081211060950.19:updateHeadline
#@-node:ekr.20090109110752.22:Low-level helpers
#@-node:ekr.20081212123717.10:Clever redraw
#@+node:ekr.20081121105001.413:allAncestorsExpanded
def allAncestorsExpanded (self,p):

    for p in p.self_and_parents_iter():
        if not p.isExpanded():
            return False
    else:
        return True
#@-node:ekr.20081121105001.413:allAncestorsExpanded
#@+node:ekr.20081211060950.16:rememberItem & rememberVnodeItem (OLD)
# def rememberItem (self,p,item):

    # self.rememberVnodeItem(p.v,item)

# def rememberVnodeItem (self,v,item):

    # # Update item2vnodeDict.
    # self.item2vnodeDict[item] = v

    # # Update vnode2itemsDict.
    # d = self.vnode2itemsDict
    # aList = d.get(v,[])

    # if item in aList:
        # self.oops('item already in list: %s, %s' % (item,aList))
    # else:
        # aList.append(item)
        # d[v] = aList
#@-node:ekr.20081211060950.16:rememberItem & rememberVnodeItem (OLD)
#@+node:ekr.20081209064740.1:Item dict getters (OLD)
# def item2vnode (self,item):
    # return self.item2vnodeDict.get(item)

# def vnode2items(self,v):
    # return self.vnode2itemsDict.get(v,[])

# def isValidItem (self,item):
    # return item in self.item2vnodeDict
#@-node:ekr.20081209064740.1:Item dict getters (OLD)
#@-node:ekr.20081208155215.12:Unused
#@+node:ekr.20090110154843.10:Crash because of bad edit_widget
#@+node:ekr.20081121105001.156:editLabel (override)
def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    trace = False ; verbose = False
    c = self.c ; w = self.treeWidget

    if self.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if self._editWidget:
        # Not an error, because of key weirdness.
        if trace: g.trace('already editing')
        return

    if trace: g.trace('***',p and p.headString(),g.callers(4))

    c.outerUpdate() # Do any scheduled redraw.

    item = self.position2item(p)

    if item:
        w.setCurrentItem(item) # Must do this first.
        w.editItem(item)
        e = w.itemWidget(item,0) # A QLineEdit
        if e:
            s = e.text() ; len_s = len(s)
            # Hook up the widget to Leo's core.
            self._editWidgetPosition = p.copy()
            self._editWidget = e
            self._editWidgetWrapper = leoQtHeadlineWidget(
                widget=e,name='head',c=c)
            start,n = g.choose(selectAll,
                tuple([0,len_s]),tuple([len_s,0]))
            e.setObjectName('headline')
            e.setSelection(start,n)
            e.setFocus()
        else: self.oops('no edit widget')
    else:
        self.killEditing()
        e = None
        self.oops('no item: %s' % p)

    # A nice hack: just set the focus request.
    if e: c.requestedFocusWidget = e
#@-node:ekr.20081121105001.156:editLabel (override)
#@+node:ekr.20081121105001.160:edit_widget
def edit_widget (self,p):

    """Returns the Qt.Edit widget for position p."""

    w = self._editWidgetWrapper

    if p and p == self._editWidgetPosition:
        w2 = g.app.gui.get_focus()
        # g.trace(w2,w,w and w.widget)
        if w.widget == w2:
            return w
        else:
            # g.trace('no match.  killing')
            self.killEditing()
            return None
    else:
        return None

    # Decouple all of the core's headline code.
    # Except for over-ridden methods.
#@-node:ekr.20081121105001.160:edit_widget
#@+node:ekr.20081121105001.163:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.'''

    trace = False ; verbose = True
    c = self.c ; u = c.undoer
    e = self._editWidget
    p = self._editWidgetPosition
    w = g.app.gui.get_focus()

    # These are not errors: sig_itemChanged may
    # have been called first.
    if trace and verbose:
        if not e:  g.trace('No e',g.callers(4))
        if e != w: g.trace('e != w',e,w,g.callers(4))
        if not p:  g.trace('No p')

    if e and e == w and p:
        s = e.text() ; len_s = len(s)
        s = g.app.gui.toUnicode(s)
        oldHead = p.headString()
        changed = s != oldHead
        if trace: g.trace('changed',changed,repr(s),g.callers(4))
        if changed:
            p.initHeadString(s)
            undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
            if not c.changed: c.setChanged(True)
            # New in Leo 4.4.5: we must recolor the body because
            # the headline may contain directives.
            c.frame.body.recolor(p,incremental=True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)

    # End the editing!
    self.killEditing()

    # This is a crucial shortcut.
    if g.unitTesting: return

    #### c.redraw(scroll=False)
    if self.stayInTree:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()
#@nonl
#@-node:ekr.20081121105001.163:onHeadChanged
#@+node:ekr.20090110154843.11:killEditing
def killEditing (self):

    # g.trace(g.callers(4))

    self._editWidgetPosition = None
    self._editWidget = None
    self._editWidgetWrapper = None
#@-node:ekr.20090110154843.11:killEditing
#@-node:ekr.20090110154843.10:Crash because of bad edit_widget
#@+node:ekr.20090112065600.11:Problems with redraw_after_icons_changed
#@+node:ekr.20081121105001.443:sig_itemChanged
def sig_itemChanged(self, item, col):

    '''Handle a change event in a headline.
    This only gets called when the user hits return.'''

    # Ignore changes when redrawing.
    if self.redrawing:
        return

    p = self.item2position(item)
    if p:
        # so far, col is always 0
        s = g.app.gui.toUnicode(item.text(col))
        p.setHeadString(s)
        p.setDirty()
        self.killEditing()
        self.redraw_after_icons_changed(all=False)
    else:
        # Make sure to end editing.
        self.killEditing()
#@-node:ekr.20081121105001.443:sig_itemChanged
#@+node:ekr.20090109110752.16:redraw_after_icons_changed
def redraw_after_icons_changed (self,all=False):

    if self.redrawing: return

    self.redrawCount += 1 # To keep a unit test happy.

    c = self.c

    # Suppress call to setHeadString in sig_itemChanged!
    self.redrawing = True
    try:
        if all:
            for p in c.rootPosition().self_and_siblings_iter():
                self.updateVisibleIcons(p)
        else:
            p = c.currentPosition()
            self.updateIcon(p,force=True)
        self.killEditing()
    finally:
        self.redrawing = False

#@-node:ekr.20090109110752.16:redraw_after_icons_changed
#@+node:ekr.20081209064740.2:Icons
#@+node:ekr.20081121105001.417:drawIcon
def drawIcon (self,p):

    '''Redraw the icon at p.'''

    w = self.treeWidget
    itemOrTree = self.position2item(p) or w
    item = QtGui.QTreeWidgetItem(itemOrTree)
    icon = self.getIcon(p)
    if icon and item:
        item.setIcon(0,icon)
#@-node:ekr.20081121105001.417:drawIcon
#@+node:ekr.20081211115412.12:drawItemIcon
def drawItemIcon (self,p,item):

    '''Set the item's icon to p's icon.'''

    icon = self.getIcon(p)
    if icon and item:
        item.setIcon(0,icon)
#@-node:ekr.20081211115412.12:drawItemIcon
#@+node:ekr.20081121105001.418:getIcon & getIconImage
def getIcon(self,p):

    '''Return the proper icon for position p.'''

    p.v.iconVal = val = p.v.computeIcon()

    return self.getCompositeIconImage(p, val)

def getVnodeIcon(self,p):

    '''Return the proper icon for position p.'''

    v.iconVal = val = v.computeIcon()
    return self.getIconImage(val)

def getIconImage(self,val):

    return g.app.gui.getIconImage(
        "box%02d.GIF" % val)

def getCompositeIconImage(self, p, val):

    userIcons = self.c.editCommands.getIconList(p)
    statusIcon = self.getIconImage(val)

    if not userIcons:
        return statusIcon

    hash = [i['file'] for i in userIcons if i['where'] == 'beforeIcon']
    hash.append(str(val))
    hash.extend([i['file'] for i in userIcons if i['where'] == 'beforeHeadline'])
    hash = ':'.join(hash)

    if hash in g.app.gui.iconimages:
        return g.app.gui.iconimages[hash]

    images = [g.app.gui.getImageImage(i['file']) for i in userIcons
             if i['where'] == 'beforeIcon']
    images.append(g.app.gui.getImageImage("box%02d.GIF" % val))
    images.extend([g.app.gui.getImageImage(i['file']) for i in userIcons
                  if i['where'] == 'beforeHeadline'])
    width = sum([i.width() for i in images])
    height = max([i.height() for i in images])

    pix = QtGui.QPixmap(width,height)
    pix.fill()
    pix.setAlphaChannel(pix)
    painter = QtGui.QPainter(pix)
    x = 0
    for i in images:
        painter.drawPixmap(x,(height-i.height())//2,i)
        x += i.width()
    painter.end()

    g.app.gui.iconimages[hash] = QtGui.QIcon(pix)

    return g.app.gui.iconimages[hash]
#@-node:ekr.20081121105001.418:getIcon & getIconImage
#@+node:ekr.20081121105001.431:updateIcon
def updateIcon (self,p,force=False):

    '''Update p's icon.'''

    if not p: return

    val = p.v.computeIcon()

    # The force arg is needed:
    # Leo's core may have updated p.v.iconVal.
    if p.v.iconVal == val and not force:
        return

    p.v.iconVal = val
    icon = self.getIconImage(val)
    # Update all cloned/joined items.
    items = self.tnode2items(p.v.t)
    for item in items:
        if self.isValidItem(item):
            item.setIcon(0,icon)
#@-node:ekr.20081121105001.431:updateIcon
#@+node:ekr.20090112065600.10:updateVisibleIcons
def updateVisibleIcons (self,p):

    '''Update the icon for p and the icons
    for all visible descendants of p.'''

    self.updateIcon(p,force=True)

    if p.hasChildren() and p.isExpanded():
        for child in p.children_iter():
            self.updateVisibleIcons(child)
#@-node:ekr.20090112065600.10:updateVisibleIcons
#@-node:ekr.20081209064740.2:Icons
#@-node:ekr.20090112065600.11:Problems with redraw_after_icons_changed
#@-all
#@nonl
#@-node:ekr.20081121105001.147:@thin qtNotes.txt
#@-leo
