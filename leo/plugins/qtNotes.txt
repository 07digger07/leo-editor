#@+leo-ver=5-thin
#@+node:ekr.20081121105001.147: * @file qtNotes.txt
#@+all
#@+node:ekr.20081121105001.148: **  qt To do
#@+node:ekr.20101101111704.3761: *3* Remove or complete x.createBindings
#@+node:ekr.20100223133144.3680: *3* Create color picker
createColorPicker
#@+node:ekr.20100223114506.3699: *3* Support cascade menu
leoQtFrame.cascade.
#@+node:ekr.20081121105001.306: *4* cascade
def cascade (self,event=None):

    '''Cascade all Leo windows.'''

    x,y,delta = 50,50,50
    for frame in g.app.windowList:

        w = frame and frame.top
        if w:
            r = w.geometry() # a Qt.Rect
            w.setGeometry(x,y,r.width(),r.height())

            # Compute the new offsets.
            x += 30 ; y += 30
            if x > 200:
                x = 10 + delta ; y = 40 + delta
                delta += 10
#@+node:ekr.20100223114506.3698: *3* Should leoQtMenu.index do something?
#@+node:ekr.20081124094918.1: *3* Fix problems with scim
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/59c1e5d6acaf4de0

I've some more information about the problems with accent previously
reported:
- I can confirm that they are caused by the interaction scim+leo (with
and without the qt plugin). If scim is not started leo works fine. If
scim is running the problems appear and are slightly different with
and without the qt plugin. The workaround is obvious: don't use leo
and scim at the same time :-)
- accents are not working in the qt plugin when scintilla is used. If
qt-use-scintilla=False I can write this:

àáä (the same for the rest of vowels)

but if qt-use-scintilla=True when I enter the same sequence in the
keyboard I get:

`aaa (the same for the rest of vowels)

- the problem with the ñ character (reported previously too) is only
present in the qt plugin (both with and without scintilla)
#@+node:ekr.20110119065600.3895: ** Leo 4.9 b1 (retain for reference)
#@+node:ekr.20110510071925.14583: *3* Fixed focus problems with QCompleter
@nocolor-node

- Calling QCompleter.hide rather than QCompleter.deleteLater
  probably solves the focus problems.
  
- c.idle_focus_helper is experimental.  The pattern::
    
    c.in_qt_dialog = True
    aDialog.exec_()
    c.in_qt_dialog = False
    
prevents c.idle_focus_helper from attempting (and failing)
to force the focus to the body pane.  This pattern isn't
actually needed.
#@+node:ekr.20081121105001.479: *4* Dialogs & panels (qtGui)
#@+node:ekr.20081122170423.1: *5* alert (qtGui)
def alert (self,c,message):

    if g.unitTesting: return

    b = QtGui.QMessageBox
    d = b(None)
    d.setWindowTitle('Alert')
    d.setText(message)
    d.setIcon(b.Warning)
    yes = d.addButton('Ok',b.YesRole)
    c.in_qt_dialog = True
    d.exec_()
    c.in_qt_dialog = False
#@+node:ekr.20081121105001.480: *5* makeFilter
def makeFilter (self,filetypes):

    '''Return the Qt-style dialog filter from filetypes list.'''

    filters = ['%s (%s)' % (z) for z in filetypes]

    return ';;'.join(filters)
#@+node:tbrown.20100421115534.17325: *5* runAskOkCancelStringDialog
def runAskOkCancelStringDialog(self,c,title,message):

    """Create and run askOkCancelString dialog ."""

    if g.unitTesting: return None

    txt,ok = QtGui.QInputDialog.getText(None, title, message)
    if not ok:
        return None

    return txt
#@+node:tbrown.20100421115534.17324: *5* runAskOkCancelNumberDialog
def runAskOkCancelNumberDialog(self,c,title,message):

    """Create and run askOkCancelNumber dialog ."""

    if g.unitTesting: return None

    n,ok = QtGui.QInputDialog.getDouble(None, title, message)
    if not ok:
        return None

    return n
#@+node:ekr.20081121105001.482: *5* qtGui panels
def createComparePanel(self,c):

    """Create a qt color picker panel."""
    return None # This window is optional.
    # return leoQtComparePanel(c)

def createFindTab (self,c,parentFrame):
    """Create a qt find tab in the indicated frame."""
    return leoQtFindTab(c,parentFrame)

def createLeoFrame(self,title):
    """Create a new Leo frame."""
    gui = self
    return leoQtFrame(title,gui)

def createSpellTab(self,c,spellHandler,tabName):
    return leoQtSpellTab(c,spellHandler,tabName)

#@+node:ekr.20081121105001.483: *5* runAboutLeoDialog
def runAboutLeoDialog(self,c,version,theCopyright,url,email):

    """Create and run a qt About Leo dialog."""

    if g.unitTesting: return None

    b = QtGui.QMessageBox
    d = b(c.frame.top)

    d.setText('%s\n%s\n%s\n%s' % (
        version,theCopyright,url,email))
    d.setIcon(b.Information)
    yes = d.addButton('Ok',b.YesRole)
    d.setDefaultButton(yes)
    c.in_qt_dialog = True
    d.exec_()
    c.in_qt_dialog = False
#@+node:ekr.20081121105001.484: *5* runAskLeoIDDialog
def runAskLeoIDDialog(self):

    """Create and run a dialog to get g.app.LeoID."""

    if g.unitTesting: return None

    message = (
        "leoID.txt not found\n\n" +
        "Please enter an id that identifies you uniquely.\n" +
        "Your cvs/bzr login name is a good choice.\n\n" +
        "Leo uses this id to uniquely identify nodes.\n\n" +
        "Your id must contain only letters and numbers\n" +
        "and must be at least 3 characters in length.")
    parent = None
    title = 'Enter Leo id'
    s,ok = QtGui.QInputDialog.getText(parent,title,message)
    return g.u(s)
#@+node:ekr.20081121105001.485: *5* runAskOkDialog
def runAskOkDialog(self,c,title,message=None,text="Ok"):

    """Create and run a qt an askOK dialog ."""

    if g.unitTesting: return None

    b = QtGui.QMessageBox
    d = b(c.frame.top)

    d.setWindowTitle(title)
    if message: d.setText(message)
    d.setIcon(b.Information)
    yes = d.addButton(text,b.YesRole)
    c.in_qt_dialog = True
    d.exec_()
    c.in_qt_dialog = False

#@+node:tbrown.20100912184720.12469: *5* runAskDateTimeDialog
def runAskDateTimeDialog(self, c, title, 
    message='Select Date/Time', init=None, step_min={}):
    """Create and run a qt date/time selection dialog.

    init - a datetime, default now
    step_min - a dict, keys are QtGui.QDateTimeEdit Sections, like
      QtGui.QDateTimeEdit.MinuteSection, and values are integers,
      the minimum amount that section of the date/time changes
      when you roll the mouse wheel.

    E.g. (5 minute increments in minute field):

        print g.app.gui.runAskDateTimeDialog(c, 'When?',
          message="When is it?",
          step_min={QtGui.QDateTimeEdit.MinuteSection: 5})

    """

    class DateTimeEditStepped(QtGui.QDateTimeEdit):
        """QDateTimeEdit which allows you to set minimum steps on fields, e.g.
          DateTimeEditStepped(parent, {QtGui.QDateTimeEdit.MinuteSection: 5})
        for a minimum 5 minute increment on the minute field.
        """
        def __init__(self, parent=None, init=None, step_min={}):

            self.step_min = step_min
            if init:
                QtGui.QDateTimeEdit.__init__(self, init, parent)
            else:
                QtGui.QDateTimeEdit.__init__(self, parent)

        def stepBy(self, step):
            cs = self.currentSection()
            if cs in self.step_min and abs(step) < self.step_min[cs]:
                step = self.step_min[cs] if step > 0 else -self.step_min[cs]
            QtGui.QDateTimeEdit.stepBy(self, step)

    class Calendar(QtGui.QDialog):
        def __init__(self, parent=None, message='Select Date/Time',
            init=None, step_min={}):
            QtGui.QDialog.__init__(self, parent)

            layout = QtGui.QVBoxLayout()
            self.setLayout(layout)

            layout.addWidget(QtGui.QLabel(message))

            self.dt = DateTimeEditStepped(init=init, step_min=step_min)
            self.dt.setCalendarPopup(True)
            layout.addWidget(self.dt)

            buttonBox = QtGui.QDialogButtonBox(
            QtGui.QDialogButtonBox.Ok
                | QtGui.QDialogButtonBox.Cancel)
            layout.addWidget(buttonBox)

            self.connect(buttonBox, QtCore.SIGNAL("accepted()"),
                self, QtCore.SLOT("accept()"))
            self.connect(buttonBox, QtCore.SIGNAL("rejected()"),
                self, QtCore.SLOT("reject()"))

    if g.unitTesting: return None

    b = Calendar
    if not init:
        init = datetime.datetime.now()
    d = b(c.frame.top, message=message, init=init, step_min=step_min)

    d.setWindowTitle(title)
    
    c.in_qt_dialog = True
    val = d.exec_()
    c.in_qt_dialog = False

    if val != d.Accepted:
        return None
    else:
        return d.dt.dateTime().toPyDateTime()
#@+node:ekr.20081121105001.486: *5* runAskYesNoCancelDialog
def runAskYesNoCancelDialog(self,c,title,
    message=None,
    yesMessage="&Yes",noMessage="&No",defaultButton="Yes"
):

    """Create and run an askYesNo dialog."""

    if g.unitTesting: return None

    b = QtGui.QMessageBox

    d = b(c.frame.top)
    if message: d.setText(message)
    d.setIcon(b.Warning)
    d.setWindowTitle(title)
    yes    = d.addButton(yesMessage,b.YesRole)
    no     = d.addButton(noMessage,b.NoRole)
    cancel = d.addButton(b.Cancel)
    if   defaultButton == "Yes": d.setDefaultButton(yes)
    elif defaultButton == "No": d.setDefaultButton(no)
    else: d.setDefaultButton(cancel)
    c.in_qt_dialog = True
    val = d.exec_()
    c.in_qt_dialog = False

    if   val == 0: val = 'yes'
    elif val == 1: val = 'no'
    else:          val = 'cancel'
    return val
#@+node:ekr.20081121105001.487: *5* runAskYesNoDialog
def runAskYesNoDialog(self,c,title,message=None):

    """Create and run an askYesNo dialog."""

    if g.unitTesting: return None

    b = QtGui.QMessageBox
    d = b(c.frame.top)

    d.setWindowTitle(title)
    if message: d.setText(message)
    d.setIcon(b.Information)
    yes = d.addButton('&Yes',b.YesRole)
    no  = d.addButton('&No',b.NoRole)
    d.setDefaultButton(yes)
    c.in_qt_dialog = True
    val = d.exec_()
    c.in_qt_dialog = False
    return g.choose(val == 0,'yes','no')

#@+node:ekr.20101111103251.3821: *5* runOpenDirectoryDialog (qtGui)
def runOpenDirectoryDialog(self,title,startdir):

    """Create and run an Qt open directory dialog ."""

    parent = None
    s = QtGui.QFileDialog.getExistingDirectory (parent,title,startdir)
    return g.u(s)
#@+node:ekr.20081121105001.488: *5* runOpenFileDialog
def runOpenFileDialog(self,title,filetypes,defaultextension='',multiple=False, startpath = None):

    """Create and run an Qt open file dialog ."""

    if startpath is None:
        startpath = os.curdir
        
    parent = None
    filter = self.makeFilter(filetypes)

    if multiple:
        lst = QtGui.QFileDialog.getOpenFileNames(parent,title,startpath,filter)
        return [g.u(s) for s in lst]
    else:
        s = QtGui.QFileDialog.getOpenFileName(parent,title,startpath,filter)
        return g.u(s)
#@+node:ekr.20090722094828.3653: *5* runPropertiesDialog (qtGui)
def runPropertiesDialog(self,
    title='Properties',data={}, callback=None, buttons=None):

    """Dispay a modal TkPropertiesDialog"""

    # g.trace(data)
    g.es_print('Properties menu not supported for Qt gui',color='blue')
    result = 'Cancel'
    return result,data

    # d = propertiesDialog(title,data)
    # result = d.run()
    # return result
#@+node:ekr.20081121105001.489: *5* runSaveFileDialog
def runSaveFileDialog(self,initialfile='',title='Save',filetypes=[],defaultextension=''):

    """Create and run an Qt save file dialog ."""

    parent = None
    filter_ = self.makeFilter(filetypes)
    s = QtGui.QFileDialog.getSaveFileName(parent,title,os.curdir,filter_)
    return g.u(s)
#@+node:ekr.20081121105001.490: *5* runScrolledMessageDialog
def runScrolledMessageDialog (self,short_title= '',title='Message', label= '',msg='',c=None, **kw):

    if g.unitTesting: return None

    def send(title=title, label=label, msg=msg, c=c, kw=kw):
        return g.doHook('scrolledMessage',
            short_title=short_title,title=title,
            label=label, msg=msg,c=c, **kw)

    if not c or not c.exists:
        << no c error>>
    else:        
        retval = send()
        if retval: return retval
        << load scrolledmessage plugin >>
        retval = send()
        if retval: return retval
        << no dialog error >>

    << emergency fallback >>
#@+node:leohag.20081205043707.12: *6* << no c error>>
g.es_print_error('%s\n%s\n\t%s' % (
    "The qt plugin requires calls to g.app.gui.scrolledMessageDialog to include 'c'",
    "as a keyword argument",
    g.callers()
))
#@+node:leohag.20081205043707.14: *6* << load scrolledmessage plugin >>
pc = g.app.pluginsController
sm = pc.getPluginModule('scrolledmessage')

if not sm:
    sm = pc.loadOnePlugin('leo.plugins.scrolledmessage',verbose=True)
    if sm:
        g.es('scrolledmessage plugin loaded.', color='blue')
        sm.onCreate('tag',{'c':c})
#@+node:leohag.20081205043707.11: *6* << no dialog error >>
g.es_print_error(
    'No handler for the "scrolledMessage" hook.\n\t%s' % (
        g.callers()))
#@+node:leohag.20081205043707.13: *6* << emergency fallback >>
b = QtGui.QMessageBox
d = b(None) # c.frame.top)
d.setWindowFlags(QtCore.Qt.Dialog) # That is, not a fixed size dialog.

d.setWindowTitle(title)
if msg: d.setText(msg)
d.setIcon(b.Information)
yes = d.addButton('Ok',b.YesRole)
c.in_qt_dialog = True
d.exec_()
c.in_qt_dialog = False
#@+node:ekr.20081121105001.491: *4* Focus (qtGui)
def get_focus(self,c=None):

    """Returns the widget that has focus."""
    
    trace = False and not g.unitTesting
    verbose = False
    app = QtGui.QApplication
    w = app.focusWidget()
    if w and isinstance(w,LeoQTextBrowser):
        has_w = hasattr(w,'leo_wrapper') and w.leo_wrapper
        if has_w:
            if trace: g.trace(w)
        elif c:
            # Kludge: DynamicWindow creates the body pane
            # with wrapper = None, so return the leoQtBody.
            w = c.frame.body

    if trace: g.trace('***',w,g.callers())
    return w

def set_focus(self,c,w):

    """Put the focus on the widget."""

    trace = False and not g.unitTesting
    gui = self

    if w:
        if trace: print('qtGui.set_focus',gui.widget_name(w),w,g.callers(2))
        w.setFocus()
#@+node:ekr.20081121105001.522: *4*  Focus (leoQtBaseTextWidget)
def getFocus(self):

    # g.trace('leoQtBody',self.widget,g.callers(4))
    return g.app.gui.get_focus(self.c) # Bug fix: 2009/6/30

findFocus = getFocus

def hasFocus (self):

    val = self.widget == g.app.gui.get_focus(self.c)
    # g.trace('leoQtBody returns',val,self.widget,g.callers(4))
    return val

def setFocus (self):
    
    trace = False and not g.unitTesting

    if trace: print('leoQtBaseTextWidget.setFocus',
        # g.app.gui.widget_name(self.widget),
        self.widget,g.callers(3))
    
    # Call the base class
    assert (
        isinstance(self.widget,QtGui.QTextBrowser) or
        isinstance(self.widget,QtGui.QLineEdit) or
        isinstance(self.widget,QtGui.QTextEdit)),self.widget
    QtGui.QTextBrowser.setFocus(self.widget)
#@+node:ekr.20110527084258.18382: *3* Clicks in minibuffer act like Alt-x.  Most other clicks act like ctrl-g
#@+node:ekr.20110527140605.18371: *4* Tree...
#@+node:ekr.20090812211903.3641: *5* onItemClicked (nativeTree)
def onItemClicked (self,item,col):

    # This is called after an item is selected.
    trace = False and not g.unitTesting ; verbose = False

    if self.busy(): return

    c = self.c
    # if trace: g.trace(self.traceItem(item),g.callers(4))
    try:
        self.selecting = True
        p = self.item2position(item)
        if p:
            auto_edit = self.prev_v == p.v
            if trace: g.trace('auto_edit',auto_edit,p.h)
            self.prev_v = p.v
            event = None
            g.doHook("iconclick1",c=c,p=p,v=p,event=event)
            # if c.positionExists(p): c.selectPosition(p) # 2011/03/07
#@verbatim
            #@ c.frame.tree.OnIconDoubleClick(p) # Call the base class method.
            g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        else:
            auto_edit = None
            g.trace('*** no p')

        # 2011/05/27: click here is like ctrl-g.
        c.k.keyboardQuit(setFocus=False)
        c.treeWantsFocus() # 2011/05/08: Focus must stay in the tree!
        c.outerUpdate()
        # 2011/06/01: A second *single* click on a selected node
        # enters editing state.
        if auto_edit and self.auto_edit:
            e,wrapper = self.createTreeEditorForItem(item)
    finally:
        self.selecting = False
#@+node:ekr.20110527140605.18372: *4* Minibuffer
#@+node:ekr.20081121105001.594: *5* class leoQtMinibuffer (leoQLineEditWidget)
class leoQtMinibuffer (leoQLineEditWidget):

    def __init__ (self,c):
        self.c = c
        w = c.frame.top.leo_ui.lineEdit # QLineEdit
        # g.trace('(leoQtMinibuffer)',w)
        
        # Init the base class.
        leoQLineEditWidget.__init__(self,widget=w,name='minibuffer',c=c)

        self.ev_filter = leoQtEventFilter(c,w=self,tag='minibuffer')
        w.installEventFilter(self.ev_filter)
    
        # Monkey-patch the event handlers
        << define mouseReleaseEvent >>
        w.mouseReleaseEvent = mouseReleaseEvent

    def setBackgroundColor(self,color):
        # Called from k.setLabelGrey & k.setLabelBlue.
        # g.trace(color,g.callers())
        self.widget.setStyleSheet('background-color:%s' % color)

    def setForegroundColor(self,color):
        pass
#@+node:ekr.20110527140605.18359: *6* << define mouseReleaseEvent >> (leoQtMinibuffer)
def mouseReleaseEvent (*args,**keys):
    
    '''Override QLineEdit.mouseReleaseEvent.
    
    Simulate alt-x if we are not in an input state.'''
    
    # Important: c and w must be unbound here.
    k = c.k
    
    # g.trace(args,keys)
    
    # Call the base class method.
    if len(args) == 1:
        event = args[0]
        QtGui.QLineEdit.mouseReleaseEvent(w,event)
        
    elif len(args) == 2:
        event = args[1]
        #QtGui.QTextBrowser.mouseReleaseEvent(*args)
        QtGui.QLineEdit.mouseReleaseEvent(*args)
    else:
        g.trace('can not happen')
        return

    # g.trace('state',k.state.kind,k.state.n)
    if not k.state.kind:
        event2 = leoKeyEvent(event=None,
            c=c,w=c.frame.body.bodyCtrl,ch='',tkKey='',stroke='')
        k.fullCommand(event2)
#@+node:ekr.20110527140605.18373: *4* Body & Log
#@+node:ekr.20081121105001.518: *5* ctor (leoQtBaseTextWidget)
def __init__ (self,widget,name='leoQtBaseTextWidget',c=None):

    self.widget = widget
    self.c = c or self.widget.leo_c

    # g.trace('leoQtBaseTextWidget',name,self.widget)

    # Init the base class.
    leoFrame.baseTextWidget.__init__(
        self,c,baseClassName='leoQtBaseTextWidget',
        name=name,
        widget=widget,
        highLevelInterface=True)

    # Init ivars.
    self.changingText = False # A lockout for onTextChanged.
    self.tags = {}
    self.permanent = True # False if selecting the minibuffer will make the widget go away.
    self.configDict = {} # Keys are tags, values are colors (names or values).
    self.configUnderlineDict = {} # Keys are tags, values are True
    self.useScintilla = False # This is used!

    if not c: return # Can happen.

    if name in ('body','rendering-pane-wrapper') or name.startswith('head'):
        # g.trace('hooking up qt events',name)
        # Hook up qt events.
        self.ev_filter = leoQtEventFilter(c,w=self,tag=name)
        self.widget.installEventFilter(self.ev_filter)

    if name == 'body':
        self.widget.connect(self.widget,
            QtCore.SIGNAL("textChanged()"),self.onTextChanged)

        self.widget.connect(self.widget,
            QtCore.SIGNAL("cursorPositionChanged()"),self.onCursorPositionChanged)
            
    if name in ('body','log'):
        # Monkey patch the event handler.
        << define mouseReleaseEvent >>
        self.widget.mouseReleaseEvent = mouseReleaseEvent

    self.injectIvars(c)
#@+node:ekr.20110527140605.18370: *6* << define mouseReleaseEvent >> (leoQtBaseTextWidget)
def mouseReleaseEvent (*args,**keys):
    
    '''Override QLineEdit.mouseReleaseEvent.
    
    Simulate alt-x if we are not in an input state.'''
    
    # g.trace(args,keys)
    
    # Call the base class method.
    if len(args) == 1:
        event = args[0]
        QtGui.QTextBrowser.mouseReleaseEvent(widget,event) # widget is unbound.
    elif len(args) == 2:
        event = args[1]
        QtGui.QTextBrowser.mouseReleaseEvent(*args)
    else:
        g.trace('can not happen')
        return

    # Open the url on a control-click.
    if QtCore.Qt.ControlModifier & event.modifiers():
        event = {'c':c}
        openURL(event) # A module-level function.

    # 2011/05/28: Do *not* change the focus!
    # This would rip focus away from tab panes.
    c.k.keyboardQuit(setFocus=False)
#@+node:ekr.20090629160050.3737: *5* signals (leoQtBaseTextWidget)
#@+node:ekr.20081208041503.499: *6* onCursorPositionChanged (leoQtBaseTextWidget)
def onCursorPositionChanged(self,event=None):

    trace = False and not g.unitTesting

    c = self.c
    name = c.widget_name(self)

    if trace: g.trace('(leoQtBaseTextWidget)',name,g.callers())

    if name.startswith('body'):
        if hasattr(c.frame,'statusLine'):
            c.frame.statusLine.update()
#@+node:ekr.20110601080718.19340: *3* Single-click on selected headline edits the headline
@nocolor-node

Only onItemClick changed.
#@+node:ekr.20090812211903.3641: *4* onItemClicked (nativeTree)
def onItemClicked (self,item,col):

    # This is called after an item is selected.
    trace = False and not g.unitTesting ; verbose = False

    if self.busy(): return

    c = self.c
    # if trace: g.trace(self.traceItem(item),g.callers(4))
    try:
        self.selecting = True
        p = self.item2position(item)
        if p:
            auto_edit = self.prev_v == p.v
            if trace: g.trace('auto_edit',auto_edit,p.h)
            self.prev_v = p.v
            event = None
            g.doHook("iconclick1",c=c,p=p,v=p,event=event)
            # if c.positionExists(p): c.selectPosition(p) # 2011/03/07
#@verbatim
            #@ c.frame.tree.OnIconDoubleClick(p) # Call the base class method.
            g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        else:
            auto_edit = None
            g.trace('*** no p')

        # 2011/05/27: click here is like ctrl-g.
        c.k.keyboardQuit(setFocus=False)
        c.treeWantsFocus() # 2011/05/08: Focus must stay in the tree!
        c.outerUpdate()
        # 2011/06/01: A second *single* click on a selected node
        # enters editing state.
        if auto_edit and self.auto_edit:
            e,wrapper = self.createTreeEditorForItem(item)
    finally:
        self.selecting = False
#@+node:ekr.20110601164458.19313: *3* Fixed weird monkey-patch bug in two mouseReleaseEvent methods
#@+node:ekr.20110604043410.16738: ** Leo 4.9 b2
#@+node:ekr.20110602133526.16782: *3* ctrl-H and double-click now colorized the same
#@+node:ekr.20090124174652.56: *4* editLabel (nativeTree)
def editLabel (self,p,selectAll=False,selection=None):

    """Start editing p's headline."""

    trace = False and not g.unitTesting
    if self.busy(): return
    c = self.c
    c.outerUpdate()
        # Do any scheduled redraw.
        # This won't do anything in the new redraw scheme.

    item = self.position2item(p)
    if item:
        e,wrapper = self.editLabelHelper(item,selectAll,selection)
    else:
        e = None
        self.error('no item for %s' % p)

    # A nice hack: just set the focus request.
    if e: c.requestedFocusWidget = e
    
    if trace: g.trace(e,wrapper,g.callers())
    return e,wrapper # 2011/02/12
#@+node:ekr.20090129062500.13: *4* editLabelHelper (leoQtTree)
def editLabelHelper (self,item,selectAll=False,selection=None):

    '''Called by nativeTree.editLabel to do
    gui-specific stuff.'''

    trace = False and not g.unitTesting
    w = self.treeWidget
    w.setCurrentItem(item) # Must do this first.
    w.editItem(item)
        # Generates focus-in event that tree doesn't report.
    e = w.itemWidget(item,0) # A QLineEdit.

    if e:
        s = e.text() ; len_s = len(s)
        if s == 'newHeadline': selectAll=True
        if selection:
            i,j,ins = selection
            start,n = i,abs(i-j)
                # Not right for backward searches.
        elif selectAll: start,n,ins = 0,len_s,len_s
        else:           start,n,ins = len_s,0,len_s
        e.setObjectName('headline')
        e.setSelection(start,n)
        # e.setCursorPosition(ins) # Does not work.
        e.setFocus()
        wrapper = self.connectEditorWidget(e,item) # Hook up the widget.

    if trace: g.trace(e,wrapper)
    return e,wrapper # 2011/02/11
#@+node:ekr.20090124174652.41: *4* onItemDoubleClicked (nativeTree)
def onItemDoubleClicked (self,item,col):

    trace = False and not g.unitTesting
    verbose = False

    if self.busy(): return

    c = self.c

    if trace: g.trace(col,self.traceItem(item),g.callers(4))

    try:
        self.selecting = True

        e,wrapper = self.createTreeEditorForItem(item)
        if e:
            wrapper.setEditorColors(c.k.insert_mode_bg_color,'(not used)')
        else:
            g.trace('*** no e')

        p = self.item2position(item)
        if p:
            event = None
            g.doHook("icondclick1",c=c,p=p,v=p,event=event)
            c.frame.tree.OnIconDoubleClick(p) # Call the base class method.
            g.doHook("icondclick2",c=c,p=p,v=p,event=event)
        else:
            g.trace('*** no p')

        c.outerUpdate()
    finally:
        self.selecting = False
#@+node:ekr.20090124174652.104: *4* createTreeEditorForItem (leoQtTree)
def createTreeEditorForItem(self,item):

    trace = False and not g.unitTesting

    w = self.treeWidget
    w.setCurrentItem(item) # Must do this first.
    w.editItem(item)
    e = w.itemWidget(item,0)
    e.setObjectName('headline')
    wrapper = self.connectEditorWidget(e,item)
    
    if trace: g.trace(e,wrapper)

    return e,wrapper
#@+node:ekr.20090322190318.10: *4* connectEditorWidget & helper
def connectEditorWidget(self,e,item):

    c = self.c ; w = self.treeWidget

    if not e: return g.trace('can not happen: no e')

    wrapper = self.getWrapper(e,item)

    # Hook up the widget.
    def editingFinishedCallback(e=e,item=item,self=self,wrapper=wrapper):
        # g.trace(wrapper,g.callers(5))
        c = self.c ; w = self.treeWidget
        self.onHeadChanged(p=c.p,e=e)
        w.setCurrentItem(item)

    e.connect(e,QtCore.SIGNAL(
        "editingFinished()"),
        editingFinishedCallback)
        
    return wrapper # 2011/02/12
#@+node:ekr.20090602083443.3817: *4* getWrapper (leoQtTree)
def getWrapper (self,e,item):

    '''Return headlineWrapper that wraps e (a QLineEdit).'''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c
    
    if e:
        wrapper = self.editWidgetsDict.get(e)
        if wrapper:
            if trace and verbose: g.trace('old wrapper',e,wrapper)
        else:
            if item:
                # 2011/02/12: item can be None.
                wrapper = self.headlineWrapper(c,item,name='head',widget=e)
                if trace: g.trace('new wrapper',e,wrapper,g.callers())
                self.editWidgetsDict[e] = wrapper
            else:
                if trace: g.trace('no item and no wrapper',
                    e,self.editWidgetsDict)
        return wrapper
    else:
        g.trace('no e')
        return None
#@-all
#@-leo
