#@+leo-ver=4-thin
#@+node:ekr.20081016072304.13:@thin qtNotes.txt
#@+all
#@+node:ekr.20081010070648.5: To do
@nocolor-node

First:
* (Done?) Make sure Leo handle's non-ascii characters properly.
- Disable automatic horizontal tree scrolling.
* Merge into trunk.

Next:
- Finish colorizer.
- Shift-tab is Smart home. (Allow shift-tab binding).
- Fix minor pylint stuff.

Next:
- Make auto-scrolling an option (full_redraw and redraw_after_select)
- Allow coloring of icon bar buttons.
- Support multiple body editors.
- Clicks in body text do not update row/column position.
- Handle pane orientation:
    A popular arrangement would be editor and outline
    in top pane with the log along the bottom.

Finally:
- Install new Qt version and play with QScintilla.
    From QScintilla change log:
    2008/10/12 14:32:05  phil
    QsciScintilla::setSelection() is now implemented using SCI_SETSEL so that the
    carat can be left at either the start or the end of the selection.
    Exposed QsciScintilla::positionFromLineIndex() and
    QsciScintilla::lineIndexFromPosition().
- Add stylesheets for dialogs.
    - Set font for dummy widget in style sheet, then copy that font.
#@+node:ekr.20081109123309.13:Finish colorizer
- Simulate Tk's handling of tags (an optimization)
- Use Qt threading.
- Handle all colorizer tags.
#@nonl
#@-node:ekr.20081109123309.13:Finish colorizer
#@+node:ekr.20081109123309.14:QScintilla stuff
- Check event handling with QScintilla.
- Experiment with sending <shift-tab> directly to QScintilla.
- Call setLexer(0) for nocolor nodes.
- Add settings for syntax coloring.
     - Make Scintilla handle Leo markup.
#@nonl
#@-node:ekr.20081109123309.14:QScintilla stuff
#@+node:ekr.20081109123309.15:To do in trunk
- Make tkinter code a plugin.
    - If no gui specified on command line,
      use the first gui that can be imported.
- Support @ifgui in settings trees.
#@nonl
#@-node:ekr.20081109123309.15:To do in trunk
#@+node:ekr.20081029050144.10:Finally/maybe
- Can style sheets really do the job?
- Flash characters without changing the selection?
- Remove old-style Leo settings?
#@-node:ekr.20081029050144.10:Finally/maybe
#@-node:ekr.20081010070648.5: To do
#@+node:ekr.20081019082316.10:New features in the core
@nocolor-node

- Added support for --gui=qt and --gui=tk command-line options.
#@nonl
#@-node:ekr.20081019082316.10:New features in the core
#@+node:ekr.20081017015442.15:pylint errors
# Hard to fix
W0221:4426:leoQtMenu.add_command: Arguments number differs from overridden method
W0221:4607:leoQtMenu.getMenuLabel: Arguments number differs from overridden method
#@-node:ekr.20081017015442.15:pylint errors
#@+node:ekr.20081014095718.13:Recent projects...
#@+node:ekr.20081015062931.10:Focus stuff...
#@+node:ekr.20081014095718.15:get_name (qtTree)
def getName (self):

    name = 'canvas(tree)' # Must start with canvas.

    return name
#@-node:ekr.20081014095718.15:get_name (qtTree)
#@+node:ekr.20081004172422.621:Qt bindings... (qtFrame)
def bringToFront (self):
    self.top.showNormal()
def deiconify (self):
    self.top.showNormal()
def getFocus(self):
    return g.app.gui.get_focus() 
def get_window_info(self):
    rect = self.top.geometry()
    topLeft = rect.topLeft()
    x,y = topLeft.x(),topLeft.y()
    w,h = rect.width(),rect.height()
    return w,h,x,y
def iconify(self):
    g.trace()
    self.top.showMinimized()
def lift (self):
    self.top.activateWindow()
def update (self):
    pass
def getTitle (self):
    return g.toUnicode(self.top.windowTitle(),'utf-8')
def setTitle (self,s):
    self.top.setWindowTitle(s)
def setTopGeometry(self,w,h,x,y,adjustSize=True):
    self.top.setGeometry(QtCore.QRect(x,y,w,h))
#@-node:ekr.20081004172422.621:Qt bindings... (qtFrame)
#@+node:ekr.20081004172422.865:add_command
def add_command (self,**keys):

    """Wrapper for the Tkinter add_command menu method."""

    c = self.c
    accel = keys.get('accelerator') or ''
    command = keys.get('command')
    label = keys.get('label')
    n = keys.get('underline')
    menu = keys.get('menu') or self
    if not label: return

    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    if accel:
        label = '%s\t%s' % (label,accel)

    action = menu.addAction(label)

    if command:
        def add_command_callback(label=label,command=command):
            return command()

        QtCore.QObject.connect(action,
            QtCore.SIGNAL("triggered()"),add_command_callback)
#@-node:ekr.20081004172422.865:add_command
#@+node:ekr.20081004102201.676:class leoKeyEvent
class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c,w,tkKey):

        # Last minute-munges to keysym.
        d = {
            '\r':'Return',
            '\n':'Return',
            '\t':'Tab',
        }

        # The main ivars.
        self.actualEvent = event
        self.c      = c
        self.char   = tkKey
        self.keysym = d.get(tkKey,tkKey)
        self.w = self.widget = w # A leoQtX object

        # Auxiliary info.
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0
        # Support for fastGotoNode plugin
        self.x_root = hasattr(event,'x_root') and event.x_root or 0
        self.y_root = hasattr(event,'y_root') and event.y_root or 0

    def __repr__ (self):

        return 'qtGui.leoKeyEvent: char: %s, keysym: %s' % (repr(self.char),repr(self.keysym))
#@-node:ekr.20081004102201.676:class leoKeyEvent
#@+node:ekr.20081004172422.510: Focus
def getFocus(self):

    g.trace('leoQtBody',self.widget,g.callers(4))
    return g.app.gui.get_focus()

findFocus = getFocus

def hasFocus (self):

    val = self.widget == g.app.gui.get_focus(self.c)
    # g.trace('leoQtBody returns',val,self.widget,g.callers(4))
    return val

def setFocus (self):

    # g.trace('leoQtBody',self.widget,g.callers(4))
    g.app.gui.set_focus(self.c,self.widget)
#@-node:ekr.20081004172422.510: Focus
#@+node:ekr.20081004102201.657:Focus (qtGui)
def get_focus(self,c=None):

    """Returns the widget that has focus."""

    w = QtGui.QApplication.focusWidget()
    # g.trace('leoQtGui',w)
    return w

def set_focus(self,c,w):

    """Put the focus on the widget."""

    if w:
        # g.trace('leoQtGui',w,g.callers(4))
        w.setFocus()
#@-node:ekr.20081004102201.657:Focus (qtGui)
#@+node:ekr.20081015062931.11:widget_name (qtGui)
def widget_name (self,w):

    # First try the widget's getName method.
    if not 'w':
        name = '<no widget>'
    elif hasattr(w,'getName'):
        name = w.getName()
    elif hasattr(w,'objectName'):
        name = str(w.objectName())
        # if name == 'treeWidget':
            # name = 'canvas(treeWidget)'
    elif hasattr(w,'_name'):
        name = w._name
    else:
        name = repr(w)

    # g.trace(name,w,g.callers(4))
    return name
#@-node:ekr.20081015062931.11:widget_name (qtGui)
#@+node:ekr.20081004102201.628:class leoQtEventFilter
class leoQtEventFilter(QtCore.QObject):

    << about internal bindings >>

    @others
#@+node:ekr.20081007115148.6:<< about internal bindings >>
@nocolor-node
@

Here are the rules for translating key bindings (in leoSettings.leo) into keys for k.bindingsDict:

1.  The case of plain letters is significant:  a is not A.

2. The Shift- prefix can be applied *only* to letters. Leo will ignore (with a
warning) the shift prefix applied to any other binding, e.g., Ctrl-Shift-(

3. The case of letters prefixed by Ctrl-, Alt-, Key- or Shift- is *not*
significant. Thus, the Shift- prefix is required if you want an upper-case
letter (with the exception of 'bare' uppercase letters.)

The following table illustrates these rules. In each row, the first entry is the
key (for k.bindingsDict) and the other entries are equivalents that the user may
specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
!, Key-!,Key-exclam,exclam

This table is consistent with how Leo already works (because it is consistent
with Tk's key-event specifiers). It is also, I think, the least confusing set of
rules.
#@nonl
#@-node:ekr.20081007115148.6:<< about internal bindings >>
#@+node:ekr.20081018155359.10: ctor
def __init__(self,c,w,tag=''):

    # Init the base class.
    QtCore.QObject.__init__(self)

    self.c = c
    self.w = w      # A leoQtX object, *not* a Qt object.
    self.tag = tag

    # Pretend there is a binding for these characters.
    close_flashers = c.config.getString('close_flash_brackets') or ''
    open_flashers  = c.config.getString('open_flash_brackets') or ''
    self.flashers = open_flashers + close_flashers


#@-node:ekr.20081018155359.10: ctor
#@+node:ekr.20081013143507.12:eventFilter
def eventFilter(self, obj, event):

    c = self.c ; k = c.k 
    trace = False ; verbose = True
    eventType = event.type()
    ev = QtCore.QEvent
    kinds = (ev.ShortcutOverride,ev.KeyPress,ev.KeyRelease)

    if eventType in kinds:
        tkKey,ch,ignore = self.toTkKey(event)
        aList = c.k.masterGuiBindingsDict.get('<%s>' %tkKey,[])

        if ignore:
            override = False
        elif self.isSpecialOverride(tkKey,ch):
            override = True
        elif k.inState():
            override = not ignore # allow all keystrokes.
        elif safe_mode:
            override = len(aList) > 0 and not self.isDangerous(tkKey,ch)
        else:
            override = len(aList) > 0
    else:
        override = False ; tkKey = '<no key>'

    if eventType == ev.KeyPress:
        if override:
            w = self.w # Pass the wrapper class, not the wrapped widget.
            stroke = self.toStroke(tkKey,ch)
            leoEvent = leoKeyEvent(event,c,w,ch) # ch was stroke
            ret = k.masterKeyHandler(leoEvent,stroke=stroke)
            c.outerUpdate()
        else:
            if trace: g.trace(self.tag,'unbound',tkKey)

    if trace: self.traceEvent(obj,event,tkKey,override)

    return override
#@-node:ekr.20081013143507.12:eventFilter
#@+node:ekr.20081015132934.10:isDangerous
def isDangerous (self,tkKey,ch):

    c = self.c

    if not c.frame.body.useScintilla: return False

    arrows = ('home','end','left','right','up','down')
    special = ('tab','backspace','period','parenright','parenleft')

    key = tkKey.lower()
    ch = ch.lower()
    isAlt = key.find('alt') > -1
    w = g.app.gui.get_focus()
    inTree = w == self.c.frame.tree.treeWidget

    val = (
        key in special or
        ch in arrows and not inTree and not isAlt or
        key == 'return' and not inTree # Just barely works.
    )

    # g.trace(tkKey,ch,val)
    return val
#@-node:ekr.20081015132934.10:isDangerous
#@+node:ekr.20081111065912.10:isSpecialOverride
def isSpecialOverride (self,tkKey,ch):

    # g.trace(repr(tkKey),repr(ch))

    if tkKey == 'Tab':
        return True
    elif len(tkKey) == 1:
        return True # Must process all ascii keys.
    elif ch in self.flashers:
        return True
    else:
        return False
#@-node:ekr.20081111065912.10:isSpecialOverride
#@+node:ekr.20081011152302.10:toStroke
def toStroke (self,tkKey,ch):

    k = self.c.k ; s = tkKey ; trace = False

    special = ('Alt','Ctrl','Control',)
    isSpecial = [True for z in special if s.find(z) > -1]

    if not isSpecial:
        # Keep the Tk spellings for special keys.
        ch2 = k.guiBindNamesDict.get(ch) # was inverseDict
        if trace: g.trace('ch',repr(ch),'ch2',repr(ch2))
        if ch2: s = s.replace(ch,ch2)

    table = (
        ('Alt-','Alt+'),
        ('Ctrl-','Ctrl+'),
        ('Control-','Ctrl+'),
        # Use Alt+Key-1, etc.  Sheesh.
        # ('Key-','Key+'),
        ('Shift-','Shift+')
    )
    for a,b in table:
        s = s.replace(a,b)

    if trace: g.trace('tkKey',tkKey,'-->',s)
    return s
#@-node:ekr.20081011152302.10:toStroke
#@+node:ekr.20081008084746.1:toTkKey & helpers
def toTkKey (self,event):

    mods = self.qtMods(event)

    keynum,text,toString,ch = self.qtKey(event)

    tkKey,ch,ignore = self.tkKey(
        event,mods,keynum,text,toString,ch)

    return tkKey,ch,ignore
#@+node:ekr.20081024164012.10:isFKey
def isFKey(self,ch):

    return (
        ch and len(ch) in (2,3) and
        ch[0].lower() == 'f' and
        ch[1:].isdigit()
    )
#@-node:ekr.20081024164012.10:isFKey
#@+node:ekr.20081028055229.1:qtKey
def qtKey (self,event):

    '''Return the components of a Qt key event.'''

    keynum = event.key()
    text   = event.text()
    toString = QtGui.QKeySequence(keynum).toString()
    try:
        ch = chr(keynum)
    except ValueError:
        ch = ''
    encoding = 'utf-8'
    ch       = g.toUnicode(ch,encoding)
    text     = g.toUnicode(text,encoding)
    toString = g.toUnicode(toString,encoding)

    return keynum,text,toString,ch


#@-node:ekr.20081028055229.1:qtKey
#@+node:ekr.20081028055229.2:qtMods
def qtMods (self,event):

    modifiers = event.modifiers()

    # The order of this table is significant.
    # It must the order of modifiers in bindings
    # in k.masterGuiBindingsDict

    table = (
        (QtCore.Qt.AltModifier,     'Alt'),
        (QtCore.Qt.ControlModifier, 'Control'),
        (QtCore.Qt.MetaModifier,    'Meta'),
        (QtCore.Qt.ShiftModifier,   'Shift'),
    )

    mods = [b for a,b in table if (modifiers & a)]

    return mods
#@-node:ekr.20081028055229.2:qtMods
#@+node:ekr.20081028055229.3:tkKey & helpers
def tkKey (self,event,mods,keynum,text,toString,ch):

    '''Carefully convert the Qt key to a 
    Tk-style binding compatible with Leo's core
    binding dictionaries.'''

    k = self.c.k ; trace = False ; verbose = True

    special = {
        'Backspace':'BackSpace',
        'Esc':'Escape',
    }

    # Convert '&' to 'ampersand', for example.
    ch2 = k.guiBindNamesDict.get(ch or toString)

    if not ch: ch = ch2
    if not ch: ch = ''

    # Handle special cases.
    ch3 = special.get(toString)
    if ch3: ch = ch3

    ch4 = k.guiBindNamesDict.get(ch)
    if ch4: ch = ch4

    if trace and verbose: g.trace(
'keynum: %s, mods: %s text: %s, toString: %s, '
'ch: %s, ch2: %s, ch3: %s, ch4: %s' % (
keynum,mods,repr(text),toString,
repr(ch),repr(ch2),repr(ch3),repr(ch4)))

    if 'Shift' in mods:
        mods,ch = self.shifted(mods,ch)
    elif len(ch) == 1:
        ch = ch.lower()

    if 'Alt' in mods and ch and ch in string.digits:
        mods.append('Key')

    tkKey = '%s%s%s' % ('-'.join(mods),mods and '-' or '',ch)
    ignore = not ch

    if trace and (ignore or verbose):
        g.trace('tkKey: %s, ch: %s, ignore: %s' % (
            repr(tkKey),repr(ch),ignore))

    ch = text or toString # was ch
    return tkKey,ch,ignore
#@+node:ekr.20081028055229.16:keyboardUpper1
def keyboardUpper1 (self,ch):

    '''A horrible, keyboard-dependent hack.

    Return the upper-case version of the given character
    whose original spelling has length == 1.'''

    d = {
        '1':'exclam',
        '2':'at',
        '3':'numbersign',
        '4':'dollar',
        '5':'percent',
        '6':'asciicircum',
        '7':'ampersand',
        '8':'asterisk',
        '9':'parenleft',
        '0':'parenright',
    }

    # g.trace(ch,d.get(ch))
    return d.get(ch)

#@-node:ekr.20081028055229.16:keyboardUpper1
#@+node:ekr.20081028055229.17:keyboardUpperLong
def keyboardUpperLong (self,ch):

    '''A horrible, keyboard-dependent hack.

    Return the upper-case version of the given character
    whose original spelling has length > 1.'''

    d = {
        "quoteleft":    "asciitilde",
        "minus":        "underscore",
        "equal":        "plus",
        "bracketleft":  "braceleft",
        "bracketright": "braceright",
        "semicolon":    "colon",
        "quoteright":   "quotedbl",
        "backslash":    "bar",
        "comma":        "less",
        "period":       "greater",
        "slash":        "question",
    }
    # g.trace(ch,d.get(ch))
    return d.get(ch)
#@-node:ekr.20081028055229.17:keyboardUpperLong
#@+node:ekr.20081028055229.14:shifted
def shifted (self,mods,ch):
    '''
        A horrible, keyboard-dependent kludge.
        return the shifted version of the letter.
        return mods, ch.
    '''

    # Special tk symbols, like '&' have already
    # been converted to names like 'ampersand'.

    # These special characters should be handled in Leo's core.
    noShiftList = ('Return','BackSpace','Tab',)

    special = ('Home','End','Right','Left','Up','Down',)

    if len(ch) == 1:
        ch2 = self.keyboardUpper1(ch)
        if ch2:
            mods.remove('Shift')
            ch = ch2
        elif len(ch) == 1:
            # Correct regardless of alt/ctrl mods.
            mods.remove('Shift')
            ch = ch.upper()
        elif len(mods) == 1: # No alt/ctrl.
            mods.remove('Shift')
        else:
            pass
    else:
        ch3 = self.keyboardUpperLong(ch)
        if ch3: ch = ch3

        if ch3 or ch in noShiftList:
            mods.remove('Shift')
        elif ch in special:
            pass # Allow the shift.
        elif len(mods) == 1: # No alt/ctrl.
            mods.remove('Shift')
        else:
            pass # Retain shift modifier for all special keys.

    return mods,ch
#@-node:ekr.20081028055229.14:shifted
#@+node:ekr.20081028134004.11:shifted2
# This idea doesn't work.  The key-code in the ctor overrides everything else.

def shifted2 (self,event):

    mods = event.modifiers()
    mods2 = mods & QtCore.Qt.ShiftModifier

    event2 = QtGui.QKeyEvent (
        QtCore.QEvent.KeyPress,
        event.key(),mods2,event.text())

    encoding = 'utf-8'
    keynum = event2.key()
    text   = g.toUnicode(event2.text(),encoding)
    toString = g.toUnicode(QtGui.QKeySequence(keynum).toString(),encoding)
    mods = self.qtMods(event2)

    g.trace(
        'keynum: %s, mods: %s text: %s, toString: %s' % (
        keynum,mods,repr(text),toString))
#@-node:ekr.20081028134004.11:shifted2
#@-node:ekr.20081028055229.3:tkKey & helpers
#@-node:ekr.20081008084746.1:toTkKey & helpers
#@+node:ekr.20081013143507.11:traceEvent
def traceEvent (self,obj,event,tkKey,override):

    c = self.c ; e = QtCore.QEvent

    eventType = event.type()

    if 0: # Show focus events.
        show = (
            (e.FocusIn,'focus-in'),(e.FocusOut,'focus-out'),
            (e.Enter,'enter'),(e.Leave,'leave'),
        )

    else:
        show = (
            (e.KeyPress,'key-press'),(e.KeyRelease,'key-release'),
            (e.ShortcutOverride,'shortcut-override'),
        )

    ignore = (
        e.ToolTip,
        e.FocusIn,e.FocusOut,e.Enter,e.Leave,
        e.MetaCall,e.Move,e.Paint,e.Resize,
        e.Polish,e.PolishRequest,
    )

    for val,kind in show:
        if eventType == val:
            g.trace(
            'tag: %s, kind: %s, in-state: %s, key: %s, override: %s' % (
            self.tag,kind,repr(c.k.inState()),tkKey,override))
            return

    # if trace: g.trace(self.tag,
        # 'bound in state: %s, key: %s, returns: %s' % (
        # k.getState(),tkKey,ret))

    if False and eventType not in ignore:
        g.trace('%3s:%s' % (eventType,'unknown'))
#@-node:ekr.20081013143507.11:traceEvent
#@-node:ekr.20081004102201.628:class leoQtEventFilter
#@+node:ekr.20081004172422.846:editLabel (override)
def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c ; trace = True ; verbose = False

    if self.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if self._editWidget:
        # Not an error, because of key weirdness.
        g.trace('already editing')
        return

    if trace:
        g.trace('*** all',selectAll,p.headString(),g.callers(4))

    w = self.treeWidget
    data = self.vnodeDict.get(p.v)
    if not data:
        if trace and verbose:
            g.trace('No data: redrawing if possible')
        c.outerUpdate() # Do any scheduled redraw.
        data = self.vnodeDict.get(p.v)

    if data:
        item = data [0][1]
    else:
        if trace and not g.app.unitTesting:
            g.trace('*** Can not happen: no data',p and p.headString())
        return None

    if item:
        w.setCurrentItem(item) # Must do this first.
        w.editItem(item)
        e = w.itemWidget(item,0) # A QLineEdit
        if e:
            s = e.text() ; len_s = len(s)
            # Hook up the widget to Leo's core.
            self._editWidgetPosition = p.copy()
            self._editWidget = e
            self._editWidgetWrapper = leoQtHeadlineWidget(
                widget=e,name='head',c=c)
            start,n = g.choose(selectAll,
                tuple([0,len_s]),tuple([len_s,0]))
            e.setObjectName('headline')
            e.setSelection(start,n)
            e.setFocus()
        else: g.trace('*** no e')
    else:
        self._editWidgetPosition = None
        self._editWidget = None
        self._editWidgetWrapper = None
        e = None
        g.trace('*** no item')

    # A nice hack: just set the focus request.
    c.requestedFocusWidget = e
#@-node:ekr.20081004172422.846:editLabel (override)
#@-node:ekr.20081015062931.10:Focus stuff...
#@+node:ekr.20081018155359.12:Problems with multiple windows
#@+node:ekr.20081004102201.629:class  Window
class Window(QtGui.QMainWindow):

    '''A class representing all parts of the main Qt window
    as created by Designer.

    c.frame.top is a Window object.

    All leoQtX classes use the ivars of this Window class to
    support operations requested by Leo's core.
    '''

    @others

#@+node:ekr.20081004172422.884: ctor (Window)
# Called from leoQtFrame.finishCreate.

def __init__(self,c,parent=None):

    '''Create Leo's main window, c.frame.top'''

    self.c = c ; top = c.frame.top

    # g.trace('Window')

    # Init both base classes.
    QtGui.QMainWindow.__init__(self,parent)
    #qt_main.Ui_MainWindow.__init__(self)

    self.ui = qt_main.Ui_MainWindow()
    # Init the QDesigner elements.
    self.ui.setupUi(self)

    # The following ivars (and more) are inherited from UiMainWindow:
        # self.lineEdit   = QtGui.QLineEdit(self.centralwidget) # The minibuffer.
        # self.menubar    = QtGui.QMenuBar(MainWindow)          # The menu bar.
        # self.tabWidget  = QtGui.QTabWidget(self.splitter)     # The log pane.
        # self.textEdit   = Qsci.QsciScintilla(self.splitter_2) # The body pane.
        # self.treeWidget = QtGui.QTreeWidget(self.splitter)    # The tree pane.

    self.iconBar = self.addToolBar("IconBar")
    self.statusBar = QtGui.QStatusBar()
    self.setStatusBar(self.statusBar)

    self.setStyleSheets()
#@-node:ekr.20081004172422.884: ctor (Window)
#@+node:ekr.20081020075840.11:closeEvent (qtFrame)
def closeEvent (self,event):

    c = self.c

    if c.inCommand:
        # g.trace('requesting window close')
        c.requestCloseWindow = True
    else:
        ok = g.app.closeLeoWindow(c.frame)
        # g.trace('ok',ok)
        if ok:
            event.accept()
        else:
            event.ignore()
#@-node:ekr.20081020075840.11:closeEvent (qtFrame)
#@+node:ekr.20081016072304.14:setStyleSheets & helper
styleSheet_inited = False

def setStyleSheets(self):

    c = self.c

    sheet = c.config.getData('qt-gui-plugin-style-sheet')
    if sheet: sheet = '\n'.join(sheet)
    self.setStyleSheet(sheet or self.default_sheet())
#@nonl
#@+node:ekr.20081018053140.10:defaultStyleSheet
def defaultStyleSheet (self):

    '''Return a reasonable default style sheet.'''

    # Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords
    return '''\

/* A QWidget: supports only background attributes.*/
QSplitter::handle {

    background-color: #CAE1FF; /* Leo's traditional lightSteelBlue1 */
}
QSplitter {
    border-color: white;
    background-color: white;
    border-width: 3px;
    border-style: solid;
}
QTreeWidget {
    background-color: #ffffec; /* Leo's traditional tree color */
}
/* Not supported. */
QsciScintilla {
    background-color: pink;
}
'''
#@-node:ekr.20081018053140.10:defaultStyleSheet
#@-node:ekr.20081016072304.14:setStyleSheets & helper
#@-node:ekr.20081004102201.629:class  Window
#@-node:ekr.20081018155359.12:Problems with multiple windows
#@+node:ekr.20081020075840.21:Suppress updates until init complete
#@+node:ekr.20081020075840.20:initCompleteHint
def initCompleteHint (self):

    '''A kludge: called to enable text changed events.'''

    self.initComplete = True
    # g.trace(self.c)
#@-node:ekr.20081020075840.20:initCompleteHint
#@+node:ekr.20081011035036.1:onTextChanged
def onTextChanged (self):

    '''Update Leo after the body has been changed.

    self.selecting is guaranteed to be True during
    the entire selection process.'''

    c = self.c ; p = c.currentPosition()
    tree = c.frame.tree ; w = self
    trace = True ; verbose = False

    if tree.selecting:
        if trace and verbose: g.trace('selecting')
        return
    if tree.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if not p:
        return g.trace('*** no p')

    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText() # Converts to unicode.

    # Get the previous values from the tnode.
    oldText = g.toUnicode(p.v.t._bodyString,"utf-8")
    if oldText == newText:
        # This can happen as the result of undo.
        # g.trace('*** unexpected non-change',color="red")
        return

    if trace and verbose:
        g.trace(p.headString(),len(oldText),len(newText))

    oldIns  = p.v.t.insertSpot
    i,j = p.v.t.selectionStart,p.v.t.selectionLength
    oldSel  = (i,j-i)
    oldYview = None
    undoType = 'Typing'
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,
        oldSel=oldSel,newSel=newSel,oldYview=oldYview)

    # Update the tnode.
    p.v.setBodyString(newText)
    p.v.t.insertSpot = newInsert
    i,j = newSel
    i,j = self.toGuiIndex(i),self.toGuiIndex(j)
    if i > j: i,j = j,i
    p.v.t.selectionStart,p.v.t.selectionLength = (i,j-i)

    # No need to redraw the screen.
    if not self.useScintilla:
        c.recolor()
    if not c.changed and c.frame.initComplete:
        c.setChanged(True)
    c.frame.body.updateEditors()
    c.frame.tree.updateIcon(p)
    c.outerUpdate()
#@-node:ekr.20081011035036.1:onTextChanged
#@-node:ekr.20081020075840.21:Suppress updates until init complete
#@+node:ekr.20081022151429.10:Fixed startup crasher
Traceback (most recent call last):
 File "launchLeo.py", line 8, in ?
   leo.core.runLeo.run()
 File "/transfer/qt-plugin/leo/core/runLeo.py", line 120, in run
   c,frame = createFrame(fileName,relativeFileName,script)
 File "/transfer/qt-plugin/leo/core/runLeo.py", line 170, in
createFrame
   c.chapterController.finishCreate()
 File "/transfer/qt-plugin/leo/core/leoChapters.py", line 50, in
finishCreate
   cc.createChaptersNode()
 File "/transfer/qt-plugin/leo/core/leoChapters.py", line 473, in
createChaptersNode
   p = root.insertAsLastChild()
 File "/transfer/qt-plugin/leo/core/leoNodes.py", line 2307, in
insertAsLastChild
   n = p.numberOfChildren()
 File "/transfer/qt-plugin/leo/core/leoNodes.py", line 1263, in
numberOfChildren
   return len(p.v.t.children)
AttributeError: 'NoneType' object has no attribute 't'
#@+node:ekr.20081004172422.528:qtFrame.finishCreate & helpers
def finishCreate (self,c):

    f = self ; f.c = c

    # g.trace('***qtFrame')

    self.bigTree           = c.config.getBool('big_outline_pane')
    self.trace_status_line = c.config.getBool('trace_status_line')
    self.use_chapters      = c.config.getBool('use_chapters')
    self.use_chapter_tabs  = c.config.getBool('use_chapter_tabs')

    # xx todo
    f.top = DynamicWindow(c)
    g.app.gui.attachLeoIcon(f.top)
    f.top.setWindowTitle(self.title)
    f.top.show()

    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    # # f.createOuterFrames()
    f.createIconBar() # A base class method.
    # # f.createLeoSplitters(f.outerFrame)
    f.createSplitterComponents()
    f.createStatusLine() # A base class method.
    f.createFirstTreeNode() # Call the base-class method.
    f.menu = leoQtMenu(f)
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = leoQtMinibuffer(c)
    c.bodyWantsFocusNow()
#@+node:ekr.20081004172422.530:createSplitterComponents (qtFrame)
def createSplitterComponents (self):

    f = self ; c = f.c

    f.tree  = leoQtTree(c,f)
    f.log   = leoQtLog(f,None)
    f.body  = leoQtBody(f,None)

    if f.use_chapters:
        c.chapterController = cc = leoChapters.chapterController(c)

    # # Create the canvas, tree, log and body.
    # if f.use_chapters:
        # c.chapterController = cc = leoChapters.chapterController(c)

    # # split1.pane1 is the secondary splitter.

    # if self.bigTree: # Put outline in the main splitter.
        # if self.use_chapters and self.use_chapter_tabs:
            # cc.tt = leoQtTreeTab(c,f.split1Pane2,cc)
        # f.canvas = f.createCanvas(f.split1Pane1)
        # f.tree  = leoQtTree(c,f,f.canvas)
        # f.log   = leoQtLog(f,f.split2Pane2)
        # f.body  = leoQtBody(f,f.split2Pane1)
    # else:
        # if self.use_chapters and self.use_chapter_tabs:
            # cc.tt = leoQtTreeTab(c,f.split2Pane1,cc)
        # f.canvas = f.createCanvas(f.split2Pane1)
        # f.tree   = leoQtTree(c,f,f.canvas)
        # f.log    = leoQtLog(f,f.split2Pane2)
        # f.body   = leoQtBody(f,f.split1Pane2)

    # # Yes, this an "official" ivar: this is a kludge.
    # # f.bodyCtrl = f.body.bodyCtrl

    # # Configure.
    # f.setTabWidth(c.tab_width)
    # f.reconfigurePanes()
    # f.body.setFontFromConfig()
    # f.body.setColorFromConfig()
#@-node:ekr.20081004172422.530:createSplitterComponents (qtFrame)
#@-node:ekr.20081004172422.528:qtFrame.finishCreate & helpers
#@-node:ekr.20081022151429.10:Fixed startup crasher
#@+node:ekr.20081023060109.10:Make the body pane a richTextEdit
I added the stackedWidget and richTextWidget (for demo purposes). The
layout is not quite optimal yet (the border around the body pane is a
bit too big). You can test it by running this script (ctrl+b):

w = c.frame.top
sw = w.stackedWidget
rted = w.richTextEdit
rted.setHtml("This is <b>rich text</b>")
sw.setCurrentIndex(1)

We should not rig widgets like this to the core,
and notably not install the event filter for these (since the wanted
behaviour should be dictated by the current widget). 
#@nonl
#@+node:ekr.20081004172422.504: ctor (qtBody)
def __init__ (self,frame,parentFrame):

    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)

    c = self.c
    assert c.frame == frame and frame.c == c

    self.useScintilla = c.config.getBool('qt-use-scintilla')

    # Set the actual gui widget.
    if self.useScintilla:
        self.widget = w = leoQScintillaWidget(
            c.frame.top.textEdit,
            name='body',c=c)
        self.bodyCtrl = w # The widget as seen from Leo's core.
        self.colorizer = leoColor.nullColorizer(c)
    else:
        top = c.frame.top ; sw = top.ui.stackedWidget
        sw.setCurrentIndex(1)
        self.widget = w = leoQTextEditWidget(
            top.ui.richTextEdit,
            name = 'body',c=c) # A QTextEdit.
        self.bodyCtrl = w # The widget as seen from Leo's core.
        self.colorizer = leoColor.colorizer(c)
        w.acceptRichText = False

    # Config stuff.
    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")
    self.wrapState = wrap

    # For multiple body editors.
    self.editor_name = None
    self.editor_v = None
    self.numberOfEditors = 1
    self.totalNumberOfEditors = 1
#@nonl
#@-node:ekr.20081004172422.504: ctor (qtBody)
#@+node:ekr.20081004172422.884: ctor (Window)
# Called from leoQtFrame.finishCreate.

def __init__(self,c,parent=None):

    '''Create Leo's main window, c.frame.top'''

    self.c = c ; top = c.frame.top

    # g.trace('Window')

    # Init both base classes.
    QtGui.QMainWindow.__init__(self,parent)
    #qt_main.Ui_MainWindow.__init__(self)

    self.ui = qt_main.Ui_MainWindow()
    # Init the QDesigner elements.
    self.ui.setupUi(self)

    # The following ivars (and more) are inherited from UiMainWindow:
        # self.lineEdit   = QtGui.QLineEdit(self.centralwidget) # The minibuffer.
        # self.menubar    = QtGui.QMenuBar(MainWindow)          # The menu bar.
        # self.tabWidget  = QtGui.QTabWidget(self.splitter)     # The log pane.
        # self.textEdit   = Qsci.QsciScintilla(self.splitter_2) # The body pane.
        # self.treeWidget = QtGui.QTreeWidget(self.splitter)    # The tree pane.

    self.iconBar = self.addToolBar("IconBar")
    self.statusBar = QtGui.QStatusBar()
    self.setStatusBar(self.statusBar)

    self.setStyleSheets()
#@-node:ekr.20081004172422.884: ctor (Window)
#@+node:ekr.20081023131208.10:Coloring
# These are body methods.
# def forceFullRecolor (self): pass
# def update_idletasks(self):  pass

def removeAllTags(self):
    s = self.getAllText()
    self.colorSelection(0,len(s),'black')

def tag_add(self,tag,x1,x2):
    if tag == 'comment1':
        self.colorSelection(x1,x2,'firebrick')

def tag_config (self,*args,**keys):
    if len(args) == 1:
        key = args[0]
        # g.trace(key,keys)
        self.tags[key] = keys
    else:
        g.trace('oops',args,keys)

tag_configure = tag_config

def tag_names (self):
    return []
#@+node:ekr.20081029084058.10:colorSelection
def colorSelection (self,i,j,colorName):

    w = self.widget
    color = QtGui.QColor(colorName)
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    old_i,old_j = self.getSelectionRange()
    old_ins = self.getInsertPoint()
    self.setSelectionRange(i,j)
    w.setTextColor(color)
    self.setSelectionRange(old_i,old_j,insert=old_ins)
    sb.setSliderPosition(pos)
#@-node:ekr.20081029084058.10:colorSelection
#@-node:ekr.20081023131208.10:Coloring
#@+node:ekr.20081004172422.516:Idle time
def after_idle(self,func,threadCount):
    # g.trace(func.__name__,'threadCount',threadCount)
    return func(threadCount)

def after(self,n,func,threadCount):
    def after_callback(func=func,threadCount=threadCount):
        # g.trace(func.__name__,threadCount)
        return func(threadCount)
    QtCore.QTimer.singleShot(n,after_callback)

def scheduleIdleTimeRoutine (self,function,*args,**keys):
    g.trace()
    # if not g.app.unitTesting:
        # self.widget.after_idle(function,*args,**keys)
#@-node:ekr.20081004172422.516:Idle time
#@-node:ekr.20081023060109.10:Make the body pane a richTextEdit
#@+node:ekr.20081025124450.10:Switching nodes reliably
#@+node:ekr.20081004172422.844:Selecting & editing... (qtTree)
#@+node:ekr.20081004172422.799:edit_widget
def edit_widget (self,p):

    """Returns the Qt.Edit widget for position p."""

    w = self._editWidgetWrapper

    if p and p == self._editWidgetPosition:
        return w
    else:
        return None

    # Decouple all of the core's headline code.
    # Except for over-ridden methods.
#@-node:ekr.20081004172422.799:edit_widget
#@+node:ekr.20081025124450.14:beforeSelectHint
def beforeSelectHint (self,p,old_p):

    w = self.treeWidget ; trace = True

    if self.selecting:
        return g.trace('*** Error: already selecting',g.callers(4))

    if self.redrawing:
        if trace: g.trace('already redrawing')
        return

    # Disable onTextChanged.
    self.selecting = True
#@-node:ekr.20081025124450.14:beforeSelectHint
#@+node:ekr.20081025124450.15:afterSelectHint
def afterSelectHint (self,p,old_p):

    c = self.c ; w = self.treeWidget ; trace = False

    self.selecting = False

    if not p:
        return g.trace('Error: no p')
    if p != c.currentPosition():
        return g.trace('Error: p is not c.currentPosition()')
    if self.redrawing:
        return g.trace('Error: already redrawing')
    if trace:
        g.trace(p.headString(),g.callers(4))

    # setCurrentItem sets & clears .selecting ivar
    self.setCurrentItem()
    item = w.currentItem()
    if item:
        w.scrollToItem(item,
            QtGui.QAbstractItemView.PositionAtCenter)
#@-node:ekr.20081025124450.15:afterSelectHint
#@+node:ekr.20081004172422.854:setHeadline
def setHeadline (self,p,s):

    '''Set the actual text of the headline widget.

    This is called from the undo/redo logic to change the text before redrawing.'''

    # w = self.edit_widget(p)
    # if w:
        # w.configure(state='normal')
        # w.delete(0,'end')
        # if s.endswith('\n') or s.endswith('\r'):
            # s = s[:-1]
        # w.insert(0,s)
        # self.revertHeadline = s
        # # g.trace(repr(s),w.getAllText())
    # else:
        # g.trace('-'*20,'oops')
#@-node:ekr.20081004172422.854:setHeadline
#@+node:ekr.20081004172422.846:editLabel (override)
def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c ; trace = True ; verbose = False

    if self.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if self._editWidget:
        # Not an error, because of key weirdness.
        g.trace('already editing')
        return

    if trace:
        g.trace('*** all',selectAll,p.headString(),g.callers(4))

    w = self.treeWidget
    data = self.vnodeDict.get(p.v)
    if not data:
        if trace and verbose:
            g.trace('No data: redrawing if possible')
        c.outerUpdate() # Do any scheduled redraw.
        data = self.vnodeDict.get(p.v)

    if data:
        item = data [0][1]
    else:
        if trace and not g.app.unitTesting:
            g.trace('*** Can not happen: no data',p and p.headString())
        return None

    if item:
        w.setCurrentItem(item) # Must do this first.
        w.editItem(item)
        e = w.itemWidget(item,0) # A QLineEdit
        if e:
            s = e.text() ; len_s = len(s)
            # Hook up the widget to Leo's core.
            self._editWidgetPosition = p.copy()
            self._editWidget = e
            self._editWidgetWrapper = leoQtHeadlineWidget(
                widget=e,name='head',c=c)
            start,n = g.choose(selectAll,
                tuple([0,len_s]),tuple([len_s,0]))
            e.setObjectName('headline')
            e.setSelection(start,n)
            e.setFocus()
        else: g.trace('*** no e')
    else:
        self._editWidgetPosition = None
        self._editWidget = None
        self._editWidgetWrapper = None
        e = None
        g.trace('*** no item')

    # A nice hack: just set the focus request.
    c.requestedFocusWidget = e
#@-node:ekr.20081004172422.846:editLabel (override)
#@+node:ekr.20081117065611.11:editLabelHelper
def editLabelHelper (self,item):

    '''A helper shared by editLabel and onItemDoubleClicked.'''
#@-node:ekr.20081117065611.11:editLabelHelper
#@+node:ekr.20081030120643.11:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.'''

    trace = False ; verbose = True
    c = self.c ; u = c.undoer
    e = self._editWidget
    p = self._editWidgetPosition
    w = g.app.gui.get_focus()

    # These are not errors: sig_itemChanged may
    # have been called first.
    if not e:
        if trace: g.trace('No e')
        return 
    if e != w:
        if trace and verbose: g.trace('e != w',e,w,g.callers(4))
        self._editWidget = None
        self._editWidgetPosition = None
        self._editWidgetWrapper = None
        return
    if not p:
        if trace: g.trace('No p')
        return
    s = e.text() ; len_s = len(s)
    s = g.toUnicode(s,'utf-8')
    oldHead = p.headString()
    changed = s != oldHead
    if trace: g.trace('changed',changed,repr(s),g.callers(4))
    if not changed: return
    p.initHeadString(s)
    undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
    if not c.changed: c.setChanged(True)
    # New in Leo 4.4.5: we must recolor the body because
    # the headline may contain directives.
    c.frame.body.recolor(p,incremental=True)
    dirtyVnodeList = p.setDirty()
    u.afterChangeNodeContents(p,undoType,undoData,
        dirtyVnodeList=dirtyVnodeList)
    # End the editing!
    self._editWidget = None
    self._editWidgetPosition = None
    self._editWidgetWrapper = None
    c.redraw(scroll=False)
    if self.stayInTree:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()
#@nonl
#@-node:ekr.20081030120643.11:onHeadChanged
#@-node:ekr.20081004172422.844:Selecting & editing... (qtTree)
#@+node:ekr.20081010070648.19:Drawing... (qtTree)
#@+node:ekr.20081011035036.12:allAncestorsExpanded
def allAncestorsExpanded (self,p):

    for p in p.self_and_parents_iter():
        if not p.isExpanded():
            return False
    else:
        return True
#@-node:ekr.20081011035036.12:allAncestorsExpanded
#@+node:ekr.20081021043407.23:full_redraw & helpers
def full_redraw (self,scroll=False,forceDraw=False): # forceDraw not used.

    '''Redraw all visible nodes of the tree'''

    c = self.c ; w = self.treeWidget
    trace = False; verbose = False
    if not w: return
    if self.redrawing:
        g.trace('***** already drawing',g.callers(5))
        return

    # Bug fix: 2008/11/10
    self.expandAllAncestors(c.currentPosition())

    self.redrawCount += 1
    if trace and verbose: tstart()

    # Init the data structures.
    self.initData()
    self.nodeDrawCount = 0
    self.redrawing = True
    self.fullDrawing = True # To suppress some traces.
    try:
        w.clear()
        # Draw all top-level nodes and their visible descendants.
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()
    finally:
        if not self.selecting:
            item = self.setCurrentItem()
            if item:
                if 0: # Annoying.
                    w.scrollToItem(item,
                        QtGui.QAbstractItemView.PositionAtCenter)
            elif p and self.redrawCount > 1:
                g.trace('Error: no current item: %s' % (p.headString()))

        item = w.currentItem()
        if item:
            w.scrollToItem(item,
                QtGui.QAbstractItemView.PositionAtCenter)

        # Necessary to get the tree drawn initially.
        w.repaint()

        c.requestRedrawFlag= False
        self.redrawing = False
        self.fullDrawing = False
        if trace:
            if verbose: tstop()
            g.trace('%s: drew %3s nodes' % (
                self.redrawCount,self.nodeDrawCount),g.callers(5))

redraw = full_redraw # Compatibility
redraw_now = full_redraw
#@+node:ekr.20081021043407.30:initData
def initData (self):

    self.tnodeDict = {} # keys are tnodes, values are lists of items (p,it)
    self.vnodeDict = {} # keys are vnodes, values are lists of items (p,it)
    self.itemsDict = {} # keys are items, values are positions
    self.parentsDict = {}
    self._editWidgetPosition = None
    self._editWidget = None
    self._editWidgetWrapper = None
#@nonl
#@-node:ekr.20081021043407.30:initData
#@+node:ekr.20081021043407.24:drawNode
def drawNode (self,p,dummy=False):

    c = self.c ; w = self.treeWidget ; trace = False
    self.nodeDrawCount += 1

    # Allocate the qt tree item.
    parent = p.parent()
    itemOrTree = self.parentsDict.get(parent and parent.v,w)

    if trace and not self.fullDrawing:
        g.trace(id(itemOrTree),parent and parent.headString())

    item = QtGui.QTreeWidgetItem(itemOrTree)
    item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)

    # Draw the headline and the icon.
    item.setText(0,p.headString())
    icon = self.getIcon(p)
    if icon: item.setIcon(0,icon)

    if dummy: return item

    # Remember the associatiation of item with p, and vice versa.
    self.itemsDict[item] = p.copy()
    self.parentsDict[p.v] = item 

    # Remember the association of p.v with (p,item)
    aList = self.vnodeDict.get(p.v,[])
    data = p.copy(),item
    aList.append(data)
    self.vnodeDict[p.v] = aList

    # Remember the association of p.v.t with (p,item).
    aList = self.tnodeDict.get(p.v.t,[])
    data = p.copy(),item
    aList.append(data)
    self.tnodeDict[p.v.t] = aList

    return item
#@-node:ekr.20081021043407.24:drawNode
#@+node:ekr.20081021043407.25:drawTree
def drawTree (self,p):

    c = self.c ; w = self.treeWidget

    p = p.copy()

    # g.trace(p.headString())

    # Draw the (visible) parent node.
    it = self.drawNode(p)

    if p.hasChildren():
        if p.isExpanded():
            w.expandItem(it)
            child = p.firstChild()
            while child:
                self.drawTree(child)
                child.moveToNext()
        else:
            if 0:
                # Just draw one dummy child.
                # This doesn't work with the new expansion code.
                self.drawNode(p.firstChild(),dummy=True)
            else:
                # Draw the hidden children.
                child = p.firstChild()
                while child:
                    self.drawNode(child)
                    child.moveToNext()
            w.collapseItem(it)
    else:
        w.collapseItem(it)
#@-node:ekr.20081021043407.25:drawTree
#@-node:ekr.20081021043407.23:full_redraw & helpers
#@+node:ekr.20081010070648.14:getIcon & getIconImage
def getIcon(self,p):

    '''Return the proper icon for position p.'''

    p.v.iconVal = val = p.v.computeIcon()
    return self.getIconImage(val)

def getIconImage(self,val):

    return g.app.gui.getIconImage(
        "box%02d.GIF" % val)

#@-node:ekr.20081010070648.14:getIcon & getIconImage
#@+node:ekr.20081021043407.4:redraw_after_clone
def redraw_after_clone (self):

    self.full_redraw()
#@-node:ekr.20081021043407.4:redraw_after_clone
#@+node:ekr.20081021043407.5:redraw_after_contract
def redraw_after_contract (self):

    self.full_redraw()
#@-node:ekr.20081021043407.5:redraw_after_contract
#@+node:ekr.20081021043407.6:redraw_after_delete
def redraw_after_delete (self):

    self.full_redraw()


#@-node:ekr.20081021043407.6:redraw_after_delete
#@+node:ekr.20081021043407.7:redraw_after_expand & helper
def redraw_after_expand (self):

    # This is reasonable now that we only allocate
    # one dummy node in collapsed trees.
    return self.full_redraw()

    # trace = True ; verbose = False
    # c = self.c ; p = c.currentPosition()
    # w = self.treeWidget

    # if self.redrawing:
        # if trace: g.trace('already drawing',p.headString())
        # return
    # self.redrawCount += 1
    # if trace: g.trace(self.redrawCount,p.headString())
    # it = self.parentsDict.get(p.v)
    # if not it:
        # g.trace('can not happen: no item for %s' % p.headString())
        # return self.full_redraw()
    # self.nodeDrawCount = 0
    # self.redrawing = True
    # self.expanding = True
    # try:
        # w.expandItem(it)
        # # Delete all the children from the tree.
        # items = it.takeChildren()
        # if trace and verbose:
            # g.trace(id(it),len(items),p.headString())
        # # Delete all descendant entries from dictionaries.
        # for child in p.children_iter():
            # for z in child.self_and_subtree_iter():
                # self.removeFromDicts(z)
        # # Redraw all descendants.
        # for child in p.children_iter():
            # self.drawTree(child)
    # finally:
        # w.setCurrentItem(it)
        # self.redrawing = False
        # self.expanding = False
        # c.requestRedrawFlag= False
        # if trace:
            # g.trace('drew %3s nodes' %self.nodeDrawCount)
#@+node:ekr.20081021043407.28:removeFromDicts
def removeFromDicts (self,p):

    # Important: items do not necessarily exist.

    # Remove item from parentsDict.
    it = self.parentsDict.get(p.v)
    if it: del self.parentsDict[p.v]

    # Remove position from itemsDict.
    p2 = self.itemsDict.get(it)
    if p2 == p: del self.itemsDict[it]

    # Remove items from vnodeDict
    aList = self.vnodeDict.get(p.v,[])
    # aList = [z for z in aList if z[1] != it] # Wrong
    aList = [z for z in aList if z[0] != p]
    self.vnodeDict[p.v] = aList

    # Remove items from tnodeDict
    aList = self.tnodeDict.get(p.v.t,[])
    # aList = [z for z in aList if z[1] != it] # Wrong
    aList = [z for z in aList if z[0] != p]
    self.tnodeDict[p.v.t] = aList
#@-node:ekr.20081021043407.28:removeFromDicts
#@-node:ekr.20081021043407.7:redraw_after_expand & helper
#@+node:ekr.20081021043407.3:redraw_after_icons_changed
def redraw_after_icons_changed (self,all=False):

    g.trace('should not be called',g.callers(4))

    c = self.c ; p = c.currentPosition()

    if all:
        self.full_redraw()
    else:
        self.updateIcon(p)


#@-node:ekr.20081021043407.3:redraw_after_icons_changed
#@+node:ekr.20081021043407.8:redraw_after_insert
def redraw_after_insert (self):

    self.full_redraw()
#@-node:ekr.20081021043407.8:redraw_after_insert
#@+node:ekr.20081021043407.9:redraw_after_move_down
def redraw_after_move_down (self):

    self.full_redraw()
#@nonl
#@-node:ekr.20081021043407.9:redraw_after_move_down
#@+node:ekr.20081021043407.10:redraw_after_move_left
def redraw_after_move_left (self):

    self.full_redraw()
#@nonl
#@-node:ekr.20081021043407.10:redraw_after_move_left
#@+node:ekr.20081021043407.11:redraw_after_move_right
def redraw_after_move_right (self):

    if 0: # now done in c.moveOutlineRight.
        c = self.c ; p = c.currentPosition()
        parent = p.parent()
        if parent: parent.expand()


    # g.trace('parent',c.currentPosition().parent() or "non")

    self.full_redraw()
#@-node:ekr.20081021043407.11:redraw_after_move_right
#@+node:ekr.20081021043407.12:redraw_after_move_up
def redraw_after_move_up (self):

    self.full_redraw()
#@-node:ekr.20081021043407.12:redraw_after_move_up
#@+node:ekr.20081021043407.13:redraw_after_select
def redraw_after_select (self):

    '''Redraw the screen after selecting a node.'''

    pass # It is quite wrong to do an automatic redraw after select.
#@-node:ekr.20081021043407.13:redraw_after_select
#@+node:ekr.20081011035036.11:updateIcon
def updateIcon (self,p):

    '''Update p's icon.'''

    if not p: return

    val = p.v.computeIcon()
    if p.v.iconVal == val: return

    icon = self.getIconImage(val)
    aList = self.tnodeDict.get(p.v.t,[])
    for p,it in aList:
        # g.trace(id(it),p.headString())
        it.setIcon(0,icon)
#@-node:ekr.20081011035036.11:updateIcon
#@-node:ekr.20081010070648.19:Drawing... (qtTree)
#@+node:ekr.20081011035036.1:onTextChanged
def onTextChanged (self):

    '''Update Leo after the body has been changed.

    self.selecting is guaranteed to be True during
    the entire selection process.'''

    c = self.c ; p = c.currentPosition()
    tree = c.frame.tree ; w = self
    trace = True ; verbose = False

    if tree.selecting:
        if trace and verbose: g.trace('selecting')
        return
    if tree.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if not p:
        return g.trace('*** no p')

    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText() # Converts to unicode.

    # Get the previous values from the tnode.
    oldText = g.toUnicode(p.v.t._bodyString,"utf-8")
    if oldText == newText:
        # This can happen as the result of undo.
        # g.trace('*** unexpected non-change',color="red")
        return

    if trace and verbose:
        g.trace(p.headString(),len(oldText),len(newText))

    oldIns  = p.v.t.insertSpot
    i,j = p.v.t.selectionStart,p.v.t.selectionLength
    oldSel  = (i,j-i)
    oldYview = None
    undoType = 'Typing'
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,
        oldSel=oldSel,newSel=newSel,oldYview=oldYview)

    # Update the tnode.
    p.v.setBodyString(newText)
    p.v.t.insertSpot = newInsert
    i,j = newSel
    i,j = self.toGuiIndex(i),self.toGuiIndex(j)
    if i > j: i,j = j,i
    p.v.t.selectionStart,p.v.t.selectionLength = (i,j-i)

    # No need to redraw the screen.
    if not self.useScintilla:
        c.recolor()
    if not c.changed and c.frame.initComplete:
        c.setChanged(True)
    c.frame.body.updateEditors()
    c.frame.tree.updateIcon(p)
    c.outerUpdate()
#@-node:ekr.20081011035036.1:onTextChanged
#@-node:ekr.20081025124450.10:Switching nodes reliably
#@+node:ekr.20081026084658.1:Update icons properly...
#@+node:ekr.20081021043407.3:redraw_after_icons_changed
def redraw_after_icons_changed (self,all=False):

    g.trace('should not be called',g.callers(4))

    c = self.c ; p = c.currentPosition()

    if all:
        self.full_redraw()
    else:
        self.updateIcon(p)


#@-node:ekr.20081021043407.3:redraw_after_icons_changed
#@+node:ekr.20081011035036.11:updateIcon
def updateIcon (self,p):

    '''Update p's icon.'''

    if not p: return

    val = p.v.computeIcon()
    if p.v.iconVal == val: return

    icon = self.getIconImage(val)
    aList = self.tnodeDict.get(p.v.t,[])
    for p,it in aList:
        # g.trace(id(it),p.headString())
        it.setIcon(0,icon)
#@-node:ekr.20081011035036.11:updateIcon
#@+node:ekr.20081010070648.14:getIcon & getIconImage
def getIcon(self,p):

    '''Return the proper icon for position p.'''

    p.v.iconVal = val = p.v.computeIcon()
    return self.getIconImage(val)

def getIconImage(self,val):

    return g.app.gui.getIconImage(
        "box%02d.GIF" % val)

#@-node:ekr.20081010070648.14:getIcon & getIconImage
#@-node:ekr.20081026084658.1:Update icons properly...
#@+node:ekr.20081027082521.11:Redraw crashes & problems
#@clone 2
#@+node:ekr.20081021043407.23:full_redraw & helpers
def full_redraw (self,scroll=False,forceDraw=False): # forceDraw not used.

    '''Redraw all visible nodes of the tree'''

    c = self.c ; w = self.treeWidget
    trace = False; verbose = False
    if not w: return
    if self.redrawing:
        g.trace('***** already drawing',g.callers(5))
        return

    # Bug fix: 2008/11/10
    self.expandAllAncestors(c.currentPosition())

    self.redrawCount += 1
    if trace and verbose: tstart()

    # Init the data structures.
    self.initData()
    self.nodeDrawCount = 0
    self.redrawing = True
    self.fullDrawing = True # To suppress some traces.
    try:
        w.clear()
        # Draw all top-level nodes and their visible descendants.
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()
    finally:
        if not self.selecting:
            item = self.setCurrentItem()
            if item:
                if 0: # Annoying.
                    w.scrollToItem(item,
                        QtGui.QAbstractItemView.PositionAtCenter)
            elif p and self.redrawCount > 1:
                g.trace('Error: no current item: %s' % (p.headString()))

        item = w.currentItem()
        if item:
            w.scrollToItem(item,
                QtGui.QAbstractItemView.PositionAtCenter)

        # Necessary to get the tree drawn initially.
        w.repaint()

        c.requestRedrawFlag= False
        self.redrawing = False
        self.fullDrawing = False
        if trace:
            if verbose: tstop()
            g.trace('%s: drew %3s nodes' % (
                self.redrawCount,self.nodeDrawCount),g.callers(5))

redraw = full_redraw # Compatibility
redraw_now = full_redraw
#@+node:ekr.20081021043407.30:initData
def initData (self):

    self.tnodeDict = {} # keys are tnodes, values are lists of items (p,it)
    self.vnodeDict = {} # keys are vnodes, values are lists of items (p,it)
    self.itemsDict = {} # keys are items, values are positions
    self.parentsDict = {}
    self._editWidgetPosition = None
    self._editWidget = None
    self._editWidgetWrapper = None
#@nonl
#@-node:ekr.20081021043407.30:initData
#@+node:ekr.20081021043407.24:drawNode
def drawNode (self,p,dummy=False):

    c = self.c ; w = self.treeWidget ; trace = False
    self.nodeDrawCount += 1

    # Allocate the qt tree item.
    parent = p.parent()
    itemOrTree = self.parentsDict.get(parent and parent.v,w)

    if trace and not self.fullDrawing:
        g.trace(id(itemOrTree),parent and parent.headString())

    item = QtGui.QTreeWidgetItem(itemOrTree)
    item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)

    # Draw the headline and the icon.
    item.setText(0,p.headString())
    icon = self.getIcon(p)
    if icon: item.setIcon(0,icon)

    if dummy: return item

    # Remember the associatiation of item with p, and vice versa.
    self.itemsDict[item] = p.copy()
    self.parentsDict[p.v] = item 

    # Remember the association of p.v with (p,item)
    aList = self.vnodeDict.get(p.v,[])
    data = p.copy(),item
    aList.append(data)
    self.vnodeDict[p.v] = aList

    # Remember the association of p.v.t with (p,item).
    aList = self.tnodeDict.get(p.v.t,[])
    data = p.copy(),item
    aList.append(data)
    self.tnodeDict[p.v.t] = aList

    return item
#@-node:ekr.20081021043407.24:drawNode
#@+node:ekr.20081021043407.25:drawTree
def drawTree (self,p):

    c = self.c ; w = self.treeWidget

    p = p.copy()

    # g.trace(p.headString())

    # Draw the (visible) parent node.
    it = self.drawNode(p)

    if p.hasChildren():
        if p.isExpanded():
            w.expandItem(it)
            child = p.firstChild()
            while child:
                self.drawTree(child)
                child.moveToNext()
        else:
            if 0:
                # Just draw one dummy child.
                # This doesn't work with the new expansion code.
                self.drawNode(p.firstChild(),dummy=True)
            else:
                # Draw the hidden children.
                child = p.firstChild()
                while child:
                    self.drawNode(child)
                    child.moveToNext()
            w.collapseItem(it)
    else:
        w.collapseItem(it)
#@-node:ekr.20081021043407.25:drawTree
#@-node:ekr.20081021043407.23:full_redraw & helpers
#@+node:ekr.20081025124450.15:afterSelectHint
def afterSelectHint (self,p,old_p):

    c = self.c ; w = self.treeWidget ; trace = False

    self.selecting = False

    if not p:
        return g.trace('Error: no p')
    if p != c.currentPosition():
        return g.trace('Error: p is not c.currentPosition()')
    if self.redrawing:
        return g.trace('Error: already redrawing')
    if trace:
        g.trace(p.headString(),g.callers(4))

    # setCurrentItem sets & clears .selecting ivar
    self.setCurrentItem()
    item = w.currentItem()
    if item:
        w.scrollToItem(item,
            QtGui.QAbstractItemView.PositionAtCenter)
#@-node:ekr.20081025124450.15:afterSelectHint
#@+node:ekr.20081027124640.10:sig_itemCollapsed
def sig_itemCollapsed (self,item):

    c = self.c ; p = c.currentPosition() ; w = self.treeWidget
    trace = False ; verbose = False

    # Ignore events generated by redraws.
    if self.redrawing:
        if trace and verbose: g.trace('already redrawing',g.callers(4))
        return
    if self.expanding:
        if trace and verbose: g.trace('already expanding',g.callers(4))
        return
    if self.selecting:
        if trace and verbose: g.trace('already selecting',g.callers(4))
        return

    if trace: g.trace(p.headString() or "<no p>",g.callers(4))

    p2 = self.itemsDict.get(item)
    if p2:
        p2.contract()
        c.setCurrentPosition(p2)
        item = self.setCurrentItem()
        if 0: # Annoying.
            w.scrollToItem(item,
                QtGui.QAbstractItemView.PositionAtCenter)
    else:
        g.trace('Error no p2')
#@-node:ekr.20081027124640.10:sig_itemCollapsed
#@+node:ekr.20081021043407.26:sig_itemExpanded
def sig_itemExpanded (self,item):

    '''Handle and tree-expansion event.'''

    # The difficult case is when the user clicks the expansion box.

    c = self.c ; p = c.currentPosition() ; w = self.treeWidget
    trace = False ; verbose = False

    # Ignore events generated by redraws.
    if self.redrawing:
        if trace and verbose: g.trace('already redrawing',g.callers(4))
        return
    if self.expanding:
        if trace and verbose: g.trace('already expanding',g.callers(4))
        return
    if self.selecting:
        if trace and verbose: g.trace('already selecting',g.callers(4))
        return

    if trace: g.trace(p.headString() or "<no p>",g.callers(4))

    self.expanding = True
    try:
        redraw = False
        p2 = self.itemsDict.get(item)
        if p2:
            if trace: g.trace(p2)
            if not p2.isExpanded():
                p2.expand()
            c.setCurrentPosition(p2)
            self.full_redraw()
            redraw = True
        else:
            g.trace('Error no p2')

    finally:
        self.expanding = False
        if redraw:
            item = self.setCurrentItem()
            if item:
                w.scrollToItem(item,
                    QtGui.QAbstractItemView.PositionAtCenter)
#@-node:ekr.20081021043407.26:sig_itemExpanded
#@+node:ekr.20081021043407.13:redraw_after_select
def redraw_after_select (self):

    '''Redraw the screen after selecting a node.'''

    pass # It is quite wrong to do an automatic redraw after select.
#@-node:ekr.20081021043407.13:redraw_after_select
#@+node:ekr.20081021043407.11:redraw_after_move_right
def redraw_after_move_right (self):

    if 0: # now done in c.moveOutlineRight.
        c = self.c ; p = c.currentPosition()
        parent = p.parent()
        if parent: parent.expand()


    # g.trace('parent',c.currentPosition().parent() or "non")

    self.full_redraw()
#@-node:ekr.20081021043407.11:redraw_after_move_right
#@+node:ekr.20081027082521.12:setCurrentItem
def setCurrentItem (self):

    c = self.c ; p = c.currentPosition()
    trace = False
    w = self.treeWidget

    if self.expanding:
        if trace: g.trace('already expanding')
        return None
    if self.selecting:
        if trace: g.trace('already selecting')
        return None

    aList = self.vnodeDict.get(p.v,[])
    h = p and p.headString() or '<no p!>'
    if not p: return False

    for p2,item in aList:
        if p == p2:
            if trace: g.trace('found: %s, %s' % (id(item),h))
            # Actually select the item only if necessary.
            # This prevents any side effects.
            item2 = w.currentItem()
            if item != item2:
                if trace: g.trace(item==item,'old item',item2)
                self.selecting = True
                try:
                    w.setCurrentItem(item)
                finally:
                    self.selecting = False
            return item
    else:
        if trace: g.trace('** no item for',p.headString())
        return None
#@-node:ekr.20081027082521.12:setCurrentItem
#@-node:ekr.20081027082521.11:Redraw crashes & problems
#@+node:ekr.20081027163149.12:Menu accels
# Mystery solved: top-level menu accels only visible when alt key pressed.
#@nonl
#@+node:ekr.20081004172422.865:add_command
def add_command (self,**keys):

    """Wrapper for the Tkinter add_command menu method."""

    c = self.c
    accel = keys.get('accelerator') or ''
    command = keys.get('command')
    label = keys.get('label')
    n = keys.get('underline')
    menu = keys.get('menu') or self
    if not label: return

    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    if accel:
        label = '%s\t%s' % (label,accel)

    action = menu.addAction(label)

    if command:
        def add_command_callback(label=label,command=command):
            return command()

        QtCore.QObject.connect(action,
            QtCore.SIGNAL("triggered()"),add_command_callback)
#@-node:ekr.20081004172422.865:add_command
#@+node:ekr.20081004172422.864:add_cascade
def add_cascade (self,parent,label,menu,underline):

    """Wrapper for the Tkinter add_cascade menu method.

    Adds a submenu to the parent menu, or the menubar."""

    c = self.c ; leoFrame = c.frame
    n = underline
    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]

    menu.setTitle(label)
    menu.leo_label = label

    if parent:
        parent.addMenu(menu)
    else:
        self.menuBar.addMenu(menu)

    return menu
#@-node:ekr.20081004172422.864:add_cascade
#@-node:ekr.20081027163149.12:Menu accels
#@+node:ekr.20081027163149.13:Get undo menu working...
#@+node:ekr.20081004172422.865:add_command
def add_command (self,**keys):

    """Wrapper for the Tkinter add_command menu method."""

    c = self.c
    accel = keys.get('accelerator') or ''
    command = keys.get('command')
    label = keys.get('label')
    n = keys.get('underline')
    menu = keys.get('menu') or self
    if not label: return

    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    if accel:
        label = '%s\t%s' % (label,accel)

    action = menu.addAction(label)

    if command:
        def add_command_callback(label=label,command=command):
            return command()

        QtCore.QObject.connect(action,
            QtCore.SIGNAL("triggered()"),add_command_callback)
#@-node:ekr.20081004172422.865:add_command
#@+node:ekr.20081004172422.872:insert_cascade
def insert_cascade (self,parent,index,label,menu,underline):

    """Wrapper for the Tkinter insert_cascade menu method."""

    g.trace(label,menu)

    menu.setTitle(label)
    menu.leo_label = label

    if parent:
        parent.addMenu(menu)
    else:
        self.menuBar.addMenu(menu)

    return menu
#@-node:ekr.20081004172422.872:insert_cascade
#@+node:ekr.20081011035036.1:onTextChanged
def onTextChanged (self):

    '''Update Leo after the body has been changed.

    self.selecting is guaranteed to be True during
    the entire selection process.'''

    c = self.c ; p = c.currentPosition()
    tree = c.frame.tree ; w = self
    trace = True ; verbose = False

    if tree.selecting:
        if trace and verbose: g.trace('selecting')
        return
    if tree.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if not p:
        return g.trace('*** no p')

    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText() # Converts to unicode.

    # Get the previous values from the tnode.
    oldText = g.toUnicode(p.v.t._bodyString,"utf-8")
    if oldText == newText:
        # This can happen as the result of undo.
        # g.trace('*** unexpected non-change',color="red")
        return

    if trace and verbose:
        g.trace(p.headString(),len(oldText),len(newText))

    oldIns  = p.v.t.insertSpot
    i,j = p.v.t.selectionStart,p.v.t.selectionLength
    oldSel  = (i,j-i)
    oldYview = None
    undoType = 'Typing'
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,
        oldSel=oldSel,newSel=newSel,oldYview=oldYview)

    # Update the tnode.
    p.v.setBodyString(newText)
    p.v.t.insertSpot = newInsert
    i,j = newSel
    i,j = self.toGuiIndex(i),self.toGuiIndex(j)
    if i > j: i,j = j,i
    p.v.t.selectionStart,p.v.t.selectionLength = (i,j-i)

    # No need to redraw the screen.
    if not self.useScintilla:
        c.recolor()
    if not c.changed and c.frame.initComplete:
        c.setChanged(True)
    c.frame.body.updateEditors()
    c.frame.tree.updateIcon(p)
    c.outerUpdate()
#@-node:ekr.20081011035036.1:onTextChanged
#@+node:ekr.20081004172422.880:getMenuLabel
def getMenuLabel (self,menu,name):

    '''Return the index of the menu item whose name (or offset) is given.
    Return None if there is no such menu item.'''

    g.trace('menu',menu,'name',name)

    actions = menu.actions()
    for action in actions:
        g.trace(action.label())

    # try:
        # index = menu.index(name)
    # except:
        # index = None

    # return index
#@-node:ekr.20081004172422.880:getMenuLabel
#@+node:ekr.20081004172422.881:setMenuLabel
def setMenuLabel (self,menu,name,label,underline=-1):

    def munge(s):
        s = g.toUnicode(s,'utf-8')
        return s.replace('&','')

    # menu is a qtMenuWrapper.

    # g.trace('menu',menu,'name: %20s label: %s' % (name,label))

    if not menu: return

    realName  = munge(self.getRealMenuName(name))
    realLabel = self.getRealMenuName(label)
    for action in menu.actions():
        s = munge(action.text())
        s = s.split('\t')[0]
        if s == realName:
            action.setText(realLabel)
            break
#@-node:ekr.20081004172422.881:setMenuLabel
#@-node:ekr.20081027163149.13:Get undo menu working...
#@+node:ekr.20081029065805.12:Closing windows properly
#@+node:ekr.20081020075840.11:closeEvent (qtFrame)
def closeEvent (self,event):

    c = self.c

    if c.inCommand:
        # g.trace('requesting window close')
        c.requestCloseWindow = True
    else:
        ok = g.app.closeLeoWindow(c.frame)
        # g.trace('ok',ok)
        if ok:
            event.accept()
        else:
            event.ignore()
#@-node:ekr.20081020075840.11:closeEvent (qtFrame)
#@+node:ekr.20081004172422.549:destroySelf (qtFrame)
def destroySelf (self):

    # Remember these: we are about to destroy all of our ivars!
    c,top = self.c,self.top 

    # Indicate that the commander is no longer valid.
    c.exists = False

    if 0: # We can't do this unless we unhook the event filter.
        # Destroys all the objects of the commander.
        self.destroyAllObjects()

    c.exists = False # Make sure this one ivar has not been destroyed.

    # g.trace('qtFrame',c,g.callers(4))
    top.close()

#@-node:ekr.20081004172422.549:destroySelf (qtFrame)
#@-node:ekr.20081029065805.12:Closing windows properly
#@+node:ekr.20081103092019.12:Widget names...
#@+node:ekr.20081015062931.11:widget_name (qtGui)
def widget_name (self,w):

    # First try the widget's getName method.
    if not 'w':
        name = '<no widget>'
    elif hasattr(w,'getName'):
        name = w.getName()
    elif hasattr(w,'objectName'):
        name = str(w.objectName())
        # if name == 'treeWidget':
            # name = 'canvas(treeWidget)'
    elif hasattr(w,'_name'):
        name = w._name
    else:
        name = repr(w)

    # g.trace(name,w,g.callers(4))
    return name
#@-node:ekr.20081015062931.11:widget_name (qtGui)
#@+node:ekr.20081103092019.10:getName (baseTextWidget)
def getName (self):

    # g.trace('leoQtBaseTextWidget',self.name,g.callers())

    return self.name
#@-node:ekr.20081103092019.10:getName (baseTextWidget)
#@+node:ekr.20081014095718.15:get_name (qtTree)
def getName (self):

    name = 'canvas(tree)' # Must start with canvas.

    return name
#@-node:ekr.20081014095718.15:get_name (qtTree)
#@-node:ekr.20081103092019.12:Widget names...
#@+node:ekr.20081107102518.10:Allow commands when focus is in log.
print 'focus',repr(c.frame.getFocus())
#@nonl
#@+node:ekr.20081004172422.624:qtLog.__init__
def __init__ (self,frame,parentFrame):

    # g.trace("leoQtLog")

    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)

    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    self.logCtrl = None # The text area for log messages.

    self.contentsDict = {} # Keys are tab names.  Values are widgets.
    self.logDict = {} # Keys are tab names text widgets.  Values are the widgets.
    self.menu = None # A menu that pops up on right clicks in the hull or in tabs.

    self.tabWidget = c.frame.top.ui.tabWidget # The Qt.TabWidget that holds all the tabs.
    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")

    self.setFontFromConfig()
    self.setColorFromConfig()
#@-node:ekr.20081004172422.624:qtLog.__init__
#@+node:ekr.20081004172422.649:createTab
def createTab (self,tabName,createText=True,wrap='none'):

    c = self.c ; w = self.tabWidget

    if createText:
        contents = QtGui.QTextBrowser()
        contents.setWordWrapMode(QtGui.QTextOption.NoWrap)
        self.logDict[tabName] = contents
        # filter = leoQtEventFilter(c,
            # w=contents,tag='log-%s' % tabName)
        # contents.installEventFilter(filter)
        if tabName == 'Log': self.logCtrl = contents
    else:
        contents = QtGui.QWidget()

    self.contentsDict[tabName] = contents
    w.addTab(contents,tabName)
    return contents

#@-node:ekr.20081004172422.649:createTab
#@-node:ekr.20081107102518.10:Allow commands when focus is in log.
#@+node:ekr.20081107114035.10:Made findTextWrapper a subclass...
#@+node:ekr.20081031074959.12: class leoQtBaseTextWidget
class leoQtBaseTextWidget (leoFrame.baseTextWidget):

    @others
#@+node:ekr.20081031074959.20: Birth
#@+node:ekr.20081031074959.17:ctor (leoQtBaseTextWidget)
def __init__ (self,widget,name='leoQtBaseTextWidget',c=None):

    self.widget = widget
    self.c = c or self.widget.c

    # Init the base class.
    leoFrame.baseTextWidget.__init__(
        self,c,baseClassName='leoQtBaseTextWidget',
        name=name,
        widget=widget,
        highLevelInterface=True)

    # Init ivars.
    self.tags = {}
    self.useScintilla = False # This is used!

    if not c: return ### Can happen.

    # Hook up qt events.
    self.ev_filter = leoQtEventFilter(c,w=self,tag='body')
    self.widget.installEventFilter(self.ev_filter)

    self.widget.connect(self.widget,
        QtCore.SIGNAL("textChanged()"),self.onTextChanged)

    self.injectIvars(c)
#@-node:ekr.20081031074959.17:ctor (leoQtBaseTextWidget)
#@+node:ekr.20081007015817.77:injectIvars
def injectIvars (self,name='1',parentFrame=None):

    w = self ; p = self.c.currentPosition()

    if name == '1':
        w.leo_p = w.leo_v = None # Will be set when the second editor is created.
    else:

        w.leo_p = p.copy()
        w.leo_v = w.leo_p.v

    w.leo_active = True

    # New in Leo 4.4.4 final: inject the scrollbar items into the text widget.
    w.leo_bodyBar = None ### bodyBar
    w.leo_bodyXBar = None ### bodyXBar
    w.leo_chapter = None
    w.leo_frame = None ### parentFrame
    w.leo_name = name
    w.leo_label = None
    w.leo_label_s = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    return w
#@-node:ekr.20081007015817.77:injectIvars
#@-node:ekr.20081031074959.20: Birth
#@+node:ekr.20081031074959.15: Do nothings
def bind (self,stroke,command,**keys):
    pass # eventFilter handles all keys.

#@-node:ekr.20081031074959.15: Do nothings
#@+node:ekr.20081031074959.40: Must be defined in base class
#@+node:ekr.20081004172422.510: Focus
def getFocus(self):

    g.trace('leoQtBody',self.widget,g.callers(4))
    return g.app.gui.get_focus()

findFocus = getFocus

def hasFocus (self):

    val = self.widget == g.app.gui.get_focus(self.c)
    # g.trace('leoQtBody returns',val,self.widget,g.callers(4))
    return val

def setFocus (self):

    # g.trace('leoQtBody',self.widget,g.callers(4))
    g.app.gui.set_focus(self.c,self.widget)
#@-node:ekr.20081004172422.510: Focus
#@+node:ekr.20081007115148.7: Indices
def toPythonIndex (self,index):

    w = self

    if type(index) == type(99):
        return index
    elif index == '1.0':
        return 0
    elif index == 'end':
        return w.getLastPosition()
    else:
        # g.trace(repr(index))
        s = w.getAllText()
        row,col = index.split('.')
        row,col = int(row),int(col)
        i = g.convertRowColToPythonIndex(s,row-1,col) # Bug fix: 2008/11/11
        # g.trace(index,row,col,i,g.callers(6))
        return i

toGuiIndex = toPythonIndex
#@-node:ekr.20081007115148.7: Indices
#@+node:ekr.20081007015817.99: Text getters/settters
#@+node:ekr.20081007015817.79:appendText
def appendText(self,s):

    s2 = self.getAllText()
    self.setAllText(s2+s,insert=len(s2))

#@-node:ekr.20081007015817.79:appendText
#@+node:ekr.20081008084746.6:delete
def delete (self,i,j=None):

    w = self.widget
    s = self.getAllText()

    i = self.toGuiIndex(i)
    if j is None: j = i+1
    j = self.toGuiIndex(j)
    if i > j: i,j = j,i

    # g.trace('i',i,'j',j)

    s = s[:i] + s[j:]
    self.setAllText(s,insert=i)

    if i > 0 or j > 0: self.indexWarning('leoQtBody.delete')
    return i
#@-node:ekr.20081008084746.6:delete
#@+node:ekr.20081103131824.13:deleteTextSelection
def deleteTextSelection (self):

    i,j = self.getSelectionRange()
    self.delete(i,j)
#@-node:ekr.20081103131824.13:deleteTextSelection
#@+node:ekr.20081007015817.80:get
def get(self,i,j=None):

    w = self.widget
    s = self.getAllText()
    i = self.toGuiIndex(i)
    if j is None: j = i+1
    j = self.toGuiIndex(j)
    return s[i:j]
#@-node:ekr.20081007015817.80:get
#@+node:ekr.20081007015817.84:getLastPosition
def getLastPosition(self):

    return len(self.getAllText())
#@-node:ekr.20081007015817.84:getLastPosition
#@+node:ekr.20081007015817.85:getSelectedText
def getSelectedText(self):

    w = self.widget

    i,j = self.getSelectionRange()
    if i == j:
        return ''
    else:
        s = self.getAllText()
        # g.trace(repr(s[i:j]))
        return s[i:j]
#@-node:ekr.20081007015817.85:getSelectedText
#@+node:ekr.20081007015817.89:insert
def insert(self,i,s):

    s2 = self.getAllText()
    i = self.toGuiIndex(i)
    self.setAllText(s2[:i] + s + s2[i:],insert=i+len(s))
    return i
#@-node:ekr.20081007015817.89:insert
#@+node:ekr.20081008175216.5:selectAllText
def selectAllText(self,insert=None):

    w = self.widget
    w.selectAll()
    if insert is not None:
        self.setInsertPoint(insert)
    # g.trace('insert',insert)

#@-node:ekr.20081008175216.5:selectAllText
#@+node:ekr.20081007015817.96:setSelectionRange
def setSelectionRange(self,*args,**keys):

    # A kludge to allow a single arg containing i,j
    w = self.widget

    if len(args) == 1:
        i,j = args[0]
    elif len(args) == 2:
        i,j = args
    else:
        g.trace('can not happen',args)
    insert = keys.get('insert')
    i,j = self.toGuiIndex(i),self.toGuiIndex(j)
    if i > j: i,j = j,i

    return self.setSelectionRangeHelper(i,j,insert)

    # g.trace('i',i,'j',j,'insert',insert,g.callers(4))

    # if self.useScintilla:
        # if i > j: i,j = j,i
        # if insert in (j,None):
            # self.setInsertPoint(j)
            # w.SendScintilla(w.SCI_SETANCHOR,i)
        # else:
            # self.setInsertPoint(i)
            # w.SendScintilla(w.SCI_SETANCHOR,j)
    # else:
        # e = QtGui.QTextCursor
        # if i > j: i,j = j,i
        # s = w.toPlainText()
        # i = max(0,min(i,len(s)))
        # j = max(0,min(j,len(s)))
        # k = max(0,min(j-i,len(s)))
        # cursor = w.textCursor()
        # if i == j:
            # cursor.setPosition(i)
        # elif insert in (j,None):
            # cursor.setPosition(i)
            # k = max(0,min(k,len(s)))
            # cursor.movePosition(e.Right,e.KeepAnchor,k)
        # else:
            # cursor.setPosition(j)
            # cursor.movePosition(e.Left,e.KeepAnchor,k)

        # w.setTextCursor(cursor)
#@-node:ekr.20081007015817.96:setSelectionRange
#@-node:ekr.20081007015817.99: Text getters/settters
#@+node:ekr.20081103092019.10:getName (baseTextWidget)
def getName (self):

    # g.trace('leoQtBaseTextWidget',self.name,g.callers())

    return self.name
#@-node:ekr.20081103092019.10:getName (baseTextWidget)
#@+node:ekr.20081011035036.1:onTextChanged
def onTextChanged (self):

    '''Update Leo after the body has been changed.

    self.selecting is guaranteed to be True during
    the entire selection process.'''

    c = self.c ; p = c.currentPosition()
    tree = c.frame.tree ; w = self
    trace = True ; verbose = False

    if tree.selecting:
        if trace and verbose: g.trace('selecting')
        return
    if tree.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if not p:
        return g.trace('*** no p')

    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText() # Converts to unicode.

    # Get the previous values from the tnode.
    oldText = g.toUnicode(p.v.t._bodyString,"utf-8")
    if oldText == newText:
        # This can happen as the result of undo.
        # g.trace('*** unexpected non-change',color="red")
        return

    if trace and verbose:
        g.trace(p.headString(),len(oldText),len(newText))

    oldIns  = p.v.t.insertSpot
    i,j = p.v.t.selectionStart,p.v.t.selectionLength
    oldSel  = (i,j-i)
    oldYview = None
    undoType = 'Typing'
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,
        oldSel=oldSel,newSel=newSel,oldYview=oldYview)

    # Update the tnode.
    p.v.setBodyString(newText)
    p.v.t.insertSpot = newInsert
    i,j = newSel
    i,j = self.toGuiIndex(i),self.toGuiIndex(j)
    if i > j: i,j = j,i
    p.v.t.selectionStart,p.v.t.selectionLength = (i,j-i)

    # No need to redraw the screen.
    if not self.useScintilla:
        c.recolor()
    if not c.changed and c.frame.initComplete:
        c.setChanged(True)
    c.frame.body.updateEditors()
    c.frame.tree.updateIcon(p)
    c.outerUpdate()
#@-node:ekr.20081011035036.1:onTextChanged
#@+node:ekr.20081016072304.12:indexWarning
warningsDict = {}

def indexWarning (self,s):

    return

    # if s not in self.warningsDict:
        # g.es_print('warning: using dubious indices in %s' % (s),color='red')
        # g.es_print('callers',g.callers(5))
        # self.warningsDict[s] = True
#@-node:ekr.20081016072304.12:indexWarning
#@-node:ekr.20081031074959.40: Must be defined in base class
#@+node:ekr.20081031074959.38: May be overridden in subclasses
def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75):
    pass

def getYScrollPosition(self):
    return None # A flag

def seeInsertPoint (self):
    self.see(self.getInsertPoint())

def setYScrollPosition(self,pos):
    pass

def scrollLines(self,n):
    pass

#@+node:ekr.20081023113729.1:Configuration
# Configuration will be handled by style sheets.
def cget(self,*args,**keys):            return None
def configure (self,*args,**keys):      pass
def setBackgroundColor(self,color):     pass
def setEditorColors (self,bg,fg):       pass
def setForegroundColor(self,color):     pass
#@-node:ekr.20081023113729.1:Configuration
#@+node:ekr.20081004172422.516:Idle time
def after_idle(self,func,threadCount):
    # g.trace(func.__name__,'threadCount',threadCount)
    return func(threadCount)

def after(self,n,func,threadCount):
    def after_callback(func=func,threadCount=threadCount):
        # g.trace(func.__name__,threadCount)
        return func(threadCount)
    QtCore.QTimer.singleShot(n,after_callback)

def scheduleIdleTimeRoutine (self,function,*args,**keys):
    g.trace()
    # if not g.app.unitTesting:
        # self.widget.after_idle(function,*args,**keys)
#@-node:ekr.20081004172422.516:Idle time
#@+node:ekr.20081023131208.10:Coloring
# These are body methods.
# def forceFullRecolor (self): pass
# def update_idletasks(self):  pass

def removeAllTags(self):
    s = self.getAllText()
    self.colorSelection(0,len(s),'black')

def tag_add(self,tag,x1,x2):
    if tag == 'comment1':
        self.colorSelection(x1,x2,'firebrick')

def tag_config (self,*args,**keys):
    if len(args) == 1:
        key = args[0]
        # g.trace(key,keys)
        self.tags[key] = keys
    else:
        g.trace('oops',args,keys)

tag_configure = tag_config

def tag_names (self):
    return []
#@+node:ekr.20081029084058.10:colorSelection
def colorSelection (self,i,j,colorName):

    w = self.widget
    color = QtGui.QColor(colorName)
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    old_i,old_j = self.getSelectionRange()
    old_ins = self.getInsertPoint()
    self.setSelectionRange(i,j)
    w.setTextColor(color)
    self.setSelectionRange(old_i,old_j,insert=old_ins)
    sb.setSliderPosition(pos)
#@-node:ekr.20081029084058.10:colorSelection
#@-node:ekr.20081023131208.10:Coloring
#@-node:ekr.20081031074959.38: May be overridden in subclasses
#@+node:ekr.20081031074959.29: Must be overridden in subclasses
def getAllText(self):                   self.oops()
def getInsertPoint(self):               self.oops()
def getSelectionRange(self,sort=True):  self.oops()
def hasSelection(self):                 self.oops()
def see(self,i):                        self.oops()
def setAllText(self,s,insert=None):     self.oops()
def setInsertPoint(self,i):             self.oops()
#@-node:ekr.20081031074959.29: Must be overridden in subclasses
#@-node:ekr.20081031074959.12: class leoQtBaseTextWidget
#@+node:ekr.20081101134906.13: class leoQLineEditWidget
class leoQLineEditWidget (leoQtBaseTextWidget):

    @others
#@+node:ekr.20081101134906.14:Birth
#@+node:ekr.20081101134906.15:ctor
def __init__ (self,widget,name,c=None):

    # Init the base class.
    leoQtBaseTextWidget.__init__(self,widget,name,c=c)

    self.baseClassName='leoQLineEditWidget'

    # g.trace('leoQLineEditWidget',id(widget),g.callers(4))

    self.setConfig()
    self.setFontFromConfig()
    self.setColorFromConfig()
#@-node:ekr.20081101134906.15:ctor
#@+node:ekr.20081101134906.16:setFontFromConfig
def setFontFromConfig (self,w=None):

    '''Set the font in the widget w (a body editor).'''

    return

    # c = self.c
    # if not w: w = self.widget

    # font = c.config.getFontFromParams(
        # "head_text_font_family", "head_text_font_size",
        # "head_text_font_slant",  "head_text_font_weight",
        # c.config.defaultBodyFontSize)

    # self.fontRef = font # ESSENTIAL: retain a link to font.
    # # w.configure(font=font)

    # # g.trace("BODY",body.cget("font"),font.cget("family"),font.cget("weight"))
#@-node:ekr.20081101134906.16:setFontFromConfig
#@+node:ekr.20081101134906.17:setColorFromConfig
def setColorFromConfig (self,w=None):

    '''Set the font in the widget w (a body editor).'''

    return

    # c = self.c
    # if w is None: w = self.widget

    # bg = c.config.getColor("body_text_background_color") or 'white'
    # try:
        # pass ### w.configure(bg=bg)
    # except:
        # g.es("exception setting body text background color")
        # g.es_exception()

    # fg = c.config.getColor("body_text_foreground_color") or 'black'
    # try:
        # pass ### w.configure(fg=fg)
    # except:
        # g.es("exception setting body textforeground color")
        # g.es_exception()

    # bg = c.config.getColor("body_insertion_cursor_color")
    # if bg:
        # try:
            # pass ### w.configure(insertbackground=bg)
        # except:
            # g.es("exception setting body pane cursor color")
            # g.es_exception()

    # sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
    # try:
        # pass ### w.configure(selectbackground=sel_bg)
    # except Exception:
        # g.es("exception setting body pane text selection background color")
        # g.es_exception()

    # sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
    # try:
        # pass ### w.configure(selectforeground=sel_fg)
    # except Exception:
        # g.es("exception setting body pane text selection foreground color")
        # g.es_exception()

    # # if sys.platform != "win32": # Maybe a Windows bug.
        # # fg = c.config.getColor("body_cursor_foreground_color")
        # # bg = c.config.getColor("body_cursor_background_color")
        # # if fg and bg:
            # # cursor="xterm" + " " + fg + " " + bg
            # # try:
                # # pass ### w.configure(cursor=cursor)
            # # except:
                # # import traceback ; traceback.print_exc()
#@-node:ekr.20081101134906.17:setColorFromConfig
#@+node:ekr.20081101134906.18:setConfig
def setConfig (self):
    pass
#@nonl
#@-node:ekr.20081101134906.18:setConfig
#@-node:ekr.20081101134906.14:Birth
#@+node:ekr.20081101134906.19:Widget-specific overrides (QLineEdit)
#@+node:ekr.20081101134906.20:getAllText
def getAllText(self):

    w = self.widget
    s = w.text()
    s = g.toUnicode(s,'utf-8')
    # g.trace(repr(s))
    return s
#@-node:ekr.20081101134906.20:getAllText
#@+node:ekr.20081101134906.21:getInsertPoint
def getInsertPoint(self):

    i = self.widget.cursorPosition()
    # g.trace(i)
    return i
#@-node:ekr.20081101134906.21:getInsertPoint
#@+node:ekr.20081101134906.22:getSelectionRange
def getSelectionRange(self,sort=True):

    w = self.widget

    if w.hasSelectedText():
        i = w.selectionStart()
        s = w.selectedText()
        s = g.toUnicode(s,'utf-8')
        j = i + len(s)
    else:
        i = j = w.cursorPosition()

    # g.trace(i,j)
    return i,j
#@-node:ekr.20081101134906.22:getSelectionRange
#@+node:ekr.20081101134906.23:hasSelection
def hasSelection(self):

    return self.widget.hasSelection()
#@-node:ekr.20081101134906.23:hasSelection
#@+node:ekr.20081101134906.24:see & seeInsertPoint
def see(self,i):
    pass

def seeInsertPoint (self):
    pass
#@-node:ekr.20081101134906.24:see & seeInsertPoint
#@+node:ekr.20081101134906.25:setAllText
def setAllText(self,s,insert=None):

    w = self.widget
    i = g.choose(insert is None,0,insert)
    w.setText(s)
    if insert is not None:
        self.setSelectionRange(i,i,insert=i)

    # g.trace(i,repr(s))
#@-node:ekr.20081101134906.25:setAllText
#@+node:ekr.20081101134906.26:setInsertPoint
def setInsertPoint(self,i):

    w = self.widget
    s = w.text()
    s = g.toUnicode(s,'utf-8')
    i = max(0,min(i,len(s)))
    w.setCursorPosition(i)
#@-node:ekr.20081101134906.26:setInsertPoint
#@+node:ekr.20081101134906.27:setSelectionRangeHelper
def setSelectionRangeHelper(self,i,j,insert):

    w = self.widget
    # g.trace('i',i,'j',j,'insert',insert,g.callers(4))
    if i > j: i,j = j,i
    s = w.text()
    s = g.toUnicode(s,'utf-8')
    i = max(0,min(i,len(s)))
    j = max(0,min(j,len(s)))
    k = max(0,min(j-i,len(s)))
    if i == j:
        w.setCursorPosition(i)
    else:
        w.setSelection(i,k)
#@-node:ekr.20081101134906.27:setSelectionRangeHelper
#@-node:ekr.20081101134906.19:Widget-specific overrides (QLineEdit)
#@-node:ekr.20081101134906.13: class leoQLineEditWidget
#@+node:ekr.20081018130812.12:class findTextWrapper
class findTextWrapper (leoQLineEditWidget):

    '''A class representing the find/change edit widgets.'''

    pass
#@-node:ekr.20081018130812.12:class findTextWrapper
#@-node:ekr.20081107114035.10:Made findTextWrapper a subclass...
#@+node:ekr.20081107114035.11:Fixed (??) crash in editLabel
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoCommands.py", line 320, in doCommand
    val = command(event)
  File "C:\leo.repo\qt-plugin\leo\core\leoEditCommands.py", line 7803, in findTabFindNext
    self.findTabHandler.findNextCommand()
  File "C:\leo.repo\qt-plugin\leo\core\leoFind.py", line 1506, in findNextCommand
    self.findNext()
  File "C:\leo.repo\qt-plugin\leo\core\leoFind.py", line 744, in findNext
    self.showSuccess(pos,newpos)
  File "C:\leo.repo\qt-plugin\leo\core\leoFind.py", line 1359, in showSuccess
    c.editPosition(p)
  File "C:\leo.repo\qt-plugin\leo\core\leoCommands.py", line 7233, in editPosition
    c.frame.tree.editLabel(p,selectAll=selectAll)
  File "C:\leo.repo\qt-plugin\leo\plugins\qtGui.py", line 4943, in editLabel
    # c.outerUpdate()
RuntimeError: underlying C/C++ object has been deleted
#@nonl
#@+node:ekr.20081004172422.846:editLabel (override)
def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c ; trace = True ; verbose = False

    if self.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if self._editWidget:
        # Not an error, because of key weirdness.
        g.trace('already editing')
        return

    if trace:
        g.trace('*** all',selectAll,p.headString(),g.callers(4))

    w = self.treeWidget
    data = self.vnodeDict.get(p.v)
    if not data:
        if trace and verbose:
            g.trace('No data: redrawing if possible')
        c.outerUpdate() # Do any scheduled redraw.
        data = self.vnodeDict.get(p.v)

    if data:
        item = data [0][1]
    else:
        if trace and not g.app.unitTesting:
            g.trace('*** Can not happen: no data',p and p.headString())
        return None

    if item:
        w.setCurrentItem(item) # Must do this first.
        w.editItem(item)
        e = w.itemWidget(item,0) # A QLineEdit
        if e:
            s = e.text() ; len_s = len(s)
            # Hook up the widget to Leo's core.
            self._editWidgetPosition = p.copy()
            self._editWidget = e
            self._editWidgetWrapper = leoQtHeadlineWidget(
                widget=e,name='head',c=c)
            start,n = g.choose(selectAll,
                tuple([0,len_s]),tuple([len_s,0]))
            e.setObjectName('headline')
            e.setSelection(start,n)
            e.setFocus()
        else: g.trace('*** no e')
    else:
        self._editWidgetPosition = None
        self._editWidget = None
        self._editWidgetWrapper = None
        e = None
        g.trace('*** no item')

    # A nice hack: just set the focus request.
    c.requestedFocusWidget = e
#@-node:ekr.20081004172422.846:editLabel (override)
#@-node:ekr.20081107114035.11:Fixed (??) crash in editLabel
#@+node:ekr.20081107120516.10:Fixed problems with minibuffer interface
# The problems were solved by making the minibuffer a subclass of leoQTextEditWidget.
#@nonl
#@+node:ekr.20081017015442.12:class leoQtMinibuffer (leoQLineEditWidget)
class leoQtMinibuffer (leoQLineEditWidget):

    def __init__ (self,c):
        self.c = c
        w = c.frame.top.ui.lineEdit # QLineEdit
        # Init the base class.
        leoQLineEditWidget.__init__(self,widget=w,name='minibuffer',c=c)

        self.ev_filter = leoQtEventFilter(c,w=self,tag='minibuffer')
        w.installEventFilter(self.ev_filter)

    def setBackgroundColor(self,color):
        self.widget.setStyleSheet('background-color:%s' % color)

    def setForegroundColor(self,color):
        pass
#@-node:ekr.20081017015442.12:class leoQtMinibuffer (leoQLineEditWidget)
#@-node:ekr.20081107120516.10:Fixed problems with minibuffer interface
#@+node:ekr.20081109123309.11:Recent crasher (after find)

wrote recent file: C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
exception executing command
Traceback (most recent call last):

  File "C:\leo.repo\qt-plugin\leo\core\leoCommands.py", line 320, in doCommand
    val = command(event)

  File "C:\leo.repo\qt-plugin\leo\core\leoEditCommands.py", line 7803, in findTabFindNext
    self.findTabHandler.findNextCommand()

  File "C:\leo.repo\qt-plugin\leo\core\leoFind.py", line 1506, in findNextCommand
    self.findNext()

  File "C:\leo.repo\qt-plugin\leo\core\leoFind.py", line 744, in findNext
    self.showSuccess(pos,newpos)

  File "C:\leo.repo\qt-plugin\leo\core\leoFind.py", line 1359, in showSuccess
    c.editPosition(p)

  File "C:\leo.repo\qt-plugin\leo\core\leoCommands.py", line 7233, in editPosition
    c.frame.tree.editLabel(p,selectAll=selectAll)

  File "C:\leo.repo\qt-plugin\leo\plugins\qtGui.py", line 4277, in editLabel
    w.editItem(item)

RuntimeError: underlying C/C++ object has been deleted
#@+node:ekr.20081004172422.846:editLabel (override)
def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c ; trace = True ; verbose = False

    if self.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if self._editWidget:
        # Not an error, because of key weirdness.
        g.trace('already editing')
        return

    if trace:
        g.trace('*** all',selectAll,p.headString(),g.callers(4))

    w = self.treeWidget
    data = self.vnodeDict.get(p.v)
    if not data:
        if trace and verbose:
            g.trace('No data: redrawing if possible')
        c.outerUpdate() # Do any scheduled redraw.
        data = self.vnodeDict.get(p.v)

    if data:
        item = data [0][1]
    else:
        if trace and not g.app.unitTesting:
            g.trace('*** Can not happen: no data',p and p.headString())
        return None

    if item:
        w.setCurrentItem(item) # Must do this first.
        w.editItem(item)
        e = w.itemWidget(item,0) # A QLineEdit
        if e:
            s = e.text() ; len_s = len(s)
            # Hook up the widget to Leo's core.
            self._editWidgetPosition = p.copy()
            self._editWidget = e
            self._editWidgetWrapper = leoQtHeadlineWidget(
                widget=e,name='head',c=c)
            start,n = g.choose(selectAll,
                tuple([0,len_s]),tuple([len_s,0]))
            e.setObjectName('headline')
            e.setSelection(start,n)
            e.setFocus()
        else: g.trace('*** no e')
    else:
        self._editWidgetPosition = None
        self._editWidget = None
        self._editWidgetWrapper = None
        e = None
        g.trace('*** no item')

    # A nice hack: just set the focus request.
    c.requestedFocusWidget = e
#@-node:ekr.20081004172422.846:editLabel (override)
#@-node:ekr.20081109123309.11:Recent crasher (after find)
#@+node:ekr.20081115134154.10:Fixed headline data loss bug
#@+node:ekr.20081113091207.1:Report
To reproduce:

- open any outline
- hit Ctrl-I to add a node
- select the headline so you can edit it
- change the headline, then press Ctrl-S to save the outline.

Important: press Ctrl-S when the headline is still selected and can be
modified.

It looks like the change is lost. If I change the focus to another
headline, then press Ctrl-S after changing focus, the change is saved.

The tk GUI behaves normally, no changes are lost. So I qualify this as
a bug in the qt GUI.

Slackware Linux 12.1
Python 2.6
qt/pyqt 4.4.3
r1486 of qt-plugin
#@nonl
#@-node:ekr.20081113091207.1:Report
#@+node:ekr.20081005065934.10:qtTree.initAfterLoad
def initAfterLoad (self):

    c = self.c ; frame = c.frame
    w = c.frame.top ; tw = self.treeWidget

    if not leoQtTree.callbacksInjected:
        leoQtTree.callbacksInjected = True
        self.injectCallbacks() # A base class method.

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemDoubleClicked(QTreeWidgetItem*, int)"),
        self.onItemDoubleClicked)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemSelectionChanged()"),
        self.onTreeSelect)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemChanged(QTreeWidgetItem*, int)"),
        self.sig_itemChanged)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemCollapsed(QTreeWidgetItem*)"),
        self.sig_itemCollapsed)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemExpanded(QTreeWidgetItem*)"),
        self.sig_itemExpanded)

    self.ev_filter = leoQtEventFilter(c,w=self,tag='tree')
    tw.installEventFilter(self.ev_filter)

    c.setChanged(False)
#@-node:ekr.20081005065934.10:qtTree.initAfterLoad
#@+node:ekr.20081004172422.846:editLabel (override)
def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c ; trace = True ; verbose = False

    if self.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if self._editWidget:
        # Not an error, because of key weirdness.
        g.trace('already editing')
        return

    if trace:
        g.trace('*** all',selectAll,p.headString(),g.callers(4))

    w = self.treeWidget
    data = self.vnodeDict.get(p.v)
    if not data:
        if trace and verbose:
            g.trace('No data: redrawing if possible')
        c.outerUpdate() # Do any scheduled redraw.
        data = self.vnodeDict.get(p.v)

    if data:
        item = data [0][1]
    else:
        if trace and not g.app.unitTesting:
            g.trace('*** Can not happen: no data',p and p.headString())
        return None

    if item:
        w.setCurrentItem(item) # Must do this first.
        w.editItem(item)
        e = w.itemWidget(item,0) # A QLineEdit
        if e:
            s = e.text() ; len_s = len(s)
            # Hook up the widget to Leo's core.
            self._editWidgetPosition = p.copy()
            self._editWidget = e
            self._editWidgetWrapper = leoQtHeadlineWidget(
                widget=e,name='head',c=c)
            start,n = g.choose(selectAll,
                tuple([0,len_s]),tuple([len_s,0]))
            e.setObjectName('headline')
            e.setSelection(start,n)
            e.setFocus()
        else: g.trace('*** no e')
    else:
        self._editWidgetPosition = None
        self._editWidget = None
        self._editWidgetWrapper = None
        e = None
        g.trace('*** no item')

    # A nice hack: just set the focus request.
    c.requestedFocusWidget = e
#@-node:ekr.20081004172422.846:editLabel (override)
#@+node:ekr.20081004172422.799:edit_widget
def edit_widget (self,p):

    """Returns the Qt.Edit widget for position p."""

    w = self._editWidgetWrapper

    if p and p == self._editWidgetPosition:
        return w
    else:
        return None

    # Decouple all of the core's headline code.
    # Except for over-ridden methods.
#@-node:ekr.20081004172422.799:edit_widget
#@+node:ekr.20081117065611.1:onItemDoubleClicked
def onItemDoubleClicked (self,item,col):

    c = self.c ; w = self.treeWidget
    w.setCurrentItem(item) # Must do this first.
    w.editItem(item)
    e = w.itemWidget(item,0)
    if not e:
        return g.trace('*** no e')
    p = self.itemsDict.get(item)
    if not p:
        return g.trace('*** no p')
    # Hook up the widget to Leo's core.
    e.connect(e,
        QtCore.SIGNAL("textEdited(QTreeWidgetItem*,int)"),
        self.onHeadChanged)
    self._editWidgetPosition = p.copy()
    self._editWidget = e
    self._editWidgetWrapper = leoQtHeadlineWidget(
        widget=e,name='head',c=c)
    e.setObjectName('headline')
#@-node:ekr.20081117065611.1:onItemDoubleClicked
#@+node:ekr.20081009055104.8:onTreeSelect
def onTreeSelect(self):

    '''Select the proper position when a tree node is selected.'''

    trace = False ; verbose = False
    c = self.c ; w = self.treeWidget 

    if self.selecting:
        if trace: g.trace('already selecting')
        return
    if self.redrawing:
        if trace: g.trace('drawing')
        return

    item = w.currentItem()
    if trace and verbose: g.trace('item',item)
    p = self.itemsDict.get(item)
    if p:
        if trace: g.trace(p and p.headString())
        c.frame.tree.select(p) # The crucial hook.
        # g.trace(g.callers())
        c.outerUpdate()
    else:
        # An error: we are not redrawing.
        g.trace('no p for item: %s' % item,g.callers(4))
#@nonl
#@-node:ekr.20081009055104.8:onTreeSelect
#@+node:ekr.20081030120643.11:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.'''

    trace = False ; verbose = True
    c = self.c ; u = c.undoer
    e = self._editWidget
    p = self._editWidgetPosition
    w = g.app.gui.get_focus()

    # These are not errors: sig_itemChanged may
    # have been called first.
    if not e:
        if trace: g.trace('No e')
        return 
    if e != w:
        if trace and verbose: g.trace('e != w',e,w,g.callers(4))
        self._editWidget = None
        self._editWidgetPosition = None
        self._editWidgetWrapper = None
        return
    if not p:
        if trace: g.trace('No p')
        return
    s = e.text() ; len_s = len(s)
    s = g.toUnicode(s,'utf-8')
    oldHead = p.headString()
    changed = s != oldHead
    if trace: g.trace('changed',changed,repr(s),g.callers(4))
    if not changed: return
    p.initHeadString(s)
    undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
    if not c.changed: c.setChanged(True)
    # New in Leo 4.4.5: we must recolor the body because
    # the headline may contain directives.
    c.frame.body.recolor(p,incremental=True)
    dirtyVnodeList = p.setDirty()
    u.afterChangeNodeContents(p,undoType,undoData,
        dirtyVnodeList=dirtyVnodeList)
    # End the editing!
    self._editWidget = None
    self._editWidgetPosition = None
    self._editWidgetWrapper = None
    c.redraw(scroll=False)
    if self.stayInTree:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()
#@nonl
#@-node:ekr.20081030120643.11:onHeadChanged
#@+node:ekr.20081021043407.24:drawNode
def drawNode (self,p,dummy=False):

    c = self.c ; w = self.treeWidget ; trace = False
    self.nodeDrawCount += 1

    # Allocate the qt tree item.
    parent = p.parent()
    itemOrTree = self.parentsDict.get(parent and parent.v,w)

    if trace and not self.fullDrawing:
        g.trace(id(itemOrTree),parent and parent.headString())

    item = QtGui.QTreeWidgetItem(itemOrTree)
    item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)

    # Draw the headline and the icon.
    item.setText(0,p.headString())
    icon = self.getIcon(p)
    if icon: item.setIcon(0,icon)

    if dummy: return item

    # Remember the associatiation of item with p, and vice versa.
    self.itemsDict[item] = p.copy()
    self.parentsDict[p.v] = item 

    # Remember the association of p.v with (p,item)
    aList = self.vnodeDict.get(p.v,[])
    data = p.copy(),item
    aList.append(data)
    self.vnodeDict[p.v] = aList

    # Remember the association of p.v.t with (p,item).
    aList = self.tnodeDict.get(p.v.t,[])
    data = p.copy(),item
    aList.append(data)
    self.tnodeDict[p.v.t] = aList

    return item
#@-node:ekr.20081021043407.24:drawNode
#@-node:ekr.20081115134154.10:Fixed headline data loss bug
#@-node:ekr.20081014095718.13:Recent projects...
#@+node:ekr.20081018155359.11:Unused
#@+node:ekr.20081010070648.17:setTreeFont
def setTreeFont (self):

    c = self.c ; w = self.treeWidget

    font = c.config.getFontFromParams(
        "headline_text_font_family", "headline_text_font_size",
        "headline_text_font_slant",  "headline_text_font_weight",
        c.config.defaultTreeFontSize)

    if not font:
        # g.trace('*** no font, using default')
        font = QtGui.QFont("SansSerif",12, QtGui.QFont.Normal)

    w.setFont(font)
#@-node:ekr.20081010070648.17:setTreeFont
#@+node:ekr.20081010070648.15:setTreeColors
def setTreeColors (self):

    pass # Style sheets now work.

    # p = QtGui.QPalette ; w = self.treeWidget
    # black = QtGui.QColor('black')
    # red   = QtGui.QColor('red')
    # white = QtGui.QColor('white')

    # # Create a single palette.
    # palette = p()

    # # Selected, not editing.
    # fg    = self.headline_text_selected_foreground_color or black
    # bg    = self.headline_text_selected_background_color or 'grey80'
    # selfg = self.headline_text_editing_selection_foreground_color
    # selbg = self.headline_text_editing_selection_background_color

    # # Selected, editing
    # fg    = self.headline_text_editing_foreground_color or black
    # bg    = self.headline_text_editing_background_color or white
    # selfg = self.headline_text_editing_selection_foreground_color or white
    # selbg = self.headline_text_editing_selection_background_color or black

    # # Not selected.
    # fg = self.headline_text_unselected_foreground_color or black
    # bg = self.headline_text_unselected_background_color or white

    # # Assign colors to the single palette.
    # palette.setColor(p.Active,p.Background,red)

    # # w.setPalette(palette)
#@-node:ekr.20081010070648.15:setTreeColors
#@+node:ekr.20081004172422.519:Editors (to do) (was in leoQtBaseTextWidget)
#@+node:ekr.20081004172422.520:createEditorFrame
def createEditorFrame (self,pane):

    # f = qt.Frame(pane)
    # f.pack(side='top',expand=1,fill='both')
    # return f

    return None
#@-node:ekr.20081004172422.520:createEditorFrame
#@+node:ekr.20081004172422.521:packEditorLabelWidget
def packEditorLabelWidget (self,w):

    '''Create a Qt label widget.'''

    return ###

    # if not hasattr(w,'leo_label') or not w.leo_label:
        # # g.trace('w.leo_frame',id(w.leo_frame))
        # w.pack_forget()
        # w.leo_label = Qt.Label(w.leo_frame)
        # w.leo_label.pack(side='top')
        # w.pack(expand=1,fill='both')
#@-node:ekr.20081004172422.521:packEditorLabelWidget
#@+node:ekr.20081031074959.19:updateEditors
def updateEditors (self):

    pass
#@nonl
#@-node:ekr.20081031074959.19:updateEditors
#@-node:ekr.20081004172422.519:Editors (to do) (was in leoQtBaseTextWidget)
#@-node:ekr.20081018155359.11:Unused
#@+node:ekr.20081024175359.10:Scripts
#@+node:ekr.20081022172620.10:Script to display Qt font database
import PyQt4.QtGui as QtGui

db = QtGui.QFontDatabase()
for family in db.families():
    print family
    for style in db.styles(family):
        print '\t',style,db.smoothSizes(family,style)
#@-node:ekr.20081022172620.10:Script to display Qt font database
#@+node:ekr.20081020151747.10:dump guiBindNamesInverseDict
print g.dictToString(c.k.guiBindNamesInverseDict)

@
   BackSpace: 'BackSpace'
       Begin: 'Begin'
       Break: 'Break'
   Caps_Lock: 'Caps_Lock'
       Clear: 'Clear'
      Delete: 'Delete'
        Down: 'Down'
         End: 'End'
      Escape: 'Escape'
          F1: 'F1'
         F10: 'F10'
         F11: 'F11'
         F12: 'F12'
          F2: 'F2'
          F3: 'F3'
          F4: 'F4'
          F5: 'F5'
          F6: 'F6'
          F7: 'F7'
          F8: 'F8'
          F9: 'F9'
        Home: 'Home'
        Left: 'Left'
    Linefeed: 'Linefeed'
        Next: 'Next'
    Num_Lock: 'Num_Lock'
       Prior: 'Prior'
      Return: 'Return'
       Right: 'Right'
         Tab: 'Tab'
          Up: 'Up'
   ampersand: '&'
 asciicircum: '^'
  asciitilde: '~'
    asterisk: '*'
          at: '@'
   backslash: '\\'
         bar: '|'
   braceleft: '{'
  braceright: '}'
 bracketleft: '['
bracketright: ']'
       colon: ':'
       comma: ','
      dollar: '$'
       equal: '='
      exclam: '!'
     greater: '>'
        less: '<'
       minus: '-'
  numbersign: '#'
   parenleft: '('
  parenright: ')'
     percent: '%'
      period: '.'
        plus: '+'
    question: '?'
    quotedbl: '"'
   quoteleft: '`'
  quoteright: "'"
   semicolon: ';'
       slash: '/'
       space: ' '
  underscore: '_'
#@nonl
#@-node:ekr.20081020151747.10:dump guiBindNamesInverseDict
#@-node:ekr.20081024175359.10:Scripts
#@-all
#@nonl
#@-node:ekr.20081016072304.13:@thin qtNotes.txt
#@-leo
