#@+leo-ver=4-thin
#@+node:ekr.20081121105001.147:@thin qtNotes.txt
#@+all
#@+node:ekr.20081121105001.148: qt To do
#@+node:ekr.20090304084841.10:Asap 4
#@+node:ekr.20081215074704.16:Mark finds doesn't work in Qt gui plugin
http://groups.google.com/group/leo-editor/browse_thread/thread/b2af78fbb36d3590
#@nonl
#@-node:ekr.20081215074704.16:Mark finds doesn't work in Qt gui plugin
#@+node:ekr.20090304084841.15:Complete open-with menu
#@-node:ekr.20090304084841.15:Complete open-with menu
#@+node:ekr.20081215162017.5:Support multiple body editors
@

The body part is a QFrame with QGridLayout.

For an example, run this script:
@c

from PyQt4.QtGui import QTextEdit
w = QTextEdit()
c.frame.top.ui.leo_body_inner_frame.layout().addWidget(w,0,1)
#@-node:ekr.20081215162017.5:Support multiple body editors
#@+node:ekr.20090128083504.1:Fix rclick
@nocolor-node

rClick


After the qt-plugin merge (rev 1251 ), the image plugin no longer works. I
couldn't find any mention of gsimage in the diff.

 # Erase image if it was previously displayed
             a = g.app ; c = keywords.get("c")

-            if a.gsimage:
+            if getattr(a, 'gsimage', None):
                 try:
                     c.frame.body.bodyCtrl.delete(a.gsimage)
                 except:
#@-node:ekr.20090128083504.1:Fix rclick
#@-node:ekr.20090304084841.10:Asap 4
#@+node:ekr.20090304084841.11:Later
#@+node:ekr.20081215074704.21:Add drag and drop
#@-node:ekr.20081215074704.21:Add drag and drop
#@+node:ekr.20081121105001.151:Clean up settings
- Can style sheets really do the job?

- Remove old-style Leo settings?

- Add stylesheets for dialogs.
    - Set font for dummy widget in style sheet, then copy that font.
#@+node:ekr.20081121105001.150:QScintilla stuff
- Check event handling with QScintilla.
- Experiment with sending <shift-tab> directly to QScintilla.
- Call setLexer(0) for nocolor nodes.
- Add settings for syntax coloring.
- Make Scintilla handle Leo markup.
- Install new Qt version and play with QScintilla.
    From QScintilla change log:
    2008/10/12 14:32:05  phil
    QsciScintilla::setSelection() is now implemented using SCI_SETSEL so that the
    carat can be left at either the start or the end of the selection.
    Exposed QsciScintilla::positionFromLineIndex() and
    QsciScintilla::lineIndexFromPosition().
    - Fix problem with accented characters: see child node for notes.
#@nonl
#@-node:ekr.20081121105001.150:QScintilla stuff
#@-node:ekr.20081121105001.151:Clean up settings
#@+node:ekr.20081215162017.4:Allow coloring of script buttons
#@-node:ekr.20081215162017.4:Allow coloring of script buttons
#@+node:ekr.20081215074704.20:Change background color of body pane depending on focus
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/1cce885a697d0236/5aea5d0587b47b92?lnk=gst&q=command+and+insert#5aea5d0587b47b92

Set focus in/out events.
#@nonl
#@-node:ekr.20081215074704.20:Change background color of body pane depending on focus
#@+node:ekr.20081124094918.1:Fix problems with scim
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/59c1e5d6acaf4de0

I've some more information about the problems with accent previously
reported:
- I can confirm that they are caused by the interaction scim+leo (with
and without the qt plugin). If scim is not started leo works fine. If
scim is running the problems appear and are slightly different with
and without the qt plugin. The workaround is obvious: don't use leo
and scim at the same time :-)
- accents are not working in the qt plugin when scintilla is used. If
qt-use-scintilla=False I can write this:

àáä (the same for the rest of vowels)

but if qt-use-scintilla=True when I enter the same sequence in the
keyboard I get:

`aaa (the same for the rest of vowels)

- the problem with the ñ character (reported previously too) is only
present in the qt plugin (both with and without scintilla)
#@-node:ekr.20081124094918.1:Fix problems with scim
#@+node:ekr.20090223065019.11:Make Leo's page-up/page-down commands funtional
# This will be needed for vim.
#@nonl
#@-node:ekr.20090223065019.11:Make Leo's page-up/page-down commands funtional
#@-node:ekr.20090304084841.11:Later
#@-node:ekr.20081121105001.148: qt To do
#@+node:ekr.20081121105001.185:Scripts
#@+node:ekr.20081121105001.186:Script to display Qt font database
import PyQt4.QtGui as QtGui

db = QtGui.QFontDatabase()
for family in db.families():
    print family
    for style in db.styles(family):
        print '\t',style,db.smoothSizes(family,style)
#@-node:ekr.20081121105001.186:Script to display Qt font database
#@+node:ekr.20081121105001.187:dump guiBindNamesInverseDict
print g.dictToString(c.k.guiBindNamesInverseDict)

@
   BackSpace: 'BackSpace'
       Begin: 'Begin'
       Break: 'Break'
   Caps_Lock: 'Caps_Lock'
       Clear: 'Clear'
      Delete: 'Delete'
        Down: 'Down'
         End: 'End'
      Escape: 'Escape'
          F1: 'F1'
         F10: 'F10'
         F11: 'F11'
         F12: 'F12'
          F2: 'F2'
          F3: 'F3'
          F4: 'F4'
          F5: 'F5'
          F6: 'F6'
          F7: 'F7'
          F8: 'F8'
          F9: 'F9'
        Home: 'Home'
        Left: 'Left'
    Linefeed: 'Linefeed'
        Next: 'Next'
    Num_Lock: 'Num_Lock'
       Prior: 'Prior'
      Return: 'Return'
       Right: 'Right'
         Tab: 'Tab'
          Up: 'Up'
   ampersand: '&'
 asciicircum: '^'
  asciitilde: '~'
    asterisk: '*'
          at: '@'
   backslash: '\\'
         bar: '|'
   braceleft: '{'
  braceright: '}'
 bracketleft: '['
bracketright: ']'
       colon: ':'
       comma: ','
      dollar: '$'
       equal: '='
      exclam: '!'
     greater: '>'
        less: '<'
       minus: '-'
  numbersign: '#'
   parenleft: '('
  parenright: ')'
     percent: '%'
      period: '.'
        plus: '+'
    question: '?'
    quotedbl: '"'
   quoteleft: '`'
  quoteright: "'"
   semicolon: ';'
       slash: '/'
       space: ' '
  underscore: '_'
#@nonl
#@-node:ekr.20081121105001.187:dump guiBindNamesInverseDict
#@-node:ekr.20081121105001.185:Scripts
#@+node:ekr.20090124101344.1:Recent
#@+node:ekr.20081215074704.15:Cut/paste work erratically
#@+node:ekr.20090128083504.11:Report
#@-node:ekr.20090128083504.11:Report
#@+node:ekr.20081121105001.502:toUnicode (qtGui)
def toUnicode (self,s,encoding='utf-8',reportErrors=True):    
    return unicode(s)
#@nonl
#@-node:ekr.20081121105001.502:toUnicode (qtGui)
#@+node:ekr.20081121105001.183:Clipboard (qtGui)
def replaceClipboardWith (self,s):

    '''Replace the clipboard with the string s.'''

    trace = False
    cb = self.qtApp.clipboard()
    if cb:
        #cb.clear()  # unnecessary, breaks on some Qt versions
        s = g.app.gui.toUnicode(s,
            encoding=g.app.tkEncoding,
            reportErrors=True)
        cb.setText(s)
        if trace: g.trace(len(s),type(s))
    else:
        g.trace('no clipboard!')

def getTextFromClipboard (self):

    '''Get a unicode string from the clipboard.'''

    trace = False
    cb = self.qtApp.clipboard()
    if cb:
        s = cb.text()
        if trace: g.trace (len(s),type(s))
        s = g.app.gui.toUnicode(s,
            encoding=g.app.tkEncoding,
            reportErrors=True)
        return s
    else:
        g.trace('no clipboard!')
        return ''
#@-node:ekr.20081121105001.183:Clipboard (qtGui)
#@-node:ekr.20081215074704.15:Cut/paste work erratically
#@+node:ekr.20090128173959.1:Fixed headline reversion
#@+node:ekr.20090126120517.22:getItemText (debugging only)
def getItemText (self,item):

    '''Return the text of the item.'''

    if item:
        return unicode(item.text(0))
    else:
        return '<no item>'
#@nonl
#@-node:ekr.20090126120517.22:getItemText (debugging only)
#@+node:ekr.20090124174652.59:onHeadChanged (nativeTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; u = c.undoer
    if not p:
        if trace: g.trace('*** no p')
        return

    item = self.position2item(p)
    if not item:
        # This is not an error.
        if trace: g.trace('no item for p: %s' % (p))
        return

    w = g.app.gui.get_focus()
    ew = self.edit_widget(p)
    if ew: e = ew.widget
    else: e = None

    # These are not errors: focus may have been lost.
    # if trace and verbose:
        # if not e:  g.trace('No e',g.callers(4))
        # if e != w: g.trace('e != w',e,w,g.callers(4))
        # if not p:  g.trace('No p')

    if e and e == w:
        s = e.text() ; len_s = len(s)
        s = g.app.gui.toUnicode(s)
    else:
        s = self.getItemText(item)

    oldHead = p.h
    changed = s != oldHead
    if changed:
        if trace: g.trace('changed',repr(s),p.h)
        p.initHeadString(s)
        item.setText(0,s) # Required to avoid full redraw.
        undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)

    # This is a crucial shortcut.
    if g.unitTesting: return

    self.redraw_after_head_changed()
    self.closeEditorHelper(ew,item)
    if self.stayInTree:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()
    c.outerUpdate()
#@-node:ekr.20090124174652.59:onHeadChanged (nativeTree)
#@+node:ekr.20090124174652.58:endEditLabel (nativeTree)
def endEditLabel (self):

    '''Override leoTree.endEditLabel.

    End editing of the presently-selected headline.'''

    # Let onHeadChanged do all the work.
    c = self.c ; p = c.currentPosition()

    # g.trace(p.h)

    self.onHeadChanged(p)

    # c.bodyWantsFocusNow()
    # c.outerUpdate()
#@-node:ekr.20090124174652.58:endEditLabel (nativeTree)
#@+node:ekr.20090124174652.60:setHeadline (nativeTree)
def setHeadline (self,p,s):

    '''Force the actual text of the headline widget to p.h.'''

    trace = False and not g.unitTesting

    # This is used by unit tests to force the headline and p into alignment.
    if not p:
        if trace: g.trace('*** no p')
        return

    # Don't do this here: the caller should do it.
    # p.setHeadString(s)
    e = self.edit_widget(p)
    if e:
        if trace: g.trace('e',s)
        e.setAllText(s)
    else:
        item = self.position2item(p)
        if item:
            if trace: g.trace('item',s)
            self.setItemText(item,s)
        else:
            if trace: g.trace('*** failed. no item for %s' % p.h)
#@-node:ekr.20090124174652.60:setHeadline (nativeTree)
#@-node:ekr.20090128173959.1:Fixed headline reversion
#@+node:ekr.20090129125507.10:Fixed (??) body pane corruption
#@+node:ekr.20090124174652.10:__init__ (nativeTree)
def __init__(self,c,frame):

    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Components.
    self.c = c
    self.canvas = self # An official ivar used by Leo's core.

    # Subclasses should define headline wrappers to
    # be a subclass of leoFrame.baseTextWidget.
    self.headlineWrapper = leoFrame.baseTextWidget

    # Subclasses should define .treeWidget to be the underlying
    # native tree widget.
    self.treeWidget = None

    # Widget independent status ivars...
    self.contracting = False
    self.dragging = False
    self.expanding = False
    self.prev_p = None
    self.redrawing = False
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    self.selecting = False

    # Debugging...
    self.nodeDrawCount = 0
    self.traceCallersFlag = False # Enable traceCallers method.

    # Associating items with vnodes...
    self.item2vnodeDict = {}
    self.tnode2itemsDict = {} # values are lists of items.
    self.vnode2itemsDict = {} # values are lists of items.

    self.setConfigIvars()
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
#@-node:ekr.20090124174652.10:__init__ (nativeTree)
#@+node:ekr.20090129062500.10:busy (nativeTree)
def busy (self):

    '''Return True (actually, a debugging string)
    if any lockout is set.'''

    trace = False
    table = (
        (self.contracting,  'contracting'),
        (self.expanding,    'expanding'),
        (self.redrawing,    'redrawing'),
        (self.selecting,    'selecting'))

    item = self.getCurrentItem()

    aList = []
    for ivar,kind in table:
        if ivar: aList.append(kind)
    kinds = ','.join(aList)

    if aList and trace:
        g.trace(self.traceItem(item),kinds,g.callers(4))

    return kinds # Return the string for debugging
#@-node:ekr.20090129062500.10:busy (nativeTree)
#@+node:ekr.20090124174652.53:afterSelectHint (nativeTree)
def afterSelectHint (self,p,old_p):

    trace = False and not g.unitTesting
    c = self.c

    self.selecting = False

    if self.busy():
        self.error('afterSelectHint busy!: %s' % self.busy())

    if not p:
        return self.error('no p')
    if p != c.currentPosition():
        return self.error('p is not c.currentPosition()')

    if trace: g.trace(p and p.headString(),g.callers(4))

    c.outerUpdate() # Bring the tree up to date.

    self.setItemForCurrentPosition(scroll=False)
#@-node:ekr.20090124174652.53:afterSelectHint (nativeTree)
#@+node:ekr.20090124174652.56:editLabel (nativeTree)
def editLabel (self,p,selectAll=False,selection=None):

    """Start editing p's headline."""

    trace = False ; verbose = False

    if self.busy():
        return

    c = self.c

    if trace: g.trace('***',p and p.headString(),g.callers(4))

    c.outerUpdate()
        # Do any scheduled redraw.
        # This won't do anything in the new redraw scheme.

    item = self.position2item(p)
    if item:
        e = self.editLabelHelper(item,selectAll,selection)
    else:
        e = None
        self.error('no item for %s' % p)

    # A nice hack: just set the focus request.
    if e: c.requestedFocusWidget = e
#@-node:ekr.20090124174652.56:editLabel (nativeTree)
#@+node:ekr.20090124174652.40:onItemCollapsed (nativeTree)
def onItemCollapsed (self,item):

    trace = False
    verbose = False

    if self.busy(): return

    c = self.c
    if trace: g.trace(self.traceItem(item))
    p = self.item2position(item)

    if p:
        # Important: do not set lockouts here.
        # Only methods that actually generate events should set lockouts.
        p.contract()
        self.select(p) # Calls before/afterSelectHint.    
    else:
        self.error('no p')

    c.outerUpdate()
#@-node:ekr.20090124174652.40:onItemCollapsed (nativeTree)
#@+node:ekr.20090124174652.42:onItemExpanded (nativeTree)
def onItemExpanded (self,item):

    '''Handle and tree-expansion event.'''

    trace = False
    verbose = False

    if self.busy(): return

    c = self.c
    if trace: g.trace(self.traceItem(item))
    p = self.item2position(item)

    if p:
        # Important: do not set lockouts here.
        # Only methods that actually generate events should set lockouts.
        if not p.isExpanded():
            p.expand()
            self.select(p) # Calls before/afterSelectHint.
            self.full_redraw()
        else:
            self.select(p)
    else:
        self.error('no p')

    c.outerUpdate()
#@-node:ekr.20090124174652.42:onItemExpanded (nativeTree)
#@+node:ekr.20090124174652.43:onTreeSelect (nativeTree)
def onTreeSelect(self):

    '''Select the proper position when a tree node is selected.'''

    trace = False and not g.unitTesting
    verbose = False

    if self.busy(): return

    c = self.c

    item = self.getCurrentItem()
    p = self.item2position(item)

    if p:
        # Important: do not set lockouts here.
        # Only methods that actually generate events should set lockouts.
        if trace: g.trace(self.traceItem(item))
        self.select(p) # Calls before/afterSelectHint.
    else:
        self.error('no p for item: %s' % item,g.callers(4))

    c.outerUpdate()
#@-node:ekr.20090124174652.43:onTreeSelect (nativeTree)
#@+node:ekr.20090124174652.44:setItemForCurrentPosition (nativeTree)
def setItemForCurrentPosition (self,scroll=True):

    '''Select the item for c.currentPosition()'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; p = c.currentPosition()

    if self.busy(): return

    if not p:
        if trace and verbose: g.trace('** no p')
        return None

    item = self.position2item(p)

    if not item:
        # This is not necessarily an error.
        # We often attempt to select an item before redrawing it.
        if trace and verbose: g.trace('** no item for',p)
        return None

    item2 = self.getCurrentItem()
    if item == item2:
        if trace and verbose: g.trace('no change',self.traceItem(item))
        if scroll:
            self.scrollToItem(item)
    else:
        try:
            self.selecting = True
            # This generates gui events, so we must use a lockout.
            self.setCurrentItemHelper(item)
            if scroll:
                if trace: g.trace(self.traceItem(item),g.callers(4))
                self.scrollToItem(item)
        finally:
            self.selecting = False

    return item
#@-node:ekr.20090124174652.44:setItemForCurrentPosition (nativeTree)
#@+node:ekr.20090124174652.76:setItemIcon (nativeTree)
def setItemIcon (self,item,icon):

    trace = False

    valid = item and self.isValidItem(item)

    if icon and valid:
        # Important: do not set lockouts here.
        # This will generate changed events,
        # but there is no itemChanged event handler.
        self.setItemIconHelper(item,icon)
    elif trace:
        # Apparently, icon can be None due to recent icon changes.
        if icon:
            g.trace('** item %s, valid: %s, icon: %s' % (
                item and id(item) or '<no item>',valid,icon),
                g.callers(4))
#@-node:ekr.20090124174652.76:setItemIcon (nativeTree)
#@+node:ekr.20090124174652.17:full_redraw & helpers
# forceDraw not used. It is used in the Tk code.

def full_redraw (self,p=None,scroll=True,forceDraw=False):

    '''Redraw all visible nodes of the tree.

    Preserve the vertical scrolling unless scroll is True.'''

    trace = False and not g.app.unitTesting
    c = self.c

    if self.busy():
        return g.trace('*** full_redraw: busy!',g.callers(5))

    if p is None:   p = c.currentPosition()
    else:           c.setCurrentPosition(p)

    self.redrawCount += 1
    if trace: t1 = g.getTime()
    self.initData()
    self.nodeDrawCount = 0
    try:
        self.redrawing = True
        self.drawTopTree(p,scroll)
    finally:
        self.redrawing = False

    self.setItemForCurrentPosition(scroll=True)
    c.requestRedrawFlag= False

    if trace:
        theTime = g.timeSince(t1)
        g.trace('%s: drew %3s nodes in %s' % (
            self.redrawCount,self.nodeDrawCount,theTime))

# Compatibility
redraw = full_redraw 
redraw_now = full_redraw
#@+node:ekr.20090124174652.19:drawChildren
def drawChildren (self,p,parent_item):

    if not p:
        return g.trace('can not happen: no p')

    if p.hasChildren():
        if p.isExpanded():
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child,parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child,parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
#@-node:ekr.20090124174652.19:drawChildren
#@+node:ekr.20090124174652.20:drawNode
def drawNode (self,p,parent_item):

    trace = False
    c = self.c 
    self.nodeDrawCount += 1

    # Allocate the item.
    item = self.createTreeItem(p,parent_item) 

    # Do this now, so self.isValidItem will be true in setItemIcon.
    self.rememberItem(p,item)

    # Set the headline and maybe the icon.
    self.setItemText(item,p.headString())
    if p:
        self.drawItemIcon(p,item)

    if trace: g.trace(self.traceItem(item))

    return item
#@-node:ekr.20090124174652.20:drawNode
#@+node:ekr.20090129062500.12:drawTopTree
def drawTopTree (self,p,scroll):

    c = self.c
    hPos,vPos = self.getScroll()
    self.clear()
    # Draw all top-level nodes and their visible descendants.
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p ; h = p.headString()
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            while p:
                self.drawTree(p)
                p.moveToNext()
        else:
            self.drawTree(p)
    else:
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()

    self.setHScroll(hPos)
    if scroll:
        pass
    else:
        # Retain former scroll position.
        self.setVScroll(vPos)

    self.repaint()
#@nonl
#@-node:ekr.20090129062500.12:drawTopTree
#@+node:ekr.20090124174652.21:drawTree
def drawTree (self,p,parent_item=None):

    # Draw the (visible) parent node.
    item = self.drawNode(p,parent_item)

    # Draw all the visible children.
    self.drawChildren(p,parent_item=item)


#@-node:ekr.20090124174652.21:drawTree
#@+node:ekr.20090124174652.22:initData
def initData (self):

    # g.trace('*****')

    self.item2vnodeDict = {}
    self.tnode2itemsDict = {}
    self.vnode2itemsDict = {}
#@-node:ekr.20090124174652.22:initData
#@+node:ekr.20090124174652.23:rememberItem & rememberVnodeItem
def rememberItem (self,p,item):

    self.rememberVnodeItem(p.v,item)

def rememberVnodeItem (self,v,item):

    # Update item2vnodeDict.
    self.item2vnodeDict[item] = v

    # Update tnode2itemsDict & vnode2itemsDict.
    table = (
        (self.tnode2itemsDict,v.t),
        (self.vnode2itemsDict,v))

    for d,key in table:
        aList = d.get(key,[])
        if item in aList:
            g.trace('*** ERROR *** item already in list: %s, %s' % (item,aList))
        else:
            aList.append(item)
        d[key] = aList
#@nonl
#@-node:ekr.20090124174652.23:rememberItem & rememberVnodeItem
#@-node:ekr.20090124174652.17:full_redraw & helpers
#@-node:ekr.20090129125507.10:Fixed (??) body pane corruption
#@+node:ekr.20090203081015.10:Hooked up icondclick events
# used QTreeWidget.itemDoubleClicked event.
# There seems to be no way to connect events to individual tree items.
#@+node:ekr.20090124174652.120:qtTree.initAfterLoad
def initAfterLoad (self):

    '''Do late-state inits.'''

    # Called by Leo's core.

    c = self.c ; frame = c.frame
    w = c.frame.top ; tw = self.treeWidget

    if not leoQtTree.callbacksInjected:
        leoQtTree.callbacksInjected = True
        self.injectCallbacks() # A base class method.

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemDoubleClicked(QTreeWidgetItem*, int)"),
        self.onItemDoubleClicked)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemSelectionChanged()"),
        self.onTreeSelect)

    # We don't need this.  Hooray!
    # w.connect(self.treeWidget,QtCore.SIGNAL(
            # "itemChanged(QTreeWidgetItem*, int)"),
        # self.onItemChanged)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemCollapsed(QTreeWidgetItem*)"),
        self.onItemCollapsed)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemExpanded(QTreeWidgetItem*)"),
        self.onItemExpanded)

    self.ev_filter = leoQtEventFilter(c,w=self,tag='tree')
    tw.installEventFilter(self.ev_filter)

    c.setChanged(False)
#@-node:ekr.20090124174652.120:qtTree.initAfterLoad
#@+node:ekr.20090124174652.35:Icon Box... (nativeTree)
# For Qt, there seems to be no way to trigger these events.
#@nonl
#@+node:ekr.20090124174652.36:onIconBoxClick
def onIconBoxClick (self,event,p=None):

    if self.busy(): return

    c = self.c

    g.doHook("iconclick1",c=c,p=p,v=p,event=event)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)

    c.outerUpdate()
#@-node:ekr.20090124174652.36:onIconBoxClick
#@+node:ekr.20090124174652.37:onIconBoxRightClick
def onIconBoxRightClick (self,event,p=None):

    """Handle a right click in any outline widget."""

    if self.busy(): return

    c = self.c

    g.doHook("iconrclick1",c=c,p=p,v=p,event=event)
    g.doHook("iconrclick2",c=c,p=p,v=p,event=event)

    c.outerUpdate()
#@-node:ekr.20090124174652.37:onIconBoxRightClick
#@+node:ekr.20090124174652.38:onIconBoxDoubleClick
def onIconBoxDoubleClick (self,event,p=None):

    if self.busy(): return

    c = self.c

    g.doHook("icondclick1",c=c,p=p,v=p,event=event)
    g.doHook("icondclick2",c=c,p=p,v=p,event=event)

    c.outerUpdate()
#@-node:ekr.20090124174652.38:onIconBoxDoubleClick
#@-node:ekr.20090124174652.35:Icon Box... (nativeTree)
#@+node:ekr.20090124174652.112:setItemIconHelper (qtTree)
def setItemIconHelper (self,item,icon):

    # Generates an item-changed event.
    item.setIcon(0,icon)
#@-node:ekr.20090124174652.112:setItemIconHelper (qtTree)
#@+node:ekr.20090124174652.41:onItemDoubleClicked (nativeTree)
def onItemDoubleClicked (self,item,col):

    trace = False
    verbose = False

    if self.busy(): return

    c = self.c

    if trace: g.trace(col,self.traceItem(item),g.callers(4))

    try:
        self.selecting = True

        e = self.createTreeEditorForItem(item)
        if not e: g.trace('*** no e')

        p = self.item2position(item)
        if p:
            event = None
            g.doHook("icondclick1",c=c,p=p,v=p,event=event)
            g.doHook("icondclick2",c=c,p=p,v=p,event=event)
        else:
            g.trace('*** no p')

        c.outerUpdate()
    finally:
        self.selecting = False
#@-node:ekr.20090124174652.41:onItemDoubleClicked (nativeTree)
#@-node:ekr.20090203081015.10:Hooked up icondclick events
#@+node:ekr.20090201080444.1:Improved scrolling
#@+node:ekr.20090124174652.16:Entry points (nativeTree)
#@+node:ekr.20090124174652.17:full_redraw & helpers
# forceDraw not used. It is used in the Tk code.

def full_redraw (self,p=None,scroll=True,forceDraw=False):

    '''Redraw all visible nodes of the tree.

    Preserve the vertical scrolling unless scroll is True.'''

    trace = False and not g.app.unitTesting
    c = self.c

    if self.busy():
        return g.trace('*** full_redraw: busy!',g.callers(5))

    if p is None:   p = c.currentPosition()
    else:           c.setCurrentPosition(p)

    self.redrawCount += 1
    if trace: t1 = g.getTime()
    self.initData()
    self.nodeDrawCount = 0
    try:
        self.redrawing = True
        self.drawTopTree(p,scroll)
    finally:
        self.redrawing = False

    self.setItemForCurrentPosition(scroll=True)
    c.requestRedrawFlag= False

    if trace:
        theTime = g.timeSince(t1)
        g.trace('%s: drew %3s nodes in %s' % (
            self.redrawCount,self.nodeDrawCount,theTime))

# Compatibility
redraw = full_redraw 
redraw_now = full_redraw
#@+node:ekr.20090124174652.19:drawChildren
def drawChildren (self,p,parent_item):

    if not p:
        return g.trace('can not happen: no p')

    if p.hasChildren():
        if p.isExpanded():
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child,parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child,parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
#@-node:ekr.20090124174652.19:drawChildren
#@+node:ekr.20090124174652.20:drawNode
def drawNode (self,p,parent_item):

    trace = False
    c = self.c 
    self.nodeDrawCount += 1

    # Allocate the item.
    item = self.createTreeItem(p,parent_item) 

    # Do this now, so self.isValidItem will be true in setItemIcon.
    self.rememberItem(p,item)

    # Set the headline and maybe the icon.
    self.setItemText(item,p.headString())
    if p:
        self.drawItemIcon(p,item)

    if trace: g.trace(self.traceItem(item))

    return item
#@-node:ekr.20090124174652.20:drawNode
#@+node:ekr.20090129062500.12:drawTopTree
def drawTopTree (self,p,scroll):

    c = self.c
    hPos,vPos = self.getScroll()
    self.clear()
    # Draw all top-level nodes and their visible descendants.
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p ; h = p.headString()
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            while p:
                self.drawTree(p)
                p.moveToNext()
        else:
            self.drawTree(p)
    else:
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()

    self.setHScroll(hPos)
    if scroll:
        pass
    else:
        # Retain former scroll position.
        self.setVScroll(vPos)

    self.repaint()
#@nonl
#@-node:ekr.20090129062500.12:drawTopTree
#@+node:ekr.20090124174652.21:drawTree
def drawTree (self,p,parent_item=None):

    # Draw the (visible) parent node.
    item = self.drawNode(p,parent_item)

    # Draw all the visible children.
    self.drawChildren(p,parent_item=item)


#@-node:ekr.20090124174652.21:drawTree
#@+node:ekr.20090124174652.22:initData
def initData (self):

    # g.trace('*****')

    self.item2vnodeDict = {}
    self.tnode2itemsDict = {}
    self.vnode2itemsDict = {}
#@-node:ekr.20090124174652.22:initData
#@+node:ekr.20090124174652.23:rememberItem & rememberVnodeItem
def rememberItem (self,p,item):

    self.rememberVnodeItem(p.v,item)

def rememberVnodeItem (self,v,item):

    # Update item2vnodeDict.
    self.item2vnodeDict[item] = v

    # Update tnode2itemsDict & vnode2itemsDict.
    table = (
        (self.tnode2itemsDict,v.t),
        (self.vnode2itemsDict,v))

    for d,key in table:
        aList = d.get(key,[])
        if item in aList:
            g.trace('*** ERROR *** item already in list: %s, %s' % (item,aList))
        else:
            aList.append(item)
        d[key] = aList
#@nonl
#@-node:ekr.20090124174652.23:rememberItem & rememberVnodeItem
#@-node:ekr.20090124174652.17:full_redraw & helpers
#@+node:ekr.20090124174652.24:redraw_after_contract
def redraw_after_contract (self,p=None):

    if self.redrawing:
        return

    item = self.position2item(p)

    if item:
        self.contractItem(item)
    else:
        # This is not an error.
        # We may have contracted a node that was not, in fact, visible.
        self.full_redraw(scroll=False)
#@-node:ekr.20090124174652.24:redraw_after_contract
#@+node:ekr.20090124174652.25:redraw_after_expand
def redraw_after_expand (self,p=None):

    # Important, setting scrolling to False makes the problem *worse*
    self.full_redraw (p,scroll=True)
#@-node:ekr.20090124174652.25:redraw_after_expand
#@+node:ekr.20090124174652.26:redraw_after_head_changed
def redraw_after_head_changed (self):

    trace = True and not g.unitTesting

    if self.busy(): return

    c = self.c ; p = c.currentPosition()
    ew = self.edit_widget(p)
    currentItem = self.getCurrentItem()

    if p:
        for item in self.tnode2items(p.v.t):
            if self.isValidItem(item):
                self.setItemText(item,p.h)
#@nonl
#@-node:ekr.20090124174652.26:redraw_after_head_changed
#@+node:ekr.20090124174652.27:redraw_after_icons_changed
def redraw_after_icons_changed (self):

    trace = False and not g.unitTesting

    if self.busy(): return

    if trace: g.trace(g.callers(4))

    self.redrawCount += 1 # To keep a unit test happy.

    c = self.c

    # Suppress call to setHeadString in onItemChanged!
    self.redrawing = True
    try:
        item = self.getCurrentItem()
        for p in c.rootPosition().self_and_siblings_iter():
            self.updateVisibleIcons(p)
    finally:
        self.redrawing = False
#@nonl
#@-node:ekr.20090124174652.27:redraw_after_icons_changed
#@+node:ekr.20090124174652.28:redraw_after_select
# Important: this can not replace before/afterSelectHint.

def redraw_after_select (self,p=None):

    '''Redraw the entire tree when an invisible node
    is selected.'''

    trace = False and not g.unitTesting
    if trace: g.trace('(leoQtTree)',p and p.h or '<No p>')

    if self.busy(): return

    # Don't set self.redrawing here.
    # It will be set by self.afterSelectHint.

    self.full_redraw(p,scroll=False)

    # c.redraw_after_select calls tree.select indirectly.
    # Do not call it again here.
#@-node:ekr.20090124174652.28:redraw_after_select
#@-node:ekr.20090124174652.16:Entry points (nativeTree)
#@+node:ekr.20090124174652.53:afterSelectHint (nativeTree)
def afterSelectHint (self,p,old_p):

    trace = False and not g.unitTesting
    c = self.c

    self.selecting = False

    if self.busy():
        self.error('afterSelectHint busy!: %s' % self.busy())

    if not p:
        return self.error('no p')
    if p != c.currentPosition():
        return self.error('p is not c.currentPosition()')

    if trace: g.trace(p and p.headString(),g.callers(4))

    c.outerUpdate() # Bring the tree up to date.

    self.setItemForCurrentPosition(scroll=False)
#@-node:ekr.20090124174652.53:afterSelectHint (nativeTree)
#@+node:ekr.20090201080444.12:scrollToItem
def scrollToItem (self,item):

    w = self.treeWidget

    # g.trace(self.traceItem(item),g.callers(4))

    hPos,vPos = self.getScroll()

    w.scrollToItem(item,w.PositionAtCenter)

    self.setHScroll(0)
#@-node:ekr.20090201080444.12:scrollToItem
#@+node:ekr.20090124174652.44:setItemForCurrentPosition (nativeTree)
def setItemForCurrentPosition (self,scroll=True):

    '''Select the item for c.currentPosition()'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; p = c.currentPosition()

    if self.busy(): return

    if not p:
        if trace and verbose: g.trace('** no p')
        return None

    item = self.position2item(p)

    if not item:
        # This is not necessarily an error.
        # We often attempt to select an item before redrawing it.
        if trace and verbose: g.trace('** no item for',p)
        return None

    item2 = self.getCurrentItem()
    if item == item2:
        if trace and verbose: g.trace('no change',self.traceItem(item))
        if scroll:
            self.scrollToItem(item)
    else:
        try:
            self.selecting = True
            # This generates gui events, so we must use a lockout.
            self.setCurrentItemHelper(item)
            if scroll:
                if trace: g.trace(self.traceItem(item),g.callers(4))
                self.scrollToItem(item)
        finally:
            self.selecting = False

    return item
#@-node:ekr.20090124174652.44:setItemForCurrentPosition (nativeTree)
#@-node:ekr.20090201080444.1:Improved scrolling
#@+node:ekr.20090215160745.10:Improved speed for scanning color directives
#@+node:ekr.20081205131308.24:updateSyntaxColorer
def updateSyntaxColorer (self,p):

    trace = False and not g.unitTesting
    p = p.copy()

    # self.flag is True unless an unambiguous @nocolor is seen.
    self.flag = self.useSyntaxColoring(p)
    self.scanColorDirectives(p)

    if trace: g.trace(self.flag,self.language,p.h)
    return self.flag
#@-node:ekr.20081205131308.24:updateSyntaxColorer
#@+node:ekr.20081205131308.23:useSyntaxColoring & helper
def useSyntaxColoring (self,p):

    """Return True unless p is unambiguously under the control of @nocolor."""

    trace = False and not g.unitTesting
    if not p:
        if trace: g.trace('no p',repr(p))
        return False

    p = p.copy()
    first = True ; kind = None ; val = True
    self.killColorFlag = False
    for p in p.self_and_parents_iter():
        d = self.findColorDirectives(p)
        color,no_color = 'color' in d,'nocolor' in d
        # An @nocolor-node in the first node disabled coloring.
        if first and 'nocolor-node' in d:
            kind = '@nocolor-node'
            self.killColorFlag = True
            val = False ; break
        # A killcolor anywhere disables coloring.
        elif 'killcolor' in d:
            kind = '@killcolor %s' % p.h
            self.killColorFlag = True
            val = False ; break
        # A color anywhere in the target enables coloring.
        elif color and first:
            kind = 'color %s' % p.h
            val = True ; break
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            kind = '@nocolor %s' % p.h
            val = False ; break
        elif color and not no_color:
            kind = '@color %s' % p.h
            val = True ; break
        first = False

    if trace: g.trace(val,kind)
    return val
#@+node:ekr.20090214075058.12:findColorDirectives
color_directives_pat = re.compile(
    # Order is important: put longest matches first.
    r'(^@color|^@killcolor|^@nocolor-node|^@nocolor)'
    ,re.MULTILINE)

def findColorDirectives (self,p):

    '''Scan p for @color, @killcolor, @nocolor and @nocolor-node directives.

    Return a dict containing pointers to the start of each directive.'''

    trace = False and not g.unitTesting

    d = {}
    anIter = self.color_directives_pat.finditer(p.b)
    for m in anIter:
        # Remove leading '@' for compatibility with
        # functions in leoGlobals.py.
        word = m.group(0)[1:]
        d[word] = word

    if trace: g.trace(d)
    return d
#@-node:ekr.20090214075058.12:findColorDirectives
#@-node:ekr.20081205131308.23:useSyntaxColoring & helper
#@+node:ekr.20090214075058.12:findColorDirectives
color_directives_pat = re.compile(
    # Order is important: put longest matches first.
    r'(^@color|^@killcolor|^@nocolor-node|^@nocolor)'
    ,re.MULTILINE)

def findColorDirectives (self,p):

    '''Scan p for @color, @killcolor, @nocolor and @nocolor-node directives.

    Return a dict containing pointers to the start of each directive.'''

    trace = False and not g.unitTesting

    d = {}
    anIter = self.color_directives_pat.finditer(p.b)
    for m in anIter:
        # Remove leading '@' for compatibility with
        # functions in leoGlobals.py.
        word = m.group(0)[1:]
        d[word] = word

    if trace: g.trace(d)
    return d
#@-node:ekr.20090214075058.12:findColorDirectives
#@-node:ekr.20090215160745.10:Improved speed for scanning color directives
#@+node:ekr.20090217121624.10:Fixed bad startup bug
# The problem was that @chapter nodes were not expanded if they should be selected.
#@nonl
#@+node:ekr.20090124174652.28:redraw_after_select
# Important: this can not replace before/afterSelectHint.

def redraw_after_select (self,p=None):

    '''Redraw the entire tree when an invisible node
    is selected.'''

    trace = False and not g.unitTesting
    if trace: g.trace('(leoQtTree)',p and p.h or '<No p>')

    if self.busy(): return

    # Don't set self.redrawing here.
    # It will be set by self.afterSelectHint.

    self.full_redraw(p,scroll=False)

    # c.redraw_after_select calls tree.select indirectly.
    # Do not call it again here.
#@-node:ekr.20090124174652.28:redraw_after_select
#@+node:ekr.20090124174652.17:full_redraw & helpers
# forceDraw not used. It is used in the Tk code.

def full_redraw (self,p=None,scroll=True,forceDraw=False):

    '''Redraw all visible nodes of the tree.

    Preserve the vertical scrolling unless scroll is True.'''

    trace = False and not g.app.unitTesting
    c = self.c

    if self.busy():
        return g.trace('*** full_redraw: busy!',g.callers(5))

    if p is None:   p = c.currentPosition()
    else:           c.setCurrentPosition(p)

    self.redrawCount += 1
    if trace: t1 = g.getTime()
    self.initData()
    self.nodeDrawCount = 0
    try:
        self.redrawing = True
        self.drawTopTree(p,scroll)
    finally:
        self.redrawing = False

    self.setItemForCurrentPosition(scroll=True)
    c.requestRedrawFlag= False

    if trace:
        theTime = g.timeSince(t1)
        g.trace('%s: drew %3s nodes in %s' % (
            self.redrawCount,self.nodeDrawCount,theTime))

# Compatibility
redraw = full_redraw 
redraw_now = full_redraw
#@+node:ekr.20090124174652.19:drawChildren
def drawChildren (self,p,parent_item):

    if not p:
        return g.trace('can not happen: no p')

    if p.hasChildren():
        if p.isExpanded():
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child,parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child,parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
#@-node:ekr.20090124174652.19:drawChildren
#@+node:ekr.20090124174652.20:drawNode
def drawNode (self,p,parent_item):

    trace = False
    c = self.c 
    self.nodeDrawCount += 1

    # Allocate the item.
    item = self.createTreeItem(p,parent_item) 

    # Do this now, so self.isValidItem will be true in setItemIcon.
    self.rememberItem(p,item)

    # Set the headline and maybe the icon.
    self.setItemText(item,p.headString())
    if p:
        self.drawItemIcon(p,item)

    if trace: g.trace(self.traceItem(item))

    return item
#@-node:ekr.20090124174652.20:drawNode
#@+node:ekr.20090129062500.12:drawTopTree
def drawTopTree (self,p,scroll):

    c = self.c
    hPos,vPos = self.getScroll()
    self.clear()
    # Draw all top-level nodes and their visible descendants.
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p ; h = p.headString()
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            while p:
                self.drawTree(p)
                p.moveToNext()
        else:
            self.drawTree(p)
    else:
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()

    self.setHScroll(hPos)
    if scroll:
        pass
    else:
        # Retain former scroll position.
        self.setVScroll(vPos)

    self.repaint()
#@nonl
#@-node:ekr.20090129062500.12:drawTopTree
#@+node:ekr.20090124174652.21:drawTree
def drawTree (self,p,parent_item=None):

    # Draw the (visible) parent node.
    item = self.drawNode(p,parent_item)

    # Draw all the visible children.
    self.drawChildren(p,parent_item=item)


#@-node:ekr.20090124174652.21:drawTree
#@+node:ekr.20090124174652.22:initData
def initData (self):

    # g.trace('*****')

    self.item2vnodeDict = {}
    self.tnode2itemsDict = {}
    self.vnode2itemsDict = {}
#@-node:ekr.20090124174652.22:initData
#@+node:ekr.20090124174652.23:rememberItem & rememberVnodeItem
def rememberItem (self,p,item):

    self.rememberVnodeItem(p.v,item)

def rememberVnodeItem (self,v,item):

    # Update item2vnodeDict.
    self.item2vnodeDict[item] = v

    # Update tnode2itemsDict & vnode2itemsDict.
    table = (
        (self.tnode2itemsDict,v.t),
        (self.vnode2itemsDict,v))

    for d,key in table:
        aList = d.get(key,[])
        if item in aList:
            g.trace('*** ERROR *** item already in list: %s, %s' % (item,aList))
        else:
            aList.append(item)
        d[key] = aList
#@nonl
#@-node:ekr.20090124174652.23:rememberItem & rememberVnodeItem
#@-node:ekr.20090124174652.17:full_redraw & helpers
#@-node:ekr.20090217121624.10:Fixed bad startup bug
#@+node:ekr.20090226094019.1:Fixed bug: No headline selected after return
#@+node:ekr.20090126093408.855:setCurrentItemHelper
def setCurrentItemHelper(self,item):

    w = self.treeWidget
    w.SelectItem(item)
#@-node:ekr.20090126093408.855:setCurrentItemHelper
#@+node:ekr.20090124174652.26:redraw_after_head_changed
def redraw_after_head_changed (self):

    trace = True and not g.unitTesting

    if self.busy(): return

    c = self.c ; p = c.currentPosition()
    ew = self.edit_widget(p)
    currentItem = self.getCurrentItem()

    if p:
        for item in self.tnode2items(p.v.t):
            if self.isValidItem(item):
                self.setItemText(item,p.h)
#@nonl
#@-node:ekr.20090124174652.26:redraw_after_head_changed
#@+node:ekr.20090124174652.28:redraw_after_select
# Important: this can not replace before/afterSelectHint.

def redraw_after_select (self,p=None):

    '''Redraw the entire tree when an invisible node
    is selected.'''

    trace = False and not g.unitTesting
    if trace: g.trace('(leoQtTree)',p and p.h or '<No p>')

    if self.busy(): return

    # Don't set self.redrawing here.
    # It will be set by self.afterSelectHint.

    self.full_redraw(p,scroll=False)

    # c.redraw_after_select calls tree.select indirectly.
    # Do not call it again here.
#@-node:ekr.20090124174652.28:redraw_after_select
#@-node:ekr.20090226094019.1:Fixed bug: No headline selected after return
#@+node:ekr.20090302100414.10:Fixed alt-tab problems
# It was not always restoring focus or headline selection
#@+node:ekr.20081121105001.491:Focus (qtGui)
def get_focus(self,c=None):

    """Returns the widget that has focus."""

    w = QtGui.QApplication.focusWidget()
    # g.trace('leoQtGui',w)
    return w

def set_focus(self,c,w):

    """Put the focus on the widget."""

    trace = False and not g.unitTesting

    if w:
        if trace: g.trace('leoQtGui',w,g.callers(4))
        w.setFocus()
#@-node:ekr.20081121105001.491:Focus (qtGui)
#@+node:ekr.20090123150451.11:onActivateEvent (qtGui)
def onActivateEvent (self,event,c,obj,tag):

    '''Put the focus in the body pane when the Leo window is
    activated, say as the result of an Alt-tab or click.'''

    trace = False and not g.unitTesting

    # This is called several times for each window activation.
    # We only need to set the focus once.

    if c.exists and tag == 'body':
        if trace: g.trace('Activate',tag)
        c.redraw_now()
        c.bodyWantsFocusNow()
        c.outerUpdate() # Required because this is an event handler.
#@-node:ekr.20090123150451.11:onActivateEvent (qtGui)
#@-node:ekr.20090302100414.10:Fixed alt-tab problems
#@+node:ekr.20090226105328.18:Ctrl-S destroys headline selection
# The ctrl-s problem happens when editing body text.
# The fix was to redraw_after_icons_changed.
#@nonl
#@+node:ekr.20090123150451.11:onActivateEvent (qtGui)
def onActivateEvent (self,event,c,obj,tag):

    '''Put the focus in the body pane when the Leo window is
    activated, say as the result of an Alt-tab or click.'''

    trace = False and not g.unitTesting

    # This is called several times for each window activation.
    # We only need to set the focus once.

    if c.exists and tag == 'body':
        if trace: g.trace('Activate',tag)
        c.redraw_now()
        c.bodyWantsFocusNow()
        c.outerUpdate() # Required because this is an event handler.
#@-node:ekr.20090123150451.11:onActivateEvent (qtGui)
#@+node:ekr.20090124174652.28:redraw_after_select
# Important: this can not replace before/afterSelectHint.

def redraw_after_select (self,p=None):

    '''Redraw the entire tree when an invisible node
    is selected.'''

    trace = False and not g.unitTesting
    if trace: g.trace('(leoQtTree)',p and p.h or '<No p>')

    if self.busy(): return

    # Don't set self.redrawing here.
    # It will be set by self.afterSelectHint.

    self.full_redraw(p,scroll=False)

    # c.redraw_after_select calls tree.select indirectly.
    # Do not call it again here.
#@-node:ekr.20090124174652.28:redraw_after_select
#@+node:ekr.20090124174652.27:redraw_after_icons_changed
def redraw_after_icons_changed (self):

    trace = False and not g.unitTesting

    if self.busy(): return

    if trace: g.trace(g.callers(4))

    self.redrawCount += 1 # To keep a unit test happy.

    c = self.c

    # Suppress call to setHeadString in onItemChanged!
    self.redrawing = True
    try:
        item = self.getCurrentItem()
        for p in c.rootPosition().self_and_siblings_iter():
            self.updateVisibleIcons(p)
    finally:
        self.redrawing = False
#@nonl
#@-node:ekr.20090124174652.27:redraw_after_icons_changed
#@-node:ekr.20090226105328.18:Ctrl-S destroys headline selection
#@+node:ekr.20090303084544.10:Syntax coloring problem
# OMG, the problem was in a match_mark_prev.
# The solution: set self.prev to False in recolor.
#@nonl
#@+node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
def setSplitDirection (self,orientation='vertical'):

    vert = orientation and orientation.lower().startswith('v')

    orientation1 = g.choose(vert,QtCore.Qt.Horizontal, QtCore.Qt.Vertical)
    orientation2 = g.choose(vert,QtCore.Qt.Vertical, QtCore.Qt.Horizontal)
    self.splitter.setOrientation(orientation1)
    self.splitter_2.setOrientation(orientation2)

    # g.trace('vert',vert)

#@-node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
#@+node:ekr.20081206062411.12:recolor & helpers
def recolor (self,s):

    '''Recolor line s.'''

    trace = False and not g.unitTesting
    verbose = False ; traceMatch = False

    # Return immediately if syntax coloring has been disabled.
    if self.colorizer.killColorFlag or not self.colorizer.enabled:
        self.highlighter.setCurrentBlockState(-1)
        if trace and (self.initFlag or verbose):
            self.initFlag = False
            g.trace('immediate return')
        return

    # Reload all_s if the widget's text is known to have changed.
    if self.initFlag:
        self.initFlag = False
        self.all_s = self.w.getAllText()
        if trace and verbose:
            g.trace('**** set all_s: %s' % len(self.all_s),g.callers(5))

    all_s = self.all_s
    if not all_s: return

    # Update the counts.
    self.recolorCount += 1
    self.totalChars += len(s)

    # Init values that do not depend on all_s.
    offset = self.highlighter.currentBlock().position()
    b = self.getPrevState()
    lastFunc,lastMatch = b.lastFunc,b.lastMatch
    lastN,minimalMatch = 0,'' # Not used until there is a match.
    if trace and verbose and lastFunc: g.trace('prevState',b)
    i = g.choose(lastFunc,lastMatch,offset)

    # Make sure we are in synch with all_s.
    # Reload all_s if we are not.
    if not self.checkRecolor(offset,s):
        return g.trace('**** resych failure',s)

    # Set the values that depend on all_s.
    all_s = self.all_s
    j = min(offset + len(s),len(all_s))
    self.global_i,self.global_j = offset,j

    if trace:
        kind = g.choose(verbose,'** entry **','')
        g.trace(kind,self.colorizer.language,s)

    # The main colorizing loop.
    self.prev = None
    while i < j:
        assert 0 <= i < len(all_s)
        progress = i
        functions = self.rulesDict.get(all_s[i],[])
        self.minimalMatch = ''
        for f in functions:
            n = f(self,all_s,i)
            if n is None:
                g.trace('Can not happen' % (repr(n),repr(f)))
                break
            elif n > 0: # Success.
                if trace and traceMatch:
                    g.trace('match: offset %3s, i %3s, n %3s, f %s %s' % (
                        offset,i,n,f.__name__,repr(s[i:i+n])))
                lastFunc,lastMatch,lastN,minimalMatch = f,i,n,self.minimalMatch
                i += n
                break # Stop searching the functions.
            elif n < 0: # Fail and skip n chars.
                # match_keyword now sets n < 0 on first failure.
                i += -n # Don't set lastMatch on failure!
                break # Stop searching the functions.
            else: # Fail.  Go on to the next f in functions.
                pass # Do not break or change i!
        else:
            i += 1 # Don't set lastMatch on failure!
        assert i > progress

    self.setCurrentState(s,offset,len(s)+1,
        lastFunc,lastMatch,lastN,minimalMatch)
#@+node:ekr.20090213102946.10:checkRecolor
def checkRecolor (self,offset,s):

    '''Return True if s can be synched with self.all_s.'''

    trace = True and not g.unitTesting

    all_s = self.all_s
    j = min(offset + len(s),len(all_s))
    s2 = all_s[offset:j]

    # The first check is allowed to fail.
    if s == s2: return True

    if trace: g.trace('**resynch**')

    # Assume we should have re-inited all_s
    self.all_s = all_s = self.w.getAllText()
    j = min(offset + len(s),len(all_s))
    s2 = all_s[offset:j]

    # Check again. This should never fail.
    if s != s2:
        g.trace('**** mismatch! offset %s len %s %s\n%s\n%s' % (
           offset,len(all_s),g.callers(5),repr(s),repr(s2)))
    return s == s2
#@-node:ekr.20090213102946.10:checkRecolor
#@+node:ekr.20090303081428.10:clearLine
# blackColor = None

# def clearLine (self,s):

    # trace = False and not g.unitTesting
    # if trace: g.trace(s)

    # if not self.blackColor:
        # self.blackColor = QtGui.QColor('black')

    # self.highlighter.setFormat(0,len(s),self.blackColor)
#@-node:ekr.20090303081428.10:clearLine
#@+node:ekr.20090211072718.14:computeStateName
def computeStateName (self,lastFunc,lastMatch,lastN,minimalMatch):

    if lastFunc:
        matchString = g.choose(minimalMatch,
            minimalMatch,
            self.all_s[lastMatch:lastMatch+lastN])
        return '%s:%s' % (
            lastFunc.__name__,matchString)
    else:
        return self.defaultState
#@-node:ekr.20090211072718.14:computeStateName
#@+node:ekr.20090211072718.2:getPrevState
def getPrevState (self):

    h = self.highlighter
    n = h.previousBlockState()

    if n == -1:
        return g.Bunch(lastFunc=None,lastMatch=0,lastN=0)
    else:
        bunch = self.stateDict.get(n)
        assert bunch,'n=%s' % (n)
        return bunch
#@nonl
#@-node:ekr.20090211072718.2:getPrevState
#@+node:ekr.20090211072718.3:setCurrentState
def setCurrentState (self,s,offset,limit,lastFunc,lastMatch,lastN,minimalMatch):

    trace = False and not g.unitTesting
    verbose = False
    h = self.highlighter

    self.stateCount += 1
    oldN = h.currentBlockState()
    active = bool(lastFunc and lastMatch + lastN > offset + limit)

    if active:
        b = self.stateDict.get(oldN)
        if b:
            changeState = b.lastFunc != lastFunc or b.lastN != lastN
        else:
            changeState = True
    else:
        lastFunc,lastMatch,lastN,minimalMatch = None,None,None,None
        changeState = oldN != -1

    stateName = self.computeStateName(
        lastFunc,lastMatch,lastN,minimalMatch)

    if trace and (changeState or active or verbose):
        g.trace('%2d ** active %5s changed %5s %-20s %s' % (
            self.stateCount,active,changeState,stateName,s))

    if not changeState:
        return

    n = self.stateNameDict.get(stateName)
    if n is None:
        n = self.nextState
        self.nextState += 1
        self.totalStates += 1
        self.maxStateNumber = max(n,self.maxStateNumber)

    state = g.bunch(
        lastFunc=lastFunc,
        lastMatch=lastMatch,
        lastN=lastN)

    self.stateNameDict[stateName] = n
    self.stateDict[n] = state

    h.setCurrentBlockState(n)
#@-node:ekr.20090211072718.3:setCurrentState
#@+node:ekr.20081206062411.14:setTag
tagCount = 0

def setTag (self,tag,s,i,j):

    trace = False and not g.unitTesting
    verbose = False
    w = self.w
    colorName = w.configDict.get(tag)

    # Munch the color name.
    if not colorName:
        if trace: g.trace('no color for %s' % tag)
        return
    if colorName[-1].isdigit() and colorName[0] != '#':
        colorName = colorName[:-1]

    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name',colorName)

    # Clip the colorizing to the global bounds.
    offset = self.global_i
    lim_i,lim_j = self.global_i,self.global_j
    clip_i = max(i,lim_i)
    clip_j = min(j,lim_j)
    ok = clip_i < clip_j

    if trace:
        self.tagCount += 1
        kind = g.choose(ok,' ','***')
        s2 = g.choose(ok,s[clip_i:clip_j],self.all_s[i:j])

        if verbose:
            g.trace('%3s %3s %3s %3s %3s %3s %3s %3s %s' % (
                self.tagCount,kind,tag,offset,i,j,lim_i,lim_j,s2),
                g.callers(4))
        else:
            g.trace('%3s %3s %7s %s' % (self.tagCount,kind,tag,s2))

    if ok:
        self.highlighter.setFormat(clip_i-offset,clip_j-clip_i,color)
#@-node:ekr.20081206062411.14:setTag
#@-node:ekr.20081206062411.12:recolor & helpers
#@-node:ekr.20090303084544.10:Syntax coloring problem
#@+node:ekr.20090223065019.12:Swap scroll bars when orientation changes
#@+node:ekr.20081121105001.200:class  DynamicWindow
from PyQt4 import uic

class DynamicWindow(QtGui.QMainWindow):

    '''A class representing all parts of the main Qt window
    as created by Designer.

    c.frame.top is a Window object.

    All leoQtX classes use the ivars of this Window class to
    support operations requested by Leo's core.
    '''

    @others

#@+node:ekr.20081121105001.201: ctor (Window)
# Called from leoQtFrame.finishCreate.

def __init__(self,c,parent=None):

    '''Create Leo's main window, c.frame.top'''

    self.c = c ; top = c.frame.top
    # print('DynamicWindow.__init__ %s' % c)

    # Init both base classes.

    ui_file_name = c.config.getString('qt_ui_file_name')
    if not ui_file_name:
        ui_file_name = 'qt_main.ui'

    ui_description_file = g.app.loadDir + "/../plugins/" + ui_file_name
    # g.pr('DynamicWindw.__init__,ui_description_file)
    assert g.os_path_exists(ui_description_file)

    QtGui.QMainWindow.__init__(self,parent)        
    self.ui = uic.loadUi(ui_description_file, self)

    # Init the QDesigner elements.
    #self.setupUi(self)

    ivars = """
    tabWidget treeWidget stackedWidget richTextEdit lineEdit
    findPattern findChange checkBoxWholeWord checkBoxIgnoreCase
    checkBoxWrapAround checkBoxReverse checkBoxRexexp checkBoxMarkFinds
    checkBoxEntireOutline checkBoxSubroutineOnly checkBoxNodeOnly
    checkBoxSearchHeadline checkBoxSearchBody checkBoxMarkChanges
    setWindowIcon setWindowTitle show setGeometry windowTitle
    menuBar

    """.strip().split()

    #for v in ivars:
    #    setattr(self, v, getattr(self.ui, v))

    self.iconBar = self.addToolBar("IconBar")
    self.menubar = self.menuBar()
    self.statusBar = QtGui.QStatusBar()
    self.setStatusBar(self.statusBar)

    orientation = c.config.getString('initial_split_orientation')
    self.setSplitDirection(orientation)
    self.setStyleSheets()
#@+node:leohag.20081203210510.17:do_leo_spell_btn_*
def doSpellBtn(self, btn):
    getattr(self.c.spellCommands.handler.tab, btn)() 

def do_leo_spell_btn_Add(self):
    self.doSpellBtn('onAddButton')

def do_leo_spell_btn_Change(self):
    self.doSpellBtn('onChangeButton')

def do_leo_spell_btn_Find(self):
    self.doSpellBtn('onFindButton')

def do_leo_spell_btn_FindChange(self):
    self.doSpellBtn('onChangeThenFindButton')

def do_leo_spell_btn_Hide(self):
    self.doSpellBtn('onHideButton')

def do_leo_spell_btn_Ignore(self):
    self.doSpellBtn('onIgnoreButton')
#@-node:leohag.20081203210510.17:do_leo_spell_btn_*
#@-node:ekr.20081121105001.201: ctor (Window)
#@+node:ekr.20081121105001.202:closeEvent (qtFrame)
def closeEvent (self,event):

    c = self.c

    if c.inCommand:
        # g.trace('requesting window close')
        c.requestCloseWindow = True
    else:
        ok = g.app.closeLeoWindow(c.frame)
        # g.trace('ok',ok)
        if ok:
            event.accept()
        else:
            event.ignore()
#@-node:ekr.20081121105001.202:closeEvent (qtFrame)
#@+node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
def setSplitDirection (self,orientation='vertical'):

    vert = orientation and orientation.lower().startswith('v')

    orientation1 = g.choose(vert,QtCore.Qt.Horizontal, QtCore.Qt.Vertical)
    orientation2 = g.choose(vert,QtCore.Qt.Vertical, QtCore.Qt.Horizontal)
    self.splitter.setOrientation(orientation1)
    self.splitter_2.setOrientation(orientation2)

    # g.trace('vert',vert)

#@-node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
#@+node:ekr.20081121105001.203:setStyleSheets & helper
styleSheet_inited = False

def setStyleSheets(self):

    trace = False
    c = self.c

    sheet = c.config.getData('qt-gui-plugin-style-sheet')
    if sheet:
        sheet = '\n'.join(sheet)
        if trace: g.trace(len(sheet))
        self.ui.setStyleSheet(sheet or self.default_sheet())
    else:
        if trace: g.trace('no style sheet')
#@nonl
#@+node:ekr.20081121105001.204:defaultStyleSheet
def defaultStyleSheet (self):

    '''Return a reasonable default style sheet.'''

    # Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords
    return '''\

/* A QWidget: supports only background attributes.*/
QSplitter::handle {

    background-color: #CAE1FF; /* Leo's traditional lightSteelBlue1 */
}
QSplitter {
    border-color: white;
    background-color: white;
    border-width: 3px;
    border-style: solid;
}
QTreeWidget {
    background-color: #ffffec; /* Leo's traditional tree color */
}
/* Not supported. */
QsciScintilla {
    background-color: pink;
}
'''
#@-node:ekr.20081121105001.204:defaultStyleSheet
#@-node:ekr.20081121105001.203:setStyleSheets & helper
#@-node:ekr.20081121105001.200:class  DynamicWindow
#@+node:ekr.20090303084544.1:setupUi
def setupUi(self, MainWindow):
    MainWindow.setObjectName("MainWindow")
    MainWindow.resize(957, 778)
    self.centralwidget = QtGui.QWidget(MainWindow)
    self.centralwidget.setObjectName("centralwidget")
    self.verticalLayout = QtGui.QVBoxLayout(self.centralwidget)
    self.verticalLayout.setObjectName("verticalLayout")
    self.splitter_2 = QtGui.QSplitter(self.centralwidget)
    self.splitter_2.setOrientation(QtCore.Qt.Vertical)
    self.splitter_2.setObjectName("splitter_2")
    self.splitter = QtGui.QSplitter(self.splitter_2)
    self.splitter.setOrientation(QtCore.Qt.Horizontal)
    self.splitter.setObjectName("splitter")
    self.treeWidget = QtGui.QTreeWidget(self.splitter)
    self.treeWidget.setObjectName("treeWidget")
    self.tabWidget = QtGui.QTabWidget(self.splitter)
    self.tabWidget.setObjectName("tabWidget")
    self.tab = QtGui.QWidget()
    self.tab.setObjectName("tab")
    self.verticalLayout_3 = QtGui.QVBoxLayout(self.tab)
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.textBrowser = QtGui.QTextBrowser(self.tab)
    self.textBrowser.setObjectName("textBrowser")
    self.verticalLayout_3.addWidget(self.textBrowser)
    self.tabWidget.addTab(self.tab, "")
    self.tab_2 = QtGui.QWidget()
    self.tab_2.setObjectName("tab_2")
    self.gridLayout = QtGui.QGridLayout(self.tab_2)
    self.gridLayout.setObjectName("gridLayout")
    self.findPattern = QtGui.QLineEdit(self.tab_2)
    self.findPattern.setObjectName("findPattern")
    self.gridLayout.addWidget(self.findPattern, 0, 1, 1, 1)
    self.findChange = QtGui.QLineEdit(self.tab_2)
    self.findChange.setObjectName("findChange")
    self.gridLayout.addWidget(self.findChange, 1, 1, 1, 1)
    self.checkBoxWholeWord = QtGui.QCheckBox(self.tab_2)
    self.checkBoxWholeWord.setObjectName("checkBoxWholeWord")
    self.gridLayout.addWidget(self.checkBoxWholeWord, 2, 0, 1, 1)
    self.checkBoxEntireOutline = QtGui.QCheckBox(self.tab_2)
    self.checkBoxEntireOutline.setObjectName("checkBoxEntireOutline")
    self.gridLayout.addWidget(self.checkBoxEntireOutline, 2, 1, 1, 1)
    self.checkBoxIgnoreCase = QtGui.QCheckBox(self.tab_2)
    self.checkBoxIgnoreCase.setObjectName("checkBoxIgnoreCase")
    self.gridLayout.addWidget(self.checkBoxIgnoreCase, 3, 0, 1, 1)
    self.checkBoxSubroutineOnly = QtGui.QCheckBox(self.tab_2)
    self.checkBoxSubroutineOnly.setObjectName("checkBoxSubroutineOnly")
    self.gridLayout.addWidget(self.checkBoxSubroutineOnly, 3, 1, 1, 1)
    self.checkBoxWrapAround = QtGui.QCheckBox(self.tab_2)
    self.checkBoxWrapAround.setObjectName("checkBoxWrapAround")
    self.gridLayout.addWidget(self.checkBoxWrapAround, 4, 0, 1, 1)
    self.checkBoxNodeOnly = QtGui.QCheckBox(self.tab_2)
    self.checkBoxNodeOnly.setObjectName("checkBoxNodeOnly")
    self.gridLayout.addWidget(self.checkBoxNodeOnly, 4, 1, 1, 1)
    self.checkBoxReverse = QtGui.QCheckBox(self.tab_2)
    self.checkBoxReverse.setObjectName("checkBoxReverse")
    self.gridLayout.addWidget(self.checkBoxReverse, 5, 0, 1, 1)
    self.checkBoxSearchHeadline = QtGui.QCheckBox(self.tab_2)
    self.checkBoxSearchHeadline.setObjectName("checkBoxSearchHeadline")
    self.gridLayout.addWidget(self.checkBoxSearchHeadline, 5, 1, 1, 1)
    self.checkBoxRexexp = QtGui.QCheckBox(self.tab_2)
    self.checkBoxRexexp.setObjectName("checkBoxRexexp")
    self.gridLayout.addWidget(self.checkBoxRexexp, 6, 0, 1, 1)
    self.checkBoxSearchBody = QtGui.QCheckBox(self.tab_2)
    self.checkBoxSearchBody.setObjectName("checkBoxSearchBody")
    self.gridLayout.addWidget(self.checkBoxSearchBody, 6, 1, 1, 1)
    self.checkBoxMarkFinds = QtGui.QCheckBox(self.tab_2)
    self.checkBoxMarkFinds.setObjectName("checkBoxMarkFinds")
    self.gridLayout.addWidget(self.checkBoxMarkFinds, 7, 0, 1, 1)
    self.checkBoxMarkChanges = QtGui.QCheckBox(self.tab_2)
    self.checkBoxMarkChanges.setObjectName("checkBoxMarkChanges")
    self.gridLayout.addWidget(self.checkBoxMarkChanges, 7, 1, 1, 1)
    self.label_2 = QtGui.QLabel(self.tab_2)
    self.label_2.setObjectName("label_2")
    self.gridLayout.addWidget(self.label_2, 0, 0, 1, 1)
    self.label_3 = QtGui.QLabel(self.tab_2)
    self.label_3.setObjectName("label_3")
    self.gridLayout.addWidget(self.label_3, 1, 0, 1, 1)
    self.tabWidget.addTab(self.tab_2, "")
    self.tab_3 = QtGui.QWidget()
    self.tab_3.setObjectName("tab_3")
    self.tabWidget.addTab(self.tab_3, "")
    self.stackedWidget = QtGui.QStackedWidget(self.splitter_2)
    self.stackedWidget.setAcceptDrops(True)
    self.stackedWidget.setObjectName("stackedWidget")
    self.page = QtGui.QWidget()
    self.page.setObjectName("page")
    self.verticalLayout_2 = QtGui.QVBoxLayout(self.page)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.textEdit = Qsci.QsciScintilla(self.page)
    self.textEdit.setObjectName("textEdit")
    self.verticalLayout_2.addWidget(self.textEdit)
    self.stackedWidget.addWidget(self.page)
    self.page_2 = QtGui.QWidget()
    self.page_2.setObjectName("page_2")
    self.verticalLayout_4 = QtGui.QVBoxLayout(self.page_2)
    self.verticalLayout_4.setObjectName("verticalLayout_4")
    self.richTextEdit = QtGui.QTextEdit(self.page_2)
    self.richTextEdit.setObjectName("richTextEdit")
    self.verticalLayout_4.addWidget(self.richTextEdit)
    self.stackedWidget.addWidget(self.page_2)
    self.verticalLayout.addWidget(self.splitter_2)
    self.horizontalLayout = QtGui.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.label = QtGui.QLabel(self.centralwidget)
    self.label.setObjectName("label")
    self.horizontalLayout.addWidget(self.label)
    self.lineEdit = QtGui.QLineEdit(self.centralwidget)
    self.lineEdit.setObjectName("lineEdit")
    self.horizontalLayout.addWidget(self.lineEdit)
    self.verticalLayout.addLayout(self.horizontalLayout)
    MainWindow.setCentralWidget(self.centralwidget)
    self.menubar = QtGui.QMenuBar(MainWindow)
    self.menubar.setGeometry(QtCore.QRect(0, 0, 957, 22))
    self.menubar.setObjectName("menubar")
    MainWindow.setMenuBar(self.menubar)
    self.statusbar = QtGui.QStatusBar(MainWindow)
    self.statusbar.setObjectName("statusbar")
    MainWindow.setStatusBar(self.statusbar)
    self.actionOpen = QtGui.QAction(MainWindow)
    self.actionOpen.setObjectName("actionOpen")
    self.actionSave = QtGui.QAction(MainWindow)
    self.actionSave.setObjectName("actionSave")
    self.actionIPython = QtGui.QAction(MainWindow)
    self.actionIPython.setObjectName("actionIPython")
    self.label.setBuddy(self.lineEdit)

    self.retranslateUi(MainWindow)
    self.tabWidget.setCurrentIndex(1)
    self.stackedWidget.setCurrentIndex(0)
    QtCore.QObject.connect(self.treeWidget, QtCore.SIGNAL("itemSelectionChanged()"), MainWindow.showNormal)
    QtCore.QMetaObject.connectSlotsByName(MainWindow)

#@-node:ekr.20090303084544.1:setupUi
#@+node:ekr.20081121105001.207: ctor (qtBody)
def __init__ (self,frame,parentFrame):

    trace = False and not g.unitTesting

    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)

    c = self.c
    assert c.frame == frame and frame.c == c

    self.useScintilla = c.config.getBool('qt-use-scintilla')

    # Set the actual gui widget.
    if self.useScintilla:
        self.widget = w = leoQScintillaWidget(
            c.frame.top.textEdit,
            name='body',c=c)
        self.bodyCtrl = w # The widget as seen from Leo's core.
        self.colorizer = leoColor.nullColorizer(c)
    else:
        top = c.frame.top ; sw = top.ui.stackedWidget
        sw.setCurrentIndex(1)
        self.widget = w = leoQTextEditWidget(
            top.ui.richTextEdit,
            name = 'body',c=c) # A QTextEdit.
        self.bodyCtrl = w # The widget as seen from Leo's core.

        # Hook up the QSyntaxHighlighter
        self.colorizer = leoQtColorizer(c,w.widget)
        w.acceptRichText = False

    # Config stuff.
    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    wrap = c.config.getBool('body_pane_wraps')
    # g.trace('wrap',wrap,self.widget.widget)
    if self.useScintilla:
        pass
    else:
        self.widget.widget.setWordWrapMode(g.choose(wrap,
            QtGui.QTextOption.WordWrap,
            QtGui.QTextOption.NoWrap))
    wrap = g.choose(wrap,"word","none")
    self.wrapState = wrap

    # For multiple body editors.
    self.editor_name = None
    self.editor_v = None
    self.numberOfEditors = 1
    self.totalNumberOfEditors = 1

    if trace: print('qtBody.__init__ %s' % self.widget)
#@-node:ekr.20081121105001.207: ctor (qtBody)
#@+node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
def setSplitDirection (self,orientation='vertical'):

    vert = orientation and orientation.lower().startswith('v')

    orientation1 = g.choose(vert,QtCore.Qt.Horizontal, QtCore.Qt.Vertical)
    orientation2 = g.choose(vert,QtCore.Qt.Vertical, QtCore.Qt.Horizontal)
    self.splitter.setOrientation(orientation1)
    self.splitter_2.setOrientation(orientation2)

    # g.trace('vert',vert)

#@-node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
#@+node:ekr.20081121105001.572: class leoQTextEditWidget
class leoQTextEditWidget (leoQtBaseTextWidget):

    @others
#@+node:ekr.20081121105001.573:Birth
#@+node:ekr.20081121105001.574:ctor
def __init__ (self,widget,name,c=None):

    # Init the base class.
    leoQtBaseTextWidget.__init__(self,widget,name,c=c)

    self.baseClassName='leoQTextEditWidget'

    widget.setUndoRedoEnabled(False)

    self.setConfig()
    self.setFontFromConfig()
    self.setColorFromConfig()
    # self.setScrollBarOrientation()
#@-node:ekr.20081121105001.574:ctor
#@+node:ekr.20081121105001.575:setFontFromConfig
def setFontFromConfig (self,w=None):

    '''Set the font in the widget w (a body editor).'''

    c = self.c
    if not w: w = self.widget

    font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    # w.configure(font=font)

    # g.trace("BODY",body.cget("font"),font.cget("family"),font.cget("weight"))
#@-node:ekr.20081121105001.575:setFontFromConfig
#@+node:ekr.20081121105001.576:setColorFromConfig
def setColorFromConfig (self,w=None):

    '''Set the font in the widget w (a body editor).'''

    c = self.c
    if w is None: w = self.widget

    bg = c.config.getColor("body_text_background_color") or 'white'
    try:
        pass ### w.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()

    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try:
        pass ### w.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try:
            pass ### w.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()

    sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
    try:
        pass ### w.configure(selectbackground=sel_bg)
    except Exception:
        g.es("exception setting body pane text selection background color")
        g.es_exception()

    sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
    try:
        pass ### w.configure(selectforeground=sel_fg)
    except Exception:
        g.es("exception setting body pane text selection foreground color")
        g.es_exception()

    # if sys.platform != "win32": # Maybe a Windows bug.
        # fg = c.config.getColor("body_cursor_foreground_color")
        # bg = c.config.getColor("body_cursor_background_color")
        # if fg and bg:
            # cursor="xterm" + " " + fg + " " + bg
            # try:
                # pass ### w.configure(cursor=cursor)
            # except:
                # import traceback ; traceback.print_exc()
#@-node:ekr.20081121105001.576:setColorFromConfig
#@+node:ekr.20081121105001.577:setConfig
def setConfig (self):

    c = self.c ; w = self.widget

    n = c.config.getInt('qt-rich-text-zoom-in')

    w.setWordWrapMode(QtGui.QTextOption.NoWrap)

    # w.zoomIn(1)
    # w.updateMicroFocus()
    if n not in (None,0):
        # This only works when there is no style sheet.
        # g.trace('zoom-in',n)
        w.zoomIn(n)
        w.updateMicroFocus()

    # tab stop in pixels - no config for this (yet)        
    w.setTabStopWidth(24)


#@-node:ekr.20081121105001.577:setConfig
#@+node:ekr.20090303095630.10:setScrollBarOrientation (QTextEdit)
# def setScrollBarOrientation (self):

    # c = self.c
    # orientation = c.config.getString(jk13ab02xy04)
#@-node:ekr.20090303095630.10:setScrollBarOrientation (QTextEdit)
#@-node:ekr.20081121105001.573:Birth
#@+node:ekr.20081121105001.578:Widget-specific overrides (QTextEdit)
#@+node:ekr.20090205153624.11:delete (avoid call to setAllText)
def delete(self,i,j=None):

    trace = False and not g.unitTesting
    c,w = self.c,self.widget
    colorer = c.frame.body.colorizer.highlighter.colorer
    n = colorer.recolorCount

    i = self.toGuiIndex(i)
    if j is None: j = i+1
    j = self.toGuiIndex(j)

    # Set a hook for the colorer.
    colorer.initFlag = True

    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    cursor = w.textCursor()
    cursor.setPosition(i)
    moveCount = abs(j-i)
    cursor.movePosition(cursor.Right,cursor.KeepAnchor,moveCount)
    cursor.removeSelectedText()
    sb.setSliderPosition(pos)

    if trace:
        g.trace('%s calls to recolor' % (
            colorer.recolorCount-n))
#@-node:ekr.20090205153624.11:delete (avoid call to setAllText)
#@+node:ekr.20081121105001.579:flashCharacter (leoQTextEditWidget)
def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75):

    # numbered color names don't work in Ubuntu 8.10, so...
    if bg[-1].isdigit() and bg[0] != '#':
        bg = bg[:-1]
    if fg[-1].isdigit() and fg[0] != '#':
        fg = fg[:-1]

    # This might causes problems during unit tests.
    # The selection point isn't restored in time.
    if g.app.unitTesting: return

    w = self.widget # A QTextEdit.
    e = QtGui.QTextCursor

    def after(func):
        QtCore.QTimer.singleShot(delay,func)

    def addFlashCallback(self=self,w=w):
        n,i = self.flashCount,self.flashIndex

        cursor = w.textCursor() # Must be the widget's cursor.
        cursor.setPosition(i)
        cursor.movePosition(e.Right,e.KeepAnchor,1)

        extra = w.ExtraSelection()
        extra.cursor = cursor
        if self.flashBg: extra.format.setBackground(QtGui.QColor(self.flashBg))
        if self.flashFg: extra.format.setForeground(QtGui.QColor(self.flashFg))
        self.extraSelList = [extra] # keep the reference.
        w.setExtraSelections(self.extraSelList)

        self.flashCount -= 1
        after(removeFlashCallback)

    def removeFlashCallback(self=self,w=w):
        w.setExtraSelections([])
        if self.flashCount > 0:
            after(addFlashCallback)
        else:
            w.setFocus()

    # g.trace(flashes,fg,bg)
    self.flashCount = flashes
    self.flashIndex = i
    self.flashBg = g.choose(bg.lower()=='same',None,bg)
    self.flashFg = g.choose(fg.lower()=='same',None,fg)

    addFlashCallback()
#@-node:ekr.20081121105001.579:flashCharacter (leoQTextEditWidget)
#@+node:ekr.20081121105001.580:getAllText (leoQTextEditWidget)
def getAllText(self):

    w = self.widget
    s = unicode(w.toPlainText())

    # Doesn't work: gets only the line containing the cursor.
    # s = unicode(w.textCursor().block().text())

    # g.trace(repr(s))
    return s
#@nonl
#@-node:ekr.20081121105001.580:getAllText (leoQTextEditWidget)
#@+node:ekr.20081121105001.581:getInsertPoint
def getInsertPoint(self):

    return self.widget.textCursor().position()
#@-node:ekr.20081121105001.581:getInsertPoint
#@+node:ekr.20081121105001.582:getSelectionRange
def getSelectionRange(self,sort=True):

    w = self.widget
    tc = w.textCursor()
    i,j = tc.selectionStart(),tc.selectionEnd()
    # g.trace(i,j,g.callers(4))
    return i,j
#@nonl
#@-node:ekr.20081121105001.582:getSelectionRange
#@+node:ekr.20081121105001.583:getYScrollPosition
def getYScrollPosition(self):

    w = self.widget
    sb = w.verticalScrollBar()
    i = sb.sliderPosition()

    # Return a tuple, only the first of which is used.
    return i,i 
#@-node:ekr.20081121105001.583:getYScrollPosition
#@+node:ekr.20081121105001.584:hasSelection
def hasSelection(self):

    return self.widget.textCursor().hasSelection()
#@-node:ekr.20081121105001.584:hasSelection
#@+node:ekr.20090205153624.12:insert (avoid call to setAllText)
def insert(self,i,s):

    trace = False and not g.unitTesting
    c,w = self.c,self.widget
    colorer = c.frame.body.colorizer.highlighter.colorer
    n = colorer.recolorCount

    # Set a hook for the colorer.
    colorer.initFlag = True

    i = self.toGuiIndex(i)

    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    cursor = w.textCursor()
    cursor.setPosition(i)
    cursor.insertText(s) # This cause an incremental call to recolor.
    sb.setSliderPosition(pos)

    if trace:
        g.trace('%s calls to recolor' % (
            colorer.recolorCount-n))
#@-node:ekr.20090205153624.12:insert (avoid call to setAllText)
#@+node:ekr.20081121105001.585:see
def see(self,i):

    self.widget.ensureCursorVisible()
#@nonl
#@-node:ekr.20081121105001.585:see
#@+node:ekr.20081121105001.586:seeInsertPoint
def seeInsertPoint (self):

    self.widget.ensureCursorVisible()
#@-node:ekr.20081121105001.586:seeInsertPoint
#@+node:ekr.20081121105001.587:setAllText
def setAllText(self,s,insert=None):

    '''Set the text of the widget.

    If insert is None, the insert point, selection range and scrollbars are initied.
    Otherwise, the scrollbars are preserved.'''

    trace = False and not g.unitTesting
    c,w = self.c,self.widget
    colorizer = c.frame.body.colorizer
    highlighter = colorizer.highlighter
    colorer = highlighter.colorer

    # Set a hook for the colorer.
    colorer.initFlag = True

    sb = w.verticalScrollBar()
    if insert is None: i,pos = 0,0
    else: i,pos = insert,sb.sliderPosition()

    if trace: t1 = g.getTime()
    w.setPlainText(s)
    if trace: g.trace(g.timeSince(t1))

    self.setSelectionRange(i,i,insert=i)
    sb.setSliderPosition(pos)
#@nonl
#@-node:ekr.20081121105001.587:setAllText
#@+node:ekr.20081121105001.588:setInsertPoint
def setInsertPoint(self,i):

    w = self.widget
    s = w.toPlainText()
    cursor = w.textCursor()
    i = max(0,min(i,len(s)))
    cursor.setPosition(i)
    w.setTextCursor(cursor)
#@-node:ekr.20081121105001.588:setInsertPoint
#@+node:ekr.20081121105001.589:setSelectionRangeHelper & helper
def setSelectionRangeHelper(self,i,j,insert):

    w = self.widget
    # g.trace('i',i,'j',j,'insert',insert,g.callers(4))
    e = QtGui.QTextCursor
    if i > j: i,j = j,i
    n = self.lengthHelper()
    # s = w.toPlainText() ; n = len(s)
    i = max(0,min(i,n))
    j = max(0,min(j,n))
    k = max(0,min(j-i,n))
    cursor = w.textCursor()
    if i == j:
        cursor.setPosition(i)
    elif insert in (j,None):
        cursor.setPosition(i)
        cursor.movePosition(e.Right,e.KeepAnchor,k)
    else:
        cursor.setPosition(j)
        cursor.movePosition(e.Left,e.KeepAnchor,k)

    w.setTextCursor(cursor)
#@+node:ekr.20081121105001.590:lengthHelper
def lengthHelper(self):

    '''Return the length of the text.'''

    w = self.widget
    cursor = w.textCursor()
    cursor.movePosition(QtGui.QTextCursor.End)
    n = cursor.position()
    return n

#@-node:ekr.20081121105001.590:lengthHelper
#@-node:ekr.20081121105001.589:setSelectionRangeHelper & helper
#@+node:ekr.20081121105001.591:setYScrollPosition
def setYScrollPosition(self,pos):

    # g.trace('pos',pos)

    w = self.widget
    sb = w.verticalScrollBar()
    if pos is None: pos = 0
    elif type(pos) == types.TupleType:
        pos = pos[0]
    sb.setSliderPosition(pos)
#@-node:ekr.20081121105001.591:setYScrollPosition
#@-node:ekr.20081121105001.578:Widget-specific overrides (QTextEdit)
#@-node:ekr.20081121105001.572: class leoQTextEditWidget
#@+node:ekr.20081121105001.310:toggleSplitDirection (qtFrame)
# The key invariant: self.splitVerticalFlag tells the alignment of the main splitter.

def toggleSplitDirection (self,event=None):

    '''Toggle the split direction in the present Leo window.'''

    frame = self ; top = frame.top

    for w in (top.splitter,top.splitter_2):
        w.setOrientation(
            g.choose(w.orientation() == QtCore.Qt.Horizontal,
                QtCore.Qt.Vertical,QtCore.Qt.Horizontal))
#@nonl
#@+node:ekr.20081121105001.311:toggleQtSplitDirection
def toggleQtSplitDirection (self,verticalFlag):

    # Abbreviations.
    frame = self
    # bar1 = self.bar1 ; bar2 = self.bar2
    # split1Pane1,split1Pane2 = self.split1Pane1,self.split1Pane2
    # split2Pane1,split2Pane2 = self.split2Pane1,self.split2Pane2
    # # Reconfigure the bars.
    # bar1.place_forget()
    # bar2.place_forget()
    # self.configureBar(bar1,verticalFlag)
    # self.configureBar(bar2,not verticalFlag)
    # # Make the initial placements again.
    # self.placeSplitter(bar1,split1Pane1,split1Pane2,verticalFlag)
    # self.placeSplitter(bar2,split2Pane1,split2Pane2,not verticalFlag)
    # # Adjust the log and body panes to give more room around the bars.
    # self.reconfigurePanes()
    # # Redraw with an appropriate ratio.
    # vflag,ratio,secondary_ratio = frame.initialRatios()
    # self.resizePanesToRatio(ratio,secondary_ratio)
#@-node:ekr.20081121105001.311:toggleQtSplitDirection
#@-node:ekr.20081121105001.310:toggleSplitDirection (qtFrame)
#@-node:ekr.20090223065019.12:Swap scroll bars when orientation changes
#@+node:ekr.20090302135940.11:Ctrl-s does not completely end editing
@nocolor-node

There are 3 cases:

- Ctrl-s in headline.
- Ctrl-s in body.
- Return in headline.
#@nonl
#@+node:ekr.20090124174652.58:endEditLabel (nativeTree)
def endEditLabel (self):

    '''Override leoTree.endEditLabel.

    End editing of the presently-selected headline.'''

    # Let onHeadChanged do all the work.
    c = self.c ; p = c.currentPosition()

    # g.trace(p.h)

    self.onHeadChanged(p)

    # c.bodyWantsFocusNow()
    # c.outerUpdate()
#@-node:ekr.20090124174652.58:endEditLabel (nativeTree)
#@+node:ekr.20090124174652.59:onHeadChanged (nativeTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; u = c.undoer
    if not p:
        if trace: g.trace('*** no p')
        return

    item = self.position2item(p)
    if not item:
        # This is not an error.
        if trace: g.trace('no item for p: %s' % (p))
        return

    w = g.app.gui.get_focus()
    ew = self.edit_widget(p)
    if ew: e = ew.widget
    else: e = None

    # These are not errors: focus may have been lost.
    # if trace and verbose:
        # if not e:  g.trace('No e',g.callers(4))
        # if e != w: g.trace('e != w',e,w,g.callers(4))
        # if not p:  g.trace('No p')

    if e and e == w:
        s = e.text() ; len_s = len(s)
        s = g.app.gui.toUnicode(s)
    else:
        s = self.getItemText(item)

    oldHead = p.h
    changed = s != oldHead
    if changed:
        if trace: g.trace('changed',repr(s),p.h)
        p.initHeadString(s)
        item.setText(0,s) # Required to avoid full redraw.
        undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)

    # This is a crucial shortcut.
    if g.unitTesting: return

    self.redraw_after_head_changed()
    self.closeEditorHelper(ew,item)
    if self.stayInTree:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()
    c.outerUpdate()
#@-node:ekr.20090124174652.59:onHeadChanged (nativeTree)
#@+node:ekr.20090124174652.27:redraw_after_icons_changed
def redraw_after_icons_changed (self):

    trace = False and not g.unitTesting

    if self.busy(): return

    if trace: g.trace(g.callers(4))

    self.redrawCount += 1 # To keep a unit test happy.

    c = self.c

    # Suppress call to setHeadString in onItemChanged!
    self.redrawing = True
    try:
        item = self.getCurrentItem()
        for p in c.rootPosition().self_and_siblings_iter():
            self.updateVisibleIcons(p)
    finally:
        self.redrawing = False
#@nonl
#@-node:ekr.20090124174652.27:redraw_after_icons_changed
#@+node:ekr.20090124174652.26:redraw_after_head_changed
def redraw_after_head_changed (self):

    trace = True and not g.unitTesting

    if self.busy(): return

    c = self.c ; p = c.currentPosition()
    ew = self.edit_widget(p)
    currentItem = self.getCurrentItem()

    if p:
        for item in self.tnode2items(p.v.t):
            if self.isValidItem(item):
                self.setItemText(item,p.h)
#@nonl
#@-node:ekr.20090124174652.26:redraw_after_head_changed
#@+node:ekr.20090303095630.15:closeEditorHelper (leoQtTree)
def closeEditorHelper (self,ew,item):

    w = self.treeWidget

    if ew:
        w.closeEditor(ew.widget,QtGui.QAbstractItemDelegate.NoHint)
        w.setCurrentItem(item)
#@nonl
#@-node:ekr.20090303095630.15:closeEditorHelper (leoQtTree)
#@+node:ekr.20090124174652.107:setCurrentItemHelper (leoQtTree)
def setCurrentItemHelper(self,item):

    w = self.treeWidget
    w.setCurrentItem(item)
#@-node:ekr.20090124174652.107:setCurrentItemHelper (leoQtTree)
#@-node:ekr.20090302135940.11:Ctrl-s does not completely end editing
#@+node:ekr.20090303095630.14:Fixed clone-find-all problem with Qt
@nocolor-node

EKR: the problem was in the select logic in cloneFindAll in the core.
It was calling c.selectPosition.  That called nativeTree.endEditLabel,
which used old values for position2item.
The solution was not to call c.selectPosition before calling full_redraw.

http://groups.google.com/group/leo-editor/browse_thread/thread/ee1dbcb22a5d0bcb

I've just realised about the following problem with the qt pluguin
(rev 1593): if I call Find -> Clone Find All when the first node of
the outline is selected then it gets renamed to "Found:
something" (something being the searched string), so the first two
nodes of the oultine have the same name. The top one is correct (it
contains the found nodes), the second is not. If I call Edit --> Undo
Typing the badly renamed node recovers it correct name.
#@+node:ekr.20090124174652.58:endEditLabel (nativeTree)
def endEditLabel (self):

    '''Override leoTree.endEditLabel.

    End editing of the presently-selected headline.'''

    # Let onHeadChanged do all the work.
    c = self.c ; p = c.currentPosition()

    # g.trace(p.h)

    self.onHeadChanged(p)

    # c.bodyWantsFocusNow()
    # c.outerUpdate()
#@-node:ekr.20090124174652.58:endEditLabel (nativeTree)
#@+node:ekr.20090124174652.59:onHeadChanged (nativeTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; u = c.undoer
    if not p:
        if trace: g.trace('*** no p')
        return

    item = self.position2item(p)
    if not item:
        # This is not an error.
        if trace: g.trace('no item for p: %s' % (p))
        return

    w = g.app.gui.get_focus()
    ew = self.edit_widget(p)
    if ew: e = ew.widget
    else: e = None

    # These are not errors: focus may have been lost.
    # if trace and verbose:
        # if not e:  g.trace('No e',g.callers(4))
        # if e != w: g.trace('e != w',e,w,g.callers(4))
        # if not p:  g.trace('No p')

    if e and e == w:
        s = e.text() ; len_s = len(s)
        s = g.app.gui.toUnicode(s)
    else:
        s = self.getItemText(item)

    oldHead = p.h
    changed = s != oldHead
    if changed:
        if trace: g.trace('changed',repr(s),p.h)
        p.initHeadString(s)
        item.setText(0,s) # Required to avoid full redraw.
        undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)

    # This is a crucial shortcut.
    if g.unitTesting: return

    self.redraw_after_head_changed()
    self.closeEditorHelper(ew,item)
    if self.stayInTree:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()
    c.outerUpdate()
#@-node:ekr.20090124174652.59:onHeadChanged (nativeTree)
#@-node:ekr.20090303095630.14:Fixed clone-find-all problem with Qt
#@+node:ekr.20090128113654.1:Fixed bug re: duplicate recent-files menu
@nocolor

Using r1372 and the Qt plugin, I get strange results with the recent-
files menu item.  To reproduce:

1. open a leo window (call this window 1)
2. open an existing .leo file using file->open... (this opens a new window, window 2)
3. go to the file->Recent-files menu item of window 1.  The file-list is duplicated.
4. repeat step 2.  Now window 1's recent-files list is duplicated twice...

** Affects: leo-editor
    Importance: Undecided
        Status: New

--
recent-files menu item list is duplicated
https://bugs.launchpad.net/bugs/313320
You received this bug notification because you are a member of The Leo
editor team, which is subscribed to leo-editor.

Status in Leo: a programmer's editor and more: New

Bug description:
Using r1372 and the Qt plugin, I get strange results with the recent-files menu item.  To reproduce:

1. open a leo window (call this window 1)
2. open an existing .leo file using file->open... (this opens a new window, window 2)
3. go to the file->Recent-files menu item of window 1.  The file-list is duplicated.
4. repeat step 2.  Now window 1's recent-files list is duplicated twice...

@color
#@nonl
#@+node:ekr.20081215074704.18:Report
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/51edf3b44d6a587e

revno: 1259.1.10
revision-id: terry_n_brown@yahoo.com-20081130181632-ci0ioaksewdvc257

I added code so that this no longer derails the initialization process,
i.e. just catch the exception and continue.  I don't know what's wrong
except I first noticed it after a tkinter update from Ubuntu.  I
think.  Anyway, that's my story :)

When I added the "clean recent files" menu option long before this
traceback showed up I had a heap of trouble deleting just the file
entries on the recent files menu.  It was originally hardwired that the
menu have a "Clear list" item, and then the file entries, but I wanted
to make it get it's command entries from @menu @settings and add the
files afterward and that was a lot of fiddling.  I.e. originally it
deleted everything and added the "Clear list" item before rebuilding
the file list, now it either tries to delete only the file entries, or
stores the entries before the files (from @menu) and adds them back
before the files each time, I forget which finally worked.

What's my point?  It would be nice if delete_range "just worked".  It's
a 'pass' in qt, and I would guess recent files is the only thing in the
entire code base that uses it.

The menu tree seems to me to be "write only", i.e. not readable, at
least from the Leo API, of course you can walk it in a gui specific
way.  Not necessarily a problem, but would be nice if it was more
robustly dynamic.  Or maybe I'm missing something, but I've only seen
functions which find a menu based on knowing it exists before hand.
#@nonl
#@-node:ekr.20081215074704.18:Report
#@+node:ekr.20081121105001.469:class qtMenuWrapper (QMenu,leoQtMenu)
class qtMenuWrapper (QtGui.QMenu,leoQtMenu):

    def __init__ (self,c,frame,parent):

        assert c
        assert frame
        QtGui.QMenu.__init__(self,parent)
        leoQtMenu.__init__(self,frame)

    def __repr__(self):

        return '<qtMenuWrapper %s>' % self.leo_label or 'unlabeled'
#@-node:ekr.20081121105001.469:class qtMenuWrapper (QMenu,leoQtMenu)
#@+node:ekr.20081121105001.354:class leoQtMenu (leoMenu)
class leoQtMenu (leoMenu.leoMenu):

    @others
#@+node:ekr.20081121105001.355:leoQtMenu.__init__
def __init__ (self,frame):

    assert frame
    assert frame.c

    # Init the base class.
    leoMenu.leoMenu.__init__(self,frame)

    # g.pr('leoQtMenu.__init__',g.callers(4))

    self.frame = frame
    self.c = c = frame.c
    self.leo_label = '<no leo_label>'

    self.menuBar = c.frame.top.menuBar()
    assert self.menuBar

    # Inject this dict into the commander.
    if not hasattr(c,'menuAccels'):
        setattr(c,'menuAccels',{})

    if 0:
        self.font = c.config.getFontFromParams(
            'menu_text_font_family', 'menu_text_font_size',
            'menu_text_font_slant',  'menu_text_font_weight',
            c.config.defaultMenuFontSize)
#@-node:ekr.20081121105001.355:leoQtMenu.__init__
#@+node:ekr.20081121105001.356:Activate menu commands (to do)
#@+node:ekr.20081121105001.357:qtMenu.activateMenu
def activateMenu (self,menuName):

    c = self.c ;  top = c.frame.top
    # topx,topy = top.winfo_rootx(),top.winfo_rooty()
    # menu = c.frame.menu.getMenu(menuName)

    # if menu:
        # d = self.computeMenuPositions()
        # x = d.get(menuName)
        # if x is None:
            # x = 0 ; g.trace('oops, no menu offset: %s' % menuName)

        # menu.tk_popup(topx+d.get(menuName,0),topy) # Fix by caugm.  Thanks!
    # else:
        # g.trace('oops, no menu: %s' % menuName)
#@-node:ekr.20081121105001.357:qtMenu.activateMenu
#@+node:ekr.20081121105001.358:qtMenu.computeMenuPositions
def computeMenuPositions (self):

    # A hack.  It would be better to set this when creating the menus.
    menus = ('File','Edit','Outline','Plugins','Cmds','Window','Help')

    # Compute the *approximate* x offsets of each menu.
    d = {}
    n = 0
    # for z in menus:
        # menu = self.getMenu(z)
        # fontName = menu.cget('font')
        # font = tkFont.Font(font=fontName)
        # # g.pr('%8s' % (z),menu.winfo_reqwidth(),menu.master,menu.winfo_x())
        # d [z] = n
        # # A total hack: sorta works on windows.
        # n += font.measure(z+' '*4)+1

    return d
#@-node:ekr.20081121105001.358:qtMenu.computeMenuPositions
#@-node:ekr.20081121105001.356:Activate menu commands (to do)
#@+node:ekr.20081121105001.359:Tkinter menu bindings
# See the Tk docs for what these routines are to do
#@+node:ekr.20081121105001.360:Methods with Tk spellings
#@+node:ekr.20081121105001.361:add_cascade
def add_cascade (self,parent,label,menu,underline):

    """Wrapper for the Tkinter add_cascade menu method.

    Adds a submenu to the parent menu, or the menubar."""

    c = self.c ; leoFrame = c.frame
    n = underline
    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]

    menu.setTitle(label)
    menu.leo_label = label

    if parent:
        parent.addMenu(menu)
    else:
        self.menuBar.addMenu(menu)

    return menu
#@-node:ekr.20081121105001.361:add_cascade
#@+node:ekr.20081121105001.362:add_command (qt)
def add_command (self,**keys):

    """Wrapper for the Tkinter add_command menu method."""

    c = self.c
    accel = keys.get('accelerator') or ''
    command = keys.get('command')
    label = keys.get('label')
    n = keys.get('underline')
    menu = keys.get('menu') or self
    if not label: return

    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    if accel:
        label = '%s\t%s' % (label,accel)

    if menu.leo_label == 'File': g.trace(label,g.callers(4))

    action = menu.addAction(label)

    if command:
        def add_command_callback(label=label,command=command):
            return command()

        QtCore.QObject.connect(action,
            QtCore.SIGNAL("triggered()"),add_command_callback)
#@-node:ekr.20081121105001.362:add_command (qt)
#@+node:ekr.20081121105001.363:add_separator
def add_separator(self,menu):

    """Wrapper for the Tkinter add_separator menu method."""

    if menu:
        menu.addSeparator()
#@-node:ekr.20081121105001.363:add_separator
#@+node:ekr.20081121105001.364:delete
def delete (self,menu,realItemName):

    """Wrapper for the Tkinter delete menu method."""

    # if menu:
        # return menu.delete(realItemName)
#@-node:ekr.20081121105001.364:delete
#@+node:ekr.20081121105001.365:delete_range (leoQtMenu)
def delete_range (self,menu,n1,n2):

    """Wrapper for the Tkinter delete menu method."""

    # Menu is a subclass of QMenu and leoQtMenu.

    # g.trace(menu,n1,n2,g.callers(4))

    for z in menu.actions()[n1:n2]:
        menu.removeAction(z)
#@-node:ekr.20081121105001.365:delete_range (leoQtMenu)
#@+node:ekr.20081121105001.366:destroy
def destroy (self,menu):

    """Wrapper for the Tkinter destroy menu method."""

    # if menu:
        # return menu.destroy()
#@-node:ekr.20081121105001.366:destroy
#@+node:ekr.20081121105001.367:insert
def insert (self,menuName,position,label,command,underline=None):

    # g.trace(menuName,position,label,command,underline)

    menu = self.getMenu(menuName)
    if menu and label:
        n = underline
        if -1 > n > len(label):
            label = label[:n] + '&' + label[n:]
        action = menu.addAction(label)
        if command:
            def insert_callback(label=label,command=command):
                command()
            QtCore.QObject.connect(
                action,QtCore.SIGNAL("triggered()"),insert_callback)
#@-node:ekr.20081121105001.367:insert
#@+node:ekr.20081121105001.368:insert_cascade
def insert_cascade (self,parent,index,label,menu,underline):

    """Wrapper for the Tkinter insert_cascade menu method."""

    g.trace(label,menu)

    menu.setTitle(label)
    menu.leo_label = label

    if parent:
        parent.addMenu(menu)
    else:
        self.menuBar.addMenu(menu)

    return menu
#@-node:ekr.20081121105001.368:insert_cascade
#@+node:ekr.20081121105001.369:new_menu (qt)
def new_menu(self,parent,tearoff=False,label=''): # label is for debugging.

    """Wrapper for the Tkinter new_menu menu method."""

    c = self.c ; leoFrame = self.frame

    # g.trace(parent,label)

    # Parent can be None, in which case it will be added to the menuBar.
    menu = qtMenuWrapper(c,leoFrame,parent)

    return menu
#@nonl
#@-node:ekr.20081121105001.369:new_menu (qt)
#@-node:ekr.20081121105001.360:Methods with Tk spellings
#@+node:ekr.20081121105001.370:Methods with other spellings (Qtmenu)
#@+node:ekr.20081121105001.371:clearAccel
def clearAccel(self,menu,name):

    pass

    # if not menu:
        # return

    # realName = self.getRealMenuName(name)
    # realName = realName.replace("&","")

    # menu.entryconfig(realName,accelerator='')
#@-node:ekr.20081121105001.371:clearAccel
#@+node:ekr.20081121105001.372:createMenuBar (Qtmenu)
def createMenuBar(self,frame):

    '''Create all top-level menus.
    The menuBar itself has already been created.'''

    self.createMenusFromTables()
#@-node:ekr.20081121105001.372:createMenuBar (Qtmenu)
#@+node:ekr.20081121105001.373:createOpenWithMenu
def createOpenWithMenu(self,parent,label,index,amp_index):

    '''Create a submenu.'''

    c = self.c ; leoFrame = c.frame

    g.trace()

    # menu = qtMenuWrapper(c,leoFrame,parent)
    # self.insert_cascade(parent,index,label,menu,underline=amp_index)

    # menu = Tk.Menu(parent,tearoff=0)
    # if menu:
        # parent.insert_cascade(index,label=label,menu=menu,underline=amp_index)
    # return menu
#@-node:ekr.20081121105001.373:createOpenWithMenu
#@+node:ekr.20081121105001.374:disableMenu
def disableMenu (self,menu,name):

    if not menu:
        return

    # try:
        # menu.entryconfig(name,state="disabled")
    # except: 
        # try:
            # realName = self.getRealMenuName(name)
            # realName = realName.replace("&","")
            # menu.entryconfig(realName,state="disabled")
        # except:
            # g.pr("disableMenu menu,name:",menu,name)
            # g.es_exception()
#@-node:ekr.20081121105001.374:disableMenu
#@+node:ekr.20081121105001.375:enableMenu
# Fail gracefully if the item name does not exist.

def enableMenu (self,menu,name,val):

    if not menu:
        return

    # state = g.choose(val,"normal","disabled")
    # try:
        # menu.entryconfig(name,state=state)
    # except:
        # try:
            # realName = self.getRealMenuName(name)
            # realName = realName.replace("&","")
            # menu.entryconfig(realName,state=state)
        # except:
            # g.pr("enableMenu menu,name,val:",menu,name,val)
            # g.es_exception()
#@nonl
#@-node:ekr.20081121105001.375:enableMenu
#@+node:ekr.20081121105001.376:getMenuLabel
def getMenuLabel (self,menu,name):

    '''Return the index of the menu item whose name (or offset) is given.
    Return None if there is no such menu item.'''

    g.trace('menu',menu,'name',name)

    actions = menu.actions()
    for action in actions:
        g.trace(action.label())

    # try:
        # index = menu.index(name)
    # except:
        # index = None

    # return index
#@-node:ekr.20081121105001.376:getMenuLabel
#@+node:ekr.20081121105001.377:setMenuLabel
def setMenuLabel (self,menu,name,label,underline=-1):

    def munge(s):
        s = g.app.gui.toUnicode(s)
        return s.replace('&','')

    # menu is a qtMenuWrapper.

    # g.trace('menu',menu,'name: %20s label: %s' % (name,label))

    if not menu: return

    realName  = munge(self.getRealMenuName(name))
    realLabel = self.getRealMenuName(label)
    for action in menu.actions():
        s = munge(action.text())
        s = s.split('\t')[0]
        if s == realName:
            action.setText(realLabel)
            break
#@-node:ekr.20081121105001.377:setMenuLabel
#@-node:ekr.20081121105001.370:Methods with other spellings (Qtmenu)
#@-node:ekr.20081121105001.359:Tkinter menu bindings
#@+node:ekr.20081121105001.378:getMacHelpMenu
def getMacHelpMenu (self,table):

    return None

    # defaultTable = [
            # # &: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
            # ('&About Leo...',           'about-leo'),
            # ('Online &Home Page',       'open-online-home'),
            # '*open-online-&tutorial',
            # '*open-&users-guide',
            # '-',
            # ('Open Leo&Docs.leo',       'open-leoDocs-leo'),
            # ('Open Leo&Plugins.leo',    'open-leoPlugins-leo'),
            # ('Open Leo&Settings.leo',   'open-leoSettings-leo'),
            # ('Open &myLeoSettings.leo', 'open-myLeoSettings-leo'),
            # ('Open scr&ipts.leo',       'open-scripts-leo'),
            # '-',
            # '*he&lp-for-minibuffer',
            # '*help-for-&command',
            # '-',
            # '*&apropos-autocompletion',
            # '*apropos-&bindings',
            # '*apropos-&debugging-commands',
            # '*apropos-&find-commands',
            # '-',
            # '*pri&nt-bindings',
            # '*print-c&ommands',
        # ]

    # try:
        # topMenu = self.getMenu('top')
        # # Use the name argument to create the special Macintosh Help menu.
        # helpMenu = Tk.Menu(topMenu,name='help',tearoff=0)
        # self.add_cascade(topMenu,label='Help',menu=helpMenu,underline=0)
        # self.createMenuEntries(helpMenu,table or defaultTable)
        # return helpMenu

    # except Exception:
        # g.trace('Can not get MacOS Help menu')
        # g.es_exception()
        # return None
#@-node:ekr.20081121105001.378:getMacHelpMenu
#@-node:ekr.20081121105001.354:class leoQtMenu (leoMenu)
#@+node:ekr.20081121105001.365:delete_range (leoQtMenu)
def delete_range (self,menu,n1,n2):

    """Wrapper for the Tkinter delete menu method."""

    # Menu is a subclass of QMenu and leoQtMenu.

    # g.trace(menu,n1,n2,g.callers(4))

    for z in menu.actions()[n1:n2]:
        menu.removeAction(z)
#@-node:ekr.20081121105001.365:delete_range (leoQtMenu)
#@-node:ekr.20090128113654.1:Fixed bug re: duplicate recent-files menu
#@+node:ekr.20090304084841.14:isearch now works for tkinter
# The fix was in k.showStateAndMode:
# it does nothing when in isearch mode.
#@nonl
#@-node:ekr.20090304084841.14:isearch now works for tkinter
#@-node:ekr.20090124101344.1:Recent
#@+node:ekr.20081208155215.12:Unused
#@+node:ekr.20081205131308.26:scanColorDirectives (very slow!)
# def scanColorDirectives(self,p):

    # '''Scan position p and p's ancestors looking for @comment,
    # @language and @root directives,
    # setting corresponding colorizer ivars.'''

    # c = self.c
    # if not c: return # May be None for testing.

    # table = (
        # ('lang-dict',   g.scanAtCommentAndAtLanguageDirectives),
        # ('root',        c.scanAtRootDirectives),
    # )

    # # Set d by scanning all directives.
    # aList = g.get_directives_dict_list(p)
    # d = {}
    # for key,func in table:
        # val = func(aList)
        # if val: d[key]=val

    # # Post process.
    # lang_dict       = d.get('lang-dict')
    # self.rootMode   = d.get('root') or None

    # if lang_dict:
        # self.language       = lang_dict.get('language')
        # self.comment_string = lang_dict.get('comment')
    # else:
        # self.language       = c.target_language and c.target_language.lower()
        # self.comment_string = None

    # # g.trace('self.language',self.language)
    # return self.language # For use by external routines.
#@-node:ekr.20081205131308.26:scanColorDirectives (very slow!)
#@+node:ekr.20090124174652.124:Timing (nativeTree)
# def tstart (self):
    # return g.app.gui.tstart()

# def tstop (self):
    # return g.app.gui.stop()
#@-node:ekr.20090124174652.124:Timing (nativeTree)
#@+node:ekr.20081121110412.7:tstart & tstop (tkGui)
# def tstart():
    # global __timing
    # __timing = time.time()

# def tstop():
    # return "%1.2f sec." % (time.time()-__timing)
#@-node:ekr.20081121110412.7:tstart & tstop (tkGui)
#@+node:ekr.20081121105001.193:tstart & tstop (qtGui)
# def tstart():
    # global __timing
    # __timing = time.time()

# def tstop():
    # return "%1.2f sec" % (time.time()-__timing)
#@-node:ekr.20081121105001.193:tstart & tstop (qtGui)
#@-node:ekr.20081208155215.12:Unused
#@-all
#@nonl
#@-node:ekr.20081121105001.147:@thin qtNotes.txt
#@-leo
