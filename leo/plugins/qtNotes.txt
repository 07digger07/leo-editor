#@+leo-ver=4-thin
#@+node:ekr.20081121105001.147:@thin qtNotes.txt
#@+all
#@+node:ekr.20081121105001.148: qt To do
#@+node:ekr.20090429101847.10:Support canvas widgets in all panes
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/9ac06147e75fc042

add-canvas: Like add-editor, but it creates a canvas area, not a text area.
#@nonl
#@-node:ekr.20090429101847.10:Support canvas widgets in all panes
#@+node:ekr.20081215074704.21:Add drag and drop
#@-node:ekr.20081215074704.21:Add drag and drop
#@+node:ekr.20090418064921.12:Qt, vim bindings
http://groups.google.com/group/leo-editor/browse_thread/thread/7285ac185355efb1
#@nonl
#@-node:ekr.20090418064921.12:Qt, vim bindings
#@+node:ekr.20081215162017.4:Allow coloring of script buttons
@nocolor-node

Use @string qt-button-color = lightSteelBlue

The following does *not* work in @data qt-gui-plugin-style-sheet::

    QPushButton {
        background-color: red;
    }
#@+node:ekr.20090406111739.12:setWidgetColor (qtGui)
badWidgetColors = []

def setWidgetColor (self,w,widgetKind,selector,colorName):

    if not colorName: return

    # g.trace(widgetKind,selector,colorName,g.callers(4))

    # A bit of a hack: Qt color names do not end with a digit.
    # Remove them to avoid annoying qt color warnings.
    if colorName[-1].isdigit():
        colorName = colorName[:-1]

    if colorName in self.badWidgetColors:
        pass
    elif QtGui.QColor(colorName).isValid():
        g.app.gui.setStyleSetting(w,widgetKind,selector,colorName)
    else:
        self.badWidgetColors.append(colorName)
        g.es_print('bad widget color %s for %s' % (
            colorName,widgetKind),color='blue')
#@-node:ekr.20090406111739.12:setWidgetColor (qtGui)
#@+node:ekr.20090406111739.13:setStyleSetting (qtGui)
def setStyleSetting(self,w,widgetKind,selector,val):

    '''Set the styleSheet for w to
       "%s { %s: %s; }  % (widgetKind,selector,val)"
    '''

    s = '%s { %s: %s; }' % (widgetKind,selector,val)

    try:
        w.setStyleSheet(s)
    except Exception:
        g.es_print('bad style sheet: %s' % s)
        g.es_exception()
#@-node:ekr.20090406111739.13:setStyleSetting (qtGui)
#@+node:ekr.20081121105001.266:class qtIconBarClass
class qtIconBarClass:

    '''A class representing the singleton Icon bar'''

    @others
#@+node:ekr.20081121105001.267: ctor
def __init__ (self,c,parentFrame):

    self.c = c
    self.parentFrame = parentFrame
    self.toolbar = self
    self.w = c.frame.top.iconBar # A QToolBar.
    self.actions = []

    # Options
    self.buttonColor = c.config.getString('qt-button-color')

    # g.app.iconWidgetCount = 0
#@-node:ekr.20081121105001.267: ctor
#@+node:ekr.20081121105001.268: do-nothings
def addRow(self,height=None):   pass
def getFrame (self):            return None
def getNewFrame (self):         return None
def pack (self):                pass
def unpack (self):              pass

hide = unpack
show = pack
#@-node:ekr.20081121105001.268: do-nothings
#@+node:ekr.20081121105001.269:add
def add(self,*args,**keys):

    '''Add a button to the icon bar.'''

    c = self.c
    command = keys.get('command')
    text = keys.get('text')
    # able to specify low-level QAction directly (QPushButton not forced)
    qaction = keys.get('qaction')

    if not text and not qaction:
        g.es('bad toolbar item')

    bg = keys.get('bg') or self.toolbar.buttonColor

    # imagefile = keys.get('imagefile')
    # image = keys.get('image')

    class leoIconBarButton (QtGui.QWidgetAction):
        def __init__ (self,parent,text,toolbar):
            QtGui.QWidgetAction.__init__(self,parent)
            self.button = None # set below
            self.text = text
            self.toolbar = toolbar
        def createWidget (self,parent):
            # g.trace('leoIconBarButton',self.toolbar.buttonColor)
            self.button = b = QtGui.QPushButton(self.text,parent)
            g.app.gui.setWidgetColor(b,
                widgetKind='QPushButton',
                selector='background-color',
                colorName = bg)
            return b

    if qaction is None:
        action = leoIconBarButton(parent=self.w,text=text,toolbar=self)
    else:
        action = qaction

    self.w.addAction(action)

    self.actions.append(action)
    b = self.w.widgetForAction(action)

    b.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)

    def delete_callback(action=action,):
        self.w.removeAction(action)

    b.leo_removeAction = rb = QtGui.QAction('Remove Button' ,b)

    b.addAction(rb)
    rb.connect(rb, QtCore.SIGNAL("triggered()"), delete_callback)

    if command:
        def button_callback(c=c,command=command):
            # g.trace('command',command.__name__)
            val = command()
            if c.exists:
                # c.bodyWantsFocus()
                c.outerUpdate()
            return val

        self.w.connect(b,
            QtCore.SIGNAL("clicked()"),
            button_callback)

    return action
#@-node:ekr.20081121105001.269:add
#@+node:ekr.20081121105001.270:addRowIfNeeded
def addRowIfNeeded (self):

    '''Add a new icon row if there are too many widgets.'''

    # n = g.app.iconWidgetCount

    # if n >= self.widgets_per_row:
        # g.app.iconWidgetCount = 0
        # self.addRow()

    # g.app.iconWidgetCount += 1
#@-node:ekr.20081121105001.270:addRowIfNeeded
#@+node:ekr.20081121105001.271:addWidget
def addWidget (self,w):

    self.w.addWidget(w)
#@-node:ekr.20081121105001.271:addWidget
#@+node:ekr.20081121105001.272:clear
def clear(self):

    """Destroy all the widgets in the icon bar"""

    self.w.clear()
    self.actions = []

    g.app.iconWidgetCount = 0
#@-node:ekr.20081121105001.272:clear
#@+node:ekr.20081121105001.273:deleteButton
def deleteButton (self,w):
    """ w is button """

    #g.trace(w, '##')    

    self.w.removeAction(w)

    self.c.bodyWantsFocus()
    self.c.outerUpdate()
#@-node:ekr.20081121105001.273:deleteButton
#@+node:ekr.20081121105001.274:setCommandForButton
def setCommandForButton(self,button,command):

    if command:
        # button is a leoIconBarButton.
        QtCore.QObject.connect(button.button,
            QtCore.SIGNAL("clicked()"),command)
#@-node:ekr.20081121105001.274:setCommandForButton
#@-node:ekr.20081121105001.266:class qtIconBarClass
#@-node:ekr.20081215162017.4:Allow coloring of script buttons
#@+node:ekr.20081124094918.1:Fix problems with scim
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/59c1e5d6acaf4de0

I've some more information about the problems with accent previously
reported:
- I can confirm that they are caused by the interaction scim+leo (with
and without the qt plugin). If scim is not started leo works fine. If
scim is running the problems appear and are slightly different with
and without the qt plugin. The workaround is obvious: don't use leo
and scim at the same time :-)
- accents are not working in the qt plugin when scintilla is used. If
qt-use-scintilla=False I can write this:

àáä (the same for the rest of vowels)

but if qt-use-scintilla=True when I enter the same sequence in the
keyboard I get:

`aaa (the same for the rest of vowels)

- the problem with the ñ character (reported previously too) is only
present in the qt plugin (both with and without scintilla)
#@-node:ekr.20081124094918.1:Fix problems with scim
#@+node:ekr.20090406111739.10:Let gui handle hard part of next/prev-line commands
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/ef04b185f74f4926

This is a little difficult to describe in words, but trying it out
should, I hope make the issue clear enough.

(1) Start by setting body_pane_wraps to true.

(2) Create a very long line of e.g. 500 characters, which is wrapped
around on the body pane. (E.g. paste in a paragraph from a Word
document). This text will then be wrapped onscreen into roughly 8
lines of 70 characters.

(3) The up and down arrows do not behave as expected.

I'd expect that in this scenario, pressing the down arrow key should
go to go to the next line down as it currently appears *onscreen* --
so in this example, I'd expect to have to press the down arrow several
times to get to the end of the paragraph.  This is the way that Emacs
works when it is in word wrap mode, and is of course is the way that
all word processors work. However, Leo does not play this way, and
takes you right to the end of the line (i.e. to the last of the 500
characters) when you press the down key once. This makes editing plain
text (e.g. using Leo as an outliner) rather more tricky than it ought
to be. Would it be possible to change the effect of Previous-Line and
Next-Line when in word wrap mode, so that they behave as other text
editors and word processors do?

============================

This is a long-standing problem.  It's tricky to fix in a straightforward
way.

However, I just realized that there might be a clever way: the commands
could let the gui handle the hard part of the command (the actual move) and
then the commands could detect the resulting row/col numbers as they must.

I've been putting this off, I'll see if this more clever way will work soon. 
#@nonl
#@-node:ekr.20090406111739.10:Let gui handle hard part of next/prev-line commands
#@-node:ekr.20081121105001.148: qt To do
#@+node:ekr.20081121105001.185:Scripts
#@+node:ekr.20081121105001.186:Script to display Qt font database
import PyQt4.QtGui as QtGui

db = QtGui.QFontDatabase()
for family in db.families():
    print family
    for style in db.styles(family):
        print '\t',style,db.smoothSizes(family,style)
#@-node:ekr.20081121105001.186:Script to display Qt font database
#@+node:ekr.20081121105001.187:dump guiBindNamesInverseDict
print g.dictToString(c.k.guiBindNamesInverseDict)

@
   BackSpace: 'BackSpace'
       Begin: 'Begin'
       Break: 'Break'
   Caps_Lock: 'Caps_Lock'
       Clear: 'Clear'
      Delete: 'Delete'
        Down: 'Down'
         End: 'End'
      Escape: 'Escape'
          F1: 'F1'
         F10: 'F10'
         F11: 'F11'
         F12: 'F12'
          F2: 'F2'
          F3: 'F3'
          F4: 'F4'
          F5: 'F5'
          F6: 'F6'
          F7: 'F7'
          F8: 'F8'
          F9: 'F9'
        Home: 'Home'
        Left: 'Left'
    Linefeed: 'Linefeed'
        Next: 'Next'
    Num_Lock: 'Num_Lock'
       Prior: 'Prior'
      Return: 'Return'
       Right: 'Right'
         Tab: 'Tab'
          Up: 'Up'
   ampersand: '&'
 asciicircum: '^'
  asciitilde: '~'
    asterisk: '*'
          at: '@'
   backslash: '\\'
         bar: '|'
   braceleft: '{'
  braceright: '}'
 bracketleft: '['
bracketright: ']'
       colon: ':'
       comma: ','
      dollar: '$'
       equal: '='
      exclam: '!'
     greater: '>'
        less: '<'
       minus: '-'
  numbersign: '#'
   parenleft: '('
  parenright: ')'
     percent: '%'
      period: '.'
        plus: '+'
    question: '?'
    quotedbl: '"'
   quoteleft: '`'
  quoteright: "'"
   semicolon: ';'
       slash: '/'
       space: ' '
  underscore: '_'
#@nonl
#@-node:ekr.20081121105001.187:dump guiBindNamesInverseDict
#@-node:ekr.20081121105001.185:Scripts
#@+node:ekr.20090717095154.3729:Leo 4.7 devel projects
#@-node:ekr.20090717095154.3729:Leo 4.7 devel projects
#@+node:ekr.20081208155215.12:Unused
#@-node:ekr.20081208155215.12:Unused
#@-all
#@nonl
#@-node:ekr.20081121105001.147:@thin qtNotes.txt
#@-leo
