#@+leo-ver=4-thin
#@+node:ekr.20081121105001.147:@thin qtNotes.txt
#@+all
#@+node:ekr.20081121105001.148: qt To do
#@+node:ekr.20090429101847.10:Support canvas widgets in all panes
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/9ac06147e75fc042

add-canvas: Like add-editor, but it creates a canvas area, not a text area.
#@nonl
#@-node:ekr.20090429101847.10:Support canvas widgets in all panes
#@+node:ekr.20081215074704.21:Add drag and drop
#@-node:ekr.20081215074704.21:Add drag and drop
#@+node:ekr.20090418064921.12:Qt, vim bindings
http://groups.google.com/group/leo-editor/browse_thread/thread/7285ac185355efb1
#@nonl
#@-node:ekr.20090418064921.12:Qt, vim bindings
#@+node:ekr.20081215162017.4:Allow coloring of script buttons
@nocolor-node

Use @string qt-button-color = lightSteelBlue

The following does *not* work in @data qt-gui-plugin-style-sheet::

    QPushButton {
        background-color: red;
    }
#@+node:ekr.20090406111739.12:setWidgetColor (qtGui)
badWidgetColors = []

def setWidgetColor (self,w,widgetKind,selector,colorName):

    if not colorName: return

    # g.trace(widgetKind,selector,colorName,g.callers(4))

    # A bit of a hack: Qt color names do not end with a digit.
    # Remove them to avoid annoying qt color warnings.
    if colorName[-1].isdigit():
        colorName = colorName[:-1]

    if colorName in self.badWidgetColors:
        pass
    elif QtGui.QColor(colorName).isValid():
        g.app.gui.setStyleSetting(w,widgetKind,selector,colorName)
    else:
        self.badWidgetColors.append(colorName)
        g.es_print('bad widget color %s for %s' % (
            colorName,widgetKind),color='blue')
#@-node:ekr.20090406111739.12:setWidgetColor (qtGui)
#@+node:ekr.20090406111739.13:setStyleSetting (qtGui)
def setStyleSetting(self,w,widgetKind,selector,val):

    '''Set the styleSheet for w to
       "%s { %s: %s; }  % (widgetKind,selector,val)"
    '''

    s = '%s { %s: %s; }' % (widgetKind,selector,val)

    try:
        w.setStyleSheet(s)
    except Exception:
        g.es_print('bad style sheet: %s' % s)
        g.es_exception()
#@-node:ekr.20090406111739.13:setStyleSetting (qtGui)
#@+node:ekr.20081121105001.266:class qtIconBarClass
class qtIconBarClass:

    '''A class representing the singleton Icon bar'''

    @others
#@+node:ekr.20081121105001.267: ctor
def __init__ (self,c,parentFrame):

    self.c = c
    self.parentFrame = parentFrame
    self.toolbar = self
    self.w = c.frame.top.iconBar # A QToolBar.
    self.actions = []

    # Options
    self.buttonColor = c.config.getString('qt-button-color')

    # g.app.iconWidgetCount = 0
#@-node:ekr.20081121105001.267: ctor
#@+node:ekr.20081121105001.268: do-nothings
def addRow(self,height=None):   pass
def getFrame (self):            return None
def getNewFrame (self):         return None
def pack (self):                pass
def unpack (self):              pass

hide = unpack
show = pack
#@-node:ekr.20081121105001.268: do-nothings
#@+node:ekr.20081121105001.269:add
def add(self,*args,**keys):

    '''Add a button to the icon bar.'''

    c = self.c
    command = keys.get('command')
    text = keys.get('text')
    # able to specify low-level QAction directly (QPushButton not forced)
    qaction = keys.get('qaction')

    if not text and not qaction:
        g.es('bad toolbar item')

    bg = keys.get('bg') or self.toolbar.buttonColor

    # imagefile = keys.get('imagefile')
    # image = keys.get('image')

    class leoIconBarButton (QtGui.QWidgetAction):
        def __init__ (self,parent,text,toolbar):
            QtGui.QWidgetAction.__init__(self,parent)
            self.button = None # set below
            self.text = text
            self.toolbar = toolbar
        def createWidget (self,parent):
            # g.trace('leoIconBarButton',self.toolbar.buttonColor)
            self.button = b = QtGui.QPushButton(self.text,parent)
            g.app.gui.setWidgetColor(b,
                widgetKind='QPushButton',
                selector='background-color',
                colorName = bg)
            return b

    if qaction is None:
        action = leoIconBarButton(parent=self.w,text=text,toolbar=self)
    else:
        action = qaction

    self.w.addAction(action)

    self.actions.append(action)
    b = self.w.widgetForAction(action)

    b.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)

    def delete_callback(action=action,):
        self.w.removeAction(action)

    b.leo_removeAction = rb = QtGui.QAction('Remove Button' ,b)

    b.addAction(rb)
    rb.connect(rb, QtCore.SIGNAL("triggered()"), delete_callback)

    if command:
        def button_callback(c=c,command=command):
            # g.trace('command',command.__name__)
            val = command()
            if c.exists:
                # c.bodyWantsFocus()
                c.outerUpdate()
            return val

        self.w.connect(b,
            QtCore.SIGNAL("clicked()"),
            button_callback)

    return action
#@-node:ekr.20081121105001.269:add
#@+node:ekr.20081121105001.270:addRowIfNeeded
def addRowIfNeeded (self):

    '''Add a new icon row if there are too many widgets.'''

    # n = g.app.iconWidgetCount

    # if n >= self.widgets_per_row:
        # g.app.iconWidgetCount = 0
        # self.addRow()

    # g.app.iconWidgetCount += 1
#@-node:ekr.20081121105001.270:addRowIfNeeded
#@+node:ekr.20081121105001.271:addWidget
def addWidget (self,w):

    self.w.addWidget(w)
#@-node:ekr.20081121105001.271:addWidget
#@+node:ekr.20081121105001.272:clear
def clear(self):

    """Destroy all the widgets in the icon bar"""

    self.w.clear()
    self.actions = []

    g.app.iconWidgetCount = 0
#@-node:ekr.20081121105001.272:clear
#@+node:ekr.20081121105001.273:deleteButton
def deleteButton (self,w):
    """ w is button """

    #g.trace(w, '##')    

    self.w.removeAction(w)

    self.c.bodyWantsFocus()
    self.c.outerUpdate()
#@-node:ekr.20081121105001.273:deleteButton
#@+node:ekr.20081121105001.274:setCommandForButton
def setCommandForButton(self,button,command):

    if command:
        # button is a leoIconBarButton.
        QtCore.QObject.connect(button.button,
            QtCore.SIGNAL("clicked()"),command)
#@-node:ekr.20081121105001.274:setCommandForButton
#@-node:ekr.20081121105001.266:class qtIconBarClass
#@-node:ekr.20081215162017.4:Allow coloring of script buttons
#@+node:ekr.20081124094918.1:Fix problems with scim
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/59c1e5d6acaf4de0

I've some more information about the problems with accent previously
reported:
- I can confirm that they are caused by the interaction scim+leo (with
and without the qt plugin). If scim is not started leo works fine. If
scim is running the problems appear and are slightly different with
and without the qt plugin. The workaround is obvious: don't use leo
and scim at the same time :-)
- accents are not working in the qt plugin when scintilla is used. If
qt-use-scintilla=False I can write this:

àáä (the same for the rest of vowels)

but if qt-use-scintilla=True when I enter the same sequence in the
keyboard I get:

`aaa (the same for the rest of vowels)

- the problem with the ñ character (reported previously too) is only
present in the qt plugin (both with and without scintilla)
#@-node:ekr.20081124094918.1:Fix problems with scim
#@+node:ekr.20090406111739.10:Let gui handle hard part of next/prev-line commands
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/ef04b185f74f4926

This is a little difficult to describe in words, but trying it out
should, I hope make the issue clear enough.

(1) Start by setting body_pane_wraps to true.

(2) Create a very long line of e.g. 500 characters, which is wrapped
around on the body pane. (E.g. paste in a paragraph from a Word
document). This text will then be wrapped onscreen into roughly 8
lines of 70 characters.

(3) The up and down arrows do not behave as expected.

I'd expect that in this scenario, pressing the down arrow key should
go to go to the next line down as it currently appears *onscreen* --
so in this example, I'd expect to have to press the down arrow several
times to get to the end of the paragraph.  This is the way that Emacs
works when it is in word wrap mode, and is of course is the way that
all word processors work. However, Leo does not play this way, and
takes you right to the end of the line (i.e. to the last of the 500
characters) when you press the down key once. This makes editing plain
text (e.g. using Leo as an outliner) rather more tricky than it ought
to be. Would it be possible to change the effect of Previous-Line and
Next-Line when in word wrap mode, so that they behave as other text
editors and word processors do?

============================

This is a long-standing problem.  It's tricky to fix in a straightforward
way.

However, I just realized that there might be a clever way: the commands
could let the gui handle the hard part of the command (the actual move) and
then the commands could detect the resulting row/col numbers as they must.

I've been putting this off, I'll see if this more clever way will work soon. 
#@nonl
#@-node:ekr.20090406111739.10:Let gui handle hard part of next/prev-line commands
#@-node:ekr.20081121105001.148: qt To do
#@+node:ekr.20081121105001.185:Scripts
#@+node:ekr.20081121105001.186:Script to display Qt font database
import PyQt4.QtGui as QtGui

db = QtGui.QFontDatabase()
for family in db.families():
    print family
    for style in db.styles(family):
        print '\t',style,db.smoothSizes(family,style)
#@-node:ekr.20081121105001.186:Script to display Qt font database
#@+node:ekr.20081121105001.187:dump guiBindNamesInverseDict
print g.dictToString(c.k.guiBindNamesInverseDict)

@
   BackSpace: 'BackSpace'
       Begin: 'Begin'
       Break: 'Break'
   Caps_Lock: 'Caps_Lock'
       Clear: 'Clear'
      Delete: 'Delete'
        Down: 'Down'
         End: 'End'
      Escape: 'Escape'
          F1: 'F1'
         F10: 'F10'
         F11: 'F11'
         F12: 'F12'
          F2: 'F2'
          F3: 'F3'
          F4: 'F4'
          F5: 'F5'
          F6: 'F6'
          F7: 'F7'
          F8: 'F8'
          F9: 'F9'
        Home: 'Home'
        Left: 'Left'
    Linefeed: 'Linefeed'
        Next: 'Next'
    Num_Lock: 'Num_Lock'
       Prior: 'Prior'
      Return: 'Return'
       Right: 'Right'
         Tab: 'Tab'
          Up: 'Up'
   ampersand: '&'
 asciicircum: '^'
  asciitilde: '~'
    asterisk: '*'
          at: '@'
   backslash: '\\'
         bar: '|'
   braceleft: '{'
  braceright: '}'
 bracketleft: '['
bracketright: ']'
       colon: ':'
       comma: ','
      dollar: '$'
       equal: '='
      exclam: '!'
     greater: '>'
        less: '<'
       minus: '-'
  numbersign: '#'
   parenleft: '('
  parenright: ')'
     percent: '%'
      period: '.'
        plus: '+'
    question: '?'
    quotedbl: '"'
   quoteleft: '`'
  quoteright: "'"
   semicolon: ';'
       slash: '/'
       space: ' '
  underscore: '_'
#@nonl
#@-node:ekr.20081121105001.187:dump guiBindNamesInverseDict
#@-node:ekr.20081121105001.185:Scripts
#@+node:ekr.20090717095154.3729:Leo 4.7 devel projects
#@+node:ekr.20090813101852.3644:Features
#@+node:ekr.20090718070434.3640:Removed signon code from guis
@nocolor-node

This is now done in app.computeSignon and app.writeWaitingLog.
#@nonl
#@-node:ekr.20090718070434.3640:Removed signon code from guis
#@+node:ekr.20090812211903.3642:Added support for iconclick hooks
#@+node:ekr.20090812211903.3641:onItemClicked (nativeTree) (New in Leo 4.7)
def onItemClicked (self,item,col):

    trace = False and not g.unitTesting
    verbose = False

    if self.busy(): return

    c = self.c

    if trace: g.trace(col,self.traceItem(item),g.callers(4))

    try:
        self.selecting = True

        p = self.item2position(item)
        if p:
            event = None
            g.doHook("iconclick1",c=c,p=p,v=p,event=event)
#@verbatim
            #@ c.frame.tree.OnIconDoubleClick(p) # Call the base class method.
            g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        else:
            g.trace('*** no p')

        c.outerUpdate()
    finally:
        self.selecting = False
#@-node:ekr.20090812211903.3641:onItemClicked (nativeTree) (New in Leo 4.7)
#@+node:ekr.20090124174652.120:qtTree.initAfterLoad
def initAfterLoad (self):

    '''Do late-state inits.'''

    # Called by Leo's core.

    c = self.c ; frame = c.frame
    w = c.frame.top ; tw = self.treeWidget

    if not leoQtTree.callbacksInjected:
        leoQtTree.callbacksInjected = True
        self.injectCallbacks() # A base class method.

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemDoubleClicked(QTreeWidgetItem*, int)"),
        self.onItemDoubleClicked)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemClicked(QTreeWidgetItem*, int)"),
        self.onItemClicked)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemSelectionChanged()"),
        self.onTreeSelect)

    # We don't need this.  Hooray!
    # w.connect(self.treeWidget,QtCore.SIGNAL(
            # "itemChanged(QTreeWidgetItem*, int)"),
        # self.onItemChanged)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemCollapsed(QTreeWidgetItem*)"),
        self.onItemCollapsed)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemExpanded(QTreeWidgetItem*)"),
        self.onItemExpanded)

    w.connect(self.treeWidget, QtCore.SIGNAL(
            "customContextMenuRequested(QPoint)"),
        self.onContextMenu)    

    self.ev_filter = leoQtEventFilter(c,w=self,tag='tree')
    tw.installEventFilter(self.ev_filter)

    c.setChanged(False)
#@-node:ekr.20090124174652.120:qtTree.initAfterLoad
#@-node:ekr.20090812211903.3642:Added support for iconclick hooks
#@+node:ekr.20091006164957.3701:Select all text if headline is newHeadline
#@+node:ekr.20090129062500.13:editLabelHelper (leoQtTree)
def editLabelHelper (self,item,selectAll=False,selection=None):

    '''Called by nativeTree.editLabel to do
    gui-specific stuff.'''

    w = self.treeWidget
    w.setCurrentItem(item) # Must do this first.
    w.editItem(item)
        # Generates focus-in event that tree doesn't report.
    e = w.itemWidget(item,0) # A QLineEdit.

    if e:
        s = e.text() ; len_s = len(s)
        if s == 'newHeadline': selectAll=True
        if selection:
            i,j,ins = selection
            start,n = i,abs(i-j)
                # Not right for backward searches.
        elif selectAll: start,n,ins = 0,len_s,len_s
        else:           start,n,ins = len_s,0,len_s
        e.setObjectName('headline')
        e.setSelection(start,n)
        # e.setCursorPosition(ins) # Does not work.
        e.setFocus()
        self.connectEditorWidget(e,item) # Hook up the widget.

    return e
#@-node:ekr.20090129062500.13:editLabelHelper (leoQtTree)
#@-node:ekr.20091006164957.3701:Select all text if headline is newHeadline
#@-node:ekr.20090813101852.3644:Features
#@+node:ekr.20090813101852.3643:Bugs
#@+node:ekr.20090718070434.3641:Fixed file-open focus problem
#@+node:ekr.20081121105001.317:Qt bindings... (qtFrame)
def bringToFront (self):
    self.lift()
def deiconify (self):
    if self.top.isMinimized(): # Buf 400739.
        self.lift()
def getFocus(self):
    return g.app.gui.get_focus(self.c) # Bug fix: 2009/6/30.
def get_window_info(self):
    rect = self.top.geometry()
    topLeft = rect.topLeft()
    x,y = topLeft.x(),topLeft.y()
    w,h = rect.width(),rect.height()
    # g.trace(w,h,x,y)
    return w,h,x,y
def iconify(self):
    self.top.showMinimized()
def lift (self):
    # g.trace(self.c,'\n',g.callers(9))
    if self.top.isMinimized(): # Bug 379141
        self.top.showNormal()
    self.top.activateWindow()
    self.top.raise_()
def update (self):
    pass
def getTitle (self):
    return g.app.gui.toUnicode(self.top.windowTitle())
def setTitle (self,s):
    self.top.setWindowTitle(s)
def setTopGeometry(self,w,h,x,y,adjustSize=True):
    # g.trace(x,y,w,y,g.callers(5))
    self.top.setGeometry(QtCore.QRect(x,y,w,h))
#@-node:ekr.20081121105001.317:Qt bindings... (qtFrame)
#@-node:ekr.20090718070434.3641:Fixed file-open focus problem
#@+node:ekr.20090813101852.3642:Eliminate double close prompt
#@+node:ekr.20081121105001.202:closeEvent (DynanicWindow)
def closeEvent (self,event):

    trace = False and not g.unitTesting
    c = self.c

    if not c.exists:
        # Fixes double-prompt bug on Linux.
        if trace: g.trace('destroyed')
        event.accept()
        return

    if c.inCommand:
        if trace: g.trace('in command')
        c.requestCloseWindow = True
    else:
        if trace: g.trace('closing')
        ok = g.app.closeLeoWindow(c.frame)
        if ok:
            event.accept()
        else:
            event.ignore()
#@-node:ekr.20081121105001.202:closeEvent (DynanicWindow)
#@-node:ekr.20090813101852.3642:Eliminate double close prompt
#@+node:ekr.20090818115409.3645:Fixed scrolling problem with multiple editors
#@-node:ekr.20090818115409.3645:Fixed scrolling problem with multiple editors
#@+node:ekr.20091006123049.3699:Fixed crash in quicksearch plugin
#@+node:ekr.20081121105001.330:createTab
def createTab (self,tabName,widget=None,wrap='none'):
    """ Create a new tab in tab widget

    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """

    trace = False and not g.unitTesting
    if trace: g.trace(tabName,g.callers(4))

    c = self.c ; w = self.tabWidget

    # Important. Not called during startup.

    if widget is None:
        # widget = QtGui.QTextBrowser()
        widget = QTextBrowserSubclass(parent=None,c=c,wrapper=self)
        contents = leoQTextEditWidget(widget=widget,name='log',c=c)
        widget.leo_log_wrapper = contents # Inject an ivar.
        if trace: g.trace('** creating',tabName,contents,widget,'\n',g.callers(9))
        widget.setWordWrapMode(QtGui.QTextOption.NoWrap)
        widget.setReadOnly(False) # Allow edits.
        self.logDict[tabName] = widget
        if tabName == 'Log':
            self.logCtrl = contents
            widget.setObjectName('log-widget')
            theFilter = leoQtEventFilter(c,w=self,tag='log')
            self.eventFilters.append(theFilter) # Needed!
            widget.installEventFilter(theFilter)
        self.contentsDict[tabName] = widget
        w.addTab(widget,tabName)
    else:
        contents = widget
        # Bug fix: 2009/10/06
        widget.leo_log_wrapper = contents # Inject an ivar.
        # if trace: g.trace('** using',tabName,contents)
        self.contentsDict[tabName] = contents
        w.addTab(contents,tabName)

    return contents
#@-node:ekr.20081121105001.330:createTab
#@-node:ekr.20091006123049.3699:Fixed crash in quicksearch plugin
#@+node:ekr.20091006142109.3700:Fixed @nosent dirty bug
# Note: changing a headline as *no effect* on an @nosent file!
# The only bug was that redraw_after_head_changed must update icons.
#@nonl
#@+node:ekr.20090124174652.59:onHeadChanged (nativeTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None,e=None):

    '''Officially change a headline.'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; u = c.undoer
    if not p:
        if trace: g.trace('** no p')
        return

    item = self.getCurrentItem()
    if not item:
        if trace and verbose: g.trace('** no item')
        return
    if not e:
        e = self.getTreeEditorForItem(item)
    if not e:
        if trace and verbose: g.trace('** not editing')
        return

    s = g.u(e.text())

    if g.doHook("headkey1",c=c,p=c.p,v=c.p,s=s):
        return

    self.closeEditorHelper(e,item)
    oldHead = p.h
    changed = s != oldHead
    if changed:
        if trace: g.trace('new',repr(s),'old',p.h,g.callers())
        p.initHeadString(s)
        item.setText(0,s) # Required to avoid full redraw.
        undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)

    g.doHook("headkey2",c=c,p=c.p,v=c.p,s=s)

    # This is a crucial shortcut.
    if g.unitTesting: return

    if changed:
        self.redraw_after_head_changed()

    if 0: # Don't do this: it interferes with clicks, and is not needed.
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()

    c.outerUpdate()
#@-node:ekr.20090124174652.59:onHeadChanged (nativeTree)
#@+node:ekr.20090124174652.15:Drawing... (nativeTree)
#@+node:ekr.20090124174652.17:full_redraw & helpers
# forceDraw not used. It is used in the Tk code.

def full_redraw (self,p=None,scroll=True,forceDraw=False):

    '''Redraw all visible nodes of the tree.

    Preserve the vertical scrolling unless scroll is True.'''

    trace = False and not g.app.unitTesting
    verbose = False
    c = self.c

    if self.busy():
        return g.trace('*** full_redraw: busy!',g.callers(5))

    if p is None:   p = c.currentPosition()
    else:           c.setCurrentPosition(p)

    # if trace: g.trace(p.isExpanded(),p.h)

    self.redrawCount += 1
    if trace: t1 = g.getTime()
    self.initData()
    self.nodeDrawCount = 0
    try:
        self.redrawing = True
        self.drawTopTree(p)
    finally:
        self.redrawing = False

    self.setItemForCurrentPosition(scroll=scroll)
    c.requestRedrawFlag= False

    if trace:
        theTime = g.timeSince(t1)
        callers = g.choose(verbose,g.callers(5),'')
        g.trace('*** %s: scroll %5s drew %3s nodes in %s' % (
            self.redrawCount,scroll,self.nodeDrawCount,theTime),callers)

# Compatibility
redraw = full_redraw 
redraw_now = full_redraw
#@+node:ekr.20090124174652.19:drawChildren
def drawChildren (self,p,parent_item):

    trace = False and not g.unitTesting

    if trace: g.trace('children? %5s expanded? %5s %s' % (
        p.hasChildren(),p.isExpanded(),p.h))

    if not p:
        return g.trace('can not happen: no p')

    if p.hasChildren():
        if p.isExpanded():
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child,parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child,parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
#@-node:ekr.20090124174652.19:drawChildren
#@+node:ekr.20090124174652.20:drawNode
def drawNode (self,p,parent_item):

    trace = False
    c = self.c 
    self.nodeDrawCount += 1

    # Allocate the item.
    item = self.createTreeItem(p,parent_item) 

    # Do this now, so self.isValidItem will be true in setItemIcon.
    self.rememberItem(p,item)

    # Set the headline and maybe the icon.
    self.setItemText(item,p.h)
    if p:
        self.drawItemIcon(p,item)

    if trace: g.trace(self.traceItem(item))

    return item
#@-node:ekr.20090124174652.20:drawNode
#@+node:ekr.20090129062500.12:drawTopTree (qt)
def drawTopTree (self,p):

    c = self.c
    hPos,vPos = self.getScroll()
    self.clear()
    # Draw all top-level nodes and their visible descendants.
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p ; h = p.h
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            while p:
                self.drawTree(p)
                p.moveToNext()
        else:
            self.drawTree(p)
    else:
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()

    # This method always retains previous scroll position.
    self.setHScroll(hPos)
    self.setVScroll(vPos)

    self.repaint()
#@nonl
#@-node:ekr.20090129062500.12:drawTopTree (qt)
#@+node:ekr.20090124174652.21:drawTree
def drawTree (self,p,parent_item=None):

    # Draw the (visible) parent node.
    item = self.drawNode(p,parent_item)

    # Draw all the visible children.
    self.drawChildren(p,parent_item=item)
#@-node:ekr.20090124174652.21:drawTree
#@+node:ekr.20090124174652.22:initData
def initData (self):

    # g.trace('*****')

    self.item2positionDict = {}
    self.item2vnodeDict = {}
    self.position2itemDict = {}
    self.vnode2itemsDict = {}
    self.editWidgetsDict = {}
#@-node:ekr.20090124174652.22:initData
#@+node:ekr.20090124174652.23:rememberItem
def rememberItem (self,p,item):

    trace = False and not g.unitTesting
    if trace: g.trace(id(item),p.h)

    v = p.v

    # Update position dicts.
    itemHash = self.itemHash(item)
    self.position2itemDict[p.key()] = item
    self.item2positionDict[itemHash] = p.copy() # was item

    # Update item2vnodeDict.
    self.item2vnodeDict[itemHash] = v # was item

    # Update vnode2itemsDict.
    d = self.vnode2itemsDict
    aList = d.get(v,[])
    if item in aList:
        g.trace('*** ERROR *** item already in list: %s, %s' % (item,aList))
    else:
        aList.append(item)
    d[v] = aList
#@-node:ekr.20090124174652.23:rememberItem
#@-node:ekr.20090124174652.17:full_redraw & helpers
#@+node:ekr.20090124174652.24:redraw_after_contract
def redraw_after_contract (self,p=None):

    trace = False and not g.unitTesting

    if self.redrawing:
        return

    item = self.position2item(p)

    if item:
        if trace: g.trace('contracting item',item,p and p.h or '<no p>')
        self.contractItem(item)
    else:
        # This is not an error.
        # We may have contracted a node that was not, in fact, visible.
        if trace: g.trace('***full redraw',p and p.h or '<no p>')
        self.full_redraw(scroll=False)
#@-node:ekr.20090124174652.24:redraw_after_contract
#@+node:ekr.20090124174652.25:redraw_after_expand
def redraw_after_expand (self,p=None):

    # Important, setting scrolling to False makes the problem *worse*
    self.full_redraw (p,scroll=True)
#@-node:ekr.20090124174652.25:redraw_after_expand
#@+node:ekr.20090124174652.26:redraw_after_head_changed
def redraw_after_head_changed (self):

    trace = False and not g.unitTesting

    if self.busy(): return

    c = self.c ; p = c.currentPosition()
    ew = self.edit_widget(p)

    if trace: g.trace(p.h)

    currentItem = self.getCurrentItem()

    if p:
        for item in self.vnode2items(p.v):
            if self.isValidItem(item):
                self.setItemText(item,p.h)

    # Bug fix: 2009/10/06
    self.redraw_after_icons_changed()
#@-node:ekr.20090124174652.26:redraw_after_head_changed
#@+node:ekr.20090124174652.27:redraw_after_icons_changed
def redraw_after_icons_changed (self):

    trace = False and not g.unitTesting

    if self.busy(): return

    self.redrawCount += 1 # To keep a unit test happy.

    c = self.c

    if trace: g.trace(c.p.h,g.callers(4))

    # Suppress call to setHeadString in onItemChanged!
    self.redrawing = True
    try:
        item = self.getCurrentItem()
        for p in c.rootPosition().self_and_siblings():
            # Updates icons in p and all visible descendants of p.
            self.updateVisibleIcons(p)
    finally:
        self.redrawing = False
#@-node:ekr.20090124174652.27:redraw_after_icons_changed
#@+node:ekr.20090124174652.28:redraw_after_select
# Important: this can not replace before/afterSelectHint.

def redraw_after_select (self,p=None):

    '''Redraw the entire tree when an invisible node
    is selected.'''

    trace = False and not g.unitTesting

    if trace: g.trace('(leoQtTree) busy? %s %s' % (
        self.busy(),p and p.h or '<no p>'),g.callers(4))

    # Prevent the selecting lockout from disabling the redraw.
    oldSelecting = self.selecting
    self.selecting = False
    try:
        if not self.busy():
            self.full_redraw(p,scroll=False)
    finally:
        self.selecting = oldSelecting

    # c.redraw_after_select calls tree.select indirectly.
    # Do not call it again here.
#@-node:ekr.20090124174652.28:redraw_after_select
#@-node:ekr.20090124174652.15:Drawing... (nativeTree)
#@-node:ekr.20091006142109.3700:Fixed @nosent dirty bug
#@-node:ekr.20090813101852.3643:Bugs
#@-node:ekr.20090717095154.3729:Leo 4.7 devel projects
#@-all
#@nonl
#@-node:ekr.20081121105001.147:@thin qtNotes.txt
#@-leo
