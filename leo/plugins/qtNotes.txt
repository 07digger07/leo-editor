#@+leo-ver=4-thin
#@+node:ekr.20081121105001.147:@thin qtNotes.txt
#@+all
#@+node:ekr.20081121105001.148: qt To do
#@+node:ekr.20090429101847.10:Support canvas widgets in all panes
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/9ac06147e75fc042

add-canvas: Like add-editor, but it creates a canvas area, not a text area.
#@nonl
#@-node:ekr.20090429101847.10:Support canvas widgets in all panes
#@+node:ekr.20081215074704.21:Add drag and drop
#@-node:ekr.20081215074704.21:Add drag and drop
#@+node:ekr.20090418064921.12:Qt, vim bindings
http://groups.google.com/group/leo-editor/browse_thread/thread/7285ac185355efb1
#@nonl
#@-node:ekr.20090418064921.12:Qt, vim bindings
#@+node:ekr.20081215162017.4:Allow coloring of script buttons
@nocolor-node

Use @string qt-button-color = lightSteelBlue

The following does *not* work in @data qt-gui-plugin-style-sheet::

    QPushButton {
        background-color: red;
    }
#@-node:ekr.20081215162017.4:Allow coloring of script buttons
#@+node:ekr.20081124094918.1:Fix problems with scim
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/59c1e5d6acaf4de0

I've some more information about the problems with accent previously
reported:
- I can confirm that they are caused by the interaction scim+leo (with
and without the qt plugin). If scim is not started leo works fine. If
scim is running the problems appear and are slightly different with
and without the qt plugin. The workaround is obvious: don't use leo
and scim at the same time :-)
- accents are not working in the qt plugin when scintilla is used. If
qt-use-scintilla=False I can write this:

àáä (the same for the rest of vowels)

but if qt-use-scintilla=True when I enter the same sequence in the
keyboard I get:

`aaa (the same for the rest of vowels)

- the problem with the ñ character (reported previously too) is only
present in the qt plugin (both with and without scintilla)
#@-node:ekr.20081124094918.1:Fix problems with scim
#@-node:ekr.20081121105001.148: qt To do
#@+node:ekr.20090717095154.3729:Leo 4.7 b2
#@+node:ekr.20100119112903.3701:Update qttabs when saving a new file
#@-node:ekr.20100119112903.3701:Update qttabs when saving a new file
#@+node:ekr.20100121082850.3696:Fixed unicode bug
#@+node:ekr.20081121105001.536:onTextChanged (qtText)
def onTextChanged (self):

    '''Update Leo after the body has been changed.

    self.selecting is guaranteed to be True during
    the entire selection process.'''

    # Important: usually w.changingText is True.
    # This method very seldom does anything.
    trace = False and not g.unitTesting
    verbose = True
    c = self.c ; p = c.p
    tree = c.frame.tree ; w = self

    if w.changingText: 
        if trace and verbose: g.trace('already changing')
        return
    if tree.tree_select_lockout:
        if trace and verbose: g.trace('selecting lockout')
        return
    if tree.selecting:
        if trace and verbose: g.trace('selecting')
        return
    if tree.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if not p:
        return g.trace('*** no p')

    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText() # Converts to unicode.

    # Get the previous values from the vnode.
    oldText = p.b
    if oldText == newText:
        # This can happen as the result of undo.
        # g.trace('*** unexpected non-change',color="red")
        return

    # g.trace('**',len(newText),p.h,'\n',g.callers(8))

    oldIns  = p.v.insertSpot
    i,j = p.v.selectionStart,p.v.selectionLength
    oldSel  = (i,i+j)
    if trace: g.trace('oldSel',oldSel,'newSel',newSel)
    oldYview = None
    undoType = 'Typing'
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,
        oldSel=oldSel,newSel=newSel,oldYview=oldYview)

    # Update the vnode.
    p.v.setBodyString(newText)
    if True:
        p.v.insertSpot = newInsert
        i,j = newSel
        i,j = self.toGuiIndex(i),self.toGuiIndex(j)
        if i > j: i,j = j,i
        p.v.selectionStart,p.v.selectionLength = (i,j-i)

    # No need to redraw the screen.
    if not self.useScintilla:
        c.recolor()

    if g.app.qt_use_tabs:
        if trace: g.trace(c.frame.top)

    if not c.changed and c.frame.initComplete:
        c.setChanged(True)

    c.frame.body.updateEditors()
    c.frame.tree.updateIcon(p)

    if 1: # This works, and is probably better.
        # Set a hook for the old jEdit colorer.
        colorer = c.frame.body.colorizer.highlighter.colorer
        colorer.initFlag = True
    else:
        # Allow incremental recoloring.
        c.incrementalRecolorFlag = True
        c.outerUpdate()
#@-node:ekr.20081121105001.536:onTextChanged (qtText)
#@+node:ekr.20081121105001.183:Clipboard (qtGui)
def replaceClipboardWith (self,s):

    '''Replace the clipboard with the string s.'''

    trace = False and not g.unitTesting
    cb = self.qtApp.clipboard()
    if cb:
        # cb.clear()  # unnecessary, breaks on some Qt versions
        s = g.toUnicode(s)
        QtGui.QApplication.processEvents()
        cb.setText(s)
        QtGui.QApplication.processEvents()
        if trace: g.trace(len(s),type(s))
    else:
        g.trace('no clipboard!')

def getTextFromClipboard (self):

    '''Get a unicode string from the clipboard.'''

    trace = False and not g.unitTesting
    cb = self.qtApp.clipboard()
    if cb:
        QtGui.QApplication.processEvents()
        s = cb.text()
        if trace: g.trace (len(s),type(s))
        s = g.app.gui.toUnicode(s)
            # Same as g.u(s), but with error handling.
        return s
    else:
        g.trace('no clipboard!')
        return ''
#@-node:ekr.20081121105001.183:Clipboard (qtGui)
#@+node:ekr.20081121105001.502:toUnicode (qtGui)
def toUnicode (self,s):

    try:
        s = g.u(s)
        return s
    except Exception:
        g.trace('*** Unicode Error: bugs possible')
        # The mass update omitted the encoding param.
        return g.toUnicode(s,reportErrors='replace')
#@-node:ekr.20081121105001.502:toUnicode (qtGui)
#@-node:ekr.20100121082850.3696:Fixed unicode bug
#@-node:ekr.20090717095154.3729:Leo 4.7 b2
#@+node:ekr.20100201113707.3728:Leo 4.7 b3 projects
#@+node:ekr.20100201113707.3727:Made sure Leo keywords end with whitespace
#@+node:ekr.20090614134853.3724:match_leo_keywords
def match_leo_keywords(self,s,i):

    '''Succeed if s[i:] is a Leo keyword.'''

    # g.trace(i,g.get_line(s,i))

    self.totalLeoKeywordsCalls += 1

    if s[i] != '@':
        return 0

    # fail if something besides whitespace precedes the word on the line.
    i2 = i-1
    while i2 >= 0:
        ch = s[i2]
        if ch == '\n':
            break
        elif ch in (' ','\t'):
            i2 -= 1
        else:
            return 0

    # Get the word as quickly as possible.
    j = i+1
    while j < len(s) and s[j] in self.word_chars:
        j += 1
    word = s[i+1:j] # Bug fix: 10/17/07: entries in leoKeywordsDict do not start with '@'

    if j < len(s) and s[j] not in (' ','\t','\n'):
        return -(j-i+1) # Fail.

    if self.leoKeywordsDict.get(word):
        kind = 'leoKeyword'
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j-i+1 # Bug fix: skip the last character.
        self.trace_match(kind,s,i,j)
        # g.trace('*** match',repr(s))
        return result
    else:
        return -(j-i+1) # An important optimization.
#@-node:ekr.20090614134853.3724:match_leo_keywords
#@-node:ekr.20100201113707.3727:Made sure Leo keywords end with whitespace
#@+node:ekr.20100102100353.3668:Show invisibles
#@+node:ekr.20090614134853.3696: Birth & init
#@+node:ekr.20090614134853.3697:__init__ (jeditColorizer)
def __init__(self,c,colorizer,highlighter,w):

    # Basic data...
    self.c = c
    self.colorizer = colorizer
    self.highlighter = highlighter # a QSyntaxHighlighter
    self.p = None
    self.w = w
    assert(w == self.c.frame.body.bodyCtrl)

    # Used by recolor and helpers...
    self.actualColorDict = {} # Used only by setTag.
    self.hyperCount = 0
    self.defaultState = 'default-state:' # The name of the default state.
    self.nextState = 1 # Dont use 0.
    self.restartDict = {} # Keys are state numbers, values are restart functions.
    self.stateDict = {} # Keys are state numbers, values state names.
    self.stateNameDict = {} # Keys are state names, values are state numbers.

    # Attributes dict ivars: defaults are as shown...
    self.default = 'null'
    self.digit_re = ''
    self.escape = ''
    self.highlight_digits = True
    self.ignore_case = True
    self.no_word_sep = ''
    # Config settings...
    self.showInvisibles = c.config.getBool("show_invisibles_by_default")
    self.colorizer.showInvisibles = self.showInvisibles
    # g.trace(self.showInvisibles)
        # Also set in init().
    self.underline_undefined = c.config.getBool("underline_undefined_section_names")
    self.use_hyperlinks = c.config.getBool("use_hyperlinks")
    # Debugging...
    self.count = 0 # For unit testing.
    self.allow_mark_prev = True # The new colorizer tolerates this nonsense :-)
    self.tagCount = 0
    self.trace = False or c.config.getBool('trace_colorizer')
    self.trace_leo_matches = False
    self.trace_match_flag = False # (Useful) True: trace all matching methods.
    self.verbose = False
    # Profiling...
    self.recolorCount = 0 # Total calls to recolor
    self.stateCount = 0 # Total calls to setCurrentState
    self.totalChars = 0 # The total number of characters examined by recolor.
    self.totalStates = 0
    self.maxStateNumber = 0
    self.totalKeywordsCalls = 0
    self.totalLeoKeywordsCalls = 0
    # Mode data...
    self.defaultRulesList = []
    self.importedRulesets = {}
    self.prev = None # The previous token.
    self.fonts = {} # Keys are config names.  Values are actual fonts.
    self.keywords = {} # Keys are keywords, values are 0..5.
    self.last_language = None # The language for which configuration tags are valid.
    self.modes = {} # Keys are languages, values are modes.
    self.mode = None # The mode object for the present language.
    self.modeBunch = None # A bunch fully describing a mode.
    self.modeStack = []
    self.rulesDict = {}
    # self.defineAndExtendForthWords()
    self.word_chars = {} # Inited by init_keywords().
    self.setFontFromConfig()
    self.tags = [
        "blank","comment","cwebName","docPart","keyword","leoKeyword",
        "latexModeBackground","latexModeKeyword",
        "latexBackground","latexKeyword",
        "link","name","nameBrackets","pp","string",
        "elide","bold","bolditalic","italic", # new for wiki styling.
        "tab",
        # Leo jEdit tags...
        '@color', '@nocolor', 'doc_part', 'section_ref',
        # jEdit tags.
        'bracketRange',
        'comment1','comment2','comment3','comment4',
        'function',
        'keyword1','keyword2','keyword3','keyword4',
        'label','literal1','literal2','literal3','literal4',
        'markup','operator',
    ]

    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
#@+node:ekr.20090614134853.3698:defineLeoKeywordsDict
def defineLeoKeywordsDict(self):

    self.leoKeywordsDict = {}

    for key in g.globalDirectiveList:
        self.leoKeywordsDict [key] = 'leoKeyword'
#@-node:ekr.20090614134853.3698:defineLeoKeywordsDict
#@+node:ekr.20090614134853.3699:defineDefaultColorsDict
def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {
        # tag name       :(     option name,           default color),
        'blank'          :('blank_color',                 'black'), # 2010/1/2
        'tab'            :('tab_color',                   'black'), # 2010/1/2
        'comment'        :('comment_color',               'red'),
        'cwebName'       :('cweb_section_name_color',     'red'),
        'pp'             :('directive_color',             'blue'),
        'docPart'        :('doc_part_color',              'red'),
        'keyword'        :('keyword_color',               'blue'),
        'leoKeyword'     :('leo_keyword_color',           'blue'),
        'link'           :('section_name_color',          'red'),
        'nameBrackets'   :('section_name_brackets_color', 'blue'),
        'string'         :('string_color',                '#00aa00'), # Used by IDLE.
        'name'           :('undefined_section_name_color','red'),
        'latexBackground':('latex_background_color',      'white'),

        # Tags used by forth.
        'bracketRange'   :('bracket_range_color','orange'),

        # jEdit tags.
        'comment1'       :('comment1_color', 'red'),
        'comment2'       :('comment2_color', 'red'),
        'comment3'       :('comment3_color', 'red'),
        'comment4'       :('comment4_color', 'red'),
        'function'       :('function_color', 'black'),
        'keyword1'       :('keyword1_color', 'blue'),
        'keyword2'       :('keyword2_color', 'blue'),
        'keyword3'       :('keyword3_color', 'blue'),
        'keyword4'       :('keyword4_color', 'blue'),
        'keyword5'       :('keyword5_color', 'blue'),
        'label'          :('label_color',    'black'),
        'literal1'       :('literal1_color', '#00aa00'),
        'literal2'       :('literal2_color', '#00aa00'),
        'literal3'       :('literal3_color', '#00aa00'),
        'literal4'       :('literal4_color', '#00aa00'),
        'markup'         :('markup_color',   'red'),
        'null'           :('null_color',     'black'),
        'operator'       :('operator_color', 'black'),
    }
#@-node:ekr.20090614134853.3699:defineDefaultColorsDict
#@+node:ekr.20090614134853.3700:defineDefaultFontDict
def defineDefaultFontDict (self):

    self.default_font_dict = {
        # tag name      : option name
        'comment'       :'comment_font',
        'cwebName'      :'cweb_section_name_font',
        'pp'            :'directive_font',
        'docPart'       :'doc_part_font',
        'keyword'       :'keyword_font',
        'leoKeyword'    :'leo_keyword_font',
        'link'          :'section_name_font',
        'nameBrackets'  :'section_name_brackets_font',
        'string'        :'string_font',
        'name'          :'undefined_section_name_font',
        'latexBackground':'latex_background_font',
        'tab'           : 'tab_font',

        # Tags used by forth.
        'bracketRange'   :'bracketRange_font',

         # jEdit tags.
        'comment1'      :'comment1_font',
        'comment2'      :'comment2_font',
        'comment3'      :'comment3_font',
        'comment4'      :'comment4_font',
        'function'      :'function_font',
        'keyword1'      :'keyword1_font',
        'keyword2'      :'keyword2_font',
        'keyword3'      :'keyword3_font',
        'keyword4'      :'keyword4_font',
        'keyword5'      :'keyword5_font',
        'label'         :'label_font',
        'literal1'      :'literal1_font',
        'literal2'      :'literal2_font',
        'literal3'      :'literal3_font',
        'literal4'      :'literal4_font',
        'markup'        :'markup_font',
        # 'nocolor' This tag is used, but never generates code.
        'null'          :'null_font',
        'operator'      :'operator_font',
    }
#@-node:ekr.20090614134853.3700:defineDefaultFontDict
#@-node:ekr.20090614134853.3697:__init__ (jeditColorizer)
#@+node:ekr.20090614134853.3701:addImportedRules
def addImportedRules (self,mode,rulesDict,rulesetName):

    '''Append any imported rules at the end of the rulesets specified in mode.importDict'''

    if self.importedRulesets.get(rulesetName):
        return
    else:
        self.importedRulesets [rulesetName] = True

    names = hasattr(mode,'importDict') and mode.importDict.get(rulesetName,[]) or []

    for name in names:
        savedBunch = self.modeBunch
        ok = self.init_mode(name)
        if ok:
            rulesDict2 = self.rulesDict
            for key in rulesDict2.keys():
                aList = self.rulesDict.get(key,[])
                aList2 = rulesDict2.get(key)
                if aList2:
                    # Don't add the standard rules again.
                    rules = [z for z in aList2 if z not in aList]
                    if rules:
                        # g.trace([z.__name__ for z in rules])
                        aList.extend(rules)
                        self.rulesDict [key] = aList
        # g.trace('***** added rules for %s from %s' % (name,rulesetName))
        self.initModeFromBunch(savedBunch)
#@nonl
#@-node:ekr.20090614134853.3701:addImportedRules
#@+node:ekr.20090614134853.3702:addLeoRules
def addLeoRules (self,theDict):

    '''Put Leo-specific rules to theList.'''

    table = (
        # Rules added at front are added in **reverse** order.
        ('@',  self.match_leo_keywords,True), # Called after all other Leo matchers.
            # Debatable: Leo keywords override langauge keywords.
        ('@',  self.match_at_color,    True),
        ('@',  self.match_at_killcolor,True),
        ('@',  self.match_at_nocolor,  True),
        ('@',  self.match_at_nocolor_node,True),
        ('@',  self.match_doc_part,    True), 
        ('<',  self.match_section_ref, True), # Called **first**.
        # Rules added at back are added in normal order.
        (' ',  self.match_blanks,      False),
        ('\t', self.match_tabs,        False),
    )

    for ch, rule, atFront, in table:

        # Replace the bound method by an unbound method.

        if g.isPython3:
            rule = rule.__func__
        else:
            rule = rule.im_func
        # g.trace(rule)

        theList = theDict.get(ch,[])
        if rule not in theList:
            if atFront:
                theList.insert(0,rule)
            else:
                theList.append(rule)
            theDict [ch] = theList

    # g.trace(g.listToString(theDict.get('@')))
#@-node:ekr.20090614134853.3702:addLeoRules
#@+node:ekr.20090614134853.3703:configure_tags
def configure_tags (self):

    trace = False and not g.unitTesting
    verbose = False
    traceColor = False
    traceFonts = True
    c = self.c ; w = self.w

    if trace: g.trace(self.colorizer.language)

    # The stated default is 40, but apparently it must be set explicitly.
    tabWidth = c.config.getInt('qt-tab-width') or 40
    w.widget.setTabStopWidth(tabWidth)

    if w and hasattr(w,'start_tag_configure'):
        w.start_tag_configure()

    # Get the default body font.
    defaultBodyfont = self.fonts.get('default_body_font')
    if not defaultBodyfont:
        defaultBodyfont = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize)
        self.fonts['default_body_font'] = defaultBodyfont

    # Configure fonts.
    keys = list(self.default_font_dict.keys()) ; keys.sort()
    for key in keys:
        option_name = self.default_font_dict[key]
        # First, look for the language-specific setting, then the general setting.
        for name in ('%s_%s' % (self.colorizer.language,option_name),(option_name)):
            font = self.fonts.get(name)
            if font:
                if trace and traceFonts:
                    g.trace('**found',name,id(font))
                w.tag_config(key,font=font)
                break
            else:
                family = c.config.get(name + '_family','family')
                size   = c.config.get(name + '_size',  'size')   
                slant  = c.config.get(name + '_slant', 'slant')
                weight = c.config.get(name + '_weight','weight')
                if family or slant or weight or size:
                    family = family or g.app.config.defaultFontFamily
                    size   = size or c.config.defaultBodyFontSize
                    slant  = slant or 'roman'
                    weight = weight or 'normal'
                    font = g.app.gui.getFontFromParams(family,size,slant,weight)
                    # Save a reference to the font so it 'sticks'.
                    self.fonts[key] = font
                    if trace and traceFonts:
                        g.trace('**found',key,name,family,size,slant,weight,id(font))
                    w.tag_config(key,font=font)
                    break
        else: # Neither the general setting nor the language-specific setting exists.
            if list(self.fonts.keys()): # Restore the default font.
                if trace and verbose and traceFonts: g.trace('default',key)
                w.tag_config(key,font=defaultBodyfont)
            else:
                if trace and traceFonts:
                    g.trace('no fonts')

    keys = list(self.default_colors_dict.keys()) ; keys.sort()
    for name in keys:
        option_name,default_color = self.default_colors_dict[name]
        color = (
            c.config.getColor('%s_%s' % (self.colorizer.language,option_name)) or
            c.config.getColor(option_name) or
            default_color
        )
        if trace and traceColor: g.trace(option_name,color)

        # Must use foreground, not fg.
        try:
            w.tag_configure(name, foreground=color)
        except: # Recover after a user error.
            g.es_exception()
            w.tag_configure(name, foreground=default_color)

    # underline=var doesn't seem to work.
    if 0: # self.use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
        w.tag_configure("link",underline=1) # defined
        w.tag_configure("name",underline=0) # undefined
    else:
        w.tag_configure("link",underline=0)
        if self.underline_undefined:
            w.tag_configure("name",underline=1)
        else:
            w.tag_configure("name",underline=0)

    self.configure_variable_tags()

    # Colors for latex characters.  Should be user options...

    if 1: # Alas, the selection doesn't show if a background color is specified.
        w.tag_configure("latexModeBackground",foreground="black")
        w.tag_configure("latexModeKeyword",foreground="blue")
        w.tag_configure("latexBackground",foreground="black")
        w.tag_configure("latexKeyword",foreground="blue")
    else: # Looks cool, and good for debugging.
        w.tag_configure("latexModeBackground",foreground="black",background="seashell1")
        w.tag_configure("latexModeKeyword",foreground="blue",background="seashell1")
        w.tag_configure("latexBackground",foreground="black",background="white")
        w.tag_configure("latexKeyword",foreground="blue",background="white")

    # Tags for wiki coloring.
    w.tag_configure("bold",font=self.bold_font)
    w.tag_configure("italic",font=self.italic_font)
    w.tag_configure("bolditalic",font=self.bolditalic_font)
    for name in self.color_tags_list:
        w.tag_configure(name,foreground=name)

    try:
        w.end_tag_configure()
    except AttributeError:
        pass
#@-node:ekr.20090614134853.3703:configure_tags
#@+node:ekr.20090614134853.3704:configure_variable_tags
def configure_variable_tags (self):

    c = self.c ; w = self.w

    # g.trace()

    for name,option_name,default_color in (
        ("blank","show_invisibles_space_background_color","Gray90"),
        ("tab",  "show_invisibles_tab_background_color",  "Gray80"),
        ("elide", None,                                   "yellow"),
    ):
        if self.showInvisibles:
            color = option_name and c.config.getColor(option_name) or default_color
        else:
            option_name,default_color = self.default_colors_dict.get(name,(None,None),)
            color = option_name and c.config.getColor(option_name) or ''
        try:
            w.tag_configure(name,background=color)
        except: # A user error.
            w.tag_configure(name,background=default_color)

    # Special case:
    if not self.showInvisibles:
        w.tag_configure("elide",elide="1")
#@-node:ekr.20090614134853.3704:configure_variable_tags
#@+node:ekr.20090614134853.3705:init (jeditColorizer)
def init (self,p,s):

    trace = False and not g.unitTesting

    if p: self.p = p.copy()
    self.all_s = s or ''

    if trace: g.trace('='*20,self.colorizer.language) #,g.callers(4))

    # State info.
    self.all_s = s
    self.global_i,self.global_j = 0,0
    self.global_offset = 0

    # These *must* be recomputed.
    self.nextState = 1 # Dont use 0.
    self.stateDict = {}
    self.stateNameDict = {}
    self.restartDict = {}
    self.init_mode(self.colorizer.language)
    self.clearState()
    self.showInvisibles = self.colorizer.showInvisibles
        # The show/hide-invisible commands changes this.

    # Used by matchers.
    self.prev = None
    if self.last_language != self.colorizer.language:
        # Must be done to support per-language @font/@color settings.
        self.configure_tags()
        self.last_language = self.colorizer.language
#@nonl
#@-node:ekr.20090614134853.3705:init (jeditColorizer)
#@+node:ekr.20090614134853.3706:init_mode & helpers
def init_mode (self,name):

    '''Name may be a language name or a delegate name.'''

    trace = False and not g.unitTesting
    if not name: return False
    h = self.highlighter
    language,rulesetName = self.nameToRulesetName(name)
    bunch = self.modes.get(rulesetName)
    if bunch:
        if trace: g.trace('found',language,rulesetName,g.callers(2))
        self.initModeFromBunch(bunch)
        return True
    else:
        if trace: g.trace('****',language,rulesetName)
        path = g.os_path_join(g.app.loadDir,'..','modes')
        # Bug fix: 2008/2/10: Don't try to import a non-existent language.
        fileName = g.os_path_join(path,'%s.py' % (language))
        if g.os_path_exists(fileName):
            mode = g.importFromPath (language,path)
        else: mode = None

        if mode:
            # A hack to give modes/forth.py access to c.
            if hasattr(mode,'pre_init_mode'):
                mode.pre_init_mode(self.c)
        else:
            # Create a dummy bunch to limit recursion.
            self.modes [rulesetName] = self.modeBunch = g.Bunch(
                attributesDict  = {},
                defaultColor    = None,
                keywordsDict    = {},
                language        = language,
                mode            = mode,
                properties      = {},
                rulesDict       = {},
                rulesetName     = rulesetName,
            )
            # g.trace('No colorizer file: %s.py' % language)
            self.rulesetName = rulesetName
            return False
        self.colorizer.language = language
        self.rulesetName = rulesetName
        self.properties = hasattr(mode,'properties') and mode.properties or {}
        self.keywordsDict = hasattr(mode,'keywordsDictDict') and mode.keywordsDictDict.get(rulesetName,{}) or {}
        self.setKeywords()
        self.attributesDict = hasattr(mode,'attributesDictDict') and mode.attributesDictDict.get(rulesetName) or {}
        self.setModeAttributes()
        self.rulesDict = hasattr(mode,'rulesDictDict') and mode.rulesDictDict.get(rulesetName) or {}
        self.addLeoRules(self.rulesDict)

        self.defaultColor = 'null'
        self.mode = mode
        self.modes [rulesetName] = self.modeBunch = g.Bunch(
            attributesDict  = self.attributesDict,
            defaultColor    = self.defaultColor,
            keywordsDict    = self.keywordsDict,
            language        = self.colorizer.language,
            mode            = self.mode,
            properties      = self.properties,
            rulesDict       = self.rulesDict,
            rulesetName     = self.rulesetName,
        )
        # Do this after 'officially' initing the mode, to limit recursion.
        self.addImportedRules(mode,self.rulesDict,rulesetName)
        self.updateDelimsTables()
        initialDelegate = self.properties.get('initialModeDelegate')
        if initialDelegate:
            # g.trace('initialDelegate',initialDelegate)
            # Replace the original mode by the delegate mode.
            self.init_mode(initialDelegate)
            language2,rulesetName2 = self.nameToRulesetName(initialDelegate)
            self.modes[rulesetName] = self.modes.get(rulesetName2)
        return True
#@+node:ekr.20090614134853.3707:nameToRulesetName
def nameToRulesetName (self,name):

    '''Compute language and rulesetName from name, which is either a language or a delegate name.'''

    if not name: return ''

    i = name.find('::')
    if i == -1:
        language = name
        rulesetName = '%s_main' % (language)
    else:
        language = name[:i]
        delegate = name[i+2:]
        rulesetName = self.munge('%s_%s' % (language,delegate))

    # if rulesetName == 'php_main': rulesetName = 'php_php'

    # g.trace(name,language,rulesetName)
    return language,rulesetName
#@-node:ekr.20090614134853.3707:nameToRulesetName
#@+node:ekr.20090614134853.3708:setKeywords
def setKeywords (self):

    '''Initialize the keywords for the present language.

     Set self.word_chars ivar to string.letters + string.digits
     plus any other character appearing in any keyword.'''

    # Add any new user keywords to leoKeywordsDict.
    d = self.keywordsDict
    keys = list(d.keys())
    for s in g.globalDirectiveList:
        key = '@' + s
        if key not in keys:
            d [key] = 'leoKeyword'

    # Create a temporary chars list.  It will be converted to a dict later.
    chars = [g.toUnicode(ch) for ch in (string.ascii_letters + string.digits)]

    for key in list(d.keys()):
        for ch in key:
            if ch not in chars:
                chars.append(g.toUnicode(ch))

    # jEdit2Py now does this check, so this isn't really needed.
    # But it is needed for forth.py.
    for ch in (' ', '\t'):
        if ch in chars:
            # g.es_print('removing %s from word_chars' % (repr(ch)))
            chars.remove(ch)

    # g.trace(self.colorizer.language,[str(z) for z in chars])

    # Convert chars to a dict for faster access.
    self.word_chars = {}
    for z in chars:
        self.word_chars[z] = z
#@-node:ekr.20090614134853.3708:setKeywords
#@+node:ekr.20090614134853.3709:setModeAttributes
def setModeAttributes (self):

    '''Set the ivars from self.attributesDict,
    converting 'true'/'false' to True and False.'''

    d = self.attributesDict
    aList = (
        ('default',         'null'),
	    ('digit_re',        ''),
        ('escape',          ''), # New in Leo 4.4.2.
	    ('highlight_digits',True),
	    ('ignore_case',     True),
	    ('no_word_sep',     ''),
    )

    for key, default in aList:
        val = d.get(key,default)
        if val in ('true','True'): val = True
        if val in ('false','False'): val = False
        setattr(self,key,val)
        # g.trace(key,val)
#@nonl
#@-node:ekr.20090614134853.3709:setModeAttributes
#@+node:ekr.20090614134853.3710:initModeFromBunch
def initModeFromBunch (self,bunch):

    self.modeBunch = bunch
    self.attributesDict = bunch.attributesDict
    self.setModeAttributes()
    self.defaultColor   = bunch.defaultColor
    self.keywordsDict   = bunch.keywordsDict
    self.colorizer.language = bunch.language
    self.mode           = bunch.mode
    self.properties     = bunch.properties
    self.rulesDict      = bunch.rulesDict
    self.rulesetName    = bunch.rulesetName

    # State stuff.
    # h = self.highlighter
    # h.setCurrentBlockState(bunch.currentState)
    # self.nextState      = bunch.nextState
    # self.restartDict    = bunch.restartDict
    # self.stateDict      = bunch.stateDict
    # self.stateNameDict  = bunch.stateNameDict

    # self.clearState()

    # g.trace(self.rulesetName)

#@-node:ekr.20090614134853.3710:initModeFromBunch
#@+node:ekr.20090614134853.3711:updateDelimsTables
def updateDelimsTables (self):

    '''Update g.app.language_delims_dict if no entry for the language exists.'''

    d = self.properties
    lineComment = d.get('lineComment')
    startComment = d.get('commentStart')
    endComment = d.get('commentEnd')

    if lineComment and startComment and endComment:
        delims = '%s %s %s' % (lineComment,startComment,endComment)
    elif startComment and endComment:
        delims = '%s %s' % (startComment,endComment)
    elif lineComment:
        delims = '%s' % lineComment
    else:
        delims = None

    if delims:
        d = g.app.language_delims_dict
        if not d.get(self.colorizer.language):
            d [self.colorizer.language] = delims
            # g.trace(self.colorizer.language,'delims:',repr(delims))
#@-node:ekr.20090614134853.3711:updateDelimsTables
#@-node:ekr.20090614134853.3706:init_mode & helpers
#@+node:ekr.20090614134853.3712:munge
def munge(self,s):

    '''Munge a mode name so that it is a valid python id.'''

    valid = string.ascii_letters + string.digits + '_'

    return ''.join([g.choose(ch in valid,ch.lower(),'_') for ch in s])
#@nonl
#@-node:ekr.20090614134853.3712:munge
#@+node:ekr.20090614134853.3713:setFontFromConfig
def setFontFromConfig (self):

    c = self.c
    # isQt = g.app.gui.guiName() == 'qt'

    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize) # , tag = "colorer bold")

    # if self.bold_font and not isQt:
        # self.bold_font.configure(weight="bold")

    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize) # , tag = "colorer italic")

    # if self.italic_font and not isQt:
        # self.italic_font.configure(slant="italic",weight="normal")

    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize) # , tag = "colorer bold italic")

    # if self.bolditalic_font and not isQt:
        # self.bolditalic_font.configure(weight="bold",slant="italic")

    self.color_tags_list = []
    # self.image_references = []
#@nonl
#@-node:ekr.20090614134853.3713:setFontFromConfig
#@-node:ekr.20090614134853.3696: Birth & init
#@+node:ekr.20081124102726.11:tag_config & tag_configure (baseTextWidget)
def tag_config (self,*args,**keys):

    trace = False and not g.unitTesting
    if trace: g.trace(self,args,keys)

    if len(args) == 1:
        key = args[0]
        self.tags[key] = keys
        val = keys.get('foreground')
        underline = keys.get('underline')
        if val:
            # if trace: g.trace(key,val)
            self.configDict [key] = val
        if underline:
            self.configUnderlineDict [key] = True
    else:
        g.trace('oops',args,keys)

tag_configure = tag_config
#@-node:ekr.20081124102726.11:tag_config & tag_configure (baseTextWidget)
#@+node:ekr.20090614134853.3697:__init__ (jeditColorizer)
def __init__(self,c,colorizer,highlighter,w):

    # Basic data...
    self.c = c
    self.colorizer = colorizer
    self.highlighter = highlighter # a QSyntaxHighlighter
    self.p = None
    self.w = w
    assert(w == self.c.frame.body.bodyCtrl)

    # Used by recolor and helpers...
    self.actualColorDict = {} # Used only by setTag.
    self.hyperCount = 0
    self.defaultState = 'default-state:' # The name of the default state.
    self.nextState = 1 # Dont use 0.
    self.restartDict = {} # Keys are state numbers, values are restart functions.
    self.stateDict = {} # Keys are state numbers, values state names.
    self.stateNameDict = {} # Keys are state names, values are state numbers.

    # Attributes dict ivars: defaults are as shown...
    self.default = 'null'
    self.digit_re = ''
    self.escape = ''
    self.highlight_digits = True
    self.ignore_case = True
    self.no_word_sep = ''
    # Config settings...
    self.showInvisibles = c.config.getBool("show_invisibles_by_default")
    self.colorizer.showInvisibles = self.showInvisibles
    # g.trace(self.showInvisibles)
        # Also set in init().
    self.underline_undefined = c.config.getBool("underline_undefined_section_names")
    self.use_hyperlinks = c.config.getBool("use_hyperlinks")
    # Debugging...
    self.count = 0 # For unit testing.
    self.allow_mark_prev = True # The new colorizer tolerates this nonsense :-)
    self.tagCount = 0
    self.trace = False or c.config.getBool('trace_colorizer')
    self.trace_leo_matches = False
    self.trace_match_flag = False # (Useful) True: trace all matching methods.
    self.verbose = False
    # Profiling...
    self.recolorCount = 0 # Total calls to recolor
    self.stateCount = 0 # Total calls to setCurrentState
    self.totalChars = 0 # The total number of characters examined by recolor.
    self.totalStates = 0
    self.maxStateNumber = 0
    self.totalKeywordsCalls = 0
    self.totalLeoKeywordsCalls = 0
    # Mode data...
    self.defaultRulesList = []
    self.importedRulesets = {}
    self.prev = None # The previous token.
    self.fonts = {} # Keys are config names.  Values are actual fonts.
    self.keywords = {} # Keys are keywords, values are 0..5.
    self.last_language = None # The language for which configuration tags are valid.
    self.modes = {} # Keys are languages, values are modes.
    self.mode = None # The mode object for the present language.
    self.modeBunch = None # A bunch fully describing a mode.
    self.modeStack = []
    self.rulesDict = {}
    # self.defineAndExtendForthWords()
    self.word_chars = {} # Inited by init_keywords().
    self.setFontFromConfig()
    self.tags = [
        "blank","comment","cwebName","docPart","keyword","leoKeyword",
        "latexModeBackground","latexModeKeyword",
        "latexBackground","latexKeyword",
        "link","name","nameBrackets","pp","string",
        "elide","bold","bolditalic","italic", # new for wiki styling.
        "tab",
        # Leo jEdit tags...
        '@color', '@nocolor', 'doc_part', 'section_ref',
        # jEdit tags.
        'bracketRange',
        'comment1','comment2','comment3','comment4',
        'function',
        'keyword1','keyword2','keyword3','keyword4',
        'label','literal1','literal2','literal3','literal4',
        'markup','operator',
    ]

    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
#@+node:ekr.20090614134853.3698:defineLeoKeywordsDict
def defineLeoKeywordsDict(self):

    self.leoKeywordsDict = {}

    for key in g.globalDirectiveList:
        self.leoKeywordsDict [key] = 'leoKeyword'
#@-node:ekr.20090614134853.3698:defineLeoKeywordsDict
#@+node:ekr.20090614134853.3699:defineDefaultColorsDict
def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {
        # tag name       :(     option name,           default color),
        'blank'          :('blank_color',                 'black'), # 2010/1/2
        'tab'            :('tab_color',                   'black'), # 2010/1/2
        'comment'        :('comment_color',               'red'),
        'cwebName'       :('cweb_section_name_color',     'red'),
        'pp'             :('directive_color',             'blue'),
        'docPart'        :('doc_part_color',              'red'),
        'keyword'        :('keyword_color',               'blue'),
        'leoKeyword'     :('leo_keyword_color',           'blue'),
        'link'           :('section_name_color',          'red'),
        'nameBrackets'   :('section_name_brackets_color', 'blue'),
        'string'         :('string_color',                '#00aa00'), # Used by IDLE.
        'name'           :('undefined_section_name_color','red'),
        'latexBackground':('latex_background_color',      'white'),

        # Tags used by forth.
        'bracketRange'   :('bracket_range_color','orange'),

        # jEdit tags.
        'comment1'       :('comment1_color', 'red'),
        'comment2'       :('comment2_color', 'red'),
        'comment3'       :('comment3_color', 'red'),
        'comment4'       :('comment4_color', 'red'),
        'function'       :('function_color', 'black'),
        'keyword1'       :('keyword1_color', 'blue'),
        'keyword2'       :('keyword2_color', 'blue'),
        'keyword3'       :('keyword3_color', 'blue'),
        'keyword4'       :('keyword4_color', 'blue'),
        'keyword5'       :('keyword5_color', 'blue'),
        'label'          :('label_color',    'black'),
        'literal1'       :('literal1_color', '#00aa00'),
        'literal2'       :('literal2_color', '#00aa00'),
        'literal3'       :('literal3_color', '#00aa00'),
        'literal4'       :('literal4_color', '#00aa00'),
        'markup'         :('markup_color',   'red'),
        'null'           :('null_color',     'black'),
        'operator'       :('operator_color', 'black'),
    }
#@-node:ekr.20090614134853.3699:defineDefaultColorsDict
#@+node:ekr.20090614134853.3700:defineDefaultFontDict
def defineDefaultFontDict (self):

    self.default_font_dict = {
        # tag name      : option name
        'comment'       :'comment_font',
        'cwebName'      :'cweb_section_name_font',
        'pp'            :'directive_font',
        'docPart'       :'doc_part_font',
        'keyword'       :'keyword_font',
        'leoKeyword'    :'leo_keyword_font',
        'link'          :'section_name_font',
        'nameBrackets'  :'section_name_brackets_font',
        'string'        :'string_font',
        'name'          :'undefined_section_name_font',
        'latexBackground':'latex_background_font',
        'tab'           : 'tab_font',

        # Tags used by forth.
        'bracketRange'   :'bracketRange_font',

         # jEdit tags.
        'comment1'      :'comment1_font',
        'comment2'      :'comment2_font',
        'comment3'      :'comment3_font',
        'comment4'      :'comment4_font',
        'function'      :'function_font',
        'keyword1'      :'keyword1_font',
        'keyword2'      :'keyword2_font',
        'keyword3'      :'keyword3_font',
        'keyword4'      :'keyword4_font',
        'keyword5'      :'keyword5_font',
        'label'         :'label_font',
        'literal1'      :'literal1_font',
        'literal2'      :'literal2_font',
        'literal3'      :'literal3_font',
        'literal4'      :'literal4_font',
        'markup'        :'markup_font',
        # 'nocolor' This tag is used, but never generates code.
        'null'          :'null_font',
        'operator'      :'operator_font',
    }
#@-node:ekr.20090614134853.3700:defineDefaultFontDict
#@-node:ekr.20090614134853.3697:__init__ (jeditColorizer)
#@+node:ekr.20090614134853.3705:init (jeditColorizer)
def init (self,p,s):

    trace = False and not g.unitTesting

    if p: self.p = p.copy()
    self.all_s = s or ''

    if trace: g.trace('='*20,self.colorizer.language) #,g.callers(4))

    # State info.
    self.all_s = s
    self.global_i,self.global_j = 0,0
    self.global_offset = 0

    # These *must* be recomputed.
    self.nextState = 1 # Dont use 0.
    self.stateDict = {}
    self.stateNameDict = {}
    self.restartDict = {}
    self.init_mode(self.colorizer.language)
    self.clearState()
    self.showInvisibles = self.colorizer.showInvisibles
        # The show/hide-invisible commands changes this.

    # Used by matchers.
    self.prev = None
    if self.last_language != self.colorizer.language:
        # Must be done to support per-language @font/@color settings.
        self.configure_tags()
        self.last_language = self.colorizer.language
#@nonl
#@-node:ekr.20090614134853.3705:init (jeditColorizer)
#@+node:ekr.20090614134853.3699:defineDefaultColorsDict
def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {
        # tag name       :(     option name,           default color),
        'blank'          :('blank_color',                 'black'), # 2010/1/2
        'tab'            :('tab_color',                   'black'), # 2010/1/2
        'comment'        :('comment_color',               'red'),
        'cwebName'       :('cweb_section_name_color',     'red'),
        'pp'             :('directive_color',             'blue'),
        'docPart'        :('doc_part_color',              'red'),
        'keyword'        :('keyword_color',               'blue'),
        'leoKeyword'     :('leo_keyword_color',           'blue'),
        'link'           :('section_name_color',          'red'),
        'nameBrackets'   :('section_name_brackets_color', 'blue'),
        'string'         :('string_color',                '#00aa00'), # Used by IDLE.
        'name'           :('undefined_section_name_color','red'),
        'latexBackground':('latex_background_color',      'white'),

        # Tags used by forth.
        'bracketRange'   :('bracket_range_color','orange'),

        # jEdit tags.
        'comment1'       :('comment1_color', 'red'),
        'comment2'       :('comment2_color', 'red'),
        'comment3'       :('comment3_color', 'red'),
        'comment4'       :('comment4_color', 'red'),
        'function'       :('function_color', 'black'),
        'keyword1'       :('keyword1_color', 'blue'),
        'keyword2'       :('keyword2_color', 'blue'),
        'keyword3'       :('keyword3_color', 'blue'),
        'keyword4'       :('keyword4_color', 'blue'),
        'keyword5'       :('keyword5_color', 'blue'),
        'label'          :('label_color',    'black'),
        'literal1'       :('literal1_color', '#00aa00'),
        'literal2'       :('literal2_color', '#00aa00'),
        'literal3'       :('literal3_color', '#00aa00'),
        'literal4'       :('literal4_color', '#00aa00'),
        'markup'         :('markup_color',   'red'),
        'null'           :('null_color',     'black'),
        'operator'       :('operator_color', 'black'),
    }
#@-node:ekr.20090614134853.3699:defineDefaultColorsDict
#@+node:ekr.20090614134853.3722:match_blanks
def match_blanks (self,s,i):

    if not self.showInvisibles:
        return 0

    j = i ; n = len(s)

    while j < n and s[j] == ' ':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'blank')
        return j - i
    else:
        return 0
#@-node:ekr.20090614134853.3722:match_blanks
#@+node:ekr.20090614134853.3727:match_tabs
def match_tabs (self,s,i):

    if not self.showInvisibles:
        return 0

    if self.trace_leo_matches: g.trace()

    j = i ; n = len(s)

    while j < n and s[j] == '\t':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'tab')
        return j - i
    else:
        return 0
#@-node:ekr.20090614134853.3727:match_tabs
#@+node:ekr.20081121105001.376:getMenuLabel
def getMenuLabel (self,menu,name):

    '''Return the index of the menu item whose name (or offset) is given.
    Return None if there is no such menu item.'''

    # At present, it is valid to always return None.

    # g.trace('menu',menu,'name',name)

    # actions = menu.actions()
    # for action in actions:
        # g.trace(action)
#@-node:ekr.20081121105001.376:getMenuLabel
#@+node:ekr.20081121105001.377:setMenuLabel
def setMenuLabel (self,menu,name,label,underline=-1):

    def munge(s):
        return g.u(s or '').replace('&','')

    # menu is a qtMenuWrapper.
    # g.trace('menu',menu,'name: %20s label: %s' % (name,label))
    if not menu: return

    realName  = munge(self.getRealMenuName(name))
    realLabel = self.getRealMenuName(label)
    for action in menu.actions():
        s = munge(action.text())
        s = s.split('\t')[0]
        if s == realName:
            action.setText(realLabel)
            break
#@-node:ekr.20081121105001.377:setMenuLabel
#@+node:ekr.20090614134853.3813:setTag
def setTag (self,tag,s,i,j):

    trace = False and not g.unitTesting

    if i == j:
        if trace: g.trace('empty range')
        return

    w = self.w
    colorName = w.configDict.get(tag)

    # Munge the color name.
    if not colorName:
        if trace: g.trace('no color for %s' % tag)
        return

    if colorName[-1].isdigit() and colorName[0] != '#':
        colorName = colorName[:-1]

    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name',colorName)

    underline = w.configUnderlineDict.get(tag)

    format = QtGui.QTextCharFormat()

    font = self.fonts.get(tag)
    if font:
        format.setFont(font)

    if trace:
        self.tagCount += 1
        g.trace(
            '%3s %3s %3s %9s %7s' % (i,j,len(s),font and id(font) or '<no font>',colorName),
            '%-10s %-25s' % (tag,s[i:j])) # ,g.callers(4))

    if tag in ('blank','tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setFontUnderline(True)
    else:
        format.setForeground(color)

    self.highlighter.setFormat (i,j-i,format)

#@-node:ekr.20090614134853.3813:setTag
#@-node:ekr.20100102100353.3668:Show invisibles
#@-node:ekr.20100201113707.3728:Leo 4.7 b3 projects
#@+node:ekr.20100202160247.3681:Leo 4.7 rc1 projects
#@+node:ekr.20100127124405.3701:The unicode bug
#@+node:ekr.20100109082023.3734:leoMoveCursorHelper (Qt)
def leoMoveCursorHelper (self,kind,extend=False,linesPerPage=15):

    '''Move the cursor in a QTextEdit.'''

    trace = False and not g.unitTesting
    verbose = True
    w = self.widget
    if trace:
        g.trace(kind,'extend',extend)
        if verbose:
            g.trace(len(w.toPlainText()))

    tc = QtGui.QTextCursor
    d = {
        'exchange': True, # Dummy.
        'down':tc.Down,'end':tc.End,'end-line':tc.EndOfLine,
        'home':tc.Start,'left':tc.Left,'page-down':tc.Down,
        'page-up':tc.Up,'right':tc.Right,'start-line':tc.StartOfLine,
        'up':tc.Up,
    }
    kind = kind.lower()
    op = d.get(kind)
    mode = g.choose(extend,tc.KeepAnchor,tc.MoveAnchor)

    if not op:
        return g.trace('can not happen: bad kind: %s' % kind)

    if kind in ('page-down','page-up'):
        cursor = w.textCursor()
        cursor.movePosition(op,mode,linesPerPage)
        w.setTextCursor(cursor)
    elif kind == 'exchange': # exchange-point-and-mark
        cursor = w.textCursor()
        anchor = cursor.anchor()
        pos = cursor.position()
        cursor.setPosition(pos,tc.MoveAnchor)
        cursor.setPosition(anchor,tc.KeepAnchor)
        w.setTextCursor(cursor)
    else:
        if not extend:
            # Fix an annoyance. Make sure to clear the selection.
            cursor = w.textCursor()
            cursor.clearSelection()
            w.setTextCursor(cursor)
        w.moveCursor(op,mode)
#@-node:ekr.20100109082023.3734:leoMoveCursorHelper (Qt)
#@+node:ekr.20081121105001.589:setSelectionRangeHelper & helper
def setSelectionRangeHelper(self,i,j,insert):

    trace = False and not g.unitTesting
    w = self.widget
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)

    n = self.lengthHelper()
    i = max(0,min(i,n))
    j = max(0,min(j,n))
    if insert is None:
        ins = max(i,j)
    else:
        ins = self.toPythonIndex(insert)
        ins = max(0,min(ins,n))

    if trace:g.trace('i',i,'j',j,'insert',insert)

    # 2010/02/02: Use only tc.setPosition here.
    # Using tc.movePosition doesn't work.
    tc = w.textCursor()
    if i == j:
        tc.setPosition(i)
    elif ins == j:
        # Put the insert point at j
        tc.setPosition(i)
        tc.setPosition(j,tc.KeepAnchor)
    else:
        # Put the insert point a i
        tc.setPosition(j)
        tc.setPosition(i,tc.KeepAnchor)

    w.setTextCursor(tc)
#@+node:ekr.20081121105001.590:lengthHelper
def lengthHelper(self):

    '''Return the length of the text.'''

    w = self.widget
    tc = w.textCursor()
    tc.movePosition(QtGui.QTextCursor.End)
    n = tc.position()
    return n

#@-node:ekr.20081121105001.590:lengthHelper
#@-node:ekr.20081121105001.589:setSelectionRangeHelper & helper
#@-node:ekr.20100127124405.3701:The unicode bug
#@-node:ekr.20100202160247.3681:Leo 4.7 rc1 projects
#@-all
#@nonl
#@-node:ekr.20081121105001.147:@thin qtNotes.txt
#@-leo
