<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="40" left="210" height="800" width="907"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240" str_leo_pos="2"><vh>Startup</vh>
<v t="ekr.20080312060129.5"><vh>Buttons</vh>
<v t="ekr.20070628175250"><vh>@@button Add if g.unitTesting @key=f6</vh></v>
<v t="ekr.20071004062031"><vh>@@button print -----</vh></v>
<v t="ekr.20071001054335"><vh>@@button split-defs</vh></v>
<v t="ekr.20080121091513"><vh>@@button parse2tree</vh></v>
<v t="ekr.20080220082617"><vh>@@button print g.es stats</vh>
<v t="ekr.20080220082617.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20080220082617.2"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20080220082617.3"><vh> ctor</vh></v>
<v t="ekr.20080220082617.4"><vh>error &amp; trace</vh></v>
<v t="ekr.20080220082617.5"><vh>main</vh></v>
<v t="ekr.20080221101728"><vh>munging...</vh>
<v t="ekr.20080221071308"><vh>mungeString</vh></v>
<v t="ekr.20080220093930"><vh>mungeHeadline</vh></v>
<v t="ekr.20080221073909"><vh>mungeStatements</vh></v>
<v t="ekr.20080221101728.1"><vh>stringize</vh></v>
</v>
<v t="ekr.20080220082617.6"><vh>scan &amp; helpers</vh>
<v t="ekr.20080220182141"><vh>scanIdChain</vh></v>
<v t="ekr.20080220082617.9"><vh>scanNode</vh>
<v t="ekr.20080221071734"><vh>&lt;&lt; insert statements highlighting the @thin node &gt;&gt;</vh></v>
<v t="ekr.20080221071734.1"><vh>&lt;&lt; Insert a comment containing the headline &gt;&gt;</vh></v>
</v>
<v t="ekr.20080220082617.8"><vh>scanParens</vh></v>
<v t="ekr.20080220183819"><vh>scanStringArg</vh></v>
</v>
<v t="ekr.20080220082617.10"><vh>setDecl</vh></v>
<v t="ekr.20080221110301"><vh>setToBeTranslated</vh></v>
</v>
<v t="ekr.20060910141935"><vh>ZODB plugin buttons</vh>
<v t="ekr.20060910141935.1"><vh>@@button zodb-read</vh></v>
<v t="ekr.20060910141935.2"><vh>@@button zodb-write</vh></v>
</v>
</v>
<v t="ekr.20080312060129.6"><vh>Commands</vh>
<v t="ekr.20060531093331"><vh>@@command clones-tab</vh>
<v t="ekr.20060531093331.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060531093331.2"><vh>init</vh></v>
<v t="ekr.20060531093331.3"><vh>getAllClones</vh></v>
<v t="ekr.20060531093331.4"><vh>displayClones</vh>
<v t="ekr.20060531093331.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060531093331.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20071024180738"><vh>@@command ext-unit-test @key=Alt+6</vh></v>
<v t="ekr.20071024171346"><vh>@@command unit-test @key=Alt+4</vh></v>
</v>
<v t="ekr.20070605104410"><vh>@chapters</vh></v>
<v t="ekr.20080121092503"><vh>Scripts</vh>
<v t="ekr.20080121090750"><vh>create-at-auto-nodes</vh></v>
</v>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20080412053100.4"><vh>@bool fixedWindow = False</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20060217111834"><vh>@url http://docs.python.org/lib/re-syntax.html</vh></v>
<v t="ekr.20060908104329"><vh>@url file:c:/prog/tigris-cvs/leo/doc/leoDocs.leo#Users Guide</vh></v>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933" annotate="7d71002855046e6f6465710155007102550262677103680255087072696f72697479710455043939393971055502666771066802550870726f677265737371076802550961726368657479706571086802752e"
marks="ekr.20060417194232.2,ekr.20080416161551.103,ekr.20031218072017.3425,"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"
marks="ekr.20080404074921.2,"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20040629121554.1" a="M"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@thin leoBridge.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@thin leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.1,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719"
marks="ekr.20060417194232.2,"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3320"
marks="ekr.20031218072017.3425,ekr.20080416161551.196,"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@thin leoPymacs.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="285808000000616e6e6f7461746571007d71017471022e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
<v t="ekr.20080112145409"><vh>Gui gtk classes</vh>
<v t="ekr.20080112145409.1"><vh>@thin leoGtkDialog.py</vh></v>
<v t="ekr.20080112173119"><vh>@thin leoGtkFind.py</vh></v>
<v t="ekr.20080112145409.53"><vh>@thin leoGtkFrame.py</vh></v>
<v t="ekr.20080112145409.435"><vh>@thin leoGtkGui.py</vh></v>
<v t="ekr.20080112171650"><vh>@thin leoGtkKeys.py</vh></v>
<v t="ekr.20080112171213"><vh>@thin leoGtkMenu.py</vh></v>
<v t="ekr.20080112170946"><vh>@thin leoGtkTree.py</vh></v>
</v>
</v>
<v t="ekr.20080416161308.1"><vh>This is the graph world</vh>
<v t="ekr.20080416161551.189"><vh>To do</vh></v>
<v t="ekr.20080417064246.1"><vh>What I did</vh></v>
<v t="ekr.20080416161551.1"><vh>From unified-node world: leoNodes.py</vh>
<v t="ekr.20080416161551.2"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20080416161551.3"><vh>class nodeIndices</vh>
<v t="ekr.20080416161551.4"><vh>nodeIndices.__init__</vh></v>
<v t="ekr.20080416161551.5"><vh>areEqual</vh></v>
<v t="ekr.20080416161551.6"><vh>get/setDefaultId</vh></v>
<v t="ekr.20080416161551.7"><vh>getNewIndex</vh></v>
<v t="ekr.20080416161551.8"><vh>isGnx</vh></v>
<v t="ekr.20080416161551.9"><vh>scanGnx</vh></v>
<v t="ekr.20080416161551.10"><vh>setTimeStamp</vh></v>
<v t="ekr.20080416161551.11"><vh>toString</vh></v>
</v>
<v t="ekr.20080416161551.12"><vh>class node (should be ok)</vh>
<v t="ekr.20080416161551.13"><vh>&lt;&lt; node constants &gt;&gt;</vh></v>
<v t="ekr.20080416161551.14"><vh>Birth &amp; death (test)</vh>
<v t="ekr.20080416161551.15"><vh>node.__init__</vh></v>
<v t="ekr.20080416161551.16"><vh>node.__hash__ (only for zodb)</vh></v>
<v t="ekr.20080416161551.17"><vh>node.__repr__ &amp; node.__str__</vh></v>
<v t="ekr.20080416161551.18"><vh>node.dump</vh></v>
</v>
<v t="ekr.20080416161551.19"><vh>v.Node Comparisons (no change)</vh>
<v t="ekr.20080416161551.20"><vh>findAtFileName</vh></v>
<v t="ekr.20080416161551.21"><vh>anyAtFileNodeName</vh></v>
<v t="ekr.20080416161551.22"><vh>at...FileNodeName</vh></v>
<v t="ekr.20080416161551.23"><vh>isAtAllNode</vh></v>
<v t="ekr.20080416161551.24"><vh>isAnyAtFileNode</vh></v>
<v t="ekr.20080416161551.25"><vh>isAt...FileNode (vnode)</vh></v>
<v t="ekr.20080416161551.26"><vh>isAtIgnoreNode</vh></v>
<v t="ekr.20080416161551.27"><vh>isAtOthersNode</vh></v>
<v t="ekr.20080416161551.28"><vh>matchHeadline</vh></v>
</v>
<v t="ekr.20080416161551.29"><vh>v.Node Getters (test)</vh>
<v t="ekr.20080416161551.30"><vh>v.Children (test)</vh>
<v t="ekr.20080416161551.31"><vh>v.firstChild</vh></v>
<v t="ekr.20080416161551.32"><vh>v.hasChildren &amp; hasFirstChild</vh></v>
<v t="ekr.20080416161551.33"><vh>v.lastChild</vh></v>
<v t="ekr.20080416161551.34"><vh>v.nthChild</vh></v>
<v t="ekr.20080416161551.35"><vh>v.numberOfChildren (n)</vh></v>
</v>
<v t="ekr.20080416161551.36"><vh>Status Bits</vh>
<v t="ekr.20080416161551.37"><vh>isCloned (test)</vh></v>
<v t="ekr.20080416161551.38"><vh>isDirty</vh></v>
<v t="ekr.20080416161551.39"><vh>isExpanded</vh></v>
<v t="ekr.20080416161551.40"><vh>isMarked</vh></v>
<v t="ekr.20080416161551.41"><vh>isOrphan</vh></v>
<v t="ekr.20080416161551.42"><vh>isRichTextBit</vh></v>
<v t="ekr.20080416161551.43"><vh>isSelected</vh></v>
<v t="ekr.20080416161551.44"><vh>isTopBitSet</vh></v>
<v t="ekr.20080416161551.45"><vh>isVisited</vh></v>
<v t="ekr.20080416161551.46"><vh>isWriteBit</vh></v>
<v t="ekr.20080416161551.47"><vh>status</vh></v>
</v>
<v t="ekr.20080416161551.48"><vh>bodyString</vh></v>
<v t="ekr.20080416161551.49"><vh>hasBody</vh></v>
<v t="ekr.20080416161551.50"><vh>headString &amp; cleanHeadString</vh></v>
<v t="ekr.20080416161551.51"><vh>v.directParents (test)</vh></v>
</v>
<v t="ekr.20080416161551.52"><vh>v.Node Setters (test)</vh>
<v t="ekr.20080416161551.53"><vh>Setting body and headline text</vh>
<v t="ekr.20080416161551.54"><vh>setBodyString and setTnodeText</vh></v>
<v t="ekr.20080416161551.55"><vh>setHeadString and initHeadString</vh></v>
<v t="ekr.20080416161551.56"><vh>setSelection</vh></v>
</v>
<v t="ekr.20080416161551.57"><vh>Status bits</vh>
<v t="ekr.20080416161551.58"><vh>clearClonedBit (not used)</vh></v>
<v t="ekr.20080416161551.59"><vh>clearDirty</vh></v>
<v t="ekr.20080416161551.60"><vh>clearMarked</vh></v>
<v t="ekr.20080416161551.61"><vh>clearOrphan</vh></v>
<v t="ekr.20080416161551.62"><vh>clearRichTextBit</vh></v>
<v t="ekr.20080416161551.63"><vh>clearVisited</vh></v>
<v t="ekr.20080416161551.64"><vh>clearWriteBit</vh></v>
<v t="ekr.20080416161551.65"><vh>contract &amp; expand &amp; initExpandedBit</vh></v>
<v t="ekr.20080416161551.66"><vh>initStatus</vh></v>
<v t="ekr.20080416161551.67"><vh>setClonedBit &amp; initClonedBit (not used)</vh></v>
<v t="ekr.20080416161551.68"><vh>setDirty</vh></v>
<v t="ekr.20080416161551.69"><vh>setMarked &amp; initMarkedBit</vh></v>
<v t="ekr.20080416161551.70"><vh>setOrphan</vh></v>
<v t="ekr.20080416161551.71"><vh>setRichTextBit</vh></v>
<v t="ekr.20080416161551.72"><vh>setSelected (vnode)</vh></v>
<v t="ekr.20080416161551.73"><vh>setVisited</vh></v>
<v t="ekr.20080416161551.74"><vh>setWriteBit</vh></v>
</v>
<v t="ekr.20080416161551.75"><vh>setCloneIndex (used in 3.x)</vh></v>
<v t="ekr.20080416161551.76"><vh>setFileIndex</vh></v>
<v t="ekr.20080416161551.77"><vh>computeIcon &amp; setIcon</vh></v>
</v>
</v>
<v t="ekr.20080416161551.78"><vh>class position (test)</vh>
<v t="ekr.20080416161551.79"><vh> ctor &amp; other special methods... (test)</vh>
<v t="ekr.20080416161551.80"><vh> p.__init__</vh></v>
<v t="ekr.20080416161551.81"><vh>p.__cmp__, equal and isEqual</vh></v>
<v t="ekr.20080416161551.82"><vh>p.__nonzero__</vh></v>
<v t="ekr.20080416161551.83"><vh>p.__str__ and p.__repr__</vh></v>
<v t="ekr.20080416161551.84"><vh>p.archivedPosition</vh></v>
<v t="ekr.20080416161551.85"><vh>p.copy</vh></v>
<v t="ekr.20080416161551.86"><vh>p.dump &amp; p.vnodeListIds</vh></v>
<v t="ekr.20080416161551.87"><vh>p.key</vh></v>
</v>
<v t="ekr.20080416161551.88"><vh>Getters (position) (test)</vh>
<v t="ekr.20080416161551.89"><vh> node proxies (no change)</vh>
<v t="ekr.20080416161551.90"><vh>p.Comparisons</vh></v>
<v t="ekr.20080416161551.91"><vh>p.Headline &amp; body strings</vh></v>
<v t="ekr.20080416161551.92"><vh>p.Status bits</vh></v>
<v t="ekr.20080416161551.93"><vh>p.directParents (test)</vh></v>
</v>
<v t="ekr.20080416161551.94"><vh>p.childIndex</vh></v>
<v t="ekr.20080416161551.95"><vh>p.numberOfChildren &amp; hasChildren (test)</vh></v>
<v t="ekr.20080416161551.96"><vh>p.getX &amp; vnode compatibility traversal routines (no change)</vh></v>
<v t="ekr.20080416161551.97"><vh>p.hasX (test)</vh>
<v t="ekr.20080416161551.98"><vh>hasThreadNext (the only complex hasX method)</vh></v>
</v>
<v t="ekr.20080416161551.99"><vh>p.findRootPosition (no change)</vh></v>
<v t="ekr.20080416161551.100"><vh>p.isAncestorOf (test)</vh></v>
<v t="ekr.20080416161551.101"><vh>p.isCloned (test)</vh></v>
<v t="ekr.20080416161551.102"><vh>p.isRoot (no change)</vh></v>
<v t="ekr.20080416161551.103" a="M"><vh>p.isVisible  (test)</vh></v>
<v t="ekr.20080416161551.104"><vh>p.level &amp; simpleLevel</vh></v>
</v>
<v t="ekr.20080416161551.105"><vh>Setters (test)</vh>
<v t="ekr.20080416161551.106"><vh>p.Node proxies (no change)</vh>
<v t="ekr.20080416161551.107"><vh> Status bits (position)</vh></v>
<v t="ekr.20080416161551.108"><vh>p.computeIcon &amp; p.setIcon</vh></v>
<v t="ekr.20080416161551.109"><vh>p.setSelection</vh></v>
<v t="ekr.20080416161551.110"><vh>p.setTnodeText</vh></v>
</v>
<v t="ekr.20080416161551.111"><vh>p.Head &amp; body text (test)</vh>
<v t="ekr.20080416161551.112"><vh>p.setHeadString &amp; p.initHeadString</vh></v>
<v t="ekr.20080416161551.113"><vh>p.scriptSetBodyString</vh></v>
</v>
<v t="ekr.20080416161551.114"><vh>p.Visited bits (test)</vh>
<v t="ekr.20080416161551.115"><vh>p.clearVisitedInTree</vh></v>
<v t="ekr.20080416161551.116"><vh>p.clearAllVisitedInTree</vh></v>
</v>
<v t="ekr.20080416161551.117"><vh>p.Dirty bits (test)</vh>
<v t="ekr.20080416161551.118"><vh>p.clearDirty</vh></v>
<v t="ekr.20080416161551.119"><vh>p.findAllPotentiallyDirtyNodes (Test: changed vnodeList to parents)</vh></v>
<v t="ekr.20080416161551.120"><vh>p.inAtIgnoreRange (no change)</vh></v>
<v t="ekr.20080416161551.121"><vh>p.setAllAncestorAtFileNodesDirty (no change)</vh></v>
<v t="ekr.20080416161551.122"><vh>p.setDirty (test)</vh></v>
</v>
</v>
<v t="ekr.20080416161551.123"><vh>File Conversion (no change)</vh>
<v t="ekr.20080416161551.124"><vh>convertTreeToString</vh></v>
<v t="ekr.20080416161551.125"><vh>moreHead</vh></v>
<v t="ekr.20080416161551.126"><vh>moreBody</vh></v>
</v>
<v t="ekr.20080416161551.127"><vh>p.Iterators (no real change)</vh>
<v t="ekr.20080416161551.128"><vh>p.tnodes_iter</vh>
<v t="ekr.20080416161551.129"><vh>__init__ &amp; __iter__ (p.tnodes_iter)</vh></v>
<v t="ekr.20080416161551.130"><vh>next</vh></v>
</v>
<v t="ekr.20080416161551.131"><vh>p.unique_tnodes_iter</vh>
<v t="ekr.20080416161551.132"><vh>__init__ &amp; __iter__ (p.unique_tnodes_iter)</vh></v>
<v t="ekr.20080416161551.133"><vh>next</vh></v>
</v>
<v t="ekr.20080416161551.134"><vh>p.vnodes_iter</vh>
<v t="ekr.20080416161551.135"><vh>__init__ &amp; __iter__ (p.tnodes_iter)</vh></v>
<v t="ekr.20080416161551.136"><vh>next</vh></v>
</v>
<v t="ekr.20080416161551.137"><vh>p.unique_vnodes_iter</vh>
<v t="ekr.20080416161551.138"><vh>__init__ &amp; __iter__ (p.unique_vnodes_iter)</vh></v>
<v t="ekr.20080416161551.139"><vh>next</vh></v>
</v>
<v t="ekr.20080416161551.140"><vh>p.subtree_iter</vh>
<v t="ekr.20080416161551.141"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20080416161551.142"><vh>next</vh></v>
</v>
<v t="ekr.20080416161551.143"><vh>p.children_iter</vh>
<v t="ekr.20080416161551.144"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20080416161551.145"><vh>next</vh></v>
</v>
<v t="ekr.20080416161551.146"><vh>p.parents_iter</vh>
<v t="ekr.20080416161551.147"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20080416161551.148"><vh>next</vh></v>
</v>
<v t="ekr.20080416161551.149"><vh>p.siblings_iter</vh>
<v t="ekr.20080416161551.150"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20080416161551.151"><vh>next</vh></v>
</v>
</v>
<v t="ekr.20080416161551.152"><vh>p.Moving, Inserting, Deleting, Cloning, Sorting (test)</vh>
<v t="ekr.20080416161551.153"><vh>p.clone (test)</vh></v>
<v t="ekr.20080416161551.154"><vh>p.copyTreeAfter, copyTreeTo (no change)</vh></v>
<v t="ekr.20080416161551.155"><vh>p.doDelete (no change)</vh></v>
<v t="ekr.20080416161551.156"><vh>p.insertAfter (test)</vh></v>
<v t="ekr.20080416161551.157"><vh>p.insertAsLastChild (test)</vh></v>
<v t="ekr.20080416161551.158"><vh>p.insertAsNthChild (test)</vh></v>
<v t="ekr.20080416161551.159"><vh>p.invalidOutline (huh??)</vh></v>
<v t="ekr.20080416161551.160"><vh>p.moveAfter (no change)</vh></v>
<v t="ekr.20080416161551.161"><vh>p.moveToFirst/LastChildOf (no change)</vh></v>
<v t="ekr.20080416161551.162"><vh>p.moveToNthChildOf (no change)</vh></v>
<v t="ekr.20080416161551.163"><vh>p.moveToRoot (no change)</vh></v>
<v t="ekr.20080416161551.164"><vh>p.validateOutlineWithParent (test)</vh>
<v t="ekr.20080416161551.165"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="ekr.20080416161551.166"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20080416161551.167"><vh>p.moveToX (test)</vh>
<v t="ekr.20080416161551.168"><vh>p.moveToBack (test)</vh></v>
<v t="ekr.20080416161551.169"><vh>p.moveToFirstChild (pushes stack) (test)</vh></v>
<v t="ekr.20080416161551.170"><vh>p.moveToLastChild (pushes stack) (test)</vh></v>
<v t="ekr.20080416161551.171"><vh>p.moveToLastNode (no change)</vh></v>
<v t="ekr.20080416161551.172"><vh>p.moveToNext (test)</vh></v>
<v t="ekr.20080416161551.173"><vh>p.moveToNodeAfterTree (no change)</vh></v>
<v t="ekr.20080416161551.174"><vh>p.moveToNthChild (pushes stack) (test)</vh></v>
<v t="ekr.20080416161551.175"><vh>p.moveToParent (pops stack) (test)</vh></v>
<v t="ekr.20080416161551.176"><vh>p.moveToThreadBack (no change)</vh></v>
<v t="ekr.20080416161551.177"><vh>p.moveToThreadNext (test)</vh></v>
<v t="ekr.20080416161551.178"><vh>p.moveToVisBack (no change)</vh></v>
<v t="ekr.20080416161551.179"><vh>p.moveToVisNext (no change)</vh></v>
</v>
<v t="ekr.20080416161551.180"><vh>p.parentNode (New, test)</vh></v>
<v t="ekr.20080416161551.181"><vh>p.Link/Unlink methods (test)</vh>
<v t="ekr.20080416161551.182"><vh>p.linkAfter (test)</vh></v>
<v t="ekr.20080416161551.183"><vh>p.linkAsNthChild (test)</vh></v>
<v t="ekr.20080416161551.184"><vh>p.linkAsRoot (test)</vh></v>
<v t="ekr.20080416161551.185"><vh>p.unlink (test)</vh></v>
</v>
</v>
</v>
<v t="ekr.20080416161551.223"><vh>Uses v._parent</vh>
<v t="ekr.20060919110638.7"><vh>createSaxVnode (uses v._parent)</vh>
<v t="ekr.20060919110638.8"><vh>handleTnodeSaxAttributes</vh></v>
<v t="ekr.20061004053644"><vh>handleVnodeSaxAttributes</vh></v>
</v>
<v t="ekr.20060919110638.9"><vh>linkParentAndChildren (uses v._parent)</vh></v>
<v t="EKR.20040530121329"><vh>u.restoreTree &amp; helpers (uses v._parent)</vh>
<v t="ekr.20050415170737.2"><vh>restoreVnodeUndoInfo</vh></v>
<v t="ekr.20050415170812.2"><vh>restoreTnodeUndoInfo</vh></v>
</v>
<v t="EKR.20040528075307"><vh>u.saveTree &amp; helpers (uses v._parent)</vh>
<v t="EKR.20040530114124"><vh>&lt;&lt; about u.saveTree &gt;&gt;</vh></v>
<v t="ekr.20050415170737.1"><vh>createVnodeUndoInfo</vh></v>
<v t="ekr.20050415170812.1"><vh>createTnodeUndoInfo</vh></v>
</v>
</v>
<v t="ekr.20080416161551.225"><vh>Uses t._firstChild</vh>
<v t="ekr.20041005105605.127"><vh>readError</vh></v>
<v t="ekr.20040323162707"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20050415170812.2"><vh>restoreTnodeUndoInfo</vh></v>
<v t="ekr.20050415170812.1"><vh>createTnodeUndoInfo</vh></v>
</v>
<v t="ekr.20080417064246.2"><vh>Recent</vh>
<v t="ekr.20031218072017.2812"><vh>c.__init__</vh></v>
<v t="ekr.20080416161551.199"><vh>p.moveToX (test)</vh>
<v t="ekr.20080416161551.200"><vh>p.moveToBack (test)</vh></v>
<v t="ekr.20080416161551.201"><vh>p.moveToFirstChild (pushes stack) (test)</vh></v>
<v t="ekr.20080416161551.202"><vh>p.moveToLastChild (pushes stack) (test)</vh></v>
<v t="ekr.20080416161551.203"><vh>p.moveToLastNode (no change)</vh></v>
<v t="ekr.20080416161551.204"><vh>p.moveToNext (test)</vh></v>
<v t="ekr.20080416161551.205"><vh>p.moveToNodeAfterTree (no change)</vh></v>
<v t="ekr.20080416161551.206"><vh>p.moveToNthChild (pushes stack) (test)</vh></v>
<v t="ekr.20080416161551.207"><vh>p.moveToParent (pops stack) (test)</vh></v>
<v t="ekr.20080416161551.208"><vh>p.moveToThreadBack (no change)</vh></v>
<v t="ekr.20080416161551.209"><vh>p.moveToThreadNext (test)</vh></v>
<v t="ekr.20080416161551.210"><vh>p.moveToVisBack (no change)</vh></v>
<v t="ekr.20080416161551.211"><vh>p.moveToVisNext (no change)</vh></v>
</v>
<v t="ekr.20041117093246"><vh>Scanning @settings (g.app.config)</vh>
<v t="ekr.20041120064303"><vh>g.app.config.readSettingsFiles &amp; helpers</vh>
<v t="ekr.20061028082834"><vh>&lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;</vh></v>
<v t="ekr.20041117085625"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20051013161232"><vh>g.app.config.updateSettings</vh></v>
</v>
<v t="ekr.20041117083857.1"><vh>g.app.config.readSettings</vh></v>
</v>
<v t="ekr.20041120074536"><vh>settingsRoot</vh></v>
<v t="ekr.20080416161551.207"><vh>p.moveToParent (pops stack) (test)</vh></v>
<v t="ekr.20060919104530"><vh>Sax (reading)</vh>
<v t="ekr.20060919110638.4"><vh>createSaxVnodes &amp; helpers</vh>
<v t="ekr.20060919110638.5"><vh>createSaxChildren</vh></v>
<v t="ekr.20060919110638.6"><vh>createSaxVnodeTree</vh></v>
<v t="ekr.20060919110638.7"><vh>createSaxVnode (uses v._parent)</vh>
<v t="ekr.20060919110638.8"><vh>handleTnodeSaxAttributes</vh></v>
<v t="ekr.20061004053644"><vh>handleVnodeSaxAttributes</vh></v>
</v>
<v t="ekr.20060919110638.9"><vh>linkParentAndChildren (uses v._parent)</vh></v>
<v t="ekr.20060919110638.10"><vh>linkSiblings</vh></v>
</v>
<v t="ekr.20060919110638.2"><vh>dumpSaxTree</vh></v>
<v t="ekr.20061003093021"><vh>getSaxUa</vh></v>
<v t="ekr.20060919110638.14"><vh>parse_leo_file</vh></v>
<v t="ekr.20060919110638.3"><vh>readSaxFile</vh></v>
<v t="ekr.20060919110638.11"><vh>resolveTnodeLists</vh></v>
<v t="ekr.20060919110638.13"><vh>setPositionsFromVnodes &amp; helper</vh>
<v t="ekr.20061006104837.1"><vh>archivedPositionToPosition</vh></v>
</v>
</v>
<v t="ekr.20060919110638.3"><vh>readSaxFile</vh></v>
<v t="ekr.20060919110638.4"><vh>createSaxVnodes &amp; helpers</vh>
<v t="ekr.20060919110638.5"><vh>createSaxChildren</vh></v>
<v t="ekr.20060919110638.6"><vh>createSaxVnodeTree</vh></v>
<v t="ekr.20060919110638.7"><vh>createSaxVnode (uses v._parent)</vh>
<v t="ekr.20060919110638.8"><vh>handleTnodeSaxAttributes</vh></v>
<v t="ekr.20061004053644"><vh>handleVnodeSaxAttributes</vh></v>
</v>
<v t="ekr.20060919110638.9"><vh>linkParentAndChildren (uses v._parent)</vh></v>
<v t="ekr.20060919110638.10"><vh>linkSiblings</vh></v>
</v>
<v t="ekr.20041005105605.72"><vh>createThinChild4</vh></v>
</v>
<v t="ekr.20080417100013.1"><vh>recent 2</vh>
<v t="ekr.20040228094013.1"><vh>p.utils... (test)</vh>
<v t="ekr.20080416161551.212"><vh>p.parentNode (New, test)</vh></v>
<v t="ekr.20040409203454"><vh>p.restoreLinksInTree (no change)</vh></v>
<v t="ekr.20040409203454.1"><vh>p.deleteLinksInTree &amp; allies (????)</vh>
<v t="ekr.20040410170806"><vh>p.deleteLinksInSubtree</vh></v>
<v t="ekr.20040410170806.1"><vh>p.adjustParentLinksInSubtree</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1565"><vh>getVnodes</vh>
<v t="ekr.20041023105832"><vh>&lt;&lt; set self.forbiddenTnodes to tnodes than must not be pasted &gt;&gt;</vh></v>
</v>
<v t="ekr.20040301071824"><vh>v.Link/Unlink/Insert methods (used by file read logic)</vh>
<v t="ekr.20031218072017.3421"><vh>v.insertAsNthChild (used by 3.x read logic)</vh></v>
<v t="ekr.20031218072017.3425" a="M"><vh>v.linkAsNthChild (used by 4.x read logic)</vh></v>
</v>
<v t="ekr.20040303175026.6"><vh>p.moveToRoot</vh></v>
<v t="ekr.20080416161551.216"><vh>p.linkAsRoot (test)</vh></v>
</v>
<v t="ekr.20080416161551.187"><vh>Unused</vh>
<v t="ekr.20080416161551.188"><vh>From position class</vh>
<v t="ekr.20031218072017.893"><vh>p.__cmp__</vh></v>
<v t="ekr.20040325142015"><vh>p.equal &amp; isEqual</vh></v>
<v t="ekr.20031218072017.892"><vh>p.__init__</vh></v>
<v t="ekr.20060202090907"><vh>p.key</vh></v>
<v t="ekr.20040227212621"><vh>p.hasX</vh>
<v t="ekr.20040227224946"><vh>hasThreadNext (the only complex hasX method)</vh></v>
</v>
<v t="ekr.20040307104131.1"><vh>p.isAncestorOf</vh></v>
<v t="ekr.20040117162509.16"><vh>p.isVisible</vh></v>
<v t="ekr.20040227214711"><vh>p.level &amp; simpleLevel</vh></v>
<v t="ekr.20031218072017.928"><vh>p.moveToX</vh>
<v t="ekr.20031218072017.930"><vh>p.moveToBack</vh></v>
<v t="ekr.20031218072017.931"><vh>p.moveToFirstChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.932"><vh>p.moveToLastChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.933"><vh>p.moveToLastNode (Big improvement for 4.2)</vh></v>
<v t="ekr.20031218072017.934"><vh>p.moveToNext</vh></v>
<v t="ekr.20031218072017.935"><vh>p.moveToNodeAfterTree</vh></v>
<v t="ekr.20031218072017.936"><vh>p.moveToNthChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.937"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
<v t="ekr.20031218072017.938"><vh>p.moveToThreadBack</vh></v>
<v t="ekr.20031218072017.939"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20031218072017.940"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20031218072017.941"><vh>p.moveToVisNext</vh></v>
</v>
<v t="ekr.20040228060340"><vh>p.vParentWithStack</vh>
<v t="ekr.20040228060340.1"><vh>&lt;&lt; about the vParentWithStack utility method &gt;&gt;</vh></v>
</v>
<v t="ekr.20040310062332"><vh>p.Link/Unlink methods</vh>
<v t="ekr.20040310062332.2"><vh>p.linkAfter</vh></v>
<v t="ekr.20040310062332.3"><vh>p.linkAsNthChild</vh></v>
<v t="ekr.20040310062332.4"><vh>p.linkAsRoot</vh></v>
<v t="ekr.20040310062332.5"><vh>p.unlink</vh></v>
</v>
</v>
<v t="ekr.20080416161551.224"><vh>From vnode class</vh>
<v t="ekr.20040303212445"><vh>v.childIndex</vh></v>
<v t="ekr.20040306214240"><vh>v.Tree Traversal getters</vh>
<v t="ekr.20031218072017.3406"><vh>v.back</vh></v>
<v t="ekr.20031218072017.3409"><vh>v.next</vh></v>
</v>
</v>
<v t="ekr.20080417064246.3"><vh>v.Link/Unlink methods (changed, unused)</vh>
<v t="ekr.20060913091805.1"><vh>v.detach</vh></v>
<v t="ekr.20031218072017.3419"><vh>v.insertAfter</vh></v>
<v t="ekr.20031218072017.2355"><vh>v.linkAfter</vh></v>
<v t="ekr.20031218072017.3426"><vh>v.linkAsRoot</vh></v>
<v t="ekr.20031218072017.3422"><vh>v.moveToRoot</vh></v>
<v t="ekr.20031218072017.3438"><vh>v.unlink</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="EKR.20040528075307">def saveTree (self,p,treeInfo=None):

    """Return a list of tuples with all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    &lt;&lt; about u.saveTree &gt;&gt;

    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v and p.v.t.  Duplicate tnode info is harmless.
    data = (p.v,u.createVnodeUndoInfo(p.v),u.createTnodeUndoInfo(p.v.t))
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
</t>
<t tx="EKR.20040530114124">@ 
The old code made a free-standing copy of the tree using v.copy and t.copy.  This looks "elegant" and is WRONG.  The problem is that it can not handle clones properly, especially when some clones were in the "undo" tree and some were not.   Moreover, it required complex adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed to properly restore the vnodes and tnodes.  It creates a list of tuples, on tuple for each vnode in the tree.  Each tuple has the form,

(vnodeInfo, tnodeInfo)

where vnodeInfo and tnodeInfo are dicts contain all info needed to recreate the nodes.  The v.createUndoInfoDict and t.createUndoInfoDict methods correspond to the old v.copy and t.copy methods.

Aside:  Prior to 4.2 Leo used a scheme that was equivalent to the createUndoInfoDict info, but quite a bit uglier.
</t>
<t tx="EKR.20040530121329">def restoreTree (self,treeInfo):

    """Use the tree info to restore all vnode and tnode data,
    including all links."""

    u = self

    # This effectively relinks all vnodes.
    for v,vInfo,tInfo in treeInfo:
        u.restoreVnodeUndoInfo(vInfo)
        u.restoreTnodeUndoInfo(tInfo)
</t>
<t tx="ekr.20031218072017.892"># New in Leo 4.4.2: make stack default to None.

def __init__ (self,v,stack=None,trace=True):

    """Create a new position."""

    # __pychecker__ = '--no-argsused' # trace not used.

    # To support ZODB the code must set vort._p_changed = 1 whenever
    # t.vnodeList (or any mutable tnode or vnode object) changes.

    self.v = v
    # assert(v is None or v.t)

    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []

    g.app.positions += 1

    # if g.app.tracePositions and trace: g.trace(g.callers())

    # Note: __getattr__ implements p.t.</t>
<t tx="ekr.20031218072017.893">def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self

    # g.trace(p1.headString(),p2 and p2.headString())

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal

    # Check entire stack quickly.
    # The stack contains vnodes, so this is not a recursive call.
    if p1.v != p2.v or p1.stack != p2.stack:
        return 1 # notEqual

    # This is slow: do this last!
    if p1.childIndex() != p2.childIndex():
        # Disambiguate clones having the same parents.
        return 1 # notEqual

    return 0 # equal
</t>
<t tx="ekr.20031218072017.928">@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()
</t>
<t tx="ekr.20031218072017.930">def moveToBack (self):

    """Move self to its previous sibling."""

    p = self

    p.v = p.v and p.v._back

    return p
</t>
<t tx="ekr.20031218072017.931">def moveToFirstChild (self):

    """Move a position to it's first child's position."""

    p = self

    if p:
        child = p.v.t._firstChild
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None

    return p

</t>
<t tx="ekr.20031218072017.932">def moveToLastChild (self):

    """Move a position to it's last child's position."""

    p = self

    if p:
        if p.v.t._firstChild:
            child = p.v.lastChild()
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None

    return p
</t>
<t tx="ekr.20031218072017.933">def moveToLastNode (self):

    """Move a position to last node of its tree.

    N.B. Returns p if p has no children."""

    p = self

    # Huge improvement for 4.2.
    while p.hasChildren():
        p.moveToLastChild()

    return p
</t>
<t tx="ekr.20031218072017.934">def moveToNext (self):

    """Move a position to its next sibling."""

    p = self

    p.v = p.v and p.v._next

    return p
</t>
<t tx="ekr.20031218072017.935">def moveToNodeAfterTree (self):

    """Move a position to the node after the position's tree."""

    p = self

    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
</t>
<t tx="ekr.20031218072017.936">def moveToNthChild (self,n):

    p = self

    if p:
        child = p.v.nthChild(n) # Must call vnode method here!
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None

    return p
</t>
<t tx="ekr.20031218072017.937">def moveToParent (self):

    """Move a position to its parent position."""

    p = self

    if not p: return p

    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
    else:
        p.v = None
    return p
</t>
<t tx="ekr.20031218072017.938">def moveToThreadBack (self):

    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
</t>
<t tx="ekr.20031218072017.939">def moveToThreadNext (self):

    """Move a position to threadNext position."""

    p = self

    if p:
        if p.v.t._firstChild:
            p.moveToFirstChild()
        elif p.v._next:
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.v._next:
                    p.moveToNext()
                    break #found
                p.moveToParent()
            # not found.

    return p
</t>
<t tx="ekr.20031218072017.940">def moveToVisBack (self,c):

    """Move a position to the position of the previous visible node."""

    p = self ; limit,limitIsVisible = c.visLimit() ; trace = False

    def checkLimit (p):
        '''Return done, return-val'''
        if limit:
            if limit == p:
                if trace: g.trace('at limit',p)
                return True,g.choose(limitIsVisible and p.isVisible(c),p,None)
            elif limit.isAncestorOf(p):
                return False,None
            else:
                if trace: g.trace('outside limit tree')
                return True,None
        else:
            return False,None

    while p:
        # Short-circuit if possible.
        back = p.back()
        if back and (not back.hasChildren() or not back.isExpanded()):
            p.moveToBack()
        else:
            p.moveToThreadBack()
        if p:
            if trace: g.trace('*p',p.headString())
            done,val = checkLimit(p)
            if done: return val
            if p.isVisible(c):
                return p
    else:
        # assert not p.
        return p</t>
<t tx="ekr.20031218072017.941">def moveToVisNext (self,c):

    """Move a position to the position of the next visible node."""

    p = self ; limit,limitIsVisible = c.visLimit() ; trace = False

    def checkLimit (p):
        '''Return done, return-val'''
        if limit:
            # Unlike moveToVisBack, being at the limit does not terminate.
            if limit == p:
                return False, None
            elif limit.isAncestorOf(p):
                return False,None
            else:
                if trace: g.trace('outside limit tree')
                return True,None
        else:
            return False,None

    while p:
        # Short-circuit if possible.
        if p.hasNext() and (not p.hasChildren() or not p.isExpanded()):
            p.moveToNext()
        else:
            p.moveToThreadNext()
        if p:
            if trace: g.trace('*p',p.headString())
            done,val = checkLimit(p)
            if done: return val
            if p.isVisible(c):
                return p.copy()
    else:
        # assert not p.
        return p</t>
<t tx="ekr.20031218072017.1565">def getVnodes (self,reassignIndices=True):

    c = self.c

    if self.getOpenTag("&lt;vnodes&gt;"):
        return # &lt;vnodes/&gt; seen.

    self.forbiddenTnodes = []
    back = parent = None # This routine _must_ work on vnodes!
    self.currentVnodeStack = []
    self.topVnodeStack = []

    if self.usingClipboard:
        oldRoot = c.rootPosition()
        oldCurrent = c.currentPosition()
        if not reassignIndices:
            &lt;&lt; set self.forbiddenTnodes to tnodes than must not be pasted &gt;&gt;

    while self.matchTag("&lt;v"):
        append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
        append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip=False,
            appendToCurrentStack=append1,appendToTopStack=append2)

    if self.usingClipboard and not self.checking:
        # Link in the pasted nodes after the current position.
        newRoot = c.rootPosition()
        c.setRootPosition(oldRoot)
        newRoot.v.linkAfter(oldCurrent.v)
        newCurrent = oldCurrent.copy()
        newCurrent.v = newRoot.v
        c.setCurrentPosition(newCurrent)

    self.getTag("&lt;/vnodes&gt;")
</t>
<t tx="ekr.20031218072017.2355"># def linkAfter (self,v):

    # """Link self after v."""

    # self._parent = v._parent
    # self._back = v
    # self._next = v._next
    # v._next = self
    # if self._next:
        # self._next._back = self
</t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode
z:  a local temp.</t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2812">def __init__(self,frame,fileName,relativeFileName=None):

    c = self

    # g.trace('Commands')
    self.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.

    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.chapterController = None
    self.frame = frame
    t = leoNodes.tnode()
    self.hiddenRootNode = leoNodes.vnode(context=c,t=t)
    self.hiddenRootNode.setHeadString('&lt;hidden root vnode&gt;')
    self.isZipped = False # May be set to True by g.openWithFileName.
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)
    self.mRelativeFileName = relativeFileName

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()
    self.nodeHistory = nodeHistory(c)

    self.contractVisitedNodes = c.config.getBool('contractVisitedNodes')
    self.useTextMinibuffer = c.config.getBool('useTextMinibuffer')
    self.showMinibuffer = c.config.getBool('useMinibuffer')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')
    self.fixed = c.config.getBool('fixedWindow',False)
        # New in Leo 4.5: True: Don't write window position, expansion states, marks, etc.
    self.fixedWindowPosition = c.config.getData('fixedWindowPosition')
    if self.fixedWindowPosition:
        try:
            w,h,l,t = self.fixedWindowPosition
            self.fixedWindowPosition = int(w),int(h),int(l),int(t)
        except Exception:
            g.es_print('bad @data fixedWindowPosition',repr(self.fixedWindowPosition),color='red')
    else:
        self.windowPosition = 500,700,50,50 # width,height,left,top.

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
</t>
<t tx="ekr.20031218072017.3406"># Compatibility routine for scripts

def back (self):

    return self._back
</t>
<t tx="ekr.20031218072017.3409"># Compatibility routine for scripts
# Used by p.findAllPotentiallyDirtyNodes.

def next (self):

    return self._next
</t>
<t tx="ekr.20031218072017.3419">def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    v = self

    if not t:
        t = tnode(headString="NewHeadline")

    v2 = vnode(context=v.context,t=t)
    v2.linkAfter(self)

    return v2
</t>
<t tx="ekr.20031218072017.3421">def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    v = self

    if not t:
        t = tnode(headString="NewHeadline")

    v2 = vnode(context=v.context,t=t)
    v2.linkAsNthChild(self,n)

    return v2
</t>
<t tx="ekr.20031218072017.3422">def moveToRoot (self,oldRoot=None):

    '''Moves a vnode to the root position.

    Important: oldRoot must the previous root vnode if it exists.'''

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)

    return v</t>
<t tx="ekr.20031218072017.3425">def linkAsNthChild (self,parent_v,n):

    """Links self as the n'th child of vnode pv"""

    # Similar to p.linkAsNthChild.

    v = self

     # Add v to it's tnode's vnodeList.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1 # Support for tnode class.

    # Add v to parent_v's children.
    parent_v.children.insert(n,v)
    parent_v._p_changed = 1

    # Add parent_v to v's parents.
    if not parent_v in v.parents:
        v.parents.append(parent_v)
        v._p_changed = 1

    # v = self
    # # g.trace(v,pv,n)
    # v._parent = pv
    # if n == 0:
        # v._back = None
        # v._next = pv.t._firstChild
        # if pv.t._firstChild:
            # pv.t._firstChild._back = v
        # pv.t._firstChild = v
    # else:
        # prev = pv.nthChild(n-1) # zero based
        # assert(prev)
        # v._back = prev
        # v._next = prev._next
        # prev._next = v
        # if v._next:
            # v._next._back = v
</t>
<t tx="ekr.20031218072017.3426">def linkAsRoot (self,oldRoot):

    """Link a vnode as the root node and set the root _position_."""

    v = self

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot

    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v</t>
<t tx="ekr.20031218072017.3438">def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20040117162509.16">def isVisible (self,c):

    """Return True if all of a position's parents are expanded."""

    # v.isVisible no longer exists.
    p = self ; cc = c.chapterController ; trace = False
    limit,limitIsVisible = c.visLimit()
    limit_v = limit and limit.v or None
    if p.v == limit_v:
        if trace: g.trace('*** at limit','limitIsVisible',limitIsVisible,p.v.headString())
        return limitIsVisible

    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1

    v,n = p.vParentWithStack(v,p.stack,n)
    while v:
        if v == limit_v:  # We are at a descendant of limit.
            if trace: g.trace('*** descendant of limit',
                'limitIsVisible',limitIsVisible,
                'limit.isExpanded()',limit.isExpanded(),'v',v)
            if limitIsVisible:
                return limit.isExpanded()
            else: # Ignore the expansion state of @chapter nodes.
                return True
        if not v.isExpanded():
            if trace: g.trace('*** non-limit parent is not expanded',v)
            return False
        v,n = p.vParentWithStack(v,p.stack,n)

    return True
</t>
<t tx="ekr.20040227212621">def hasBack(self):
    return self.v and self.v._back

hasFirstChild = hasChildren

def hasNext(self):
    return self.v and self.v._next

def hasParent(self):
    return self.v and self.v._parent is not None

def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
</t>
<t tx="ekr.20040227214711">def simpleLevel(self):

    return len([p for p in self.parents_iter()])

def level(self,verbose=False):

    p = self ; level = 0
    if not p: return level

    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1
    while 1:
        assert(p)
        v,n = p.vParentWithStack(v,p.stack,n)
        if v:
            level += 1
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        else:
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # if g.app.debug: assert(level==self.simpleLevel())
            break
    return level
</t>
<t tx="ekr.20040227224946">def hasThreadNext(self):

    p = self ; v = p.v
    if not p.v: return False

    if v.t._firstChild or v._next:
        return True
    else:
        n = len(p.stack)-1
        v,n = p.vParentWithStack(v,p.stack,n)
        while v:
            if v._next:
                return True
            v,n = p.vParentWithStack(v,p.stack,n)
        return False
</t>
<t tx="ekr.20040228060340"># A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

&lt;&lt; about the vParentWithStack utility method &gt;&gt;

def vParentWithStack(self,v,stack,n):

    """A utility that allows the computation of p.v without calling p.copy().

    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n &gt;= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n
</t>
<t tx="ekr.20040228060340.1">@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)
</t>
<t tx="ekr.20040228094013.1"></t>
<t tx="ekr.20040301071824"># These remain in 4.2: the file read logic calls these before creating positions.
</t>
<t tx="ekr.20040303175026.6">def moveToRoot (self,oldRoot=None):

    '''Moves a position to the root position.

    Important: oldRoot must the previous root position if it exists.'''

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsRoot(oldRoot)

    return p
</t>
<t tx="ekr.20040303212445">def childIndex(self):

    v = self

    if not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back
    return n
</t>
<t tx="ekr.20040306214240"></t>
<t tx="ekr.20040307104131.1">def isAncestorOf (self, p2):

    p = self

    if 0: # Avoid the copies made in the iterator.
        for p3 in p2.parents_iter():
            if p3 == p:
                return True

    # Avoid calling p.copy() or copying the stack.
    v2 = p2.v ; n = len(p2.stack)-1
        # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    v2,n = p2.vParentWithStack(v2,p2.stack,n)
    while v2:
        if v2 == p.v:
            return True
        v2,n = p2.vParentWithStack(v2,p2.stack,n)

    return False
</t>
<t tx="ekr.20040310062332"># These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
</t>
<t tx="ekr.20040310062332.2">def linkAfter (self,after):

    """Link self after v."""

    p = self
    # g.trace(p,after)

    p.stack = after.stack[:]
    p.v._parent = after.v._parent

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    p.v._back = after.v
    p.v._next = after.v._next

    after.v._next = p.v

    if p.v._next:
        p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")
</t>
<t tx="ekr.20040310062332.3">def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of parent."""

    # g.trace(self,parent,n,parent.v)

    p = self

    # Recreate the stack using the parent.
    p.stack = parent.stack[:]

    if parent.isCloned():
        p.stack.append(parent.v)

    p.v._parent = parent.v

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    if n == 0:
        child1 = parent.v.t._firstChild
        p.v._back = None
        p.v._next = child1
        if child1:
            child1._back = p.v
        parent.v.t._firstChild = p.v
    else:
        prev = parent.nthChild(n-1) # zero based
        assert(prev)
        p.v._back = prev.v
        p.v._next = prev.v._next
        prev.v._next = p.v
        if p.v._next:
            p.v._next._back = p.v

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")
</t>
<t tx="ekr.20040310062332.4">def linkAsRoot (self,oldRoot):

    """Link self as the root node."""

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None

    p.stack = [] # Clear the stack.

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRootVnode

    # Add v to it's tnode's vnodeList.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1 # Support for tnode class.

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot:
        oldRoot.v._back = v

    # p.dump(label="root")
</t>
<t tx="ekr.20040310062332.5">def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.

    The p.v._fistChild link does NOT change."""

    # Warning: p.parent() is NOT necessarily the same as p.v._parent!

    p = self ; v = p.v

    # g.trace('p.v._parent',p.v._parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)

    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
        v.t._p_changed = 1 # Support for tnode class.
    assert(v not in vnodeList)

    # Reset the firstChild link in its direct father.
    if p.v._parent:
        if 0: # This can fail.  I have no idea why it was present.
            assert(p.v and p.v._parent in p.v.directParents())
        if p.v._parent.t._firstChild == v:
            #g.trace('resetting _parent.v.t._firstChild to',v._next)
            p.v._parent.t._firstChild = v._next
    else:
        parent = p.parent()
        if parent:
            if 0: # This can fail.  I have no idea why it was present.
                assert(parent.v in p.v.directParents())
            if parent.v.t._firstChild == v:
                #g.trace('resetting parent().v.t._firstChild to',v._next)
                parent.v.t._firstChild = v._next

    # Do NOT delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")</t>
<t tx="ekr.20040323162707">if p.isCloned() and p.hasChildren():
    childv = p.firstChild().v
    assert childv == p.v.t._firstChild, "childv == p.v.t._firstChild"
    assert id(childv) == id(p.v.t._firstChild), "id(childv) == id(p.v.t._firstChild)"
    for v in p.v.t.vnodeList:
        assert v.t._firstChild == childv, "v.t._firstChild == childv"
        assert id(v.t._firstChild) == id(childv), "id(v.t._firstChild) == id(childv)"
</t>
<t tx="ekr.20040325142015">def equal(self,p2):

    """Return True if two postions are equivalent.

    Use this method when the speed comparisons is crucial

    N.B. Unlike __cmp__, p2 must not be None.
    """

    p1 = self

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1.stack == p2.stack and
        p1.childIndex() == p2.childIndex())

isEqual = equal
</t>
<t tx="ekr.20040409203454">def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""

    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    for p in root.children_iter():
        p.restoreLinksInTree()
</t>
<t tx="ekr.20040409203454.1">def deleteLinksInTree (self):

    """Delete and otherwise adjust links when deleting node."""

    root = self

    root.deleteLinksInSubtree()

    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
</t>
<t tx="ekr.20040410170806">def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        # g.trace('**** remove p.v from %s' % p.headString())
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1  # Support for tnode class.
        assert(p.v not in p.v.t.vnodeList)
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
</t>
<t tx="ekr.20040410170806.1">def adjustParentLinksInSubtree (self,parent):

    root = p = self

    # assert(parent)

    # if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        # # g.trace('**** adjust parent in %s' % p.headString())
        # p.v._parent = parent.v.t.vnodeList[0]

    # for p in root.children_iter():
        # p.adjustParentLinksInSubtree(parent=root)
</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4.8 final, build %s, April 6, 2008" % c.getBuildNumber()
</t>
<t tx="ekr.20041005105605.72">def createThinChild4 (self,gnxString,headline):

    """Find or create a new *vnode* whose parent (also a vnode) is at.lastThinNode."""

    at = self ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)

    # New in Leo 4.4a5: Solve Read @file nodes problem (by LeoUser)
    if self._forcedGnxPositionList and last in self._forcedGnxPositionList:
        last.fileIndex = lastIndex =  gnx
        self._forcedGnxPositionList.remove(last)

    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)

    # See if there is already a child with the proper index.
    # child = at.lastThinNode.firstChild()
    # while child and not indices.areEqual(gnx,child.t.fileIndex):
        # child = child.next()
    children = at.lastThinNode.children
    for child in children:
        if indices.areEqual(gnx,child.t.fileIndex):
            break
    else:
        child = None

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            last.t.setVisited() # Supress warning/deletion of unvisited nodes.
            return last
        if child:
            child.t.setVisited() # Supress warning/deletion of unvisited nodes.
            return child
        copies = 1 # Create exactly one copy.

    while copies &gt; 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            if indices.areEqual(t.fileIndex,gnx):
                pass
            else:
                g.trace('can not happen: t.fileIndex: %s gnx: %s' % (t.fileIndex,gnx))
                # g.trace('not created, should already exist',gnxString)
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(context=c,t=t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    child.t.setVisited() # Supress warning/deletion of unvisited nodes.
    return child
</t>
<t tx="ekr.20041005105605.127">def readError(self,message):

    # This is useful now that we don't print the actual messages.
    if self.errors == 0:
        self.printError("----- read error. line: %s, file: %s" % (
            self.lineNumber,self.targetFileName,))

    # g.trace(self.root,g.callers())
    self.error(message)

    # Bug fix: 12/10/05: Delete all of root's tree.
    ### self.root.v.t.   = None
    self.root.children = []
    self.root.setOrphan()
    self.root.setDirty()
</t>
<t tx="ekr.20041023105832">self.forbiddenTnodes = []

for p in oldCurrent.self_and_parents_iter():
    if p.v.t not in self.forbiddenTnodes:
        self.forbiddenTnodes.append(p.v.t)

# g.trace("forbiddenTnodes",self.forbiddenTnodes)
</t>
<t tx="ekr.20041117083857.1"># Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):

    """Read settings from a file that may contain an @settings tree."""

    # g.trace(c.fileName())

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d
</t>
<t tx="ekr.20041117085625">def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
</t>
<t tx="ekr.20041117093246"></t>
<t tx="ekr.20041120064303">def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    &lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                s = g.toEncodedString(s,'ascii')
                print s
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
</t>
<t tx="ekr.20041120074536">def settingsRoot (self,c):

    '''Return the position of the @settings tree.'''

    # g.trace(c,c.rootPosition())

    for p in c.allNodes_iter():
        # g.trace(c.shortFileName(),p.headString())
        if p.headString().rstrip() == "@settings":
            # g.trace('**found**',p.headString())
            return p.copy()
    else:
        # g.trace('***no @settings found')
        return c.nullPosition()
</t>
<t tx="ekr.20050415170737.1">def createVnodeUndoInfo (self,v):

    """Create a bunch containing all info needed to recreate a vnode for undo."""

    bunch = g.Bunch(
        v = v,
        statusBits = v.statusBits,
        parent     = v._parent,
        next       = v._next,
        back       = v._back,
        # The tnode never changes so there is no need to save it here.
    )

    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
</t>
<t tx="ekr.20050415170737.2">def restoreVnodeUndoInfo (self,bunch):

    """Restore all ivars saved in the bunch."""

    v = bunch.v

    v.statusBits = bunch.statusBits
    v._parent    = bunch.parent
    v._next      = bunch.next
    v._back      = bunch.back

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
</t>
<t tx="ekr.20050415170812.1">def createTnodeUndoInfo (self,t):

    """Create a bunch containing all info needed to recreate a vnode."""

    bunch = g.Bunch(
        t = t,
        headString = t._headString,
        bodyString = t._bodyString,
        vnodeList  = t.vnodeList[:],
        statusBits = t.statusBits,
        ### firstChild = t._firstChild,
    )

    if hasattr(t,'unknownAttributes'):
        bunch.unknownAttributes = t.unknownAttributes

    return bunch
</t>
<t tx="ekr.20050415170812.2">def restoreTnodeUndoInfo (self,bunch):

    t = bunch.t

    t._headString  = bunch.headString
    t._bodyString  = bunch.bodyString
    t.vnodeList   = bunch.vnodeList
    t.statusBits  = bunch.statusBits
    ### t._firstChild = bunch.firstChild

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        t.unknownAttributes = uA
        t._p_changed = 1
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20051013161232">def updateSettings (self,c,localFlag):

    d = self.readSettings(c)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20060202090907">def key (self):

    p = self

    return '%s:%d.%s' % (
        id(p.v),
        p.childIndex(),
        ','.join([str(id(v)) for v in p.stack])
    )
</t>
<t tx="ekr.20060217111834">@nocolor

.  any char
^  start line
$  end of line
\w alphanum: [a-zA-Z0-9_]
\W non-alphanum
\s whitespace
\S non-whitespace

These can be done with regexps:
    
copy-to-end-of-each-line:   (.)$        --&gt;  \1x
copy-to-start-of-each-line: ^([ \t]+)   --&gt;  \1x
remove-leading-ws:  ^[ \t]+             --&gt;  empty
remove-trailing-ws: [ \t]+$             --&gt;  empty
paste-at-column:    ^(.{4})             --&gt;  \1x
paste-after-lws:    ^([ \t]+)           --&gt;  \1x

(?=...)
    Matches if ... matches next, but doesnt consume any of the string. This is called a lookahead assertion. For example, Isaac (?=Asimov) will match 'Isaac ' only if it's followed by 'Asimov'.

(?!...)
    Matches if ... doesn't match next. This is a negative lookahead assertion. For example, Isaac (?!Asimov) will match 'Isaac ' only if it is not followed by 'Asimov'.

(?&lt;=...)
    Matches if the current position in the string is preceded by a match for ... that ends at the current position. This is called a positive lookbehind assertion. The contained pattern must only match strings of some fixed length, meaning that abc or a|b are allowed, but a* and a{3,4} are not</t>
<t tx="ekr.20060531093331">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060531093331.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others</t>
<t tx="ekr.20060531093331.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")</t>
<t tx="ekr.20060531093331.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060531093331.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.currentPosition()
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.headString())
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060531093331.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().headString()
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)</t>
<t tx="ekr.20060531093331.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20060908104329"></t>
<t tx="ekr.20060910141935"></t>
<t tx="ekr.20060910141935.1"># c.k.simulateCommand('read-zodb-file')

path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.readFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060910141935.2"># c.k.simulateCommand('write-zodb-file')

path = c.fileName()
# path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.writeFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060913091805.1">def detach (self):

    '''Return a standalone copy of a vnode,
    detached from all other nodes and with a new tnode.'''

    v = self

    # Create a completely separate tnode.
    t2 = tnode(
        bodyString=v.bodyString(),
        headString=v.headString())

    return vnode(context=v.context,t=t2)</t>
<t tx="ekr.20060919104530"></t>
<t tx="ekr.20060919110638.2">def dumpSaxTree (self,root,dummy):

    if not root:
        print 'dumpSaxTree: empty tree'
        return
    if not dummy:
        root.dump()
    for child in root.children:
        self.dumpSaxTree(child,dummy=False)</t>
<t tx="ekr.20060919110638.3">def readSaxFile (self,theFile,fileName,silent):

    # Pass one: create the intermediate nodes.
    dummyRoot = self.parse_leo_file(theFile,fileName,silent=silent)

    # self.dumpSaxTree(dummyRoot,dummy=True)

    # Pass two: create the tree of vnodes and tnodes from the intermediate nodes.
    if dummyRoot:
        children = self.createSaxVnodes(dummyRoot)
        # g.trace('children',children)
        self.c.hiddenRootNode.children = children
        v = children and children[0] or None
        return v
    else:
        return None
</t>
<t tx="ekr.20060919110638.4">def createSaxVnodes (self, dummyRoot):

    '''**Important**: this method and its helpers are low-level code
    corresponding to link/unlink methods in leoNodes.py.
    Modify this with extreme care.'''

    children = self.createSaxChildren(dummyRoot,parent_v = None)
    ### firstChild = children and children[0]
    ### return firstChild
    return children</t>
<t tx="ekr.20060919110638.5"># node is a saxNodeClass object, parent_v is a vnode.

def createSaxChildren (self, sax_node, parent_v):

    result = []

    for child in sax_node.children:
        tnx = child.tnx
        t = self.tnodesDict.get(tnx)
        if t:
            # A clone.  Create a new clone vnode, but share the subtree, i.e., the tnode.
            v = self.createSaxVnode(child,parent_v,t=t)
            # g.trace('clone',id(child),child.headString,'t',v.t)
        else:
            v = self.createSaxVnodeTree(child,parent_v)
        result.append(v)

    self.linkSiblings(result)
    if parent_v: self.linkParentAndChildren(parent_v,result)
    return result
</t>
<t tx="ekr.20060919110638.6">def createSaxVnodeTree (self,sax_node,parent_v):

    v = self.createSaxVnode(sax_node,parent_v)

    self.createSaxChildren(sax_node,v)

    return v</t>
<t tx="ekr.20060919110638.7">def createSaxVnode (self,sax_node,parent_v,t=None):

    c = self.c
    h = sax_node.headString
    b = sax_node.bodyString

    if not t:
        t = leoNodes.tnode(bodyString=b,headString=h)
        if sax_node.tnx:
            t.fileIndex = g.app.nodeIndices.scanGnx(sax_node.tnx,0)

    v = leoNodes.vnode(context=c,t=t)
    v.t.vnodeList.append(v)

    ### v._parent = parent_v

    index = self.canonicalTnodeIndex(sax_node.tnx)
    self.tnodesDict [index] = t

    # g.trace('tnx','%-22s' % (index),'v',id(v),'v.t',id(v.t),'body','%-4d' % (len(b)),h)

    self.handleVnodeSaxAttributes(sax_node,v)
    self.handleTnodeSaxAttributes(sax_node,t)

    return v</t>
<t tx="ekr.20060919110638.8">def handleTnodeSaxAttributes (self,sax_node,t):

    d = sax_node.tnodeAttributes

    aDict = {}
    for key in d.keys():
        val = d.get(key)
        val2 = self.getSaxUa(key,val)
        aDict[key] = val2

    if aDict:
        # g.trace('uA',aDict)
        t.unknownAttributes = aDict</t>
<t tx="ekr.20060919110638.9">def linkParentAndChildren (self, parent_v, children):

    # if children: g.trace(parent_v,len(children))

    # Add parent_v to it's tnode's vnodeList.
    if parent_v not in parent_v.t.vnodeList:
        parent_v.t.vnodeList.append(v)

    # Set parent_v's children.
    parent_v.children = children

    # Make parent_v a parent of each child.
    for v in children:
        if parent_v not in v.parents:
            v.parents.append(parent_v)

    # firstChild_v = children and children[0] or None

    # parent_v.t._firstChild = firstChild_v

    # for child in children:
        # child._parent = parent_v

    # v = parent_v
    # if v not in v.t.vnodeList:
        # v.t.vnodeList.append(v)
</t>
<t tx="ekr.20060919110638.10">def linkSiblings (self, sibs):

    '''Set the v._back and v._next links for all vnodes v in sibs.'''

    n = len(sibs)

    for i in xrange(n):
        v = sibs[i]
        v._back = (i-1 &gt;= 0 and sibs[i-1]) or None
        v._next = (i+1 &lt;  n and sibs[i+1]) or None</t>
<t tx="ekr.20060919110638.11">def resolveTnodeLists (self):

    c = self.c

    for p in c.allNodes_iter():
        if hasattr(p.v,'tempTnodeList'):
            # g.trace(p.v.headString())
            result = []
            for tnx in p.v.tempTnodeList:
                index = self.canonicalTnodeIndex(tnx)
                t = self.tnodesDict.get(index)
                if t:
                    # g.trace(tnx,t)
                    result.append(t)
                else:
                    g.trace('No tnode for %s' % tnx)
            p.v.t.tnodeList = result
            delattr(p.v,'tempTnodeList')</t>
<t tx="ekr.20060919110638.13">def setPositionsFromVnodes (self):

    c = self.c ; p = c.rootPosition()

    current = None
    d = hasattr(p.v,'unknownAttributes') and p.v.unknownAttributes
    if d:
        s = d.get('str_leo_pos')
        if s:
            current = self.archivedPositionToPosition(s)

    c.setCurrentPosition(current or c.rootPosition())</t>
<t tx="ekr.20060919110638.14">def parse_leo_file (self,theFile,inputFileName,silent):

    c = self.c
    # g.trace('hiddenRootNode',c.hiddenRootNode)

    try:
        # Use cStringIo to avoid a crash in sax when inputFileName has unicode characters.
        s = theFile.read()
        theFile = cStringIO.StringIO(s)
        # g.trace(repr(inputFileName))
        node = None
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the &lt;?xml&gt; element.
        handler = saxContentHandler(c,inputFileName,silent)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()

    return node</t>
<t tx="ekr.20061003093021">def getSaxUa(self,attr,val):

    """Parse an unknown attribute in a &lt;v&gt; or &lt;t&gt; element.
    The unknown tag has been pickled and hexlify'd.
    """

    try:
        val = str(val)
    except UnicodeError:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()

    # g.trace(attr,repr(val))

    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_') and type(val) == type(''):
        # g.trace(attr,val)
        return val

    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass

    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except TypeError:
        # Assume that Leo 4.1 wrote the attribute.
        g.trace('can not unhexlify',val)
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return val2
    except (pickle.UnpicklingError,ImportError):
        g.trace('can not unpickle',val)
        return val
</t>
<t tx="ekr.20061004053644"># The native attributes of &lt;v&gt; elements are a, t, vtag, tnodeList,
# marks, expanded and descendentTnodeUnknownAttributes.

def handleVnodeSaxAttributes (self,sax_node,v):

    d = sax_node.attributes
    s = d.get('a')
    if s:
        # g.trace('%s a=%s %s' % (id(sax_node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.trace('setting currentVnode',v,color='red')
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnode list will be resolved later.
        # g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes') # Correct: only tnode have descendent uA's.
    if s: 
        aDict = self.getDescendentUnknownAttributes(s)
        if aDict:
            # g.trace('descendentUaDictList',aDict)
            self.descendentUnknownAttributesDictList.append(aDict)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d.keys():
        if key in self.nativeVnodeAttributes:
            if 0: g.trace('****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # g.trace('uA',aDict)
        v.unknownAttributes = aDict</t>
<t tx="ekr.20061006104837.1">def archivedPositionToPosition (self,s):

    c = self.c
    aList = s.split(',')
    try:
        aList = [int(z) for z in aList]
    except Exception:
        # g.trace('oops: bad archived position. not an int:',aList,c)
        aList = None
    if not aList: return None
    p = c.rootPosition() ; level = 0
    while level &lt; len(aList):
        i = aList[level]
        while i &gt; 0:
            if p.hasNext():
                p.moveToNext()
                i -= 1
            else:
                # g.trace('oops: bad archived position. no sibling:',aList,p.headString(),c)
                return None
        level += 1
        if level &lt; len(aList):
            p.moveToFirstChild()
            # g.trace('level',level,'index',aList[level],p.headString())
    return p</t>
<t tx="ekr.20061028082834"># This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None</t>
<t tx="ekr.20070605104410"></t>
<t tx="ekr.20070628175250">@color

u = c.undoer
b = u.beforeChangeNodeContents(p)
s = p.bodyString()

result = [' '*4 + line for line in g.splitLines(s)]
result.insert(0,'if g.unitTesting:\n')
s = ''.join(result)
c.setBodyString(p,s)

u.afterChangeNodeContents(p,'add-if-g-unitTesting',b)
</t>
<t tx="ekr.20071001054335"># script to split node containing multiple def's into child nodes

def createChild (parent,body,line):
    p = parent.insertAsLastChild()
    h = line [3:].strip()
    i = h.find('(')
    if i &gt; -1:
        func = h [: i].strip()
    h2 = g.choose(func,func,h)
    p.setHeadString(h2)
    p.setTnodeText(''.join(body))

s = p.bodyString()
if s.strip():
    b = c.undoer.beforeChangeTree(p)
    c.beginUpdate()
    try:
        lines = g.splitLines(s) ; body = [] ; changed = False ; lastDefLine = ''
        for line in lines:
            if g.match_word(line,0,'def'):
                if body and lastDefLine:
                    createChild(p,body,lastDefLine)
                    body = [] ; changed = True
                lastDefLine = line
            body.append(line)
        if body and lastDefLine:
            createChild(p,body,lastDefLine)
            changed = True
        if changed:
            c.setChanged(True) ; c.setBodyString(p,'')
    finally:
        c.undoer.afterChangeTree(p,'split-defs',b)
        c.endUpdate()</t>
<t tx="ekr.20071004062031">print '-'*60
</t>
<t tx="ekr.20071024171346"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.doTests(c,all=False)
c.selectPosition(p,updateBeadList=False)</t>
<t tx="ekr.20071024180738"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.runTestsExternally(c,all=False)

</t>
<t tx="ekr.20080112145409"></t>
<t tx="ekr.20080121090750"># A script to create @auto nodes from all .py files in a directory.

import glob,os

reallyCreate = True

baseDir = r'c:\Python25\Lib\site-packages\pubsub'
baseDir = r'C:\Program Files\Komodo Edit 4.3\lib\mozilla\python\komodo\codeintel2'
dirs = ('',) #'Extensions','UserConfig',)
print '-----'

c.beginUpdate()
try:
    for theDir in dirs:
        pattern = g.os_path_join(baseDir,theDir,'*.py')
        files = glob.glob(pattern)
        print pattern
        # print g.listToString(files)
        for name in files:
            h = '@auto %s' % (name[len(baseDir) + 1:].strip())
            print 'creating',h
            if reallyCreate:
                child = p.insertAsLastChild()
                child.initHeadString(h)
finally:
    c.endUpdate()
</t>
<t tx="ekr.20080121091513">c.importCommands.createOutline(
    fileName=None,
    parent=p,
    atAuto=True,
    s=p.bodyString(),ext='.py')


</t>
<t tx="ekr.20080121092503"></t>
<t tx="ekr.20080220082617">@first # -*- coding: utf-8 -*-

# To do: put list of to-be-translated strings in a doc part.

&lt;&lt; docstring &gt;&gt;
&lt;&lt; version history &gt;&gt;

class controllerClass:
    @others

x = controllerClass(c,p)
x.main()
</t>
<t tx="ekr.20080220082617.1">'''Here is a cute Leo script. It discovers all g.es statements and the unbound
variables in those statements in a single pass over the selected outline. It
then puts the decls followed by the statements in the body text of the @scan_g.es_results node.

Thus, after this script, you can **execute** the body text of the @scan_g.es_results node.
In particular, assuming that g.translateString converts all translated text to upper case,
it is easy to tell which strings have been translated.
'''</t>
<t tx="ekr.20080220082617.2">@nocolor
@

2008/2/19 EKR: Initial 2-pass version.
2008/2/20 EKR:
- Convert to single-pass using decls and statements arrays.
- Add 'tabName' to list of keyword arguments.
- Fixed various bugs.
2008/2/20 EKR 2:
- Generate g.es statements to inicate beginnings of files.
  This allows us to execute all generated statements at once.
- Convert between '.' and '__' as needed to avoid using real ivars.
2008/2/21 EKR:
- Added mungeString.
- Rewrote mungeStatements, scanParens and scanIdChain.
These changes now properly handle all arguments.
2008/2/21 EKR 2:
- Added stringize and related logic.
- Added setToBeTranslated to put list of to-be-translated strings into leading docstring.</t>
<t tx="ekr.20080220082617.3">def __init__ (self,c,p):

    self.c = c
    self.p = p

    self.decls = {}
    self.keywordArgs = ('color','commas','newline','spaces','tabName',)
    self.nodeName = '@scan_g.es_results'
    self.statements = []
    self.printStatements = ('g.es','g.es_print',)
    self.suppressTranslation = False # True: keyword arg to g.es seen.
    self.toBeTranslated = []
    self.traceFlag = False

    self.root = g.findNodeAnywhere(c,self.nodeName)
</t>
<t tx="ekr.20080220082617.4">def error (self,s):

    self.statements.append('***error: %s' % s)

def trace(self,s):

    if self.traceFlag:
        self.statements.append(s)
</t>
<t tx="ekr.20080220082617.5">def main (self):

    '''The main line.'''

    c = self.c
    self.scan()
    self.mungeStatements()
    keys = self.decls.keys()
    keys.sort()
    # This is such a great hack :-)
    decls = ["%s = '%s'" % (self.mungeString(z),self.stringize(z,delim="'")) for z in keys]

    # Put to-be-translated.
    results = ['@ To be translated...',]
    self.toBeTranslated.sort()
    results.extend(self.toBeTranslated)
    results.extend(['@c',])
    # Put decls.
    results.extend(['# Decls...',])
    results.extend(["color='red'","newline=True","tabName='Log'"])
    results.extend(decls)
    # Put statements
    results.extend(["g.app.translateToUpperCase=True",])
    results.extend(self.statements)
    results.extend(["g.app.translateToUpperCase=False",])

    results = '\n'.join(results)

    # Put the results in the root node, or print them.
    if self.root:
        c.setBodyString(self.root,results)
        c.beginUpdate()
        try:
            c.selectPosition(self.root)
        finally:
            c.endUpdate()
    else:
        print 'node not found',self.rootName
        print results

    g.es('done')
</t>
<t tx="ekr.20080220082617.6">def scan(self):


    for p in self.p.self_and_subtree_iter():

        self.scanNode(p)</t>
<t tx="ekr.20080220082617.8">def scanParens(self,s,i,outer):

    '''Scan a parenthesized list of args.'''

    assert g.match(s,i,'(')
    j = g.skip_matching_python_parens(s,i)
    if j == -1:
        self.error('**incomplete paren at: %s' % s[i:])
        return i+1 # Just skip the paren

    assert g.match(s,j,')')
    n = 1
    while i &lt; j:
        progress = i ; ch = s[i]

        if ch in ("'",'"',):
            i = self.scanStringArg(s,i,n,outer)
            n += 1

        elif g.is_c_id(ch):
            i = self.scanIdChain(s,i,outer)
            n += 1

        i = max(i,progress+1)

    return j + 1 # return the character after the paren.
</t>
<t tx="ekr.20080220082617.9">def scanNode(self,p):

    tags = ('g.es','g.es_print',)
    s,h = p.bodyString(), p.headString()
    print_h = True

    if h.startswith('@thin'):
        &lt;&lt; insert statements highlighting the @thin node &gt;&gt;

    i = 0
    while i &lt; len(s):
        progress = i
        for tag in tags:
            if g.match_word(s,i,tag):
                start = i ; i += len(tag)
                self.suppressTranslation = False
                i = g.skip_ws(s,i)
                if g.match(s,i,'('):
                    &lt;&lt; Insert a comment containing the headline &gt;&gt;
                    i = self.scanParens(s,i,outer=True)
                    statement = s[start:i]
                    if statement.find('*arg') == -1 and statement.find('**key') == -1:
                        self.statements.append(statement)
                break
        i = max(i,progress+1)
</t>
<t tx="ekr.20080220082617.10">def setDecl (self,s):

    s = s.strip()

    if s in ('c','g','p','len','str','repr','and','or','not','is',):
        return # Don't need a binding for these.

    if s in ('color','newline','tabName',):
        return # Special binding will be used for these.

    if s.isdigit():
        return # Don't bind integers.

    self.decls[s] = True
</t>
<t tx="ekr.20080220093930">def mungeHeadline (self,s):

    s = s.strip()
    s = s.replace('&lt;&lt;','&lt; &lt;')
    s = s.replace('&gt;&gt;','&gt; &gt;')
    return s
</t>
<t tx="ekr.20080220182141">def scanIdChain (self,s,i,outer):

    assert g.is_c_id(s[i])
    start = i 

    while i &lt; len(s):
        progress = i
        # Skip a.b.c...
        if not g.is_c_id(s[i]): break
        i = g.skip_id(s,i,chars='.')
        i = g.skip_ws(s,i)
        word = s[start:i].strip()
        if outer and g.match(s,i,'=') and word in (self.keywordArgs):
            # g.trace('***','=',word)
            self.suppressTranslation = True
        # Only a paren is valid now.
        if not g.match(s,i,'('): break
        # We shall munge the entire paren expression.
        i = g.skip_matching_python_parens(s,i)
        if g.match(s,i,')'): i += 1
        # Only a dot is valid now.
        if not g.match(s,i,'.'): break
        i += 1
        assert i &gt; progress

    self.setDecl(s[start:i])
    return i
</t>
<t tx="ekr.20080220183819">def scanStringArg(self,s,i,n,outer):

    '''Skip a string, and possible %'''

    j = g.skip_python_string(s,i)
    if j &lt;= i: return i

    # g.trace(n,s[i:j])

    if outer:
        self.setToBeTranslated(s[i:j],n)

    i = g.skip_ws(s,j)
    if not g.match(s,i,'%'):
        return i

    # Handle what follows the '%'
    i = g.skip_ws(s,i+1)

    if g.match(s,i,'('):
        i = self.scanParens(s,i,outer=False)
    elif i &lt; len(s) and g.is_c_id(s[i]):
        i = self.scanIdChain(s,i,outer)

    return i
</t>
<t tx="ekr.20080221071308">def mungeString (self,s):

    '''Convert string s so that it is a valid Python name.'''

    s = s.strip()
    # s = s.replace('@','_AT_')
    # s = s.replace('&lt;','_LT_')
    # s = s.replace('&gt;','_GT_')
    s = s.replace(',','_COMMA_')
    s = s.replace('.','_DOT_')
    s = s.replace('()','_PARENS_')
    s = s.replace('(','_LP_')
    s = s.replace(')','_RP_')
    s = s.replace('"','_DQ_')
    s = s.replace("'",'_SQ_')
    s = ''.join([g.choose(z == '_' or z.isalnum(),z,'_') for z in s])
    return s
</t>
<t tx="ekr.20080221071734">self.statements.append('# ---- %s' % (h))
self.statements.append("g.es_print('','%s %s',color='red')" % ('-'*20,h))</t>
<t tx="ekr.20080221071734.1">if print_h:
    print_h = False
    if not h.startswith('@thin'):
        self.statements.append('# -- node %s' % (self.mungeHeadline(h)))</t>
<t tx="ekr.20080221073909">def mungeStatements (self):

    '''Convert a references to an known id chain by the corresponding decl.'''

    keys = self.decls.keys()
    for tag in self.printStatements:
        if tag in keys: keys.remove(tag)

    results = []
    for s in self.statements:
        i = 0 ; inner_result = []
        while i &lt; len(s):
            progress = i
            for key in keys:
                if g.match_word(s,i,key):
                    inner_result.append(self.mungeString(key))
                    i += len(key)
                    break
            else:
                inner_result.append(s[i])
            i = max(i,progress+1)
        new_statement = ''.join(inner_result)
        if new_statement != s:
            # Add the original lines as comments.
            for z in g.splitLines(s):
                results.append ('# %s' % (z.rstrip()))
        results.append(new_statement) # Add the munged line.

    self.statements = results

</t>
<t tx="ekr.20080221101728"></t>
<t tx="ekr.20080221101728.1">def stringize (self,s,delim):

    s = s.strip()
    s = s.replace(delim,'\\%s' % (delim))
    return s
</t>
<t tx="ekr.20080221110301">def setToBeTranslated (self,s,n):


    s = s.strip()

    if s.startswith('"') or s.startswith("'"):
        s = s[1:]
    if s.endswith('"') or s.endswith("'"):
        s = s[:-1]

    s = s.strip()

    # Suppress translation when a keyword is seen, regardless of position.
    if s in self.keywordArgs:
        self.suppressTranslation = True

    if self.suppressTranslation:
        # g.trace('not added',s)
        return

    if (n % 2) == 1 and s not in self.toBeTranslated:
        self.toBeTranslated.append(s)
</t>
<t tx="ekr.20080312060129.5"></t>
<t tx="ekr.20080312060129.6"></t>
<t tx="ekr.20080412053100.4"></t>
<t tx="ekr.20080412053100.5"></t>
<t tx="ekr.20080416161308.1"></t>
<t tx="ekr.20080416161551.1">@language python
@tabwidth -4
@pagewidth 80

# __pychecker__ = '--no-reuseattr' # Suppress warnings about redefining vnode and tnode classes.

use_zodb = False

&lt;&lt; imports &gt;&gt;

@others</t>
<t tx="ekr.20080416161551.2">if use_zodb:
    # It may be important to import ZODB first.
    try:
        import ZODB
        import ZODB.FileStorage
    except ImportError:
        ZODB = None
else:
    ZODB = None

import leoGlobals as g

if g.app and g.app.use_psyco:
    # print "enabled psyco classes",__file__
    try: from psyco.classes import *
    except ImportError: pass

import string
import time</t>
<t tx="ekr.20080416161551.3"># Indices are Python dicts containing 'id','loc','time' and 'n' keys.

class nodeIndices (object):

    """A class to implement global node indices (gnx's)."""

    @others
</t>
<t tx="ekr.20080416161551.4">def __init__ (self,id):

    """ctor for nodeIndices class"""

    self.userId = id
    self.defaultId = id

    # A Major simplification: Only assign the timestamp once.
    self.setTimeStamp()
    self.lastIndex = 0
</t>
<t tx="ekr.20080416161551.5">def areEqual (self,gnx1,gnx2):

    """Return True if all fields of gnx1 and gnx2 are equal"""

    # works whatever the format of gnx1 and gnx2.
    # This should never throw an exception.
    return gnx1 == gnx2
</t>
<t tx="ekr.20080416161551.6"># These are used by the fileCommands read/write code.

def getDefaultId (self):

    """Return the id to be used by default in all gnx's"""
    return self.defaultId

def setDefaultId (self,theId):

    """Set the id to be used by default in all gnx's"""
    self.defaultId = theId
</t>
<t tx="ekr.20080416161551.7">def getNewIndex (self):

    '''Create a new gnx.'''

    self.lastIndex += 1
    d = (self.userId,self.timeString,self.lastIndex)
    # g.trace(d)
    return d
</t>
<t tx="ekr.20080416161551.8">def isGnx (self,gnx):
    try:
        theId,t,n = gnx
        return t != None
    except Exception:
        return False
</t>
<t tx="ekr.20080416161551.9">def scanGnx (self,s,i):

    """Create a gnx from its string representation"""

    if type(s) not in (type(""),type(u"")):
        g.es("scanGnx: unexpected index type:",type(s),'',s,color="red")
        return None,None,None

    s = s.strip()

    theId,t,n = None,None,None
    i,theId = g.skip_to_char(s,i,'.')
    if g.match(s,i,'.'):
        i,t = g.skip_to_char(s,i+1,'.')
        if g.match(s,i,'.'):
            i,n = g.skip_to_char(s,i+1,'.')
    # Use self.defaultId for missing id entries.
    if theId == None or len(theId) == 0:
        theId = self.defaultId
    # Convert n to int.
    if n:
        try: n = int(n)
        except Exception: pass

    return theId,t,n
</t>
<t tx="ekr.20080416161551.10">def setTimestamp (self):

    """Set the timestamp string to be used by getNewIndex until further notice"""

    self.timeString = time.strftime(
        "%Y%m%d%H%M%S", # Help comparisons; avoid y2k problems.
        time.localtime())

    # g.trace(self.timeString,self.lastIndex,g.callers(4))

setTimeStamp = setTimestamp
</t>
<t tx="ekr.20080416161551.11">def toString (self,index):

    """Convert a gnx (a tuple) to its string representation"""

    try:
        theId,t,n = index
        if n in (None,0,'',):
            return "%s.%s" % (theId,t)
        else:
            return "%s.%s.%d" % (theId,t,n)
    except Exception:
        if not g.app.unitTesting:
            g.trace('unusual gnx',repr(index),g.callers()) 
        try:
            theId,t,n = self.getNewIndex()
            if n in (None,0,'',):
                return "%s.%s" % (theId,t)
            else:
                return "%s.%s.%d" % (theId,t,n)
        except Exception:
            g.trace('double exception: returning original index')
            return repr(index)</t>
<t tx="ekr.20080416161551.12"># if use_zodb and ZODB:
    # class baseTnode (ZODB.Persistence.Persistent):
        # pass
# else:
    # class baseTnode (object):
        # pass

class node (object):
    """A class that implements unified nodes."""
    &lt;&lt; node constants &gt;&gt;
    @others</t>
<t tx="ekr.20080416161551.13"># From tnodes

### dirtyBit    = 0x01
### richTextBit = 0x02 # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
### visitedBit  = 0x04
### writeBit    = 0x08 # Set: write the tnode.

# From vnodes

# Define the meaning of status bits in new vnodes.

# Archived...
clonedBit   = 0x01 # True: vnode has clone mark.

# not used = 0x02
expandedBit = 0x04 # True: vnode is expanded.
markedBit   = 0x08 # True: vnode is marked
orphanBit   = 0x10 # True: vnode saved in .leo file, not derived file.
selectedBit = 0x20 # True: vnode is current vnode.
# topBit    = 0x40 # True: vnode was top vnode when saved.

# Not archived...
dirtyBit    = 0x060
richTextBit = 0x080 # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
visitedBit  = 0x100
writeBit    = 0x200 # True: write the node.
</t>
<t tx="ekr.20080416161551.14"></t>
<t tx="ekr.20080416161551.15"># All params have defaults, so t = tnode() is valid.

def __init__ (self,context,bodyString=None,headString=None):

    # To support ZODB the code must set v._p_changed = 1 whenever
    # v.children, v.parents, v.unknownAttributes or any mutable node object changes.

    self.context = context # The context containing context.hiddenRootNode.
        # Required for trees, so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.

    self.children = [] # List of all child nodes.
    self.clones = [{}] # A list of dicts (possibly containing uA).  One for each created/cloned node.
    # self.cloneIndex = 0 # For Pre-3.12 files.  Zero for @file nodes
    self.fileIndex = None # The immutable file index for this tnode.
    self.iconVal = 0 
    self.insertSpot = None # Location of previous insert point.
    self.parents = [] # List of all nodes pointing to this tnode.
    self.scrollBarSpot = None # Previous value of scrollbar position.
    self.selectionLength = 0 # The length of the selected body text.
    self.selectionStart = 0 # The start of the selected body text.
    self.statusBits = 0 # status bits
    # self.vnodeList = [] # OOOOOPS: this can't be defined here.

    # Convert everything to unicode...
    self._headString = g.toUnicode(headString,g.app.tkEncoding)
    self._bodyString = g.toUnicode(bodyString,g.app.tkEncoding)

    # For compatibility:
    self.t = self
    # self.v = self
</t>
<t tx="ekr.20080416161551.16">if use_zodb and ZODB:

    # The only required property is that objects
    # which compare equal have the same hash value.

    def __hash__(self):

        return hash(g.app.nodeIndices.toString(self.fileIndex))
</t>
<t tx="ekr.20080416161551.17">def __repr__ (self):

    # return "&lt;node %s&gt;" % id(self)

    return "&lt;node %d: %s&gt;" % (id(self),self.headString() or '&lt;no v.headString&gt;')

__str__ = __repr__
</t>
<t tx="ekr.20080416161551.18">def dump (self,label='',verbose=True):

    v = self

    if label:
        print '-'*10,label,v
    else:
        print "self",repr(v),
        print "len(children)",len(v.children),
        print "len(parents)",len(v.parents)

    if verbose:
        print 'parents...'
        for z in v.parents:
            print z
        print 'children...'
        for z in v.children:
            print z
</t>
<t tx="ekr.20080416161551.19"></t>
<t tx="ekr.20080416161551.20">def findAtFileName (self,names):

    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()

    if not g.match(h,0,'@'):
        return ""

    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""
</t>
<t tx="ekr.20080416161551.21">def anyAtFileNodeName (self):

    """Return the file name following an @file node or an empty string."""

    names = (
        "@auto",
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)
</t>
<t tx="ekr.20080416161551.22"># These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atAutoNodeName (self):
    # h = self.headString() ; tag = '@auto'
    # # Prevent conflicts with autotrees plugin: don't allow @auto-whatever to match.
    # return g.match_word(h,0,tag) and not g.match(h,0,tag+'-') and h[len(tag):].strip()
    names = ("@auto",)
    return self.findAtFileName(names)

def atFileNodeName (self):
    names = ("@file",)
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)

def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)

def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName
</t>
<t tx="ekr.20080416161551.23">def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.bodyString(),0,"@all")
    return flag
</t>
<t tx="ekr.20080416161551.24">def isAnyAtFileNode (self):

    """Return True if v is any kind of @file or related node."""

    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()
</t>
<t tx="ekr.20080416161551.25">def isAtAutoNode (self):
    return g.choose(self.atAutoNodeName(),True,False)

def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)

def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode
</t>
<t tx="ekr.20080416161551.26">def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.bodyString(), 0, "@ignore")
    return flag
</t>
<t tx="ekr.20080416161551.27">def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.bodyString(),0,"@others")
    return flag
</t>
<t tx="ekr.20080416161551.28">def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.

    The headline may contain characters following the successfully matched pattern."""

    v = self

    h = g.toUnicode(v.headString(),'utf-8')
    h = h.lower().replace(' ','').replace('\t','')

    pattern = g.toUnicode(pattern,'utf-8')
    pattern = pattern.lower().replace(' ','').replace('\t','')

    return h.startswith(pattern)
</t>
<t tx="ekr.20080416161551.29"></t>
<t tx="ekr.20080416161551.30"></t>
<t tx="ekr.20080416161551.31">def firstChild (self):

    v = self
    return self.children and self.children[0] or None

</t>
<t tx="ekr.20080416161551.32">def hasChildren (self):

    v = self
    return len(self.children) &gt; 0

hasFirstChild = hasChildren
</t>
<t tx="ekr.20080416161551.33">def lastChild (self):

    v = self
    n = len(v.children)
    if n:
        return v.children[n-1]
    else:
        return None

    # child = self.firstChild()
    # while child and child.next():
        # child = child.next()
    # return child
</t>
<t tx="ekr.20080416161551.34"># childIndex and nthChild are zero-based.

def nthChild (self, n):

    v = self
    if 0 &lt;= n &lt; len(v.children):
        return v.children[n]
    else:
        return None

    # child = self.firstChild()
    # if not child: return None
    # while n &gt; 0 and child:
        # n -= 1
        # child = child.next()
    # return child
</t>
<t tx="ekr.20080416161551.35">def numberOfChildren (self):

    v = self
    return len(v.children)

    # n = 0
    # child = self.firstChild()
    # while child:
        # n += 1
        # child = child.next()
    # return n
</t>
<t tx="ekr.20080416161551.36"></t>
<t tx="ekr.20080416161551.37">def isCloned (self):

    return len(self.clones) &gt; 1
</t>
<t tx="ekr.20080416161551.38">def isDirty (self):

    return (self.statusBits &amp; self.dirtyBit) != 0
</t>
<t tx="ekr.20080416161551.39">def isExpanded (self):

    return ( self.statusBits &amp; self.expandedBit ) != 0
</t>
<t tx="ekr.20080416161551.40">def isMarked (self):

    return ( self.statusBits &amp; self.markedBit ) != 0
</t>
<t tx="ekr.20080416161551.41">def isOrphan (self):

    return ( self.statusBits &amp; self.orphanBit ) != 0
</t>
<t tx="ekr.20080416161551.42">def isRichTextBit (self):

    return (self.statusBits &amp; self.richTextBit) != 0
</t>
<t tx="ekr.20080416161551.43">def isSelected (self):

    return ( self.statusBits &amp; self.selectedBit ) != 0
</t>
<t tx="ekr.20080416161551.44">def isTopBitSet (self):

    return ( self.statusBits &amp; self.topBit ) != 0
</t>
<t tx="ekr.20080416161551.45">def isVisited (self):

    return ( self.statusBits &amp; self.visitedBit ) != 0
</t>
<t tx="ekr.20080416161551.46">def isWriteBit (self):

    return (self.statusBits &amp; self.writeBit) != 0
</t>
<t tx="ekr.20080416161551.47">def status (self):

    return self.statusBits
</t>
<t tx="ekr.20080416161551.48">def bodyString (self):

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self._bodyString):
        s = "v.bodyString: Leo internal error: not unicode:" + repr(self._bodyString)
        g.es_print('',s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self._bodyString,g.app.tkEncoding)

getBody = bodyString
</t>
<t tx="ekr.20080416161551.49">def hasBody (self):

    '''Return True if this node contains body text.'''

    s = self.bodyString()

    return s and len(s) &gt; 0
</t>
<t tx="ekr.20080416161551.50">def headString (self):

    """Return the headline string."""

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self._headString):
        s = "Leo internal error: not unicode:" + repr(self._headString)
        g.es_print('',s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self._headString,g.app.tkEncoding)

def cleanHeadString (self):

    v = self
    s = v.headString()
    return g.toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'
</t>
<t tx="ekr.20080416161551.51">def directParents (self):

    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.

    # This is NOT the same as the list of ancestors of the vnode."""

    v = self
    return v.parents

    # v = self

    # if v._parent:
        # return v._parent.t.vnodeList
    # else:
        # return []
</t>
<t tx="ekr.20080416161551.52"></t>
<t tx="ekr.20080416161551.53"></t>
<t tx="ekr.20080416161551.54"># This sets the text in the tnode from the given string.

def setBodyString (self,s,encoding="utf-8"):

    """Set the body text of a tnode to the given string."""

    s = g.toUnicode(s,encoding,reportErrors=True)
    self._bodyString = s

setTnodeText = setBodyString
setBodyText = setBodyString

</t>
<t tx="ekr.20080416161551.55">def setHeadString (self,s,encoding="utf-8"):

    v = self
    s = g.toUnicode(s,encoding,reportErrors=True)
    v._headString = s

def initHeadString (self,s,encoding="utf-8"):

    v = self
    s = g.toUnicode(s,encoding,reportErrors=True)
    v._headString = s
</t>
<t tx="ekr.20080416161551.56">def setSelection (self,start,length):

    self.selectionStart = start
    self.selectionLength = length
</t>
<t tx="ekr.20080416161551.57"></t>
<t tx="ekr.20080416161551.58"># def clearClonedBit (self):

    # self.statusBits &amp;= ~ self.clonedBit
</t>
<t tx="ekr.20080416161551.59">def clearDirty (self):

    self.statusBits &amp;= ~ self.dirtyBit
</t>
<t tx="ekr.20080416161551.60">def clearMarked (self):

    self.statusBits &amp;= ~ self.markedBit
</t>
<t tx="ekr.20080416161551.61">def clearOrphan (self):

    self.statusBits &amp;= ~ self.orphanBit
</t>
<t tx="ekr.20080416161551.62">def clearRichTextBit (self):

    self.statusBits &amp;= ~ self.richTextBit
</t>
<t tx="ekr.20080416161551.63">def clearVisited (self):

    self.statusBits &amp;= ~ self.visitedBit
</t>
<t tx="ekr.20080416161551.64">def clearWriteBit (self):

    self.statusBits &amp;= ~ self.writeBit
</t>
<t tx="ekr.20080416161551.65">def contract(self):

    self.statusBits &amp;= ~ self.expandedBit

    # g.trace(self.statusBits)

def expand(self):

    self.statusBits |= self.expandedBit

    # g.trace(self,g.callers())

    # g.trace(self.statusBits)

def initExpandedBit (self):

    self.statusBits |= self.expandedBit
</t>
<t tx="ekr.20080416161551.66">def initStatus (self, status):

    self.statusBits = status
</t>
<t tx="ekr.20080416161551.67"># def setClonedBit (self):

    # self.statusBits |= self.clonedBit

# def initClonedBit (self, val):

    # if val:
        # self.statusBits |= self.clonedBit
    # else:
        # self.statusBits &amp;= ~ self.clonedBit
</t>
<t tx="ekr.20080416161551.68">def setDirty (self):

    self.statusBits |= self.dirtyBit
</t>
<t tx="ekr.20080416161551.69">def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
</t>
<t tx="ekr.20080416161551.70">def setOrphan (self):

    self.statusBits |= self.orphanBit
</t>
<t tx="ekr.20080416161551.71">def setRichTextBit (self):

    self.statusBits |= self.richTextBit
</t>
<t tx="ekr.20080416161551.72"># This only sets the selected bit.

def setSelected (self):

    self.statusBits |= self.selectedBit
</t>
<t tx="ekr.20080416161551.73">def setVisited (self):

    self.statusBits |= self.visitedBit
</t>
<t tx="ekr.20080416161551.74">def setWriteBit (self):

    self.statusBits |= self.writeBit
</t>
<t tx="ekr.20080416161551.75">def setCloneIndex (self, index):

    self.cloneIndex = index
</t>
<t tx="ekr.20080416161551.76">def setFileIndex (self, index):

    self.fileIndex = index
</t>
<t tx="ekr.20080416161551.77">def computeIcon (self):

    val = 0 ; v = self
    if v.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val

def setIcon (self):

    pass # Compatibility routine for old scripts
</t>
<t tx="ekr.20080416161551.78"># Positions should *never* be saved by the ZOBD.

class position (object):

    '''A class that represents a postion in a tree traversal.'''

    @others</t>
<t tx="ekr.20080416161551.79"></t>
<t tx="ekr.20080416161551.80">def __init__ (self,v,childIndex=0,stack=None,trace=False):

    '''Create a new position with the given childIndex and parent stack.'''

    # __pychecker__ = '--no-argsused' # trace not used.

    # To support ZODB the code must set v._p_changed = 1
    # whenever any mutable vnode object changes.

    self._childIndex = childIndex
    self.v = v

    # New in Leo 4.5: stack entries are tuples (v,childIndex).
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []

    g.app.positions += 1

    # if g.app.tracePositions and trace: g.trace(g.callers())</t>
<t tx="ekr.20080416161551.81">def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    p1 = self

    # g.trace(p1.headString(),p2 and p2.headString())

    if p2 is not None and p1.v == p2.v and p1._childIndex == p2._childIndex and p1.stack == p2.stack:
        return 0 # equal
    else:
        return 1 # not equal

# isEqual and equal are deprecated.

def isEqual (self,p2):

    p1 = self
    return p2 is not None and p1.v == p2.v and p1._childIndex == p2._childIndex and p1.stack == p2.stack

equal = isEqual
</t>
<t tx="ekr.20080416161551.82">def __nonzero__ ( self):

    '''Return True if a position is valid.

    Tests such as 'if p' or 'if not p' are the _only_ correct ways to test
    whether a position p is valid. In particular, tests like 'if p is None' or
    'if p is not None' will not work properly.
    '''

    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None
</t>
<t tx="ekr.20080416161551.83">def __str__ (self):

    # return '&lt;position %s&gt;' % id(self)

    p = self

    if p.v:
        return "&lt;pos %d lvl: %s [%s] %s&gt;" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "&lt;pos %d        [%s] None&gt;" % (id(p),len(p.stack))

__repr__ = __str__
</t>
<t tx="ekr.20080416161551.84">def archivedPosition (self):

    '''Return a representation of a position suitable for use in .leo files.'''

    p = self
    aList = [p2._childIndex for p2 in p.self_and_parents_iter()]
    aList.reverse()
    return aList</t>
<t tx="ekr.20080416161551.85"># Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):

    '''Return an independent copy of a position.'''

    # if g.app.tracePositions: g.trace(g.callers())

    return position(self.v,self._childIndex,self.stack,trace=False)
</t>
<t tx="ekr.20080416161551.86">def childIds (self):

    p = self
    return [id(z) for z in p.v.children]

def dump (self,label=""):

    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label

def dumpLink (self,link):

    return g.choose(link,link,"&lt;none&gt;")

def parentIds (self):

    p = self
    return [id(z) for z in p.v.parents]
</t>
<t tx="ekr.20080416161551.87">def key (self):

    p = self

    vList = [z[0] for z in p.stack]

    return '%s:%s.%s' % (
        id(p.v),
        p._childIndex,
        # ','.join([str(id(v)) for v in p.stack])
        ','.join([str(id(z)) for z in vList])
    )
</t>
<t tx="ekr.20080416161551.88"></t>
<t tx="ekr.20080416161551.89"></t>
<t tx="ekr.20080416161551.90">def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atAutoNodeName            (self): return self.v.atAutoNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtAutoNode            (self): return self.v.isAtAutoNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
</t>
<t tx="ekr.20080416161551.91">def bodyString (self):

    return self.v.bodyString()

def headString (self):

    return self.v.headString()

def cleanHeadString (self):

    return self.v.cleanHeadString()
</t>
<t tx="ekr.20080416161551.92">def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()
</t>
<t tx="ekr.20080416161551.93">def directParents (self):

    return self.v.parents
</t>
<t tx="ekr.20080416161551.94">def childIndex (self):

    return self._childIndex
</t>
<t tx="ekr.20080416161551.95">def numberOfChildren (self):

    p = self
    return len(p.v.children)

    # return self.v.numberOfChildren()

def hasChildren (self):

    p = self
    return len(p.v.children) &gt; 0

hasFirstChild = hasChildren
</t>
<t tx="ekr.20080416161551.96"># These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()

# New in Leo 4.4.3 b2: add c args.
def getVisBack (self,c): return self.copy().moveToVisBack(c)
def getVisNext (self,c): return self.copy().moveToVisNext(c)

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext

# New in Leo 4.4.3:
hasVisBack = visBack
hasVisNext = visNext</t>
<t tx="ekr.20080416161551.97">def hasBack(self):
    p = self
    return p.v and p._childIndex &gt; 0

def hasNext(self):
    p = self
    parent_v = p.parentNode(includeHiddenRootNode=True)
        # Returns None if p.v is None.
    return p.v and parent_v and p._childIndex+1 &lt; len(parent_v.children)

def hasParent(self):
    p = self
    return p.v and len(p.stack) &gt; 0

def hasThreadBack(self):
    p = self
    return p.hasParent() or p.hasBack() # Much cheaper than computing the actual value.
</t>
<t tx="ekr.20080416161551.98">def hasThreadNext (self):

    p = self
    if not p.v: return False

    if p.hasChildren() or p.hasNext(): return True

    n = len(p.stack) -1
    while n &gt;= 0:
        v,childIndex = p.stack[n]
        # See how many children v's parent has.
        if n == 0:
            parent_v = v.context.hiddenRootNode
        else:
            parent_v,junk = p.stack[n-1]
        if len(parent_v.children) &gt; childIndex+1:
            # v has a next sibling.
            return True
        n -= 1
    return False

# def hasThreadNext(self):

    # p = self ; v = p.v
    # if not p.v: return False

    # if v.t._firstChild or v._next:
        # return True
    # else:
        # n = len(p.stack)-1
        # v,n = p.vParentWithStack(v,p.stack,n)
        # while v:
            # if v._next:
                # return True
            # v,n = p.vParentWithStack(v,p.stack,n)
        # return False
</t>
<t tx="ekr.20080416161551.99">def findRootPosition (self):

    p = self.copy()
    while p.hasParent():
        p.moveToParent()
    while p.hasBack():
        p.moveToBack()
    return p</t>
<t tx="ekr.20080416161551.100">def isAncestorOf (self, p2):

    p = self ; v = p.v

    for z in p2.stack:
        v2,junk = z
        if v2 == v:
            return True

    return False

    # # Avoid calling p.copy() or copying the stack.
    # v2 = p2.v ; n = len(p2.stack)-1
        # # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # while v2:
        # if v2 == p.v:
            # return True
        # v2,n = p2.vParentWithStack(v2,p2.stack,n)

    # return False
</t>
<t tx="ekr.20080416161551.101">def isCloned (self):

    return self.v and len(self.v.clones) &gt; 1
</t>
<t tx="ekr.20080416161551.102">def isRoot (self):

    p = self

    return not p.hasParent() and not p.hasBack()
</t>
<t tx="ekr.20080416161551.103">def isVisible (self,c):

    p = self
    trace = True
    limit,limitIsVisible = c.visLimit()
    limit_v = limit and limit.v or None
    if p.v == limit_v:
        if trace: g.trace('*** at limit','limitIsVisible',limitIsVisible,p.v.headString())
        return limitIsVisible

    # It's much easier with a full stack.
    n = len(p.stack)-1
    while n &gt;= 0:
        progress = n
        # v,n = p.vParentWithStack(v,p.stack,n)
        v,junk = p.stack[n]
        if v == limit_v:  # We are at a descendant of limit.
            if trace: g.trace('*** descendant of limit',
                'limitIsVisible',limitIsVisible,
                'limit.isExpanded()',limit.isExpanded(),'v',v)
            if limitIsVisible:
                return limit.isExpanded()
            else: # Ignore the expansion state of @chapter nodes.
                return True
        if not v.isExpanded():
            if trace: g.trace('*** non-limit parent is not expanded',v)
            return False
        n -= 1
        assert progress &gt; n

    return True


# def isVisible (self,c):

    # """Return True if all of a position's parents are expanded."""

    # # v.isVisible no longer exists.
    # p = self ; cc = c.chapterController ; trace = False
    # limit,limitIsVisible = c.visLimit()
    # limit_v = limit and limit.v or None
    # if p.v == limit_v:
        # if trace: g.trace('*** at limit','limitIsVisible',limitIsVisible,p.v.headString())
        # return limitIsVisible

    # # Avoid calling p.copy() or copying the stack.
    # v = p.v ; n = len(p.stack)-1

    # v,n = p.vParentWithStack(v,p.stack,n)
    # while v:
        # if v == limit_v:  # We are at a descendant of limit.
            # if trace: g.trace('*** descendant of limit',
                # 'limitIsVisible',limitIsVisible,
                # 'limit.isExpanded()',limit.isExpanded(),'v',v)
            # if limitIsVisible:
                # return limit.isExpanded()
            # else: # Ignore the expansion state of @chapter nodes.
                # return True
        # if not v.isExpanded():
            # if trace: g.trace('*** non-limit parent is not expanded',v)
            # return False
        # v,n = p.vParentWithStack(v,p.stack,n)

    # return True
</t>
<t tx="ekr.20080416161551.104">def level (p):
    return p.v and len(p.stack) or 0

simpleLevel = level
</t>
<t tx="ekr.20080416161551.105"></t>
<t tx="ekr.20080416161551.106"></t>
<t tx="ekr.20080416161551.107"># Clone bits are no longer used.
# Dirty bits are handled carefully by the position class.

def clearMarked  (self): return self.v.clearMarked()
def clearOrphan  (self): return self.v.clearOrphan()
def clearVisited (self): return self.v.clearVisited()

def contract (self): return self.v.contract()
def expand   (self): return self.v.expand()

def initExpandedBit    (self): return self.v.initExpandedBit()
def initMarkedBit      (self): return self.v.initMarkedBit()
def initStatus (self, status): return self.v.initStatus(status)

def setMarked   (self): return self.v.setMarked()
def setOrphan   (self): return self.v.setOrphan()
def setSelected (self): return self.v.setSelected()
def setVisited  (self): return self.v.setVisited()
</t>
<t tx="ekr.20080416161551.108">def computeIcon (self):

    return self.v.computeIcon()

def setIcon (self):

    pass # Compatibility routine for old scripts
</t>
<t tx="ekr.20080416161551.109">def setSelection (self,start,length):

    return self.v and self.v.setSelection(start,length)
</t>
<t tx="ekr.20080416161551.110">def setTnodeText (self,s,encoding="utf-8"):

    return self.v.setNodeText(s,encoding)
</t>
<t tx="ekr.20080416161551.111"></t>
<t tx="ekr.20080416161551.112">def setHeadString (self,s,encoding="utf-8"):

    p = self
    p.v.initHeadString(s,encoding)
    p.setDirty()

def initHeadString (self,s,encoding="utf-8"):

    p = self
    p.v.initHeadString(s,encoding)
</t>
<t tx="ekr.20080416161551.113">def scriptSetBodyString (self,s,encoding="utf-8"):

    """Update the body string for the receiver.

    Should be called only from scripts: does NOT update body text."""

    self.v.bodyString = g.toUnicode(s,encoding)
</t>
<t tx="ekr.20080416161551.114"></t>
<t tx="ekr.20080416161551.115"># Compatibility routine for scripts.

def clearVisitedInTree (self):

    for p in self.self_and_subtree_iter():
        p.clearVisited()
</t>
<t tx="ekr.20080416161551.116">def clearAllVisitedInTree (self):

    for p in self.self_and_subtree_iter():
        p.v.clearVisited()
        p.v.clearWriteBit()
</t>
<t tx="ekr.20080416161551.117"></t>
<t tx="ekr.20080416161551.118">def clearDirty (self):

    p = self
    p.v.clearDirty()
</t>
<t tx="ekr.20080416161551.119">def findAllPotentiallyDirtyNodes(self):

    p = self 

    # Start with all nodes in the parents
    nodes = []
    newNodes = p.v.parents[:] ### was vnodeList

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.parents:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
                for v3 in v2.parents: ### directParents():
                    if v3 not in nodes and v3 not in addedNodes:
                        addedNodes.append(v3)
        newNodes = addedNodes[:]

    # g.trace(len(nodes))
    return nodes
</t>
<t tx="ekr.20080416161551.120">def inAtIgnoreRange (self):

    """Returns True if position p or one of p's parents is an @ignore node."""

    p = self

    for p in p.self_and_parents_iter():
        if p.isAtIgnoreNode():
            return True

    return False
</t>
<t tx="ekr.20080416161551.121">def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self
    dirtyNodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()

    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)

    dirtyNodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyNodeList) &gt; 0

    for v in dirtyNodeList:
        v.setDirty() # Do not call v.setDirty here!

    return dirtyNodeList</t>
<t tx="ekr.20080416161551.122">def setDirty (self,setDescendentsDirty=True):

    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; dirtyNodeList = []

    # g.trace(p.headString(),g.callers())

    if not p.v.isDirty():
        p.v.setDirty()
        dirtyNodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyNodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyNodeList.extend(dirtyNodeList2)

    return dirtyNodeList
</t>
<t tx="ekr.20080416161551.123">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20080416161551.124">def convertTreeToString (self):

    """Convert a positions  suboutline to a string in MORE format."""

    p = self ; level1 = p.level()

    array = []
    for p in p.self_and_subtree_iter():
        array.append(p.moreHead(level1)+'\n')
        body = p.moreBody()
        if body:
            array.append(body +'\n')

    return ''.join(array)
</t>
<t tx="ekr.20080416161551.125">def moreHead (self, firstLevel,useVerticalBar=False):

    """Return the headline string in MORE format."""

    # useVerticalBar is unused, but it would be useful in over-ridden methods.
    # __pychecker__ = '--no-argsused'

    p = self
    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")

    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())
</t>
<t tx="ekr.20080416161551.126">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  

    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; array = []
    lines = string.split(p.bodyString(),'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s) and s[i] in ('+','-','\\'):
            s = s[:i] + '\\' + s[i:]
        array.append(s)
    return '\n'.join(array)
</t>
<t tx="ekr.20080416161551.127">@ A crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others
</t>
<t tx="ekr.20080416161551.128"># def tnodes_iter(self):

    # """Return all tnode's in a positions subtree."""

    # p = self
    # for p in p.self_and_subtree_iter():
        # yield p.v.t

class tnodes_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def tnodes_iter (self):

    p = self
    return self.tnodes_iter_class(p)
</t>
<t tx="ekr.20080416161551.129">def __init__(self,p):

    # g.trace('p.tnodes_iter.__init','p',p)

    self.first = p.copy()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20080416161551.130">def next(self):

    if self.first:
        self.p = self.first
        self.first = None
    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.p.v

    else: raise StopIteration
</t>
<t tx="ekr.20080416161551.131"># def unique_tnodes_iter(self):

    # """Return all unique tnode's in a positions subtree."""

    # p = self
    # marks = {}
    # for p in p.self_and_subtree_iter():
        # if p.v.t not in marks:
            # marks[p.v.t] = p.v.t
            # yield p.v.t

class unique_tnodes_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def unique_tnodes_iter (self):

    p = self
    return self.unique_tnodes_iter_class(p)
</t>
<t tx="ekr.20080416161551.132">def __init__(self,p):

    # g.trace('p.unique_tnodes_iter.__init','p',p,)

    self.d = {}
    self.first = p.copy()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20080416161551.133">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    while self.p:
        self.p.moveToThreadNext()
        if not self.p:
            break
        elif not self.d.get(self.p.v):
            self.d [self.p.v] = True
            return self.p.v

    else: raise StopIteration
</t>
<t tx="ekr.20080416161551.134"># def vnodes_iter(self):

    # """Return all vnode's in a positions subtree."""

    # p = self
    # for p in p.self_and_subtree_iter():
        # yield p.v

class vnodes_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def vnodes_iter (self):

    p = self
    return self.vnodes_iter_class(p)


</t>
<t tx="ekr.20080416161551.135">def __init__(self,p):

    # g.trace('p.tnodes_iter.__init','p',p)

    self.first = p.copy()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20080416161551.136">def next(self):

    if self.first:
        self.p = self.first
        self.first = None
    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.p.v

    else: raise StopIteration
</t>
<t tx="ekr.20080416161551.137"># def unique_vnodes_iter(self):

    # """Return all unique vnode's in a positions subtree."""

    # p = self
    # marks = {}
    # for p in p.self_and_subtree_iter():
        # if p.v not in marks:
            # marks[p.v] = p.v
            # yield p.v

class unique_vnodes_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def unique_vnodes_iter (self):

    p = self
    return self.unique_vnodes_iter_class(p)
</t>
<t tx="ekr.20080416161551.138">def __init__(self,p):

    # g.trace('p.unique_tnodes_iter.__init','p',p,)

    self.d = {}
    self.first = p.copy()
    self.p = None

def __iter__(self):

    return self
</t>
<t tx="ekr.20080416161551.139">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    while self.p:
        self.p.moveToThreadNext()
        if not self.p:
            break
        elif not self.d.get(self.p.v):
            self.d [self.p.v] = True
            return self.p.v

    else: raise StopIteration
</t>
<t tx="ekr.20080416161551.140">class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=False)

def self_and_subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=True)
</t>
<t tx="ekr.20080416161551.141">def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
</t>
<t tx="ekr.20080416161551.142">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
</t>
<t tx="ekr.20080416161551.143">class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):

    return self.children_iter_class(self,copy)
</t>
<t tx="ekr.20080416161551.144">def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
</t>
<t tx="ekr.20080416161551.145">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
</t>
<t tx="ekr.20080416161551.146">class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=False)

def self_and_parents_iter(self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=True)
</t>
<t tx="ekr.20080416161551.147">def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
</t>
<t tx="ekr.20080416161551.148">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
</t>
<t tx="ekr.20080416161551.149">class siblings_iter_class:

    '''Returns a list of siblings of a position, including the position itself!'''

    @others

def siblings_iter (self,copy=False,following=False):

    return self.siblings_iter_class(self,copy,following)

self_and_siblings_iter = siblings_iter

def following_siblings_iter (self,copy=False):

    return self.siblings_iter_class(self,copy,following=True)
</t>
<t tx="ekr.20080416161551.150">def __init__(self,p,copy,following):

    # We always include p, even if following is True.

    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
</t>
<t tx="ekr.20080416161551.151">def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
</t>
<t tx="ekr.20080416161551.152"></t>
<t tx="ekr.20080416161551.153">def clone (self):

    """Create a clone of back.

    Returns the newly created position."""

    p = self

    p2 = p.copy()
        # Creats an exact copy of p.
        # Does *not* create a new node.
    p2.linkAfter(p)
    p2.v.clones.append({})

    return p2</t>
<t tx="ekr.20080416161551.154"># These used by unit tests and by the group_operations plugin.

def copyTreeAfter(self):
    p = self
    p2 = p.insertAfter()
    p.copyTreeFromSelfTo(p2)
    return p2

def copyTreeFromSelfTo(self,p2):
    p = self
    p2.v.setHeadString(p.headString())
    p2.v.setBodyString(p.bodyString())
    for child in p.children_iter(copy=True):
        child2 = p2.insertAsLastChild()
        child.copyTreeFromSelfTo(child2)
</t>
<t tx="ekr.20080416161551.155">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self):

    """Deletes position p from the outline."""

    p = self
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
</t>
<t tx="ekr.20080416161551.156">def insertAfter (self,v=None):

    """Inserts a new position after self.

    Returns the newly created position."""

    p = self ; context = self.v.context
    p2 = self.copy()

    if not v:
        v = node(context=context,headString="NewHeadline")

    p2.v = v
    p2.v.iconVal = 0
    p2.linkAfter(p)

    return p2
</t>
<t tx="ekr.20080416161551.157">def insertAsLastChild (self,v=None):

    """Inserts a new vnode as the last child of self.

    Returns the newly created position."""

    p = self ; context = self.v.context
    n = p.numberOfChildren()

    if not v:
        v = node(context=context,headString="NewHeadline")

    return p.insertAsNthChild(n,v)
</t>
<t tx="ekr.20080416161551.158">def insertAsNthChild (self,n,v=None):

    """Inserts a new node as the the nth child of self.
    self must have at least n-1 children.

    Returns the newly created position."""

    p = self ; context = self.v.context
    p2 = self.copy()

    if not v:
        v = node(context=context,headString="NewHeadline")

    p2.v = v
    p2.v.iconVal = 0
    p2.linkAsNthChild(p,n)

    return p2
</t>
<t tx="ekr.20080416161551.159">def invalidOutline (self, message):

    p = self

    if p.hasParent():
        node = p.parent()
    else:
        node = p

    g.alert("invalid outline: %s\n%s" % (message,node))
</t>
<t tx="ekr.20080416161551.160">def moveAfter (self,a):

    """Move a position after position a."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAfter(a)

    return p</t>
<t tx="ekr.20080416161551.161">def moveToFirstChildOf (self,parent):

    """Move a position to the first child of parent."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsNthChild(parent,0)
    return p


def moveToLastChildOf (self,parent):

    """Move a position to the last child of parent."""

    p = self # Do NOT copy the position!
    p.unlink()
    n = parent.numberOfChildren()
    p.linkAsNthChild(parent,n)
    return p
</t>
<t tx="ekr.20080416161551.162">def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsNthChild(parent,n)

    return p</t>
<t tx="ekr.20080416161551.163">def moveToRoot (self,oldRoot=None):

    '''Moves a position to the root position.

    Important: oldRoot must the previous root position if it exists.'''

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsRoot(oldRoot)

    return p
</t>
<t tx="ekr.20080416161551.164"># This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self,pv):

    p = self
    result = True # optimists get only unpleasant surprises.
    parent_v = p.parentNode()
    childIndex = p._childIndex

    &lt;&lt; validate parent ivar &gt;&gt;
    &lt;&lt; validate childIndex ivar &gt;&gt;

    # Recursively validate all the children.
    for child in p.children_iter():
        r = child.validateOutlineWithParent(p)
        if not r: result = False

    return result
</t>
<t tx="ekr.20080416161551.165">if parent_v != pv:
    p.invalidOutline( "Invalid parent link: " + repr(parent_v))
</t>
<t tx="ekr.20080416161551.166">if pv:
    if childIndex &lt; 0:
        p.invalidOutline ( "missing childIndex" + childIndex )
    elif childIndex &gt;= pv.numberOfChildren():
        p.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex &lt; 0:
    p.invalidOutline ( "negative childIndex" + childIndex )
</t>
<t tx="ekr.20080416161551.167">@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()
</t>
<t tx="ekr.20080416161551.168">def moveToBack (self):

    """Move self to its previous sibling."""

    p = self ; n = p._childIndex

    parent_v = p.parentNode(includeHiddenRootNode = True)
        # Returns None if p.v is None.

    if parent_v and p.v and n &gt; 0:
        p._childIndex -= 1
        p.v = parent_v.children[n-1]
    else:
        p.v = None

    return p
</t>
<t tx="ekr.20080416161551.169">def moveToFirstChild (self):

    """Move a position to it's first child's position."""

    p = self

    if p.v and p.v.children:
        p.stack.append((p.v,p._childIndex),)
        p.v = p.v.children[0]
        p._childIndex = 0
    else:
        p.v = None

    return p

    # if p:
        # child = p.v.t._firstChild
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
                # # g.trace("push",p.v,p)
            # p.v = child
        # else:
            # p.v = None

    # return p

</t>
<t tx="ekr.20080416161551.170">def moveToLastChild (self):

    """Move a position to it's last child's position."""

    p = self

    if p.v and p.v.children:
        p.stack.append((p.v,p._childIndex),)
        n = len(p.v.children)
        p.v = p.v.children[n-1]
        p._childIndex = n-1
    else:
        p.v = None

    return p

    # if p:
        # if p.v.t._firstChild:
            # child = p.v.lastChild()
            # if p.isCloned():
                # p.stack.append(p.v)
                # # g.trace("push",p.v,p)
            # p.v = child
        # else:
            # p.v = None

    # return p
</t>
<t tx="ekr.20080416161551.171">def moveToLastNode (self):

    """Move a position to last node of its tree.

    N.B. Returns p if p has no children."""

    p = self

    # Huge improvement for 4.2.
    while p.hasChildren():
        p.moveToLastChild()

    return p
</t>
<t tx="ekr.20080416161551.172">def moveToNext (self):

    """Move a position to its next sibling."""

    p = self ; n = p._childIndex

    parent_v = p.parentNode(includeHiddenRootNode = True)
        # Returns None if p.v is None.

    if p.v and parent_v and len(parent_v.children) &gt; n+1:
        p._childIndex = n+1
        p.v = parent_v.children[n+1]
    else:
        p.v = None

    return p
</t>
<t tx="ekr.20080416161551.173">def moveToNodeAfterTree (self):

    """Move a position to the node after the position's tree."""

    p = self

    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
</t>
<t tx="ekr.20080416161551.174">def moveToNthChild (self,n):

    p = self

    if p.v and len(p.v.children) &gt; n:
        p.stack.append((p.v,p._childIndex),)
        p.v = p.v.children[n]
        p._childIndex = n
    else:
        p.v = None

    return p

    # if p:
        # child = p.v.nthChild(n) # Must call vnode method here!
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
                # # g.trace("push",p.v,p)
            # p.v = child
        # else:
            # p.v = None

    # return p
</t>
<t tx="ekr.20080416161551.175">def moveToParent (self):

    """Move a position to its parent position."""

    p = self

    if p.v and p.stack:
        p.v,p._childIndex = p.stack.pop()
    else:
        p.v = None

    return p

    # if not p: return p

    # if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        # p.v = p.v._parent
    # elif p.stack:
        # p.v = p.stack.pop()
    # else:
        # p.v = None
    # return p
</t>
<t tx="ekr.20080416161551.176">def moveToThreadBack (self):

    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
</t>
<t tx="ekr.20080416161551.177">def moveToThreadNext (self):

    """Move a position to threadNext position."""

    p = self

    if p.v:
        if p.v.children:
            p.moveToFirstChild()
        elif p.hasNext():
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.hasNext():
                    p.moveToNext()
                    break #found
                p.moveToParent()
            # not found.

    return p

    # if p:
        # if p.v.t._firstChild:
            # p.moveToFirstChild()
        # elif p.v._next:
            # p.moveToNext()
        # else:
            # p.moveToParent()
            # while p:
                # if p.v._next:
                    # p.moveToNext()
                    # break #found
                # p.moveToParent()
            # # not found.

    # return p
</t>
<t tx="ekr.20080416161551.178">def moveToVisBack (self,c):

    """Move a position to the position of the previous visible node."""

    p = self ; limit,limitIsVisible = c.visLimit() ; trace = False

    def checkLimit (p):
        '''Return done, return-val'''
        if limit:
            if limit == p:
                if trace: g.trace('at limit',p)
                return True,g.choose(limitIsVisible and p.isVisible(c),p,None)
            elif limit.isAncestorOf(p):
                return False,None
            else:
                if trace: g.trace('outside limit tree')
                return True,None
        else:
            return False,None

    while p:
        # Short-circuit if possible.
        back = p.back()
        if back and (not back.hasChildren() or not back.isExpanded()):
            p.moveToBack()
        else:
            p.moveToThreadBack()
        if p:
            if trace: g.trace('*p',p.headString())
            done,val = checkLimit(p)
            if done: return val
            if p.isVisible(c):
                return p
    else:
        # assert not p.
        return p</t>
<t tx="ekr.20080416161551.179">def moveToVisNext (self,c):

    """Move a position to the position of the next visible node."""

    p = self ; limit,limitIsVisible = c.visLimit() ; trace = False

    def checkLimit (p):
        '''Return done, return-val'''
        if limit:
            # Unlike moveToVisBack, being at the limit does not terminate.
            if limit == p:
                return False, None
            elif limit.isAncestorOf(p):
                return False,None
            else:
                if trace: g.trace('outside limit tree')
                return True,None
        else:
            return False,None

    while p:
        # Short-circuit if possible.
        if p.hasNext() and (not p.hasChildren() or not p.isExpanded()):
            p.moveToNext()
        else:
            p.moveToThreadNext()
        if p:
            if trace: g.trace('*p',p.headString())
            done,val = checkLimit(p)
            if done: return val
            if p.isVisible(c):
                return p.copy()
    else:
        # assert not p.
        return p</t>
<t tx="ekr.20080416161551.180">def parentNode (self,includeHiddenRootNode=False):

    '''return a new position representing the parent position.

    This is always inexpensive.'''

    p = self

    if p.v:
        data = p.stack and p.stack[-1]
        if data:
            v, junk = data
            return v
        elif includeHiddenRootNode:
            return p.v.context.hiddenRootNode
        else:
            return None
    else:
        return None
</t>
<t tx="ekr.20080416161551.181"># These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
</t>
<t tx="ekr.20080416161551.182">def linkAfter (self,p_after):

    '''Link self after p_after.'''

    p = self
    parent_v = p_after.parentNode(includeHiddenRootNode=True)
        # Returns None if p.v is None
    assert(p.v)
    assert(parent_v)

    # Add p.v to parent_v's children.
    parent_v.children.insert(p_after._childIndex+1,p.v)
    p.stack = p_after.stack[:]
    p._childIndex = p_after._childIndex + 1

    if not parent_v in p.v.parents:
        p.v.parents.append(parent_v)
        p.v._p_changed = 1

# def linkAfter (self,after):

    # """Link self after v."""

    # p = self
    # # g.trace(p,after)

    # p.stack = after.stack[:]
    # p.v._parent = after.v._parent

    # # Add v to it's tnode's vnodeList.
    # if p.v not in p.v.t.vnodeList:
        # p.v.t.vnodeList.append(p.v)
        # p.v.t._p_changed = 1 # Support for tnode class.

    # p.v._back = after.v
    # p.v._next = after.v._next

    # after.v._next = p.v

    # if p.v._next:
        # p.v._next._back = p.v

    # if 0:
        # g.trace('-'*20,after)
        # p.dump(label="p")
        # after.dump(label="back")
        # if p.hasNext(): p.next().dump(label="next")
</t>
<t tx="ekr.20080416161551.183">def linkAsNthChild (self,parent,n):

    p = self
    parent_v = parent.v
    parent_v.children.insert(n,p.v)
    p.stack = parent.stack[:]
    p.stack.append((p.v,p._childIndex),)
    p._childIndex = n

    if not parent_v in p.v.parents:
        p.v.parents.append(parent_v)
        p.v._p_changed = 1

# def linkAsNthChild (self,parent,n):

    # """Links self as the n'th child of parent."""

    # # g.trace(self,parent,n,parent.v)

    # p = self

    # # Recreate the stack using the parent.
    # p.stack = parent.stack[:]

    # if parent.isCloned():
        # p.stack.append(parent.v)

    # p.v._parent = parent.v

    # # Add v to it's tnode's vnodeList.
    # if p.v not in p.v.t.vnodeList:
        # p.v.t.vnodeList.append(p.v)
        # p.v.t._p_changed = 1 # Support for tnode class.

    # if n == 0:
        # child1 = parent.v.t._firstChild
        # p.v._back = None
        # p.v._next = child1
        # if child1:
            # child1._back = p.v
        # parent.v.t._firstChild = p.v
    # else:
        # prev = parent.nthChild(n-1) # zero based
        # assert(prev)
        # p.v._back = prev.v
        # p.v._next = prev.v._next
        # prev.v._next = p.v
        # if p.v._next:
            # p.v._next._back = p.v

    # if 0:
        # g.trace('-'*20)
        # p.dump(label="p")
        # parent.dump(label="parent")
</t>
<t tx="ekr.20080416161551.184">def linkAsRoot (self,oldRoot):

    """Link self as the root node."""

    p = self ; v = p.v
    assert(p.v)

    hiddenRootNode = p.v.context.hiddenRootNode

    if oldRoot: oldRootNode = oldRoot.v
    else:       oldRootNode = None

    p.stack = [] # Clear the stack.

    # Add the hidden root node to its parents.
    if hiddenRootNode not in v.parents:
        v.parents.append(hiddenRootNode)
        v._p_changed = 1

    hiddenRootNode.children.append(p.v)

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot:
        hiddenRootNode.children.append(oldRootNode)

    # p = self ; v = p.v
    # if oldRoot: oldRootNode = oldRoot.v
    # else:       oldRootNnode = None

    # p.stack = [] # Clear the stack.

    # # Clear all links except the child link.
    # v._parent = None
    # v._back = None
    # v._next = oldRootVnode

    # # Add v to it's tnode's vnodeList.
    # if v not in v.t.vnodeList:
        # v.t.vnodeList.append(v)
        # v.t._p_changed = 1 # Support for tnode class.

    # # Link in the rest of the tree only when oldRoot != None.
    # # Otherwise, we are calling this routine from init code and
    # # we want to start with a pristine tree.
    # if oldRoot:
        # oldRoot.v._back = v

    # # p.dump(label="root")
</t>
<t tx="ekr.20080416161551.185">def unlink (self):

    p = self
    n = p._childIndex
    parent_v = p.parentNode(includeHiddenRootNode=True)
        # returns None if p.v is None
    assert(p.v)
    assert(parent_v)

    del parent_v.children[n:n+1]

    if parent_v in p.v.parents:
        p.v.parents.remove(parent_v)

# def unlink (self):

    # """Unlinks a position p from the tree before moving or deleting.

    # The p.v._fistChild link does NOT change."""

    # # Warning: p.parent() is NOT necessarily the same as p.v._parent!

    # p = self ; v = p.v

    # # g.trace('p.v._parent',p.v._parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)

    # # Remove v from it's tnode's vnodeList.
    # vnodeList = v.t.vnodeList
    # if v in vnodeList:
        # vnodeList.remove(v)
        # v.t._p_changed = 1 # Support for tnode class.
    # assert(v not in vnodeList)

    # # Reset the firstChild link in its direct father.
    # if p.v._parent:
        # if 0: # This can fail.  I have no idea why it was present.
            # assert(p.v and p.v._parent in p.v.directParents())
        # if p.v._parent.t._firstChild == v:
            # #g.trace('resetting _parent.v.t._firstChild to',v._next)
            # p.v._parent.t._firstChild = v._next
    # else:
        # parent = p.parent()
        # if parent:
            # if 0: # This can fail.  I have no idea why it was present.
                # assert(parent.v in p.v.directParents())
            # if parent.v.t._firstChild == v:
                # #g.trace('resetting parent().v.t._firstChild to',v._next)
                # parent.v.t._firstChild = v._next

    # # Do NOT delete the links in any child nodes.

    # # Clear the links in other nodes.
    # if v._back: v._back._next = v._next
    # if v._next: v._next._back = v._back

    # # Unlink _this_ node.
    # v._parent = v._next = v._back = None

    # if 0:
        # g.trace('-'*20)
        # p.dump(label="p")
        # if parent: parent.dump(label="parent")</t>
<t tx="ekr.20080416161551.187"></t>
<t tx="ekr.20080416161551.188"></t>
<t tx="ekr.20080416161551.189">@nocolor

- Replace calls to v.linkAfter by calls to v.linkAsNthChild.
    - This happens in getVnodes (clipboard cut/paste)

- Rewrite code that uses v._parent:
    - Done in sax read code.
    - Todo: in undo.
    
Later:
    
- Replace p.equal(p2) and p.isEqual(p2) by p1 == p2
    (Can be done later, or not at all).</t>
<t tx="ekr.20080416161551.199">@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()
</t>
<t tx="ekr.20080416161551.200">def moveToBack (self):

    """Move self to its previous sibling."""

    p = self ; n = p._childIndex

    parent_v = p.parentNode(includeHiddenRootNode = True)
        # Returns None if p.v is None.

    if parent_v and p.v and n &gt; 0:
        p._childIndex -= 1
        p.v = parent_v.children[n-1]
    else:
        p.v = None

    return p
</t>
<t tx="ekr.20080416161551.201">def moveToFirstChild (self):

    """Move a position to it's first child's position."""

    p = self

    if p.v and p.v.children:
        p.stack.append((p.v,p._childIndex),)
        p.v = p.v.children[0]
        p._childIndex = 0
    else:
        p.v = None

    return p

    # if p:
        # child = p.v.t._firstChild
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
                # # g.trace("push",p.v,p)
            # p.v = child
        # else:
            # p.v = None

    # return p

</t>
<t tx="ekr.20080416161551.202">def moveToLastChild (self):

    """Move a position to it's last child's position."""

    p = self

    if p.v and p.v.children:
        p.stack.append((p.v,p._childIndex),)
        n = len(p.v.children)
        p.v = p.v.children[n-1]
        p._childIndex = n-1
    else:
        p.v = None

    return p

    # if p:
        # if p.v.t._firstChild:
            # child = p.v.lastChild()
            # if p.isCloned():
                # p.stack.append(p.v)
                # # g.trace("push",p.v,p)
            # p.v = child
        # else:
            # p.v = None

    # return p
</t>
<t tx="ekr.20080416161551.203">def moveToLastNode (self):

    """Move a position to last node of its tree.

    N.B. Returns p if p has no children."""

    p = self

    # Huge improvement for 4.2.
    while p.hasChildren():
        p.moveToLastChild()

    return p
</t>
<t tx="ekr.20080416161551.204">def moveToNext (self):

    """Move a position to its next sibling."""

    p = self ; n = p._childIndex

    parent_v = p.parentNode(includeHiddenRootNode = True)
        # Returns None if p.v is None.
    if not p.v: g.trace('parent_v',parent_v,'p.v',p.v)

    if p.v and parent_v and len(parent_v.children) &gt; n+1:
        p._childIndex = n+1
        p.v = parent_v.children[n+1]
    else:
        p.v = None

    return p
</t>
<t tx="ekr.20080416161551.205">def moveToNodeAfterTree (self):

    """Move a position to the node after the position's tree."""

    p = self

    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
</t>
<t tx="ekr.20080416161551.206">def moveToNthChild (self,n):

    p = self

    if p.v and len(p.v.children) &gt; n:
        p.stack.append((p.v,p._childIndex),)
        p.v = p.v.children[n]
        p._childIndex = n
    else:
        p.v = None

    return p

    # if p:
        # child = p.v.nthChild(n) # Must call vnode method here!
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
                # # g.trace("push",p.v,p)
            # p.v = child
        # else:
            # p.v = None

    # return p
</t>
<t tx="ekr.20080416161551.207">def moveToParent (self):

    """Move a position to its parent position."""

    p = self

    if p.v and p.stack:
        p.v,p._childIndex = p.stack.pop()
    else:
        p.v = None

    return p

    # if not p: return p

    # if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        # p.v = p.v._parent
    # elif p.stack:
        # p.v = p.stack.pop()
    # else:
        # p.v = None
    # return p
</t>
<t tx="ekr.20080416161551.208">def moveToThreadBack (self):

    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
</t>
<t tx="ekr.20080416161551.209">def moveToThreadNext (self):

    """Move a position to threadNext position."""

    p = self

    if p.v:
        if p.v.children:
            p.moveToFirstChild()
        elif p.hasNext():
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.hasNext():
                    p.moveToNext()
                    break #found
                p.moveToParent()
            # not found.

    return p

    # if p:
        # if p.v.t._firstChild:
            # p.moveToFirstChild()
        # elif p.v._next:
            # p.moveToNext()
        # else:
            # p.moveToParent()
            # while p:
                # if p.v._next:
                    # p.moveToNext()
                    # break #found
                # p.moveToParent()
            # # not found.

    # return p
</t>
<t tx="ekr.20080416161551.210">def moveToVisBack (self,c):

    """Move a position to the position of the previous visible node."""

    p = self ; limit,limitIsVisible = c.visLimit() ; trace = False

    def checkLimit (p):
        '''Return done, return-val'''
        if limit:
            if limit == p:
                if trace: g.trace('at limit',p)
                return True,g.choose(limitIsVisible and p.isVisible(c),p,None)
            elif limit.isAncestorOf(p):
                return False,None
            else:
                if trace: g.trace('outside limit tree')
                return True,None
        else:
            return False,None

    while p:
        # Short-circuit if possible.
        back = p.back()
        if back and (not back.hasChildren() or not back.isExpanded()):
            p.moveToBack()
        else:
            p.moveToThreadBack()
        if p:
            if trace: g.trace('*p',p.headString())
            done,val = checkLimit(p)
            if done: return val
            if p.isVisible(c):
                return p
    else:
        # assert not p.
        return p</t>
<t tx="ekr.20080416161551.211">def moveToVisNext (self,c):

    """Move a position to the position of the next visible node."""

    p = self ; limit,limitIsVisible = c.visLimit() ; trace = False

    def checkLimit (p):
        '''Return done, return-val'''
        if limit:
            # Unlike moveToVisBack, being at the limit does not terminate.
            if limit == p:
                return False, None
            elif limit.isAncestorOf(p):
                return False,None
            else:
                if trace: g.trace('outside limit tree')
                return True,None
        else:
            return False,None

    while p:
        # Short-circuit if possible.
        if p.hasNext() and (not p.hasChildren() or not p.isExpanded()):
            p.moveToNext()
        else:
            p.moveToThreadNext()
        if p:
            if trace: g.trace('*p',p.headString())
            done,val = checkLimit(p)
            if done: return val
            if p.isVisible(c):
                return p.copy()
    else:
        # assert not p.
        return p</t>
<t tx="ekr.20080416161551.212">def parentNode (self,includeHiddenRootNode=False):

    '''return a new position representing the parent position.

    This is always inexpensive.'''

    p = self

    if p.v:
        data = p.stack and p.stack[-1]
        if data:
            v, junk = data
            return v
        elif includeHiddenRootNode:
            return p.v.context.hiddenRootNode
        else:
            return None
    else:
        return None
</t>
<t tx="ekr.20080416161551.216">def linkAsRoot (self,oldRoot):

    """Link self as the root node."""

    p = self
    assert(p.v)

    hiddenRootNode = p.v.context.hiddenRootNode

    if oldRoot: oldRootNode = oldRoot.v
    else:       oldRootNode = None

    # Init the ivars.
    p.stack = []
    p._childIndex = 0

    # Add p.v to it's tnode's vnodeList.
    # if p.v not in hiddenRootNode.t.vnodeList:
        # hiddenRootNode.t.vnodeList.append(p.v)
        # hiddenRootNode.t._p_changed = 1 # Support for tnode class.

    # Init p.v.t.vnodeList
    p.v.t.vnodeList = [p.v]

    # Init p.v.parents to the hidden root node.
    p.v.parents = [hiddenRootNode]
    p.v._p_changed = 1

    # Init hiddenRootNode's children to p.v.
    hiddenRootNode.children = [p.v]

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot:
        hiddenRootNode.children.append(oldRootNode)
        oldRootNode.parents = [hiddenRootNode]
        oldRootNode.t.vnodeList = [oldRootNode]

    # p = self ; v = p.v
    # if oldRoot: oldRootNode = oldRoot.v
    # else:       oldRootNnode = None

    # p.stack = [] # Clear the stack.

    # # Clear all links except the child link.
    # v._parent = None
    # v._back = None
    # v._next = oldRootVnode

    # # Add v to it's tnode's vnodeList.
    # if v not in v.t.vnodeList:
        # v.t.vnodeList.append(v)
        # v.t._p_changed = 1 # Support for tnode class.

    # # Link in the rest of the tree only when oldRoot != None.
    # # Otherwise, we are calling this routine from init code and
    # # we want to start with a pristine tree.
    # if oldRoot:
        # oldRoot.v._back = v

    # # p.dump(label="root")
</t>
<t tx="ekr.20080416161551.223"></t>
<t tx="ekr.20080416161551.224"></t>
<t tx="ekr.20080416161551.225"></t>
<t tx="ekr.20080417064246.1">@nocolor

- Rewrote some code in createThinChild4 to v.children

- Create c.hiddenRootNode in Commands ctor.

- readSaxFile now sets c.hiddenRootNode.children:
    - createSaxVnodes now return the entire children list.

- Added context keyword arg to vnode ctor.
    - Done in core.
    - Done in plugins.

- Changed t.headString to t._headString
    - Done in core.
    - Done in plugins.

- Change t.bodyString to t._bodyString
    - Done in core.
    - Done in plugins.

- Removed all but first arg from position ctor.
    - Done in core.
    - Done in plugins.</t>
<t tx="ekr.20080417064246.2"></t>
<t tx="ekr.20080417064246.3">if 0:
    @others

</t>
<t tx="ekr.20080417100013.1"></t>
</tnodes>
</leo_file>
