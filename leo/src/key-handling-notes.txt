#@+leo-ver=4-thin
#@+node:ekr.20080508083640.10:@thin key-handling-notes.txt
#@+all
#@+node:ekr.20080508083640.11:Notes
#@+node:ekr.20080509145618.2:Old/obsolete
#@+node:ekr.20080508083640.12:Requests (old)
@nocolor

Some of the features I've grown to like with VIM are:

- search-and-replace within the current selection,
- easy keyboard navigation
- and to some extent macro recording and running.
#@-node:ekr.20080508083640.12:Requests (old)
#@+node:ekr.20080508083640.13:Design post (old)
@nocolor

http://sourceforge.net/forum/forum.php?thread_id=1800079&forum_id=10226

Recent posts have discussed @menu trees and resolving cvs conflicts. The third of my recent ruminations concerns adding support for vim-like key bindings. 

Earlier work involving input modes (@mode nodes in settings file) probably is not completely sufficient to implement plain-key key bindings in a way that would truly be vim-like. 

Most of the issues are implementation issues: Leo's key-handling code is very complicated. The trick is to handle both vim and emacs styles compatibly. 

The user must be able to specify vim-like key bindings without using @mode nodes. That is, top-level vim key bindings must always be available. Vim has an enormous number of key bindings: the user must be able to specify which are in effect. 

My strategy will be as follows: 

1. Create enter-vim-mode and exit-vim-mode commands, and create the setting: 

@bool vim-mode-by-default = False 

This will allow the user to specify vim mode as the default mode if desired. 

2. Create **vim-edit** commands as needed in order to handler user interaction. For example, dd deletes the present line while d5 deletes 5 lines. Rather than trying to simulate this effect using the present mechanisms, the vim-delete command will prompt for the number of characters or lines to delete. 

Give the complex nature of vims c and d commands (and others) it will probably be necessary to create a vim-edit class in leoEditCommands.py. This class will handle all the ways of specifying a range of characters to which the various commands will apply. It's not clear exactly how much work will be needed, but my guess is that it will, in fact, be easiest to handle vim-like interactions with new code. 

3. Vim's ':' command will simply invoke Leo's minibuffer. This isn't precisely the same as Vim's status line: it is significantly better. Otoh, we will want a way to simulate the actual spelling of vim's ':' commands. Possible @abbreviation nodes can be pressed into service. 

4. Internally, it will be quite a trick to allow top-level vim-like plain-key bindings in all text widgets. I'm not sure how to do this, but it is essential. 

I am quite eager to get something truly vim-like working. It promises to increase my editing speed substantially. It also should appeal strongly to present vim users. 
#@nonl
#@-node:ekr.20080508083640.13:Design post (old)
#@+node:ekr.20080508094751.1:(obsolete) Auto-change panes  OR unified body/tree panes
@nocolor

The Huge Focus Aha makes this obsolete.

The idea: if a key binding is only in effect for one pane, and we get the
binding, maybe we should change to the pane first!

Examples:

copy-node: auto-select tree pane.
copy_text (when not editing a headline): auto-select body text.


Unified body/tree panes

Up/down arrows move between headline and body panes.
#@nonl
#@-node:ekr.20080508094751.1:(obsolete) Auto-change panes  OR unified body/tree panes
#@-node:ekr.20080509145618.2:Old/obsolete
#@+node:ekr.20080508083640.14:Posting re vim bindings
@nocolor

> I'm looking forward to this.

Excellent.  You can help with the testing :-)

Leo looks like a perfect match for the vim approach.  Indeed, vim typically uses a 1 or 2 level concatenation scheme (preceded by a repeat count).  This is kinda like a utf-8 encoding :-)  That is, it is a variable-length encoding of the command.

This is a very powerful approach, one that vim doesn't really exploit (because it doesn't need to). But Leo absolutely needs this power of some extra levels.  Something like this:

i input mode

f focus commands
..fb focus to body
..fo focus to outline
..fl focus to log
..ft toggle body pane focus

o outline commands
..om outline move, i.e., actually move the nodes.
..og outline go, i.e., select nodes without changing the outline
..od outline delete
..oh outline edit headline

s search commands
..so search options
...soi toggle ignore-case checkbox
...sow toggle word checkbox
...etc!
..st search using search tab
..sf forward incremental search
..sb backward incremental search

x minibuffer commands

w file commands
..ws save outline
..wq quit

escape: universal escape, like ctrl-g now.

Do you see?  Just one extra level allows 10+ times the number of key bindings.  This is a perfect match for Leo's complex environment.

Naturally, Leo will allow the user to specify these bindings using nodes in the @settings tree. Indeed, this is truly an exciting prospect.

Edward

P.S.  I've glossed over the details of which single characters (like d for delete character) should be reserved for common editing and cursor-movement commands.  That's the beauty of creating these bindings with user settings: no need to argue :-)  And that's the beauty of arbitrarily deep key binding trees: there are plenty of keys to go around.

EKR
#@-node:ekr.20080508083640.14:Posting re vim bindings
#@+node:ekr.20080508083640.16:Posting: New key handling
@nocolor

The "Huge Focus Aha", namely that focus never needs to be in the
outline pane, continues to clarify and guide my thinking:

1. There is no need for per-pane key bindings.  I'll be discussing
this in more detail as we go along.  This is itself a major
simplification.

2. Ville has discovered the heart of the matter: most modes should
continue until an unknown character is seen.  An **unknown character
for a mode** is a character for which no explicit binding has been
made for that mode.  Leo will enter a **main** (or default) mode when
the user types an unknown (unbound) character in a mode.

The main mode would be normal text-input mode for the emacs-like
bindings, and a "command" mode for vim-like bindings.  Leo already
allows the user to specify emacs-like or vim-like defaults via various
settings.  I forget the details, but they don't much matter in this
discussion.

There are a few complications with "stay in the mode until an unknown
character is seen".

A. Some modes, like the minibuffer, and vim input mode, will allow the
user to enter any unicode character.  Thus, we can't just list the
"known" bindings of a mode--there can be too many.  To handle this, we
need to create the distinction between **input modes** and **command
modes**.  Input modes continue until another mode is explicitly
requested.  Command modes continue until an unknown (unbound) key
sequence is seen.

B. Several modes, including the minibuffer and search modes, contain
implicit bindings for keys like <tab>, <return> and <backspace>.
Indeed, the user probably need not specify any bindings explicitly for
such modes.  This creates some interesting complications however.  Let
us distinguish between *text-editing* commands and *non-text-editing*
commands.  'beginning-of-line' is a text editing command; 'save-
outline' is not.  Commands such as sort-lines could be called text-
editing commands, but they make no sense in a single-line environment
such as the minibuffer or search/replace commands, so let us
tentatively call them non-text-editing commands, or rather **multi-
line-editing** commands.

As I write this, I realize that the distinction between text-editing
and non-text-editing commands implicitly assumes emacs-like *bindings*
for commands.  In the vim-like world of plain-key bindings, we could
imagine *temporarily* entering vim-command mode in the minibuffer, and
then *returning* to the minibuffer-insert-mode after the temporary vim-
command mode finished.  This could cause complications.  In general,
I'd rather stay away from a stack of modes, but only experimentation
will show what is needed.

C. Regardless of other details, some **basic editing commands/
bindings** surely must be supported in the minibuffer and search
commands:  cut, copy, paste, arrow-keys move the cursor, shift-arrow
keys extend the selection.  In emacs-like operation we can throw in
all text-editing bindings at essentially no cost.  In vim-like
operation, we can use the basic bindings, but more complex commands
would seem to require nested modes.

But the main point is that special-purpose modes will probably use
some reasonable, standard defaults based on settings for *other*
modes, plus some standard keys.  In other words, it may be possible to
dispense with explicit bindings for the minibuffer, etc.

That being so, we are left with a simple scheme:

1. Bindings apply **everywhere** in several senses.  They apply to all
panes, and bindings for text-editing commands apply in all text
widgets: the minibuffer, body pane, log pane, headlines, etc.

2. Binding unknown in a mode terminate the mode and return to the main
or default mode.

3. Non-text-editing commands, including multi-line-editing commands,
should terminate **single-line modes** such as minibuffer commands
unless a special case explicitly exists for them.

4. Bindings for **Leo-provided modes** will be created automatically
using the user's bindings for text-editing commands, plus special
characters like <tab>, <return> and <backspace>.  Leo provided modes
are the initial minibuffer mode and secondary minibuffer modes such
entering search patterns.

5. The only complication is possibly allowing vim-like command sub-
modes of single-line modes.

The code in k.masterKeyHandler is in the back of my mind as I write
this.  With luck, the new scheme will be considerably simpler than the
old, while being more flexible and more general.  Note that the way
bindings are actually specified is an entirely separate issue, which
is good because that logic is horrible.  Eliminating per-pane bindings
will help some, but not a lot.

We may want to allow the user to specify per-pane bindings as before,
but the bindings will be ignored.  But as I write this it seems like
this could cause a great deal of confusion.  Perhaps it will be better
to outlaw the old syntax entirely, or at least issue warnings that per-
pane bindings no longer have any effect.

This is all very preliminary.  I've written no code.  Your comments
are welcome now.
#@-node:ekr.20080508083640.16:Posting: New key handling
#@+node:ekr.20080509064108.9:Posting: More design notes
@nocolor

On May 7, 7:05 pm, "Edward K. Ream" <edream...@gmail.com> wrote:

> This post will be a "thinking out loud" discussion of the new design.

I've just spent some time drawing state diagrams that indicate transitions between various states.  It turned out to be more simple than I had feared.

> As I write this, I realize that the distinction between text-editing
> and non-text-editing commands implicitly assumes emacs-like *bindings*
> for commands.  

No.  The distinction has nothing to do with bindings, as my post earlier today shows.  In fact, after seeing the final state diagrams, my intention is to be able to support *both* emacs-like and vim-like bindings simultaneously.  Actually, Leo can already do this, or it could if @mode bindings actually worked :-)

The more useful distinction is between commands that change modes and commands that stay in the same mode.  This became clearer as I played with the diagrams.

Ok, let's see if I can summarize what the diagrams are trying to tell me without tying myself up in knots :-)

1. *All* modes are minibuffer modes.  That is, the present mode will always be indicated at the start of the minibuffer.  It would not be good to use the status area because the UNL plugin overwrites the status when changing nodes.

However, not all modes need actually *use* (alter) the minibuffer.  For example, a user-defined outline mode might provide bindings for just the arrow and shift arrow keys.  Nothing the user types would appear in the minibuffer during that mode.

2. @mode nodes define user modes.  These nodes can specify the "prompt" that will appear in the minibuffer while the node is active. For example:

@mode <mode name> @prompt = <prompt>

When a mode is active the minibuffer will contain as a **minibuffer prefix**:

<mode name> mode: <prompt>

As always, the prefix is protected: the user can not erase it by backspacing.

3. Binding are actually a completely separate topic from how Leo handles modes.  However, modes can create "virtual key sequences" that represent a command.  It would be extremely complex to generate those virtual key sequences in menus with the present code base--and probably for *any* version of Leo's config code.  To handle this, @item nodes in @settings trees could specify a "hint" that would look like a real menu shortcut.  Leo would completely ignore such hints: they would be only for cosmetic purposes.  Like this;

@item move-outline-left @hint = A-S-Left or [cmd]o,S-Left

The hint can be any string that makes sense to you.  In this case it signifies that there are two possible ways move an outline left: Alt-Shift-Left in any mode or type o followed by Shift-Left in command mode.

The advantage of this scheme is its simplicity and generality.  The disadvantage is that you, the user, must ensure that the hints make sense and are up-to-date.  I think it will turn out to be very handy.

4. With these preliminaries in place, the actual scheme for switching between modes is relatively straightforward:

A: The default (main) mode will be insert-mode for emacs-like operation and command-mode for vim-like operation.

B: In insert mode, edit-commands executed via menus or by key bindings will cause Leo to remain in insert mode.  All other commands transfer to other modes, with the default mode as the default.  So for emacs-like operation, control (focus) typically stays in the body pane, while for vim-like operation control typically stays in the minibuffer.

BTW, now that all modes can be considered minibuffer modes, we need to distinguish between modes that insert unbound keys (either in the present text pane or in the minibuffer) and those that don't.  For those modes that don't, any unbound key will transfer to the default mode.

C: In general (there may be smallish exceptions), a key stroke that would invoke an unknown command causes control to go to the default mode.

D: In user modes, all commands transfer to the default mode except for explicitly declared "stay-in-this-mode" commands.  This mechanism is already in place.

In short, key **bindings** no longer matter to k.masterKeyHandler.  All that matters is the command that is about to be executed.  This is a very nice simplification: all the old pane-specific logic should just go away.  Actually, it seems like an important Aha.

I now have hopes of putting this all in place in just a few days.

BTW, none of this is a "requirements specification".  That's not how I work :-)  What will emerge will be the result of playing with the code and seeing what works and what doesn't.

Edward
#@nonl
#@-node:ekr.20080509064108.9:Posting: More design notes
#@+node:ekr.20080509145618.3:New vim-like bindings
@nocolor

top-level commands

b/B enter-backward-find-text-mode (quick find)
d enter-delete-mode
f/F enter-find-text-mode (quick find)
i enter-insert-mode
o enter-outline-mode
r enter-replace-mode
s enter-search-mode
t enter-toggle-options-mode
: full-command (minibuffer)

d delete commands
..c character
..l line
..n node
..p paragraph
..s sentence

m outline-move commands
..Arrow keys select nodes

o outline commands
..c cut outline
..d delete outline
..m enter-move-outline-mode
..Arrow keys select nodes
..Shift-Arrow keys move nodes
..Shift-ctrl-x: cut outline

s/r search commands (search/replace)
..st search using search tab
..sf forward incremental search
..sb backward incremental search

t toggle options commands
...i toggle ignore-case checkbox
...w toggle word checkbox
...etc!

x minibuffer

: command shortcut mode
..q quit
..s save
etc (like Vim)


escape: universal escape, like ctrl-g now.

No longer needed:

f enter-focus-mode (not important: ctrl-/ cycle-focus will work)

f focus commands
..Ctrl-\ cycle-all-focus
..b focus to body
..l focus to log
..t toggle body pane focus

m enter-outline-move-mode (can use another key to get moves)
#@nonl
#@-node:ekr.20080509145618.3:New vim-like bindings
#@+node:ekr.20080509145618.4:Used by vim
@nocolor

Used by vim:

a/A (append after cursor)
c
d,dd,D (delete before cursor)
f/F/t/T
g,gf,g0,gg,ge,gE
h,j,k,l (motion commands)
i/I (insert before cursor, insert at indentation)
m,m',m` (marks)
n,N
o/O (open line) Why not just use <insert?>
r/R
x/X (delete after cursor)
y
u
v,V
w/W
ZZ,ZQ
.
:
;
+-
/ (patterns)
#@nonl
#@-node:ekr.20080509145618.4:Used by vim
#@+node:ekr.20080510055530.2:Small improvements
@nocolor

- no need for <return> binding for end-edit-headline command.
- no need for Alt-T and Alt-D binding for focus-to-outline and focus-to-body.

Plan:

- Fix mode bugs.
- Change myLeoSettings.leo.
#@nonl
#@-node:ekr.20080510055530.2:Small improvements
#@-node:ekr.20080508083640.11:Notes
#@+node:ekr.20080510185834.6:Projects
#@+node:ekr.20080509064108.8:Classified commands
#@+node:ekr.20080509064108.6:k.defineSingleLineCommands
def defineSingleLineCommands (self):

    k = self

    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # editCommandsClass
        'back-to-indentation',
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # keyHandlerCommandsClass
        # 'auto-complete',
        'negative-argument',
        'number-command',
        'number-command-0',
        'number-command-1',
        'number-command-2',
        'number-command-3',
        'number-command-4',
        'number-command-5',
        'number-command-6',
        'number-command-7',
        'number-command-8',
        'universal-argument',
        # killBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # macroCommandsClass
        'call-last-keyboard-macro',
        # search commands
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
        # registerCommandsClass
        'append-to-register',
        'copy-to-register',
        'insert-register',
        'prepend-to-register',
    ]
#@-node:ekr.20080509064108.6:k.defineSingleLineCommands
#@+node:ekr.20080509064108.7:k.defineMultiLineCommands
def defineMultiLineCommands (self):

    k = self

    k.multiLineCommandList = [
        # editCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down',
        'scroll-down-extend-selection',
        'scroll-outline-down-line',
        'scroll-outline-down-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # keyHandlerCommandsClass
        'repeat-complex-command',
        # killBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # queryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # rectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # registerCommandsClass
        'jump-to-register',
        'point-to-register',
        # searchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
#@-node:ekr.20080509064108.7:k.defineMultiLineCommands
#@+node:ekr.20080509064108.1:editing commands: single-line (appropriate for find or minibuffer)
# editCommandsClass
# change ':.*$ to nothing
# change ^[ ]*' to '

'back-to-indentation':                  self.backToIndentation,
'back-char':                            self.backCharacter,
'back-char-extend-selection':           self.backCharacterExtendSelection,
'back-word':                            self.backwardWord,
'back-word-extend-selection':           self.backwardWordExtendSelection,
'backward-delete-char':                 self.backwardDeleteCharacter,
'backward-find-character':              self.backwardFindCharacter,
'backward-find-character-extend-selection': self.backwardFindCharacterExtendSelection,
'beginning-of-line':                    self.beginningOfLine,
'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
'capitalize-word':                      self.capitalizeWord,
'delete-char':                          self.deleteNextChar,
'delete-indentation':                   self.deleteIndentation,
'delete-spaces':                        self.deleteSpaces,
# 'do-nothing':                           self.doNothing,
'downcase-word':                        self.downCaseWord,
'end-of-line':                          self.endOfLine,
'end-of-line-extend-selection':         self.endOfLineExtendSelection,
'escape':                               self.watchEscape,
'exchange-point-mark':                  self.exchangePointMark,
'extend-to-line':                       self.extendToLine,
'extend-to-word':                       self.extendToWord,
'find-character':                       self.findCharacter,
'find-character-extend-selection':      self.findCharacterExtendSelection,
'find-word':                            self.findWord,
'find-word-in-line':                    self.findWordInLine,
'forward-char':                         self.forwardCharacter,
'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
'forward-end-word':                     self.forwardEndWord, # New in Leo 4.4.2.
'forward-end-word-extend-selection':    self.forwardEndWordExtendSelection, # New in Leo 4.4.2.
'forward-word':                         self.forwardWord,
'forward-word-extend-selection':        self.forwardWordExtendSelection,
'insert-newline':                       self.insertNewline,
'insert-parentheses':                   self.insertParentheses,
'move-past-close':                      self.movePastClose,
'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
'newline-and-indent':                   self.insertNewLineAndTab,
'select-all':                           self.selectAllText,
'transpose-chars':                      self.transposeCharacters,
'transpose-words':                      self.transposeWords,
'upcase-word':                          self.upCaseWord,

# keyHandlerCommandsClass
'negative-argument':        k.negativeArgument,
'number-command':           k.numberCommand,
'number-command-0':         k.numberCommand0,
'number-command-1':         k.numberCommand1,
'number-command-2':         k.numberCommand2,
'number-command-3':         k.numberCommand3,
'number-command-4':         k.numberCommand4,
'number-command-5':         k.numberCommand5,
'number-command-6':         k.numberCommand6,
'number-command-7':         k.numberCommand7,
'number-command-8':         k.numberCommand8,
'universal-argument':       k.universalArgument,

# killBufferCommandsClass
'backward-kill-word':       self.backwardKillWord,
'kill-line':                self.killLine,
'kill-word':                self.killWord,
'kill-ws':                  self.killWs,
'yank':                     self.yank,
'yank-pop':                 self.yankPop,
'zap-to-character':         self.zapToCharacter,

# macroCommandsClass
'call-last-keyboard-macro': self.callLastKeyboardMacro,

# registerCommandsClass
'append-to-register':           self.appendToRegister,
'copy-to-register':             self.copyToRegister,
'insert-register':              self.insertRegister,
'prepend-to-register':          self.prependToRegister,

#@-node:ekr.20080509064108.1:editing commands: single-line (appropriate for find or minibuffer)
#@+node:ekr.20080509064108.2:editing commands: multi-line
# editCommandsClass
'add-space-to-lines':                   self.addSpaceToLines,
'add-tab-to-lines':                     self.addTabToLines,
'back-paragraph':                       self.backwardParagraph,
'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
'back-sentence':                        self.backSentence,
'back-sentence-extend-selection':       self.backSentenceExtendSelection,
'backward-kill-paragraph':              self.backwardKillParagraph,
'beginning-of-buffer':                  self.beginningOfBuffer,
'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
'center-line':                          self.centerLine,
'center-region':                        self.centerRegion,
'clean-all-lines':                      self.cleanAllLines,
'clean-lines':                          self.cleanLines,
'downcase-region':                      self.downCaseRegion,
'end-of-buffer':                        self.endOfBuffer,
'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
'extend-to-paragraph':                  self.extendToParagraph,
'extend-to-sentence':                   self.extendToSentence,
'fill-paragraph':                       self.fillParagraph,
'fill-region':                          self.fillRegion,
'fill-region-as-paragraph':             self.fillRegionAsParagraph,
'flush-lines':                          self.flushLines,
'forward-paragraph':                    self.forwardParagraph,
'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
'forward-sentence':                     self.forwardSentence,
'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
'indent-relative':                      self.indentRelative,
'indent-rigidly':                       self.tabIndentRegion,
'indent-to-comment-column':             self.indentToCommentColumn,
'move-lines-down':                      self.moveLinesDown,
'move-lines-up':                        self.moveLinesUp,
'next-line':                            self.nextLine,
'next-line-extend-selection':           self.nextLineExtendSelection,
'previous-line':                        self.prevLine,
'previous-line-extend-selection':       self.prevLineExtendSelection,
'remove-blank-lines':                   self.removeBlankLines,
'remove-space-from-lines':              self.removeSpaceFromLines,
'remove-tab-from-lines':                self.removeTabFromLines,
'reverse-region':                       self.reverseRegion,
'reverse-sort-lines':                   self.reverseSortLines,
'reverse-sort-lines-ignoring-case':     self.reverseSortLinesIgnoringCase,                 
'scroll-down':                          self.scrollDown,
'scroll-down-extend-selection':         self.scrollDownExtendSelection,
'scroll-outline-down-line':             self.scrollOutlineDownLine,
'scroll-outline-down-page':             self.scrollOutlineDownPage,
'simulate-begin-drag':                  self.simulateBeginDrag,
'simulate-end-drag':                    self.simulateEndDrag,
'sort-columns':                         self.sortColumns,
'sort-fields':                          self.sortFields,
'sort-lines':                           self.sortLines,
'sort-lines-ignoring-case':             self.sortLinesIgnoringCase,
'split-line':                           self.splitLine,
'tabify':                               self.tabify,
'transpose-lines':                      self.transposeLines,
'untabify':                             self.untabify,
'upcase-region':                        self.upCaseRegion,

# keyHandlerCommandsClass
'repeat-complex-command':               k.repeatComplexCommand,

# killBufferCommandsClass
'backward-kill-sentence':   self.backwardKillSentence,
'kill-sentence':            self.killSentence,
'kill-region':              self.killRegion,
'kill-region-save':         self.killRegionSave,

# queryReplaceCommandsClass
'query-replace':        self.queryReplace,
'query-replace-regex':  self.queryReplaceRegex,

# rectangleCommandsClass
'clear-rectangle':  self.clearRectangle,
'close-rectangle':  self.closeRectangle,
'delete-rectangle': self.deleteRectangle,
'kill-rectangle':   self.killRectangle,
'open-rectangle':   self.openRectangle,
'string-rectangle': self.stringRectangle,
'yank-rectangle':   self.yankRectangle,

# registerCommandsClass
'jump-to-register':             self.jumpToRegister,
'point-to-register':            self.pointToRegister,

# searchCommandsClass
'change':                               self.findTabChange,
'change-then-find':                     self.findTabChangeThenFind,
'find-next':                            self.findTabFindNext,
'find-prev':                            self.findTabFindPrev,

#@-node:ekr.20080509064108.2:editing commands: multi-line
#@+node:ekr.20080509064108.3:non-editing commands (everything else)
'activate-cmds-menu':                   self.activateCmdsMenu,
'activate-edit-menu':                   self.activateEditMenu,
'activate-file-menu':                   self.activateFileMenu,
'activate-help-menu':                   self.activateHelpMenu,
'activate-outline-menu':                self.activateOutlineMenu,
'activate-plugins-menu':                self.activatePluginsMenu,
'activate-window-menu':                 self.activateWindowMenu,
'add-editor':                           c.frame.body and c.frame.body.addEditor,
'clear-extend-mode':                    self.clearExtendMode,
'clear-selected-text':                  self.clearSelectedText,
'click-click-box':                      self.clickClickBox,
'click-headline':                       self.clickHeadline,
'click-icon-box':                       self.clickIconBox,
'contract-body-pane':                   c.frame.contractBodyPane,
'contract-log-pane':                    c.frame.contractLogPane,
'contract-outline-pane':                c.frame.contractOutlinePane,
'contract-pane':                        c.frame.contractPane,
'count-region':                         self.countRegion,
'cycle-focus':                          self.cycleFocus,
'cycle-all-focus':                      self.cycleAllFocus,
'cycle-editor-focus':                   c.frame.body.cycleEditorFocus,
'delete-editor':                        c.frame.body.deleteEditor,
'delete-first-icon':                    self.deleteFirstIcon,
'delete-last-icon':                     self.deleteLastIcon,
'delete-node-icons':                    self.deleteNodeIcons,
'double-click-headline':                self.doubleClickHeadline,
'double-click-icon-box':                self.doubleClickIconBox,
'eval-expression':                      self.evalExpression,
'expand-body-pane':                     c.frame.expandBodyPane,
'expand-log-pane':                      c.frame.expandLogPane,
'expand-outline-pane':                  c.frame.expandOutlinePane,
'expand-pane':                          c.frame.expandPane,
'focus-to-body':                        self.focusToBody,
'focus-to-log':                         self.focusToLog,
'focus-to-minibuffer':                  self.focusToMinibuffer,
'focus-to-tree':                        self.focusToTree,
'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
'fully-expand-pane':                    c.frame.fullyExpandPane,
'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
'goto-char':                            self.gotoCharacter,
'goto-global-line':                     self.gotoGlobalLine,
'goto-line':                            self.gotoLine,
'hide-body-pane':                       c.frame.hideBodyPane,
'hide-log-pane':                        c.frame.hideLogPane,
'hide-pane':                            c.frame.hidePane,
'hide-outline-pane':                    c.frame.hideOutlinePane,
'how-many':                             self.howMany,
'insert-icon':                          self.insertIcon,
'keep-lines':                           self.keepLines,
'kill-paragraph':                       self.killParagraph,
'line-number':                          self.lineNumber,
'scroll-outline-left':                  self.scrollOutlineLeft,
'scroll-outline-right':                 self.scrollOutlineRight,
'scroll-outline-up-line':               self.scrollOutlineUpLine,
'scroll-outline-up-page':               self.scrollOutlineUpPage,
'scroll-up':                            self.scrollUp,
'scroll-up-extend-selection':           self.scrollUpExtendSelection,
'set-comment-column':                   self.setCommentColumn,
'set-extend-mode':                      self.setExtendMode,
'set-fill-column':                      self.setFillColumn,
'set-fill-prefix':                      self.setFillPrefix,
'show-colors':                          self.showColors,
'show-fonts':                           self.showFonts,
'toggle-extend-mode':                   self.toggleExtendMode,
'view-lossage':                         self.viewLossage,
'what-line':                            self.whatLine,

# registerCommandsClass
'copy-rectangle-to-register':   self.copyRectangleToRegister,
'increment-register':           self.incrementRegister,
'view-register':                self.viewRegister,

# Search commands
'clone-find-all':                       self.cloneFindAll,
'find-all':                             self.findAll,
'change-all':                           self.changeAll,
'hide-find-tab':                        self.hideFindTab,
'isearch-forward':                      self.isearchForward,
'isearch-backward':                     self.isearchBackward,
'isearch-forward-regexp':               self.isearchForwardRegexp,
'isearch-backward-regexp':              self.isearchBackwardRegexp,
'isearch-with-present-options':         self.isearchWithPresentOptions,
'open-find-tab':                        self.openFindTab,
'replace-string':                       self.replaceString,
're-search-forward':                    self.reSearchForward,
're-search-backward':                   self.reSearchBackward,
'search-again':                         self.findAgain,
'search-forward':                       self.searchForward,
'search-backward':                      self.searchBackward,
'search-with-present-options':          self.searchWithPresentOptions,
'set-find-everywhere':                  self.setFindScopeEveryWhere,
'set-find-node-only':                   self.setFindScopeNodeOnly,
'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,
'show-find-options':                    self.showFindOptions,
'word-search-forward':                  self.wordSearchForward,
'word-search-backward':                 self.wordSearchBackward,

# spelling
'open-spell-tab':           self.openSpellTab,
'spell-find':               self.find,
'spell-change':             self.change,
'spell-change-then-find':   self.changeThenFind,
'spell-ignore':             self.ignore,
'hide-spell-tab':           self.hide,
#@-node:ekr.20080509064108.3:non-editing commands (everything else)
#@-node:ekr.20080509064108.8:Classified commands
#@+node:ekr.20080510145650.1:Found: unboundKeyAction
#@+node:ekr.20031218072017.2886:c.editHeadline
def editHeadline (self,event=None):

    '''Begin editing the headline of the selected node.'''

    c = self ; k = c.k ; tree = c.frame.tree

    if g.app.batchMode:
        c.notValidInBatchMode("Edit Headline")
        return

    if k:
        k.setDefaultUnboundKeyAction()
        k.showStateAndMode()

    tree.editLabel(c.currentPosition())
#@-node:ekr.20031218072017.2886:c.editHeadline
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):

    '''Update a headline from an event.

    The headline officially changes only when editing ends.'''

    c = self.c ; k = c.k
    ch = event and event.char or ''
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if i != j: ins = i

    # g.trace('w',w,'ch',repr(ch),g.callers())

    if ch == '\b':
        if i != j:  w.delete(i,j)
        else:       w.delete(ins-1)
        w.setSelectionRange(i-1,i-1,insert=i-1)
    elif ch and ch not in ('\n','\r'):
        if i != j:                              w.delete(i,j)
        elif k.unboundKeyAction == 'overwrite': w.delete(i,i+1)
        w.insert(ins,ch)
        w.setSelectionRange(ins+1,ins+1,insert=ins+1)

    s = w.getAllText()
    if s.endswith('\n'):
        # g.trace('can not happen: trailing newline')
        s = s[:-1]
    w.setWidth(self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@+node:ekr.20061031131434.82:setDefaultUnboundKeyAction
def setDefaultUnboundKeyAction (self,allowCommandState=True):

    k = self ; c = k.c

    # g.trace(g.callers())

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()

    if defaultAction == 'command' and not allowCommandState:
        self.unboundAction = 'insert'
    elif defaultAction in ('command','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % (defaultAction))
        self.unboundKeyAction = 'insert'

    k.setInputState(self.unboundKeyAction)
#@-node:ekr.20061031131434.82:setDefaultUnboundKeyAction
#@+node:ekr.20061031131434.110:k.handleDefaultChar
def handleDefaultChar(self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False

    if trace: g.trace('stroke',stroke)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
#@-node:ekr.20061031131434.110:k.handleDefaultChar
#@+node:ekr.20061031131434.119:printBindings & helper
def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    keys = d.keys() ; keys.sort()
    c.frame.log.clearTab(tabName)
    data = [] ; n1 = 4 ; n2 = 20
    if not keys: return g.es('no bindings')
    for key in keys:
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)

    # Print keys by type:
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
    ):
        data2 = []
        for item in data:
            s1,s2,s3 = item
            if s2.startswith(prefix):
                data2.append(item)
        g.es('','%s %s' % (sep, prefix),tabName=tabName)
        self.printBindingsHelper(data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    g.es('','%s %s' % (sep, 'Plain Keys',),tabName=tabName)
    self.printBindingsHelper(data,n1,n2,prefix=None)
    state = k.unboundKeyAction 
    k.showStateAndMode()
#@+node:ekr.20061031131434.120:printBindingsHelper
def printBindingsHelper (self,data,n1,n2,prefix):

    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.

    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.
    data2 = [z for z in data if z and z[1] and len(z[1][n:]) >  1]
        # The list of all other items.

    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(lambda x,y: cmp(x[1],y[1]))
        for s1,s2,s3 in data:
            g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
#@-node:ekr.20061031131434.120:printBindingsHelper
#@-node:ekr.20061031131434.119:printBindings & helper
#@+node:ekr.20061031131434.124:toggle-input-state
def toggleInputState (self,event=None):

    '''The toggle-input-state command.'''

    k = self ; c = k.c
    default = c.config.getString('top_level_unbound_key_action') or 'insert'
    state = k.unboundKeyAction

    if default == 'insert':
        state = g.choose(state=='insert','command','insert')
    elif default == 'overwrite':
        state = g.choose(state=='overwrite','command','overwrite')
    else:
        state = g.choose(state=='command','insert','command') # prefer insert to overwrite.

    k.setInputState(state)
#@-node:ekr.20061031131434.124:toggle-input-state
#@+node:ekr.20061031131434.130:keyboardQuit
def keyboardQuit (self,event,hideTabs=True,setDefaultUnboundKeyAction=True):

    '''This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.'''

    k = self ; c = k.c

    if g.app.quitting:
        return

    if hideTabs:
        k.autoCompleter.exit()
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')

    # Completely clear the mode.
    if k.inputModeName:
        k.endMode(event)

    # Complete clear the state.
    k.state.kind = None
    k.state.n = None

    k.clearState()
    k.resetLabel()

    if setDefaultUnboundKeyAction: k.setDefaultUnboundKeyAction()
    k.showStateAndMode()
    c.endEditing()
    c.bodyWantsFocus()
#@-node:ekr.20061031131434.130:keyboardQuit
#@+node:ekr.20061031131434.150:<< handle per-pane bindings >>
keyStatesTuple = ('command','insert','overwrite')

# g.trace('w_name',w_name,'w',w,'isTextWidget(w)',g.app.gui.isTextWidget(w))
# g.trace('button',k.masterBindingsDict.get('button'))

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None),
    ('all',None),
):
    if (
        key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key,{})
        # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d.keys())
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                if traceGC: g.printNewObjects('masterKey 3')
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
#@-node:ekr.20061031131434.150:<< handle per-pane bindings >>
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or (self.trace_masterKeyHandler and not g.app.unitTesting)

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','Escape'):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event,hideTabs=True,setDefaultUnboundKeyAction=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocusNow() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@+node:ekr.20080510095819.1:handleUnboudKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    k = self
    modesTuple = ('insert','overwrite')
    trace = False

    if stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif keysym.find('Escape') != -1:
        # Never insert escape characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        # New in Leo 4.5: any unbound special key terminates all modes.
        # k.keyboardQuit()
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20080510095819.1:handleUnboudKeys
#@+node:ekr.20061031131434.133:setInputState
def setInputState (self,state,showState=False):

    k = self ; c = k.c
    body = c.frame.body ; w = body.bodyCtrl

    k.unboundKeyAction = state
    k.showStateAndMode()

    if state not in ('insert','command','overwrite'):
        g.trace('bad input state',state)

    if self.inited and w:
        if state == 'insert':
            bg = k.insert_mode_bg_color
            fg = k.insert_mode_fg_color
        elif state == 'command':
            bg = k.command_mode_bg_color
            fg = k.command_mode_fg_color
        elif state == 'overwrite':
            bg = k.overwrite_mode_bg_color
            fg = k.overwrite_mode_fg_color
        else:
            bg = fg = 'red'

        # g.trace(id(w),bg,fg,self)

        body.setEditorColors(bg=bg,fg=fg)
#@-node:ekr.20061031131434.133:setInputState
#@+node:ekr.20061031131434.192:showStateAndMode
def showStateAndMode(self):

    k = self ; c = k.c ; w = self.widget
    if not w: return

    trace = False
    state = k.unboundKeyAction
    mode = k.getStateKind()

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        else:
            assert mode.endswith('-mode')
            mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    else:
        s = '%s State' % state.capitalize()

    if s:
        if trace: g.trace(s,g.callers(5))
        k.setLabelBlue(label=s,protect=True)

    # Restore the focus.
    # c.restoreFocus()
#@-node:ekr.20061031131434.192:showStateAndMode
#@-node:ekr.20080510145650.1:Found: unboundKeyAction
#@+node:ekr.20080510072134.5:Do tree navigation in outline mode
#@+node:ekr.20060923202156:c.onCanvasKey
def onCanvasKey (self,event):

    '''Navigate to the next headline starting with ch = event.char.
    If ch is uppercase, search all headlines; otherwise search only visible headlines.
    This is modelled on Windows explorer.'''

    if not event or not event.char or not event.keysym.isalnum():
        return
    c  = self ; p = c.currentPosition() ; p1 = p.copy()
    invisible = c.config.getBool('invisible_outline_navigation')
    ch = event.char
    allFlag = ch.isupper() and invisible # all is a global (!?)
    if not invisible: ch = ch.lower()
    found = False
    extend = self.navQuickKey()
    attempts = g.choose(extend,(True,False),(False,))
    for extend2 in attempts:
        p = p1.copy()
        while 1:
            if allFlag:
                p.moveToThreadNext()
            else:
                p.moveToVisNext(c)
            if not p:
                p = c.rootPosition()
            if p == p1: # Never try to match the same position.
                # g.trace('failed',extend2)
                found = False ; break
            newPrefix = c.navHelper(p,ch,extend2)
            if newPrefix:
                found = True ; break
        if found: break
    if found:
        if allFlag: c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.navTime = time.clock()
        c.navPrefix = newPrefix
        # g.trace('extend',extend,'extend2',extend2,'navPrefix',c.navPrefix,'p',p.headString())
    else:
        c.navTime = None
        c.navPrefix = ''
    c.treeWantsFocusNow()
#@nonl
#@+node:ekr.20061002095711.1:c.navQuickKey
def navQuickKey (self):

    '''return true if there are two quick outline navigation keys
    in quick succession.

    Returns False if @float outline_nav_extend_delay setting is 0.0 or unspecified.'''

    c = self

    deltaTime = c.config.getFloat('outline_nav_extend_delay')

    if deltaTime in (None,0.0):
        return False
    else:
        nearTime = c.navTime and time.clock() - c.navTime < deltaTime
        return nearTime
#@nonl
#@-node:ekr.20061002095711.1:c.navQuickKey
#@+node:ekr.20061002095711:c.navHelper
def navHelper (self,p,ch,extend):

    c = self ; h = p.headString().lower()

    if extend:
        prefix = c.navPrefix + ch
        return h.startswith(prefix.lower()) and prefix

    if h.startswith(ch):
        return ch

    # New feature: search for first non-blank character after @x for common x.
    if ch != '@' and h.startswith('@'):
        for s in ('button','command','file','thin','asis','nosent','noref'):
            prefix = '@'+s
            if h.startswith('@'+s):
                while 1:
                    n = len(prefix)
                    ch2 = n < len(h) and h[n] or ''
                    if ch2.isspace():
                        prefix = prefix + ch2
                    else: break
                if len(prefix) < len(h) and h.startswith(prefix + ch.lower()):
                    return prefix + ch
    return ''
#@nonl
#@-node:ekr.20061002095711:c.navHelper
#@-node:ekr.20060923202156:c.onCanvasKey
#@-node:ekr.20080510072134.5:Do tree navigation in outline mode
#@-node:ekr.20080510185834.6:Projects
#@-all
#@nonl
#@-node:ekr.20080508083640.10:@thin key-handling-notes.txt
#@-leo
