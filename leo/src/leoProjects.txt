#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20071217134533:Pylint
#@+node:ekr.20071217231348:Pylint docs
@nocolor



















#@+node:ekr.20071217231348.1:options
General options

rcfile:	Specify a configuration file.
init-hook:	Python code to execute, usually for sys.path manipulation such as pygtk.require().
rpython-mode:	enable the rpython checker which is disabled by default
errors-only:	In debug mode, checkers without error messages are disabled and for others, only the ERROR messages are displayed, and no reports are done by default
profile:	Profiled execution.
ignore:	Add <file or directory> to the black list. It should be a base name, not a path. You may set this option multiple times. Default: CVS
persistent:	Pickle collected data for later comparisons. Default: yes
cache-size:	Set the cache size for astng objects. Default: 500
load-plugins:	List of plugins (as comma separated values of python modules names) to load, usually to register additional checkers.

Commands options

help-msg:	Display a help message for the given message id and exit. The value may be a comma separated list of message ids.
list-msgs:	Generate pylint's full documentation.
generate-rcfile:
 	Generate a sample configuration file according to the current configuration. You can put other options before this one to get them in the generated configuration.
generate-man:	Generate pylint's man page.

Messages control options

enable-checker:	Enable only checker(s) with the given id(s). This option conflict with the disable-checker option
disable-checker: Enable all checker(s) except those with the given id(s). This option conflict with the disable-checker option
enable-msg-cat:	Enable all messages in the listed categories.
disable-msg-cat: Disable all messages in the listed categories.
enable-msg:	Enable the message(s) with the given id(s).
disable-msg:	Disable the message(s) with the given id(s).

Reports options

output-format:	set the output format. Available formats are text, parseable, colorized, msvs (visual studio) and html Default: text
include-ids:	Include message's id in output
files-output:	Put messages in a separate file for each module / package specified on the command line instead of printing them on stdout. Reports (if any) will be written in a file name "pylint_global.[txt|html]".
reports:	Tells wether to display a full report or only the messages Default: yes
evaluation:	Python expression which should return a note less than 10 (10 is the highest note).You have access to the variables errors warning, statement which respectivly contain the number of errors / warnings messages and the total number of statements analyzed. This is used by the global evaluation report (R0004). Default: 10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10)
comment:	Add a comment according to your evaluation note. This is used by the global evaluation report (R0004).
enable-report:	Enable the report(s) with the given id(s).
disable-report:	Disable the report(s) with the given id(s).
#@nonl
#@-node:ekr.20071217231348.1:options
#@+node:ekr.20071217231348.2:Main messages and reports
Main messages

E0001:	Used when a syntax error is raised for a module.
E0011:	Unrecognized file option %r Used when an unknown inline option is encountered.
E0012:	Bad option value %r Used when a bad value for an inline option is encountered.

I0001:	Unable to run raw checkers on built-in module %s Used to inform that a built-in module has not been checked using the raw checkers.
I0010:	Unable to consider inline option %r Used when an inline option is either badly formatted or can't be used inside modules.
I0011:	Locally disabling %s Used when an inline option disable a message or a messages category.
I0012:	Locally enabling %s Used when an inline option enable a message or a messages category.
I0013:	Ignoring entire file Used to inform that the file will not be checked
F0001:	Used when an error occured preventing the analyzing of a module (unable to find it for instance).
F0002:	%s: %s Used when an unexpected error occured while building the ASTNG representation. This is usually accomopagned by a traceback. Please report such errors !
F0003:	ignored builtin module %s Used to indicate that the user asked to analyze a builtin module which has been skipped.
F0004:	unexpected infered value %s Used to indicate that some value of an unexpected type has been infered.

Main reports

R0001:	Messages by category
R0002:	% errors / warnings by module
R0003:	Messages
R0004:	Global evaluation
#@nonl
#@-node:ekr.20071217231348.2:Main messages and reports
#@+node:ekr.20071217231348.3:Basic
Basic checker

Options

required-attributes:
 	Required attributes for module, separated by a comma
no-docstring-rgx:
 	Regular expression which should only match functions or classes name which do not require a docstring Default: __.*__
module-rgx:	Regular expression which should only match correct module names Default: (([a-z_][a-z0-9_]*)|([A-Z][a-zA-Z0-9]+))$
const-rgx:	Regular expression which should only match correct module level names Default: (([A-Z_][A-Z1-9_]*)|(__.*__))$
class-rgx:	Regular expression which should only match correct class names Default: [A-Z_][a-zA-Z0-9]+$
function-rgx:	Regular expression which should only match correct function names Default: [a-z_][a-z0-9_]{2,30}$
method-rgx:	Regular expression which should only match correct method names Default: [a-z_][a-z0-9_]{2,30}$
attr-rgx:	Regular expression which should only match correct instance attribute names Default: [a-z_][a-z0-9_]{2,30}$
argument-rgx:	Regular expression which should only match correct argument names Default: [a-z_][a-z0-9_]{2,30}$
variable-rgx:	Regular expression which should only match correct variable names Default: [a-z_][a-z0-9_]{2,30}$
inlinevar-rgx:	Regular expression which should only match correct list comprehension / generator expression variable names Default: [A-Za-z_][A-Za-z0-9_]*$
good-names:	Good variable names which should always be accepted, separated by a comma Default: i,j,k,ex,Run,_
bad-names:	Bad variable names which should always be refused, separated by a comma Default: foo,bar,baz,toto,tutu,tata
bad-functions:	List of builtins function names that should not be used, separated by a comma Default: map,filter,apply,input

Messages

E0100:	__init__ method is a generator Used when the special class method __init__ is turned into a generator by a yield in its body.
E0101:	Explicit return in __init__ Used when the special class method __init__ has an explicit return value.
E0102:	%s already defined line %s Used when a function / class / method is redefined.
E0103:	%r not properly in loop Used when break or continue keywords are used outside a loop.
E0104:	return outside function Used when a "return" statement is found outside a function or method.
E0105:	yield outside function Used when a "yield" statement is found outside a function or method.
E0106:	return with argument inside generator Used when a "return" statement with an argument is found outside in a generator function or method (e.g. with some "yield" statements).

W0101:	Unreachable code Used when there is some code behind a "return" or "raise" statement, which will never be accessed.
W0102:	Dangerous default value %s as argument Used when a mutable value as list or dictionary is detected in a default value for an argument.
W0104:	Statement seems to have no effect Used when a statement doesn't have (or at least seems to) any effect.
W0105:	String statement has no effect Used when a string is used as a statement (which of course has no effect). This is a particular case of W0104 with its own message so you can easily disable it if you're using those strings as documentation, instead of comments.
W0106:	Unnecessary semicolon Used when a statement is endend by a semi-colon (";"), which isn't necessary (that's python, not C ;).
W0107:	Unnecessary pass statement Used when a "pass" statement that can be avoided is encountered.)
W0122:	Use of the exec statement Used when you use the "exec" statement, to discourage its usage. That doesn't mean you can not use it !
W0141:	Used builtin function %r Used when a black listed builtin function is used (see the bad-function option). Usual black listed functions are the ones like map, or filter , where Python offers now some cleaner alternative like list comprehension.
W0142:	Used * or * magic* Used when a function or method is called using *args or **kwargs to dispatch arguments. This doesn't improve readility and should be used with care.

C0102:	Black listed name "%s" Used when the name is listed in the black list (unauthorized names).
C0103:	Invalid name "%s" (should match %s) Used when the name doesn't match the regular expression associated to its type (constant, variable, class...).
C0111:	Missing docstring Used when a module, function, class or method has no docstring. Some special methods like __init__ doesn't necessary require a docstring.
C0112:	Empty docstring Used when a module, function, class or method has an empty docstring (it would be too easy ;).
C0121:	Missing required attribute "%s" Used when an attribute required for modules is missing.

Reports

R0101:	Statistics by type
#@-node:ekr.20071217231348.3:Basic
#@+node:ekr.20071217231348.4:Type
Typecheck checker

Options

ignore-mixin-members:
 	Tells wether missing members accessed in mixin class should be ignored. A mixin class is detected if its name ends with "mixin" (case insensitive). Default: yes
zope:	When zope mode is activated, consider the acquired-members option to ignore access to some undefined attributes.
acquired-members:
 	List of members which are usually get through zope's acquisition mecanism and so shouldn't trigger E0201 when accessed (need zope=yes to be considered). Default: REQUEST,acl_users,aq_parent

Messages

E1101:	%s %r has no %r member  A variable is accessed for an unexistant member.
E1102:	%s is not callable      An object being called has been infered to a non callable object
E1103:	%s %r has no %r member (but some types could not be inferred) 
                               A variable is accessed for an unexistant member, but astng was not able to interpret all possible types of this variable.
E1111:	Assigning to function call which doesn't return     An assigment is done on a function call but the infered function doesn't return anything.
W1111:	Assigning to function call which only returns None  An assigment is done on a function call but the infered function returns nothing but None.
#@nonl
#@-node:ekr.20071217231348.4:Type
#@+node:ekr.20071217231348.5:Variables
Variables checker

Options

init-import:	Tells wether we should check for unused import in __init__ files.
dummy-variables-rgx:
 	A regular expression matching names used for dummy variables (i.e. not used). Default: _|dummy
additional-builtins:
 	List of additional names supposed to be defined in builtins. Remember that you should avoid to define new builtins when possible.

Messages

E0601:	Using variable %r before assignment Used when a local variable is accessed before it's assignment.
E0602:	Undefined variable %r Used when an undefined variable is accessed.
E0611:	No name %r in module %r Used when a name cannot be found in a module.

W0601:	Global variable %r undefined at the module level Used when a variable is defined through the "global" statement but the variable is not defined in the module scope.
W0602:	Using global for %r but no assigment is done Used when a variable is defined through the "global" statement but no assigment to this variable is done.
W0603:	Using the global statement Used when you use the "global" statement to update a global variable.
PyLint just try to discourage this usage. That doesn't mean you can not use it !
W0604:	Using the global statement at the module level Used when you use the "global" statement at the module level since it has no effect
W0611:	Unused import %s Used when an imported module or variable is not used.
W0612:	Unused variable %r Used when a variable is defined but not used.
W0613:	Unused argument %r Used when a function or method argument is not used.
W0614:	Unused import %s from wildcard import Used when an imported module or variable is not used from a 'from X import *' style import.

W????: Inline emphasis start-string without end-string.
W0621:	Redefining name %r from outer scope (line %s) Used when a variable's name hide a name defined in the outer scope.
W0622:	Redefining built-in %r Used when a variable or function override a built-in.
W0631:	Using possibly undefined loop variable %r Used when an loop variable (i.e. defined by a for loop or a list comprehension or a generator expression) is used outside the loop.
#@nonl
#@-node:ekr.20071217231348.5:Variables
#@+node:ekr.20071217231501:Classes
Classes checker

Options

ignore-iface-methods:
 	List of interface methods to ignore, separated by a comma. This is used for instance to not check methods defines in Zope's Interface base class. Default: isImplementedBy,deferred,extends,names,namesAndDescriptions,queryDescriptionFor,getBases,getDescriptionFor,getDoc,getName,getTaggedValue,getTaggedValueTags,isEqualOrExtendedBy,setTaggedValue,isImplementedByInstancesOf,adaptWith,is_implemented_by
defining-attr-methods:
 	List of method names used to declare (i.e. assign) instance attributes. Default: __init__,__new__,setUp

Messages

E0202:	An attribute inherited from %s hide this method Used when a class defines a method which is hiden by an instance attribute from an ancestor class.
E0203:	Access to member %r before its definition line %s Used when an instance member is accessed before it's actually assigned.
E0211:	Method has no argument Used when a method which should have the bound instance as first argument has no argument defined.
E0213:	Method should have "self" as first argument Used when a method has an attribute different the "self" as first argument. This is considered as an error since this is a soooo common convention that you should'nt break it!
E0221:	Interface resolved to %s is not a class Used when a class claims to implement an interface which is not a class.
E0222:	Missing method %r from %s interface Used when a method declared in an interface is missing from a class implementing this interface

W0201:	Attribute %r defined outside __init__ Used when an instance attribute is defined outside the __init__ method.
W0211:	Static method with %r as first argument Used when a static method has "self" or "cls" as first argument.
W0212:	Access to a protected member %s of a client class Used when a protected member (i.e. class member with a name beginning with an underscore) is access outside the class or a descendant of the class where it's defined.
W0221:	Arguments number differs from %s method Used when a method has a different number of arguments than in the implemented interface or in an overridden method.
W0222:	Signature differs from %s method Used when a method signature is different than in the implemented interface or in an overridden method.
W0223:	Method %r is abstract in class %r but is not overridden Used when an abstract method (ie raise NotImplementedError) is not overridden in concrete class.
W0231:	__init__ method from base class %r is not called Used when an ancestor class method has an __init__ method which is not called by a derived class.
W0232:	Class has no __init__ method Used when a class has no __init__ method, neither its parent classes.
W0233:	__init__ method from a non direct base class %r is called Used when an __init__ method is called on a class which is not in the direct ancestors for the analysed class.
R0201:	Method could be a function Used when a method doesn't use its bound instance, and so could be written as a function.
C0202:	Class method should have "cls" as first argument Used when a class method has an attribute different than "cls" as first argument, to easily differentiate them from regular instance methods.
C0203:	Metaclass method should have "mcs" as first argument Used when a metaclass method has an attribute different the "mcs" as first argument.
F0202:	Unable to check methods signature (%s / %s) Used when PyLint has been unable to check methods signature compatibility for an unexpected raison. Please report this kind if you don't make sense of it.
F0220:	failed to resolve interfaces implemented by %s (%s) Used when a PyLint as failed to find interfaces implemented by a class
#@-node:ekr.20071217231501:Classes
#@+node:ekr.20071217231501.1:Design
Design checker

Options
max-args:	Maximum number of arguments for function / method Default: 5
max-locals:	Maximum number of locals for function / method body Default: 15
max-returns:	Maximum number of return / yield for function / method body Default: 6
max-branchs:	Maximum number of branch for function / method body Default: 12
max-statements:	Maximum number of statements in function / method body Default: 50
max-parents:	Maximum number of parents for a class (see R0901). Default: 7
max-attributes:	Maximum number of attributes for a class (see R0902). Default: 7
min-public-methods:
 	Minimum number of public methods for a class (see R0903). Default: 2
max-public-methods:
 	Maximum number of public methods for a class (see R0904). Default: 20

Messages

R0901:	Too many ancestors (%s/%s) Used when class has too many parent classes, try to reduce this to get a more simple (and so easier to use) class.
R0902:	Too many instance attributes (%s/%s) Used when class has too many instance attributes, try to reduce this to get a more simple (and so easier to use) class.
R0903:	Too few public methods (%s/%s) Used when class has too few public methods, so be sure it's really worth it.
R0904:	Too many public methods (%s/%s) Used when class has too many public methods, try to reduce this to get a more simple (and so easier to use) class.
R0911:	Too many return statements (%s/%s) Used when a function or method has too many return statement, making it hard to follow.
R0912:	Too many branches (%s/%s) Used when a function or method has too many branches, making it hard to follow.
R0913:	Too many arguments (%s/%s) Used when a function or method takes too many arguments.
R0914:	Too many local variables (%s/%s) Used when a function or method has too many local variables.
R0915:	Too many statements (%s/%s) Used when a function or method has too many statements. You should then split it in smaller functions / methods.
R0921:	Abstract class not referenced Used when an abstract class is not used as ancestor anywhere.
R0922:	Abstract class is only referenced %s times Used when an abstract class is used less than X times as ancestor.
R0923:	Interface not implemented Used when an interface class is not implemented anywhere.
#@nonl
#@-node:ekr.20071217231501.1:Design
#@+node:ekr.20071217231501.2:Imports
Imports checker

Options

deprecated-modules:
 	Deprecated modules which should not be used, separated by a comma Default: regsub,string,TERMIOS,Bastion,rexec
import-graph:	Create a graph of every (i.e. internal and external) dependencies in the given file (report R0402 must not be disabled)
ext-import-graph:
 	Create a graph of external dependencies in the given file (report R0402 must not be disabled)
int-import-graph:
 	Create a graph of internal dependencies in the given file (report R0402 must not be disabled)

Messages

W0401:	Wildcard import %s Used when from module import * is detected.
W0402:	Uses of a deprecated module %r Used a module marked as deprecated is imported.
W0403:	Relative import %r Used when an import relative to the package directory is detected.
W0404:	Reimport %r (imported line %s) Used when a module is reimported multiple times.
W0406:	Module import itself Used when a module is importing itself.
W0410:	__future__ import is not the first non docstring statement Python 2.5 and greater require __future__ import to be the first non docstring statement in the module.
R0401:	Cyclic import (%s) Used when a cyclic import between two or more modules is detected.
F0401:	Unable to import %r (%s) Used when pylint has been unable to import a module.

Reports

R0401:	External dependencies
R0402:	Modules dependencies graph
#@nonl
#@-node:ekr.20071217231501.2:Imports
#@+node:ekr.20071217231501.3:Newstyle
Newstyle checker


Messages

E1001:	Use __slots__ on an old style class Used when an old style class use the __slots__ attribute.
E1002:	Use super on an old style class Used when an old style class use the super builtin.
E1003:	Bad first argument %r given to super class Used when another argument than the current class is given as first argument of the super builtin.
E1010:	Raising a new style class Used when a new style class is raised since it's not possible with python < 2.5.
W1001:	Use of "property" on an old style class Used when PyLint detect the use of the builtin "property" on an old style class while this is relying on new style classes 
features
W1010:	Exception doesn't inherit from standard "Exception" class Used when a custom exception class is raised but doesn't inherit from the builtin "Exception" class.
#@nonl
#@-node:ekr.20071217231501.3:Newstyle
#@+node:ekr.20071217231828:Exceptions
Exceptions checker

Messages

E0701:	Bad except clauses order (%s) Used when except clauses are not in the correct order (from the more specific to the more generic). If you don't fix the order, some exceptions may not be catched by the most specific handler.
E0702:	Raising %s while only classes, instances or string are allowed Used when something which is neither a class, an instance or a string is raised (i.e. a TypeError will be raised).
W0701:	Raising a string exception Used when a string exception is raised.
W0702:	No exception's type specified Used when an except clause doesn't specify exceptions type to catch.
W0703:	Catch "Exception" Used when an except catch Exception instances.
W0704:	Except doesn't do anything Used when an except clause does nothing but "pass" and there is no "else" clause.
W0706:	Identifier %s used to raise an exception is assigned to %s Used when a variable used to raise an exception is initially assigned to a value which can't be used as an exception.
#@nonl
#@-node:ekr.20071217231828:Exceptions
#@+node:ekr.20071217231828.1:Format
Format checker

Options

max-line-length:
 	Maximum number of characters on a single line. Default: 80
max-module-lines:
 	Maximum number of lines in a module Default: 1000
indent-string:	String used as indentation unit. This is usually " " (4 spaces) or "t" (1 tab). Default: ' '

Messages

W0311:	Bad indentation. Found %s %s, expected %s Used when an unexpected number of indentation's tabulations or spaces has been found.
W0312:	Found indentation with %ss instead of %ss Used when there are some mixed tabs and spaces in a module.
W0331:	Use of the <> operator Used when the deprecated "<>" operator is used instead of "!=".
W0332:	Use l as long integer identifier Used when a lower case "l" is used to mark a long integer. You should use a upper case "L" since the letter "l" looks too much like the digit "1"
C0301:	Line too long (%s/%s) Used when a line is longer than a given number of characters.
C0302:	Too many lines in module (%s) Used when a module has too much lines, reducing its readibility.
C0321:	More than one statement on a single line Used when more than on statement are found on the same line.
C0322:	Operator not preceded by a space Used when one of the following operator (!= | <= | == | >= | < | > | = | += | -= | *= | /= | %) is not preceded by a space.
C0323:	Operator not followed by a space Used when one of the following operator (!= | <= | == | >= | < | > | = | += | -= | *= | /= | %) is not followed by a space.
C0324:	Comma not followed by a space Used when a comma (",") is not followed by a space.
F0321:	Format detection error in %r Used when an unexpected error occured in bad format detection. Please report the error if it occurs.
#@nonl
#@-node:ekr.20071217231828.1:Format
#@+node:ekr.20071217231828.2:Miscellaneous
Miscellaneous checker

Options

notes:	List of note tags to take in consideration, separated by a comma. Default: FIXME,XXX,TODO

Messages

E0501:	Non ascii characters found but no encoding specified (PEP 263) Used when some non ascii characters are detected but now encoding is specified, as explicited in the PEP 263.
E0502:	Wrong encoding specified (%s) Used when a known encoding is specified but the file doesn't seem to be actually in this encoding.
E0503:	Unknown encoding specified (%s) Used when an encoding is specified, but it's unknown to Python.
W0511:	Used when a warning note as FIXME or XXX is detected.
#@nonl
#@-node:ekr.20071217231828.2:Miscellaneous
#@+node:ekr.20071217231828.3:Metrics
Metrics checker


Reports

R0701:	Raw metrics
#@-node:ekr.20071217231828.3:Metrics
#@+node:ekr.20071217231828.4:Simularities
Similarities checker

min-similarity-lines:
 	Minimum lines number of a similarity. Default: 4
ignore-comments:
 	Ignore comments when computing similarities. Default: yes
ignore-docstrings:
 	Ignore docstrings when computing similarities. Default: yes

Messages

R0801:	Similar lines in %s files Indicates that a set of similar lines has been detected among multiple file. This usually means that the code should be refactored to avoid this duplication.

Reports

R0801:	Duplication
#@-node:ekr.20071217231828.4:Simularities
#@-node:ekr.20071217231348:Pylint docs
#@+node:ekr.20071220081732:pylint report
@killcolor


*** Erroneous errors in Leo 4.4.8



--- old --

************* Module leoTkinterTree

W0221:2377:leoTkinterTree.setSelectedLabelState: Arguments number differs from overridden method
W0221:2387:leoTkinterTree.setUnselectedLabelState: Arguments number differs from overridden method
#@+node:ekr.20080304084023:leoEditCommands
*** All these error messages are WRONG.

E1101:114:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'name' member
E1101:115:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'undoType' member
E1101:116:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'oldSel' member
E1101:116:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'oldText' member

E1101:8091:spellCommandsClass.openSpellTab: Instance of 'spellTabHandler' has no 'bringToFront' member
E1101:8121:spellCommandsClass.changeAll: Instance of 'spellTabHandler' has no 'changeAll' member
E1101:8129:spellCommandsClass.changeThenFind: Instance of 'spellTabHandler' has no 'changeThenFind' member
#@nonl
#@-node:ekr.20080304084023:leoEditCommands
#@+node:ekr.20080304084023.1:leoGlobals
*** All these error messages are WRONG.

E1101:137:computeGlobalConfigDir: Module 'sys' has no 'leo_config_directory' member
W0104:3915: Statement seems to have no effect

E0602:3931:getpreferredencoding: Undefined variable 'LC_CTYPE'
E0602:3932:getpreferredencoding: Undefined variable 'LC_CTYPE'
E1101:3933:getpreferredencoding: Module 'locale' has no 'nl_langinfo' member
E0602:3933:getpreferredencoding: Undefined variable 'CODESET'
E0602:3934:getpreferredencoding: Undefined variable 'LC_CTYPE'
E1101:3937:getpreferredencoding: Module 'locale' has no 'nl_langinfo' member
E0602:3937:getpreferredencoding: Undefined variable 'CODESET'
E1101:4432:mulderUpdateAlgorithm.copy_time: Module 'os' has no 'mtime' member
#@-node:ekr.20080304084023.1:leoGlobals
#@+node:ekr.20080304091441:leoTkinterFind
*** All these error messages are WRONG.

************* Module leoTkinterFind
E1101: 95:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'title' member
E1101:101:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'intKeys' member
E1101:104:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'newStringKeys' member
E1101:113:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'createTopFrame' member
E1101:115:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'top' member
E1101:116:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'top' member
E1101:123:leoTkinterFind.init: Instance of 'leoTkinterFind' has no 'intKeys' member
E1101:177:leoTkinterFind.destroySelf: Instance of 'leoTkinterFind' has no 'top' member
E1101:185:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'frame' member
E1101:213:leoTkinterFind.createFrame.setFocus: Instance of 'leoTkinterFind' has no 'c' member
E1101:298:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1101:305:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1103:325:leoTkinterFind.createFrame.findButtonCallback: Instance of 'leoTkinterFind' has no 'findButton' member (but some types c
ould not be inferred)
E1101:341:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'findAllButton' member
E1101:348:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'changeButton' member
E1101:354:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'changeThenFindButton' member
E1101:360:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'changeAllButton' member
E1101:367:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'top' member
E1101:368:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'top' member
E1103:378:leoTkinterFind.createBindings.findButtonCallback2: Instance of 'leoTkinterFind' has no 'findButton' member (but some typ
es could not be inferred)
E1101:382:leoTkinterFind.createBindings: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1101:383:leoTkinterFind.createBindings: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1101:384:leoTkinterFind.createBindings: Instance of 'leoTkinterFind' has no 'selectAllFindText' member
E1101:396:leoTkinterFind.onCloseWindow: Instance of 'leoTkinterFind' has no 'top' member
E1101:401:leoTkinterFind.dismiss: Instance of 'leoTkinterFind' has no 'top' member
E1101:408:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'c' member
E1101:410:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'top' member
E1101:411:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'top' member
E1101:412:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'top' member
E1101:438:tkFindTab.initGui: Instance of 'tkFindTab' has no 'intKeys' member
E1101:441:tkFindTab.initGui: Instance of 'tkFindTab' has no 'newStringKeys' member
E1101:448:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'c' member
E1101:489:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'optionsOnly' member
E1101:504:tkFindTab.createFrame.setFocus: Instance of 'tkFindTab' has no 'c' member
E1101:538:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'optionsOnly' member
E1101:591:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'resetWrap' member
E1101:599:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'resetWrap' member
E1101:606:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'optionsOnly' member
E1101:623:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'findButtonCallback' member
E1101:624:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'findAllButton' member
E1101:626:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'changeButton' member
E1101:627:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'changeThenFindButton' member
E1101:628:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'changeAllButton' member
E1101:647:tkFindTab.createBindings: Instance of 'tkFindTab' has no 'c' member
E1103:650:tkFindTab.createBindings.resetWrapCallback: Instance of 'tkFindTab' has no 'resetWrap' member (but some types could not
be inferred)
E1103:654:tkFindTab.createBindings.findButtonBindingCallback: Instance of 'tkFindTab' has no 'findButton' member (but some types c
ould not be inferred)
E1101:664:tkFindTab.createBindings: Instance of 'tkFindTab' has no 'hideTab' member
E1101:677:tkFindTab.init: Instance of 'tkFindTab' has no 'intKeys' member
E1101:746:tkFindTab.setOption: Instance of 'tkFindTab' has no 'intKeys' member
E1101:758:tkFindTab.toggleOption: Instance of 'tkFindTab' has no 'intKeys' member
"*****done*****"
Press any key to continue . . .
#@nonl
#@-node:ekr.20080304091441:leoTkinterFind
#@+node:ekr.20080304091441.1:leoTkinterGui
*** All these error messages are WRONG.

************* Module leoTkinterGui
E1101:179:tkinterGui.runMainLoop: Instance of 'tkinterGui' has no 'script' member
E1101:183:tkinterGui.runMainLoop: Instance of 'tkinterGui' has no 'script' member
#@-node:ekr.20080304091441.1:leoTkinterGui
#@+node:ekr.20080304092628:leoTkinterFrame
*** All these error messages are WRONG.

leoTkinterFrame.py Harmless: W0221: mismatch between Tk.Text methods and overridden methods.
leoTkinterFrame.py Dangerous: E1101
************* Module leoTkinterFrame
E1101: 53:leoTkinterBody.__init__: Instance of 'leoTkinterBody' has no 'c' member
E1101: 67:leoTkinterBody.createBindings: Instance of 'leoTkinterBody' has no 'frame' member
E1101: 67:leoTkinterBody.createBindings: Instance of 'leoTkinterBody' has no 'c' member
E1101: 88:leoTkinterBody.createControl: Instance of 'leoTkinterBody' has no 'c' member
E1101:102:leoTkinterBody.createControl: Instance of 'leoTkinterBody' has no 'editorWidgets' member
E1101:109:leoTkinterBody.createTextWidget: Instance of 'leoTkinterBody' has no 'c' member
E1101:176:leoTkinterBody.setColorFromConfig: Instance of 'leoTkinterBody' has no 'c' member
E1101:224:leoTkinterBody.setFontFromConfig: Instance of 'leoTkinterBody' has no 'c' member
E1101:241:leoTkinterBody.hasFocus: Instance of 'leoTkinterBody' has no 'frame' member
E1101:245:leoTkinterBody.setFocus: Instance of 'leoTkinterBody' has no 'c' member
E1101:351:leoTkinterBody.setEditorColors: Instance of 'leoTkinterBody' has no 'c' member
E1101:351:leoTkinterBody.setEditorColors: Instance of 'leoTkinterBody' has no 'editorWidgets' member
E1101:379:leoTkinterFrame.__init__: Class 'leoTkinterFrame' has no 'instances' member
E1101:437:leoTkinterFrame.finishCreate: Instance of 'leoTkinterFrame' has no 'initialRatios' member
E1101:439:leoTkinterFrame.finishCreate: Instance of 'leoTkinterFrame' has no 'createIconBar' member
E1101:442:leoTkinterFrame.finishCreate: Instance of 'leoTkinterFrame' has no 'createStatusLine' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'comparePanel' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'colorPanel' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'fontPanel' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'prefsPanel' member
E1101:1347:leoTkinterFrame.setMinibufferBindings: Instance of 'leoTkinterFrame' has no 'OnPaste' member
E1101:1901:leoTkinterFrame.toggleTkSplitDirection: Instance of 'leoTkinterFrame' has no 'initialRatios' member
E1101:2111:leoTkinterLog.createCanvasWidget: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2138:leoTkinterLog.createTextWidget: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2140:leoTkinterLog.createTextWidget: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2303:leoTkinterLog.onActivateLog: Instance of 'leoTkinterLog' has no 'frame' member
E1101:2423:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2424:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2431:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2432:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2433:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2462:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2463:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2464:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2475:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2476:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2477:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2489:leoTkinterLog.cycleTabFocus: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2514:leoTkinterLog.deleteTab: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2515:leoTkinterLog.deleteTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2516:leoTkinterLog.deleteTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2556:leoTkinterLog.numberOfVisibleTabs: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2573:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2574:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2587:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2589:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2600:leoTkinterLog.setTabBindings: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2600:leoTkinterLog.setTabBindings: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2787:leoTkinterLog.createColorPicker: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2788:leoTkinterLog.createColorPicker: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2845:leoTkinterLog.createFontPicker: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2846:leoTkinterLog.createFontPicker: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:3018:leoTkinterTreeTab.createControl: Instance of 'leoTkinterTreeTab' has no 'c' member
E1101:3065:leoTkinterTreeTab.selectTab: Instance of 'leoTkinterTreeTab' has no 'cc' member
"*****done*****"
Press any key to continue . . .
#@nonl
#@-node:ekr.20080304092628:leoTkinterFrame
#@+node:ekr.20080304093027:leoTkinterKeys
*** All these error messages are WRONG.

************* Module leoTkinterKeys
E1101: 27:tkinterKeyHandlerClass.createTkIvars: Instance of 'tkinterKeyHandlerClass' has no 'useTextWidget' member
E1101: 27:tkinterKeyHandlerClass.createTkIvars: Instance of 'tkinterKeyHandlerClass' has no 'widget' member
E1101: 29:tkinterKeyHandlerClass.createTkIvars: Instance of 'tkinterKeyHandlerClass' has no 'widget' member
#@-node:ekr.20080304093027:leoTkinterKeys
#@+node:ekr.20080304093258:leoTkinterMenu
*** All these error messages are WRONG.

leoTkinterMenu.py
************* Module leoTkinterMenu
E1101: 62:leoTkinterMenu.computeMenuPositions: Instance of 'leoTkinterMenu' has no 'getMenu' member
E1101:136:leoTkinterMenu.insert: Instance of 'leoTkinterMenu' has no 'getMenu' member
E1101:172:leoTkinterMenu.clearAccel: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:183:leoTkinterMenu.createMenuBar: Instance of 'leoTkinterMenu' has no 'updateAllMenus' member
E1101:186:leoTkinterMenu.createMenuBar: Instance of 'leoTkinterMenu' has no 'setMenu' member
E1101:187:leoTkinterMenu.createMenuBar: Instance of 'leoTkinterMenu' has no 'createMenusFromTables' member
E1101:208:leoTkinterMenu.disableMenu: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:225:leoTkinterMenu.enableMenu: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:255:leoTkinterMenu.setMenuLabel: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:258:leoTkinterMenu.setMenuLabel: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:297:leoTkinterMenu.getMacHelpMenu: Instance of 'leoTkinterMenu' has no 'getMenu' member
E1101:301:leoTkinterMenu.getMacHelpMenu: Instance of 'leoTkinterMenu' has no 'createMenuEntries' member
#@-node:ekr.20080304093258:leoTkinterMenu
#@-node:ekr.20071220081732:pylint report
#@-node:ekr.20071217134533:Pylint
#@+node:ekr.20080408060320.4:4.5 a1
#@+node:ekr.20080408060320.782:Bug fixes
#@+node:ekr.20080407090400.1:Fixed how-many, find-word and goto-character commands
@nocolor

find-word
=========
This command is supposed to:

"Put the cursor at the next word (on a line) that starts with a
character"

It does not. You have to type in a whole word to get any result and
even then
it only selects the word it does not move the cursor to it.


goto-charachter
==============
'''Put the cursor at the n'th character of the buffer.'''

Doesn't do anything.

@color
#@nonl
#@+node:ekr.20050920084036.1:<< define class baseEditCommandsClass >>
class baseEditCommandsClass:

    '''The base class for all edit command classes'''

    @others
#@+node:ekr.20050920084036.2: ctor, finishCreate, init (baseEditCommandsClass)
def __init__ (self,c):

    self.c = c
    self.k = self.k = None
    self.registers = {} # To keep pychecker happy.
    self.undoData = None

def finishCreate(self):

    # Class delegators.
    self.k = self.k = self.c.k
    try:
        self.w = self.c.frame.body.bodyCtrl # New in 4.4a4.
    except AttributeError:
        self.w = None

def init (self):

    '''Called from k.keyboardQuit to init all classes.'''

    pass
#@nonl
#@-node:ekr.20050920084036.2: ctor, finishCreate, init (baseEditCommandsClass)
#@+node:ekr.20051214132256:begin/endCommand (baseEditCommands)
#@+node:ekr.20051214133130:beginCommand  & beginCommandWithEvent
def beginCommand (self,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)
#@+node:ekr.20051215102349:beingCommandHelper
# New in Leo 4.4b4: calling beginCommand is valid for all widgets,
# but does nothing unless we are in the body pane.

def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.currentPosition()
    name = c.widget_name(w)

    if name.startswith('body'):
        oldSel =  w.getSelectionRange()
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
    else:
        self.undoData = None

    return w
#@-node:ekr.20051215102349:beingCommandHelper
#@-node:ekr.20051214133130:beginCommand  & beginCommandWithEvent
#@+node:ekr.20051214133130.1:endCommand
# New in Leo 4.4b4: calling endCommand is valid for all widgets,
# but handles undo only if we are in body pane.

def endCommand(self,label=None,changed=True,setLabel=True):

    '''Do the common processing at the end of each command.'''

    c = self.c ; b = self.undoData ; k = self.k

    # g.trace('changed',changed)

    if b and b.name.startswith('body') and changed:
        c.frame.body.onBodyChanged(undoType=b.undoType,
            oldSel=b.oldSel,oldText=b.oldText,oldYview=None)

    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()

    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
#@-node:ekr.20051214133130.1:endCommand
#@-node:ekr.20051214132256:begin/endCommand (baseEditCommands)
#@+node:ekr.20061007105001:editWidget
def editWidget (self,event):

    c = self.c ; w = event and event.widget

    if w and g.app.gui.isTextWidget(w) and w != c.frame.miniBufferWidget:
        self.w = w
    else:
        self.w = self.c.frame.body and self.c.frame.body.bodyCtrl

    if self.w:
        c.widgetWantsFocusNow(self.w)

    return self.w
#@nonl
#@-node:ekr.20061007105001:editWidget
#@+node:ekr.20050920084036.5:getPublicCommands & getStateCommands
def getPublicCommands (self):

    '''Return a dict describing public commands implemented in the subclass.
    Keys are untranslated command names.  Values are methods of the subclass.'''

    return {}
#@-node:ekr.20050920084036.5:getPublicCommands & getStateCommands
#@+node:ekr.20050920084036.6:getWSString
def getWSString (self,s):

    return ''.join([g.choose(ch=='\t',ch,' ') for ch in s])
#@-node:ekr.20050920084036.6:getWSString
#@+node:ekr.20050920084036.7:oops
def oops (self):

    print("baseEditCommandsClass oops:",
        g.callers(),
        "must be overridden in subclass")
#@-node:ekr.20050920084036.7:oops
#@+node:ekr.20050929161635:Helpers
#@+node:ekr.20050920084036.249:_chckSel
def _chckSel (self,event,warning='no selection'):

    c = self.c ; k = self.k

    w = self.editWidget(event)

    val = w and w.hasSelection()

    if warning and not val:
        k.setLabelGrey(warning)

    return val
#@-node:ekr.20050920084036.249:_chckSel
#@+node:ekr.20050920084036.250:_checkIfRectangle
def _checkIfRectangle (self,event):

    k = self.k ; key = event.keysym.lower()

    val = self.registers.get(key)

    if val and type(val) == type([]):
        k.clearState()
        k.setLabelGrey("Register contains Rectangle, not text")
        return True

    return False
#@-node:ekr.20050920084036.250:_checkIfRectangle
#@+node:ekr.20050920084036.233:getRectanglePoints
def getRectanglePoints (self,w):

    c = self.c
    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    i,j = w.getSelectionRange()
    r1,r2 = g.convertPythonIndexToRowCol(s,i)
    r3,r4 = g.convertPythonIndexToRowCol(s,j)

    return r1+1,r2,r3+1,r4
#@-node:ekr.20050920084036.233:getRectanglePoints
#@+node:ekr.20051002090441:keyboardQuit
def keyboardQuit (self,event):

    '''Clear the state and the minibuffer label.'''

    return self.k.keyboardQuit(event)
#@-node:ekr.20051002090441:keyboardQuit
#@-node:ekr.20050929161635:Helpers
#@-node:ekr.20050920084036.1:<< define class baseEditCommandsClass >>
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20061007105001:editWidget
def editWidget (self,event):

    c = self.c ; w = event and event.widget

    if w and g.app.gui.isTextWidget(w) and w != c.frame.miniBufferWidget:
        self.w = w
    else:
        self.w = self.c.frame.body and self.c.frame.body.bodyCtrl

    if self.w:
        c.widgetWantsFocusNow(self.w)

    return self.w
#@nonl
#@-node:ekr.20061007105001:editWidget
#@+node:ekr.20050920084036.80:howMany
def howMany (self,event):

    '''Print how many occurances of a regular expression are found
    in the body text of the presently selected node.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    state = k.getState('how-many')
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.getAllText()
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
#@-node:ekr.20050920084036.80:howMany
#@+node:ekr.20061031131434.128:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or stroke in k.getArgEscapes:
        if stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20061031131434.129:<< init altX vars >>
#@-node:ekr.20061031131434.128:getArg
#@+node:ekr.20060417194232:find (quick)
#@+node:ekr.20060925151926:backward/findCharacter & helper
def backwardFindCharacter (self,event):
    return self.findCharacterHelper(event,backward=True,extend=False)

def backwardFindCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=True,extend=True)

def findCharacter (self,event):
    return self.findCharacterHelper(event,backward=False,extend=False)

def findCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=False,extend=True)
#@nonl
#@+node:ekr.20060417194232.1:findCharacterHelper
def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward ; self.extend = extend
        self.insert = w.getInsertPoint()
        s = '%s character%s: ' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' & extend',''))
        k.setLabelBlue(s,protect=True)
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward ; extend = self.extend
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = s.rfind('\n',0,i)
            if start == -1: start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        else:
            end = s.find('\n',i)
            if end == -1: end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.1:findCharacterHelper
#@-node:ekr.20060925151926:backward/findCharacter & helper
#@+node:ekr.20060417194232.2:findWord and FindWordOnLine & helper
def findWord(self,event):

    '''Put the cursor at the next word that starts with a character.'''

    return self.findWordHelper(event,oneLine=False)

def findWordInLine(self,event):

    '''Put the cursor at the next word (on a line) that starts with a character.'''

    return self.findWordHelper(event,oneLine=True)

#@+node:ekr.20080408060320.1:findWordHelper
def findWordHelper (self,event,oneLine):

    k = self.k ; tag = 'find-word' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.oneLineFlag = oneLine
        k.setLabelBlue('Find word %sstarting with: ' % (
            g.choose(oneLine,'in line ','')))
        k.getArg(event,tag,1,self.findWord,oneCharacter=True)
    else:        
        ch = k.arg ; w = self.w ; c = k.c
        if ch:
            i = w.getInsertPoint()
            s = w.getAllText()
            if self.oneLineFlag:
                end = s.find('\n',i) # Limit searches to this line.
                if end == -1: end = len(s)
            else:
                end = len(s)

            while i < end:
                i = s.find(ch,i+1,end) # Ensure progress and i > 0.
                if i == -1:
                    break
                elif not g.isWordChar(s[i-1]):
                    w.setSelectionRange(i,i,insert=i)
                    break

        k.resetLabel()
        k.clearState()
#@-node:ekr.20080408060320.1:findWordHelper
#@-node:ekr.20060417194232.2:findWord and FindWordOnLine & helper
#@-node:ekr.20060417194232:find (quick)
#@+node:ekr.20050929115226:gotoCharacter
def gotoCharacter (self,event):

    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue("Goto n'th character: ")
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.w ; ok = False
        if n.isdigit():
            n = int(n)
            if n >= 0:
                w.setInsertPoint(n)
                w.seeInsertPoint()
                ok = True
        if not ok:
            g.es('goto-char takes non-negative integer argument',color='blue')
        k.resetLabel()
        k.clearState()
#@-node:ekr.20050929115226:gotoCharacter
#@-node:ekr.20080407090400.1:Fixed how-many, find-word and goto-character commands
#@+node:ekr.20080408060320.2:Fixed bug in install script
@nocolor

On Mon, Apr 7, 2008 at 7:07 PM, SegundoBob <bhossley@ieee.org> wrote:

I installed Leo 4.4..8 final on Ubuntu.  The installation failed
because the installation put files in /usr/lib/leo/leo.  The
duplicated leo is a mistake.
On line 13 of install I changed:
LEO_LIB_DIR="${LEO_PREFIX}/lib/leo"
to
LEO_LIB_DIR="${LEO_PREFIX}/lib"

With the change the installation worked.
#@nonl
#@-node:ekr.20080408060320.2:Fixed bug in install script
#@+node:ekr.20080406075855.1:Fixed find completion bug
@nocolor

Trying to edit the minibuffer, when I backspace to a character and
press delete the cursor moves to the end of the buffer and deletes the
last character instead.
#@nonl
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20061031131434.177:k.doBackSpace
# Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList,completion=True):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c ; w = self.widget

    if 0:
        g.trace('(keyHandler)',g.callers(4))
        g.trace('completion',completion,
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    # Step 1: actually delete the character.
    ins = w.getInsertPoint()
    s = w.getAllText()
    if ins <= len(k.mb_prefix):
        # g.trace('at start')
        return
    i,j = w.getSelectionRange()
    if i == j:
        ins -= 1
        w.delete(ins)
        w.setSelectionRange(ins,ins,insert=ins)
    else:
        ins = i
        w.delete(i,j)
        w.setSelectionRange(i,i,insert=ins)

    # Step 2: compute completions.
    if not completion: return
    k.mb_tabListPrefix = w.getAllText()
    k.computeCompletionList(defaultCompletionList,backspace=True)
#@-node:ekr.20061031131434.177:k.doBackSpace
#@-node:ekr.20080406075855.1:Fixed find completion bug
#@+node:ekr.20080426071701.1:Fixed keyword handling in g.es and g.es_print
#@+node:ekr.20070626132332:es & minitest
def es(s,*args,**keys):

    '''Put all non-keyword args to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''
    # print 'es','app.log',repr(app.log),'log.isNull',not app.log or app.log.isNull,repr(s)
    # print 'es',repr(s)
    log = app.log
    if app.killed:
        return

    # Important: defining keyword arguments in addition to *args **does not work**.
    # See Section 5.3.4 (Calls) of the Python reference manual.
    # In other words, the following is about the best that can be done.
    color = keys.get('color')
    commas = keys.get('commas')
    commas = g.choose( 
        commas in (True,'True','true'),True,False)# default is False
    newline = keys.get('newline')
    newline = g.choose(
        newline in (False,'False','false'),False,True)# default is True
    spaces= keys.get('spaces')
    spaces = g.choose(
        spaces in (False,'False','false'),False,True)# default is True
    tabName = keys.get('tabName','Log')

        # Default goes to log pane *not* the presently active pane.
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""):
        s = repr(s)
    s = g.translateArgs(s,args,commas,spaces)

    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            s = g.toEncodedString(s,'ascii')
            if newline: print s
            else: print s,
    else:
        if log and log.isNull:
            pass
        elif log:
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
        else:
            app.logWaiting.append((s,color),)
#@+node:ekr.20071024101611:mini test of es
@nocolor
@first
@first
@

This doesn't work as an external unit test.
To test, select all following lines and do execute-script.

s1 = 'line1 Ä, ڱ,  궯, 奠 end'
s2 = g.toUnicode(s1,'utf-8')

for s in (s1,s2):
    g.es(s)
    g.es_print(s)
#@-node:ekr.20071024101611:mini test of es
#@-node:ekr.20070626132332:es & minitest
#@+node:ekr.20050707064040:es_print
# see: http://www.diveintopython.org/xml_processing/unicode.html

def es_print(s,*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    encoding = sys.getdefaultencoding()

    # Important: defining keyword arguments in addition to *args **does not work**.
    # See Section 5.3.4 (Calls) of the Python reference manual.
    # In other words, the following is about the best that can be done.
    commas = keys.get('commas')
    commas = g.choose( 
        commas in (True,'True','true'),True,False)# default is False
    newline = keys.get('newline')
    newline = g.choose(
        newline in (False,'False','false'),False,True)# default is True
    spaces= keys.get('spaces')
    spaces = g.choose(
        spaces in (False,'False','false'),False,True)# default is True
    try:
        if type(s) != type(u''):
            s = unicode(s,encoding)
    except Exception:
        s = g.toEncodedString(s,'ascii')

    s2 = g.translateArgs(s,args,commas,spaces)

    if newline:
        try:
            print s2
        except Exception:
            print g.toEncodedString(s2,'ascii')
    else:
        try:
            print s2,
        except Exception:
            print g.toEncodedString(s2,'ascii'),

    if g.app.gui and not g.app.gui.isNullGui and not g.unitTesting:
        g.es(s,*args,**keys)
#@+node:ekr.20070621092938:@@test g.es_print
if g.unitTesting:
    g.es_print('\ntest of es_print: Ă',color='red',newline=False)
    g.es_print('after')
    g.es_print('done')
#@-node:ekr.20070621092938:@@test g.es_print
#@-node:ekr.20050707064040:es_print
#@-node:ekr.20080426071701.1:Fixed keyword handling in g.es and g.es_print
#@-node:ekr.20080408060320.782:Bug fixes
#@+node:ekr.20080421162832.7:Recent graph-world bugs
#@+node:ekr.20080421083619.3:Fixed paste outline
#@+node:ekr.20060919110638.4:createSaxVnodes & helpers
def createSaxVnodes (self,saxRoot,reassignIndices):

    '''**Important**: this method and its helpers are low-level code
    corresponding to link/unlink methods in leoNodes.py.
    Modify this with extreme care.'''


    parent_v = self.c.hiddenRootNode

    children = self.createSaxChildren(saxRoot,parent_v=parent_v)

    return children
#@+node:ekr.20060919110638.5:createSaxChildren
def createSaxChildren (self, sax_node, parent_v):

    children = []

    for child in sax_node.children:
        tnx = child.tnx
        t = self.tnodesDict.get(tnx)
        if t:
            # A clone.  Create a new clone vnode, but share the subtree, i.e., the tnode.
            v = self.createSaxVnode(child,parent_v,t=t)
            # g.trace('**clone',v)
            if v not in t.parents:
                t.parents.append(v)
            for grandChild in v.t.children:
                if v not in grandChild.t.parents:
                    # g.trace('adding %s to parents of %s' % (v,grandChild))
                    grandChild.t.parents.append(v)
        else:
            v = self.createSaxVnodeTree(child,parent_v)
        children.append(v)

    self._linkParentAndChildren(parent_v,children)

    return children
#@-node:ekr.20060919110638.5:createSaxChildren
#@+node:ekr.20060919110638.6:createSaxVnodeTree
def createSaxVnodeTree (self,sax_node,parent_v):

    v = self.createSaxVnode(sax_node,parent_v)

    self.createSaxChildren(sax_node,v)

    return v
#@nonl
#@-node:ekr.20060919110638.6:createSaxVnodeTree
#@+node:ekr.20060919110638.7:createSaxVnode
def createSaxVnode (self,sax_node,parent_v,t=None):

    c = self.c
    trace = False and self.usingClipboard
    h = sax_node.headString
    b = sax_node.bodyString

    if t:
        if trace: g.trace('clone',t,h)
    else:
        t = leoNodes.tnode(bodyString=b,headString=h)
        if trace: g.trace('     ',t,h)

        if sax_node.tnx:
            t.fileIndex = g.app.nodeIndices.scanGnx(sax_node.tnx,0)

    v = leoNodes.vnode(context=c,t=t)
    v.t.vnodeList.append(v)

    index = self.canonicalTnodeIndex(sax_node.tnx)

    self.tnodesDict [index] = t

    # g.trace('tnx','%-22s' % (index),'v',id(v),'v.t',id(v.t),'body','%-4d' % (len(b)),h)

    self.handleVnodeSaxAttributes(sax_node,v)
    self.handleTnodeSaxAttributes(sax_node,t)

    return v
#@+node:ekr.20060919110638.8:handleTnodeSaxAttributes
def handleTnodeSaxAttributes (self,sax_node,t):

    d = sax_node.tnodeAttributes

    aDict = {}
    for key in d.keys():
        val = d.get(key)
        val2 = self.getSaxUa(key,val)
        aDict[key] = val2

    if aDict:
        # g.trace('uA',aDict)
        t.unknownAttributes = aDict
#@nonl
#@-node:ekr.20060919110638.8:handleTnodeSaxAttributes
#@+node:ekr.20061004053644:handleVnodeSaxAttributes
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded and descendentTnodeUnknownAttributes.

def handleVnodeSaxAttributes (self,sax_node,v):

    d = sax_node.attributes
    s = d.get('a')
    if s:
        # g.trace('%s a=%s %s' % (id(sax_node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        # if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.trace('setting currentVnode',v,color='red')
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnode list will be resolved later.
        # g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes') # Correct: only tnode have descendent uA's.
    if s: 
        aDict = self.getDescendentUnknownAttributes(s)
        if aDict:
            # g.trace('descendentUaDictList',aDict)
            self.descendentUnknownAttributesDictList.append(aDict)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d.keys():
        if key in self.nativeVnodeAttributes:
            if 0: g.trace('****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # g.trace('uA',aDict)
        v.unknownAttributes = aDict
#@nonl
#@-node:ekr.20061004053644:handleVnodeSaxAttributes
#@-node:ekr.20060919110638.7:createSaxVnode
#@+node:ekr.20060919110638.9:_linkParentAndChildren
def _linkParentAndChildren (self, parent_v, children):

    # if children: g.trace(parent_v,len(children))

    # Add parent_v to it's tnode's vnodeList.
    if parent_v not in parent_v.t.vnodeList:
        parent_v.t.vnodeList.append(parent_v)

    # Set parent_v's children.
    parent_v.t.children = children

    # Make parent_v a parent of each child.
    for v in children:
        if parent_v not in v.t.parents:
            v.t.parents.append(parent_v)
#@-node:ekr.20060919110638.9:_linkParentAndChildren
#@-node:ekr.20060919110638.4:createSaxVnodes & helpers
#@+node:ekr.20031218072017.1559:getLeoOutlineFromClipboard & helpers
def getLeoOutlineFromClipboard (self,s,reassignIndices=True):

    '''Read a Leo outline from string s in clipboard format.'''

    c = self.c ; current = c.currentPosition() ; check = not reassignIndices

    # Save the hidden root's children.
    children = c.hiddenRootNode.t.children

    # Always recreate the tnodesDict
    self.tnodesDict = {}
    if not reassignIndices:
        x = g.app.nodeIndices
        for t in c.all_unique_tnodes_iter():
            index = x.toString(t.fileIndex)
            self.tnodesDict[index] = t

    # g.trace('reassignIndices',reassignIndices,
        # 'len(.tnodesDict.keys())',len(self.tnodesDict.keys()))

    self.usingClipboard = True
    try:
        # This encoding must match the encoding used in putLeoOutline.
        s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)

        # readSaxFile modifies the hidden root.
        v = self.readSaxFile(
            theFile=None, fileName='<clipboard>',
            silent=True, # don't tell about stylesheet elements.
            inClipboard=True, reassignIndices=reassignIndices,s=s)
        if not v:
            return g.es("the clipboard is not valid ",color="blue")
    finally:
        self.usingClipboard = False

        # Restore the hidden root's children
        c.hiddenRootNode.t.children = children

    p = leoNodes.position(v)
    if current.hasChildren() and current.isExpanded():
        if check and not self.checkPaste(current,p): return None
        p._linkAsNthChild(current,0)
    else:
        if check and not self.checkPaste(current.parent(),p): return None
        p._linkAfter(current)

    if reassignIndices:
        for p2 in p.self_and_subtree_iter():
            p2.v.t.fileIndex = None

    c.selectPosition(p)
    return p

getLeoOutline = getLeoOutlineFromClipboard # for compatibility
#@+node:ekr.20080410115129.1:checkPaste
def checkPaste (self,parent,p):

    '''Return True if p may be pasted as a child of parent.'''

    if not parent: return True

    parents = [z.copy() for z in parent.self_and_parents_iter()]

    for p in p.self_and_subtree_iter():
        for z in parents:
            # g.trace(p.headString(),id(p.v.t),id(z.v.t))
            if p.v.t == z.v.t:
                g.es('Invalid paste: nodes may not descend from themselves',color="blue")
                return False

    return True
#@-node:ekr.20080410115129.1:checkPaste
#@-node:ekr.20031218072017.1559:getLeoOutlineFromClipboard & helpers
#@-node:ekr.20080421083619.3:Fixed paste outline
#@+node:ekr.20080421083619.1:Fixed two recent node bugs
@nocolor

1. clone-find-all truncated the outline.
   The fix was in p.linkAsRoot.

2. The move outline down command skipped nodes.
   The fix was to p.moveAfter.

3. Added defensive code to p.unlink.

@color
#@nonl
#@+node:ekr.20080416161551.216:p._linkAsRoot
def _linkAsRoot (self,oldRoot):

    """Link self as the root node."""

    p = self
    assert(p.v)

    hiddenRootNode = p.v.context.hiddenRootNode

    if oldRoot: oldRootNode = oldRoot.v
    else:       oldRootNode = None

    # Init the ivars.
    p.stack = []
    p._childIndex = 0

    # Update p.v.t.vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1

    # Update the p.v.t.parents.
    if hiddenRootNode not in p.v.t.parents:
        p.v.t.parents.append(hiddenRootNode)
        p.v._p_changed = 1

    # Update the hiddenRootNode's children.
    if oldRoot:
        hiddenRootNode.t.children.insert(0,p.v)
    else:
        hiddenRootNode.t.children = [p.v]

    return p
#@-node:ekr.20080416161551.216:p._linkAsRoot
#@+node:ekr.20040303175026.10:p.moveAfter
def moveAfter (self,a):

    """Move a position after position a."""

    p = self # Do NOT copy the position!

    # Adjust a._childIndex if p is a preceding sibling,
    # so p._linkAfter(a) will set p.v.t._childIndex correctly.
    sib = a.copy()
    while sib.hasBack():
        sib.moveToBack()
        if sib == p:
            a._childIndex -= 1
            break

    p._unlink()
    p._linkAfter(a)

    return p
#@-node:ekr.20040303175026.10:p.moveAfter
#@+node:ekr.20080416161551.217:p._unlink
def _unlink (self):

    '''Unlink the receiver from the tree.'''

    trace = True
    p = self ; n = p._childIndex
    parent_v = p._parentVnode()
        # returns None if p.v is None
    assert(p.v)
    assert(parent_v)

    # Remove v from it's tnode's vnodeList.
    if p.v in p.v.t.vnodeList:
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    # Delete p.v from parent_v's children.
    if 0 <= n < len(parent_v.t.children):
        if parent_v.t.children[n] == p.v:
            del parent_v.t.children[n]
            parent_v._p_changed = 1
        elif trace:
            g.trace('**can not happen: children[%s] != p.v' % (n))
            g.trace('parent_v.t.children...\n',g.listToString(parent_v.t.children))
            g.trace('p.v',p.v)
            g.trace(g.callers())
    elif trace:
        g.trace('can not happen: bad child index: %s, len(children): %s' % (n,len(parent_v.t.children)))
        g.trace('parent_v.t.children...\n',g.listToString(parent_v.t.children))
        g.trace('p.v',p.v)
        g.trace(g.callers())

    # Delete parent_v from p.v's parents.
    if parent_v in p.v.t.parents:
        p.v.t.parents.remove(parent_v)
        p.v._p_changed = 1 # Support for tnode class.

#@-node:ekr.20080416161551.217:p._unlink
#@-node:ekr.20080421083619.1:Fixed two recent node bugs
#@+node:ekr.20080421083619.6:Fixed bug: Deleting the root didn't select another node
#@+node:ekr.20031218072017.1193:c.deleteOutline
def deleteOutline (self,event=None,op_name="Delete Node"):

    """Deletes the selected outline."""

    c = self ; cc = c.chapterController ; u = c.undoer
    p = c.currentPosition()
    if not p: return

    if p.hasVisBack(c): newNode = p.visBack(c)
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.beginUpdate()
    try:
        c.endEditing() # Make sure we capture the headline for Undo.
    finally:
        c.endUpdate(False)

    if cc: # Special cases for @chapter and @chapters nodes.
        chapter = '@chapter ' ; chapters = '@chapters ' 
        h = p.headString()
        if h.startswith(chapters):
            if p.hasChildren():
                return cc.error('Can not delete @chapters node with children.')
        elif h.startswith(chapter):
            name = h[len(chapter):].strip()
            if name:
                return cc.removeChapterByName(name)

    c.beginUpdate()
    try:
        undoData = u.beforeDeleteNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.doDelete(newNode)
        c.selectPosition(newNode)
        c.setChanged(True)
        u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()

    c.validateOutline()
#@-node:ekr.20031218072017.1193:c.deleteOutline
#@+node:ekr.20040303175026.2:p.doDelete
@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self,newNode=None):

    """Deletes position p from the outline."""

    p = self
    p.setDirty() # Mark @file nodes dirty!

    # Adjust newNode._childIndex if newNode is a following sibling of p.
    sib = p.copy()
    while sib.hasNext():
        sib.moveToNext()
        if sib == newNode:
            newNode._childIndex -= 1
            break

    p._unlink()
    p._deleteLinksInTree()
#@-node:ekr.20040303175026.2:p.doDelete
#@+node:ekr.20040303175026.10:p.moveAfter
def moveAfter (self,a):

    """Move a position after position a."""

    p = self # Do NOT copy the position!

    # Adjust a._childIndex if p is a preceding sibling,
    # so p._linkAfter(a) will set p.v.t._childIndex correctly.
    sib = a.copy()
    while sib.hasBack():
        sib.moveToBack()
        if sib == p:
            a._childIndex -= 1
            break

    p._unlink()
    p._linkAfter(a)

    return p
#@-node:ekr.20040303175026.10:p.moveAfter
#@+node:ekr.20040303175026.3:p.insertAfter
def insertAfter (self,t=None):

    """Inserts a new position after self.

    Returns the newly created position."""

    p = self ; context = p.v.context
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(context=context,t=t)
    p2.v.iconVal = 0
    p2._linkAfter(p)

    return p2
#@-node:ekr.20040303175026.3:p.insertAfter
#@-node:ekr.20080421083619.6:Fixed bug: Deleting the root didn't select another node
#@+node:ekr.20080421162832.9:The str_leo_pos uA was not being cleared
#@+node:ekr.20031218072017.1579:putVnodes & helpers
def putVnodes (self):

    """Puts all <v> elements in the order in which they appear in the outline."""

    c = self.c
    c.clearAllVisited()

    self.put("<vnodes>\n")

    # Make only one copy for all calls.
    self.currentPosition = c.currentPosition() 
    self.rootPosition    = c.rootPosition()
    # self.topPosition     = c.topPosition()

    if self.usingClipboard:
        self.putVnode(self.currentPosition) # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings_iter():
            # New in Leo 4.4.2 b2 An optimization:
            self.putVnode(p,isIgnore=p.isAtIgnoreNode()) # Write the next top-level node.

    self.put("</vnodes>\n")
#@nonl
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    # Not writing @auto nodes is way too dangerous.
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    # forceWrite = isIgnore or not isThin or (isThin and isOrphan)
    if isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto: forceWrite = False     # Never write non-ignored @auto trees.
    elif isThin: forceWrite = isOrphan  # Only write orphan @thin trees.
    else:        forceWrite = True      # Write all other @file trees.

    << Set gnx = tnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append tnodeList and unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s><vh>%s</vh>' % (gnx,attrs,xml.sax.saxutils.escape(p.v.headString()or''))
    # The string catentation is faster than repeated calls to fc.put.
    if not self.usingClipboard:
        << issue informational messages >>
    # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren() and (forceWrite or self.usingClipboard):
        fc.put('%s\n' % v_head)
        # This optimization eliminates all "recursive" copies.
        p.moveToFirstChild()
        while 1:
            fc.putVnode(p,isIgnore)
            if p.hasNext(): p.moveToNext()
            else:           break
        p.moveToParent() # Restore p in the caller.
        fc.put('</v>\n')
    else:
        fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
# New in Leo 4.4.8.  Assign v.t.fileIndex here as needed.
if not v.t.fileIndex:
    v.t.fileIndex = g.app.nodeIndices.getNewIndex()

gnx = g.app.nodeIndices.toString(v.t.fileIndex)

if forceWrite or self.usingClipboard:
    v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
#@-node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
#@+node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren(): attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"

    # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    # if not self.use_sax:
        # if p.equal(self.topPosition):     attr += "T" # was a bottleneck
        # if p.equal(self.currentPosition): attr += "V" # was a bottleneck

    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    if not c.fixed:
        d['str_leo_pos'] = ','.join(aList)
    # g.trace(aList,d)
    v.unknownAttributes = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@-node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
#@+node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for",p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        attrs.append(fc.putTnodeList(v)) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    attrs.append(self.putUnknownAttributes(v))

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    attrs.append(self.putDescendentUnknownAttributes(p))
    attrs.append(self.putDescendentAttributes(p))
#@nonl
#@-node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
#@+node:ekr.20040702085529:<< issue informational messages >>
if isOrphan and isThin:
    g.es("writing erroneous:",p.headString(),color="blue")
    p.clearOrphan()
#@-node:ekr.20040702085529:<< issue informational messages >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20031218072017.2002:putTnodeList (4.0,4.2)
def putTnodeList (self,v):

    """Put the tnodeList attribute of a tnode."""

    # Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!
    nodeIndices = g.app.nodeIndices
    tnodeList = v.t.tnodeList

    if tnodeList:
        # g.trace("%4d" % len(tnodeList),v)
        for t in tnodeList:
            try: # Will fail for None or any pre 4.1 file index.
                junk,junk,junk = t.fileIndex
            except Exception:
                gnx = nodeIndices.getNewIndex()
                # Apparent bug fix: Leo 4.4.8, 2008-3-8: use t, not v.t here!
                # t.setFileIndex(gnx) # Don't convert to string until the actual write.
                t.fileIndex = gnx
        s = ','.join([nodeIndices.toString(t.fileIndex) for t in tnodeList])
        return ' tnodeList="%s"' % (s)
    else:
        return ''
#@nonl
#@-node:ekr.20031218072017.2002:putTnodeList (4.0,4.2)
#@+node:ekr.20040701065235.2:putDescendentAttributes
def putDescendentAttributes (self,p):

    nodeIndices = g.app.nodeIndices

    # Create lists of all tnodes whose vnodes are marked or expanded.
    marks = [] ; expanded = []
    for p in p.subtree_iter():
        t = p.v.t
        if p.isMarked() and p.v.t not in marks:
            marks.append(t)
        if p.hasChildren() and p.isExpanded() and t not in expanded:
            expanded.append(t)

    result = []
    for theList,tag in ((marks,"marks"),(expanded,"expanded")):
        if theList:
            sList = []
            for t in theList:
                # New in Leo 4.4.8.  Assign t.fileIndex here as needed.
                if not t.fileIndex:
                    t.fileIndex = g.app.nodeIndices.getNewIndex()
                gnx = t.fileIndex
                sList.append("%s," % nodeIndices.toString(gnx))
            s = string.join(sList,'')
            # g.trace(tag,[str(p.headString()) for p in theList])
            result.append('\n%s="%s"' % (tag,s))

    return ''.join(result)
#@-node:ekr.20040701065235.2:putDescendentAttributes
#@+node:EKR.20040627113418:putDescendentUnknownAttributes
def putDescendentUnknownAttributes (self,p):

    # pychecker complains about dumps.

    # The bin param doesn't exist in Python 2.3;
    # the protocol param doesn't exist in earlier versions of Python.
    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    python23 = g.CheckVersion(version,'2.3')

    # Create a list of all tnodes having a valid unknownAttributes dict.
    tnodes = []
    tnodesData = []
    for p2 in p.subtree_iter():
        t = p2.v.t
        if hasattr(t,"unknownAttributes"):
            if t not in tnodes :
                # g.trace(p2.headString(),t)
                tnodes.append(t) # Bug fix: 10/4/06.
                tnodesData.append((p2,t),)

    # Create a list of pairs (t,d) where d contains only pickleable entries.
    data = []
    for p,t in tnodesData:
        if type(t.unknownAttributes) != type({}):
            g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
        else:
            # Create a new dict containing only entries that can be pickled.
            d = dict(t.unknownAttributes) # Copy the dict.

            for key in d.keys():
                try:
                    # We don't actually save the pickled values here.
                    if python23:
                        pickle.dumps(d[key],protocol=1) # Requires Python 2.3
                    else:
                        pickle.dumps(d[key],bin=True) # Requires earlier versions of Python.
                except pickle.PicklingError:
                    del d[key]
                    g.es("ignoring bad unknownAttributes key",key,"in",p,color="blue")
                except Exception:
                    del d[key]
                    g.es('putDescendentUnknownAttributes: unexpected pickling exception',color='red')
                    g.es_exception()
            data.append((t,d),)

    # Create resultDict, an enclosing dict to hold all the data.
    resultDict = {}
    nodeIndices = g.app.nodeIndices
    for t,d in data:
        # New in Leo 4.4.8.  Assign v.t.fileIndex here as needed.
        if not t.fileIndex:
            t.fileIndex = g.app.nodeIndices.getNewIndex()
        gnx = nodeIndices.toString(t.fileIndex)
        resultDict[gnx]=d

    if 0:
        print "resultDict..."
        for key in resultDict:
            print repr(key),repr(resultDict.get(key))

    # Pickle and hexlify resultDict.
    if resultDict:
        try:
            tag = "descendentTnodeUnknownAttributes"
            if python23:
                s = pickle.dumps(resultDict,protocol=1) # Requires Python 2.3
                # g.trace('protocol=1')
            else:
                s = pickle.dumps(resultDict,bin=True) # Requires Earlier version of Python.
                # g.trace('bin=True')
            field = ' %s="%s"' % (tag,binascii.hexlify(s))
            return field
        except pickle.PicklingError:
            g.trace("putDescendentUnknownAttributes can't happen 1",color="red")
        except Exception:
            g.es("putDescendentUnknownAttributes can't happen 2",color='red')
            g.es_exception()
    return ''
#@-node:EKR.20040627113418:putDescendentUnknownAttributes
#@-node:ekr.20031218072017.1579:putVnodes & helpers
#@+node:EKR.20040526202501:putUnknownAttributes & helper
def putUnknownAttributes (self,torv):

    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""

    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:

        val = ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
        # g.trace(torv,attrDict,g.callers())
        return val
#@+node:ekr.20050418161620.2:putUaHelper
def putUaHelper (self,torv,key,val):

    '''Put attribute whose name is key and value is val to the output stream.'''

    # g.trace(key,repr(val),g.callers())

    # New in 4.3: leave string attributes starting with 'str_' alone.
    if key.startswith('str_'):
        if type(val) == type(''):
            attr = ' %s="%s"' % (key,xml.sax.saxutils.escape(val))
            return attr
        else:
            g.es("ignoring non-string attribute",key,"in",torv,color="blue")
            return ''
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
        python23 = g.CheckVersion(version,'2.3')
        try:
            if python23:
                # Protocol argument is new in Python 2.3
                # Use protocol 1 for compatibility with bin.
                s = pickle.dumps(val,protocol=1)
            else:
                s = pickle.dumps(val,bin=True)
            attr = ' %s="%s"' % (key,binascii.hexlify(s))
            return attr
        except Exception:
            g.es('putUaHelper: unexpected pickling exception',color='red')
            g.es_exception()
            return ''
    except pickle.PicklingError:
        # New in 4.2 beta 1: keep going after error.
        g.es("ignoring non-pickleable attribute",key,"in",torv,color="blue")
        return ''
#@-node:ekr.20050418161620.2:putUaHelper
#@-node:EKR.20040526202501:putUnknownAttributes & helper
#@-node:ekr.20080421162832.9:The str_leo_pos uA was not being cleared
#@+node:ekr.20080421162832.6:Fixed bug: Moving a clone to the root lost the clone mark
#@+node:ekr.20080416161551.216:p._linkAsRoot
def _linkAsRoot (self,oldRoot):

    """Link self as the root node."""

    p = self
    assert(p.v)

    hiddenRootNode = p.v.context.hiddenRootNode

    if oldRoot: oldRootNode = oldRoot.v
    else:       oldRootNode = None

    # Init the ivars.
    p.stack = []
    p._childIndex = 0

    # Update p.v.t.vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1

    # Update the p.v.t.parents.
    if hiddenRootNode not in p.v.t.parents:
        p.v.t.parents.append(hiddenRootNode)
        p.v._p_changed = 1

    # Update the hiddenRootNode's children.
    if oldRoot:
        hiddenRootNode.t.children.insert(0,p.v)
    else:
        hiddenRootNode.t.children = [p.v]

    return p
#@-node:ekr.20080416161551.216:p._linkAsRoot
#@-node:ekr.20080421162832.6:Fixed bug: Moving a clone to the root lost the clone mark
#@+node:ekr.20080423062035.16:Fixed paste-retaining-clones
# getLeoOutlineFromClipboard now recreates the tnodesDict as needed.
#@nonl
#@+node:ekr.20031218072017.1551:pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    '''Paste an outline into the present outline from the clipboard.
    Nodes do *not* retain their original identify.'''

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    tnodeInfoDict = {}
    if pasteAsClone:
        << remember all data for undo/redo Paste As Clone >>
    # create a *position* to be pasted.
    if isLeo:
        pasted = c.fileCommands.getLeoOutlineFromClipboard(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return

    c.beginUpdate()
    try:
        copiedBunchList = []
        if pasteAsClone:
            << put only needed info in copiedBunchList >>
        undoData = u.beforeInsertNode(current,
            pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)
        c.endEditing()
        c.validateOutline()
        c.selectPosition(pasted)
        pasted.setDirty()
        c.setChanged(True)
        # paste as first child if back is expanded.
        back = pasted.back()
        if back and back.isExpanded():
            pasted.moveToNthChildOf(back,0)
        c.setRootPosition(c.findRootPosition(pasted)) # New in 4.4.2.
        u.afterInsertNode(pasted,undoType,undoData)
    finally:
        c.endUpdate()
        c.recolor()
#@+node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for v in c.all_unique_vnodes_iter():
    t = v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=v.headString(),body=v.bodyString())
#@-node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
#@+node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
# Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t

# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
#@-node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
#@-node:ekr.20031218072017.1551:pasteOutline
#@+node:ekr.20031218072017.1559:getLeoOutlineFromClipboard & helpers
def getLeoOutlineFromClipboard (self,s,reassignIndices=True):

    '''Read a Leo outline from string s in clipboard format.'''

    c = self.c ; current = c.currentPosition() ; check = not reassignIndices

    # Save the hidden root's children.
    children = c.hiddenRootNode.t.children

    # Always recreate the tnodesDict
    self.tnodesDict = {}
    if not reassignIndices:
        x = g.app.nodeIndices
        for t in c.all_unique_tnodes_iter():
            index = x.toString(t.fileIndex)
            self.tnodesDict[index] = t

    # g.trace('reassignIndices',reassignIndices,
        # 'len(.tnodesDict.keys())',len(self.tnodesDict.keys()))

    self.usingClipboard = True
    try:
        # This encoding must match the encoding used in putLeoOutline.
        s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)

        # readSaxFile modifies the hidden root.
        v = self.readSaxFile(
            theFile=None, fileName='<clipboard>',
            silent=True, # don't tell about stylesheet elements.
            inClipboard=True, reassignIndices=reassignIndices,s=s)
        if not v:
            return g.es("the clipboard is not valid ",color="blue")
    finally:
        self.usingClipboard = False

        # Restore the hidden root's children
        c.hiddenRootNode.t.children = children

    p = leoNodes.position(v)
    if current.hasChildren() and current.isExpanded():
        if check and not self.checkPaste(current,p): return None
        p._linkAsNthChild(current,0)
    else:
        if check and not self.checkPaste(current.parent(),p): return None
        p._linkAfter(current)

    if reassignIndices:
        for p2 in p.self_and_subtree_iter():
            p2.v.t.fileIndex = None

    c.selectPosition(p)
    return p

getLeoOutline = getLeoOutlineFromClipboard # for compatibility
#@+node:ekr.20080410115129.1:checkPaste
def checkPaste (self,parent,p):

    '''Return True if p may be pasted as a child of parent.'''

    if not parent: return True

    parents = [z.copy() for z in parent.self_and_parents_iter()]

    for p in p.self_and_subtree_iter():
        for z in parents:
            # g.trace(p.headString(),id(p.v.t),id(z.v.t))
            if p.v.t == z.v.t:
                g.es('Invalid paste: nodes may not descend from themselves',color="blue")
                return False

    return True
#@-node:ekr.20080410115129.1:checkPaste
#@-node:ekr.20031218072017.1559:getLeoOutlineFromClipboard & helpers
#@+node:ekr.20060919110638.4:createSaxVnodes & helpers
def createSaxVnodes (self,saxRoot,reassignIndices):

    '''**Important**: this method and its helpers are low-level code
    corresponding to link/unlink methods in leoNodes.py.
    Modify this with extreme care.'''


    parent_v = self.c.hiddenRootNode

    children = self.createSaxChildren(saxRoot,parent_v=parent_v)

    return children
#@+node:ekr.20060919110638.5:createSaxChildren
def createSaxChildren (self, sax_node, parent_v):

    children = []

    for child in sax_node.children:
        tnx = child.tnx
        t = self.tnodesDict.get(tnx)
        if t:
            # A clone.  Create a new clone vnode, but share the subtree, i.e., the tnode.
            v = self.createSaxVnode(child,parent_v,t=t)
            # g.trace('**clone',v)
            if v not in t.parents:
                t.parents.append(v)
            for grandChild in v.t.children:
                if v not in grandChild.t.parents:
                    # g.trace('adding %s to parents of %s' % (v,grandChild))
                    grandChild.t.parents.append(v)
        else:
            v = self.createSaxVnodeTree(child,parent_v)
        children.append(v)

    self._linkParentAndChildren(parent_v,children)

    return children
#@-node:ekr.20060919110638.5:createSaxChildren
#@+node:ekr.20060919110638.6:createSaxVnodeTree
def createSaxVnodeTree (self,sax_node,parent_v):

    v = self.createSaxVnode(sax_node,parent_v)

    self.createSaxChildren(sax_node,v)

    return v
#@nonl
#@-node:ekr.20060919110638.6:createSaxVnodeTree
#@+node:ekr.20060919110638.7:createSaxVnode
def createSaxVnode (self,sax_node,parent_v,t=None):

    c = self.c
    trace = False and self.usingClipboard
    h = sax_node.headString
    b = sax_node.bodyString

    if t:
        if trace: g.trace('clone',t,h)
    else:
        t = leoNodes.tnode(bodyString=b,headString=h)
        if trace: g.trace('     ',t,h)

        if sax_node.tnx:
            t.fileIndex = g.app.nodeIndices.scanGnx(sax_node.tnx,0)

    v = leoNodes.vnode(context=c,t=t)
    v.t.vnodeList.append(v)

    index = self.canonicalTnodeIndex(sax_node.tnx)

    self.tnodesDict [index] = t

    # g.trace('tnx','%-22s' % (index),'v',id(v),'v.t',id(v.t),'body','%-4d' % (len(b)),h)

    self.handleVnodeSaxAttributes(sax_node,v)
    self.handleTnodeSaxAttributes(sax_node,t)

    return v
#@+node:ekr.20060919110638.8:handleTnodeSaxAttributes
def handleTnodeSaxAttributes (self,sax_node,t):

    d = sax_node.tnodeAttributes

    aDict = {}
    for key in d.keys():
        val = d.get(key)
        val2 = self.getSaxUa(key,val)
        aDict[key] = val2

    if aDict:
        # g.trace('uA',aDict)
        t.unknownAttributes = aDict
#@nonl
#@-node:ekr.20060919110638.8:handleTnodeSaxAttributes
#@+node:ekr.20061004053644:handleVnodeSaxAttributes
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded and descendentTnodeUnknownAttributes.

def handleVnodeSaxAttributes (self,sax_node,v):

    d = sax_node.attributes
    s = d.get('a')
    if s:
        # g.trace('%s a=%s %s' % (id(sax_node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        # if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.trace('setting currentVnode',v,color='red')
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnode list will be resolved later.
        # g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes') # Correct: only tnode have descendent uA's.
    if s: 
        aDict = self.getDescendentUnknownAttributes(s)
        if aDict:
            # g.trace('descendentUaDictList',aDict)
            self.descendentUnknownAttributesDictList.append(aDict)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d.keys():
        if key in self.nativeVnodeAttributes:
            if 0: g.trace('****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # g.trace('uA',aDict)
        v.unknownAttributes = aDict
#@nonl
#@-node:ekr.20061004053644:handleVnodeSaxAttributes
#@-node:ekr.20060919110638.7:createSaxVnode
#@+node:ekr.20060919110638.9:_linkParentAndChildren
def _linkParentAndChildren (self, parent_v, children):

    # if children: g.trace(parent_v,len(children))

    # Add parent_v to it's tnode's vnodeList.
    if parent_v not in parent_v.t.vnodeList:
        parent_v.t.vnodeList.append(parent_v)

    # Set parent_v's children.
    parent_v.t.children = children

    # Make parent_v a parent of each child.
    for v in children:
        if parent_v not in v.t.parents:
            v.t.parents.append(parent_v)
#@-node:ekr.20060919110638.9:_linkParentAndChildren
#@-node:ekr.20060919110638.4:createSaxVnodes & helpers
#@+node:ekr.20031218072017.2004:canonicalTnodeIndex
def canonicalTnodeIndex(self,index):

    """Convert Tnnn to nnn, leaving gnx's unchanged."""

    # index might be Tnnn, nnn, or gnx.
    junk,theTime,junk = g.app.nodeIndices.scanGnx(index,0)
    if theTime == None: # A pre-4.1 file index.
        if index[0] == "T":
            index = index[1:]

    return index
#@-node:ekr.20031218072017.2004:canonicalTnodeIndex
#@-node:ekr.20080423062035.16:Fixed paste-retaining-clones
#@+node:ekr.20080425060424.15:Undo move fixes
#@+node:ekr.20080424073114.2:Rewrote sort code
#@+node:ekr.20080416161551.217:p._unlink
def _unlink (self):

    '''Unlink the receiver from the tree.'''

    trace = True
    p = self ; n = p._childIndex
    parent_v = p._parentVnode()
        # returns None if p.v is None
    assert(p.v)
    assert(parent_v)

    # Remove v from it's tnode's vnodeList.
    if p.v in p.v.t.vnodeList:
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    # Delete p.v from parent_v's children.
    if 0 <= n < len(parent_v.t.children):
        if parent_v.t.children[n] == p.v:
            del parent_v.t.children[n]
            parent_v._p_changed = 1
        elif trace:
            g.trace('**can not happen: children[%s] != p.v' % (n))
            g.trace('parent_v.t.children...\n',g.listToString(parent_v.t.children))
            g.trace('p.v',p.v)
            g.trace(g.callers())
    elif trace:
        g.trace('can not happen: bad child index: %s, len(children): %s' % (n,len(parent_v.t.children)))
        g.trace('parent_v.t.children...\n',g.listToString(parent_v.t.children))
        g.trace('p.v',p.v)
        g.trace(g.callers())

    # Delete parent_v from p.v's parents.
    if parent_v in p.v.t.parents:
        p.v.t.parents.remove(parent_v)
        p.v._p_changed = 1 # Support for tnode class.

#@-node:ekr.20080416161551.217:p._unlink
#@+node:ekr.20080425060424.3:beforeSort
def beforeSort (self,p,undoType,oldChildren,newChildren):

    '''Create an undo node for sort operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'sort'
    bunch.undoType = undoType

    bunch.undoHelper = u.undoSort
    bunch.redoHelper = u.redoSort

    bunch.oldChildren = oldChildren
    bunch.newChildren = newChildren

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    return bunch
#@-node:ekr.20080425060424.3:beforeSort
#@+node:ekr.20080425060424.2:afterSort
def afterSort (self,p,bunch,dirtyVnodeList):

    '''Create an undo node for sort operations'''

    u = self ; c = self.c
    if u.redoing or u.undoing: return

    bunch.dirtyVnodeList = dirtyVnodeList

    # Recalculate the menu labels.
    u.setUndoTypes()

    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
#@-node:ekr.20080425060424.2:afterSort
#@+node:ekr.20080425060424.4:redoSort
def redoSort (self):

    u = self

    parent_v = u.p._parentVnode()
    parent_v.t.children = u.newChildren
#@-node:ekr.20080425060424.4:redoSort
#@+node:ekr.20080425060424.5:undoSort
def undoSort (self):

    u = self

    parent_v = u.p._parentVnode()
    parent_v.t.children = u.oldChildren
#@-node:ekr.20080425060424.5:undoSort
#@+node:ekr.20080425060424.1:Sort...
#@+node:ekr.20050415134809:c.sortChildren
def sortChildren (self,event=None,cmp=None):

    '''Sort the children of a node.'''

    c = self ; p = c.currentPosition()

    if p and p.hasChildren():
        c.sortSiblings(p=p.firstChild(),undoType='Sort Children')
#@-node:ekr.20050415134809:c.sortChildren
#@+node:ekr.20050415134809.1:c.sortSiblings
def sortSiblings (self,event=None,cmp=None,p=None,undoType='Sort Siblings'):

    '''Sort the siblings of a node.'''

    c = self ; u = c.undoer
    if p is None: p = c.currentPosition()
    if not p: return

    parent_v = p._parentVnode()
    parent = p.parent()
    oldChildren = parent_v.t.children[:]
    newChildren = parent_v.t.children[:]

    def key (self):
        return self.headString().lower()

    if cmp: newChildren.sort(cmp,key=key)
    else:   newChildren.sort(key=key)

    # g.trace(g.listToString(newChildren))

    c.beginUpdate()
    try:
        bunch = u.beforeSort(p,undoType,oldChildren,newChildren)
        parent_v.t.children = newChildren
        if parent:
            dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
        else:
            dirtyVnodeList = []
        u.afterSort(p,bunch,dirtyVnodeList)
    finally:
        c.endUpdate()


    # parent = p.parent()
    # if not parent:
        # c.sortTopLevel(cmp=cmp)
    # else:
        # c.beginUpdate()
        # try: # In update...
            # c.endEditing()
            # u.beforeChangeGroup(p,undoType)
            # c.sortChildrenHelper(parent, cmp=cmp)
            # dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
            # c.setChanged(True)
            # u.afterChangeGroup(p,'Sort Siblings',dirtyVnodeList=dirtyVnodeList)
        # finally:
            # c.endUpdate()
#@-node:ekr.20050415134809.1:c.sortSiblings
#@-node:ekr.20080425060424.1:Sort...
#@-node:ekr.20080424073114.2:Rewrote sort code
#@+node:ekr.20080425060424.11:Fixed undo/redo move
#@+node:ekr.20050410110215:beforeMoveNode
def beforeMoveNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    # bunch.oldBack = p.back()
    # bunch.oldParent = p.parent()
    bunch.oldN = p.childIndex()
    bunch.oldParent_v = p._parentVnode()

    return bunch
#@-node:ekr.20050410110215:beforeMoveNode
#@+node:ekr.20050410110343:afterMoveNode
def afterMoveNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set the types & helpers.
    bunch.kind = 'move'
    bunch.undoType = command

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoMove
    bunch.redoHelper = u.redoMove

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    # bunch.newBack   = p.back()
    # bunch.newParent = p.parent()
    bunch.newN = p.childIndex()
    bunch.newParent_v = p._parentVnode()
    bunch.newP = p.copy()

    u.pushBead(bunch)
#@-node:ekr.20050410110343:afterMoveNode
#@+node:ekr.20050411112033:undoMove
def undoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.newParent_v.t.children[u.newN] == v
    del u.newParent_v.t.children[u.newN]
    u.oldParent_v.t.children.insert(u.oldN,v)

    # Adjust the parent links.
    if u.newParent_v in v.t.parents:
        v.t.parents.remove(u.newParent_v)

    if u.oldParent_v not in v.t.parents:
        v.t.parents.append(u.oldParent_v)

    # if u.oldParent:
        # u.p.moveToNthChildOf(u.oldParent,u.oldN)
    # elif u.oldBack:
        # u.p.moveAfter(u.oldBack)
    # else:
        # u.p.moveToRoot(oldRoot=c.rootPosition())


    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    if u.newParent_v != u.oldParent_v:
        if u.newP.parent():
            u.newP.parent().contract()

    c.selectPosition(u.p)
#@-node:ekr.20050411112033:undoMove
#@+node:ekr.20050411111847:redoMove
def redoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.oldParent_v.t.children[u.oldN] == v
    del u.oldParent_v.t.children[u.oldN]
    u.newParent_v.t.children.insert(u.newN,v)

    # Adjust the parent links.
    if u.oldParent_v in v.t.parents:
        v.t.parents.remove(u.oldParent_v)

    if u.newParent_v not in v.t.parents:
        v.t.parents.append(u.newParent_v)

    # if u.newParent:
        # u.p.moveToNthChildOf(u.newParent,u.newN)
    # elif u.newBack:
        # u.p.moveAfter(u.newBack)
    # else:
        # oldRoot = c.rootPosition()
        # u.p.moveToRoot(oldRoot=oldRoot)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    if u.newParent_v != u.oldParent_v:
        if u.p.parent():
            u.p.parent().contract()

    c.selectPosition(u.newP)
#@-node:ekr.20050411111847:redoMove
#@+node:ekr.20031218072017.1766:Move... (Commands)
#@+node:ekr.20070420092425:cantMoveMessage
def cantMoveMessage (self):

    c = self ; h = c.rootPosition().headString()
    kind = g.choose(h.startswith('@chapter'),'chapter','hoist')
    g.es("can't move node out of",kind,color="blue")
#@-node:ekr.20070420092425:cantMoveMessage
#@+node:ekr.20031218072017.1767:demote
def demote (self,event=None):

    '''Make all following siblings children of the selected node.'''

    c = self ; u = c.undoer
    p = c.currentPosition()
    if not p or not p.hasNext():
        c.treeFocusHelper() ; return

    # Make sure all the moves will be valid.
    next = p.next()
    while next:
        if not c.checkMoveWithParentWithWarning(next,p,True):
            c.treeFocusHelper() ; return
        next.moveToNext()

    c.beginUpdate()
    try: # update...
        c.endEditing()
        parent_v = p._parentVnode()
        n = p.childIndex()
        followingSibs = parent_v.t.children[n+1:]
        # g.trace('sibs2\n',g.listToString(followingSibs2))
        # Adjust the parent links of all moved nodes.
        for z in followingSibs:
            if parent_v in z.t.parents:
                z.t.parents.remove(parent_v)
            if p.v not in z.t.parents:
                z.t.parents.append(p.v)
        # Remove the moved nodes from the parent's children.
        parent_v.t.children = parent_v.t.children[:n+1]
        # Add the moved nodes to p's children
        p.v.t.children.extend(followingSibs)
        p.expand()
        # Even if p is an @ignore node there is no need to mark the demoted children dirty.
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterDemote(p,followingSibs,dirtyVnodeList)
    finally:
        c.selectPosition(p)  # Also sets rootPosition.
        c.endUpdate()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1767:demote
#@+node:ekr.20031218072017.1768:moveOutlineDown
@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown (self,event=None):

    '''Move the selected node down.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    next = p.visNext(c)

    while next and p.isAncestorOf(next):
        next = next.visNext(c)
    if not next:
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        << Move p down & set moved if successful >>
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)

else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)

if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@-node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
#@-node:ekr.20031218072017.1768:moveOutlineDown
#@+node:ekr.20031218072017.1770:moveOutlineLeft
def moveOutlineLeft (self,event=None):

    '''Move the selected node left if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineLeft():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    if not p.hasParent():
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(parent)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
        if sparseMove: # New in Leo 4.4.2
            parent.contract()
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1770:moveOutlineLeft
#@+node:ekr.20031218072017.1771:moveOutlineRight
def moveOutlineRight (self,event=None):

    '''Move the selected node right if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    back = p.back()
    if not back:
        c.treeFocusHelper()
        return

    if not c.checkMoveWithParentWithWarning(p,back,True):
        c.treeFocusHelper()
        return

    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        n = back.numberOfChildren()
        p.moveToNthChildOf(back,n)
        # g.trace(p,p.parent())
        # Moving an outline right can never bring it outside the range of @ignore.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1771:moveOutlineRight
#@+node:ekr.20031218072017.1772:moveOutlineUp
def moveOutlineUp (self,event=None):

    '''Move the selected node up if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    back = p.visBack(c)
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack(c)

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        moved = False
        << Move p up >>
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)

    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1773:<< Move p up >>
if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

parent = p.parent()

# For this special case we move p after back2.
specialCase = back2 and p.v in back2.v.t.vnodeList

if specialCase:
    # The move must be legal.
    moved = True
    back2.contract()
    p.moveAfter(back2)
elif not back2:
    if c.hoistStack: # hoist or chapter.
        limit,limitIsVisible = c.visLimit()
        assert limit
        if limitIsVisible:
            # canMoveOutlineUp should have caught this.
            g.trace('can not happen. In hoist')
        else:
            # g.trace('chapter first child')
            moved = True
            p.moveToFirstChildOf(limit)
    else:
        # p will be the new root node
        p.moveToRoot(oldRoot=c.rootPosition())
        moved = True
elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)
else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)
if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@-node:ekr.20031218072017.1773:<< Move p up >>
#@-node:ekr.20031218072017.1772:moveOutlineUp
#@+node:ekr.20031218072017.1774:promote
def promote (self,event=None):

    '''Make all children of the selected nodes siblings of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    command = 'Promote'
    if not p or not p.hasChildren():
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
        return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        parent_v = p._parentVnode()
        children = p.v.t.children
        # Adjust the parent links of all moved nodes.
        for z in children:
            if p.v in z.t.parents:
                z.t.parents.remove(p.v)
            if parent_v not in z.t.parents:
                z.t.parents.append(parent_v)
        # Add the children to parent_v's children.
        n = p.childIndex()+1
        z = parent_v.t.children[:]
        parent_v.t.children = z[:n]
        parent_v.t.children.extend(children)
        parent_v.t.children.extend(z[n:])
        # Remove v's children.
        p.v.t.children = []
        c.setChanged(True)
        if not inAtIgnoreRange and isAtIgnoreNode:
            # The promoted nodes have just become newly unignored.
            dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        u.afterPromote(p,children,dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1774:promote
#@+node:ekr.20071213185710:c.toggleSparseMove
def toggleSparseMove (self,event=None):

    c = self ; p = c.currentPosition()
    tag = 'sparse_move_outline_left'

    sparseMove = not c.config.getBool(tag)
    c.config.set(p, tag, sparseMove)
    g.es(tag,'=',sparseMove,color='blue')
#@-node:ekr.20071213185710:c.toggleSparseMove
#@-node:ekr.20031218072017.1766:Move... (Commands)
#@-node:ekr.20080425060424.11:Fixed undo/redo move
#@+node:ekr.20080425060424.7:Rewrote promote/demote code
#@+node:ekr.20080425060424.8:afterDemote
def afterDemote (self,p,followingSibs,dirtyVnodeList):

    '''Create an undo node for demote operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'demote'
    bunch.undoType = 'Demote'

    bunch.undoHelper = u.undoDemote
    bunch.redoHelper = u.redoDemote

    bunch.followingSibs = followingSibs

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@-node:ekr.20080425060424.8:afterDemote
#@+node:ekr.20080425060424.12:afterPromote
def afterPromote (self,p,children,dirtyVnodeList):

    '''Create an undo node for demote operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'promote'
    bunch.undoType = 'Promote'

    bunch.undoHelper = u.undoPromote
    bunch.redoHelper = u.redoPromote

    bunch.children = children

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@-node:ekr.20080425060424.12:afterPromote
#@+node:ekr.20031218072017.1767:demote
def demote (self,event=None):

    '''Make all following siblings children of the selected node.'''

    c = self ; u = c.undoer
    p = c.currentPosition()
    if not p or not p.hasNext():
        c.treeFocusHelper() ; return

    # Make sure all the moves will be valid.
    next = p.next()
    while next:
        if not c.checkMoveWithParentWithWarning(next,p,True):
            c.treeFocusHelper() ; return
        next.moveToNext()

    c.beginUpdate()
    try: # update...
        c.endEditing()
        parent_v = p._parentVnode()
        n = p.childIndex()
        followingSibs = parent_v.t.children[n+1:]
        # g.trace('sibs2\n',g.listToString(followingSibs2))
        # Adjust the parent links of all moved nodes.
        for z in followingSibs:
            if parent_v in z.t.parents:
                z.t.parents.remove(parent_v)
            if p.v not in z.t.parents:
                z.t.parents.append(p.v)
        # Remove the moved nodes from the parent's children.
        parent_v.t.children = parent_v.t.children[:n+1]
        # Add the moved nodes to p's children
        p.v.t.children.extend(followingSibs)
        p.expand()
        # Even if p is an @ignore node there is no need to mark the demoted children dirty.
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterDemote(p,followingSibs,dirtyVnodeList)
    finally:
        c.selectPosition(p)  # Also sets rootPosition.
        c.endUpdate()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1767:demote
#@+node:ekr.20031218072017.1774:promote
def promote (self,event=None):

    '''Make all children of the selected nodes siblings of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    command = 'Promote'
    if not p or not p.hasChildren():
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
        return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        parent_v = p._parentVnode()
        children = p.v.t.children
        # Adjust the parent links of all moved nodes.
        for z in children:
            if p.v in z.t.parents:
                z.t.parents.remove(p.v)
            if parent_v not in z.t.parents:
                z.t.parents.append(parent_v)
        # Add the children to parent_v's children.
        n = p.childIndex()+1
        z = parent_v.t.children[:]
        parent_v.t.children = z[:n]
        parent_v.t.children.extend(children)
        parent_v.t.children.extend(z[n:])
        # Remove v's children.
        p.v.t.children = []
        c.setChanged(True)
        if not inAtIgnoreRange and isAtIgnoreNode:
            # The promoted nodes have just become newly unignored.
            dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        u.afterPromote(p,children,dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1774:promote
#@+node:ekr.20080425060424.9:redoDemote
def redoDemote (self):

    u = self
    parent_v = u.p._parentVnode()
    n = len(u.followingSibs)

    # Remove the moved nodes from the parent's children.
    parent_v.t.children = parent_v.t.children[:n+1]

    # Add the moved nodes to p's children
    u.p.v.t.children.extend(u.followingSibs)

    # Adjust the parent links of all moved nodes.
    for z in u.followingSibs:
        if parent_v in z.t.parents:
            z.t.parents.remove(parent_v)
        if u.p.v not in z.t.parents:
            z.t.parents.append(u.p.v)
#@-node:ekr.20080425060424.9:redoDemote
#@+node:ekr.20080425060424.10:undoDemote
def undoDemote (self):

    u = self
    parent_v = u.p._parentVnode()
    n = len(u.followingSibs)

    # Remove the demoted nodes from p's children.
    u.p.v.t.children = u.p.v.t.children[:-n]

    # Add the demoted nodes to the parent's children.
    parent_v.t.children.extend(u.followingSibs)

    # Adjust the parent links of all moved nodes.
    for z in u.followingSibs:
        if u.p.v in z.t.parents:
            z.t.parents.remove(u.p.v)
        if parent_v not in z.t.parents:
            z.t.parents.append(parent_v)
#@-node:ekr.20080425060424.10:undoDemote
#@+node:ekr.20080425060424.13:redoPromote
def redoPromote (self):

    u = self
    parent_v = u.p._parentVnode()

    # Add the children to parent_v's children.
    n = u.p.childIndex() + 1
    z = parent_v.t.children[:]
    parent_v.t.children = z[:n]
    parent_v.t.children.extend(u.children)
    parent_v.t.children.extend(z[n:])

    # Remove v's children.
    u.p.v.t.children = []

    # Adjust the parent links of all moved nodes.
    for z in u.children:
        if u.p.v in z.t.parents:
            z.t.parents.remove(u.p.v)
        if parent_v not in z.t.parents:
            z.t.parents.append(parent_v)
#@-node:ekr.20080425060424.13:redoPromote
#@+node:ekr.20080425060424.14:undoPromote
def undoPromote (self):

    u = self
    parent_v = u.p._parentVnode()

    # Remove the promoted nodes from parent_v's children.
    n = u.p.childIndex() + 1
    z = parent_v.t.children
    parent_v.t.children = z[:n]
    parent_v.t.children.extend(z[n+len(u.children):])

    # Add the demoted nodes to v's children.
    u.p.t.children = u.children[:]

    # Adjust the parent links of all moved nodes.
    for z in u.children:
        if parent_v in z.t.parents:
            z.t.parents.remove(parent_v)
        if u.p.v not in z.t.parents:
            z.t.parents.append(u.p.v)
#@-node:ekr.20080425060424.14:undoPromote
#@-node:ekr.20080425060424.7:Rewrote promote/demote code
#@+node:ekr.20080425060424.16:Test undo clone-find-all
#@-node:ekr.20080425060424.16:Test undo clone-find-all
#@+node:ekr.20080425060424.17:(done) Test undo/redo insert/delete nodes
#@-node:ekr.20080425060424.17:(done) Test undo/redo insert/delete nodes
#@-node:ekr.20080425060424.15:Undo move fixes
#@+node:ekr.20080426071701.2:Added tests to checkOutline
#@+node:ekr.20031218072017.2072:c.checkOutline
def checkOutline (self,event=None,verbose=True,unittest=False,full=True):

    """Report any possible clone errors in the outline.

    Remove any unused tnodeLists."""

    c = self ; count = 1 ; errors = 0
    isTkinter = g.app.gui and g.app.gui.guiName() == "tkinter"

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    p = c.rootPosition()
    for p in c.allNodes_iter():
        try:
            count += 1
            << remove unused tnodeList >>
            if full: # Unit tests usually set this false.
                << do full tests >>
        except AssertionError,message:
            errors += 1
            << give test failed message >>
    if verbose or not unittest:
        << print summary message >>
    return errors
#@+node:ekr.20040313150633:<< remove unused tnodeList >>
# Empty tnodeLists are not errors.
v = p.v

# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        print ; g.es_print(s,color="blue")
    delattr(v.t,"tnodeList")
    v.t._p_changed = True
#@-node:ekr.20040313150633:<< remove unused tnodeList >>
#@+node:ekr.20040323155951:<< do full tests >>
if not unittest:
    if count % 100 == 0:
        g.es('','.',newline=False)
    if count % 2000 == 0:
        g.enl()

@others
#@+node:ekr.20040314035615:assert consistency of threadNext & threadBack links
threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
    assert p == threadNext.threadBack(), "p==threadNext.threadBack"
#@-node:ekr.20040314035615:assert consistency of threadNext & threadBack links
#@+node:ekr.20040314035615.1:assert consistency of next and back links
back = p.back()
next = p.next()

if back:
    assert p == back.next(), "p==back.next"

if next:
    assert p == next.back(), "p==next.back"
#@-node:ekr.20040314035615.1:assert consistency of next and back links
#@+node:ekr.20040314035615.2:assert consistency of parent and child links
if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"

for child in p.children_iter():
    assert p == child.parent(), "p==child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent==parent"

if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent==parent"
#@-node:ekr.20040314035615.2:assert consistency of parent and child links
#@+node:ekr.20040323162707:assert that clones actually share subtrees
if p.isCloned() and p.hasChildren():
    for z in p.v.t.vnodeList:
        assert z.t == p.v.t
#@-node:ekr.20040323162707:assert that clones actually share subtrees
#@+node:ekr.20040314043623:assert consistency of vnodeList
vnodeList = p.v.t.vnodeList

for v in vnodeList:

    try:
        assert v.t == p.v.t
    except AssertionError:
        print "p",p
        print "v",v
        print "p.v",p.v
        print "v.t",v.t
        print "p.v.t",p.v.t
        raise AssertionError, "v.t == p.v.t"

    if p.v.isCloned():
        assert v.isCloned(), "v.isCloned"
        assert len(vnodeList) > 1, "len(vnodeList) > 1"
    else:
        assert not v.isCloned(), "not v.isCloned"
        assert len(vnodeList) == 1, "len(vnodeList) == 1"
#@-node:ekr.20040314043623:assert consistency of vnodeList
#@+node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
# Not a great test: it only tests visible nodes.
# This test may fail if a joined node is being editred.

if isTkinter:
    t = c.edit_widget(p)
    if t:
        s = t.getAllText()
        assert p.headString().strip() == s.strip(), "May fail if joined node is being edited"
#@-node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
#@+node:ekr.20080426051658.1:assert consistency of t.parent and t.children arrays
@
Every nodes gets visited, so we only check consistency
between p and its parent, not between p and its children.

In other words, this is a strong test.
@c

parent_v = p._parentVnode()
n = p.childIndex()

assert parent_v.t.children[n] == p.v,'fail 1'

assert parent_v in p.v.t.parents,'fail 2: parent_v: %s, parents: %s' % (
    parent_v,p.v.t.parents)
#@-node:ekr.20080426051658.1:assert consistency of t.parent and t.children arrays
#@-node:ekr.20040323155951:<< do full tests >>
#@+node:ekr.20040314044652:<< give test failed message >>
s = "test failed: %s %s" % (message,repr(p))
print s ; g.es_print(s,color="red")
#@-node:ekr.20040314044652:<< give test failed message >>
#@+node:ekr.20040314043900:<<print summary message >>
if full:
    print
    g.enl()

if errors or verbose:
    color = g.choose(errors,'red','green')
    g.es_print('',count,'nodes checked',errors,'errors',color=color)
#@-node:ekr.20040314043900:<<print summary message >>
#@-node:ekr.20031218072017.2072:c.checkOutline
#@-node:ekr.20080426071701.2:Added tests to checkOutline
#@+node:ekr.20080426051658.2:Fixed inconsistencies between parents and children arrays
#@+node:ekr.20060919110638.4:createSaxVnodes & helpers
def createSaxVnodes (self,saxRoot,reassignIndices):

    '''**Important**: this method and its helpers are low-level code
    corresponding to link/unlink methods in leoNodes.py.
    Modify this with extreme care.'''


    parent_v = self.c.hiddenRootNode

    children = self.createSaxChildren(saxRoot,parent_v=parent_v)

    return children
#@+node:ekr.20060919110638.5:createSaxChildren
def createSaxChildren (self, sax_node, parent_v):

    children = []

    for child in sax_node.children:
        tnx = child.tnx
        t = self.tnodesDict.get(tnx)
        if t:
            # A clone.  Create a new clone vnode, but share the subtree, i.e., the tnode.
            v = self.createSaxVnode(child,parent_v,t=t)
            # g.trace('**clone',v)
            if v not in t.parents:
                t.parents.append(v)
            for grandChild in v.t.children:
                if v not in grandChild.t.parents:
                    # g.trace('adding %s to parents of %s' % (v,grandChild))
                    grandChild.t.parents.append(v)
        else:
            v = self.createSaxVnodeTree(child,parent_v)
        children.append(v)

    self._linkParentAndChildren(parent_v,children)

    return children
#@-node:ekr.20060919110638.5:createSaxChildren
#@+node:ekr.20060919110638.6:createSaxVnodeTree
def createSaxVnodeTree (self,sax_node,parent_v):

    v = self.createSaxVnode(sax_node,parent_v)

    self.createSaxChildren(sax_node,v)

    return v
#@nonl
#@-node:ekr.20060919110638.6:createSaxVnodeTree
#@+node:ekr.20060919110638.7:createSaxVnode
def createSaxVnode (self,sax_node,parent_v,t=None):

    c = self.c
    trace = False and self.usingClipboard
    h = sax_node.headString
    b = sax_node.bodyString

    if t:
        if trace: g.trace('clone',t,h)
    else:
        t = leoNodes.tnode(bodyString=b,headString=h)
        if trace: g.trace('     ',t,h)

        if sax_node.tnx:
            t.fileIndex = g.app.nodeIndices.scanGnx(sax_node.tnx,0)

    v = leoNodes.vnode(context=c,t=t)
    v.t.vnodeList.append(v)

    index = self.canonicalTnodeIndex(sax_node.tnx)

    self.tnodesDict [index] = t

    # g.trace('tnx','%-22s' % (index),'v',id(v),'v.t',id(v.t),'body','%-4d' % (len(b)),h)

    self.handleVnodeSaxAttributes(sax_node,v)
    self.handleTnodeSaxAttributes(sax_node,t)

    return v
#@+node:ekr.20060919110638.8:handleTnodeSaxAttributes
def handleTnodeSaxAttributes (self,sax_node,t):

    d = sax_node.tnodeAttributes

    aDict = {}
    for key in d.keys():
        val = d.get(key)
        val2 = self.getSaxUa(key,val)
        aDict[key] = val2

    if aDict:
        # g.trace('uA',aDict)
        t.unknownAttributes = aDict
#@nonl
#@-node:ekr.20060919110638.8:handleTnodeSaxAttributes
#@+node:ekr.20061004053644:handleVnodeSaxAttributes
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded and descendentTnodeUnknownAttributes.

def handleVnodeSaxAttributes (self,sax_node,v):

    d = sax_node.attributes
    s = d.get('a')
    if s:
        # g.trace('%s a=%s %s' % (id(sax_node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        # if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.trace('setting currentVnode',v,color='red')
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnode list will be resolved later.
        # g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes') # Correct: only tnode have descendent uA's.
    if s: 
        aDict = self.getDescendentUnknownAttributes(s)
        if aDict:
            # g.trace('descendentUaDictList',aDict)
            self.descendentUnknownAttributesDictList.append(aDict)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d.keys():
        if key in self.nativeVnodeAttributes:
            if 0: g.trace('****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # g.trace('uA',aDict)
        v.unknownAttributes = aDict
#@nonl
#@-node:ekr.20061004053644:handleVnodeSaxAttributes
#@-node:ekr.20060919110638.7:createSaxVnode
#@+node:ekr.20060919110638.9:_linkParentAndChildren
def _linkParentAndChildren (self, parent_v, children):

    # if children: g.trace(parent_v,len(children))

    # Add parent_v to it's tnode's vnodeList.
    if parent_v not in parent_v.t.vnodeList:
        parent_v.t.vnodeList.append(parent_v)

    # Set parent_v's children.
    parent_v.t.children = children

    # Make parent_v a parent of each child.
    for v in children:
        if parent_v not in v.t.parents:
            v.t.parents.append(parent_v)
#@-node:ekr.20060919110638.9:_linkParentAndChildren
#@-node:ekr.20060919110638.4:createSaxVnodes & helpers
#@+node:ekr.20041005105605.72:createThinChild4
def createThinChild4 (self,gnxString,headline):

    """Find or create a new *vnode* whose parent (also a vnode) is at.lastThinNode."""

    at = self ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)

    # New in Leo 4.4a5: Solve Read @file nodes problem (by LeoUser)
    if self._forcedGnxPositionList and last in self._forcedGnxPositionList:
        last.fileIndex = lastIndex =  gnx
        self._forcedGnxPositionList.remove(last)

    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)

    # See if there is already a child with the proper index.
    # child = at.lastThinNode.firstChild()
    # while child and not indices.areEqual(gnx,child.t.fileIndex):
        # child = child.next()
    children = at.lastThinNode.t.children
    for child in children:
        if indices.areEqual(gnx,child.t.fileIndex):
            break
    else:
        child = None

    if at.cloneSibCount > 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            last.t.setVisited() # Supress warning/deletion of unvisited nodes.
            return last
        if child:
            child.t.setVisited() # Supress warning/deletion of unvisited nodes.
            return child
        copies = 1 # Create exactly one copy.

    while copies > 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            isClone = True
            if indices.areEqual(t.fileIndex,gnx):
                pass
            else:
                g.trace('can not happen: t.fileIndex: %s gnx: %s' % (t.fileIndex,gnx))
                # g.trace('not created, should already exist',gnxString)
        else:
            isClone = False
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(context=c,t=t)
        t.vnodeList.append(child)
        child._linkAsNthChild(parent,parent.numberOfChildren())

        if isClone:
            # g.trace('**clone',child)
            if parent not in t.parents:
                t.parents.append(parent)
            for grandChild in child.t.children:
                if child not in grandChild.t.parents:
                    # g.trace('adding %s to parents of %s' % (child,grandChild))
                    grandChild.t.parents.append(child)

        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    child.t.setVisited() # Supress warning/deletion of unvisited nodes.
    return child
#@-node:ekr.20041005105605.72:createThinChild4
#@+node:ekr.20080416161551.215:p._linkAsNthChild
def _linkAsNthChild (self,parent,n):

    p = self
    parent_v = parent.v

    # Init the ivars.
    p.stack = parent.stack[:]
    p.stack.append((parent_v,parent._childIndex),)
    p._childIndex = n

    # Add p.v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    # Add p.v to parent_v's children.
    parent_v.t.children.insert(n,p.v)
    parent_v._p_changed = 1

    # Add parent_v to p.v's parents.
    if not parent_v in p.v.t.parents:
        p.v.t.parents.append(parent_v)
        p.v._p_changed = 1
#@-node:ekr.20080416161551.215:p._linkAsNthChild
#@-node:ekr.20080426051658.2:Fixed inconsistencies between parents and children arrays
#@-node:ekr.20080421162832.7:Recent graph-world bugs
#@+node:ekr.20080409111805.1:Cleanup
#@+node:ekr.20080409081425.1:Remove useTextWidget option from leoKeys.py
#@-node:ekr.20080409081425.1:Remove useTextWidget option from leoKeys.py
#@+node:ekr.20080409111805.2:Set use_sax = True always
#@+node:ekr.20031218072017.3019:leoFileCommands._init_
def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame

    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a','descendentTnodeUnknownAttributes',
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )
    self.initIvars()

def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding
    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentUnknownAttributesDictList = []
    self.ratio = 0.5

    self.currentVnode = None
    self.rootVnode = None

    # For writing
    self.read_only = False
    self.rootPosition = None
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    # self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
#@-node:ekr.20031218072017.3019:leoFileCommands._init_
#@+node:ekr.20060919110638.13:setPositionsFromVnodes & helper
def setPositionsFromVnodes (self):

    c = self.c ; p = c.rootPosition()

    current = None
    d = hasattr(p.v,'unknownAttributes') and p.v.unknownAttributes
    if d:
        s = d.get('str_leo_pos')
        if s:
            current = self.archivedPositionToPosition(s)

    c.setCurrentPosition(current or c.rootPosition())
#@nonl
#@+node:ekr.20061006104837.1:archivedPositionToPosition
def archivedPositionToPosition (self,s):

    c = self.c
    aList = s.split(',')
    try:
        aList = [int(z) for z in aList]
    except Exception:
        # g.trace('oops: bad archived position. not an int:',aList,c)
        aList = None
    if not aList: return None
    p = c.rootPosition() ; level = 0
    while level < len(aList):
        i = aList[level]
        while i > 0:
            if p.hasNext():
                p.moveToNext()
                i -= 1
            else:
                # g.trace('oops: bad archived position. no sibling:',aList,p.headString(),c)
                return None
        level += 1
        if level < len(aList):
            p.moveToFirstChild()
            # g.trace('level',level,'index',aList[level],p.headString())
    return p
#@nonl
#@-node:ekr.20061006104837.1:archivedPositionToPosition
#@-node:ekr.20060919110638.13:setPositionsFromVnodes & helper
#@-node:ekr.20080409111805.2:Set use_sax = True always
#@-node:ekr.20080409111805.1:Cleanup
#@+node:ekr.20080408060320.783:Features
#@+node:ekr.20080407090400.3:Added install nodes re Leo's home directory
@nocolor

Leo puts several files in the home directory: .leoID.txt,
.leoRecentFiles.txt, and myLeoSettings.leo.  There are various fallback directories if there is no home directory.

If you want more details, you can do what I did: do a clone-find-all for homeDir.

As for how the home directory is set, the code to do this is g.computeHomeDir.  We get the home directory with

home = os.getenv('HOME',default=None)

There are some mind-numbing details to be handled if there os.getenv does, in fact, return a directory.

@color
#@nonl
#@+node:ekr.20080407090400.4:Found: homeDir
#@+node:ekr.20070224115832:readRecentFiles & helpers
def readRecentFiles (self,localConfigFile):

    '''Read all .leoRecentFiles.txt files.'''

    # The order of files in this list affects the order of the recent files list.
    seen = [] 
    localConfigPath = g.os_path_dirname(localConfigFile)
    for path in (
        g.app.homeDir,
        g.app.globalConfigDir,
        localConfigPath,
    ):
        if path and path not in seen:
            ok = self.readRecentFilesFile(path)
            if ok: seen.append(path)
    if not seen and self.write_recent_files_as_needed:
        self.createRecentFiles()
#@nonl
#@+node:ekr.20061010121944:createRecentFiles
def createRecentFiles (self):

    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created',fileName,color='red')
                return
            except Exception:
                g.es_print('can not create',fileName,color='red')
                g.es_exception()
#@nonl
#@-node:ekr.20061010121944:createRecentFiles
#@+node:ekr.20050424115658:readRecentFilesFile
def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
        if not g.unitTesting and not self.silent:
            print ('reading %s' % fileName)
        lines = file(fileName).readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
            self.appendToRecentFiles(lines)

    return ok
#@nonl
#@-node:ekr.20050424115658:readRecentFilesFile
#@-node:ekr.20070224115832:readRecentFiles & helpers
#@+node:ekr.20061010121944:createRecentFiles
def createRecentFiles (self):

    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created',fileName,color='red')
                return
            except Exception:
                g.es_print('can not create',fileName,color='red')
                g.es_exception()
#@nonl
#@-node:ekr.20061010121944:createRecentFiles
#@+node:ekr.20050424114937.2:writeRecentFilesFile & helper
recentFileMessageWritten = False

def writeRecentFilesFile (self,c):

    '''Write the appropriate .leoRecentFiles.txt file.'''

    tag = '.leoRecentFiles.txt'

    if g.app.unitTesting:
        return

    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None

    written = False
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                if not self.recentFileMessageWritten:
                    print ('wrote recent file: %s' % fileName)
                    written = True
                self.writeRecentFilesFileHelper(fileName)
                # Bug fix: Leo 4.4.6: write *all* recent files.

    if written:
        self.recentFileMessageWritten = True
    else:
        pass # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
#@+node:ekr.20050424131051:writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)

    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
            # g.trace(fileName,'lines\n%s' % lines)
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass

    except Exception:
        g.es('unexpected exception writing',fileName,color='red')
        g.es_exception()

    if theFile:
        theFile.close()
#@-node:ekr.20050424131051:writeRecentFilesFileHelper
#@-node:ekr.20050424114937.2:writeRecentFilesFile & helper
#@+node:ekr.20041117083857:initSettingsFiles
def initSettingsFiles (self):

    """Set self.globalConfigFile, self.homeFile, self.myGlobalConfigFile,
    self.myHomeConfigFile, and self.machineConfigFile."""

    settingsFile = 'leoSettings.leo'
    mySettingsFile = 'myLeoSettings.leo'
    machineConfigFile = g.computeMachineName() + 'LeoSettings.leo'

    for ivar,theDir,fileName in (
        ('globalConfigFile',    g.app.globalConfigDir,  settingsFile),
        ('homeFile',            g.app.homeDir,          settingsFile),
        ('myGlobalConfigFile',  g.app.globalConfigDir,  mySettingsFile),
        #non-prefixed names take priority over prefixed names
        ('myHomeConfigFile',    g.app.homeDir,          g.app.homeSettingsPrefix + mySettingsFile),
        ('myHomeConfigFile',    g.app.homeDir,          mySettingsFile),
        ('machineConfigFile',   g.app.homeDir,          g.app.homeSettingsPrefix + machineConfigFile),
        ('machineConfigFile',   g.app.homeDir,          machineConfigFile),
    ):
        # The same file may be assigned to multiple ivars:
        # readSettingsFiles checks for such duplications.
        path = g.os_path_join(theDir,fileName)
        if g.os_path_exists(path):
            setattr(self,ivar,path)
        #else:
            #if the path does not exist, only set to None if the ivar isn't already set.
            #dan: IMO, it's better to set the defaults to None in configClass.__init__().
            #     This avoids the creation of ivars in odd (non __init__) places.
            #setattr(self,ivar, getattr(self,ivar,None))
    if 0:
        g.trace('global file:',self.globalConfigFile)
        g.trace('home file:',self.homeFile)
        g.trace('myGlobal file:',self.myGlobalConfigFile)
        g.trace('myHome file:',self.myHomeConfigFile)
#@nonl
#@-node:ekr.20041117083857:initSettingsFiles
#@+node:ekr.20080220082727:@scan_g.es_results
@first # -*- coding: utf-8 -*-

@ To be translated...

#if and #else parts have different braces:
%s dir:
(in
)
*** Two exclusive handlers for
***Updating:
...
:
= requires @root in the headline
@comment disables untangle for
Indentation error in
Leo Log Window...
ParserError in
Referenced from
This is for testing if g.es blocks in a thread
Token error in
TokenError in
\nauto-completer scan complete
\ntest of es_print: Ă
adding
after
all plugin handlers...
all tests enabled: this may take awhile
already loaded
auto-saving outline
bad
bad @+leo sentinel
bad @+node sentinel
bad abbrev:
bad encoding in derived file:
bad open/close_flash_brackets setting: using defaults
bad tnode index:
blanks converted to tabs in
buffers...
c.target_language:
can not add
can not create
can not create temp file
can not create: read only:
can not execute
can not import
can not import Image module from PIL
can not import ImageTk module
can not import gc module
can not load enabled plugin:
can not load image:
can not open
can not open Aspell
can not open dictionary file:
can not open local dictionary
can not open script file:
can not open:
can not write %s
can't happen: is_sentinel
can't move node out of
changed:
check complete
check-derived-file passed
check-leo-file failed:
check-leo-file passed
checking Python code
clearing undo
collapse_nodes_during_finds
command is not valid in batch mode
command not ready yet
conflicting @header and @noheader directives
correcting hidden node: t=
correcting line endings in:
count:
created
created chapter
created directory:
created in
created:
creating menu from
creating new window
creating:
current directory:
debugger does not exist:
default tangle directory not found:
deleting tnode list for
directory
directory:
disabling save commands
done
dubious brackets in
dummy created
empty
enabled brief gc stats
enabled plugins...
enabled verbose gc stats
end of script
error handling:
error parsing
error pretty-printing
error reading:
error:
errors
errors inhibited read @auto
event
exception binding
exception creating directory:
exception creating temp file
exception creating:
exception deleting backup file:
exception deleting:
exception executing
exception executing command
exception executing script
exception executing:
exception handling
exception in
exception in g.importFromPath
exception in os.chmod
exception loading plugin
exception opening:
exception removing:
exception renaming
exception writing:
extend mode
file not found
file not found:
finished
first mismatched line at line
from
g.app.config: bad encoding:
g.init_zodb: can not import ZODB
g.init_zodb: exception creating ZODB.DB instance
generated line:
get_focus:
gui does not support a stand-alone find dialog
gui does not support the compare window
handlers for
hasFocusWidget:
head_lines:
ignoring
ignoring 3.x sentinel:
ignoring bad @comment directive:
ignoring bad @comment sentinel:
ignoring bad @language directive:
ignoring bad @language sentinel:
ignoring bad unknownAttributes key
ignoring command: already executing a command.
ignoring invalid key binding:
ignoring non-dictionary unknownAttributes for
ignoring non-pickleable attribute
ignoring non-string attribute
ignoring redundant -noref in:
ignoring redundant -nosent in:
ignoring:
ignoring: @comment
imported
in
in file:
indentation error in
info string
inhibits untangle for
ins:
inserting @ignore
instances
invalid @+leo sentinel in
invalid @encoding:
invalid @lineending directive:
invalid Paste As Clone
invalid encoding in .leo file:
is a sentinel line
is also a prefix of
is bound to:
is not
is not in the outline
len
leoID=
line
line:
lines
load dir:
loadOnePlugin: failed to load module
loaded plugin:
looking for a parent to tangle...
lossage...
may be read-only or in use
minibuffer hidden
missing lines
missing vnode:
modes conflict in:
newTnode: unexpected index type:
no @auto nodes in the selected tree
no @file node in the selected tree
no @file nodes in the selected tree
no @test or @suite nodes in selected outline
no Find script node
no ancestor @file node: using script line numbers
no bindings
no child index for
no children and less than 10 characters (excluding directives)
no debugger found.
no dirty @auto nodes in the selected tree
no dirty @file nodes
no docstring for
no file name
no matching #endif:
no more clones
no more misspellings
no previous command
no script selected
no state function for
no such command:
no text selected
no tnode with index:
nodes
nodes checked
not a clone:
not a valid MORE file
not changed.
not found
not found in
not found:
not written:
nothing follows section name
offending line...
offending line:\n
only
or
original line:
over-riding setting:
parent node:
path does not exist:
plugin
probably an outline topology error.
psyco now logging to:
psyco now running
putCount
putDescendentUnknownAttributes can't happen 2
putDescendentUnknownAttributes: unexpected pickling exception
putUaHelper: unexpected pickling exception
read only
read only:
reading:
recreating:
redefining
redo
relative path in @path directive:
relative_path_base_directory:
rename failed: no file created!
reopening:
replacing
requestedFocusWidget:
restoring
resurrected node:
running
save commands disabled
saved:
scanGnx: unexpected index type:
scanning for auto-completer...
seems to be mixed HTML and PHP:
selected text should contain one or more section names
selected text should start with a section name
skipping settings in
surprise in checkPythonNode
swap-words command not ready yet
syntax error in class node: can not continue
syntax error in:
syntax error: deleting
tabs converted to blanks in
tail_lines:
tangle complete
tangling parent
tangling...
the
the clipboard is not valid
the current node is not a clone
the text will be discarded
there may be conflicting settings!
time.strftime not available on this platform
time/count:
time:
to
to dictionary
unchanged:
undo
unexpected exception converting hexlified string to string
unexpected exception in
unexpected exception in app.setLeoID
unexpected exception in c.openWith
unexpected exception in g.create_temp_file
unexpected exception in g.getScript
unexpected exception in g.importFromPath(%s)
unexpected exception parsing
unexpected exception writing
unit tests
unknown attributes for
unknown attributes for tnode
unknown command name:
unknown language: using Python comment delimiters
unknown option:
unmatched
untangle complete
untangling...
using
using -asis option in:
using -thin option in:
using a blank one instead
using empty text.
using os.getenv('USER'):
warning:
warning: conflicting values for
warning: ignoring
warning: possible duplicate definition of:
warning: updating changed text in
with
write the @file node or use the Import Derived File command
writing erroneous:
wrote:
you may want to delete ressurected nodes
@c
# Decls...
color='red'
newline=True
tabName='Log'
False = 'False'
aList = 'aList'
args = 'args'
at_DOT_outputFileName = 'at.outputFileName'
at_DOT_root_DOT_headString_PARENS_ = 'at.root.headString()'
attrDict_DOT_get_LP_key_RP_ = 'attrDict.get(key)'
b2_DOT_pane = 'b2.pane'
backupName = 'backupName'
badline = 'badline'
base = 'base'
bindStroke = 'bindStroke'
bindings = 'bindings'
bunch_DOT_kind = 'bunch.kind'
c_DOT_config_DOT_getBool_LP__SQ_collapse_nodes_during_finds_SQ__RP_ = 'c.config.getBool(\'collapse_nodes_during_finds\')'
c_DOT_disableCommandsMessage = 'c.disableCommandsMessage'
c_DOT_shortFileName_PARENS_ = 'c.shortFileName()'
c_DOT_tangle_directory = 'c.tangle_directory'
c_DOT_target_language = 'c.target_language'
c_DOT_widget_name_LP_c_DOT_get_focus_PARENS__RP_ = 'c.widget_name(c.get_focus())'
c_DOT_widget_name_LP_c_DOT_hasFocusWidget_RP_ = 'c.widget_name(c.hasFocusWidget)'
c_DOT_widget_name_LP_c_DOT_requestedFocusWidget_RP_ = 'c.widget_name(c.requestedFocusWidget)'
c_DOT_widget_name_LP_w_RP_ = 'c.widget_name(w)'
ch = 'ch'
command = 'command'
commandName = 'commandName'
computeProxyObject = 'computeProxyObject'
configDir = 'configDir'
count = 'count'
d_DOT_get_LP_ch_RP_ = 'd.get(ch)'
d2 = 'd2'
d3 = 'd3'
data = 'data'
debugger = 'debugger'
delim1 = 'delim1'
delim2 = 'delim2'
delim3 = 'delim3'
dictionaryFileName = 'dictionaryFileName'
dir2 = 'dir2'
doc = 'doc'
dst = 'dst'
e = 'e'
encoding = 'encoding'
encodingName = 'encodingName'
errors = 'errors'
eventName = 'eventName'
exctype_DOT___name__ = 'exctype.__name__'
fileName = 'fileName'
file_name = 'file_name'
filename = 'filename'
fn = 'fn'
g_DOT_angleBrackets_LP__DQ___DQ__RP_ = 'g.angleBrackets("*")'
g_DOT_app_DOT_globalOpenDir = 'g.app.globalOpenDir'
g_DOT_app_DOT_gui_DOT_getFullVersion_LP_c_RP_ = 'g.app.gui.getFullVersion(c)'
g_DOT_app_DOT_gui_DOT_guiName_PARENS_ = 'g.app.gui.guiName()'
g_DOT_app_DOT_leoID = 'g.app.leoID'
g_DOT_choose_LP_val_COMMA__SQ_on_SQ__COMMA__SQ_off_SQ__RP_ = 'g.choose(val,\'on\',\'off\')'
g_DOT_get_line_LP_s_COMMA_i_RP_ = 'g.get_line(s,i)'
g_DOT_plugin_date_LP_m_RP_ = 'g.plugin_date(m)'
g_DOT_shortFileName_LP_fileName_RP_ = 'g.shortFileName(fileName)'
g_DOT_shortFileName_LP_path_RP_ = 'g.shortFileName(path)'
h = 'h'
head_lines = 'head_lines'
headline = 'headline'
homeDir = 'homeDir'
i = 'i'
index = 'index'
inputFileName = 'inputFileName'
ins = 'ins'
ivar = 'ivar'
k_DOT_prettyPrintKey_LP_stroke_RP_ = 'k.prettyPrintKey(stroke)'
k_DOT_state_DOT_kind = 'k.state.kind'
key = 'key'
keys = 'keys'
kind = 'kind'
len_LP_lines_RP_ = 'len(lines)'
len_LP_s_RP_ = 'len(s)'
letter = 'letter'
line = 'line'
line1 = 'line1'
line2 = 'line2'
loadDir = 'loadDir'
lp = 'lp'
m = 'm'
m_DOT___name__ = 'm.__name__'
m_DOT___version__ = 'm.__version__'
message = 'message'
min_LP_12_COMMA_n2_RP_ = 'min(12,n2)'
min_LP_20_COMMA_n1_RP_ = 'min(20,n1)'
modeName = 'modeName'
moduleName = 'moduleName'
msg = 'msg'
n = 'n'
n1 = 'n1'
n2 = 'n2'
n3 = 'n3'
name = 'name'
newFileName = 'newFileName'
p_DOT_headString_PARENS_ = 'p.headString()'
p_DOT_parent_PARENS__DOT_headString_PARENS_ = 'p.parent().headString()'
pane = 'pane'
part_DOT_name = 'part.name'
path = 'path'
prefix = 'prefix'
ratio = 'ratio'
relative_path = 'relative_path'
repr_LP_at_DOT_t_RP_ = 'repr(at.t)'
repr_LP_ch_RP_ = 'repr(ch)'
repr_LP_data_RP_ = 'repr(data)'
repr_LP_g_DOT_app_DOT_leoID_RP_ = 'repr(g.app.leoID)'
repr_LP_line_RP_ = 'repr(line)'
repr_LP_theId_RP_ = 'repr(theId)'
repr_LP_val_RP_ = 'repr(val)'
requestedType = 'requestedType'
root_DOT_headString_PARENS_ = 'root.headString()'
rp = 'rp'
s = 's'
s_DOT_strip_PARENS_ = 's.strip()'
s1 = 's1'
s2 = 's2'
s3 = 's3'
section_DOT_name = 'section.name'
self_DOT_currentWord = 'self.currentWord'
self_DOT_fileName = 'self.fileName'
self_DOT_outputFileName = 'self.outputFileName'
self_DOT_print_mode = 'self.print_mode'
self_DOT_putCount = 'self.putCount'
self_DOT_shortFileName = 'self.shortFileName'
self_DOT_tabName = 'self.tabName'
self_DOT_targetFileName = 'self.targetFileName'
sep = 'sep'
setting = 'setting'
shortcut = 'shortcut'
signon = 'signon'
spaces = 'spaces'
sparseMove = 'sparseMove'
src = 'src'
start = 'start'
start_line = 'start_line'
str_LP_i_1_RP_ = 'str(i+1)'
str_LP_index_RP_ = 'str(index)'
str_LP_message_RP_ = 'str(message)'
str_LP_msg_RP_ = 'str(msg)'
str_LP_n_RP_ = 'str(n)'
str_LP_time_RP_ = 'str(time)'
stroke = 'stroke'
tag = 'tag'
tail_lines = 'tail_lines'
target = 'target'
theDir = 'theDir'
theFile = 'theFile'
time_DOT_clock_PARENS_ = 'time.clock()'
title = 'title'
torv = 'torv'
type_LP_index_RP_ = 'type(index)'
type_LP_s_RP_ = 'type(s)'
url = 'url'
v_DOT_headString_PARENS_ = 'v.headString()'
val = 'val'
value = 'value'
version = 'version'
vnodeName = 'vnodeName'
word = 'word'
z = 'z'
z_line = 'z_line'
z_opt = 'z_opt'
zipMark = 'zipMark'
g.app.translateToUpperCase=True
# ---- @thin leo.py 
g.es_print('','-------------------- @thin leo.py ',color='red')
# -- node run
g.es("disabling save commands",color="red")
# -- node createFrame (leo.py)
g.es("file not found:",fileName)
# -- node getBatchScript
g.es_print("can not open script file:",name, color="red")
# -- node reportDirectories
g.es("%s dir:" % (kind),theDir,color="blue")
# -- node startPsyco
g.es("psyco now logging to:",theFile,color="blue")
g.es("psyco now running",color="blue")
# ---- @thin leoApp.py
g.es_print('','-------------------- @thin leoApp.py',color='red')
# -- node < < return if we can set leoID from sys.leoID> >
# g.es_print("leoID=",g.app.leoID,spaces=False,color='red')
g.es_print("leoID=",g_DOT_app_DOT_leoID,spaces=False,color='red')
# -- node < < return if we can set leoID from "leoID.txt" > >
# g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('leoID=',g_DOT_app_DOT_leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
g.es_print('unexpected exception in app.setLeoID',color='red')
# -- node < < return if we can set leoID from os.getenv('USER') > >
# g.es("using os.getenv('USER'):",repr(theId),color='red')
g.es("using os.getenv('USER'):",repr_LP_theId_RP_,color='red')
# -- node < < put up a dialog requiring a valid id > >
# g.es('leoID=',repr(g.app.leoID),spaces=False,color="blue")
g.es('leoID=',repr_LP_g_DOT_app_DOT_leoID_RP_,spaces=False,color="blue")
# -- node < < attempt to create leoID.txt > >
g.es_print('',tag,'created in',theDir,color='red')
g.es('can not create',tag,'in',theDir,color='red')
# -- node app.writeWaitingLog
g.es('',s,color=color,newline=0)
# ---- @thin leoAtFile.py
g.es_print('','-------------------- @thin leoAtFile.py',color='red')
# -- node checkDerivedFile (atFile)
g.es_print('check-derived-file passed',color='blue')
# -- node < < warn on read-only file > >
g.es("read only:",fn,color="red")
# -- node read
# g.es("reading:",root.headString())
g.es("reading:",root_DOT_headString_PARENS_)
# -- node < < advise user to delete all unvisited nodes > >
# g.es('resurrected node:',p.headString(),color='blue')
g.es('resurrected node:',p_DOT_headString_PARENS_,color='blue')
g.es('in file:',fileName,color='blue')
g.es('you may want to delete ressurected nodes')
# -- node readAll (atFile)
g.es("no @file nodes in the selected tree")
# -- node readOneAtAutoNode (atFile)
# g.es("reading:",p.headString())
g.es("reading:",p_DOT_headString_PARENS_)
g.es_print('errors inhibited read @auto',fileName,color='red')
# -- node createNthChild3
g.es("dummy created")
# -- node handleLinesFollowingSentinel
g.es("using",s)
# g.es('',len(lines), "lines",m)
g.es('',len_LP_lines_RP_, "lines",m)
# -- node findChild4
g.es("write the @file node or use the Import Derived File command")
# -- node < < indicate that the node has been changed > >
# g.es("warning: updating changed text in",at.root.headString(),color="blue")
g.es("warning: updating changed text in",at_DOT_root_DOT_headString_PARENS_,color="blue")
# -- node < < bump at.correctedLines and tell about the correction > >
# g.es("correcting hidden node: t=",repr(at.t),color="red")
g.es("correcting hidden node: t=",repr_LP_at_DOT_t_RP_,color="red")
# -- node ignoreOldSentinel
g.es("ignoring 3.x sentinel:",s.strip(),color="blue")
# -- node < < handle @language > >
g.es("ignoring bad @language sentinel:",line,color="red")
# -- node < < handle @comment > >
g.es("ignoring bad @comment sentinel:",line,color="red")
# -- node copyAllTempBodyStringsToTnodes
# g.es("changed:",p.headString(),color="blue")
g.es("changed:",p_DOT_headString_PARENS_,color="blue")
# -- node < < read optional encoding param > >
g.es_print("bad encoding in derived file:",encoding)
# -- node < < set dirty and orphan bits on error > >
# g.es("not written:",at.outputFileName)
g.es("not written:",at_DOT_outputFileName)
# -- node < < say the command is finished > >
g.es("finished")
g.es("no @file nodes in the selected tree")
g.es("no dirty @file nodes")
# -- node writeAtAutoNodesHelper
g.es("finished")
g.es("no dirty @auto nodes in the selected tree")
g.es("no @auto nodes in the selected tree")
# -- node writeOneAtAutoNode & helpers
# g.es("not written:",at.outputFileName)
g.es("not written:",at_DOT_outputFileName)
# g.es("not written:",at.outputFileName)
g.es("not written:",at_DOT_outputFileName)
# -- node shouldWriteAtAutoNode
# g.es_print(p.headString(),'not written:',color='red')
g.es_print(p_DOT_headString_PARENS_,'not written:',color='red')
g.es_print('no children and less than 10 characters (excluding directives)',color='red')
# -- node writeMissing
g.es("finished")
g.es("no @file node in the selected tree")
# -- node hasSectionName
g.es('dubious brackets in',line)
# -- node < < handle @language > >
g.es("ignoring bad @language directive:",line,color="blue")
# -- node < < handle @comment > >
g.es("ignoring bad @comment directive:",line,color="blue")
# -- node replaceTargetFileIfDifferent
# g.es('unchanged:',self.shortFileName)
g.es('unchanged:',self_DOT_shortFileName)
# g.es('wrote:    ',self.shortFileName)
g.es('wrote:    ',self_DOT_shortFileName)
# g.es('created:  ',self.targetFileName)
g.es('created:  ',self_DOT_targetFileName)
# -- node < < report if the files differ only in line endings > >
# g.es("correcting line endings in:",self.targetFileName,color="blue")
g.es("correcting line endings in:",self_DOT_targetFileName,color="blue")
# -- node warnAboutOrpanAndIgnoredNodes
# g.es("parent node:",p.parent().headString(),color="blue")
g.es("parent node:",p_DOT_parent_PARENS__DOT_headString_PARENS_,color="blue")
# -- node writeException
# g.es("exception writing:",self.targetFileName,color="red")
g.es("exception writing:",self_DOT_targetFileName,color="red")
# g.es("exception deleting:",self.outputFileName,color="red")
g.es("exception deleting:",self_DOT_outputFileName,color="red")
# -- node < < Test for @header and @noheader > >
g.es("conflicting @header and @noheader directives")
# -- node < < Set comment strings from delims > >
g.es("unknown language: using Python comment delimiters")
# g.es("c.target_language:",c.target_language)
g.es("c_DOT_target_language:",c_DOT_target_language)
g.es('','delim1,delim2,delim3:','',delim1,'',delim2,'',delim3)
# ---- @thin leoBridge.py
g.es_print('','-------------------- @thin leoBridge.py',color='red')
# -- node < < try to get leoID from sys.leoID> >
# g.es("leoID=",g.app.leoID,spaces=False,color='red')
g.es("leoID=",g_DOT_app_DOT_leoID,spaces=False,color='red')
# -- node < < try to get leoID from "leoID.txt" > >
# g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('leoID=',g_DOT_app_DOT_leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
g.es('unexpected exception in app.setLeoID',color='red')
# -- node < < try to get leoID from os.getenv('USER') > >
# g.es_print("using os.getenv('USER'):",repr(theId),color='red')
g.es_print("using os.getenv('USER'):",repr_LP_theId_RP_,color='red')
# -- node reportDirectories
g.es('',kind,'directory','',':',theDir,color='blue')
# -- node createFrame (leoBridge)
g.es('file not found', fileName,'creating new window')
# ---- @thin leoChapters.py
g.es_print('','-------------------- @thin leoChapters.py',color='red')
# -- node cc.createChapterByName
g.es('created chapter',name,color='blue')
# -- node cc.error
g.es_print(s,color='red')
# ---- @thin leoColor.py
g.es_print('','-------------------- @thin leoColor.py',color='red')
# ---- @thin leoCommands.py
g.es_print('','-------------------- @thin leoCommands.py',color='red')
# -- node doCommand
# g.es(c.disableCommandsMessage,color='blue')
g.es(c_DOT_disableCommandsMessage,color='blue')
g.es('ignoring command: already executing a command.',color='red')
g.es("exception executing command")
# -- node c.signOnWithVersion
g.es("Leo Log Window...",color=color)
g.es(signon)
# g.es('',"python %s.%s.%s, %s\n%s" % (n1,n2,n3,g.app.gui.getFullVersion(c),version))
g.es('',"python %s.%s.%s, %s\n%s" % (n1,n2,n3,g_DOT_app_DOT_gui_DOT_getFullVersion_LP_c_RP_,version))
# -- node openWith and allies
g.es("unexpected exception in c.openWith")
# -- node < < create or recreate temp file as needed > >
# g.es("reopening:",g.shortFileName(path),color="blue")
g.es("reopening:",g_DOT_shortFileName_LP_path_RP_,color="blue")
# -- node < < execute a command to open path in external editor > >
g.es("exception executing:",command)
# -- node createOpenWithTempFile
# g.es("recreating:  ",g.shortFileName(path),color="red")
g.es("recreating:  ",g_DOT_shortFileName_LP_path_RP_,color="red")
# g.es("creating:  ",g.shortFileName(path),color="blue")
g.es("creating:  ",g_DOT_shortFileName_LP_path_RP_,color="blue")
# g.es("time: " + str(time))
g.es("time: " + str_LP_time_RP_)
g.es("exception creating temp file",color="red")
# -- node save (commands)
g.es("save commands disabled",color="purple")
# -- node saveAs
g.es("save commands disabled",color="purple")
# -- node saveTo
g.es("save commands disabled",color="purple")
# -- node readOutlineOnly
g.es("can not open:",fileName)
# -- node readFileIntoFile
g.es("can not open:",fileName)
# -- node writeFileFromNode
g.es_print('wrote:',fileName,color='blue')
g.es('can not write %s',fileName,color='red')
# -- node c.executeScript & helpers
g.es("end of script",color="purple",tabName=tabName)
g.es("no script selected",color="blue",tabName=tabName)
# -- node goToLineNumber & allies
# g.es("error handling:",root.headString())
g.es("error handling:",root_DOT_headString_PARENS_)
# -- node < < set root > >
g.es("no ancestor @file node: using script line numbers", color="blue")
# -- node < < read the file into lines > >
g.es("not found:",fileName)
# -- node < < 4.2: get node from gnx > >
g.es("not found:",vnodeName,color="red")
# -- node < < 4.x: scan for the node using tnodeList and n > >
# g.es_print("no child index for",root.headString(),color="red")
g.es_print("no child index for",root_DOT_headString_PARENS_,color="red")
# -- node < < set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false > >
g.es_print(s, color="red")
g.es_print(s, color="red")
g.es_print(s, color = "red")
# -- node < < set p to the first node whose headline matches vnodeName > >
g.es_print(s, color="red")
# -- node < < 3.x: scan for the node with the given childIndex > >
g.es("not found:",vnodeName, color="red")
# -- node < < put the cursor on line n2 of the body text > >
# g.es('only',len(lines),'lines',color="blue")
g.es('only',len_LP_lines_RP_,'lines',color="blue")
# -- node convertLineToVnodeNameIndexLine
g.es("bad @+leo sentinel")
# -- node < < handle delim while scanning backward > >
# g.es("line",str(n),"is a sentinel line")
g.es("line",str_LP_n_RP_,"is a sentinel line")
# -- node < < set vnodeName and (childIndex or gnx) from s > >
g.es("bad @+node sentinel")
# -- node convertAllBlanks
g.es("blanks converted to tabs in",count,"nodes")
# -- node convertAllTabs
g.es("tabs converted to blanks in",count,"nodes")
# -- node extract (test)
g.es("nothing follows section name",color="blue")
# -- node extractSection
g.es("nothing follows section name",color="blue")
# -- node < < Set headline for extractSection > >
g.es("selected text should start with a section name",color="blue")
# -- node extractSectionNames
g.es("selected text should contain one or more section names",color="blue")
# -- node < < trace head_lines, ins, tail_lines > >
g.es_print("head_lines: ",head_lines)
g.es_print("ins: ",ins)
g.es_print("tail_lines: ",tail_lines)
# -- node c.findMatchingBracket, helper and test
# g.es("unmatched",repr(ch))
g.es("unmatched",repr_LP_ch_RP_)
# -- node getTime
g.es("time.strftime not available on this platform",color="blue")
# -- node addComments (test)
g.es('no text selected',color='blue')
# -- node deleteComments (test)
g.es('no text selected',color='blue')
g.es('',"'%s'" % (d2),"not found",color='blue')
g.es('',"'%s'" % (d3),"not found",color='blue')
# -- node showFindPanel
# g.es('the',g.app.gui.guiName(),
#             'gui does not support a stand-alone find dialog',color='blue')
g.es('the',g_DOT_app_DOT_gui_DOT_guiName_PARENS_,
            'gui does not support a stand-alone find dialog',color='blue')
# -- node notValidInBatchMode
g.es('the',commandName,"command is not valid in batch mode")
# -- node c.checkOutline
g.es("all tests enabled: this may take awhile",color="blue")
# -- node < < remove unused tnodeList > >
g.es_print(s,color="blue")
# -- node < < do full tests > >
g.es('','.',newline=False)
# -- node < < give test failed message > >
g.es_print(s,color="red")
# -- node < <print summary message > >
g.es_print('',count,'nodes checked',errors,'errors',color=color)
# -- node checkAllPythonCode
g.es("check complete",color="blue")
# -- node < < print dots > >
g.es('','.',newline=False)
# -- node checkPythonCode
g.es("checking Python code   ")
g.es("surprise in checkPythonNode")
g.es("check complete",color="blue")
# -- node < < print dots > >
g.es('','.',newline=False)
# -- node checkPythonNode
g.es_print(s,color="blue")
# -- node tabNannyNode
g.es("ParserError in",headline,color="blue")
# g.es('',str(msg))
g.es('',str_LP_msg_RP_)
g.es("TokenError in",headline,color="blue")
# g.es('',str(msg))
g.es('',str_LP_msg_RP_)
g.es("indentation error in",headline,"line",badline,color="blue")
g.es(message)
g.es("offending line:\n",line2)
# -- node prettyPrintNode
g.es("error pretty-printing",h,"not changed.",color="blue")
# -- node markChangedHeadlines
g.es("done",color="blue")
# -- node markChangedRoots
g.es("done",color="blue")
# -- node markClones
g.es('the current node is not a clone',color='blue')
# -- node cantMoveMessage
g.es("can't move node out of",kind,color="blue")
# -- node c.toggleSparseMove
g.es(tag,'=',sparseMove,color='blue')
# -- node goToNextClone
# g.es('not a clone:',p.headString(),color='blue')
g.es('not a clone:',p_DOT_headString_PARENS_,color='blue')
g.es("done",color="blue")
# -- node findNextClone
g.es('no more clones',color='blue')
# -- node goToNextDirtyHeadline
g.es("done",color="blue")
# -- node goToNextMarkedHeadline
g.es("done",color="blue")
# -- node openCompareWindow
# g.es('the',g.app.gui.guiName(),
#             'gui does not support the compare window',color='blue')
g.es('the',g_DOT_app_DOT_gui_DOT_guiName_PARENS_,
            'gui does not support the compare window',color='blue')
# -- node openLeoSettings and openMyLeoSettings
g.es('',name,"not found in",configDir)
g.es('',name,"not found in",configDir,"or",homeDir)
# -- node openLeoScripts
g.es('not found:',fileName)
# -- node leoDocumentation
g.es("not found:",name)
# -- node leoHome
g.es("not found:",url)
# -- node leoPlugins
g.es("not found:",name)
# -- node leoTutorial (version number)
g.es("not found:",url)
# -- node leoUsersGuide
g.es("not found:",url)
# -- node initEncoding
g.es("bad", "%s: %s" % (encodingName,encoding))
# ---- @thin leoConfig.py
g.es_print('','-------------------- @thin leoConfig.py',color='red')
# -- node error
g.es(s,color="blue")
# -- node doIfGui
g.es_print(s,color='blue')
# -- node doMenus & helper
# g.es_print('creating menu from',c.shortFileName(),color='blue')
g.es_print('creating menu from',c_DOT_shortFileName_PARENS_,color='blue')
# -- node set (parseBaseClass)
g.es("over-riding setting:",name,"from",path)
# -- node traverse (parserBaseClass)
# g.es_print('skipping settings in',p.headString(),color='blue')
g.es_print('skipping settings in',p_DOT_headString_PARENS_,color='blue')
# -- node initEncoding
g.es("g.app.config: bad encoding:","%s: %s" % (ivar,encoding))
# -- node getValFromDict
# g.es_print('warning: ignoring',bunch.kind,'',setting,'is not',requestedType,color='red')
g.es_print('warning: ignoring',bunch_DOT_kind,'',setting,'is not',requestedType,color='red')
g.es_print('there may be conflicting settings!',color='red')
# -- node createRecentFiles
g.es_print('created',fileName,color='red')
g.es_print('can not create',fileName,color='red')
# -- node writeRecentFilesFileHelper
g.es('unexpected exception writing',fileName,color='red')
# -- node g.app.config.printSettings & helper
g.es('','%s %s = %s' % (letter,key,val))
# ---- @thin leoEditCommands.py
g.es_print('','-------------------- @thin leoEditCommands.py',color='red')
# -- node dynamicCompletion
g.es('command not ready yet',color='blue')
# -- node dynamicExpansion
g.es('command not ready yet',color='blue')
# -- node listAbbrevs
g.es('','%s=%s' % (z,s))
# -- node readAbbreviations
g.es('can not open',fileName)
# -- node writeAbbreviations
g.es('can not create',fileName)
# -- node listBuffers & listBuffersAlphabetically
g.es('buffers...')
g.es('',name)
g.es('buffers...')
g.es('',name)
# -- node debug & helper
g.es("info string")
# -- node findDebugger
g.es('debugger does not exist:',debugger,color='blue')
g.es('no debugger found.')
# -- node enable/disableGcTrace
g.es('enabled verbose gc stats',color='blue')
g.es('enabled brief gc stats',color='blue')
# -- node printFocus
# g.es_print('      hasFocusWidget:',c.widget_name(c.hasFocusWidget))
g.es_print('      hasFocusWidget:',c_DOT_widget_name_LP_c_DOT_hasFocusWidget_RP_)
# g.es_print('requestedFocusWidget:',c.widget_name(c.requestedFocusWidget))
g.es_print('requestedFocusWidget:',c_DOT_widget_name_LP_c_DOT_requestedFocusWidget_RP_)
# g.es_print('           get_focus:',c.widget_name(c.get_focus()))
g.es_print('           get_focus:',c_DOT_widget_name_LP_c_DOT_get_focus_PARENS__RP_)
# -- node appendImageDictToList
g.es('can not load image:',path)
# -- node getImage
g.es('can not import Image module from PIL',color='blue')
g.es('can not import ImageTk module',color='blue')
# -- node initBracketMatcher
g.es_print('bad open/close_flash_brackets setting: using defaults')
# -- node viewLossage
g.es('lossage...')
# g.es('',stroke or d.get(ch) or ch or 'None')
g.es('',stroke or d_DOT_get_LP_ch_RP_ or ch or 'None')
# -- node clear/set/ToggleExtendMode
# g.es('extend mode',g.choose(val,'on','off'),color='red')
g.es('extend mode',g_DOT_choose_LP_val_COMMA__SQ_on_SQ__COMMA__SQ_off_SQ__RP_,color='red')
# -- node swapWords
g.es('swap-words command not ready yet',color='blue')
# -- node getReadableTextFile
g.es('can not open',fileName)
# -- node saveFile
g.es('can not create',fileName)
# -- node helpForMinibuffer
g.es_print('',s)
# -- node helpForCommand
g.es('','%s:%s\n%s\n' % (commandName,bindings,s),color='blue')
# -- node aproposAutocompletion
g.es_print('',s)
# -- node aproposBindings
g.es_print('',s)
# -- node aproposDebuggingCommands
g.es_print('',s)
# -- node aproposFindCommands
g.es_print('',s)
# -- node loadFile & helpers
g.es('can not open',fileName)
# -- node saveMacros & helper
g.es('can not create',fileName)
# -- node findNextMatch (query-replace)
g.es('command not ready yet',color='blue')
# -- node Find options wrappers
# g.es('collapse_nodes_during_finds',c.config.getBool('collapse_nodes_during_finds'))
g.es('collapse_nodes_during_finds',c_DOT_config_DOT_getBool_LP__SQ_collapse_nodes_during_finds_SQ__RP_)
# -- node scolorizer LATER
g.es('command not ready yet',color='blue')
# -- node init_aspell
g.es_print('can not open dictionary file:',dictionaryFileName, color='red')
g.es_print('can not open Aspell',color='red')
# -- node readDictionary
g.es("can not open local dictionary",fileName,"using a blank one instead")
# -- node add
g.es("adding ", color= "blue", newline= False)
# g.es('','%s' % self.currentWord)
g.es('','%s' % self_DOT_currentWord)
# g.es("can not add",self.currentWord,"to dictionary",color="red")
g.es("can not add",self_DOT_currentWord,"to dictionary",color="red")
# -- node find & helpers
g.es("no more misspellings")
# -- node hide
g.es(message,color='blue')
# -- node ignore
g.es("ignoring ",color= "blue", newline= False)
# g.es('','%s' % self.currentWord)
g.es('','%s' % self_DOT_currentWord)
# -- node report
g.es_print(message,color='blue')
# ---- @thin leoFileCommands.py
g.es_print('','-------------------- @thin leoFileCommands.py',color='red')
# -- node processingInstruction (stylesheet)
g.es('','%s: %s' % (target,data),color='blue')
# -- node startVnodes
# g.es("reading:",self.fileName)
g.es("reading:",self_DOT_fileName)
# -- node checkLeoFile (fileCommands)
g.es_print('check-leo-file passed',color='blue')
# g.es_print('check-leo-file failed:',str(message),color='red')
g.es_print('check-leo-file failed:',str_LP_message_RP_,color='red')
# -- node getLeoOutlineFromClipboard & helpers
g.es("invalid Paste As Clone",color="blue")
g.es("the clipboard is not valid ",color="blue")
# -- node < < warn on read-only files > >
g.es("read only:",fileName,color="red")
# -- node newTnode
# g.es("bad tnode index:",str(index),"using empty text.")
g.es("bad tnode index:",str_LP_index_RP_,"using empty text.")
# g.es("newTnode: unexpected index type:",type(index),index,color="red")
g.es("newTnode: unexpected index type:",type_LP_index_RP_,index,color="red")
# -- node getAllLeoElements
g.es("reading:",fileName)
# -- node getPrefs
# g.es("default tangle directory not found:",c.tangle_directory)
g.es("default tangle directory not found:",c_DOT_tangle_directory)
# -- node getTnode
# g.es("no tnode with index:",str(index),"the text will be discarded")
g.es("no tnode with index:",str_LP_index_RP_,"the text will be discarded")
# -- node < < handle unknown attributes > >
g.es_print("unknown attributes for tnode",color = "blue")
# g.es_print('',"%s = %s" % (key,attrDict.get(key)))
g.es_print('',"%s = %s" % (key,attrDict_DOT_get_LP_key_RP_))
# -- node < < handle unknown vnode attributes > >
# g.es_print("unknown attributes for",v.headString(),color="blue")
g.es_print("unknown attributes for",v_DOT_headString_PARENS_,color="blue")
# g.es_print('',"%s = %s" % (key,attrDict.get(key)))
g.es_print('',"%s = %s" % (key,attrDict_DOT_get_LP_key_RP_))
# -- node getExistingVnode
g.es("missing vnode:",headline,color="red")
g.es("probably an outline topology error.")
# -- node getXmlVersionTag
g.es("invalid encoding in .leo file:",encoding,color="red")
# -- node getSaxUa
g.es_print('unexpected exception converting hexlified string to string')
# -- node parse_leo_file
g.es_print('error parsing',inputFileName,color='red')
g.es_print('unexpected exception parsing',inputFileName,color='red')
# -- node save (fileCommands)
g.es("clearing undo")
# -- node putSavedMessage
# g.es("saved:","%s%s" % (zipMark,g.shortFileName(fileName)))
g.es("saved:","%s%s" % (zipMark,g_DOT_shortFileName_LP_fileName_RP_))
# -- node deleteFileWithMessage
g.es("read only",color="red")
g.es("exception deleting backup file:",fileName)
# -- node putUnknownAttributes & helper
g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
# -- node putUaHelper
g.es("ignoring non-string attribute",key,"in",torv,color="blue")
g.es('putUaHelper: unexpected pickling exception',color='red')
g.es("ignoring non-pickleable attribute",key,"in",torv,color="blue")
# -- node < < Append tnodeList and unKnownAttributes to attrs> >
# g.es("deleting tnode list for",p.headString(),color="blue")
g.es("deleting tnode list for",p_DOT_headString_PARENS_,color="blue")
# -- node < < issue informational messages > >
# g.es("writing erroneous:",p.headString(),color="blue")
g.es("writing erroneous:",p_DOT_headString_PARENS_,color="blue")
# -- node putDescendentUnknownAttributes
g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
g.es("ignoring bad unknownAttributes key",key,"in",p,color="blue")
g.es('putDescendentUnknownAttributes: unexpected pickling exception',color='red')
g.es("putDescendentUnknownAttributes can't happen 2",color='red')
# -- node write_Leo_file
# g.es_print('len',len(s),'putCount',self.putCount)
g.es_print('len',len_LP_s_RP_,'putCount',self_DOT_putCount)
g.es("exception writing:",fileName)
# -- node < < return if the .leo file is read-only > >
g.es("can not create: read only:",fileName,color="red")
# -- node < < create backup file > >
g.es("read only",color="red")
# -- node < < rename backupName to fileName > >
g.es("restoring",fileName,"from",backupName)
# -- node writeAtFileNodes
g.es("auto-saving outline",color="blue")
# -- node writeDirtyAtFileNodes
g.es("auto-saving outline",color="blue")
# -- node writeMissingAtFileNodes
g.es("auto-saving outline",color="blue")
# -- node writeOutlineOnly
g.es('done',color='blue')
# ---- @thin leoGlobals.py
g.es_print('','-------------------- @thin leoGlobals.py',color='red')
# -- node computeLoadDir
g.es("load dir:",loadDir,color="blue")
# -- node set_language
# g.es("ignoring:",g.get_line(s,i))
g.es("ignoring:",g_DOT_get_line_LP_s_COMMA_i_RP_)
# -- node < < set theDict for @ directives > >
g.es("warning: conflicting values for",word,color="blue")
# -- node < < set theDict["root"] for noweb * chunks > >
# g.es('',g.angleBrackets("*") + "= requires @root in the headline")
g.es('',g_DOT_angleBrackets_LP__DQ___DQ__RP_ + "= requires @root in the headline")
# -- node g.scanAtEncodingDirective
g.es("invalid @encoding:",encoding,color="red")
# -- node g.scanAtLineendingDirective
g.es("invalid @lineending directive:",e,color="red")
# -- node g.scanAtPagewidthDirective
g.es("ignoring",s,color="red")
# -- node < < scan another @root option > >
# g.es("modes conflict in:",g.get_line(s,i))
g.es("modes conflict in:",g_DOT_get_line_LP_s_COMMA_i_RP_)
# g.es("modes conflict in:",g.get_line(s,i))
g.es("modes conflict in:",g_DOT_get_line_LP_s_COMMA_i_RP_)
g.es("unknown option:",z_opt,"in",z_line)
# -- node g.scanAtTabwidthDirective
g.es("ignoring",s,color="red")
# -- node alert
g.es('',message)
# -- node es_dump
g.es_print('',title)
g.es_print('',aList)
# -- node es_error
g.es(s,color=color)
# -- node es_event_exception
g.es("exception handling ",eventName,"event")
g.es('',i)
# -- node es_exception_type
# g.es_print('','%s, %s' % (exctype.__name__, value),color=color)
g.es_print('','%s, %s' % (exctype_DOT___name__, value),color=color)
# -- node getLastTracebackFileAndLineNumber
# g.es_print('',repr(val))
g.es_print('',repr_LP_val_RP_)
# g.es_print('',repr(data))
g.es_print('',repr_LP_data_RP_)
# -- node Timing
# g.es('',"%s %6.3f" % (message,(time.clock()-start)))
###g.es('',"%s %6.3f" % (message,(time_DOT_clock_PARENS_-start)))
# -- node g.create_temp_file
###g.es('unexpected exception in g.create_temp_file',color='red')
# -- node g.is_sentinel
g.es("can't happen: is_sentinel",color="red")
# -- node g.makeAllNonExistentDirectories
g.es("created directory:",path)
g.es("exception creating directory:",path)
# -- node g.openLeoOrZipFile
g.es("can not open:",fileName,color="blue")
# -- node g.setGlobalOpenDir
# g.es('current directory:',g.app.globalOpenDir)
g.es('current directory:',g_DOT_app_DOT_globalOpenDir)
# -- node g.update_file_if_changed
g.es('','%12s: %s' % (kind,file_name))
g.es("rename failed: no file created!",color="red")
g.es('',file_name," may be read-only or in use")
# -- node g.utils_remove
g.es("exception removing:",fileName)
# -- node g.utils_rename
g.es('exception renaming',src,'to',dst,color='red')
# -- node g.utils_chmod
g.es("exception in os.chmod",fileName)
# -- node enable_gc_debug
g.es('can not import gc module',color='blue')
# -- node g.doHook
g.es_print(s,color="blue")
# -- node g.plugin_signon
# g.es('',"...%s.py v%s: %s" % (
#             m.__name__, m.__version__, g.plugin_date(m)))
g.es('',"...%s.py v%s: %s" % (
            m_DOT___name__, m_DOT___version__, g_DOT_plugin_date_LP_m_RP_))
# -- node mini test of es
g.es(s)
g.es_print(s)
# -- node es_print
# -- node @@test g.es_print
g.es_print('\ntest of es_print: Ă',color='red',newline=False)
g.es_print('after')
g.es_print('done')
# -- node es_trace
# -- node < < scan another @file option > >
g.es("using -asis option in:",h)
g.es("ignoring redundant -noref in:",h)
g.es("ignoring redundant -nosent in:",h)
g.es("using -thin option in:",h)
g.es("unknown option:",z_opt,"in",h)
# -- node scanError
g.es('',s)
# -- node skip_pp_if
g.es("#if and #else parts have different braces:",start_line)
g.es("no matching #endif:",start_line)
# -- node g.initScriptFind (set up dialog)
g.es("no Find script node",color="red")
# -- node g.handleScriptException
g.es("exception executing script",color='blue')
# -- node < < dump the lines near the error > >
g.es_print('',s)
g.es('',s,newline=False)
# -- node reportBadChars
g.es(s2,color='red')
g.es(s2,color='red')
# -- node g.executeScript
g.es("exception executing",name,color="red")
# -- node g.getScript
g.es_print("unexpected exception in g.getScript")
# -- node g.cantImport
g.es_print('',s,color="blue")
# -- node g.importFromPath
g.es_print("exception in g.importFromPath",color='blue')
g.es_print("unexpected exception in g.importFromPath(%s)" %
                    (name),color='blue')
# -- node g.init_zodb
g.es('g.init_zodb: can not import ZODB')
g.es('g.init_zodb: exception creating ZODB.DB instance')
# ---- @thin leoImport.py
g.es_print('','-------------------- @thin leoImport.py',color='red')
# -- node exportHeadlines
g.es("can not open",fileName,color="blue")
# -- node flattenOutline
g.es("can not open",fileName,color="blue")
# -- node outlineToWeb
g.es("can not open",fileName,color="blue")
# -- node < < Read file into s > >
g.es("can not open",fileName, color="blue")
# -- node < < set delims from the header line > >
g.es("invalid @+leo sentinel in",fileName)
# -- node < < Write s into newFileName > >
g.es("created:",newFileName)
g.es("exception creating:",newFileName)
# -- node < < open filename to f, or return > >
g.es("exception opening:",filename)
# -- node error
g.es('',s)
# -- node < < Read file into s > >
g.es("can not open", "%s%s" % (z,fileName),color='red')
# -- node readAtAutoNodes (importCommands) & helper
# g.es_print('ignoring',p.headString(),color='blue')
g.es_print('ignoring',p_DOT_headString_PARENS_,color='blue')
g.es(message,color='blue')
# -- node importFilesCommand
g.es("imported",fileName,color="blue")
# -- node importFlattenedOutline
g.es("not a valid MORE file",fileName)
# -- node < < Read the file into array > >
g.es("can not open",fileName, color="blue")
# -- node scanWebFile (handles limbo)
g.es("can not import",fileName, color="blue")
# -- node cstLookup
g.es('',"****** %s" % (target),"is also a prefix of",s)
g.es("replacing",target,"with",s)
# -- node scanPHPText
g.es_print('seems to be mixed HTML and PHP:',fileName)
# -- node compareHelper
# g.es_print('first mismatched line at line',str(i+1))
g.es_print('first mismatched line at line',str_LP_i_1_RP_)
g.es_print('original line: ',line1)
g.es_print('generated line:',line2)
g.es_print('missing lines')
# g.es_print('',repr(line))
g.es_print('',repr_LP_line_RP_)
# -- node checkLeadingWhitespace
# g.es_print('line:',repr(line),color='red')
g.es_print('line:',repr_LP_line_RP_,color='red')
# -- node reportMismatch
# -- node insertIgnoreDirective
g.es_print('inserting @ignore',color='blue')
# -- node error, oops, report and warning
g.es_print('',s,color='red')
g.es_print('error:',s,color='red')
g.es_print('warning:',s,color='red')
# ---- @thin leoKeys.py
g.es_print('','-------------------- @thin leoKeys.py',color='red')
# -- node showAutocompleter/CalltipsStatus
g.es(s,color='red')
g.es(s,color='red')
# -- node computeCompletionList
# g.es('',z,tabName=self.tabName)
g.es('',z,tabName=self_DOT_tabName)
# -- node info
g.es('no docstring for',word,color='blue')
g.es('',doc,tabName='Info')
g.es('no docstring for',word,color='blue')
# -- node scan
g.es("This is for testing if g.es blocks in a thread", color = 'pink' )
# -- node scanOutline
g.es_print('scanning for auto-completer...')
g.es('','.',newline=False)
g.es_print('\nauto-completer scan complete',color='blue')
# -- node createClassObjectFromString
g.es_print('unexpected exception in',computeProxyObject)
# -- node forgivingParser
g.es_print('syntax error in class node: can not continue')
# g.es_print('syntax error: deleting',p.headString())
g.es_print('syntax error: deleting',p_DOT_headString_PARENS_)
# -- node bindKey
g.es_print('exception binding',shortcut,'to',commandName)
# -- node < < give warning and return if we try to bind to Enter or Leave > >
g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
# -- node < < remove previous conflicting definitions from bunchList > >
# g.es_print('redefining',z,'in',b2.pane,'to',commandName,'in',pane,color='red')
g.es_print('redefining',z,'in',b2_DOT_pane,'to',commandName,'in',pane,color='red')
# -- node k.initAbbrev
g.es_print('bad abbrev:',key,'unknown command name:',commandName,color='blue')
# -- node k.makeMasterGuiBinding
# g.es_print('exception binding',bindStroke,'to',c.widget_name(w),color='blue')
g.es_print('exception binding',bindStroke,'to',c_DOT_widget_name_LP_w_RP_,color='blue')
# -- node callStateFunction
# g.es_print('no state function for',k.state.kind,color='red')
g.es_print('no state function for',k_DOT_state_DOT_kind,color='red')
# -- node k.show/hide/toggleMinibuffer
g.es('minibuffer hidden',color='red')
g.es('',commandName,'is bound to:',shortcut)
# -- node printBindings & helper
g.es('no bindings')
g.es('','%s %s' % (sep, prefix),tabName=tabName)
g.es('','%s %s' % (sep, 'Plain Keys',),tabName=tabName)
# -- node printBindingsHelper
# g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
# g.es('','%*s %*s %s' % (-n1,s1,-(min_LP_12_COMMA_n2_RP_),s2,s3),tabName='Bindings')
# -- node printCommands
# g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName=tabName)
# g.es('','%*s %*s %s' % (-n1,s1,-(min_LP_12_COMMA_n2_RP_),s2,s3),tabName=tabName)
# -- node repeatComplexCommand & helper
g.es('no previous command',color='blue')
# -- node k.registerCommand
g.es_print('redefining',commandName, color='red')
# g.es_print('','@command: %s = %s' % (
#                 commandName,k.prettyPrintKey(stroke)),color='blue')
g.es_print('','@command: %s = %s' % (
                commandName,k_DOT_prettyPrintKey_LP_stroke_RP_),color='blue')
g.es_print('','@command: %s' % (commandName),color='blue')
# -- node createModeBindings
g.es_print('no such command:',commandName,'Referenced from',modeName)
# -- node modeHelpHelper
g.es('','%s mode\n\n' % modeName,tabName=tabName)
###g.es('','%*s %s' % (n,s1,s2),tabName=tabName)
# -- node k.computeCompletionList
# g.es('','%*s %*s %s' % (-(min(20,n1)),s1,n2,s2,s3),tabName=tabName)
# g.es('','%*s %*s %s' % (-(min_LP_20_COMMA_n1_RP_),s1,n2,s2,s3),tabName=tabName)
# -- node k.showFileNameTabList
g.es('',s,tabName=tabName)
# ---- @thin leoNodes.py
g.es_print('','-------------------- @thin leoNodes.py',color='red')
# -- node v.bodyString
g.es_print('',s,color="red")
# -- node v.headString & v.cleanHeadString
g.es_print('',s,color="red")
# -- node scanGnx
# g.es("scanGnx: unexpected index type:",type(s),'',s,color="red")
g.es("scanGnx: unexpected index type:",type_LP_s_RP_,'',s,color="red")
# ---- @thin leoPlugins.py
g.es_print('','-------------------- @thin leoPlugins.py',color='red')
# -- node loadHandlers & helper
# -- node loadOnePlugin
g.es_print('plugin',moduleName,'already loaded',color="blue")
g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
g.es('exception loading plugin',color='red')
g.es_print('can not load enabled plugin:',moduleName,color="red")
g.es_print('loaded plugin:',moduleName,color="blue")
# -- node printHandlers
g.es_print('handlers for',moduleName,'...')
g.es_print('all plugin handlers...')
g.es_print('','%25s %s' % (tag,key))
# -- node printPlugins
g.es_print('enabled plugins...')
g.es_print('',key)
# -- node registerExclusiveHandler
g.es("*** Two exclusive handlers for","'%s'" % (tag))
# ---- @thin leoPymacs.py
g.es_print('','-------------------- @thin leoPymacs.py',color='red')
# -- node open
g.es_print('','leoPymacs.open:','no file name')
g.es_print('','leoPymacs.open:',c)
g.es_print('','leoPymacs.open:','can not open',fileName)
# ---- @thin leoTangle.py
g.es_print('','-------------------- @thin leoTangle.py',color='red')
# -- node < < call tangle_done.run() or untangle_done.run() > >
g.es("can not execute","tangle_done.run()")
g.es("can not execute","tangle_done.run()")
# -- node initTangleCommand
g.es("tangling...")
# -- node initUntangleCommand
g.es("untangling...")
# -- node tangle
g.es("looking for a parent to tangle...")
g.es("tangling parent")
g.es("tangle complete")
# -- node tangleAll
g.es("tangle complete")
# -- node tangleMarked
g.es("tangle complete")
# -- node untangle
g.es("untangle complete")
# -- node untangleAll
g.es("untangle complete")
# -- node untangleMarked
g.es("untangle complete")
# -- node untangleRoot (calls cleanup)
g.es('','@root ' + path)
# -- node < < return if @silent or unknown language > >
g.es("@comment disables untangle for",path, color="blue")
# g.es('','@%s' % (self.print_mode),"inhibits untangle for",path, color="blue")
g.es('','@%s' % (self_DOT_print_mode),"inhibits untangle for",path, color="blue")
# -- node < < Read the file into file_buf  > > in untangleRoot
g.es("error reading:",path)
# -- node tangle.put_all_roots
g.es("can not create temp file")
g.es("unchanged:",file_name)
# -- node st_check
# g.es('',' ' * 4,'warning:',lp,'',section.name,'',rp,'has been defined but not used.')
g.es('',' ' * 4,'warning:',lp,'',section_DOT_name,'',rp,'has been defined but not used.')
# -- node < <check for duplicate code definitions > >
g.es('warning: possible duplicate definition of:',s)
# -- node ust_warn_about_orphans
# g.es("warning:",'%s%s%s' % (lp,part.name,rp),"is not in the outline")
g.es("warning:",'%s%s%s' % (lp,part_DOT_name,rp),"is not in the outline")
# -- node update_def (pass 2)
# g.es("***Updating:",p.headString())
g.es("***Updating:",p_DOT_headString_PARENS_)
# -- node < < Test for @comment and @language > >
g.es("ignoring: @comment",z)
# -- node < < handle absolute @path > >
g.es("relative_path_base_directory:",base)
g.es("relative path in @path directive:",relative_path)
# -- node < < Test for @header and @noheader > >
g.es("conflicting @header and @noheader directives")
# -- node < < handle absolute path > >
g.es("relative_path_base_directory:",base)
g.es('',kind,"directory:",dir2)
# ---- @thin leoTest.py
g.es_print('','-------------------- @thin leoTest.py',color='red')
# -- node runTimerOnNode
# g.es_print("count:",count,"time/count:",ratio,'',p.headString())
g.es_print("count:",count,"time/count:",ratio,'',p_DOT_headString_PARENS_)
# -- node runTests
g.es('running',kind,'unit tests',color='blue')
g.es_print('no @test or @suite nodes in selected outline')
# -- node checkFileSyntax
g.es("syntax error in:",fileName,color="blue")
# -- node checkFileTabs
g.es_print("Token error in",fileName,color="blue")
g.es_print('',msg)
g.es_print("Indentation error in",fileName,"line",badline,color="blue")
g.es_print('',message)
g.es_print("offending line...")
g.es_print('',line)
# -- node importAllModulesInPath
g.es("path does not exist:",path)
# ---- @thin leoUndo.py
g.es_print('','-------------------- @thin leoUndo.py',color='red')
# -- node < < set newBead if we can't share the previous bead > >
g.es('exception in','setUndoRedoTypingParams',color='blue')
# -- node redoGroup
g.es("redo",count,"instances")
# -- node undoGroup
g.es("undo",count,"instances")
g.app.translateToUpperCase=False
#@nonl
#@-node:ekr.20080220082727:@scan_g.es_results
#@+node:ekr.20031218072017.1978:app.setLeoID
def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = not g.app.unitTesting
    << return if we can set leoID from sys.leoID >>
    << return if we can set leoID from "leoID.txt" >>
    << return if we can set leoID from os.getenv('USER') >>
    << put up a dialog requiring a valid id >>
    << attempt to create leoID.txt >>
#@+node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose and not g.app.unitTesting:
        g.es_print("leoID=",g.app.leoID,spaces=False,color='red')
    # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
    g.app.leoID = g.app.leoID.replace('.','-')
    return
else:
    g.app.leoID = None
#@-node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
#@+node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
                g.app.leoID = g.app.leoID.replace('.','-')
                if verbose and not g.app.unitTesting:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                return
            elif verbose and not g.app.unitTesting:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es_print('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
#@+node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
try:
    theId = os.getenv('USER')
    if theId:
        if verbose and not g.app.unitTesting:
            g.es("using os.getenv('USER'):",repr(theId),color='red')
        g.app.leoID = theId
        # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
        g.app.leoID = g.app.leoID.replace('.','-')
        return

except Exception:
    pass
#@-node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
#@+node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
# New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()

# Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
g.app.leoID = g.app.leoID.replace('.','-')

# g.trace(g.app.leoID)
g.es('leoID=',repr(g.app.leoID),spaces=False,color="blue")
#@-node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                g.es_print('',tag,'created in',theDir,color='red')
                return
        except IOError:
            pass

        g.es('can not create',tag,'in',theDir,color='red')
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@-node:ekr.20031218072017.1978:app.setLeoID
#@+node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
                g.app.leoID = g.app.leoID.replace('.','-')
                if verbose and not g.app.unitTesting:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                return
            elif verbose and not g.app.unitTesting:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es_print('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                g.es_print('',tag,'created in',theDir,color='red')
                return
        except IOError:
            pass

        g.es('can not create',tag,'in',theDir,color='red')
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@+node:ekr.20070426092031:Consider another way to compute home directory
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4281562
By: ktenney

I don't know if this is a resolved issue, here's another approach,
looks like a good one.

email link
http://murl.se/24201

python.org os.path doc
http://murl.se/24202

>>> import os
>>> lin_key, win_key = "home", "Documents"
>>> homedir = os.path.expanduser('~')
>>> if os.name == 'nt': os_key = win_key
>>> if os.name == 'posix': os_key = lin_key
>>> print homedir.find(os_key) > -1
True

#@-node:ekr.20070426092031:Consider another way to compute home directory
#@+node:ekr.20070227094232:getLeoID
def getLeoID (self):

    import os
    import sys

    g = self.g ; tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = False and not g.app.unitTesting
    << try to get leoID from sys.leoID >>
    if not g.app.leoID:
        << try to get leoID from "leoID.txt" >>
    if not g.app.leoID:
        << try to get leoID from os.getenv('USER') >>
    return g.app.leoID
#@+node:ekr.20070227094232.1:<< try to get leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose: g.es("leoID=",g.app.leoID,spaces=False,color='red')
#@nonl
#@-node:ekr.20070227094232.1:<< try to get leoID from sys.leoID>>
#@+node:ekr.20070227094232.2:<< try to get leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                if verbose:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                break
            elif verbose:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20070227094232.2:<< try to get leoID from "leoID.txt" >>
#@+node:ekr.20070227094232.3:<< try to get leoID from os.getenv('USER') >>
try:
    theId = os.getenv('USER')
    if theId:
        if verbose: g.es_print("using os.getenv('USER'):",repr(theId),color='red')
        g.app.leoID = theId

except Exception:
    pass
#@-node:ekr.20070227094232.3:<< try to get leoID from os.getenv('USER') >>
#@-node:ekr.20070227094232:getLeoID
#@+node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
def openLeoSettings (self,event=None):
    '''Open leoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('leoSettings.leo')

def openMyLeoSettings (self,event=None):
    '''Open myLeoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('myLeoSettings.leo')

def openSettingsHelper(self,name):
    c = self
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)
    ok = g.os_path_exists(fileName)
    if ok:
        ok, frame = g.openWithFileName(fileName,c)
        if ok: return

    # Look in homeDir second.
    if configDir == loadDir:
        g.es('',name,"not found in",configDir)
    else:
        fileName = g.os_path_join(homeDir,name)
        ok = g.os_path_exists(fileName)
        if ok:
            ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es('',name,"not found in",configDir,"or",homeDir)
#@-node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():

    """Returns the user's home directory."""

    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
#@-node:ekr.20041117151301:computeHomeDir
#@-node:ekr.20080407090400.4:Found: homeDir
#@-node:ekr.20080407090400.3:Added install nodes re Leo's home directory
#@+node:ekr.20080318081653.1:Added preliminary support for @bool fixedWindow option
@nocolor

We should avoid conflicts here in the first place. We really need that
'toggle-fixed' thing (that would prevent writing window positions and node
expansion statuses to .leo file) I suggested a while back, to make collaboration
with .leo files possible...

@color
#@nonl
#@+node:ekr.20080412053100.3:Documentation
@nocolor

Leo suppresses marks, expansion state, orphan bits and current
position bits when writing fixed .leo files.  As a result, all nodes
will be collapsed and the root node will always be selected when Leo
opens a fixed .leo file.

When writing fixed .leo files, Leo writes fixed, immutable, reasonable
defaults for window size, position and body-outline ratio.
Specifically, width,height,left,top = 700,500,50,50 and the ratio is
0.5. These values are written so older versions of Leo can read fixed
files.

You make a file fixed by putting '@bool fixedWindow = True' in the
@settings tree of a particular .leo file.  The file will be fixed
after you save the file, reload the file, and save the file again.
Yes, this is clumsy, but it only has to be done once.  A toggle-fixed
file command doesn't seem that useful: using an @bool node is simple
and clear.

You can optionally specify the size and position on the screen of
fixed .leo files by putting an '@data fixedWindowPosition' node in the
@settings tree of myLeoSettings.leo or leoSettings.leo.  You should
**not** put such a node in the fixed .leo file itself--everyone who
opens the file would get that fixed position.

The body of the '@data fixedWindowPosition' node should contain
something like this:

# Must be four entries: width,height,left,top.
# Put this in myLeoSettings.leo, **not** in individual .leo files.

1200
800
50
50

Leo uses reasonable defaults for fixed .leo files if this node does
not exist, or contains something other than 4 numbers, one per line. 
#@nonl
#@-node:ekr.20080412053100.3:Documentation
#@+node:ekr.20080412053100.2:changed
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName,relativeFileName=None):

    c = self

    # g.trace('Commands')
    self.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.

    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.chapterController = None
    self.frame = frame
    t = leoNodes.tnode()
    self.hiddenRootNode = leoNodes.vnode(context=c,t=t)
    self.hiddenRootNode.setHeadString('<hidden root vnode>')
    self.isZipped = False # May be set to True by g.openWithFileName.
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)
    self.mRelativeFileName = relativeFileName

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()
    self.nodeHistory = nodeHistory(c)

    self.contractVisitedNodes = c.config.getBool('contractVisitedNodes')
    self.useTextMinibuffer = c.config.getBool('useTextMinibuffer')
    self.showMinibuffer = c.config.getBool('useMinibuffer')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')
    self.fixed = c.config.getBool('fixedWindow',False)
        # New in Leo 4.5: True: Don't write window position, expansion states, marks, etc.
    self.fixedWindowPosition = c.config.getData('fixedWindowPosition')
    if self.fixedWindowPosition:
        try:
            w,h,l,t = self.fixedWindowPosition
            self.fixedWindowPosition = int(w),int(h),int(l),int(t)
        except Exception:
            g.es_print('bad @data fixedWindowPosition',repr(self.fixedWindowPosition),color='red')
    else:
        self.windowPosition = 500,700,50,50 # width,height,left,top.

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20031218072017.3037:putGlobals
# Changed for Leo 4.0.

def putGlobals (self):

    c = self.c
    self.put("<globals")
    << put the body/outline ratio >>
    self.put(">") ; self.put_nl()
    << put the position of this frame >>
    << put the position of the log window >>
    self.put("</globals>") ; self.put_nl()
#@+node:ekr.20031218072017.3038:<< put the body/outline ratio >>
# Puts an innumerate number of digits

self.put(" body_outline_ratio=")

# New in Leo 4.5: support fixed .leo files.
self.put_in_dquotes(
    str(g.choose(c.fixed,0.5,c.frame.ratio)))
#@-node:ekr.20031218072017.3038:<< put the body/outline ratio >>
#@+node:ekr.20031218072017.3039:<< put the position of this frame >>
# New in Leo 4.5: support fixed .leo files.

if c.fixed:
    width,height,left,top = 700,500,50,50
        # Put fixed, immutable, reasonable defaults.
        # Leo 4.5 and later will ignore these when reading.
        # These should be reasonable defaults so that the
        # file will be opened properly by older versions
        # of Leo that do not support fixed .leo files.
else:
    width,height,left,top = c.frame.get_window_info()

# g.trace(width,height,left,top)

self.put_tab()
self.put("<global_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@-node:ekr.20031218072017.3039:<< put the position of this frame >>
#@+node:ekr.20031218072017.3040:<< put the position of the log window >>
top = left = height = width = 0 # no longer used

self.put_tab()
self.put("<global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@-node:ekr.20031218072017.3040:<< put the position of the log window >>
#@-node:ekr.20031218072017.3037:putGlobals
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    # Not writing @auto nodes is way too dangerous.
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    # forceWrite = isIgnore or not isThin or (isThin and isOrphan)
    if isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto: forceWrite = False     # Never write non-ignored @auto trees.
    elif isThin: forceWrite = isOrphan  # Only write orphan @thin trees.
    else:        forceWrite = True      # Write all other @file trees.

    << Set gnx = tnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append tnodeList and unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s><vh>%s</vh>' % (gnx,attrs,xml.sax.saxutils.escape(p.v.headString()or''))
    # The string catentation is faster than repeated calls to fc.put.
    if not self.usingClipboard:
        << issue informational messages >>
    # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren() and (forceWrite or self.usingClipboard):
        fc.put('%s\n' % v_head)
        # This optimization eliminates all "recursive" copies.
        p.moveToFirstChild()
        while 1:
            fc.putVnode(p,isIgnore)
            if p.hasNext(): p.moveToNext()
            else:           break
        p.moveToParent() # Restore p in the caller.
        fc.put('</v>\n')
    else:
        fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
# New in Leo 4.4.8.  Assign v.t.fileIndex here as needed.
if not v.t.fileIndex:
    v.t.fileIndex = g.app.nodeIndices.getNewIndex()

gnx = g.app.nodeIndices.toString(v.t.fileIndex)

if forceWrite or self.usingClipboard:
    v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
#@-node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
#@+node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren(): attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"

    # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    # if not self.use_sax:
        # if p.equal(self.topPosition):     attr += "T" # was a bottleneck
        # if p.equal(self.currentPosition): attr += "V" # was a bottleneck

    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    if not c.fixed:
        d['str_leo_pos'] = ','.join(aList)
    # g.trace(aList,d)
    v.unknownAttributes = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@-node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
#@+node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for",p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        attrs.append(fc.putTnodeList(v)) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    attrs.append(self.putUnknownAttributes(v))

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    attrs.append(self.putDescendentUnknownAttributes(p))
    attrs.append(self.putDescendentAttributes(p))
#@nonl
#@-node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
#@+node:ekr.20040702085529:<< issue informational messages >>
if isOrphan and isThin:
    g.es("writing erroneous:",p.headString(),color="blue")
    p.clearOrphan()
#@-node:ekr.20040702085529:<< issue informational messages >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20060919110638.36:getPositionAttributes
def getPositionAttributes (self,attrs):

    c = self.c

    if c.fixed and c.fixedWindowPosition:
        width,height,left,top = c.fixedWindowPosition
        d = {'top':top,'left':left,'width':width,'height':height}
    else:
        d = {}
        for bunch in self.attrsToList(attrs):
            name = bunch.name ; val = bunch.val
            if name in ('top','left','width','height'):
                try:
                    d[name] = int(val)
                except ValueError:
                    d[name] = 100 # A reasonable default.
            else:
                g.trace(name,len(val))

    return d
#@-node:ekr.20060919110638.36:getPositionAttributes
#@+node:ekr.20040629121554.3:c.signOnWithVersion
def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info

    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass

    else: version = sys.platform

    if not g.unitTesting:
        g.es("Leo Log Window...",color=color)
        g.es(signon)
        g.es('',"python %s.%s.%s, %s\n%s" % (n1,n2,n3,g.app.gui.getFullVersion(c),version))
        g.enl()
        if c.fixed:
            g.es_print('This is a fixed window',color='red')
#@-node:ekr.20040629121554.3:c.signOnWithVersion
#@+node:ekr.20080412172151.2:updateFixedStatus
def updateFixedStatus (self):

    c = self.c
    p = g.app.config.findSettingsPosition(c,'@bool fixedWindow')
    if p:
        import leoConfig
        parser = leoConfig.settingsTreeParser(c)
        kind,name,val = parser.parseHeadline(p.headString())
        if val and val.lower() in ('true','1'):
            val = True
        else:
            val = False
        c.fixed = val

    # g.trace('c.fixed',c.fixed)
#@-node:ekr.20080412172151.2:updateFixedStatus
#@-node:ekr.20080412053100.2:changed
#@-node:ekr.20080318081653.1:Added preliminary support for @bool fixedWindow option
#@-node:ekr.20080408060320.783:Features
#@-node:ekr.20080408060320.4:4.5 a1
#@+node:ekr.20080416161308.1:This is the graph world
#@+node:ekr.20080417064246.1:What I did
@nocolor

- Rewrote some code in createThinChild4 to v.t.children

- Create c.hiddenRootNode in Commands ctor.

- readSaxFile now sets c.hiddenRootNode.children:
    - createSaxVnodes now return the entire children list.

- Added context keyword arg to vnode ctor.
    - Done in core.
    - Done in plugins.

- Changed t.headString to t._headString
    - Done in core.
    - Done in plugins.

- Change t.bodyString to t._bodyString
    - Done in core.
    - Done in plugins.

- Removed all but first arg from position ctor.
    - Done in core.
    - Done in plugins.
#@nonl
#@-node:ekr.20080417064246.1:What I did
#@+node:ekr.20080420163857.2:Projects...
#@+node:ekr.20080416161551.223:Used v._parent
#@+node:ekr.20060919110638.7:createSaxVnode
def createSaxVnode (self,sax_node,parent_v,t=None):

    c = self.c
    trace = False and self.usingClipboard
    h = sax_node.headString
    b = sax_node.bodyString

    if t:
        if trace: g.trace('clone',t,h)
    else:
        t = leoNodes.tnode(bodyString=b,headString=h)
        if trace: g.trace('     ',t,h)

        if sax_node.tnx:
            t.fileIndex = g.app.nodeIndices.scanGnx(sax_node.tnx,0)

    v = leoNodes.vnode(context=c,t=t)
    v.t.vnodeList.append(v)

    index = self.canonicalTnodeIndex(sax_node.tnx)

    self.tnodesDict [index] = t

    # g.trace('tnx','%-22s' % (index),'v',id(v),'v.t',id(v.t),'body','%-4d' % (len(b)),h)

    self.handleVnodeSaxAttributes(sax_node,v)
    self.handleTnodeSaxAttributes(sax_node,t)

    return v
#@+node:ekr.20060919110638.8:handleTnodeSaxAttributes
def handleTnodeSaxAttributes (self,sax_node,t):

    d = sax_node.tnodeAttributes

    aDict = {}
    for key in d.keys():
        val = d.get(key)
        val2 = self.getSaxUa(key,val)
        aDict[key] = val2

    if aDict:
        # g.trace('uA',aDict)
        t.unknownAttributes = aDict
#@nonl
#@-node:ekr.20060919110638.8:handleTnodeSaxAttributes
#@+node:ekr.20061004053644:handleVnodeSaxAttributes
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded and descendentTnodeUnknownAttributes.

def handleVnodeSaxAttributes (self,sax_node,v):

    d = sax_node.attributes
    s = d.get('a')
    if s:
        # g.trace('%s a=%s %s' % (id(sax_node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        # if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.trace('setting currentVnode',v,color='red')
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnode list will be resolved later.
        # g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes') # Correct: only tnode have descendent uA's.
    if s: 
        aDict = self.getDescendentUnknownAttributes(s)
        if aDict:
            # g.trace('descendentUaDictList',aDict)
            self.descendentUnknownAttributesDictList.append(aDict)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d.keys():
        if key in self.nativeVnodeAttributes:
            if 0: g.trace('****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # g.trace('uA',aDict)
        v.unknownAttributes = aDict
#@nonl
#@-node:ekr.20061004053644:handleVnodeSaxAttributes
#@-node:ekr.20060919110638.7:createSaxVnode
#@+node:ekr.20060919110638.9:_linkParentAndChildren
def _linkParentAndChildren (self, parent_v, children):

    # if children: g.trace(parent_v,len(children))

    # Add parent_v to it's tnode's vnodeList.
    if parent_v not in parent_v.t.vnodeList:
        parent_v.t.vnodeList.append(parent_v)

    # Set parent_v's children.
    parent_v.t.children = children

    # Make parent_v a parent of each child.
    for v in children:
        if parent_v not in v.t.parents:
            v.t.parents.append(parent_v)
#@-node:ekr.20060919110638.9:_linkParentAndChildren
#@+node:EKR.20040530121329:u.restoreTree & helpers
def restoreTree (self,treeInfo):

    """Use the tree info to restore all vnode and tnode data,
    including all links."""

    u = self

    # This effectively relinks all vnodes.
    for v,vInfo,tInfo in treeInfo:
        u.restoreVnodeUndoInfo(vInfo)
        u.restoreTnodeUndoInfo(tInfo)
#@+node:ekr.20050415170737.2:restoreVnodeUndoInfo
def restoreVnodeUndoInfo (self,bunch):

    """Restore all ivars saved in the bunch."""

    v = bunch.v

    v.statusBits = bunch.statusBits
    v.children   = bunch.children
    v.parents    = bunch.parents

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
#@-node:ekr.20050415170737.2:restoreVnodeUndoInfo
#@+node:ekr.20050415170812.2:restoreTnodeUndoInfo
def restoreTnodeUndoInfo (self,bunch):

    t = bunch.t

    t._headString  = bunch.headString
    t._bodyString  = bunch.bodyString
    t.vnodeList   = bunch.vnodeList
    t.statusBits  = bunch.statusBits

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        t.unknownAttributes = uA
        t._p_changed = 1
#@-node:ekr.20050415170812.2:restoreTnodeUndoInfo
#@-node:EKR.20040530121329:u.restoreTree & helpers
#@+node:EKR.20040528075307:u.saveTree & helpers
def saveTree (self,p,treeInfo=None):

    """Return a list of tuples with all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    << about u.saveTree >>

    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v and p.v.t.  Duplicate tnode info is harmless.
    data = (p.v,u.createVnodeUndoInfo(p.v),u.createTnodeUndoInfo(p.v.t))
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
#@+node:EKR.20040530114124:<< about u.saveTree >>
@ 
The old code made a free-standing copy of the tree using v.copy and t.copy.  This looks "elegant" and is WRONG.  The problem is that it can not handle clones properly, especially when some clones were in the "undo" tree and some were not.   Moreover, it required complex adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed to properly restore the vnodes and tnodes.  It creates a list of tuples, on tuple for each vnode in the tree.  Each tuple has the form,

(vnodeInfo, tnodeInfo)

where vnodeInfo and tnodeInfo are dicts contain all info needed to recreate the nodes.  The v.createUndoInfoDict and t.createUndoInfoDict methods correspond to the old v.copy and t.copy methods.

Aside:  Prior to 4.2 Leo used a scheme that was equivalent to the createUndoInfoDict info, but quite a bit uglier.
#@-node:EKR.20040530114124:<< about u.saveTree >>
#@+node:ekr.20050415170737.1:createVnodeUndoInfo
def createVnodeUndoInfo (self,v):

    """Create a bunch containing all info needed to recreate a vnode for undo."""

    bunch = g.Bunch(
        v = v,
        statusBits = v.statusBits,
        parents    = v.parents[:],
        children   = v.children[:],
        # The tnode never changes so there is no need to save it here.
    )

    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
#@-node:ekr.20050415170737.1:createVnodeUndoInfo
#@+node:ekr.20050415170812.1:createTnodeUndoInfo
def createTnodeUndoInfo (self,t):

    """Create a bunch containing all info needed to recreate a vnode."""

    bunch = g.Bunch(
        t = t,
        headString = t._headString,
        bodyString = t._bodyString,
        vnodeList  = t.vnodeList[:],
        statusBits = t.statusBits,
    )

    if hasattr(t,'unknownAttributes'):
        bunch.unknownAttributes = t.unknownAttributes

    return bunch
#@-node:ekr.20050415170812.1:createTnodeUndoInfo
#@-node:EKR.20040528075307:u.saveTree & helpers
#@-node:ekr.20080416161551.223:Used v._parent
#@+node:ekr.20080416161551.225:Used t._firstChild
#@+node:ekr.20041005105605.127:readError
def readError(self,message):

    # This is useful now that we don't print the actual messages.
    if self.errors == 0:
        self.printError("----- read error. line: %s, file: %s" % (
            self.lineNumber,self.targetFileName,))

    # g.trace(self.root,g.callers())
    self.error(message)

    # Delete all of root's tree.
    self.root.t.children = []
    self.root.setOrphan()
    self.root.setDirty()
#@-node:ekr.20041005105605.127:readError
#@+node:ekr.20040323162707:assert that clones actually share subtrees
if p.isCloned() and p.hasChildren():
    for z in p.v.t.vnodeList:
        assert z.t == p.v.t
#@-node:ekr.20040323162707:assert that clones actually share subtrees
#@+node:ekr.20050415170812.2:restoreTnodeUndoInfo
def restoreTnodeUndoInfo (self,bunch):

    t = bunch.t

    t._headString  = bunch.headString
    t._bodyString  = bunch.bodyString
    t.vnodeList   = bunch.vnodeList
    t.statusBits  = bunch.statusBits

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        t.unknownAttributes = uA
        t._p_changed = 1
#@-node:ekr.20050415170812.2:restoreTnodeUndoInfo
#@+node:ekr.20050415170812.1:createTnodeUndoInfo
def createTnodeUndoInfo (self,t):

    """Create a bunch containing all info needed to recreate a vnode."""

    bunch = g.Bunch(
        t = t,
        headString = t._headString,
        bodyString = t._bodyString,
        vnodeList  = t.vnodeList[:],
        statusBits = t.statusBits,
    )

    if hasattr(t,'unknownAttributes'):
        bunch.unknownAttributes = t.unknownAttributes

    return bunch
#@-node:ekr.20050415170812.1:createTnodeUndoInfo
#@-node:ekr.20080416161551.225:Used t._firstChild
#@+node:ekr.20080420163857.1:Eliminated _parent
#@+node:EKR.20040528075307:u.saveTree & helpers
def saveTree (self,p,treeInfo=None):

    """Return a list of tuples with all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    << about u.saveTree >>

    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v and p.v.t.  Duplicate tnode info is harmless.
    data = (p.v,u.createVnodeUndoInfo(p.v),u.createTnodeUndoInfo(p.v.t))
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
#@+node:EKR.20040530114124:<< about u.saveTree >>
@ 
The old code made a free-standing copy of the tree using v.copy and t.copy.  This looks "elegant" and is WRONG.  The problem is that it can not handle clones properly, especially when some clones were in the "undo" tree and some were not.   Moreover, it required complex adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed to properly restore the vnodes and tnodes.  It creates a list of tuples, on tuple for each vnode in the tree.  Each tuple has the form,

(vnodeInfo, tnodeInfo)

where vnodeInfo and tnodeInfo are dicts contain all info needed to recreate the nodes.  The v.createUndoInfoDict and t.createUndoInfoDict methods correspond to the old v.copy and t.copy methods.

Aside:  Prior to 4.2 Leo used a scheme that was equivalent to the createUndoInfoDict info, but quite a bit uglier.
#@-node:EKR.20040530114124:<< about u.saveTree >>
#@+node:ekr.20050415170737.1:createVnodeUndoInfo
def createVnodeUndoInfo (self,v):

    """Create a bunch containing all info needed to recreate a vnode for undo."""

    bunch = g.Bunch(
        v = v,
        statusBits = v.statusBits,
        parents    = v.parents[:],
        children   = v.children[:],
        # The tnode never changes so there is no need to save it here.
    )

    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
#@-node:ekr.20050415170737.1:createVnodeUndoInfo
#@+node:ekr.20050415170812.1:createTnodeUndoInfo
def createTnodeUndoInfo (self,t):

    """Create a bunch containing all info needed to recreate a vnode."""

    bunch = g.Bunch(
        t = t,
        headString = t._headString,
        bodyString = t._bodyString,
        vnodeList  = t.vnodeList[:],
        statusBits = t.statusBits,
    )

    if hasattr(t,'unknownAttributes'):
        bunch.unknownAttributes = t.unknownAttributes

    return bunch
#@-node:ekr.20050415170812.1:createTnodeUndoInfo
#@-node:EKR.20040528075307:u.saveTree & helpers
#@+node:EKR.20040530121329:u.restoreTree & helpers
def restoreTree (self,treeInfo):

    """Use the tree info to restore all vnode and tnode data,
    including all links."""

    u = self

    # This effectively relinks all vnodes.
    for v,vInfo,tInfo in treeInfo:
        u.restoreVnodeUndoInfo(vInfo)
        u.restoreTnodeUndoInfo(tInfo)
#@+node:ekr.20050415170737.2:restoreVnodeUndoInfo
def restoreVnodeUndoInfo (self,bunch):

    """Restore all ivars saved in the bunch."""

    v = bunch.v

    v.statusBits = bunch.statusBits
    v.children   = bunch.children
    v.parents    = bunch.parents

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
#@-node:ekr.20050415170737.2:restoreVnodeUndoInfo
#@+node:ekr.20050415170812.2:restoreTnodeUndoInfo
def restoreTnodeUndoInfo (self,bunch):

    t = bunch.t

    t._headString  = bunch.headString
    t._bodyString  = bunch.bodyString
    t.vnodeList   = bunch.vnodeList
    t.statusBits  = bunch.statusBits

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        t.unknownAttributes = uA
        t._p_changed = 1
#@-node:ekr.20050415170812.2:restoreTnodeUndoInfo
#@-node:EKR.20040530121329:u.restoreTree & helpers
#@-node:ekr.20080420163857.1:Eliminated _parent
#@+node:ekr.20080421162832.5:Cleanup: parentVnode always returns hidden root node
#@+node:ekr.20080416161551.212:p._parentVnode
def _parentVnode (self):

    '''Return the parent vnode.
    Return the hiddenRootNode if there is no other parent.'''

    p = self

    if p.v:
        data = p.stack and p.stack[-1]
        if data:
            v, junk = data
            return v
        else:
            return p.v.context.hiddenRootNode
    else:
        return None
#@-node:ekr.20080416161551.212:p._parentVnode
#@-node:ekr.20080421162832.5:Cleanup: parentVnode always returns hidden root node
#@-node:ekr.20080420163857.2:Projects...
#@-node:ekr.20080416161308.1:This is the graph world
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
