#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20071217134533:Pylint
#@+node:ekr.20071217231348:Pylint docs
@nocolor



















#@+node:ekr.20071217231348.1:options
General options

rcfile:	Specify a configuration file.
init-hook:	Python code to execute, usually for sys.path manipulation such as pygtk.require().
rpython-mode:	enable the rpython checker which is disabled by default
errors-only:	In debug mode, checkers without error messages are disabled and for others, only the ERROR messages are displayed, and no reports are done by default
profile:	Profiled execution.
ignore:	Add <file or directory> to the black list. It should be a base name, not a path. You may set this option multiple times. Default: CVS
persistent:	Pickle collected data for later comparisons. Default: yes
cache-size:	Set the cache size for astng objects. Default: 500
load-plugins:	List of plugins (as comma separated values of python modules names) to load, usually to register additional checkers.

Commands options

help-msg:	Display a help message for the given message id and exit. The value may be a comma separated list of message ids.
list-msgs:	Generate pylint's full documentation.
generate-rcfile:
 	Generate a sample configuration file according to the current configuration. You can put other options before this one to get them in the generated configuration.
generate-man:	Generate pylint's man page.

Messages control options

enable-checker:	Enable only checker(s) with the given id(s). This option conflict with the disable-checker option
disable-checker: Enable all checker(s) except those with the given id(s). This option conflict with the disable-checker option
enable-msg-cat:	Enable all messages in the listed categories.
disable-msg-cat: Disable all messages in the listed categories.
enable-msg:	Enable the message(s) with the given id(s).
disable-msg:	Disable the message(s) with the given id(s).

Reports options

output-format:	set the output format. Available formats are text, parseable, colorized, msvs (visual studio) and html Default: text
include-ids:	Include message's id in output
files-output:	Put messages in a separate file for each module / package specified on the command line instead of printing them on stdout. Reports (if any) will be written in a file name "pylint_global.[txt|html]".
reports:	Tells wether to display a full report or only the messages Default: yes
evaluation:	Python expression which should return a note less than 10 (10 is the highest note).You have access to the variables errors warning, statement which respectivly contain the number of errors / warnings messages and the total number of statements analyzed. This is used by the global evaluation report (R0004). Default: 10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10)
comment:	Add a comment according to your evaluation note. This is used by the global evaluation report (R0004).
enable-report:	Enable the report(s) with the given id(s).
disable-report:	Disable the report(s) with the given id(s).
#@nonl
#@-node:ekr.20071217231348.1:options
#@+node:ekr.20071217231348.2:Main messages and reports
Main messages

E0001:	Used when a syntax error is raised for a module.
E0011:	Unrecognized file option %r Used when an unknown inline option is encountered.
E0012:	Bad option value %r Used when a bad value for an inline option is encountered.

I0001:	Unable to run raw checkers on built-in module %s Used to inform that a built-in module has not been checked using the raw checkers.
I0010:	Unable to consider inline option %r Used when an inline option is either badly formatted or can't be used inside modules.
I0011:	Locally disabling %s Used when an inline option disable a message or a messages category.
I0012:	Locally enabling %s Used when an inline option enable a message or a messages category.
I0013:	Ignoring entire file Used to inform that the file will not be checked
F0001:	Used when an error occured preventing the analyzing of a module (unable to find it for instance).
F0002:	%s: %s Used when an unexpected error occured while building the ASTNG representation. This is usually accomopagned by a traceback. Please report such errors !
F0003:	ignored builtin module %s Used to indicate that the user asked to analyze a builtin module which has been skipped.
F0004:	unexpected infered value %s Used to indicate that some value of an unexpected type has been infered.

Main reports

R0001:	Messages by category
R0002:	% errors / warnings by module
R0003:	Messages
R0004:	Global evaluation
#@nonl
#@-node:ekr.20071217231348.2:Main messages and reports
#@+node:ekr.20071217231348.3:Basic
Basic checker

Options

required-attributes:
 	Required attributes for module, separated by a comma
no-docstring-rgx:
 	Regular expression which should only match functions or classes name which do not require a docstring Default: __.*__
module-rgx:	Regular expression which should only match correct module names Default: (([a-z_][a-z0-9_]*)|([A-Z][a-zA-Z0-9]+))$
const-rgx:	Regular expression which should only match correct module level names Default: (([A-Z_][A-Z1-9_]*)|(__.*__))$
class-rgx:	Regular expression which should only match correct class names Default: [A-Z_][a-zA-Z0-9]+$
function-rgx:	Regular expression which should only match correct function names Default: [a-z_][a-z0-9_]{2,30}$
method-rgx:	Regular expression which should only match correct method names Default: [a-z_][a-z0-9_]{2,30}$
attr-rgx:	Regular expression which should only match correct instance attribute names Default: [a-z_][a-z0-9_]{2,30}$
argument-rgx:	Regular expression which should only match correct argument names Default: [a-z_][a-z0-9_]{2,30}$
variable-rgx:	Regular expression which should only match correct variable names Default: [a-z_][a-z0-9_]{2,30}$
inlinevar-rgx:	Regular expression which should only match correct list comprehension / generator expression variable names Default: [A-Za-z_][A-Za-z0-9_]*$
good-names:	Good variable names which should always be accepted, separated by a comma Default: i,j,k,ex,Run,_
bad-names:	Bad variable names which should always be refused, separated by a comma Default: foo,bar,baz,toto,tutu,tata
bad-functions:	List of builtins function names that should not be used, separated by a comma Default: map,filter,apply,input

Messages

E0100:	__init__ method is a generator Used when the special class method __init__ is turned into a generator by a yield in its body.
E0101:	Explicit return in __init__ Used when the special class method __init__ has an explicit return value.
E0102:	%s already defined line %s Used when a function / class / method is redefined.
E0103:	%r not properly in loop Used when break or continue keywords are used outside a loop.
E0104:	return outside function Used when a "return" statement is found outside a function or method.
E0105:	yield outside function Used when a "yield" statement is found outside a function or method.
E0106:	return with argument inside generator Used when a "return" statement with an argument is found outside in a generator function or method (e.g. with some "yield" statements).

W0101:	Unreachable code Used when there is some code behind a "return" or "raise" statement, which will never be accessed.
W0102:	Dangerous default value %s as argument Used when a mutable value as list or dictionary is detected in a default value for an argument.
W0104:	Statement seems to have no effect Used when a statement doesn't have (or at least seems to) any effect.
W0105:	String statement has no effect Used when a string is used as a statement (which of course has no effect). This is a particular case of W0104 with its own message so you can easily disable it if you're using those strings as documentation, instead of comments.
W0106:	Unnecessary semicolon Used when a statement is endend by a semi-colon (";"), which isn't necessary (that's python, not C ;).
W0107:	Unnecessary pass statement Used when a "pass" statement that can be avoided is encountered.)
W0122:	Use of the exec statement Used when you use the "exec" statement, to discourage its usage. That doesn't mean you can not use it !
W0141:	Used builtin function %r Used when a black listed builtin function is used (see the bad-function option). Usual black listed functions are the ones like map, or filter , where Python offers now some cleaner alternative like list comprehension.
W0142:	Used * or * magic* Used when a function or method is called using *args or **kwargs to dispatch arguments. This doesn't improve readility and should be used with care.

C0102:	Black listed name "%s" Used when the name is listed in the black list (unauthorized names).
C0103:	Invalid name "%s" (should match %s) Used when the name doesn't match the regular expression associated to its type (constant, variable, class...).
C0111:	Missing docstring Used when a module, function, class or method has no docstring. Some special methods like __init__ doesn't necessary require a docstring.
C0112:	Empty docstring Used when a module, function, class or method has an empty docstring (it would be too easy ;).
C0121:	Missing required attribute "%s" Used when an attribute required for modules is missing.

Reports

R0101:	Statistics by type
#@-node:ekr.20071217231348.3:Basic
#@+node:ekr.20071217231348.4:Type
Typecheck checker

Options

ignore-mixin-members:
 	Tells wether missing members accessed in mixin class should be ignored. A mixin class is detected if its name ends with "mixin" (case insensitive). Default: yes
zope:	When zope mode is activated, consider the acquired-members option to ignore access to some undefined attributes.
acquired-members:
 	List of members which are usually get through zope's acquisition mecanism and so shouldn't trigger E0201 when accessed (need zope=yes to be considered). Default: REQUEST,acl_users,aq_parent

Messages

E1101:	%s %r has no %r member  A variable is accessed for an unexistant member.
E1102:	%s is not callable      An object being called has been infered to a non callable object
E1103:	%s %r has no %r member (but some types could not be inferred) 
                               A variable is accessed for an unexistant member, but astng was not able to interpret all possible types of this variable.
E1111:	Assigning to function call which doesn't return     An assigment is done on a function call but the infered function doesn't return anything.
W1111:	Assigning to function call which only returns None  An assigment is done on a function call but the infered function returns nothing but None.
#@nonl
#@-node:ekr.20071217231348.4:Type
#@+node:ekr.20071217231348.5:Variables
Variables checker

Options

init-import:	Tells wether we should check for unused import in __init__ files.
dummy-variables-rgx:
 	A regular expression matching names used for dummy variables (i.e. not used). Default: _|dummy
additional-builtins:
 	List of additional names supposed to be defined in builtins. Remember that you should avoid to define new builtins when possible.

Messages

E0601:	Using variable %r before assignment Used when a local variable is accessed before it's assignment.
E0602:	Undefined variable %r Used when an undefined variable is accessed.
E0611:	No name %r in module %r Used when a name cannot be found in a module.

W0601:	Global variable %r undefined at the module level Used when a variable is defined through the "global" statement but the variable is not defined in the module scope.
W0602:	Using global for %r but no assigment is done Used when a variable is defined through the "global" statement but no assigment to this variable is done.
W0603:	Using the global statement Used when you use the "global" statement to update a global variable.
PyLint just try to discourage this usage. That doesn't mean you can not use it !
W0604:	Using the global statement at the module level Used when you use the "global" statement at the module level since it has no effect
W0611:	Unused import %s Used when an imported module or variable is not used.
W0612:	Unused variable %r Used when a variable is defined but not used.
W0613:	Unused argument %r Used when a function or method argument is not used.
W0614:	Unused import %s from wildcard import Used when an imported module or variable is not used from a 'from X import *' style import.

W????: Inline emphasis start-string without end-string.
W0621:	Redefining name %r from outer scope (line %s) Used when a variable's name hide a name defined in the outer scope.
W0622:	Redefining built-in %r Used when a variable or function override a built-in.
W0631:	Using possibly undefined loop variable %r Used when an loop variable (i.e. defined by a for loop or a list comprehension or a generator expression) is used outside the loop.
#@nonl
#@-node:ekr.20071217231348.5:Variables
#@+node:ekr.20071217231501:Classes
Classes checker

Options

ignore-iface-methods:
 	List of interface methods to ignore, separated by a comma. This is used for instance to not check methods defines in Zope's Interface base class. Default: isImplementedBy,deferred,extends,names,namesAndDescriptions,queryDescriptionFor,getBases,getDescriptionFor,getDoc,getName,getTaggedValue,getTaggedValueTags,isEqualOrExtendedBy,setTaggedValue,isImplementedByInstancesOf,adaptWith,is_implemented_by
defining-attr-methods:
 	List of method names used to declare (i.e. assign) instance attributes. Default: __init__,__new__,setUp

Messages

E0202:	An attribute inherited from %s hide this method Used when a class defines a method which is hiden by an instance attribute from an ancestor class.
E0203:	Access to member %r before its definition line %s Used when an instance member is accessed before it's actually assigned.
E0211:	Method has no argument Used when a method which should have the bound instance as first argument has no argument defined.
E0213:	Method should have "self" as first argument Used when a method has an attribute different the "self" as first argument. This is considered as an error since this is a soooo common convention that you should'nt break it!
E0221:	Interface resolved to %s is not a class Used when a class claims to implement an interface which is not a class.
E0222:	Missing method %r from %s interface Used when a method declared in an interface is missing from a class implementing this interface

W0201:	Attribute %r defined outside __init__ Used when an instance attribute is defined outside the __init__ method.
W0211:	Static method with %r as first argument Used when a static method has "self" or "cls" as first argument.
W0212:	Access to a protected member %s of a client class Used when a protected member (i.e. class member with a name beginning with an underscore) is access outside the class or a descendant of the class where it's defined.
W0221:	Arguments number differs from %s method Used when a method has a different number of arguments than in the implemented interface or in an overridden method.
W0222:	Signature differs from %s method Used when a method signature is different than in the implemented interface or in an overridden method.
W0223:	Method %r is abstract in class %r but is not overridden Used when an abstract method (ie raise NotImplementedError) is not overridden in concrete class.
W0231:	__init__ method from base class %r is not called Used when an ancestor class method has an __init__ method which is not called by a derived class.
W0232:	Class has no __init__ method Used when a class has no __init__ method, neither its parent classes.
W0233:	__init__ method from a non direct base class %r is called Used when an __init__ method is called on a class which is not in the direct ancestors for the analysed class.
R0201:	Method could be a function Used when a method doesn't use its bound instance, and so could be written as a function.
C0202:	Class method should have "cls" as first argument Used when a class method has an attribute different than "cls" as first argument, to easily differentiate them from regular instance methods.
C0203:	Metaclass method should have "mcs" as first argument Used when a metaclass method has an attribute different the "mcs" as first argument.
F0202:	Unable to check methods signature (%s / %s) Used when PyLint has been unable to check methods signature compatibility for an unexpected raison. Please report this kind if you don't make sense of it.
F0220:	failed to resolve interfaces implemented by %s (%s) Used when a PyLint as failed to find interfaces implemented by a class
#@-node:ekr.20071217231501:Classes
#@+node:ekr.20071217231501.1:Design
Design checker

Options
max-args:	Maximum number of arguments for function / method Default: 5
max-locals:	Maximum number of locals for function / method body Default: 15
max-returns:	Maximum number of return / yield for function / method body Default: 6
max-branchs:	Maximum number of branch for function / method body Default: 12
max-statements:	Maximum number of statements in function / method body Default: 50
max-parents:	Maximum number of parents for a class (see R0901). Default: 7
max-attributes:	Maximum number of attributes for a class (see R0902). Default: 7
min-public-methods:
 	Minimum number of public methods for a class (see R0903). Default: 2
max-public-methods:
 	Maximum number of public methods for a class (see R0904). Default: 20

Messages

R0901:	Too many ancestors (%s/%s) Used when class has too many parent classes, try to reduce this to get a more simple (and so easier to use) class.
R0902:	Too many instance attributes (%s/%s) Used when class has too many instance attributes, try to reduce this to get a more simple (and so easier to use) class.
R0903:	Too few public methods (%s/%s) Used when class has too few public methods, so be sure it's really worth it.
R0904:	Too many public methods (%s/%s) Used when class has too many public methods, try to reduce this to get a more simple (and so easier to use) class.
R0911:	Too many return statements (%s/%s) Used when a function or method has too many return statement, making it hard to follow.
R0912:	Too many branches (%s/%s) Used when a function or method has too many branches, making it hard to follow.
R0913:	Too many arguments (%s/%s) Used when a function or method takes too many arguments.
R0914:	Too many local variables (%s/%s) Used when a function or method has too many local variables.
R0915:	Too many statements (%s/%s) Used when a function or method has too many statements. You should then split it in smaller functions / methods.
R0921:	Abstract class not referenced Used when an abstract class is not used as ancestor anywhere.
R0922:	Abstract class is only referenced %s times Used when an abstract class is used less than X times as ancestor.
R0923:	Interface not implemented Used when an interface class is not implemented anywhere.
#@nonl
#@-node:ekr.20071217231501.1:Design
#@+node:ekr.20071217231501.2:Imports
Imports checker

Options

deprecated-modules:
 	Deprecated modules which should not be used, separated by a comma Default: regsub,string,TERMIOS,Bastion,rexec
import-graph:	Create a graph of every (i.e. internal and external) dependencies in the given file (report R0402 must not be disabled)
ext-import-graph:
 	Create a graph of external dependencies in the given file (report R0402 must not be disabled)
int-import-graph:
 	Create a graph of internal dependencies in the given file (report R0402 must not be disabled)

Messages

W0401:	Wildcard import %s Used when from module import * is detected.
W0402:	Uses of a deprecated module %r Used a module marked as deprecated is imported.
W0403:	Relative import %r Used when an import relative to the package directory is detected.
W0404:	Reimport %r (imported line %s) Used when a module is reimported multiple times.
W0406:	Module import itself Used when a module is importing itself.
W0410:	__future__ import is not the first non docstring statement Python 2.5 and greater require __future__ import to be the first non docstring statement in the module.
R0401:	Cyclic import (%s) Used when a cyclic import between two or more modules is detected.
F0401:	Unable to import %r (%s) Used when pylint has been unable to import a module.

Reports

R0401:	External dependencies
R0402:	Modules dependencies graph
#@nonl
#@-node:ekr.20071217231501.2:Imports
#@+node:ekr.20071217231501.3:Newstyle
Newstyle checker


Messages

E1001:	Use __slots__ on an old style class Used when an old style class use the __slots__ attribute.
E1002:	Use super on an old style class Used when an old style class use the super builtin.
E1003:	Bad first argument %r given to super class Used when another argument than the current class is given as first argument of the super builtin.
E1010:	Raising a new style class Used when a new style class is raised since it's not possible with python < 2.5.
W1001:	Use of "property" on an old style class Used when PyLint detect the use of the builtin "property" on an old style class while this is relying on new style classes 
features
W1010:	Exception doesn't inherit from standard "Exception" class Used when a custom exception class is raised but doesn't inherit from the builtin "Exception" class.
#@nonl
#@-node:ekr.20071217231501.3:Newstyle
#@+node:ekr.20071217231828:Exceptions
Exceptions checker

Messages

E0701:	Bad except clauses order (%s) Used when except clauses are not in the correct order (from the more specific to the more generic). If you don't fix the order, some exceptions may not be catched by the most specific handler.
E0702:	Raising %s while only classes, instances or string are allowed Used when something which is neither a class, an instance or a string is raised (i.e. a TypeError will be raised).
W0701:	Raising a string exception Used when a string exception is raised.
W0702:	No exception's type specified Used when an except clause doesn't specify exceptions type to catch.
W0703:	Catch "Exception" Used when an except catch Exception instances.
W0704:	Except doesn't do anything Used when an except clause does nothing but "pass" and there is no "else" clause.
W0706:	Identifier %s used to raise an exception is assigned to %s Used when a variable used to raise an exception is initially assigned to a value which can't be used as an exception.
#@nonl
#@-node:ekr.20071217231828:Exceptions
#@+node:ekr.20071217231828.1:Format
Format checker

Options

max-line-length:
 	Maximum number of characters on a single line. Default: 80
max-module-lines:
 	Maximum number of lines in a module Default: 1000
indent-string:	String used as indentation unit. This is usually " " (4 spaces) or "t" (1 tab). Default: ' '

Messages

W0311:	Bad indentation. Found %s %s, expected %s Used when an unexpected number of indentation's tabulations or spaces has been found.
W0312:	Found indentation with %ss instead of %ss Used when there are some mixed tabs and spaces in a module.
W0331:	Use of the <> operator Used when the deprecated "<>" operator is used instead of "!=".
W0332:	Use l as long integer identifier Used when a lower case "l" is used to mark a long integer. You should use a upper case "L" since the letter "l" looks too much like the digit "1"
C0301:	Line too long (%s/%s) Used when a line is longer than a given number of characters.
C0302:	Too many lines in module (%s) Used when a module has too much lines, reducing its readibility.
C0321:	More than one statement on a single line Used when more than on statement are found on the same line.
C0322:	Operator not preceded by a space Used when one of the following operator (!= | <= | == | >= | < | > | = | += | -= | *= | /= | %) is not preceded by a space.
C0323:	Operator not followed by a space Used when one of the following operator (!= | <= | == | >= | < | > | = | += | -= | *= | /= | %) is not followed by a space.
C0324:	Comma not followed by a space Used when a comma (",") is not followed by a space.
F0321:	Format detection error in %r Used when an unexpected error occured in bad format detection. Please report the error if it occurs.
#@nonl
#@-node:ekr.20071217231828.1:Format
#@+node:ekr.20071217231828.2:Miscellaneous
Miscellaneous checker

Options

notes:	List of note tags to take in consideration, separated by a comma. Default: FIXME,XXX,TODO

Messages

E0501:	Non ascii characters found but no encoding specified (PEP 263) Used when some non ascii characters are detected but now encoding is specified, as explicited in the PEP 263.
E0502:	Wrong encoding specified (%s) Used when a known encoding is specified but the file doesn't seem to be actually in this encoding.
E0503:	Unknown encoding specified (%s) Used when an encoding is specified, but it's unknown to Python.
W0511:	Used when a warning note as FIXME or XXX is detected.
#@nonl
#@-node:ekr.20071217231828.2:Miscellaneous
#@+node:ekr.20071217231828.3:Metrics
Metrics checker


Reports

R0701:	Raw metrics
#@-node:ekr.20071217231828.3:Metrics
#@+node:ekr.20071217231828.4:Simularities
Similarities checker

min-similarity-lines:
 	Minimum lines number of a similarity. Default: 4
ignore-comments:
 	Ignore comments when computing similarities. Default: yes
ignore-docstrings:
 	Ignore docstrings when computing similarities. Default: yes

Messages

R0801:	Similar lines in %s files Indicates that a set of similar lines has been detected among multiple file. This usually means that the code should be refactored to avoid this duplication.

Reports

R0801:	Duplication
#@-node:ekr.20071217231828.4:Simularities
#@-node:ekr.20071217231348:Pylint docs
#@+node:ekr.20071220081732:pylint report
@killcolor


*** Erroneous errors in Leo 4.4.8



--- old --

************* Module leoTkinterTree

W0221:2377:leoTkinterTree.setSelectedLabelState: Arguments number differs from overridden method
W0221:2387:leoTkinterTree.setUnselectedLabelState: Arguments number differs from overridden method
#@+node:ekr.20080304084023:leoEditCommands
*** All these error messages are WRONG.

E1101:114:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'name' member
E1101:115:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'undoType' member
E1101:116:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'oldSel' member
E1101:116:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'oldText' member

E1101:8091:spellCommandsClass.openSpellTab: Instance of 'spellTabHandler' has no 'bringToFront' member
E1101:8121:spellCommandsClass.changeAll: Instance of 'spellTabHandler' has no 'changeAll' member
E1101:8129:spellCommandsClass.changeThenFind: Instance of 'spellTabHandler' has no 'changeThenFind' member
#@nonl
#@-node:ekr.20080304084023:leoEditCommands
#@+node:ekr.20080304084023.1:leoGlobals
*** All these error messages are WRONG.

E1101:137:computeGlobalConfigDir: Module 'sys' has no 'leo_config_directory' member
W0104:3915: Statement seems to have no effect

E0602:3931:getpreferredencoding: Undefined variable 'LC_CTYPE'
E0602:3932:getpreferredencoding: Undefined variable 'LC_CTYPE'
E1101:3933:getpreferredencoding: Module 'locale' has no 'nl_langinfo' member
E0602:3933:getpreferredencoding: Undefined variable 'CODESET'
E0602:3934:getpreferredencoding: Undefined variable 'LC_CTYPE'
E1101:3937:getpreferredencoding: Module 'locale' has no 'nl_langinfo' member
E0602:3937:getpreferredencoding: Undefined variable 'CODESET'
E1101:4432:mulderUpdateAlgorithm.copy_time: Module 'os' has no 'mtime' member
#@-node:ekr.20080304084023.1:leoGlobals
#@+node:ekr.20080304091441:leoTkinterFind
*** All these error messages are WRONG.

************* Module leoTkinterFind
E1101: 95:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'title' member
E1101:101:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'intKeys' member
E1101:104:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'newStringKeys' member
E1101:113:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'createTopFrame' member
E1101:115:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'top' member
E1101:116:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'top' member
E1101:123:leoTkinterFind.init: Instance of 'leoTkinterFind' has no 'intKeys' member
E1101:177:leoTkinterFind.destroySelf: Instance of 'leoTkinterFind' has no 'top' member
E1101:185:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'frame' member
E1101:213:leoTkinterFind.createFrame.setFocus: Instance of 'leoTkinterFind' has no 'c' member
E1101:298:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1101:305:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1103:325:leoTkinterFind.createFrame.findButtonCallback: Instance of 'leoTkinterFind' has no 'findButton' member (but some types c
ould not be inferred)
E1101:341:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'findAllButton' member
E1101:348:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'changeButton' member
E1101:354:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'changeThenFindButton' member
E1101:360:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'changeAllButton' member
E1101:367:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'top' member
E1101:368:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'top' member
E1103:378:leoTkinterFind.createBindings.findButtonCallback2: Instance of 'leoTkinterFind' has no 'findButton' member (but some typ
es could not be inferred)
E1101:382:leoTkinterFind.createBindings: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1101:383:leoTkinterFind.createBindings: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1101:384:leoTkinterFind.createBindings: Instance of 'leoTkinterFind' has no 'selectAllFindText' member
E1101:396:leoTkinterFind.onCloseWindow: Instance of 'leoTkinterFind' has no 'top' member
E1101:401:leoTkinterFind.dismiss: Instance of 'leoTkinterFind' has no 'top' member
E1101:408:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'c' member
E1101:410:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'top' member
E1101:411:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'top' member
E1101:412:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'top' member
E1101:438:tkFindTab.initGui: Instance of 'tkFindTab' has no 'intKeys' member
E1101:441:tkFindTab.initGui: Instance of 'tkFindTab' has no 'newStringKeys' member
E1101:448:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'c' member
E1101:489:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'optionsOnly' member
E1101:504:tkFindTab.createFrame.setFocus: Instance of 'tkFindTab' has no 'c' member
E1101:538:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'optionsOnly' member
E1101:591:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'resetWrap' member
E1101:599:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'resetWrap' member
E1101:606:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'optionsOnly' member
E1101:623:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'findButtonCallback' member
E1101:624:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'findAllButton' member
E1101:626:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'changeButton' member
E1101:627:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'changeThenFindButton' member
E1101:628:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'changeAllButton' member
E1101:647:tkFindTab.createBindings: Instance of 'tkFindTab' has no 'c' member
E1103:650:tkFindTab.createBindings.resetWrapCallback: Instance of 'tkFindTab' has no 'resetWrap' member (but some types could not
be inferred)
E1103:654:tkFindTab.createBindings.findButtonBindingCallback: Instance of 'tkFindTab' has no 'findButton' member (but some types c
ould not be inferred)
E1101:664:tkFindTab.createBindings: Instance of 'tkFindTab' has no 'hideTab' member
E1101:677:tkFindTab.init: Instance of 'tkFindTab' has no 'intKeys' member
E1101:746:tkFindTab.setOption: Instance of 'tkFindTab' has no 'intKeys' member
E1101:758:tkFindTab.toggleOption: Instance of 'tkFindTab' has no 'intKeys' member
"*****done*****"
Press any key to continue . . .
#@nonl
#@-node:ekr.20080304091441:leoTkinterFind
#@+node:ekr.20080304091441.1:leoTkinterGui
*** All these error messages are WRONG.

************* Module leoTkinterGui
E1101:179:tkinterGui.runMainLoop: Instance of 'tkinterGui' has no 'script' member
E1101:183:tkinterGui.runMainLoop: Instance of 'tkinterGui' has no 'script' member
#@-node:ekr.20080304091441.1:leoTkinterGui
#@+node:ekr.20080304092628:leoTkinterFrame
*** All these error messages are WRONG.

leoTkinterFrame.py Harmless: W0221: mismatch between Tk.Text methods and overridden methods.
leoTkinterFrame.py Dangerous: E1101
************* Module leoTkinterFrame
E1101: 53:leoTkinterBody.__init__: Instance of 'leoTkinterBody' has no 'c' member
E1101: 67:leoTkinterBody.createBindings: Instance of 'leoTkinterBody' has no 'frame' member
E1101: 67:leoTkinterBody.createBindings: Instance of 'leoTkinterBody' has no 'c' member
E1101: 88:leoTkinterBody.createControl: Instance of 'leoTkinterBody' has no 'c' member
E1101:102:leoTkinterBody.createControl: Instance of 'leoTkinterBody' has no 'editorWidgets' member
E1101:109:leoTkinterBody.createTextWidget: Instance of 'leoTkinterBody' has no 'c' member
E1101:176:leoTkinterBody.setColorFromConfig: Instance of 'leoTkinterBody' has no 'c' member
E1101:224:leoTkinterBody.setFontFromConfig: Instance of 'leoTkinterBody' has no 'c' member
E1101:241:leoTkinterBody.hasFocus: Instance of 'leoTkinterBody' has no 'frame' member
E1101:245:leoTkinterBody.setFocus: Instance of 'leoTkinterBody' has no 'c' member
E1101:351:leoTkinterBody.setEditorColors: Instance of 'leoTkinterBody' has no 'c' member
E1101:351:leoTkinterBody.setEditorColors: Instance of 'leoTkinterBody' has no 'editorWidgets' member
E1101:379:leoTkinterFrame.__init__: Class 'leoTkinterFrame' has no 'instances' member
E1101:437:leoTkinterFrame.finishCreate: Instance of 'leoTkinterFrame' has no 'initialRatios' member
E1101:439:leoTkinterFrame.finishCreate: Instance of 'leoTkinterFrame' has no 'createIconBar' member
E1101:442:leoTkinterFrame.finishCreate: Instance of 'leoTkinterFrame' has no 'createStatusLine' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'comparePanel' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'colorPanel' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'fontPanel' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'prefsPanel' member
E1101:1347:leoTkinterFrame.setMinibufferBindings: Instance of 'leoTkinterFrame' has no 'OnPaste' member
E1101:1901:leoTkinterFrame.toggleTkSplitDirection: Instance of 'leoTkinterFrame' has no 'initialRatios' member
E1101:2111:leoTkinterLog.createCanvasWidget: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2138:leoTkinterLog.createTextWidget: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2140:leoTkinterLog.createTextWidget: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2303:leoTkinterLog.onActivateLog: Instance of 'leoTkinterLog' has no 'frame' member
E1101:2423:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2424:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2431:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2432:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2433:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2462:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2463:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2464:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2475:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2476:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2477:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2489:leoTkinterLog.cycleTabFocus: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2514:leoTkinterLog.deleteTab: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2515:leoTkinterLog.deleteTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2516:leoTkinterLog.deleteTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2556:leoTkinterLog.numberOfVisibleTabs: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2573:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2574:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2587:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2589:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2600:leoTkinterLog.setTabBindings: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2600:leoTkinterLog.setTabBindings: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2787:leoTkinterLog.createColorPicker: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2788:leoTkinterLog.createColorPicker: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2845:leoTkinterLog.createFontPicker: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2846:leoTkinterLog.createFontPicker: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:3018:leoTkinterTreeTab.createControl: Instance of 'leoTkinterTreeTab' has no 'c' member
E1101:3065:leoTkinterTreeTab.selectTab: Instance of 'leoTkinterTreeTab' has no 'cc' member
"*****done*****"
Press any key to continue . . .
#@nonl
#@-node:ekr.20080304092628:leoTkinterFrame
#@+node:ekr.20080304093027:leoTkinterKeys
*** All these error messages are WRONG.

************* Module leoTkinterKeys
E1101: 27:tkinterKeyHandlerClass.createTkIvars: Instance of 'tkinterKeyHandlerClass' has no 'useTextWidget' member
E1101: 27:tkinterKeyHandlerClass.createTkIvars: Instance of 'tkinterKeyHandlerClass' has no 'widget' member
E1101: 29:tkinterKeyHandlerClass.createTkIvars: Instance of 'tkinterKeyHandlerClass' has no 'widget' member
#@-node:ekr.20080304093027:leoTkinterKeys
#@+node:ekr.20080304093258:leoTkinterMenu
*** All these error messages are WRONG.

leoTkinterMenu.py
************* Module leoTkinterMenu
E1101: 62:leoTkinterMenu.computeMenuPositions: Instance of 'leoTkinterMenu' has no 'getMenu' member
E1101:136:leoTkinterMenu.insert: Instance of 'leoTkinterMenu' has no 'getMenu' member
E1101:172:leoTkinterMenu.clearAccel: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:183:leoTkinterMenu.createMenuBar: Instance of 'leoTkinterMenu' has no 'updateAllMenus' member
E1101:186:leoTkinterMenu.createMenuBar: Instance of 'leoTkinterMenu' has no 'setMenu' member
E1101:187:leoTkinterMenu.createMenuBar: Instance of 'leoTkinterMenu' has no 'createMenusFromTables' member
E1101:208:leoTkinterMenu.disableMenu: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:225:leoTkinterMenu.enableMenu: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:255:leoTkinterMenu.setMenuLabel: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:258:leoTkinterMenu.setMenuLabel: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:297:leoTkinterMenu.getMacHelpMenu: Instance of 'leoTkinterMenu' has no 'getMenu' member
E1101:301:leoTkinterMenu.getMacHelpMenu: Instance of 'leoTkinterMenu' has no 'createMenuEntries' member
#@-node:ekr.20080304093258:leoTkinterMenu
#@-node:ekr.20071220081732:pylint report
#@-node:ekr.20071217134533:Pylint
#@+node:ekr.20080408060320.4:4.5 a1
#@+node:ekr.20080408060320.782:Bug fixes
#@+node:ekr.20080408060320.2:Fixed bug in install script
@nocolor

On Mon, Apr 7, 2008 at 7:07 PM, SegundoBob <bhossley@ieee.org> wrote:

I installed Leo 4.4..8 final on Ubuntu.  The installation failed
because the installation put files in /usr/lib/leo/leo.  The
duplicated leo is a mistake.
On line 13 of install I changed:
LEO_LIB_DIR="${LEO_PREFIX}/lib/leo"
to
LEO_LIB_DIR="${LEO_PREFIX}/lib"

With the change the installation worked.
#@nonl
#@-node:ekr.20080408060320.2:Fixed bug in install script
#@+node:ekr.20080407090400.1:Fixed how-many, find-word and goto-character commands
@nocolor

find-word
=========
This command is supposed to:

"Put the cursor at the next word (on a line) that starts with a
character"

It does not. You have to type in a whole word to get any result and
even then
it only selects the word it does not move the cursor to it.


goto-charachter
==============
'''Put the cursor at the n'th character of the buffer.'''

Doesn't do anything.

The fixes do **not** involve the new allowMinibuffer arg.

@color
#@nonl
#@+node:ekr.20050920084036.80:howMany
def howMany (self,event):

    '''Print how many occurances of a regular expression are found
    in the body text of the presently selected node.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    state = k.getState('how-many')
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.getAllText()
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
#@-node:ekr.20050920084036.80:howMany
#@+node:ekr.20060417194232:find (quick)
#@+node:ekr.20060925151926:backward/findCharacter & helper
def backwardFindCharacter (self,event):
    return self.findCharacterHelper(event,backward=True,extend=False)

def backwardFindCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=True,extend=True)

def findCharacter (self,event):
    return self.findCharacterHelper(event,backward=False,extend=False)

def findCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=False,extend=True)
#@nonl
#@+node:ekr.20060417194232.1:findCharacterHelper
def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward ; self.extend = extend
        self.insert = w.getInsertPoint()
        s = '%s character%s: ' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' & extend',''))
        k.setLabelBlue(s,protect=True)
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward ; extend = self.extend
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = s.rfind('\n',0,i)
            if start == -1: start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        else:
            end = s.find('\n',i)
            if end == -1: end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.1:findCharacterHelper
#@-node:ekr.20060925151926:backward/findCharacter & helper
#@+node:ekr.20060417194232.2:findWord and FindWordOnLine & helper
def findWord(self,event):

    '''Put the cursor at the next word that starts with a character.'''

    return self.findWordHelper(event,oneLine=True)

def findWordInLine(self,event):

    '''Put the cursor at the next word (on a line) that starts with a character.'''

    return self.findWordHelper(event,oneLine=True)

#@+node:ekr.20080408060320.1:findWordHelper
def findWordHelper (self,event,oneLine):

    k = self.k ; tag = 'find-word' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.oneLineFlag = oneLine
        k.setLabelBlue('Find word %sstarting with: ' % (
            g.choose(oneLine,'in line ','')))
        k.getArg(event,tag,1,self.findWord,oneCharacter=True)
    else:        
        ch = k.arg ; w = self.w ; c = k.c
        if ch:
            i = w.getInsertPoint()
            s = w.getAllText()
            if self.oneLineFlag:
                end = s.find('\n',i) # Limit searches to this line.
                if end == -1: end = len(s)
            else:
                end = len(s)

            while i < end:
                i = s.find(ch,i+1,end) # Ensure progress and i > 0.
                if i == -1:
                    break
                elif not g.isWordChar(s[i-1]):
                    w.setSelectionRange(i,i,insert=i)
                    break

        k.resetLabel()
        k.clearState()
#@-node:ekr.20080408060320.1:findWordHelper
#@-node:ekr.20060417194232.2:findWord and FindWordOnLine & helper
#@-node:ekr.20060417194232:find (quick)
#@+node:ekr.20050929115226:gotoCharacter
def gotoCharacter (self,event):

    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue("Goto n'th character: ")
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.w ; ok = False
        if n.isdigit():
            n = int(n)
            if n >= 0:
                w.setInsertPoint(n)
                w.seeInsertPoint()
                ok = True
        if not ok:
            g.es('goto-char takes non-negative integer argument',color='blue')
        k.resetLabel()
        k.clearState()
#@-node:ekr.20050929115226:gotoCharacter
#@-node:ekr.20080407090400.1:Fixed how-many, find-word and goto-character commands
#@+node:ekr.20080408060320.786:Allow cursor movement commands in the minibuffer
@ Most commands should always work *outside* of the minibuffer.

But a few commands should work both inside and outsi
#@nonl
#@+node:ekr.20080408060320.787: Present bindings
# Top-level bindings are *not* inherited in the minibuffer!
copy-text           ! mini = Ctrl-c
cut-text            ! mini = Ctrl-x
paste-text          ! mini = Ctrl-v
save-file           ! mini = Ctrl-s

# Important: at present binding to BackSpace in the minibuffer causes problems.
# backward-delete-char                ! mini = BackSpace

back-char                           ! mini = LtArrow
back-char-extend-selection          ! mini = Shift-LtArrow
back-word                           ! mini = Alt-b  
back-word-extend-selection          ! mini = Alt-Shift-b
backward-kill-word                  ! mini = Alt-Delete
beginning-of-line                   ! mini = Home
beginning-of-line-extend-selection  ! mini = Shift-Home
beginning-of-line                   ! mini = Ctrl-a
beginning-of-line-extend-selection  ! mini = Ctrl-Shift-a
dabbrev-completion                  = Alt-\
dabbrev-expands                     = Alt-Ctrl-\
end-of-line                         ! mini = End
end-of-line-extend-selection        ! mini = Shift-End
end-of-line                         ! mini = Ctrl-e
end-of-line-extend-selection        ! mini = Ctrl-Shift-e
forward-char                        ! mini = RtArrow
forward-char-extend-selection       ! mini = Shift-RtArrow
forward-word                        = None ### ! mini = Alt-f          # Usually opens file menu.
forward-word-extend-selection       = None ### ! mini = Alt-Shift-f
kill-line                           ! mini = Ctrl-K
select-all                          ! mini = Alt-Shift-A
yank                                ! mini = Ctrl-Y
#@+node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
def getPublicCommands (self):        

    c = self.c

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,
        'add-editor':                           c.frame.body and c.frame.body.addEditor,
        'add-space-to-lines':                   self.addSpaceToLines,
        'add-tab-to-lines':                     self.addTabToLines, 
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'backward-find-character':              self.backwardFindCharacter,
        'backward-find-character-extend-selection': self.backwardFindCharacterExtendSelection,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clean-all-lines':                      self.cleanAllLines,
        'clean-lines':                          self.cleanLines,
        'clear-extend-mode':                    self.clearExtendMode,
        'clear-selected-text':                  self.clearSelectedText,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'cycle-all-focus':                      self.cycleAllFocus,
        'cycle-editor-focus':                   c.frame.body.cycleEditorFocus,
        # 'delete-all-icons':                   self.deleteAllIcons,
        'delete-char':                          self.deleteNextChar,
        'delete-editor':                        c.frame.body.deleteEditor,
        'delete-first-icon':                    self.deleteFirstIcon,
        'delete-indentation':                   self.deleteIndentation,
        'delete-last-icon':                     self.deleteLastIcon,
        'delete-node-icons':                    self.deleteNodeIcons,
        'delete-spaces':                        self.deleteSpaces,
        'do-nothing':                           self.doNothing,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'extend-to-line':                       self.extendToLine,
        'extend-to-paragraph':                  self.extendToParagraph,
        'extend-to-sentence':                   self.extendToSentence,
        'extend-to-word':                       self.extendToWord,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'find-character':                       self.findCharacter,
        'find-character-extend-selection':      self.findCharacterExtendSelection,
        'find-word':                            self.findWord,
        'find-word-in-line':                    self.findWordInLine,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-end-word':                     self.forwardEndWord, # New in Leo 4.4.2.
        'forward-end-word-extend-selection':    self.forwardEndWordExtendSelection, # New in Leo 4.4.2.
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-global-line':                     self.gotoGlobalLine,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-icon':                          self.insertIcon,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-lines-down':                      self.moveLinesDown,
        'move-lines-up':                        self.moveLinesUp,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'remove-space-from-lines':              self.removeSpaceFromLines,
        'remove-tab-from-lines':                self.removeTabFromLines,
        'reverse-region':                       self.reverseRegion,
        'reverse-sort-lines':                   self.reverseSortLines,
        'reverse-sort-lines-ignoring-case':     self.reverseSortLinesIgnoringCase,                 
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-outline-down-line':             self.scrollOutlineDownLine,
        'scroll-outline-down-page':             self.scrollOutlineDownPage,
        'scroll-outline-left':                  self.scrollOutlineLeft,
        'scroll-outline-right':                 self.scrollOutlineRight,
        'scroll-outline-up-line':               self.scrollOutlineUpLine,
        'scroll-outline-up-page':               self.scrollOutlineUpPage,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-all':                           self.selectAllText,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        #'set-mark-command':                    self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'sort-lines-ignoring-case':             self.sortLinesIgnoringCase,
        'split-line':                           self.splitLine,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
#@-node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
#@-node:ekr.20080408060320.787: Present bindings
#@+node:ekr.20080408060320.795:Classes
#@+node:ekr.20061031170011.3:Minibuffer (keyHandler)
# These may be overridden, but this code is now gui-independent.
#@nonl
#@+node:ekr.20061031131434.135:k.minibufferWantsFocus/Now
def minibufferWantsFocus(self):

    c = self.c
    if self.useTextWidget:
        c.widgetWantsFocus(c.miniBufferWidget)
    else:
        c.bodyWantsFocus()

def minibufferWantsFocusNow(self):

    c = self.c
    if self.useTextWidget:
        c.widgetWantsFocusNow(c.miniBufferWidget)
    else:
        c.bodyWantsFocusNow()
#@-node:ekr.20061031131434.135:k.minibufferWantsFocus/Now
#@+node:ekr.20061031170011.5:getLabel
def getLabel (self,ignorePrompt=False):

    k = self ; w = self.widget
    if not w: return ''

    if self.useTextWidget:
        s = w.getAllText()
    else:
        s = k.svar and k.svar.get()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''
#@-node:ekr.20061031170011.5:getLabel
#@+node:ekr.20080408060320.791:k.killLine (new)
def killLine (self,protect=True):

    k = self ; c = self.c
    w = self.widget
    s = w.getAllText()
    s = s[:len(k.mb_prefix)]

    if self.useTextWidget:
        w.setAllText(s)
        n = len(s)
        w.setSelectionRange(n,n,insert=n)
        c.masterFocusHandler() # Restore to the previously requested focus.
    else:
        if k.svar: k.svar.set(s)

    if protect:
        k.mb_prefix = s
#@-node:ekr.20080408060320.791:k.killLine (new)
#@+node:ekr.20061031170011.6:protectLabel
def protectLabel (self):

    k = self ; w = self.widget
    if not w: return

    if self.useTextWidget:
        k.mb_prefix = w.getAllText()
    else:
        if k.svar:
            k.mb_prefix = k.svar.get()
#@-node:ekr.20061031170011.6:protectLabel
#@+node:ekr.20061031170011.7:resetLabel (changed)
def resetLabel (self):

    k = self ; w = self.widget
    k.setLabelGrey('')
    k.mb_prefix = ''
    if w:
        w.setSelectionRange(0,0,insert=0)
#@-node:ekr.20061031170011.7:resetLabel (changed)
#@+node:ekr.20061031170011.8:setLabel
def setLabel (self,s,protect=False):

    k = self ; c = k.c ; w = self.widget
    if not w: return
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace('len(s)',len(s),g.callers())

    if self.useTextWidget:
        w.setAllText(s)
        n = len(s)
        w.setSelectionRange(n,n,insert=n)
        c.masterFocusHandler() # Restore to the previously requested focus.
    else:
        if k.svar: k.svar.set(s)

    if protect:
        k.mb_prefix = s
#@-node:ekr.20061031170011.8:setLabel
#@+node:ekr.20061031170011.9:extendLabel
def extendLabel(self,s,select=False,protect=False):

    k = self ; c = k.c ; w = self.widget
    if not w: return
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace('len(s)',len(s))
    if not s: return

    if self.useTextWidget:
        c.widgetWantsFocusNow(w)
        w.insert('end',s)
        if select:
            i,j = k.getEditableTextRange()
            w.setSelectionRange(i,j,insert=j)
        if protect:
            k.protectLabel()
#@-node:ekr.20061031170011.9:extendLabel
#@+node:ekr.20080408060320.790:selectAll (new)
def selectAll (self):

    '''Select all the user-editable text of the minibuffer.'''

    w = self.widget
    i,j = self.getEditableTextRange()
    w.setSelectionRange(i,j,insert=j)


#@-node:ekr.20080408060320.790:selectAll (new)
#@+node:ekr.20061031170011.10:setLabelBlue
def setLabelBlue (self,label=None,protect=False):

    k = self ; w = k.widget
    if not w: return

    w.setBackgroundColor('lightblue')

    if label is not None:
        k.setLabel(label,protect)
#@-node:ekr.20061031170011.10:setLabelBlue
#@+node:ekr.20061031170011.11:setLabelGrey
def setLabelGrey (self,label=None):

    k = self ; w = self.widget
    if not w: return

    w.setBackgroundColor('lightgrey')

    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
#@-node:ekr.20061031170011.11:setLabelGrey
#@+node:ekr.20061031170011.12:updateLabel
def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''

    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace('ch',ch,'keysym',keysym,'k.stroke',k.stroke)
    # g.trace(g.callers())

    if ch and ch not in ('\n','\r'):
        if self.useTextWidget:
            c.widgetWantsFocusNow(w)
            i,j = w.getSelectionRange()
            ins = w.getInsertPoint()
            if i != j:
                w.delete(i,j)
            if ch == '\b':
                s = w.getAllText()
                if len(s) > len(k.mb_prefix):
                    w.delete(i-1)
            else:
                w.insert(ins,ch)
            # g.trace(k.mb_prefix)       
        else:
            # Just add the character.
            k.setLabel(k.getLabel() + ch)
#@-node:ekr.20061031170011.12:updateLabel
#@+node:ekr.20061031170011.13:getEditableTextRange
def getEditableTextRange (self):

    k = self ; w = self.widget
    trace = self.trace_minibuffer and not g.app.unitTesting

    s = w.getAllText()
    # g.trace(len(s),repr(s))

    i = len(k.mb_prefix)
    j = len(s)

    trace and g.trace(i,j)
    return i,j
#@-node:ekr.20061031170011.13:getEditableTextRange
#@-node:ekr.20061031170011.3:Minibuffer (keyHandler)
#@+node:ekr.20061112152012.2:class leoKeyEvent (tkGui)
class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c):

        # g.trace('leoKeyEvent(tkGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0
        # Support for fastGotoNode plugin
        self.x_root = hasattr(event,'x_root') and event.x_root or 0
        self.y_root = hasattr(event,'y_root') and event.y_root or 0

        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)

        self.widget = self.w

    def __repr__ (self):

        return 'tkGui.leoKeyEvent: char: %s, keysym: %s, widget: %s' % (
            repr(self.char),repr(self.keysym),self.widget)
#@nonl
#@-node:ekr.20061112152012.2:class leoKeyEvent (tkGui)
#@+node:ekr.20050920084036.53:editCommandsClass
class editCommandsClass (baseEditCommandsClass):

    '''Contains editing commands with little or no state.'''

    @others
#@+node:ekr.20050929155208: birth
#@+node:ekr.20050920084036.54: ctor (editCommandsClass)
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.ccolumn = '0'   # For comment column functions.
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.sampleWidget = None # Created later.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.w = None # For use by state handlers.

    # Settings...
    self.autocompleteBrackets   = c.config.getBool('autocomplete-brackets')
    self.bracketsFlashBg        = c.config.getColor('flash-brackets-background-color')
    self.bracketsFlashCount     = c.config.getInt('flash-brackets-count')
    self.bracketsFlashDelay     = c.config.getInt('flash-brackets-delay')
    self.bracketsFlashFg        = c.config.getColor('flash-brackets-foreground-color')
    self.flashMatchingBrackets  = c.config.getBool('flash-matching-brackets')
    self.smartAutoIndent        = c.config.getBool('smart_auto_indent')

    self.initBracketMatcher(c)
#@-node:ekr.20050920084036.54: ctor (editCommandsClass)
#@+node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
def getPublicCommands (self):        

    c = self.c

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,
        'add-editor':                           c.frame.body and c.frame.body.addEditor,
        'add-space-to-lines':                   self.addSpaceToLines,
        'add-tab-to-lines':                     self.addTabToLines, 
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'backward-find-character':              self.backwardFindCharacter,
        'backward-find-character-extend-selection': self.backwardFindCharacterExtendSelection,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clean-all-lines':                      self.cleanAllLines,
        'clean-lines':                          self.cleanLines,
        'clear-extend-mode':                    self.clearExtendMode,
        'clear-selected-text':                  self.clearSelectedText,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'cycle-all-focus':                      self.cycleAllFocus,
        'cycle-editor-focus':                   c.frame.body.cycleEditorFocus,
        # 'delete-all-icons':                   self.deleteAllIcons,
        'delete-char':                          self.deleteNextChar,
        'delete-editor':                        c.frame.body.deleteEditor,
        'delete-first-icon':                    self.deleteFirstIcon,
        'delete-indentation':                   self.deleteIndentation,
        'delete-last-icon':                     self.deleteLastIcon,
        'delete-node-icons':                    self.deleteNodeIcons,
        'delete-spaces':                        self.deleteSpaces,
        'do-nothing':                           self.doNothing,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'extend-to-line':                       self.extendToLine,
        'extend-to-paragraph':                  self.extendToParagraph,
        'extend-to-sentence':                   self.extendToSentence,
        'extend-to-word':                       self.extendToWord,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'find-character':                       self.findCharacter,
        'find-character-extend-selection':      self.findCharacterExtendSelection,
        'find-word':                            self.findWord,
        'find-word-in-line':                    self.findWordInLine,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-end-word':                     self.forwardEndWord, # New in Leo 4.4.2.
        'forward-end-word-extend-selection':    self.forwardEndWordExtendSelection, # New in Leo 4.4.2.
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-global-line':                     self.gotoGlobalLine,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-icon':                          self.insertIcon,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-lines-down':                      self.moveLinesDown,
        'move-lines-up':                        self.moveLinesUp,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'remove-space-from-lines':              self.removeSpaceFromLines,
        'remove-tab-from-lines':                self.removeTabFromLines,
        'reverse-region':                       self.reverseRegion,
        'reverse-sort-lines':                   self.reverseSortLines,
        'reverse-sort-lines-ignoring-case':     self.reverseSortLinesIgnoringCase,                 
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-outline-down-line':             self.scrollOutlineDownLine,
        'scroll-outline-down-page':             self.scrollOutlineDownPage,
        'scroll-outline-left':                  self.scrollOutlineLeft,
        'scroll-outline-right':                 self.scrollOutlineRight,
        'scroll-outline-up-line':               self.scrollOutlineUpLine,
        'scroll-outline-up-page':               self.scrollOutlineUpPage,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-all':                           self.selectAllText,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        #'set-mark-command':                    self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'sort-lines-ignoring-case':             self.sortLinesIgnoringCase,
        'split-line':                           self.splitLine,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
#@-node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
#@+node:ekr.20061012113455:doNothing
def doNothing (self,event):

    '''A placeholder command, useful for testing bindings.'''

    # g.trace()
    pass
#@nonl
#@-node:ekr.20061012113455:doNothing
#@-node:ekr.20050929155208: birth
#@+node:ekr.20050920084036.57:capitalization & case
#@+node:ekr.20051015114221:capitalizeWord & up/downCaseWord
def capitalizeWord (self,event):
    '''Capitalize the word at the cursor.'''
    self.capitalizeHelper(event,'cap','capitalize-word')

def downCaseWord (self,event):
    '''Convert all characters of the word at the cursor to lower case.'''
    self.capitalizeHelper(event,'low','downcase-word')

def upCaseWord (self,event):
    '''Convert all characters of the word at the cursor to UPPER CASE.'''
    self.capitalizeHelper(event,'up','upcase-word')
#@-node:ekr.20051015114221:capitalizeWord & up/downCaseWord
#@+node:ekr.20050920084036.145:changePreviousWord (not used)
def changePreviousWord (self,event):

    k = self.k ; stroke = k.stroke
    w = self.editWidget(event)
    if not w: return

    i = w.getInsertPoint()
    self.beginCommand(undoType='change-previous-word')
    self.moveWordHelper(event,extend=False,forward=False)

    if stroke == '<Alt-c>':
        self.capitalizeWord(event)
    elif stroke == '<Alt-u>':
        self.upCaseWord(event)
    elif stroke == '<Alt-l>':
        self.downCaseWord(event)

    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.145:changePreviousWord (not used)
#@+node:ekr.20051015114221.1:capitalizeHelper
def capitalizeHelper (self,event,which,undoType):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getWord(s,ins)
    word = s[i:j]
    # g.trace('word',repr(word))
    if not word.strip(): return

    self.beginCommand(undoType=undoType)

    if   which == 'cap':  word2 = word.capitalize()
    elif which == 'low':  word2 = word.lower()
    elif which == 'up':   word2 = word.upper()
    else: g.trace('can not happen: which = %s' %s (which))

    changed = word != word2
    # g.trace('changed',changed,'word2',repr(word2))

    if changed:
        w.delete(i,j)
        w.insert(i,word2)
        w.setSelectionRange(ins,ins,insert=ins)

    self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20051015114221.1:capitalizeHelper
#@-node:ekr.20050920084036.57:capitalization & case
#@+node:ekr.20051022142249:clicks and focus (editCommandsClass)
#@+node:ekr.20060211100905:activate-x-menu & activateMenu (editCommandsClass)
def activateCmdsMenu    (self,event=None):
    '''Activate Leo's Cmnds menu.'''
    self.activateMenu('Cmds')

def activateEditMenu    (self,event=None):
    '''Activate Leo's Edit menu.'''
    self.activateMenu('Edit')

def activateFileMenu    (self,event=None):
    '''Activate Leo's File menu.'''
    self.activateMenu('File')

def activateHelpMenu    (self,event=None):
    '''Activate Leo's Help menu.'''
    self.activateMenu('Help')

def activateOutlineMenu (self,event=None):
    '''Activate Leo's Outline menu.'''
    self.activateMenu('Outline')

def activatePluginsMenu (self,event=None):
    '''Activate Leo's Plugins menu.'''
    self.activateMenu('Plugins')

def activateWindowMenu  (self,event=None):
    '''Activate Leo's Window menu.'''
    self.activateMenu('Window')

def activateMenu (self,menuName):
    c = self.c
    c.frame.menu.activateMenu(menuName)
#@-node:ekr.20060211100905:activate-x-menu & activateMenu (editCommandsClass)
#@+node:ekr.20051022144825.1:cycleFocus
def cycleFocus (self,event):

    '''Cycle the keyboard focus between Leo's outline, body and log panes.'''

    c = self.c ;  w = event.widget


    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas
    panes = [body,log,tree]

    if w in panes:
        i = panes.index(w) + 1
        if i >= len(panes): i = 0
        pane = panes[i]
    else:
        pane = body

    # Warning: traces mess up the focus
    # print g.app.gui.widget_name(w),g.app.gui.widget_name(pane)

    # This works from the minibuffer *only* if there is no typing completion.
    c.widgetWantsFocusNow(pane)
    c.k.newMinibufferWidget = pane
#@nonl
#@-node:ekr.20051022144825.1:cycleFocus
#@+node:ekr.20060613090701:cycleAllFocus
editWidgetCount = 0
logWidgetCount = 0

def cycleAllFocus (self,event):

    '''Cycle the keyboard focus between Leo's outline,
    all body editors and all tabs in the log pane.'''

    c = self.c ; k = c.k
    w = event and event.widget # Does **not** require a text widget.

    pane = None ; w_name = g.app.gui.widget_name
    trace = False
    if trace: print (
        '---- w',w_name(w),id(w),
        '#tabs',c.frame.log.numberOfVisibleTabs(),
        'bodyCtrl',w_name(c.frame.body.bodyCtrl),id(c.frame.body.bodyCtrl))

    # w may not be the present body widget, so test its name, not its id.
    if w_name(w).startswith('body'):
        n = c.frame.body.numberOfEditors
        # g.trace(self.editWidgetCount,n)
        if n > 1:
            self.editWidgetCount += 1
            if self.editWidgetCount == 1:
                pane = c.frame.body.bodyCtrl
            elif self.editWidgetCount > n:
                self.editWidgetCount = 0 ; self.logWidgetCount = 1
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            else:
                c.frame.body.cycleEditorFocus(event) ; pane = None
        else:
            self.editWidgetCount = 0 ; self.logWidgetCount = 1
            c.frame.log.selectTab('Log')
            pane = c.frame.log.logCtrl
    elif w_name(w).startswith('log'):
        n = c.frame.log.numberOfVisibleTabs()
        if n > 1:
            self.logWidgetCount += 1
            if self.logWidgetCount == 1:
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            elif self.logWidgetCount > n:
                self.logWidgetCount = 0
                pane = c.frame.tree.canvas
            else:
                c.frame.log.cycleTabFocus()
                pane = c.frame.log.logCtrl
        else:
            self.logWidgetCount = 0
            pane = c.frame.tree.canvas
    else:
        pane = c.frame.body.bodyCtrl
        self.editWidgetCount = 1 ; self.logWidgetCount = 0

    if trace: print 'old: %10s new: %10s' % (w_name(w),w_name(pane))

    if pane:
        k.newMinibufferWidget = pane
        c.widgetWantsFocusNow(pane)
#@nonl
#@-node:ekr.20060613090701:cycleAllFocus
#@+node:ekr.20051022144825:focusTo...
def focusToBody (self,event):
    '''Put the keyboard focus in Leo's body pane.'''
    self.c.bodyWantsFocusNow()

def focusToLog (self,event):
    '''Put the keyboard focus in Leo's log pane.'''
    self.c.logWantsFocusNow()

def focusToMinibuffer (self,event):
    '''Put the keyboard focus in Leo's minibuffer.'''
    self.c.minibufferWantsFocusNow()

def focusToTree (self,event):
    '''Put the keyboard focus in Leo's outline pane.'''
    self.c.treeWantsFocusNow()
#@-node:ekr.20051022144825:focusTo...
#@+node:ekr.20060211063744.1:clicks in the headline
# These call the actual event handlers so as to trigger hooks.

def clickHeadline (self,event=None):
    '''Simulate a click in the headline of the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onHeadlineClick(event,p=p)

def doubleClickHeadline (self,event=None):
    '''Simulate a double click in headline of the presently selected node.'''
    return self.clickHeadline(event)

def rightClickHeadline (self,event=None):
    '''Simulate a right click in the headline of the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onHeadlineRightClick(event,p=p)
#@-node:ekr.20060211063744.1:clicks in the headline
#@+node:ekr.20060211055455:clicks in the icon box
# These call the actual event handlers so as to trigger hooks.

def clickIconBox (self,event=None):
    '''Simulate a click in the icon box of the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxClick(event,p=p)

def doubleClickIconBox (self,event=None):
    '''Simulate a double-click in the icon box of the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxDoubleClick(event,p=p)

def rightClickIconBox (self,event=None):

    '''Simulate a right click in the icon box of the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxRightClick(event,p=p)
#@-node:ekr.20060211055455:clicks in the icon box
#@+node:ekr.20060211062025:clickClickBox
# Call the actual event handlers so as to trigger hooks.

def clickClickBox (self,event=None):

    '''Simulate a click in the click box (+- box) of the presently selected node.'''

    c = self.c ; p = c.currentPosition()
    c.frame.tree.onClickBoxClick(event,p=p)
#@-node:ekr.20060211062025:clickClickBox
#@+node:ekr.20060211063744.2:simulate...Drag
# These call the drag setup methods which in turn trigger hooks.

def simulateBeginDrag (self,event=None):

    '''Simulate the start of a drag in the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.startDrag(event,p=p)

def simulateEndDrag (self,event=None):

    '''Simulate the end of a drag in the presently selected node.'''
    c = self.c

    # Note: this assumes that tree.startDrag has already been called.
    c.frame.tree.endDrag(event)
#@-node:ekr.20060211063744.2:simulate...Drag
#@-node:ekr.20051022142249:clicks and focus (editCommandsClass)
#@+node:ekr.20051019183105:color & font
#@+node:ekr.20051019183105.1:show-colors
def showColors (self,event):

    '''Open a tab in the log pane showing various color pickers.'''

    c = self.c ; log = c.frame.log ; tabName = 'Colors'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        log.createColorPicker(tabName)
#@-node:ekr.20051019183105.1:show-colors
#@+node:ekr.20051019201809:editCommands.show-fonts & helpers
def showFonts (self,event):

    '''Open a tab in the log pane showing a font picker.'''

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        log.createFontPicker(tabName)
#@-node:ekr.20051019201809:editCommands.show-fonts & helpers
#@-node:ekr.20051019183105:color & font
#@+node:ekr.20050920084036.132:comment column...
#@+node:ekr.20050920084036.133:setCommentColumn
def setCommentColumn (self,event):

    '''Set the comment column for the indent-to-comment-column command.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,ins)
    self.ccolumn = col
#@nonl
#@-node:ekr.20050920084036.133:setCommentColumn
#@+node:ekr.20050920084036.134:indentToCommentColumn
def indentToCommentColumn (self,event):

    '''Insert whitespace to indent the line containing the insert point to the comment column.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='indent-to-comment-column')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]
    c1 = int(self.ccolumn)
    line2 = ' ' * c1 + line.lstrip()
    if line2 != line:
        w.delete(i,j)
        w.insert(i,line2)
    w.setInsertPoint(i+c1)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.134:indentToCommentColumn
#@-node:ekr.20050920084036.132:comment column...
#@+node:ekr.20050920084036.62:esc methods for Python evaluation
#@+node:ekr.20050920084036.63:watchEscape (Revise)
def watchEscape (self,event):

    k = self.k

    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        # hi1 = k.keysymHistory [0]
        # hi2 = k.keysymHistory [1]
        data1 = leoKeys.keyHandlerClass.lossage[0]
        data2 = leoKeys.keyHandlerClass.lossage[1]
        ch1, stroke1 = data1
        ch2, stroke2 = data2

        if state == 'esc esc' and event.keysym == ':':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        # elif hi1 == hi2 == 'Escape':
        elif stroke1 == 'Escape' and stroke2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif event.keysym not in ('Shift_L','Shift_R'):
            k.keyboardQuit(event)
#@-node:ekr.20050920084036.63:watchEscape (Revise)
#@+node:ekr.20050920084036.64:escEvaluate (Revise)
def escEvaluate (self,event):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if event.keysym == 'Return':
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            w.insert('insert',result)
            ok = True
        finally:
            k.keyboardQuit(event)
            if not ok:
                k.setLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)
#@-node:ekr.20050920084036.64:escEvaluate (Revise)
#@-node:ekr.20050920084036.62:esc methods for Python evaluation
#@+node:ekr.20050920084036.65:evalExpression
def evalExpression (self,event):

    '''Evaluate a Python Expression entered in the minibuffer.'''

    k = self.k ; state = k.getState('eval-expression')

    if state == 0:
        k.setLabelBlue('Eval: ',protect=True)
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -> %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)
#@-node:ekr.20050920084036.65:evalExpression
#@+node:ekr.20050920084036.66:fill column and centering
@
These methods are currently just used in tandem to center the line or region within the fill column.
for example, dependent upon the fill column, this text:

cats
raaaaaaaaaaaats
mats
zaaaaaaaaap

may look like

                                 cats
                           raaaaaaaaaaaats
                                 mats
                             zaaaaaaaaap

after an center-region command via Alt-x.
@c

@others
#@+node:ekr.20050920084036.67:centerLine
def centerLine (self,event):

    '''Centers line within current fill column'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = g.getLine(s,w.getInsertPoint())
    line = s [i:j].strip()
    if not line or len(line) >= self.fillColumn: return

    self.beginCommand(undoType='center-line')
    n = (self.fillColumn-len(line)) / 2
    ws = ' ' * n
    k = g.skip_ws(s,i)
    if k > i: w.delete(i,k-i)
    w.insert(i,ws)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.67:centerLine
#@+node:ekr.20050920084036.68:setFillColumn
def setFillColumn (self,event):

    '''Set the fill column used by the center-line and center-region commands.'''

    k = self.k ; state = k.getState('set-fill-column')

    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()
#@-node:ekr.20050920084036.68:setFillColumn
#@+node:ekr.20050920084036.69:centerRegion
def centerRegion (self,event):

    '''Centers the selected text within the fill column'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1, sel_2 = w.getSelectionRange()
    ind, junk = g.getLine(s,sel_1)
    junk, end = g.getLine(s,sel_2)

    self.beginCommand(undoType='center-region')

    inserted = 0
    while ind < end:
        s = w.getAllText()
        i, j = g.getLine(s,ind)
        line = s [i:j].strip()
        # g.trace(len(line),repr(line))
        if len(line) >= self.fillColumn:
            ind = j
        else:
            n = (self.fillColumn-len(line)) / 2
            inserted += n
            k = g.skip_ws(s,i)
            if k > i: w.delete(i,k-i)
            w.insert(i,' '*n)
            ind = j + n-(k-i)

    w.setSelectionRange(sel_1,sel_2+inserted)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.69:centerRegion
#@+node:ekr.20050920084036.70:setFillPrefix
def setFillPrefix( self, event ):

    '''Make the selected text the fill prefix.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    self.fillPrefix = s[i:j]
#@-node:ekr.20050920084036.70:setFillPrefix
#@+node:ekr.20050920084036.71:_addPrefix
def _addPrefix (self,ntxt):

    ntxt = ntxt.split('.')
    ntxt = map(lambda a: self.fillPrefix+a,ntxt)
    ntxt = '.'.join(ntxt)
    return ntxt
#@-node:ekr.20050920084036.71:_addPrefix
#@-node:ekr.20050920084036.66:fill column and centering
#@+node:ekr.20060417194232:find (quick)
#@+node:ekr.20060925151926:backward/findCharacter & helper
def backwardFindCharacter (self,event):
    return self.findCharacterHelper(event,backward=True,extend=False)

def backwardFindCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=True,extend=True)

def findCharacter (self,event):
    return self.findCharacterHelper(event,backward=False,extend=False)

def findCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=False,extend=True)
#@nonl
#@+node:ekr.20060417194232.1:findCharacterHelper
def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward ; self.extend = extend
        self.insert = w.getInsertPoint()
        s = '%s character%s: ' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' & extend',''))
        k.setLabelBlue(s,protect=True)
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward ; extend = self.extend
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = s.rfind('\n',0,i)
            if start == -1: start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        else:
            end = s.find('\n',i)
            if end == -1: end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.1:findCharacterHelper
#@-node:ekr.20060925151926:backward/findCharacter & helper
#@+node:ekr.20060417194232.2:findWord and FindWordOnLine & helper
def findWord(self,event):

    '''Put the cursor at the next word that starts with a character.'''

    return self.findWordHelper(event,oneLine=True)

def findWordInLine(self,event):

    '''Put the cursor at the next word (on a line) that starts with a character.'''

    return self.findWordHelper(event,oneLine=True)

#@+node:ekr.20080408060320.1:findWordHelper
def findWordHelper (self,event,oneLine):

    k = self.k ; tag = 'find-word' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.oneLineFlag = oneLine
        k.setLabelBlue('Find word %sstarting with: ' % (
            g.choose(oneLine,'in line ','')))
        k.getArg(event,tag,1,self.findWord,oneCharacter=True)
    else:        
        ch = k.arg ; w = self.w ; c = k.c
        if ch:
            i = w.getInsertPoint()
            s = w.getAllText()
            if self.oneLineFlag:
                end = s.find('\n',i) # Limit searches to this line.
                if end == -1: end = len(s)
            else:
                end = len(s)

            while i < end:
                i = s.find(ch,i+1,end) # Ensure progress and i > 0.
                if i == -1:
                    break
                elif not g.isWordChar(s[i-1]):
                    w.setSelectionRange(i,i,insert=i)
                    break

        k.resetLabel()
        k.clearState()
#@-node:ekr.20080408060320.1:findWordHelper
#@-node:ekr.20060417194232.2:findWord and FindWordOnLine & helper
#@-node:ekr.20060417194232:find (quick)
#@+node:ekr.20050920084036.72:goto...
#@+node:ekr.20050929115226:gotoCharacter
def gotoCharacter (self,event):

    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue("Goto n'th character: ")
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.w ; ok = False
        if n.isdigit():
            n = int(n)
            if n >= 0:
                w.setInsertPoint(n)
                w.seeInsertPoint()
                ok = True
        if not ok:
            g.es('goto-char takes non-negative integer argument',color='blue')
        k.resetLabel()
        k.clearState()
#@-node:ekr.20050929115226:gotoCharacter
#@+node:ekr.20060417181052:gotoGlobalLine
def gotoGlobalLine (self,event):

    '''Put the cursor at the n'th line of a file or script.
    This is a minibuffer interface to Leo's legacy Go To Line number command.'''

    k = self.k ; tag = 'goto-global-line' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto global line: ')
        k.getArg(event,tag,1,self.gotoGlobalLine)
    else:
        n = k.arg
        k.resetLabel()
        k.clearState()
        if n.isdigit():
            self.c.goToLineNumber (n=int(n))
#@-node:ekr.20060417181052:gotoGlobalLine
#@+node:ekr.20050929124234:gotoLine
def gotoLine (self,event):

    '''Put the cursor at the n'th line of the buffer.'''

    k = self.k ; state = k.getState('goto-line')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.w
        if n.isdigit():
            s = w.getAllText()
            i = g.convertRowColToPythonIndex(s,n,0)
            w.setInsertPoint(i)
            w.seeInsertPoint()
        k.resetLabel()
        k.clearState()
#@-node:ekr.20050929124234:gotoLine
#@-node:ekr.20050920084036.72:goto...
#@+node:ekr.20071114081313:icons...
@

To do:

- Define standard icons in a subfolder of Icons folder?
- Tree control recomputes height of each line.
#@+node:ekr.20080108092811: Helpers
#@+node:ekr.20080108091349:appendImageDictToList
def appendImageDictToList(self,aList,iconDir,path,xoffset,**kargs):

    c = self.c
    path = g.os_path_abspath(g.os_path_join(iconDir,path))
    relPath = g.makePathRelativeTo(path,iconDir)

    image,image_height = self.getImage(path)
    if not image:
        g.es('can not load image:',path)
        return xoffset

    if image_height is None:
        yoffset = 0
    else:
        yoffset = 0 # (c.frame.tree.line_height-image_height)/2
        # TNB: I suspect this is being done again in the drawing code

    newEntry = {
        'type' : 'file',
        'file' : path,
        'relPath': relPath,
        'where' : 'beforeHeadline',
        'yoffset' : yoffset, 'xoffset' : xoffset, 'xpad' : 1, # -2,
        'on' : 'tnode',
    }
    newEntry.update(kargs)  # may switch 'on' to 'vnode'
    aList.append (newEntry)
    xoffset += 2

    return xoffset
#@-node:ekr.20080108091349:appendImageDictToList
#@+node:tbrown.20080119085249:getIconList
def getIconList(self, p):
    """Return list of icons for position p, call setIconList to apply changes"""

    fromTnode = []
    if hasattr(p.v.t,'unknownAttributes'):
        fromTnode = [dict(i) for i in p.v.t.unknownAttributes.get('icons',[])]
        for i in fromTnode: i['on'] = 'tnode'

    fromVnode = []
    if hasattr(p.v,'unknownAttributes'):
        fromVnode = [dict(i) for i in p.v.unknownAttributes.get('icons',[])]
        for i in fromVnode: i['on'] = 'vnode'

    fromTnode.extend(fromVnode)
    return fromTnode
#@-node:tbrown.20080119085249:getIconList
#@+node:tbrown.20080119085249.1:setIconList
def _setIconListHelper(self, p, subl, uaLoc):
    """icon setting code common between v and t nodes

    p - postion
    subl - list of icons for the v or t node
    uaLoc - the v or t node"""

    # FIXME lineYOffset is expected to be on a tnode in drawing code

    if subl:
        if not hasattr(uaLoc,'unknownAttributes'):
            uaLoc.unknownAttributes = {}
        uaLoc.unknownAttributes['icons'] = list(subl)
        # g.es((p.headString(),uaLoc.unknownAttributes['icons']))
        uaLoc.unknownAttributes["lineYOffset"] = 3
        p.setDirty()
    else:
        if hasattr(uaLoc,'unknownAttributes'):
            if 'icons' in uaLoc.unknownAttributes:
                del uaLoc.unknownAttributes['icons']
                uaLoc.unknownAttributes["lineYOffset"] = 0
                p.setDirty()

def dHash(self, d):
    """Hash a dictionary"""
    l = d.keys()
    l.sort()
    return ''.join(['%s%s' % (str(k),str(d[k])) for k in l])

def setIconList(self, p, l):
    """Set list of icons for position p to l"""

    current = self.getIconList(p)
    if not l and not current: return  # nothing to do
    lHash = ''.join([self.dHash(i) for i in l])
    cHash = ''.join([self.dHash(i) for i in current])
    if lHash == cHash:
        # no difference between original and current list of dictionaries
        return


    subl = [i for i in l if i.get('on') != 'vnode']
    self._setIconListHelper(p, subl, p.v.t)

    subl = [i for i in l if i.get('on') == 'vnode']
    self._setIconListHelper(p, subl, p.v)
#@-node:tbrown.20080119085249.1:setIconList
#@+node:ekr.20071114083142:getImage
def getImage (self,path):

    c = self.c

    try:
        from PIL import Image
    except ImportError:
        Image = None
        g.es('can not import Image module from PIL',color='blue')

    try:
        from PIL import ImageTk
    except ImportError:
        try:
            import ImageTk
        except ImportError:
            ImageTk = None
            g.es('can not import ImageTk module',color='blue')

    try:
        if Image and ImageTk:
            image1 = Image.open(path)
            image = ImageTk.PhotoImage(image1)
        else:
            import Tkinter as Tk
            image = Tk.PhotoImage(master=c.frame.tree.canvas,file=path)
        return image,image.height()
    except Exception:
        return None,None
#@-node:ekr.20071114083142:getImage
#@-node:ekr.20080108092811: Helpers
#@+node:ekr.20071114082418.2:deleteAllIcons (no longer used)
# def deleteAllIcons (self,event=None):

    # c = self.c

    # for p in c.allNodes_iter():

        # if hasattr(p.v.t,"unknownAttributes"):
            # a = p.v.t.unknownAttributes
            # iconsList = a.get("icons")
            # if iconsList:
                # a["icons"] = []
                # a["lineYOffset"] = 0
                # p.setDirty()
                # c.setChanged(True)

    # c.redraw()
#@-node:ekr.20071114082418.2:deleteAllIcons (no longer used)
#@+node:ekr.20071114082418:deleteFirstIcon
def deleteFirstIcon (self,event=None):

    c = self.c ; p = c.currentPosition()

    aList = self.getIconList(p)

    if aList:
        self.setIconList(p, aList[1:])
        c.setChanged(True)
        c.redraw()
#@nonl
#@-node:ekr.20071114082418:deleteFirstIcon
#@+node:ekr.20071114092622:deleteIconByName
def deleteIconByName (self,t,name,relPath):
    """for use by the right-click remove icon callback"""
    c = self.c ; p = c.currentPosition()

    aList = self.getIconList(p)
    if not aList: return

    basePath = g.os_path_abspath(g.os_path_normpath(g.os_path_join(g.app.loadDir,"..","Icons")))
    absRelPath = g.os_path_abspath(g.os_path_normpath(g.os_path_join(basePath,relPath)))
    name = g.os_path_abspath(name)

    newList = []
    for d in aList:
        name2 = d.get('file')
        name2 = g.os_path_abspath(name2)
        name2rel = d.get('relPath')
        # g.trace('name',name,'\nrelPath',relPath,'\nabsRelPath',absRelPath,'\nname2',name2,'\nname2rel',name2rel)
        if not (name == name2 or absRelPath == name2 or relPath == name2rel):
            newList.append(d)

    if len(newList) != len(aList):
        self.setIconList(p, newList)       
        c.setChanged(True)
        c.redraw()
    else:
        g.trace('not found',name)



#@-node:ekr.20071114092622:deleteIconByName
#@+node:ekr.20071114085054:deleteLastIcon
def deleteLastIcon (self,event=None):

    c = self.c ;  p = c.currentPosition()

    c = self.c ; p = c.currentPosition()

    aList = self.getIconList(p)

    if aList:
        self.setIconList(p, aList[:-1])
        c.setChanged(True)
        c.redraw()
#@nonl
#@-node:ekr.20071114085054:deleteLastIcon
#@+node:ekr.20071114082418.1:deleteNodeIcons
def deleteNodeIcons (self,event=None):

    c = self.c ; p = c.currentPosition()

    if hasattr(p.v.t,"unknownAttributes"):
        a = p.v.t.unknownAttributes
        if dict:  # ???
            self.setIconList(p,[])
            a["lineYOffset"] = 0
            p.setDirty()
            c.setChanged(True)
            c.redraw()
#@-node:ekr.20071114082418.1:deleteNodeIcons
#@+node:ekr.20071114081313.1:insertIcon
def insertIcon (self,event=None):

    c = self.c ; p = c.currentPosition()

    iconDir = g.os_path_abspath(g.os_path_normpath(g.os_path_join(g.app.loadDir,"..","Icons")))
    os.chdir(iconDir)

    paths = g.app.gui.runOpenFileDialog(
        title='Get Icons',
        filetypes=[('All files','*'),('Gif','*.gif'), ('Bitmap','*.bmp'),('Icon','*.ico'),],
        defaultextension=None,
        multiple=True)

    if not paths: return

    aList = [] ; xoffset = 2
    for path in paths:
        xoffset = self.appendImageDictToList(aList,iconDir,path,xoffset)

    aList2 = self.getIconList(p)
    aList2.extend(aList)
    self.setIconList(p, aList2)
    c.setChanged(True)
    c.redraw()
#@-node:ekr.20071114081313.1:insertIcon
#@+node:ekr.20080108090719:insertIconFromFile
def insertIconFromFile (self,path,p=None,pos=None,**kargs):

    c = self.c
    if p is None: p = c.currentPosition()

    iconDir = g.os_path_abspath(g.os_path_normpath(g.os_path_join(g.app.loadDir,"..","Icons")))
    os.chdir(iconDir)

    aList = [] ; xoffset = 2
    xoffset = self.appendImageDictToList(aList,iconDir,path,xoffset,**kargs)

    aList2 = self.getIconList(p)
    if pos is None: pos = len(aList2)
    aList2.insert(pos,aList[0])
    self.setIconList(p, aList2)
    c.setChanged(True)
    c.redraw()
#@-node:ekr.20080108090719:insertIconFromFile
#@-node:ekr.20071114081313:icons...
#@+node:ekr.20050920084036.74:indent...
#@+node:ekr.20050920084036.75:backToIndentation
def backToIndentation (self,event):

    '''Position the point at the first non-blank character on the line.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='back-to-indentation')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    while i < j and s[i] in (' \t'):
        i += 1
    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.75:backToIndentation
#@+node:ekr.20050920084036.76:deleteIndentation
def deleteIndentation (self,event):

    '''Delete indentation in the presently line.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return


    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]
    line2 = s[i:j].lstrip()
    delta = len(line) - len(line2)
    if delta:
        self.beginCommand(undoType='delete-indentation')

        w.delete(i,j)
        w.insert(i,line2)
        ins -= delta
        w.setSelectionRange(ins,ins,insert=ins)

        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.76:deleteIndentation
#@+node:ekr.20050920084036.78:indentRelative
def indentRelative (self,event):

    '''The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.

    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.'''

    c = self.c ; undoType = 'indent-relative' ; w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    oldSel = w.getSelectionRange()
    oldYview = w.getYScrollPosition()
    # Find the previous non-blank line
    i,j = g.getLine(s,ins)
    while 1:
        if i <= 0: return
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip(): break
    self.beginCommand(undoType=undoType)
    try:
        k = g.skip_ws(s,i)
        ws = s[i:k]
        i2,j2 = g.getLine(s,ins)
        k = g.skip_ws(s,i2)
        line = ws + s[k:j2]
        w.delete(i2,j2)
        w.insert(i2,line)
        w.setInsertPoint(i2+len(ws))
        c.frame.body.onBodyChanged(undoType,oldSel=oldSel,oldText=s,oldYview=oldYview)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.78:indentRelative
#@-node:ekr.20050920084036.74:indent...
#@+node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20060417171125:addSpace/TabToLines & removeSpace/TabFromLines & helper
def addSpaceToLines (self,event):
    '''Add a space to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=True,undoType='add-space-to-lines')

def addTabToLines (self,event):
    '''Add a tab to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=True,undoType='add-tab-to-lines')

def removeSpaceFromLines (self,event):
    '''Remove a space from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=False,undoType='remove-space-from-lines')

def removeTabFromLines (self,event):
    '''Remove a tab from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=False,undoType='remove-tab-from-lines')
#@+node:ekr.20060417172056:addRemoveHelper
def addRemoveHelper(self,event,ch,add,undoType):

    c = self.c ; k = self.k ; w = self.editWidget(event)
    if not w: return

    if w.hasSelection():s = w.getSelectedText()
    else:               s = w.getAllText()
    if not s: return

    # Insert or delete spaces instead of tabs when negative tab width is in effect.
    d = g.scanDirectives(c) ; width = d.get('tabwidth')
    if ch == '\t' and width < 0: ch = ' ' * abs(width)

    self.beginCommand(undoType=undoType)

    lines = g.splitLines(s)

    if add:
        result = [ch + line for line in lines]
    else:
        result = [g.choose(line.startswith(ch),line[len(ch):],line) for line in lines]

    result = ''.join(result)

    # g.trace('add',add,'hasSelection',w.hasSelection(),'result',repr(result))

    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
        w.insert(i,result)
        w.setSelectionRange(i,i+len(result))
    else:
        w.setAllText(result)
        w.setSelectionRange(0,len(s))

    self.endCommand(changed=True,setLabel=True)

#@-node:ekr.20060417172056:addRemoveHelper
#@-node:ekr.20060417171125:addSpace/TabToLines & removeSpace/TabFromLines & helper
#@+node:ekr.20051026092433.1:backwardDeleteCharacter
def backwardDeleteCharacter (self,event=None):

    '''Delete the character to the left of the cursor.'''

    c = self.c ; p = c.currentPosition()
    w = self.editWidget(event,allowMinibuffer=True)
    if not w: return

    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace(wname,i,j,ins)

    if wname.startswith('body'):
        self.beginCommand()
        try:
            d = g.scanDirectives(c,p)
            tab_width = d.get("tabwidth",c.tab_width)
            changed = True
            if i != j:
                w.delete(i,j)
                w.setSelectionRange(i,i,insert=i)
            elif i == 0:
                changed = False
            elif tab_width > 0:
                w.delete(ins-1)
                w.setSelectionRange(ins-1,ins-1,insert=ins-1)
            else:
                << backspace with negative tab_width >>
        finally:
            self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        # Make sure we actually delete something if we can.
        s = w.getAllText()
        if i != j:
            j = max(i,min(j,len(s)))
            w.delete(i,j)
            w.setSelectionRange(i,i,insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins-1)
            ins = ins-1
            w.setSelectionRange(ins,ins,insert=ins)
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.getAllText()
ins = w.getInsertPoint()
i,j = g.getLine(s,ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
i = ins-(max(1,count))
w.delete(i,ins)
w.setSelectionRange(i,i,insert=i)
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@-node:ekr.20051026092433.1:backwardDeleteCharacter
#@+node:ekr.20070325094935:cleanAllLines
def cleanAllLines (self,event):

    '''Clean all lines in the selected tree.'''

    c = self.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl
    if not w: return

    c.beginUpdate()
    try:
        for p in current.self_and_subtree_iter():
            c.selectPosition(p)
            w.setSelectionRange(0,0,insert=0)
            c.editCommands.cleanLines(event)
        c.selectPosition(current)
    finally:
        c.endUpdate(False)
#@-node:ekr.20070325094935:cleanAllLines
#@+node:ekr.20060415112257:cleanLines
def cleanLines (self,event):

    '''Removes leading whitespace from otherwise blanks lines.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    if w.hasSelection():
        s = w.getSelectedText()
    else:
        s = w.getAllText()

    lines = [] ; changed = False
    for line in g.splitlines(s):
        if line.strip():
            lines.append(line)
        else:
            if line.endswith('\n'):
                lines.append('\n')
            changed = changed or '\n' != line

    if changed:
        self.beginCommand(undoType='clean-lines')
        result = ''.join(lines)
        if w.hasSelection():
            i,j = w.getSelectionRange()
            w.delete(i,j)
            w.insert(i,result)
            w.setSelectionRange(i,j+len(result))
        else:
            w.delete(0,'end')
            w.insert(0,result)
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060415112257:cleanLines
#@+node:ekr.20060414085834:clearSelectedText
def clearSelectedText (self,event):

    '''Delete the selected text.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    i,j = w.getSelectionRange()
    if i == j: return

    self.beginCommand(undoType='clear-selected-text')

    w.delete(i,j)
    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20060414085834:clearSelectedText
#@+node:ekr.20050920084036.87:deleteNextChar
def deleteNextChar (self,event):

    '''Delete the character to the right of the cursor.'''

    c = self.c ; w = self.editWidget(event,allowMinibuffer=True)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()

    self.beginCommand(undoType='delete-char')

    changed = True
    if i != j:
        w.delete(i,j)
        w.setInsertPoint(i)
    elif j < len(s):
        w.delete(i)
        w.setInsertPoint(i)
    else:
        changed = False

    self.endCommand(changed=changed,setLabel=False)
#@-node:ekr.20050920084036.87:deleteNextChar
#@+node:ekr.20050920084036.135:deleteSpaces
def deleteSpaces (self,event,insertspace=False):

    '''Delete all whitespace surrounding the cursor.'''

    c = self.c ; w = self.editWidget(event)
    undoType = g.choose(insertspace,'insert-space','delete-spaces')
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    w1 = ins-1
    while w1 >= i and s[w1].isspace():
        w1 -= 1
    w1 += 1
    w2 = ins
    while w2 <= j and s[w2].isspace():
        w2 += 1
    spaces = s[w1:w2]
    if spaces:
        self.beginCommand(undoType=undoType)
        if insertspace: s = s[:w1] + ' ' + s[w2:]
        else:           s = s[:w1] + s[w2:]
        w.setAllText(s)
        w.setInsertPoint(w1)
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.135:deleteSpaces
#@+node:ekr.20050920084036.138:insertNewLine
def insertNewLine (self,event):

    '''Insert a newline at the cursor.'''

    w = self.editWidget(event)
    if not w: return
    wname = g.app.gui.widget_name(w)
    if wname.startswith('head'): return

    self.beginCommand(undoType='insert-newline')

    i = w.getInsertPoint()
    w.insert(i,'\n')
    w.setInsertPoint(i+1)

    self.endCommand(changed=True,setLabel=False)

insertNewline = insertNewLine
#@-node:ekr.20050920084036.138:insertNewLine
#@+node:ekr.20050920084036.86:insertNewLineAndTab
def insertNewLineAndTab (self,event):

    '''Insert a newline and tab at the cursor.'''

    w = self.editWidget(event)
    if not w: return
    wname = g.app.gui.widget_name(w)
    if wname.startswith('head'): return

    self.beginCommand(undoType='insert-newline-and-indent')

    i = w.getInsertPoint()
    w.insert(i,'\n\t')
    w.setInsertPoint(i+2)

    self.endCommand(changed=True,setLabel=False)
#@-node:ekr.20050920084036.86:insertNewLineAndTab
#@+node:ekr.20050920084036.139:insertParentheses
def insertParentheses (self,event):

    '''Insert () at the cursor.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='insert-parenthesis')

    i = w.getInsertPoint()
    w.insert(i,'()')
    w.setInsertPoint(i+1)

    self.endCommand(changed=True,setLabel=False)
#@-node:ekr.20050920084036.139:insertParentheses
#@+node:ekr.20050920084036.141:removeBlankLines
def removeBlankLines (self,event):

    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''

    c = self.c
    head,lines,tail,oldSel,oldYview = c.getBodyLines()

    changed = False ; result = []
    for line in lines:
        if line.strip():
            result.append(line)
        else:
            changed = True
    result = ''.join(result)

    if changed:
        oldSel = None ; undoType = 'remove-blank-lines'
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@-node:ekr.20050920084036.141:removeBlankLines
#@+node:ekr.20051125080855:selfInsertCommand, helpers
def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    w = self.editWidget(event)
    if not w: return 'break'
    << set local vars >>
    #g.trace('ch',repr(ch))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:

            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    # g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@+node:ekr.20061103114242:<< set local vars >>
c = self.c
p = c.currentPosition()
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if keysym == 'Tab': # Support for wx_alt_gui plugin.
    ch = '\t'
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.bodyString() or ''
undoType = 'Typing'
trace = c.config.getBool('trace_masterCommand')
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch,g.app.tkEncoding) in brackets
if trace: g.trace(name,repr(ch),ch and ch in brackets)
#@nonl
#@-node:ekr.20061103114242:<< set local vars >>
#@+node:ekr.20051026171121:insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.currentPosition()
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
        if (
            (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
            undoType != "Change"
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
#@nonl
#@-node:ekr.20051026171121:insertNewlineHelper
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'

    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = g.scanDirectives(c,p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.scanColorDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c
    d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.

    if i != j:
        w.delete(i,j)

    if tab_width > 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        # Get the preceeding characters.
        s = w.getAllText()
        start = g.skip_to_start_of_line(s,i)
        s2 = s[start:i]

        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s2,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        # g.trace('n',n)
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand, helpers
#@-node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20050920084036.79:info...
#@+node:ekr.20050920084036.80:howMany
def howMany (self,event):

    '''Print how many occurances of a regular expression are found
    in the body text of the presently selected node.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    state = k.getState('how-many')
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.getAllText()
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
#@-node:ekr.20050920084036.80:howMany
#@+node:ekr.20050920084036.81:lineNumber
def lineNumber (self,event):

    '''Print the line and column number and percentage of insert point.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,i)
    percent = int((i*100)/len(s))

    k.setLabelGrey(
        'char: %s row: %d col: %d pos: %d (%d%% of %d)' % (
            repr(s[i]),row,col,i,percent,len(s)))
#@-node:ekr.20050920084036.81:lineNumber
#@+node:ekr.20050920084036.83:viewLossage
def viewLossage (self,event):

    '''Put the Emacs-lossage in the minibuffer label.'''

    k = self.k

    g.es('lossage...')
    aList = leoKeys.keyHandlerClass.lossage
    aList.reverse()
    for data in aList:
        ch,stroke = data
        d = {' ':'Space','\t':'Tab','\b':'Backspace','\n':'Newline','\r':'Return'}
        g.es('',stroke or d.get(ch) or ch or 'None')
#@-node:ekr.20050920084036.83:viewLossage
#@+node:ekr.20050920084036.84:whatLine
def whatLine (self,event):

    '''Print the line number of the line containing the cursor.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,i)

    k.keyboardQuit(event)
    k.setLabel("Line %s" % row)
#@-node:ekr.20050920084036.84:whatLine
#@-node:ekr.20050920084036.79:info...
#@+node:ekr.20050920084036.88:line...
#@+node:ekr.20050920084036.90:flushLines
def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')

    if state == 0:
        k.setLabelBlue('Flush lines regexp: ',protect=True)
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg
#@-node:ekr.20050920084036.90:flushLines
#@+node:ekr.20051002095724:keepLines
def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')

    if state == 0:
        k.setLabelBlue('Keep lines regexp: ',protect=True)
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg
#@-node:ekr.20051002095724:keepLines
#@+node:ekr.20050920084036.92:linesHelper
def linesHelper (self,event,pattern,which):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType=which+'-lines')
    if w.hasSelection():
        i,end = w.getSelectionRange()
    else:
        i = w.getInsertPoint()
        end = 'end'
    txt = w.get(i,end)
    tlines = txt.splitlines(True)
    if which == 'flush':    keeplines = list(tlines)
    else:                   keeplines = []

    try:
        regex = re.compile(pattern)
        for n, z in enumerate(tlines):
            f = regex.findall(z)
            if which == 'flush' and f:
                keeplines [n] = None
            elif f:
                keeplines.append(z)
    except Exception, x:
        return
    if which == 'flush':
        keeplines = [x for x in keeplines if x != None]
    w.delete(i,end)
    w.insert(i,''.join(keeplines))
    w.setInsertPoint(i)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.92:linesHelper
#@+node:ekr.20050920084036.77:splitLine
def splitLine (self,event):

    '''Split a line at the cursor position.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='split-line')

    s = w.getAllText()
    ins = w.getInsertPoint()
    w.setAllText(s[:ins] + '\n' + s[ins:])
    w.setInsertPoint(ins+1)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.77:splitLine
#@-node:ekr.20050920084036.88:line...
#@+node:ekr.20050929114218:move cursor... (leoEditCommands)
#@+node:ekr.20051218170358: helpers
#@+node:ekr.20060113130510:extendHelper
def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    extend = extend or self.extendMode

    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace('extend',extend,'ins',ins,'sel=',i,j,'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v.t != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if True: #### j2 < len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot < self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)

    w.seeInsertPoint()
    c.frame.updateStatusLine()
#@-node:ekr.20060113130510:extendHelper
#@+node:ekr.20060113105246.1:moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return
    trace = False

    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()

    # Find the start of the next/prev line.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    if trace: g.trace('ins',ins,'row',row,'col',col)
    i,j = g.getLine(s,ins)
    if direction == 'down':
        i2,j2 = g.getLine(s,j)
    else:
        i2,j2 = g.getLine(s,i-1)

    # The spot is the start of the line plus the column index.
    n = max(0,j2-i2-1) # The length of the new line.
    col2 = min(col,n)
    spot = i2 + col2
    if trace: g.trace('spot',spot,'n',n,'col',col,'line',repr(s[i2:j2]))

    self.extendHelper(w,extend,spot,upOrDown=True)
#@nonl
#@-node:ekr.20060113105246.1:moveUpOrDownHelper
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend,allowMinibuffer=False):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event,allowMinibuffer=allowMinibuffer)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20051218171457:movePastCloseHelper
def movePastCloseHelper (self,event,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Scan backwards for i,j.
    i = ins
    while i >= 0 and s[i] != '\n':
        if s[i] == '(': break
        i -= 1
    else: return
    j = ins
    while j >= 0 and s[j] != '\n':
        if s[j] == '(': break
        j -= 1
    if i < j: return
    # Scan forward for i2,j2.
    i2 = ins
    while i2 < len(s) and s[i2] != '\n':
        if s[i2] == ')': break
        i2 += 1
    else: return
    j2 = ins
    while j2 < len(s) and s[j2] != '\n':
        if s[j2] == ')': break
        j2 += 1
    if i2 > j2: return

    self.moveToHelper(event,i2+1,extend)
#@-node:ekr.20051218171457:movePastCloseHelper
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 <= i < n and not g.isWordChar(s[i]):
            i -= 1
        while 0 <= i < n and g.isWordChar(s[i]):
            i -= 1
        i += 1

    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20051213094517:backSentenceHelper
def backSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    i = w.getInsertPoint()

    while i >= 0:
        if s[i] == '.': break
        i -= 1
    else: return

    j = i-1
    while j >= 0:
        if s[j] == '.':
            j += 1 ; break
        j -= 1
    else: j = 0

    while j < i and s[j].isspace():
        j += 1

    if j < i:
        self.moveToHelper(event,j,extend)
#@-node:ekr.20051213094517:backSentenceHelper
#@+node:ekr.20050920084036.137:forwardSentenceHelper
def forwardSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins) + 1
    i = min(i,len(s))
    self.moveToHelper(event,i,extend)
#@-node:ekr.20050920084036.137:forwardSentenceHelper
#@+node:ekr.20051218133207.1:forwardParagraphHelper
def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1

    # Skip to the next non-blank line.
    i = j
    while j < len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
#@-node:ekr.20051218133207.1:forwardParagraphHelper
#@+node:ekr.20051218133207:backwardParagraphHelper
def backwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    # A hack for wx gui: set the insertion point to the end of the selection range.
    if g.app.unitTesting:
        w.setInsertPoint(j)
    i,j = g.getLine(s,j)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i > 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i > 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218133207:backwardParagraphHelper
#@+node:ekr.20060209095101:setMoveCol
def setMoveCol (self,w,spot):

    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.currentPosition()
    s = w.getAllText()
    i = w.toPythonIndex(spot)
    junk,col = g.convertPythonIndexToRowCol(s,i)
    # g.trace('spot,i,col',spot,i,col)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v.t
#@nonl
#@-node:ekr.20060209095101:setMoveCol
#@-node:ekr.20051218170358: helpers
#@+node:ekr.20050920084036.148:buffers
def beginningOfBuffer (self,event):
    '''Move the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=False)

def beginningOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=True)

def endOfBuffer (self,event):
    '''Move the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=False)

def endOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=True)
#@-node:ekr.20050920084036.148:buffers
#@+node:ekr.20051213080533:characters
def backCharacter (self,event):
    '''Move the cursor back one character, extending the selection if in extend mode.'''
    w = self.editWidget(event,allowMinibuffer=True)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=False,allowMinibuffer=True)

def backCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one character.'''
    w = self.editWidget(event,allowMinibuffer=True)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=True,allowMinibuffer=True)

def forwardCharacter (self,event):
    '''Move the cursor forward one character, extending the selection if in extend mode.'''
    w = self.editWidget(event,allowMinibuffer=True)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=False,allowMinibuffer=True)

def forwardCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one character.'''
    w = self.editWidget(event,allowMinibuffer=True)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=True,allowMinibuffer=True)
#@-node:ekr.20051213080533:characters
#@+node:ekr.20051218174113:clear/set/ToggleExtendMode
def clearExtendMode (self,event):
    '''Turn off extend mode: cursor movement commands do not extend the selection.'''
    self.extendModeHelper(event,False)

def setExtendMode (self,event):
    '''Turn on extend mode: cursor movement commands do extend the selection.'''
    self.extendModeHelper(event,True)

def toggleExtendMode (self,event):
    '''Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections.'''
    self.extendModeHelper(event,not self.extendMode)

def extendModeHelper (self,event,val):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    self.extendMode = val
    g.es('extend mode',g.choose(val,'on','off'),color='red')
    c.widgetWantsFocusNow(w)
#@-node:ekr.20051218174113:clear/set/ToggleExtendMode
#@+node:ekr.20050920084036.136:exchangePointMark
def exchangePointMark (self,event):

    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange(sort=False)
    if i == j: return

    ins = w.getInsertPoint()
    ins = g.choose(ins==i,j,i)
    w.setInsertPoint(ins)
    w.setSelectionRange(i,j,insert=None)
#@-node:ekr.20050920084036.136:exchangePointMark
#@+node:ekr.20061007082956:extend-to-line
def extendToLine (self,event):

    '''Select the line at the cursor.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 <= i < n and not s[i] == '\n':
        i -= 1
    i += 1 ; i1 = i
    while 0 <= i < n and not s[i] == '\n':
        i += 1

    w.setSelectionRange(i1,i)
#@-node:ekr.20061007082956:extend-to-line
#@+node:ekr.20061007214835.4:extend-to-sentence
def extendToSentence (self,event):

    '''Select the line at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    i2 = 1 + s.find('.',i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.',0,i2-1)

    w.setSelectionRange(i1,i2)
#@nonl
#@-node:ekr.20061007214835.4:extend-to-sentence
#@+node:ekr.20060116074839.2:extend-to-word
def extendToWord (self,event):

    '''Select the word at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 <= i < n and not g.isWordChar(s[i]):
        i -= 1
    while 0 <= i < n and g.isWordChar(s[i]):
        i -= 1
    i += 1

    # Move to the end of the word.
    i1 = i
    while 0 <= i < n and g.isWordChar(s[i]):
        i += 1

    w.setSelectionRange(i1,i)
#@nonl
#@-node:ekr.20060116074839.2:extend-to-word
#@+node:ekr.20051218141237:lines
def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event,allowMinibuffer=True)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=False,allowMinibuffer=True)

def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    w = self.editWidget(event,allowMinibuffer=True)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=True,allowMinibuffer=True)

def endOfLine (self,event): # passed
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event,allowMinibuffer=True)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=False,allowMinibuffer=True)

def endOfLineExtendSelection (self,event): # passed
    '''Extend the selection by moving the cursor to the end of the line.'''
    w = self.editWidget(event,allowMinibuffer=True)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=True,allowMinibuffer=True)

def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)

def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)

def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)

def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
#@-node:ekr.20051218141237:lines
#@+node:ekr.20050920084036.140:movePastClose
def movePastClose (self,event):
    '''Move the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=False)

def movePastCloseExtendSelection (self,event):
    '''Extend the selection by moving the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=True)
#@-node:ekr.20050920084036.140:movePastClose
#@+node:ekr.20050920084036.102:paragraphs
def backwardParagraph (self,event):
    '''Move the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=False)

def backwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=True)

def forwardParagraph (self,event):
    '''Move the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=False)

def forwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=True)
#@-node:ekr.20050920084036.102:paragraphs
#@+node:ekr.20050920084036.131:sentences
def backSentence (self,event):
    '''Move the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=False)

def backSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=True)

def forwardSentence (self,event):
    '''Move the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=False)

def forwardSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=True)
#@-node:ekr.20050920084036.131:sentences
#@+node:ekr.20050920084036.149:words
def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)

def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)

def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)

def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)

def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
#@-node:ekr.20050920084036.149:words
#@-node:ekr.20050929114218:move cursor... (leoEditCommands)
#@+node:ekr.20050920084036.95:paragraph...
@others
#@+node:ekr.20050920084036.99:backwardKillParagraph
def backwardKillParagraph (self,event):

    '''Kill the previous paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='backward-kill-paragraph')
    try:
        self.backwardParagraphHelper(event,extend=True)
        i,j = w.getSelectionRange()
        if i > 0: i = min(i+1,j)
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.99:backwardKillParagraph
#@+node:ekr.20050920084036.100:fillRegion
def fillRegion (self,event):

    '''Fill all paragraphs in the selected text.'''

    # New in Leo 4.4.4: just use reformat-paragraph logic.

    c = self.c ; p = c.currentPosition() ; undoType = 'fill-region'
    w = self.editWidget(event)
    i,j = w.getSelectionRange()
    c.undoer.beforeChangeGroup(p,undoType)
    while 1:
        self.c.reformatParagraph(event,undoType='reformat-paragraph')
        ins = w.getInsertPoint()
        s = w.getAllText()
        if ins >= j or ins >= len(s):
            break
    c.undoer.afterChangeGroup(p,undoType)
#@-node:ekr.20050920084036.100:fillRegion
#@+node:ekr.20050920084036.104:fillRegionAsParagraph
def fillRegionAsParagraph (self,event):

    '''Fill the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='fill-region-as-paragraph')

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.104:fillRegionAsParagraph
#@+node:ekr.20050920084036.103:fillParagraph
def fillParagraph( self, event ):

    '''Fill the selected paragraph'''

    w = self.editWidget(event)
    if not w: return

    # Clear the selection range.
    i,j = w.getSelectionRange()
    w.setSelectionRange(i,i,insert=i)

    self.c.reformatParagraph(event)
#@-node:ekr.20050920084036.103:fillParagraph
#@+node:ekr.20050920084036.98:killParagraph
def killParagraph (self,event):

    '''Kill the present paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='kill-paragraph')
    try:
        self.extendToParagraph(event)
        i,j = w.getSelectionRange()
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.98:killParagraph
#@+node:ekr.20050920084036.96:extend-to-paragraph & helper
def extendToParagraph (self,event):

    '''Select the paragraph surrounding the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText() ; ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    # Find the start of the paragraph.
    if line.strip(): # Search backward.
        while i > 0:
            i2,j2 = g.getLine(s,i-1)
            line = s[i2:j2]
            if line.strip(): i = i2
            else: break # Use the previous line.
    else: # Search forward.
        while j < len(s):
            i,j = g.getLine(s,j)
            line = s[i:j]
            if line.strip(): break
        else: return

    # Select from i to the end of the paragraph.
    self.selectParagraphHelper(w,i)
#@+node:ekr.20050920084036.97:selectParagraphHelper
def selectParagraphHelper (self,w,start):

    '''Select from start to the end of the paragraph.'''

    s = w.getAllText()
    i1,j = g.getLine(s,start)
    while j < len(s):
        i,j2 = g.getLine(s,j)
        line = s[i:j2]
        if line.strip(): j = j2
        else: break

    j = max(start,j-1)
    w.setSelectionRange(i1,j,insert=j)
#@-node:ekr.20050920084036.97:selectParagraphHelper
#@-node:ekr.20050920084036.96:extend-to-paragraph & helper
#@-node:ekr.20050920084036.95:paragraph...
#@+node:ekr.20050920084036.105:region...
@others
#@+node:ekr.20050920084036.108:tabIndentRegion (indent-rigidly)
def tabIndentRegion (self,event):

    '''Insert a hard tab at the start of each line of the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='indent-rigidly')

    s = w.getAllText()
    i1,j1 = w.getSelectionRange()
    i,junk = g.getLine(s,i1)
    junk,j = g.getLine(s,j1)

    lines = g.splitlines(s[i:j])
    n = len(lines)
    lines = g.joinLines(['\t' + line for line in lines])
    s = s[:i] + lines + s[j:]
    w.setAllText(s)

    # Retain original row/col selection.
    w.setSelectionRange(i1,j1+n,insert=j1+n)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.108:tabIndentRegion (indent-rigidly)
#@+node:ekr.20050920084036.109:countRegion
def countRegion (self,event):

    '''Print the number of lines and characters in the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    txt = w.getSelectedText()
    lines = 1 ; chars = 0
    for z in txt:
        if z == '\n': lines += 1
        else:         chars += 1

    k.setLabelGrey('Region has %s lines, %s character%s' % (
        lines,chars,g.choose(chars==1,'','s')))
#@-node:ekr.20050920084036.109:countRegion
#@+node:ekr.20060417183606:moveLinesDown
def moveLinesDown (self,event):

    '''Move all lines containing any selected text down one line,
    moving to the next node if the lines are the last lines of the body.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-down')
    changed = False
    try:
        if j < len(s):
            next_i,next_j = g.getLine(s,j+1)
            next_line = s[next_i:next_j]
            n2 = next_j-next_i
            w.delete(i,next_j)
            w.insert(i,next_line+lines)
            w.setSelectionRange(i+n2,i+n2+n,insert=i+n2+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadNext(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadNext()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            s = w.getAllText()
            w.insert(0,lines)
            if not lines.endswith('\n'): w.insert(len(lines),'\n')
            s = w.getAllText()
            w.setSelectionRange(0,n,insert=n)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060417183606:moveLinesDown
#@+node:ekr.20060417183606.1:moveLinesUp
def moveLinesUp (self,event):

    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-up')
    changed = False
    try:
        if i > 0:
            prev_i,prev_j = g.getLine(s,i-1)
            prev_line = s[prev_i:prev_j]
            w.delete(prev_i,j)
            w.insert(prev_i,lines+prev_line)
            w.setSelectionRange(prev_i,prev_i+n,insert=prev_i+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadBack(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadBack()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            s = w.getAllText()
            if not s.endswith('\n'): w.insert('end','\n')
            w.insert('end',lines)
            s = w.getAllText()
            ins = len(s)-len(lines)+n
            w.setSelectionRange(len(s)-len(lines),ins,insert=ins)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060417183606.1:moveLinesUp
#@+node:ekr.20050920084036.110:reverseRegion
def reverseRegion (self,event):

    '''Reverse the order of lines in the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='reverse-region')

    s = w.getAllText()
    i1,j1 = w.getSelectionRange()
    i,junk = g.getLine(s,i1)
    junk,j = g.getLine(s,j1)

    txt = s[i:j]
    aList = txt.split('\n')
    aList.reverse()
    txt = '\n'.join(aList) + '\n'

    w.setAllText(s[:i1] + txt + s[j1:])
    ins = i1 + len(txt) - 1
    w.setSelectionRange(ins,ins,insert=ins)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.110:reverseRegion
#@+node:ekr.20050920084036.111:up/downCaseRegion & helper
def downCaseRegion (self,event):
    '''Convert all characters in the selected text to lower case.'''
    self.caseHelper(event,'low','downcase-region')

def upCaseRegion (self,event):
    '''Convert all characters in the selected text to UPPER CASE.'''
    self.caseHelper(event,'up','upcase-region')

def caseHelper (self,event,way,undoType):

    w = self.editWidget(event)
    if not w or not w.hasSelection(): return

    self.beginCommand(undoType=undoType)

    s = w.getAllText()
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    sel = g.choose(way=='low',s[i:j].lower(),s[i:j].upper())
    s2 = s[:i] + sel + s[j:]
    # g.trace('sel',repr(sel),'s2',repr(s2))
    changed = s2 != s
    if changed:
        w.setAllText(s2)
        w.setSelectionRange(i,j,insert=ins)

    self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20050920084036.111:up/downCaseRegion & helper
#@-node:ekr.20050920084036.105:region...
#@+node:ekr.20060309060654:scrolling...
#@+node:ekr.20050920084036.116:scrollUp/Down/extendSelection
def scrollDown (self,event):
    '''Scroll the presently selected pane down one page.'''
    self.scrollHelper(event,'down',extend=False)

def scrollDownExtendSelection (self,event):
    '''Extend the text selection by scrolling the body text down one page.'''
    self.scrollHelper(event,'down',extend=True)

def scrollUp (self,event):
    '''Scroll the presently selected pane up one page.'''
    self.scrollHelper(event,'up',extend=False)

def scrollUpExtendSelection (self,event):
    '''Extend the text selection by scrolling the body text up one page.'''
    self.scrollHelper(event,'up',extend=True)
#@+node:ekr.20060113082917:scrollHelper
def scrollHelper (self,event,direction,extend):

    k = self.k ; c = k.c ; gui = g.app.gui
    w = gui.eventWidget(event)
    if not w: return #  This does **not** require a text widget.

    if gui.isTextWidget(w):
        c.widgetWantsFocusNow(w)
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.getInsertPoint()
        s = w.getAllText()
        row,col = g.convertPythonIndexToRowCol(s,ins1)
        # Compute the spot.
        delta = self.measure(w)
        row1 = g.choose(direction=='down',row+delta,row-delta)
        row1 = max(0,row1)
        spot = g.convertRowColToPythonIndex(s,row1,col)
        # g.trace('spot',spot,'row1',row1)
        self.extendHelper(w,extend,spot)
        w.seeInsertPoint()
    elif gui.widget_name(w).startswith('canvas'):
        if direction=='down':
            self.scrollOutlineDownPage()
        else:
            self.scrollOutlineUpPage()
#@-node:ekr.20060113082917:scrollHelper
#@+node:ekr.20050920084036.147:measure
def measure (self,w):

    s = w.getAllText()
    ins = w.getInsertPoint()
    start, junk = g.convertPythonIndexToRowCol(s,ins)
    start += 1 ; delta = 0

    ustart = start - 1
    while ustart >= 1 and w.indexIsVisible('%s.0' % ustart):
        delta += 1 ; ustart -= 1

    ustart = start + 1
    while w.indexIsVisible('%s.0' % ustart):
        delta += 1 ; ustart += 1

    return delta
#@-node:ekr.20050920084036.147:measure
#@-node:ekr.20050920084036.116:scrollUp/Down/extendSelection
#@+node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
def scrollOutlineDownLine (self,event=None):
    '''Scroll the outline pane down one line.'''
    a,b = self.c.frame.canvas.leo_treeBar.get()
    if b < 1.0:
        self.c.frame.tree.canvas.yview_scroll(1,"unit")

def scrollOutlineDownPage (self,event=None):
    '''Scroll the outline pane down one page.'''
    a,b = self.c.frame.canvas.leo_treeBar.get()
    if b < 1.0:
        self.c.frame.tree.canvas.yview_scroll(1,"page")

def scrollOutlineUpLine (self,event=None):
    '''Scroll the outline pane up one line.'''
    a,b = self.c.frame.canvas.leo_treeBar.get()
    if a > 0.0:
        self.c.frame.tree.canvas.yview_scroll(-1,"unit")

def scrollOutlineUpPage (self,event=None):
    '''Scroll the outline pane up one page.'''
    a,b = self.c.frame.canvas.leo_treeBar.get()
    if a > 0.0:
        self.c.frame.tree.canvas.yview_scroll(-1,"page")
#@-node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
#@+node:ekr.20060726154531:scrollOutlineLeftRight
def scrollOutlineLeft (self,event=None):
    '''Scroll the outline left.'''
    self.c.frame.tree.canvas.xview_scroll(1,"unit")

def scrollOutlineRight (self,event=None):
    '''Scroll the outline left.'''
    self.c.frame.tree.canvas.xview_scroll(-1,"unit")
#@-node:ekr.20060726154531:scrollOutlineLeftRight
#@-node:ekr.20060309060654:scrolling...
#@+node:ekr.20050920084036.117:sort...
@nocolor
@color
@
XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

#@+node:ekr.20050920084036.118:sortLines commands
def reverseSortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True,reverse=True)

def reverseSortLines(self,event):
    return self.sortLines(event,reverse=True)

def sortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True)

def sortLines (self,event,ignoreCase=False,reverse=False):

    '''Sort lines of the selected text by comparing the entire text of a line.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not self._chckSel(event): return

    undoType = g.choose(reverse,'reverse-sort-lines','sort-lines')
    self.beginCommand(undoType=undoType)
    try:
        s = w.getAllText()
        sel_1,sel_2 = w.getSelectionRange()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        s2 = s[i:j]
        if not s2.endswith('\n'): s2 = s2+'\n'
        aList = g.splitLines(s2)
        if ignoreCase:  aList.sort(key=string.lower)
        else:           aList.sort()
        if reverse:     aList.reverse()
        s = g.joinLines(aList)
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_2,insert=ins)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.118:sortLines commands
#@+node:ekr.20050920084036.119:sortColumns
def sortColumns (self,event):

    '''Sort lines of selected text using only lines in the given columns to do the comparison.'''

    k = self.k
    w = self.editWidget(event)
    if not self._chckSel(event): return
    self.beginCommand(undoType='sort-columns')
    try:
        s = w.getAllText()
        ins = w.getInsertPoint()
        sel_1,sel_2 = w.getSelectionRange()
        sint1,sint2 = g.convertPythonIndexToRowCol(s,sel_1)
        sint3,sint4 = g.convertPythonIndexToRowCol(s,sel_2)
        sint1 += 1 ; sint3 += 1
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        txt = s[i:j]
        columns = [w.get('%s.%s' % (z,sint2),'%s.%s' % (z,sint4))
            for z in xrange(sint1,sint3+1)]
        aList = g.splitLines(txt)
        zlist = zip(columns,aList)
        zlist.sort()
        s = g.joinLines([z[1] for z in zlist])
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_1+len(s),insert=sel_1+len(s))
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.119:sortColumns
#@+node:ekr.20050920084036.120:sortFields
def sortFields (self,event,which=None):

    '''Divide the selected text into lines and sort by comparing the contents of
     one field in each line. Fields are defined as separated by whitespace, so
     the first run of consecutive non-whitespace characters in a line
     constitutes field 1, the second such run constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to sort by
     field 1, etc. A negative argument means sort in descending order. Thus,
     minus 2 means sort by field 2 in reverse-alphabetical order.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-fields')

    s = w.getAllText()
    ins = w.getInsertPoint()
    r1,r2,r3,r4 = self.getRectanglePoints(w)
    i,junk = g.getLine(s,r1)
    junk,j = g.getLine(s,r4)
    txt = s[i:j] # bug reported by pychecker.
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for line in txt:
        f = frx.findall(line)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) < i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    #w.delete('%s linestart' % is1,'%s lineend' % is2)
    w.delete(i,j)
    #i = is1.split('.')
    #int1 = int(i[0])
    int1 = i
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.setInsertPoint(ins)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.120:sortFields
#@-node:ekr.20050920084036.117:sort...
#@+node:ekr.20050920084036.121:swap/transpose...
#@+node:ekr.20060529184652:swapHelper
def swapHelper (self,w,find,ftext,lind,ltext):

    w.delete(find,'%s wordend' % find)
    w.insert(find,ltext)
    w.delete(lind,'%s wordend' % lind)
    w.insert(lind,ftext)
    self.swapSpots.pop()
    self.swapSpots.pop()
#@-node:ekr.20060529184652:swapHelper
#@+node:ekr.20050920084036.122:transposeLines
def transposeLines (self,event):

    '''Transpose the line containing the cursor with the preceding line.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    ins = w.getInsertPoint()
    s = w.getAllText()
    if not s.strip(): return

    i,j = g.getLine(s,ins)
    line1 = s[i:j]

    self.beginCommand(undoType='transpose-lines')

    if i == 0: # Transpose the next line.
        i2,j2 = g.getLine(s,j+1)
        line2 = s[i2:j2]
        w.delete(0,j2)
        w.insert(0,line2+line1)
        w.setInsertPoint(j2-1)
    else: # Transpose the previous line.
        i2,j2 = g.getLine(s,i-1)
        line2 = s[i2:j2]
        w.delete(i2,j)
        w.insert(i2,line1+line2)
        w.setInsertPoint(j-1)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.122:transposeLines
#@+node:ekr.20050920084036.123:swapWords
def swapWords (self,event,swapspots):

    '''Transpose the word at the cursor with the preceding word.'''

    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('swap-words command not ready yet',color='blue')

    s = w.getAllText()

    txt = w.get('insert wordstart','insert wordend') ###
    if not txt: return

    i = w.index('insert wordstart') ###

    self.beginCommand(undoType='swap-words')

    if len(swapspots):
        if i > swapspots[1]:
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif i < swapspots[1]:
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.123:swapWords
#@+node:ekr.20060529184652.1:transposeWords (doesn't work)
def transposeWords (self,event):

    '''Transpose the word at the cursor with the preceding word.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='transpose-words')
    self.swapWords(event,self.swapSpots)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20060529184652.1:transposeWords (doesn't work)
#@+node:ekr.20050920084036.124:swapCharacters & transeposeCharacters
def swapCharacters (self,event):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='swap-characters')

    s = w.getAllText()
    i = w.getInsertPoint()
    if 0 < i < len(s):
        w.setAllText(s[:i-1] + s[i] + s[i-1] + s[i+1:])
        w.setSelectionRange(i,i,insert=i)

    self.endCommand(changed=True,setLabel=True)

transposeCharacters = swapCharacters
#@-node:ekr.20050920084036.124:swapCharacters & transeposeCharacters
#@-node:ekr.20050920084036.121:swap/transpose...
#@+node:ekr.20050920084036.126:tabify & untabify
def tabify (self,event):
    '''Convert 4 spaces to tabs in the selected text.'''
    self.tabifyHelper (event,which='tabify')

def untabify (self,event):
    '''Convert tabs to 4 spaces in the selected text.'''
    self.tabifyHelper (event,which='untabify')

def tabifyHelper (self,event,which):

    k = self.k ; w = self.editWidget(event)
    if not w or not w.hasSelection(): return

    self.beginCommand(undoType=which)

    i,end = w.getSelectionRange()
    txt = w.getSelectedText()
    if which == 'tabify':
        pattern = re.compile(' {4,4}') # Huh?
        ntxt = pattern.sub('\t',txt)
    else:
        pattern = re.compile('\t')
        ntxt = pattern.sub('    ',txt)
    w.delete(i,end)
    w.insert(i,ntxt)
    n = i + len(ntxt)
    w.setSelectionRange(n,n,insert=n)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.126:tabify & untabify
#@+node:ekr.20061111223516:selectAllText (leoEditCommands)
def selectAllText (self,event):

    c = self.c 
    w = self.editWidget(event,allowMinibuffer=True) or g.app.gui.eventWidget(event) or c.frame.body.bodyCtrl
    if w == c.frame.miniBufferWidget:
        c.k.selectAll()
    else:
        return w.selectAllText()
#@-node:ekr.20061111223516:selectAllText (leoEditCommands)
#@-node:ekr.20050920084036.53:editCommandsClass
#@-node:ekr.20080408060320.795:Classes
#@clone 2
#@+node:ekr.20061007105001:editWidget
def editWidget (self,event,allowMinibuffer=False):

    c = self.c ; w = event and event.widget

    if w and g.app.gui.isTextWidget(w) and (
        allowMinibuffer or
        w != c.frame.miniBufferWidget
    ):
        self.w = w
    else:
        self.w = self.c.frame.body and self.c.frame.body.bodyCtrl

    if self.w:
        c.widgetWantsFocusNow(self.w)

    return self.w
#@nonl
#@-node:ekr.20061007105001:editWidget
#@+node:ekr.20061031131434.128:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer and k.useTextWidget: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or stroke in k.getArgEscapes:
        if stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20061031131434.129:<< init altX vars >>
#@-node:ekr.20061031131434.128:getArg
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend,allowMinibuffer=False):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event,allowMinibuffer=allowMinibuffer)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20060113130510:extendHelper
def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    extend = extend or self.extendMode

    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace('extend',extend,'ins',ins,'sel=',i,j,'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v.t != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if True: #### j2 < len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot < self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)

    w.seeInsertPoint()
    c.frame.updateStatusLine()
#@-node:ekr.20060113130510:extendHelper
#@+node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20060417171125:addSpace/TabToLines & removeSpace/TabFromLines & helper
def addSpaceToLines (self,event):
    '''Add a space to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=True,undoType='add-space-to-lines')

def addTabToLines (self,event):
    '''Add a tab to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=True,undoType='add-tab-to-lines')

def removeSpaceFromLines (self,event):
    '''Remove a space from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=False,undoType='remove-space-from-lines')

def removeTabFromLines (self,event):
    '''Remove a tab from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=False,undoType='remove-tab-from-lines')
#@+node:ekr.20060417172056:addRemoveHelper
def addRemoveHelper(self,event,ch,add,undoType):

    c = self.c ; k = self.k ; w = self.editWidget(event)
    if not w: return

    if w.hasSelection():s = w.getSelectedText()
    else:               s = w.getAllText()
    if not s: return

    # Insert or delete spaces instead of tabs when negative tab width is in effect.
    d = g.scanDirectives(c) ; width = d.get('tabwidth')
    if ch == '\t' and width < 0: ch = ' ' * abs(width)

    self.beginCommand(undoType=undoType)

    lines = g.splitLines(s)

    if add:
        result = [ch + line for line in lines]
    else:
        result = [g.choose(line.startswith(ch),line[len(ch):],line) for line in lines]

    result = ''.join(result)

    # g.trace('add',add,'hasSelection',w.hasSelection(),'result',repr(result))

    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
        w.insert(i,result)
        w.setSelectionRange(i,i+len(result))
    else:
        w.setAllText(result)
        w.setSelectionRange(0,len(s))

    self.endCommand(changed=True,setLabel=True)

#@-node:ekr.20060417172056:addRemoveHelper
#@-node:ekr.20060417171125:addSpace/TabToLines & removeSpace/TabFromLines & helper
#@+node:ekr.20051026092433.1:backwardDeleteCharacter
def backwardDeleteCharacter (self,event=None):

    '''Delete the character to the left of the cursor.'''

    c = self.c ; p = c.currentPosition()
    w = self.editWidget(event,allowMinibuffer=True)
    if not w: return

    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace(wname,i,j,ins)

    if wname.startswith('body'):
        self.beginCommand()
        try:
            d = g.scanDirectives(c,p)
            tab_width = d.get("tabwidth",c.tab_width)
            changed = True
            if i != j:
                w.delete(i,j)
                w.setSelectionRange(i,i,insert=i)
            elif i == 0:
                changed = False
            elif tab_width > 0:
                w.delete(ins-1)
                w.setSelectionRange(ins-1,ins-1,insert=ins-1)
            else:
                << backspace with negative tab_width >>
        finally:
            self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        # Make sure we actually delete something if we can.
        s = w.getAllText()
        if i != j:
            j = max(i,min(j,len(s)))
            w.delete(i,j)
            w.setSelectionRange(i,i,insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins-1)
            ins = ins-1
            w.setSelectionRange(ins,ins,insert=ins)
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.getAllText()
ins = w.getInsertPoint()
i,j = g.getLine(s,ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
i = ins-(max(1,count))
w.delete(i,ins)
w.setSelectionRange(i,i,insert=i)
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@-node:ekr.20051026092433.1:backwardDeleteCharacter
#@+node:ekr.20070325094935:cleanAllLines
def cleanAllLines (self,event):

    '''Clean all lines in the selected tree.'''

    c = self.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl
    if not w: return

    c.beginUpdate()
    try:
        for p in current.self_and_subtree_iter():
            c.selectPosition(p)
            w.setSelectionRange(0,0,insert=0)
            c.editCommands.cleanLines(event)
        c.selectPosition(current)
    finally:
        c.endUpdate(False)
#@-node:ekr.20070325094935:cleanAllLines
#@+node:ekr.20060415112257:cleanLines
def cleanLines (self,event):

    '''Removes leading whitespace from otherwise blanks lines.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    if w.hasSelection():
        s = w.getSelectedText()
    else:
        s = w.getAllText()

    lines = [] ; changed = False
    for line in g.splitlines(s):
        if line.strip():
            lines.append(line)
        else:
            if line.endswith('\n'):
                lines.append('\n')
            changed = changed or '\n' != line

    if changed:
        self.beginCommand(undoType='clean-lines')
        result = ''.join(lines)
        if w.hasSelection():
            i,j = w.getSelectionRange()
            w.delete(i,j)
            w.insert(i,result)
            w.setSelectionRange(i,j+len(result))
        else:
            w.delete(0,'end')
            w.insert(0,result)
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060415112257:cleanLines
#@+node:ekr.20060414085834:clearSelectedText
def clearSelectedText (self,event):

    '''Delete the selected text.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    i,j = w.getSelectionRange()
    if i == j: return

    self.beginCommand(undoType='clear-selected-text')

    w.delete(i,j)
    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20060414085834:clearSelectedText
#@+node:ekr.20050920084036.87:deleteNextChar
def deleteNextChar (self,event):

    '''Delete the character to the right of the cursor.'''

    c = self.c ; w = self.editWidget(event,allowMinibuffer=True)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()

    self.beginCommand(undoType='delete-char')

    changed = True
    if i != j:
        w.delete(i,j)
        w.setInsertPoint(i)
    elif j < len(s):
        w.delete(i)
        w.setInsertPoint(i)
    else:
        changed = False

    self.endCommand(changed=changed,setLabel=False)
#@-node:ekr.20050920084036.87:deleteNextChar
#@+node:ekr.20050920084036.135:deleteSpaces
def deleteSpaces (self,event,insertspace=False):

    '''Delete all whitespace surrounding the cursor.'''

    c = self.c ; w = self.editWidget(event)
    undoType = g.choose(insertspace,'insert-space','delete-spaces')
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    w1 = ins-1
    while w1 >= i and s[w1].isspace():
        w1 -= 1
    w1 += 1
    w2 = ins
    while w2 <= j and s[w2].isspace():
        w2 += 1
    spaces = s[w1:w2]
    if spaces:
        self.beginCommand(undoType=undoType)
        if insertspace: s = s[:w1] + ' ' + s[w2:]
        else:           s = s[:w1] + s[w2:]
        w.setAllText(s)
        w.setInsertPoint(w1)
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.135:deleteSpaces
#@+node:ekr.20050920084036.138:insertNewLine
def insertNewLine (self,event):

    '''Insert a newline at the cursor.'''

    w = self.editWidget(event)
    if not w: return
    wname = g.app.gui.widget_name(w)
    if wname.startswith('head'): return

    self.beginCommand(undoType='insert-newline')

    i = w.getInsertPoint()
    w.insert(i,'\n')
    w.setInsertPoint(i+1)

    self.endCommand(changed=True,setLabel=False)

insertNewline = insertNewLine
#@-node:ekr.20050920084036.138:insertNewLine
#@+node:ekr.20050920084036.86:insertNewLineAndTab
def insertNewLineAndTab (self,event):

    '''Insert a newline and tab at the cursor.'''

    w = self.editWidget(event)
    if not w: return
    wname = g.app.gui.widget_name(w)
    if wname.startswith('head'): return

    self.beginCommand(undoType='insert-newline-and-indent')

    i = w.getInsertPoint()
    w.insert(i,'\n\t')
    w.setInsertPoint(i+2)

    self.endCommand(changed=True,setLabel=False)
#@-node:ekr.20050920084036.86:insertNewLineAndTab
#@+node:ekr.20050920084036.139:insertParentheses
def insertParentheses (self,event):

    '''Insert () at the cursor.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='insert-parenthesis')

    i = w.getInsertPoint()
    w.insert(i,'()')
    w.setInsertPoint(i+1)

    self.endCommand(changed=True,setLabel=False)
#@-node:ekr.20050920084036.139:insertParentheses
#@+node:ekr.20050920084036.141:removeBlankLines
def removeBlankLines (self,event):

    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''

    c = self.c
    head,lines,tail,oldSel,oldYview = c.getBodyLines()

    changed = False ; result = []
    for line in lines:
        if line.strip():
            result.append(line)
        else:
            changed = True
    result = ''.join(result)

    if changed:
        oldSel = None ; undoType = 'remove-blank-lines'
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@-node:ekr.20050920084036.141:removeBlankLines
#@+node:ekr.20051125080855:selfInsertCommand, helpers
def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    w = self.editWidget(event)
    if not w: return 'break'
    << set local vars >>
    #g.trace('ch',repr(ch))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:

            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    # g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@+node:ekr.20061103114242:<< set local vars >>
c = self.c
p = c.currentPosition()
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if keysym == 'Tab': # Support for wx_alt_gui plugin.
    ch = '\t'
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.bodyString() or ''
undoType = 'Typing'
trace = c.config.getBool('trace_masterCommand')
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch,g.app.tkEncoding) in brackets
if trace: g.trace(name,repr(ch),ch and ch in brackets)
#@nonl
#@-node:ekr.20061103114242:<< set local vars >>
#@+node:ekr.20051026171121:insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.currentPosition()
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
        if (
            (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
            undoType != "Change"
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
#@nonl
#@-node:ekr.20051026171121:insertNewlineHelper
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'

    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = g.scanDirectives(c,p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.scanColorDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c
    d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.

    if i != j:
        w.delete(i,j)

    if tab_width > 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        # Get the preceeding characters.
        s = w.getAllText()
        start = g.skip_to_start_of_line(s,i)
        s2 = s[start:i]

        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s2,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        # g.trace('n',n)
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand, helpers
#@-node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20080408060320.788:Cursor/character commands allowed in the minibuffer
#@+node:ekr.20051213080533:characters
def backCharacter (self,event):
    '''Move the cursor back one character, extending the selection if in extend mode.'''
    w = self.editWidget(event,allowMinibuffer=True)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=False,allowMinibuffer=True)

def backCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one character.'''
    w = self.editWidget(event,allowMinibuffer=True)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=True,allowMinibuffer=True)

def forwardCharacter (self,event):
    '''Move the cursor forward one character, extending the selection if in extend mode.'''
    w = self.editWidget(event,allowMinibuffer=True)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=False,allowMinibuffer=True)

def forwardCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one character.'''
    w = self.editWidget(event,allowMinibuffer=True)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=True,allowMinibuffer=True)
#@-node:ekr.20051213080533:characters
#@+node:ekr.20050920084036.87:deleteNextChar
def deleteNextChar (self,event):

    '''Delete the character to the right of the cursor.'''

    c = self.c ; w = self.editWidget(event,allowMinibuffer=True)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()

    self.beginCommand(undoType='delete-char')

    changed = True
    if i != j:
        w.delete(i,j)
        w.setInsertPoint(i)
    elif j < len(s):
        w.delete(i)
        w.setInsertPoint(i)
    else:
        changed = False

    self.endCommand(changed=changed,setLabel=False)
#@-node:ekr.20050920084036.87:deleteNextChar
#@+node:ekr.20051026092433.1:backwardDeleteCharacter
def backwardDeleteCharacter (self,event=None):

    '''Delete the character to the left of the cursor.'''

    c = self.c ; p = c.currentPosition()
    w = self.editWidget(event,allowMinibuffer=True)
    if not w: return

    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace(wname,i,j,ins)

    if wname.startswith('body'):
        self.beginCommand()
        try:
            d = g.scanDirectives(c,p)
            tab_width = d.get("tabwidth",c.tab_width)
            changed = True
            if i != j:
                w.delete(i,j)
                w.setSelectionRange(i,i,insert=i)
            elif i == 0:
                changed = False
            elif tab_width > 0:
                w.delete(ins-1)
                w.setSelectionRange(ins-1,ins-1,insert=ins-1)
            else:
                << backspace with negative tab_width >>
        finally:
            self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        # Make sure we actually delete something if we can.
        s = w.getAllText()
        if i != j:
            j = max(i,min(j,len(s)))
            w.delete(i,j)
            w.setSelectionRange(i,i,insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins-1)
            ins = ins-1
            w.setSelectionRange(ins,ins,insert=ins)
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.getAllText()
ins = w.getInsertPoint()
i,j = g.getLine(s,ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
i = ins-(max(1,count))
w.delete(i,ins)
w.setSelectionRange(i,i,insert=i)
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@-node:ekr.20051026092433.1:backwardDeleteCharacter
#@+node:ekr.20051218141237:lines
def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event,allowMinibuffer=True)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=False,allowMinibuffer=True)

def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    w = self.editWidget(event,allowMinibuffer=True)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=True,allowMinibuffer=True)

def endOfLine (self,event): # passed
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event,allowMinibuffer=True)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=False,allowMinibuffer=True)

def endOfLineExtendSelection (self,event): # passed
    '''Extend the selection by moving the cursor to the end of the line.'''
    w = self.editWidget(event,allowMinibuffer=True)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=True,allowMinibuffer=True)

def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)

def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)

def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)

def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
#@-node:ekr.20051218141237:lines
#@+node:ekr.20071003183657:killLine
def killLine (self,event):
    '''Kill the line containing the cursor.'''
    c = self.c
    w = self.editWidget(event,allowMinibuffer=True)
    if not w: return
    if w == c.frame.miniBufferWidget:
        c.k.killLine()
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i,j = g.getLine(s,ins)
        # g.trace(i,j,ins,len(s),repr(s[i:j]))
        if ins >= len(s) and g.match(s,j-1,'\n'): # Kill the trailing newline.
            i = max(0,len(s)-1)
            j = len(s)
        elif j > i+1 and g.match(s,j-1,'\n'): # Kill the line, but not the newline.
            j -= 1
        else: # Kill the newline.
            pass
        self.kill(event,i,j,undoType='kill-line')
#@-node:ekr.20071003183657:killLine
#@+node:ekr.20061111223516:selectAllText (leoEditCommands)
def selectAllText (self,event):

    c = self.c 
    w = self.editWidget(event,allowMinibuffer=True) or g.app.gui.eventWidget(event) or c.frame.body.bodyCtrl
    if w == c.frame.miniBufferWidget:
        c.k.selectAll()
    else:
        return w.selectAllText()
#@-node:ekr.20061111223516:selectAllText (leoEditCommands)
#@+node:ekr.20050930091642.1:yank
def yank (self,event,pop=False):

    '''yank: insert the first entry of the kill ring.
    yank-pop: insert the next entry of the kill ring.
    '''

    c = self.c ; w = self.editWidget(event,allowMinibuffer=True)
    if not w: return
    current = c.currentPosition()
    if not current: return
    text = w.getAllText()
    i, j = w.getSelectionRange()
    clip_text = self.getClipboard()
    if not self.killBuffer and not clip_text: return

    undoType = g.choose(pop,'yank-pop','yank')
    self.beginCommand(undoType=undoType)
    try:
        if not pop or self.lastYankP and self.lastYankP != current:
            self.reset = 0
        s = self.kbiterator.next()
        if s is None: s = clip_text or ''
        if i != j: w.deleteTextSelection()
        if s != s.lstrip(): # s contains leading whitespace.
            i2,j2 = g.getLine(text,i)
            k = g.skip_ws(text,i2)
            if i2 < i <= k:
                # Replace the line's leading whitespace by s's leading whitespace.
                w.delete(i2,k)
                i = i2
        w.insert(i,s)
        w.setSelectionRange(i,i+len(s),insert=i+len(s))
        self.lastYankP = current.copy()
        c.frame.body.forceFullRecolor()
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050930091642.1:yank
#@-node:ekr.20080408060320.788:Cursor/character commands allowed in the minibuffer
#@+node:ekr.20061031131434.111:fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; gui = g.app.gui
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = False or c.config.getBool('trace_modes')
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'
#@+node:ekr.20061031131434.112:callAltXFunction
def callAltXFunction (self,event):

    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event.widget.widgetName)

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
#@-node:ekr.20061031131434.112:callAltXFunction
#@-node:ekr.20061031131434.111:fullCommand (alt-x) & helper
#@-node:ekr.20080408060320.786:Allow cursor movement commands in the minibuffer
#@+node:ekr.20080406075855.1:Fixed backspace bug in the find command
@nocolor

Trying to edit the minibuffer, when I backspace to a character and
press delete the cursor moves to the end of the buffer and deletes the
last character instead.

@color
#@nonl
#@+node:ekr.20061031131434.128:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer and k.useTextWidget: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or stroke in k.getArgEscapes:
        if stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20061031131434.129:<< init altX vars >>
#@-node:ekr.20061031131434.128:getArg
#@+node:ekr.20061031131434.28:computeCompletionList
def computeCompletionList (self,verbose=False):

    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) < 25:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in d.keys()] ; aList.sort()
            self.tabList = aList

    c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
    if self.tabList:
        self.tabListIndex = -1 # The next item will be item 0.
        self.setSelection(common_prefix)
    for name in self.tabList:
        z = '%s' % (name)
        g.es('',z,tabName=self.tabName)
#@-node:ekr.20061031131434.28:computeCompletionList
#@+node:ekr.20061031131434.29:doBackSpace (autocompleter)
def doBackSpace (self):

    '''Cut back to previous prefix.'''

    g.trace('(autocompleter)',self.prefix,self.object,self.prevObjects)

    c = self.c
    if self.prefix:
        self.prefix = self.prefix[:-1]
        self.setSelection(self.prefix)
        self.computeCompletionList()
    elif self.object:
        if self.prevObjects:
            obj = self.pop()
        else:
            obj = self.object
        # g.trace(self.object,obj)
        w = self.widget
        s = w.getAllText()
        i,junk = w.getSelectionRange()
        ch = 0 <= i-1 < len(s) and s[i-1] or ''
        # g.trace(ch)
        if ch == '.':
            self.object = obj
            w.delete(i-1)
            c.frame.body.onBodyChanged(undoType='Typing')
            i,j = g.getWord(s,i-2)
            word = s[i:j]
            # g.trace(i,j,repr(word))
            w.setSelectionRange(i,j,insert=j)
            self.prefix = word
            self.popTabName()
            self.membersList = self.getMembersList(obj)
            # g.trace(len(self.membersList))
            if self.membersList:
                self.computeCompletionList()
            else:
                self.abort()
        else:
            self.abort() # should not happen.
    else:
        self.abort()            
#@nonl
#@-node:ekr.20061031131434.29:doBackSpace (autocompleter)
#@+node:ekr.20061031131434.177:k.doBackSpace
# Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList,completion=True):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c ; w = self.widget

    if 0:
        g.trace('(keyHandler)',g.callers(4))
        g.trace('completion',completion,
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    # Step 1: actually delete the character.
    ins = w.getInsertPoint()
    s = w.getAllText()
    if ins <= len(k.mb_prefix):
        # g.trace('at start')
        return
    i,j = w.getSelectionRange()
    if i == j:
        ins -= 1
        w.delete(ins)
        w.setSelectionRange(ins,ins,insert=ins)
    else:
        ins = i
        w.delete(i,j)
        w.setSelectionRange(i,i,insert=ins)

    # Step 2: compute completions.
    if not completion: return
    k.mb_tabListPrefix = w.getAllText()
    k.computeCompletionList(defaultCompletionList,backspace=True)
#@-node:ekr.20061031131434.177:k.doBackSpace
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@-node:ekr.20080406075855.1:Fixed backspace bug in the find command
#@-node:ekr.20080408060320.782:Bug fixes
#@+node:ekr.20080408060320.783:Features
#@+node:ekr.20080407090400.3:Added install nodes re Leo's home directory
@nocolor

Leo puts several files in the home directory: .leoID.txt,
.leoRecentFiles.txt, and myLeoSettings.leo.  There are various fallback directories if there is no home directory.

If you want more details, you can do what I did: do a clone-find-all for homeDir.

As for how the home directory is set, the code to do this is g.computeHomeDir.  We get the home directory with

home = os.getenv('HOME',default=None)

There are some mind-numbing details to be handled if there os.getenv does, in fact, return a directory.

@color
#@nonl
#@+node:ekr.20080407090400.4:Found: homeDir
#@+node:ekr.20070224115832:readRecentFiles & helpers
def readRecentFiles (self,localConfigFile):

    '''Read all .leoRecentFiles.txt files.'''

    # The order of files in this list affects the order of the recent files list.
    seen = [] 
    localConfigPath = g.os_path_dirname(localConfigFile)
    for path in (
        g.app.homeDir,
        g.app.globalConfigDir,
        localConfigPath,
    ):
        if path and path not in seen:
            ok = self.readRecentFilesFile(path)
            if ok: seen.append(path)
    if not seen and self.write_recent_files_as_needed:
        self.createRecentFiles()
#@nonl
#@+node:ekr.20061010121944:createRecentFiles
def createRecentFiles (self):

    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created',fileName,color='red')
                return
            except Exception:
                g.es_print('can not create',fileName,color='red')
                g.es_exception()
#@nonl
#@-node:ekr.20061010121944:createRecentFiles
#@+node:ekr.20050424115658:readRecentFilesFile
def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
        if not g.unitTesting and not self.silent:
            print ('reading %s' % fileName)
        lines = file(fileName).readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
            self.appendToRecentFiles(lines)

    return ok
#@nonl
#@-node:ekr.20050424115658:readRecentFilesFile
#@-node:ekr.20070224115832:readRecentFiles & helpers
#@+node:ekr.20061010121944:createRecentFiles
def createRecentFiles (self):

    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created',fileName,color='red')
                return
            except Exception:
                g.es_print('can not create',fileName,color='red')
                g.es_exception()
#@nonl
#@-node:ekr.20061010121944:createRecentFiles
#@+node:ekr.20050424114937.2:writeRecentFilesFile & helper
recentFileMessageWritten = False

def writeRecentFilesFile (self,c):

    '''Write the appropriate .leoRecentFiles.txt file.'''

    tag = '.leoRecentFiles.txt'

    if g.app.unitTesting:
        return

    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None

    written = False
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                if not self.recentFileMessageWritten:
                    print ('wrote recent file: %s' % fileName)
                    written = True
                self.writeRecentFilesFileHelper(fileName)
                # Bug fix: Leo 4.4.6: write *all* recent files.

    if written:
        self.recentFileMessageWritten = True
    else:
        pass # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
#@+node:ekr.20050424131051:writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)

    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
            # g.trace(fileName,'lines\n%s' % lines)
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass

    except Exception:
        g.es('unexpected exception writing',fileName,color='red')
        g.es_exception()

    if theFile:
        theFile.close()
#@-node:ekr.20050424131051:writeRecentFilesFileHelper
#@-node:ekr.20050424114937.2:writeRecentFilesFile & helper
#@+node:ekr.20041117083857:initSettingsFiles
def initSettingsFiles (self):

    """Set self.globalConfigFile, self.homeFile, self.machineConfigFile and self.myConfigFile."""

    settingsFile = 'leoSettings.leo'
    mySettingsFile = 'myLeoSettings.leo'
    machineConfigFile = self.getMachineName()

    for ivar,theDir,fileName in (
        ('globalConfigFile',    g.app.globalConfigDir,  settingsFile),
        ('homeFile',            g.app.homeDir,          settingsFile),
        ('myGlobalConfigFile',  g.app.globalConfigDir,  mySettingsFile),
        ('myHomeConfigFile',    g.app.homeDir,          mySettingsFile),
        ('machineConfigFile',   g.app.homeDir,          machineConfigFile),
    ):
        # The same file may be assigned to multiple ivars:
        # readSettingsFiles checks for such duplications.
        path = g.os_path_join(theDir,fileName)
        if g.os_path_exists(path):
            setattr(self,ivar,path)
        else:
            setattr(self,ivar,None)
    if 0:
        g.trace('global file:',self.globalConfigFile)
        g.trace('home file:',self.homeFile)
        g.trace('myGlobal file:',self.myGlobalConfigFile)
        g.trace('myHome file:',self.myHomeConfigFile)
#@nonl
#@+node:ekr.20071211112804:getMachineName
def getMachineName (self):

    try:
        import os
        name = os.getenv('HOSTNAME')
        if not name:
            name = os.getenv('COMPUTERNAME')
        if not name:
            import socket
            name = socket.gethostname()
    except Exception:
        name = ''

    if name:
        name +='LeoSettings.leo'

    # g.trace(name)

    return name
#@-node:ekr.20071211112804:getMachineName
#@-node:ekr.20041117083857:initSettingsFiles
#@+node:ekr.20080220082727:@scan_g.es_results
@first # -*- coding: utf-8 -*-

@ To be translated...

#if and #else parts have different braces:
%s dir:
(in
)
*** Two exclusive handlers for
***Updating:
...
:
= requires @root in the headline
@comment disables untangle for
Indentation error in
Leo Log Window...
ParserError in
Referenced from
This is for testing if g.es blocks in a thread
Token error in
TokenError in
\nauto-completer scan complete
\ntest of es_print: Ă
adding
after
all plugin handlers...
all tests enabled: this may take awhile
already loaded
auto-saving outline
bad
bad @+leo sentinel
bad @+node sentinel
bad abbrev:
bad encoding in derived file:
bad open/close_flash_brackets setting: using defaults
bad tnode index:
blanks converted to tabs in
buffers...
c.target_language:
can not add
can not create
can not create temp file
can not create: read only:
can not execute
can not import
can not import Image module from PIL
can not import ImageTk module
can not import gc module
can not load enabled plugin:
can not load image:
can not open
can not open Aspell
can not open dictionary file:
can not open local dictionary
can not open script file:
can not open:
can not write %s
can't happen: is_sentinel
can't move node out of
changed:
check complete
check-derived-file passed
check-leo-file failed:
check-leo-file passed
checking Python code
clearing undo
collapse_nodes_during_finds
command is not valid in batch mode
command not ready yet
conflicting @header and @noheader directives
correcting hidden node: t=
correcting line endings in:
count:
created
created chapter
created directory:
created in
created:
creating menu from
creating new window
creating:
current directory:
debugger does not exist:
default tangle directory not found:
deleting tnode list for
directory
directory:
disabling save commands
done
dubious brackets in
dummy created
empty
enabled brief gc stats
enabled plugins...
enabled verbose gc stats
end of script
error handling:
error parsing
error pretty-printing
error reading:
error:
errors
errors inhibited read @auto
event
exception binding
exception creating directory:
exception creating temp file
exception creating:
exception deleting backup file:
exception deleting:
exception executing
exception executing command
exception executing script
exception executing:
exception handling
exception in
exception in g.importFromPath
exception in os.chmod
exception loading plugin
exception opening:
exception removing:
exception renaming
exception writing:
extend mode
file not found
file not found:
finished
first mismatched line at line
from
g.app.config: bad encoding:
g.init_zodb: can not import ZODB
g.init_zodb: exception creating ZODB.DB instance
generated line:
get_focus:
gui does not support a stand-alone find dialog
gui does not support the compare window
handlers for
hasFocusWidget:
head_lines:
ignoring
ignoring 3.x sentinel:
ignoring bad @comment directive:
ignoring bad @comment sentinel:
ignoring bad @language directive:
ignoring bad @language sentinel:
ignoring bad unknownAttributes key
ignoring command: already executing a command.
ignoring invalid key binding:
ignoring non-dictionary unknownAttributes for
ignoring non-pickleable attribute
ignoring non-string attribute
ignoring redundant -noref in:
ignoring redundant -nosent in:
ignoring:
ignoring: @comment
imported
in
in file:
indentation error in
info string
inhibits untangle for
ins:
inserting @ignore
instances
invalid @+leo sentinel in
invalid @encoding:
invalid @lineending directive:
invalid Paste As Clone
invalid encoding in .leo file:
is a sentinel line
is also a prefix of
is bound to:
is not
is not in the outline
len
leoID=
line
line:
lines
load dir:
loadOnePlugin: failed to load module
loaded plugin:
looking for a parent to tangle...
lossage...
may be read-only or in use
minibuffer hidden
missing lines
missing vnode:
modes conflict in:
newTnode: unexpected index type:
no @auto nodes in the selected tree
no @file node in the selected tree
no @file nodes in the selected tree
no @test or @suite nodes in selected outline
no Find script node
no ancestor @file node: using script line numbers
no bindings
no child index for
no children and less than 10 characters (excluding directives)
no debugger found.
no dirty @auto nodes in the selected tree
no dirty @file nodes
no docstring for
no file name
no matching #endif:
no more clones
no more misspellings
no previous command
no script selected
no state function for
no such command:
no text selected
no tnode with index:
nodes
nodes checked
not a clone:
not a valid MORE file
not changed.
not found
not found in
not found:
not written:
nothing follows section name
offending line...
offending line:\n
only
or
original line:
over-riding setting:
parent node:
path does not exist:
plugin
probably an outline topology error.
psyco now logging to:
psyco now running
putCount
putDescendentUnknownAttributes can't happen 2
putDescendentUnknownAttributes: unexpected pickling exception
putUaHelper: unexpected pickling exception
read only
read only:
reading:
recreating:
redefining
redo
relative path in @path directive:
relative_path_base_directory:
rename failed: no file created!
reopening:
replacing
requestedFocusWidget:
restoring
resurrected node:
running
save commands disabled
saved:
scanGnx: unexpected index type:
scanning for auto-completer...
seems to be mixed HTML and PHP:
selected text should contain one or more section names
selected text should start with a section name
skipping settings in
surprise in checkPythonNode
swap-words command not ready yet
syntax error in class node: can not continue
syntax error in:
syntax error: deleting
tabs converted to blanks in
tail_lines:
tangle complete
tangling parent
tangling...
the
the clipboard is not valid
the current node is not a clone
the text will be discarded
there may be conflicting settings!
time.strftime not available on this platform
time/count:
time:
to
to dictionary
unchanged:
undo
unexpected exception converting hexlified string to string
unexpected exception in
unexpected exception in app.setLeoID
unexpected exception in c.openWith
unexpected exception in g.create_temp_file
unexpected exception in g.getScript
unexpected exception in g.importFromPath(%s)
unexpected exception parsing
unexpected exception writing
unit tests
unknown attributes for
unknown attributes for tnode
unknown command name:
unknown language: using Python comment delimiters
unknown option:
unmatched
untangle complete
untangling...
using
using -asis option in:
using -thin option in:
using a blank one instead
using empty text.
using os.getenv('USER'):
warning:
warning: conflicting values for
warning: ignoring
warning: possible duplicate definition of:
warning: updating changed text in
with
write the @file node or use the Import Derived File command
writing erroneous:
wrote:
you may want to delete ressurected nodes
@c
# Decls...
color='red'
newline=True
tabName='Log'
False = 'False'
aList = 'aList'
args = 'args'
at_DOT_outputFileName = 'at.outputFileName'
at_DOT_root_DOT_headString_PARENS_ = 'at.root.headString()'
attrDict_DOT_get_LP_key_RP_ = 'attrDict.get(key)'
b2_DOT_pane = 'b2.pane'
backupName = 'backupName'
badline = 'badline'
base = 'base'
bindStroke = 'bindStroke'
bindings = 'bindings'
bunch_DOT_kind = 'bunch.kind'
c_DOT_config_DOT_getBool_LP__SQ_collapse_nodes_during_finds_SQ__RP_ = 'c.config.getBool(\'collapse_nodes_during_finds\')'
c_DOT_disableCommandsMessage = 'c.disableCommandsMessage'
c_DOT_shortFileName_PARENS_ = 'c.shortFileName()'
c_DOT_tangle_directory = 'c.tangle_directory'
c_DOT_target_language = 'c.target_language'
c_DOT_widget_name_LP_c_DOT_get_focus_PARENS__RP_ = 'c.widget_name(c.get_focus())'
c_DOT_widget_name_LP_c_DOT_hasFocusWidget_RP_ = 'c.widget_name(c.hasFocusWidget)'
c_DOT_widget_name_LP_c_DOT_requestedFocusWidget_RP_ = 'c.widget_name(c.requestedFocusWidget)'
c_DOT_widget_name_LP_w_RP_ = 'c.widget_name(w)'
ch = 'ch'
command = 'command'
commandName = 'commandName'
computeProxyObject = 'computeProxyObject'
configDir = 'configDir'
count = 'count'
d_DOT_get_LP_ch_RP_ = 'd.get(ch)'
d2 = 'd2'
d3 = 'd3'
data = 'data'
debugger = 'debugger'
delim1 = 'delim1'
delim2 = 'delim2'
delim3 = 'delim3'
dictionaryFileName = 'dictionaryFileName'
dir2 = 'dir2'
doc = 'doc'
dst = 'dst'
e = 'e'
encoding = 'encoding'
encodingName = 'encodingName'
errors = 'errors'
eventName = 'eventName'
exctype_DOT___name__ = 'exctype.__name__'
fileName = 'fileName'
file_name = 'file_name'
filename = 'filename'
fn = 'fn'
g_DOT_angleBrackets_LP__DQ___DQ__RP_ = 'g.angleBrackets("*")'
g_DOT_app_DOT_globalOpenDir = 'g.app.globalOpenDir'
g_DOT_app_DOT_gui_DOT_getFullVersion_LP_c_RP_ = 'g.app.gui.getFullVersion(c)'
g_DOT_app_DOT_gui_DOT_guiName_PARENS_ = 'g.app.gui.guiName()'
g_DOT_app_DOT_leoID = 'g.app.leoID'
g_DOT_choose_LP_val_COMMA__SQ_on_SQ__COMMA__SQ_off_SQ__RP_ = 'g.choose(val,\'on\',\'off\')'
g_DOT_get_line_LP_s_COMMA_i_RP_ = 'g.get_line(s,i)'
g_DOT_plugin_date_LP_m_RP_ = 'g.plugin_date(m)'
g_DOT_shortFileName_LP_fileName_RP_ = 'g.shortFileName(fileName)'
g_DOT_shortFileName_LP_path_RP_ = 'g.shortFileName(path)'
h = 'h'
head_lines = 'head_lines'
headline = 'headline'
homeDir = 'homeDir'
i = 'i'
index = 'index'
inputFileName = 'inputFileName'
ins = 'ins'
ivar = 'ivar'
k_DOT_prettyPrintKey_LP_stroke_RP_ = 'k.prettyPrintKey(stroke)'
k_DOT_state_DOT_kind = 'k.state.kind'
key = 'key'
keys = 'keys'
kind = 'kind'
len_LP_lines_RP_ = 'len(lines)'
len_LP_s_RP_ = 'len(s)'
letter = 'letter'
line = 'line'
line1 = 'line1'
line2 = 'line2'
loadDir = 'loadDir'
lp = 'lp'
m = 'm'
m_DOT___name__ = 'm.__name__'
m_DOT___version__ = 'm.__version__'
message = 'message'
min_LP_12_COMMA_n2_RP_ = 'min(12,n2)'
min_LP_20_COMMA_n1_RP_ = 'min(20,n1)'
modeName = 'modeName'
moduleName = 'moduleName'
msg = 'msg'
n = 'n'
n1 = 'n1'
n2 = 'n2'
n3 = 'n3'
name = 'name'
newFileName = 'newFileName'
p_DOT_headString_PARENS_ = 'p.headString()'
p_DOT_parent_PARENS__DOT_headString_PARENS_ = 'p.parent().headString()'
pane = 'pane'
part_DOT_name = 'part.name'
path = 'path'
prefix = 'prefix'
ratio = 'ratio'
relative_path = 'relative_path'
repr_LP_at_DOT_t_RP_ = 'repr(at.t)'
repr_LP_ch_RP_ = 'repr(ch)'
repr_LP_data_RP_ = 'repr(data)'
repr_LP_g_DOT_app_DOT_leoID_RP_ = 'repr(g.app.leoID)'
repr_LP_line_RP_ = 'repr(line)'
repr_LP_theId_RP_ = 'repr(theId)'
repr_LP_val_RP_ = 'repr(val)'
requestedType = 'requestedType'
root_DOT_headString_PARENS_ = 'root.headString()'
rp = 'rp'
s = 's'
s_DOT_strip_PARENS_ = 's.strip()'
s1 = 's1'
s2 = 's2'
s3 = 's3'
section_DOT_name = 'section.name'
self_DOT_currentWord = 'self.currentWord'
self_DOT_fileName = 'self.fileName'
self_DOT_outputFileName = 'self.outputFileName'
self_DOT_print_mode = 'self.print_mode'
self_DOT_putCount = 'self.putCount'
self_DOT_shortFileName = 'self.shortFileName'
self_DOT_tabName = 'self.tabName'
self_DOT_targetFileName = 'self.targetFileName'
sep = 'sep'
setting = 'setting'
shortcut = 'shortcut'
signon = 'signon'
spaces = 'spaces'
sparseMove = 'sparseMove'
src = 'src'
start = 'start'
start_line = 'start_line'
str_LP_i_1_RP_ = 'str(i+1)'
str_LP_index_RP_ = 'str(index)'
str_LP_message_RP_ = 'str(message)'
str_LP_msg_RP_ = 'str(msg)'
str_LP_n_RP_ = 'str(n)'
str_LP_time_RP_ = 'str(time)'
stroke = 'stroke'
tag = 'tag'
tail_lines = 'tail_lines'
target = 'target'
theDir = 'theDir'
theFile = 'theFile'
time_DOT_clock_PARENS_ = 'time.clock()'
title = 'title'
torv = 'torv'
type_LP_index_RP_ = 'type(index)'
type_LP_s_RP_ = 'type(s)'
url = 'url'
v_DOT_headString_PARENS_ = 'v.headString()'
val = 'val'
value = 'value'
version = 'version'
vnodeName = 'vnodeName'
word = 'word'
z = 'z'
z_line = 'z_line'
z_opt = 'z_opt'
zipMark = 'zipMark'
g.app.translateToUpperCase=True
# ---- @thin leo.py 
g.es_print('','-------------------- @thin leo.py ',color='red')
# -- node run
g.es("disabling save commands",color="red")
# -- node createFrame (leo.py)
g.es("file not found:",fileName)
# -- node getBatchScript
g.es_print("can not open script file:",name, color="red")
# -- node reportDirectories
g.es("%s dir:" % (kind),theDir,color="blue")
# -- node startPsyco
g.es("psyco now logging to:",theFile,color="blue")
g.es("psyco now running",color="blue")
# ---- @thin leoApp.py
g.es_print('','-------------------- @thin leoApp.py',color='red')
# -- node < < return if we can set leoID from sys.leoID> >
# g.es_print("leoID=",g.app.leoID,spaces=False,color='red')
g.es_print("leoID=",g_DOT_app_DOT_leoID,spaces=False,color='red')
# -- node < < return if we can set leoID from "leoID.txt" > >
# g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('leoID=',g_DOT_app_DOT_leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
g.es_print('unexpected exception in app.setLeoID',color='red')
# -- node < < return if we can set leoID from os.getenv('USER') > >
# g.es("using os.getenv('USER'):",repr(theId),color='red')
g.es("using os.getenv('USER'):",repr_LP_theId_RP_,color='red')
# -- node < < put up a dialog requiring a valid id > >
# g.es('leoID=',repr(g.app.leoID),spaces=False,color="blue")
g.es('leoID=',repr_LP_g_DOT_app_DOT_leoID_RP_,spaces=False,color="blue")
# -- node < < attempt to create leoID.txt > >
g.es_print('',tag,'created in',theDir,color='red')
g.es('can not create',tag,'in',theDir,color='red')
# -- node app.writeWaitingLog
g.es('',s,color=color,newline=0)
# ---- @thin leoAtFile.py
g.es_print('','-------------------- @thin leoAtFile.py',color='red')
# -- node checkDerivedFile (atFile)
g.es_print('check-derived-file passed',color='blue')
# -- node < < warn on read-only file > >
g.es("read only:",fn,color="red")
# -- node read
# g.es("reading:",root.headString())
g.es("reading:",root_DOT_headString_PARENS_)
# -- node < < advise user to delete all unvisited nodes > >
# g.es('resurrected node:',p.headString(),color='blue')
g.es('resurrected node:',p_DOT_headString_PARENS_,color='blue')
g.es('in file:',fileName,color='blue')
g.es('you may want to delete ressurected nodes')
# -- node readAll (atFile)
g.es("no @file nodes in the selected tree")
# -- node readOneAtAutoNode (atFile)
# g.es("reading:",p.headString())
g.es("reading:",p_DOT_headString_PARENS_)
g.es_print('errors inhibited read @auto',fileName,color='red')
# -- node createNthChild3
g.es("dummy created")
# -- node handleLinesFollowingSentinel
g.es("using",s)
# g.es('',len(lines), "lines",m)
g.es('',len_LP_lines_RP_, "lines",m)
# -- node findChild4
g.es("write the @file node or use the Import Derived File command")
# -- node < < indicate that the node has been changed > >
# g.es("warning: updating changed text in",at.root.headString(),color="blue")
g.es("warning: updating changed text in",at_DOT_root_DOT_headString_PARENS_,color="blue")
# -- node < < bump at.correctedLines and tell about the correction > >
# g.es("correcting hidden node: t=",repr(at.t),color="red")
g.es("correcting hidden node: t=",repr_LP_at_DOT_t_RP_,color="red")
# -- node ignoreOldSentinel
g.es("ignoring 3.x sentinel:",s.strip(),color="blue")
# -- node < < handle @language > >
g.es("ignoring bad @language sentinel:",line,color="red")
# -- node < < handle @comment > >
g.es("ignoring bad @comment sentinel:",line,color="red")
# -- node copyAllTempBodyStringsToTnodes
# g.es("changed:",p.headString(),color="blue")
g.es("changed:",p_DOT_headString_PARENS_,color="blue")
# -- node < < read optional encoding param > >
g.es_print("bad encoding in derived file:",encoding)
# -- node < < set dirty and orphan bits on error > >
# g.es("not written:",at.outputFileName)
g.es("not written:",at_DOT_outputFileName)
# -- node < < say the command is finished > >
g.es("finished")
g.es("no @file nodes in the selected tree")
g.es("no dirty @file nodes")
# -- node writeAtAutoNodesHelper
g.es("finished")
g.es("no dirty @auto nodes in the selected tree")
g.es("no @auto nodes in the selected tree")
# -- node writeOneAtAutoNode & helpers
# g.es("not written:",at.outputFileName)
g.es("not written:",at_DOT_outputFileName)
# g.es("not written:",at.outputFileName)
g.es("not written:",at_DOT_outputFileName)
# -- node shouldWriteAtAutoNode
# g.es_print(p.headString(),'not written:',color='red')
g.es_print(p_DOT_headString_PARENS_,'not written:',color='red')
g.es_print('no children and less than 10 characters (excluding directives)',color='red')
# -- node writeMissing
g.es("finished")
g.es("no @file node in the selected tree")
# -- node hasSectionName
g.es('dubious brackets in',line)
# -- node < < handle @language > >
g.es("ignoring bad @language directive:",line,color="blue")
# -- node < < handle @comment > >
g.es("ignoring bad @comment directive:",line,color="blue")
# -- node replaceTargetFileIfDifferent
# g.es('unchanged:',self.shortFileName)
g.es('unchanged:',self_DOT_shortFileName)
# g.es('wrote:    ',self.shortFileName)
g.es('wrote:    ',self_DOT_shortFileName)
# g.es('created:  ',self.targetFileName)
g.es('created:  ',self_DOT_targetFileName)
# -- node < < report if the files differ only in line endings > >
# g.es("correcting line endings in:",self.targetFileName,color="blue")
g.es("correcting line endings in:",self_DOT_targetFileName,color="blue")
# -- node warnAboutOrpanAndIgnoredNodes
# g.es("parent node:",p.parent().headString(),color="blue")
g.es("parent node:",p_DOT_parent_PARENS__DOT_headString_PARENS_,color="blue")
# -- node writeException
# g.es("exception writing:",self.targetFileName,color="red")
g.es("exception writing:",self_DOT_targetFileName,color="red")
# g.es("exception deleting:",self.outputFileName,color="red")
g.es("exception deleting:",self_DOT_outputFileName,color="red")
# -- node < < Test for @header and @noheader > >
g.es("conflicting @header and @noheader directives")
# -- node < < Set comment strings from delims > >
g.es("unknown language: using Python comment delimiters")
# g.es("c.target_language:",c.target_language)
g.es("c_DOT_target_language:",c_DOT_target_language)
g.es('','delim1,delim2,delim3:','',delim1,'',delim2,'',delim3)
# ---- @thin leoBridge.py
g.es_print('','-------------------- @thin leoBridge.py',color='red')
# -- node < < try to get leoID from sys.leoID> >
# g.es("leoID=",g.app.leoID,spaces=False,color='red')
g.es("leoID=",g_DOT_app_DOT_leoID,spaces=False,color='red')
# -- node < < try to get leoID from "leoID.txt" > >
# g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('leoID=',g_DOT_app_DOT_leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
g.es('unexpected exception in app.setLeoID',color='red')
# -- node < < try to get leoID from os.getenv('USER') > >
# g.es_print("using os.getenv('USER'):",repr(theId),color='red')
g.es_print("using os.getenv('USER'):",repr_LP_theId_RP_,color='red')
# -- node reportDirectories
g.es('',kind,'directory','',':',theDir,color='blue')
# -- node createFrame (leoBridge)
g.es('file not found', fileName,'creating new window')
# ---- @thin leoChapters.py
g.es_print('','-------------------- @thin leoChapters.py',color='red')
# -- node cc.createChapterByName
g.es('created chapter',name,color='blue')
# -- node cc.error
g.es_print(s,color='red')
# ---- @thin leoColor.py
g.es_print('','-------------------- @thin leoColor.py',color='red')
# ---- @thin leoCommands.py
g.es_print('','-------------------- @thin leoCommands.py',color='red')
# -- node doCommand
# g.es(c.disableCommandsMessage,color='blue')
g.es(c_DOT_disableCommandsMessage,color='blue')
g.es('ignoring command: already executing a command.',color='red')
g.es("exception executing command")
# -- node c.signOnWithVersion
g.es("Leo Log Window...",color=color)
g.es(signon)
# g.es('',"python %s.%s.%s, %s\n%s" % (n1,n2,n3,g.app.gui.getFullVersion(c),version))
g.es('',"python %s.%s.%s, %s\n%s" % (n1,n2,n3,g_DOT_app_DOT_gui_DOT_getFullVersion_LP_c_RP_,version))
# -- node openWith and allies
g.es("unexpected exception in c.openWith")
# -- node < < create or recreate temp file as needed > >
# g.es("reopening:",g.shortFileName(path),color="blue")
g.es("reopening:",g_DOT_shortFileName_LP_path_RP_,color="blue")
# -- node < < execute a command to open path in external editor > >
g.es("exception executing:",command)
# -- node createOpenWithTempFile
# g.es("recreating:  ",g.shortFileName(path),color="red")
g.es("recreating:  ",g_DOT_shortFileName_LP_path_RP_,color="red")
# g.es("creating:  ",g.shortFileName(path),color="blue")
g.es("creating:  ",g_DOT_shortFileName_LP_path_RP_,color="blue")
# g.es("time: " + str(time))
g.es("time: " + str_LP_time_RP_)
g.es("exception creating temp file",color="red")
# -- node save (commands)
g.es("save commands disabled",color="purple")
# -- node saveAs
g.es("save commands disabled",color="purple")
# -- node saveTo
g.es("save commands disabled",color="purple")
# -- node readOutlineOnly
g.es("can not open:",fileName)
# -- node readFileIntoFile
g.es("can not open:",fileName)
# -- node writeFileFromNode
g.es_print('wrote:',fileName,color='blue')
g.es('can not write %s',fileName,color='red')
# -- node c.executeScript & helpers
g.es("end of script",color="purple",tabName=tabName)
g.es("no script selected",color="blue",tabName=tabName)
# -- node goToLineNumber & allies
# g.es("error handling:",root.headString())
g.es("error handling:",root_DOT_headString_PARENS_)
# -- node < < set root > >
g.es("no ancestor @file node: using script line numbers", color="blue")
# -- node < < read the file into lines > >
g.es("not found:",fileName)
# -- node < < 4.2: get node from gnx > >
g.es("not found:",vnodeName,color="red")
# -- node < < 4.x: scan for the node using tnodeList and n > >
# g.es_print("no child index for",root.headString(),color="red")
g.es_print("no child index for",root_DOT_headString_PARENS_,color="red")
# -- node < < set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false > >
g.es_print(s, color="red")
g.es_print(s, color="red")
g.es_print(s, color = "red")
# -- node < < set p to the first node whose headline matches vnodeName > >
g.es_print(s, color="red")
# -- node < < 3.x: scan for the node with the given childIndex > >
g.es("not found:",vnodeName, color="red")
# -- node < < put the cursor on line n2 of the body text > >
# g.es('only',len(lines),'lines',color="blue")
g.es('only',len_LP_lines_RP_,'lines',color="blue")
# -- node convertLineToVnodeNameIndexLine
g.es("bad @+leo sentinel")
# -- node < < handle delim while scanning backward > >
# g.es("line",str(n),"is a sentinel line")
g.es("line",str_LP_n_RP_,"is a sentinel line")
# -- node < < set vnodeName and (childIndex or gnx) from s > >
g.es("bad @+node sentinel")
# -- node convertAllBlanks
g.es("blanks converted to tabs in",count,"nodes")
# -- node convertAllTabs
g.es("tabs converted to blanks in",count,"nodes")
# -- node extract (test)
g.es("nothing follows section name",color="blue")
# -- node extractSection
g.es("nothing follows section name",color="blue")
# -- node < < Set headline for extractSection > >
g.es("selected text should start with a section name",color="blue")
# -- node extractSectionNames
g.es("selected text should contain one or more section names",color="blue")
# -- node < < trace head_lines, ins, tail_lines > >
g.es_print("head_lines: ",head_lines)
g.es_print("ins: ",ins)
g.es_print("tail_lines: ",tail_lines)
# -- node c.findMatchingBracket, helper and test
# g.es("unmatched",repr(ch))
g.es("unmatched",repr_LP_ch_RP_)
# -- node getTime
g.es("time.strftime not available on this platform",color="blue")
# -- node addComments (test)
g.es('no text selected',color='blue')
# -- node deleteComments (test)
g.es('no text selected',color='blue')
g.es('',"'%s'" % (d2),"not found",color='blue')
g.es('',"'%s'" % (d3),"not found",color='blue')
# -- node showFindPanel
# g.es('the',g.app.gui.guiName(),
#             'gui does not support a stand-alone find dialog',color='blue')
g.es('the',g_DOT_app_DOT_gui_DOT_guiName_PARENS_,
            'gui does not support a stand-alone find dialog',color='blue')
# -- node notValidInBatchMode
g.es('the',commandName,"command is not valid in batch mode")
# -- node c.checkOutline
g.es("all tests enabled: this may take awhile",color="blue")
# -- node < < remove unused tnodeList > >
g.es_print(s,color="blue")
# -- node < < do full tests > >
g.es('','.',newline=False)
# -- node < < give test failed message > >
g.es_print(s,color="red")
# -- node < <print summary message > >
g.es_print('',count,'nodes checked',errors,'errors',color=color)
# -- node checkAllPythonCode
g.es("check complete",color="blue")
# -- node < < print dots > >
g.es('','.',newline=False)
# -- node checkPythonCode
g.es("checking Python code   ")
g.es("surprise in checkPythonNode")
g.es("check complete",color="blue")
# -- node < < print dots > >
g.es('','.',newline=False)
# -- node checkPythonNode
g.es_print(s,color="blue")
# -- node tabNannyNode
g.es("ParserError in",headline,color="blue")
# g.es('',str(msg))
g.es('',str_LP_msg_RP_)
g.es("TokenError in",headline,color="blue")
# g.es('',str(msg))
g.es('',str_LP_msg_RP_)
g.es("indentation error in",headline,"line",badline,color="blue")
g.es(message)
g.es("offending line:\n",line2)
# -- node prettyPrintNode
g.es("error pretty-printing",h,"not changed.",color="blue")
# -- node markChangedHeadlines
g.es("done",color="blue")
# -- node markChangedRoots
g.es("done",color="blue")
# -- node markClones
g.es('the current node is not a clone',color='blue')
# -- node cantMoveMessage
g.es("can't move node out of",kind,color="blue")
# -- node c.toggleSparseMove
g.es(tag,'=',sparseMove,color='blue')
# -- node goToNextClone
# g.es('not a clone:',p.headString(),color='blue')
g.es('not a clone:',p_DOT_headString_PARENS_,color='blue')
g.es("done",color="blue")
# -- node findNextClone
g.es('no more clones',color='blue')
# -- node goToNextDirtyHeadline
g.es("done",color="blue")
# -- node goToNextMarkedHeadline
g.es("done",color="blue")
# -- node openCompareWindow
# g.es('the',g.app.gui.guiName(),
#             'gui does not support the compare window',color='blue')
g.es('the',g_DOT_app_DOT_gui_DOT_guiName_PARENS_,
            'gui does not support the compare window',color='blue')
# -- node openLeoSettings and openMyLeoSettings
g.es('',name,"not found in",configDir)
g.es('',name,"not found in",configDir,"or",homeDir)
# -- node openLeoScripts
g.es('not found:',fileName)
# -- node leoDocumentation
g.es("not found:",name)
# -- node leoHome
g.es("not found:",url)
# -- node leoPlugins
g.es("not found:",name)
# -- node leoTutorial (version number)
g.es("not found:",url)
# -- node leoUsersGuide
g.es("not found:",url)
# -- node initEncoding
g.es("bad", "%s: %s" % (encodingName,encoding))
# ---- @thin leoConfig.py
g.es_print('','-------------------- @thin leoConfig.py',color='red')
# -- node error
g.es(s,color="blue")
# -- node doIfGui
g.es_print(s,color='blue')
# -- node doMenus & helper
# g.es_print('creating menu from',c.shortFileName(),color='blue')
g.es_print('creating menu from',c_DOT_shortFileName_PARENS_,color='blue')
# -- node set (parseBaseClass)
g.es("over-riding setting:",name,"from",path)
# -- node traverse (parserBaseClass)
# g.es_print('skipping settings in',p.headString(),color='blue')
g.es_print('skipping settings in',p_DOT_headString_PARENS_,color='blue')
# -- node initEncoding
g.es("g.app.config: bad encoding:","%s: %s" % (ivar,encoding))
# -- node getValFromDict
# g.es_print('warning: ignoring',bunch.kind,'',setting,'is not',requestedType,color='red')
g.es_print('warning: ignoring',bunch_DOT_kind,'',setting,'is not',requestedType,color='red')
g.es_print('there may be conflicting settings!',color='red')
# -- node createRecentFiles
g.es_print('created',fileName,color='red')
g.es_print('can not create',fileName,color='red')
# -- node writeRecentFilesFileHelper
g.es('unexpected exception writing',fileName,color='red')
# -- node g.app.config.printSettings & helper
g.es('','%s %s = %s' % (letter,key,val))
# ---- @thin leoEditCommands.py
g.es_print('','-------------------- @thin leoEditCommands.py',color='red')
# -- node dynamicCompletion
g.es('command not ready yet',color='blue')
# -- node dynamicExpansion
g.es('command not ready yet',color='blue')
# -- node listAbbrevs
g.es('','%s=%s' % (z,s))
# -- node readAbbreviations
g.es('can not open',fileName)
# -- node writeAbbreviations
g.es('can not create',fileName)
# -- node listBuffers & listBuffersAlphabetically
g.es('buffers...')
g.es('',name)
g.es('buffers...')
g.es('',name)
# -- node debug & helper
g.es("info string")
# -- node findDebugger
g.es('debugger does not exist:',debugger,color='blue')
g.es('no debugger found.')
# -- node enable/disableGcTrace
g.es('enabled verbose gc stats',color='blue')
g.es('enabled brief gc stats',color='blue')
# -- node printFocus
# g.es_print('      hasFocusWidget:',c.widget_name(c.hasFocusWidget))
g.es_print('      hasFocusWidget:',c_DOT_widget_name_LP_c_DOT_hasFocusWidget_RP_)
# g.es_print('requestedFocusWidget:',c.widget_name(c.requestedFocusWidget))
g.es_print('requestedFocusWidget:',c_DOT_widget_name_LP_c_DOT_requestedFocusWidget_RP_)
# g.es_print('           get_focus:',c.widget_name(c.get_focus()))
g.es_print('           get_focus:',c_DOT_widget_name_LP_c_DOT_get_focus_PARENS__RP_)
# -- node appendImageDictToList
g.es('can not load image:',path)
# -- node getImage
g.es('can not import Image module from PIL',color='blue')
g.es('can not import ImageTk module',color='blue')
# -- node initBracketMatcher
g.es_print('bad open/close_flash_brackets setting: using defaults')
# -- node viewLossage
g.es('lossage...')
# g.es('',stroke or d.get(ch) or ch or 'None')
g.es('',stroke or d_DOT_get_LP_ch_RP_ or ch or 'None')
# -- node clear/set/ToggleExtendMode
# g.es('extend mode',g.choose(val,'on','off'),color='red')
g.es('extend mode',g_DOT_choose_LP_val_COMMA__SQ_on_SQ__COMMA__SQ_off_SQ__RP_,color='red')
# -- node swapWords
g.es('swap-words command not ready yet',color='blue')
# -- node getReadableTextFile
g.es('can not open',fileName)
# -- node saveFile
g.es('can not create',fileName)
# -- node helpForMinibuffer
g.es_print('',s)
# -- node helpForCommand
g.es('','%s:%s\n%s\n' % (commandName,bindings,s),color='blue')
# -- node aproposAutocompletion
g.es_print('',s)
# -- node aproposBindings
g.es_print('',s)
# -- node aproposDebuggingCommands
g.es_print('',s)
# -- node aproposFindCommands
g.es_print('',s)
# -- node loadFile & helpers
g.es('can not open',fileName)
# -- node saveMacros & helper
g.es('can not create',fileName)
# -- node findNextMatch (query-replace)
g.es('command not ready yet',color='blue')
# -- node Find options wrappers
# g.es('collapse_nodes_during_finds',c.config.getBool('collapse_nodes_during_finds'))
g.es('collapse_nodes_during_finds',c_DOT_config_DOT_getBool_LP__SQ_collapse_nodes_during_finds_SQ__RP_)
# -- node scolorizer LATER
g.es('command not ready yet',color='blue')
# -- node init_aspell
g.es_print('can not open dictionary file:',dictionaryFileName, color='red')
g.es_print('can not open Aspell',color='red')
# -- node readDictionary
g.es("can not open local dictionary",fileName,"using a blank one instead")
# -- node add
g.es("adding ", color= "blue", newline= False)
# g.es('','%s' % self.currentWord)
g.es('','%s' % self_DOT_currentWord)
# g.es("can not add",self.currentWord,"to dictionary",color="red")
g.es("can not add",self_DOT_currentWord,"to dictionary",color="red")
# -- node find & helpers
g.es("no more misspellings")
# -- node hide
g.es(message,color='blue')
# -- node ignore
g.es("ignoring ",color= "blue", newline= False)
# g.es('','%s' % self.currentWord)
g.es('','%s' % self_DOT_currentWord)
# -- node report
g.es_print(message,color='blue')
# ---- @thin leoFileCommands.py
g.es_print('','-------------------- @thin leoFileCommands.py',color='red')
# -- node processingInstruction (stylesheet)
g.es('','%s: %s' % (target,data),color='blue')
# -- node startVnodes
# g.es("reading:",self.fileName)
g.es("reading:",self_DOT_fileName)
# -- node checkLeoFile (fileCommands)
g.es_print('check-leo-file passed',color='blue')
# g.es_print('check-leo-file failed:',str(message),color='red')
g.es_print('check-leo-file failed:',str_LP_message_RP_,color='red')
# -- node getLeoOutlineFromClipboard & helpers
g.es("invalid Paste As Clone",color="blue")
g.es("the clipboard is not valid ",color="blue")
# -- node < < warn on read-only files > >
g.es("read only:",fileName,color="red")
# -- node newTnode
# g.es("bad tnode index:",str(index),"using empty text.")
g.es("bad tnode index:",str_LP_index_RP_,"using empty text.")
# g.es("newTnode: unexpected index type:",type(index),index,color="red")
g.es("newTnode: unexpected index type:",type_LP_index_RP_,index,color="red")
# -- node getAllLeoElements
g.es("reading:",fileName)
# -- node getPrefs
# g.es("default tangle directory not found:",c.tangle_directory)
g.es("default tangle directory not found:",c_DOT_tangle_directory)
# -- node getTnode
# g.es("no tnode with index:",str(index),"the text will be discarded")
g.es("no tnode with index:",str_LP_index_RP_,"the text will be discarded")
# -- node < < handle unknown attributes > >
g.es_print("unknown attributes for tnode",color = "blue")
# g.es_print('',"%s = %s" % (key,attrDict.get(key)))
g.es_print('',"%s = %s" % (key,attrDict_DOT_get_LP_key_RP_))
# -- node < < handle unknown vnode attributes > >
# g.es_print("unknown attributes for",v.headString(),color="blue")
g.es_print("unknown attributes for",v_DOT_headString_PARENS_,color="blue")
# g.es_print('',"%s = %s" % (key,attrDict.get(key)))
g.es_print('',"%s = %s" % (key,attrDict_DOT_get_LP_key_RP_))
# -- node getExistingVnode
g.es("missing vnode:",headline,color="red")
g.es("probably an outline topology error.")
# -- node getXmlVersionTag
g.es("invalid encoding in .leo file:",encoding,color="red")
# -- node getSaxUa
g.es_print('unexpected exception converting hexlified string to string')
# -- node parse_leo_file
g.es_print('error parsing',inputFileName,color='red')
g.es_print('unexpected exception parsing',inputFileName,color='red')
# -- node save (fileCommands)
g.es("clearing undo")
# -- node putSavedMessage
# g.es("saved:","%s%s" % (zipMark,g.shortFileName(fileName)))
g.es("saved:","%s%s" % (zipMark,g_DOT_shortFileName_LP_fileName_RP_))
# -- node deleteFileWithMessage
g.es("read only",color="red")
g.es("exception deleting backup file:",fileName)
# -- node putUnknownAttributes & helper
g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
# -- node putUaHelper
g.es("ignoring non-string attribute",key,"in",torv,color="blue")
g.es('putUaHelper: unexpected pickling exception',color='red')
g.es("ignoring non-pickleable attribute",key,"in",torv,color="blue")
# -- node < < Append tnodeList and unKnownAttributes to attrs> >
# g.es("deleting tnode list for",p.headString(),color="blue")
g.es("deleting tnode list for",p_DOT_headString_PARENS_,color="blue")
# -- node < < issue informational messages > >
# g.es("writing erroneous:",p.headString(),color="blue")
g.es("writing erroneous:",p_DOT_headString_PARENS_,color="blue")
# -- node putDescendentUnknownAttributes
g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
g.es("ignoring bad unknownAttributes key",key,"in",p,color="blue")
g.es('putDescendentUnknownAttributes: unexpected pickling exception',color='red')
g.es("putDescendentUnknownAttributes can't happen 2",color='red')
# -- node write_Leo_file
# g.es_print('len',len(s),'putCount',self.putCount)
g.es_print('len',len_LP_s_RP_,'putCount',self_DOT_putCount)
g.es("exception writing:",fileName)
# -- node < < return if the .leo file is read-only > >
g.es("can not create: read only:",fileName,color="red")
# -- node < < create backup file > >
g.es("read only",color="red")
# -- node < < rename backupName to fileName > >
g.es("restoring",fileName,"from",backupName)
# -- node writeAtFileNodes
g.es("auto-saving outline",color="blue")
# -- node writeDirtyAtFileNodes
g.es("auto-saving outline",color="blue")
# -- node writeMissingAtFileNodes
g.es("auto-saving outline",color="blue")
# -- node writeOutlineOnly
g.es('done',color='blue')
# ---- @thin leoGlobals.py
g.es_print('','-------------------- @thin leoGlobals.py',color='red')
# -- node computeLoadDir
g.es("load dir:",loadDir,color="blue")
# -- node set_language
# g.es("ignoring:",g.get_line(s,i))
g.es("ignoring:",g_DOT_get_line_LP_s_COMMA_i_RP_)
# -- node < < set theDict for @ directives > >
g.es("warning: conflicting values for",word,color="blue")
# -- node < < set theDict["root"] for noweb * chunks > >
# g.es('',g.angleBrackets("*") + "= requires @root in the headline")
g.es('',g_DOT_angleBrackets_LP__DQ___DQ__RP_ + "= requires @root in the headline")
# -- node g.scanAtEncodingDirective
g.es("invalid @encoding:",encoding,color="red")
# -- node g.scanAtLineendingDirective
g.es("invalid @lineending directive:",e,color="red")
# -- node g.scanAtPagewidthDirective
g.es("ignoring",s,color="red")
# -- node < < scan another @root option > >
# g.es("modes conflict in:",g.get_line(s,i))
g.es("modes conflict in:",g_DOT_get_line_LP_s_COMMA_i_RP_)
# g.es("modes conflict in:",g.get_line(s,i))
g.es("modes conflict in:",g_DOT_get_line_LP_s_COMMA_i_RP_)
g.es("unknown option:",z_opt,"in",z_line)
# -- node g.scanAtTabwidthDirective
g.es("ignoring",s,color="red")
# -- node alert
g.es('',message)
# -- node es_dump
g.es_print('',title)
g.es_print('',aList)
# -- node es_error
g.es(s,color=color)
# -- node es_event_exception
g.es("exception handling ",eventName,"event")
g.es('',i)
# -- node es_exception_type
# g.es_print('','%s, %s' % (exctype.__name__, value),color=color)
g.es_print('','%s, %s' % (exctype_DOT___name__, value),color=color)
# -- node getLastTracebackFileAndLineNumber
# g.es_print('',repr(val))
g.es_print('',repr_LP_val_RP_)
# g.es_print('',repr(data))
g.es_print('',repr_LP_data_RP_)
# -- node Timing
# g.es('',"%s %6.3f" % (message,(time.clock()-start)))
###g.es('',"%s %6.3f" % (message,(time_DOT_clock_PARENS_-start)))
# -- node g.create_temp_file
###g.es('unexpected exception in g.create_temp_file',color='red')
# -- node g.is_sentinel
g.es("can't happen: is_sentinel",color="red")
# -- node g.makeAllNonExistentDirectories
g.es("created directory:",path)
g.es("exception creating directory:",path)
# -- node g.openLeoOrZipFile
g.es("can not open:",fileName,color="blue")
# -- node g.setGlobalOpenDir
# g.es('current directory:',g.app.globalOpenDir)
g.es('current directory:',g_DOT_app_DOT_globalOpenDir)
# -- node g.update_file_if_changed
g.es('','%12s: %s' % (kind,file_name))
g.es("rename failed: no file created!",color="red")
g.es('',file_name," may be read-only or in use")
# -- node g.utils_remove
g.es("exception removing:",fileName)
# -- node g.utils_rename
g.es('exception renaming',src,'to',dst,color='red')
# -- node g.utils_chmod
g.es("exception in os.chmod",fileName)
# -- node enable_gc_debug
g.es('can not import gc module',color='blue')
# -- node g.doHook
g.es_print(s,color="blue")
# -- node g.plugin_signon
# g.es('',"...%s.py v%s: %s" % (
#             m.__name__, m.__version__, g.plugin_date(m)))
g.es('',"...%s.py v%s: %s" % (
            m_DOT___name__, m_DOT___version__, g_DOT_plugin_date_LP_m_RP_))
# -- node mini test of es
g.es(s)
g.es_print(s)
# -- node es_print
# -- node @@test g.es_print
g.es_print('\ntest of es_print: Ă',color='red',newline=False)
g.es_print('after')
g.es_print('done')
# -- node es_trace
# -- node < < scan another @file option > >
g.es("using -asis option in:",h)
g.es("ignoring redundant -noref in:",h)
g.es("ignoring redundant -nosent in:",h)
g.es("using -thin option in:",h)
g.es("unknown option:",z_opt,"in",h)
# -- node scanError
g.es('',s)
# -- node skip_pp_if
g.es("#if and #else parts have different braces:",start_line)
g.es("no matching #endif:",start_line)
# -- node g.initScriptFind (set up dialog)
g.es("no Find script node",color="red")
# -- node g.handleScriptException
g.es("exception executing script",color='blue')
# -- node < < dump the lines near the error > >
g.es_print('',s)
g.es('',s,newline=False)
# -- node reportBadChars
g.es(s2,color='red')
g.es(s2,color='red')
# -- node g.executeScript
g.es("exception executing",name,color="red")
# -- node g.getScript
g.es_print("unexpected exception in g.getScript")
# -- node g.cantImport
g.es_print('',s,color="blue")
# -- node g.importFromPath
g.es_print("exception in g.importFromPath",color='blue')
g.es_print("unexpected exception in g.importFromPath(%s)" %
                    (name),color='blue')
# -- node g.init_zodb
g.es('g.init_zodb: can not import ZODB')
g.es('g.init_zodb: exception creating ZODB.DB instance')
# ---- @thin leoImport.py
g.es_print('','-------------------- @thin leoImport.py',color='red')
# -- node exportHeadlines
g.es("can not open",fileName,color="blue")
# -- node flattenOutline
g.es("can not open",fileName,color="blue")
# -- node outlineToWeb
g.es("can not open",fileName,color="blue")
# -- node < < Read file into s > >
g.es("can not open",fileName, color="blue")
# -- node < < set delims from the header line > >
g.es("invalid @+leo sentinel in",fileName)
# -- node < < Write s into newFileName > >
g.es("created:",newFileName)
g.es("exception creating:",newFileName)
# -- node < < open filename to f, or return > >
g.es("exception opening:",filename)
# -- node error
g.es('',s)
# -- node < < Read file into s > >
g.es("can not open", "%s%s" % (z,fileName),color='red')
# -- node readAtAutoNodes (importCommands) & helper
# g.es_print('ignoring',p.headString(),color='blue')
g.es_print('ignoring',p_DOT_headString_PARENS_,color='blue')
g.es(message,color='blue')
# -- node importFilesCommand
g.es("imported",fileName,color="blue")
# -- node importFlattenedOutline
g.es("not a valid MORE file",fileName)
# -- node < < Read the file into array > >
g.es("can not open",fileName, color="blue")
# -- node scanWebFile (handles limbo)
g.es("can not import",fileName, color="blue")
# -- node cstLookup
g.es('',"****** %s" % (target),"is also a prefix of",s)
g.es("replacing",target,"with",s)
# -- node scanPHPText
g.es_print('seems to be mixed HTML and PHP:',fileName)
# -- node compareHelper
# g.es_print('first mismatched line at line',str(i+1))
g.es_print('first mismatched line at line',str_LP_i_1_RP_)
g.es_print('original line: ',line1)
g.es_print('generated line:',line2)
g.es_print('missing lines')
# g.es_print('',repr(line))
g.es_print('',repr_LP_line_RP_)
# -- node checkLeadingWhitespace
# g.es_print('line:',repr(line),color='red')
g.es_print('line:',repr_LP_line_RP_,color='red')
# -- node reportMismatch
# -- node insertIgnoreDirective
g.es_print('inserting @ignore',color='blue')
# -- node error, oops, report and warning
g.es_print('',s,color='red')
g.es_print('error:',s,color='red')
g.es_print('warning:',s,color='red')
# ---- @thin leoKeys.py
g.es_print('','-------------------- @thin leoKeys.py',color='red')
# -- node showAutocompleter/CalltipsStatus
g.es(s,color='red')
g.es(s,color='red')
# -- node computeCompletionList
# g.es('',z,tabName=self.tabName)
g.es('',z,tabName=self_DOT_tabName)
# -- node info
g.es('no docstring for',word,color='blue')
g.es('',doc,tabName='Info')
g.es('no docstring for',word,color='blue')
# -- node scan
g.es("This is for testing if g.es blocks in a thread", color = 'pink' )
# -- node scanOutline
g.es_print('scanning for auto-completer...')
g.es('','.',newline=False)
g.es_print('\nauto-completer scan complete',color='blue')
# -- node createClassObjectFromString
g.es_print('unexpected exception in',computeProxyObject)
# -- node forgivingParser
g.es_print('syntax error in class node: can not continue')
# g.es_print('syntax error: deleting',p.headString())
g.es_print('syntax error: deleting',p_DOT_headString_PARENS_)
# -- node bindKey
g.es_print('exception binding',shortcut,'to',commandName)
# -- node < < give warning and return if we try to bind to Enter or Leave > >
g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
# -- node < < remove previous conflicting definitions from bunchList > >
# g.es_print('redefining',z,'in',b2.pane,'to',commandName,'in',pane,color='red')
g.es_print('redefining',z,'in',b2_DOT_pane,'to',commandName,'in',pane,color='red')
# -- node k.initAbbrev
g.es_print('bad abbrev:',key,'unknown command name:',commandName,color='blue')
# -- node k.makeMasterGuiBinding
# g.es_print('exception binding',bindStroke,'to',c.widget_name(w),color='blue')
g.es_print('exception binding',bindStroke,'to',c_DOT_widget_name_LP_w_RP_,color='blue')
# -- node callStateFunction
# g.es_print('no state function for',k.state.kind,color='red')
g.es_print('no state function for',k_DOT_state_DOT_kind,color='red')
# -- node k.show/hide/toggleMinibuffer
g.es('minibuffer hidden',color='red')
g.es('',commandName,'is bound to:',shortcut)
# -- node printBindings & helper
g.es('no bindings')
g.es('','%s %s' % (sep, prefix),tabName=tabName)
g.es('','%s %s' % (sep, 'Plain Keys',),tabName=tabName)
# -- node printBindingsHelper
# g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
# g.es('','%*s %*s %s' % (-n1,s1,-(min_LP_12_COMMA_n2_RP_),s2,s3),tabName='Bindings')
# -- node printCommands
# g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName=tabName)
# g.es('','%*s %*s %s' % (-n1,s1,-(min_LP_12_COMMA_n2_RP_),s2,s3),tabName=tabName)
# -- node repeatComplexCommand & helper
g.es('no previous command',color='blue')
# -- node k.registerCommand
g.es_print('redefining',commandName, color='red')
# g.es_print('','@command: %s = %s' % (
#                 commandName,k.prettyPrintKey(stroke)),color='blue')
g.es_print('','@command: %s = %s' % (
                commandName,k_DOT_prettyPrintKey_LP_stroke_RP_),color='blue')
g.es_print('','@command: %s' % (commandName),color='blue')
# -- node createModeBindings
g.es_print('no such command:',commandName,'Referenced from',modeName)
# -- node modeHelpHelper
g.es('','%s mode\n\n' % modeName,tabName=tabName)
###g.es('','%*s %s' % (n,s1,s2),tabName=tabName)
# -- node k.computeCompletionList
# g.es('','%*s %*s %s' % (-(min(20,n1)),s1,n2,s2,s3),tabName=tabName)
# g.es('','%*s %*s %s' % (-(min_LP_20_COMMA_n1_RP_),s1,n2,s2,s3),tabName=tabName)
# -- node k.showFileNameTabList
g.es('',s,tabName=tabName)
# ---- @thin leoNodes.py
g.es_print('','-------------------- @thin leoNodes.py',color='red')
# -- node v.bodyString
g.es_print('',s,color="red")
# -- node v.headString & v.cleanHeadString
g.es_print('',s,color="red")
# -- node scanGnx
# g.es("scanGnx: unexpected index type:",type(s),'',s,color="red")
g.es("scanGnx: unexpected index type:",type_LP_s_RP_,'',s,color="red")
# ---- @thin leoPlugins.py
g.es_print('','-------------------- @thin leoPlugins.py',color='red')
# -- node loadHandlers & helper
# -- node loadOnePlugin
g.es_print('plugin',moduleName,'already loaded',color="blue")
g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
g.es('exception loading plugin',color='red')
g.es_print('can not load enabled plugin:',moduleName,color="red")
g.es_print('loaded plugin:',moduleName,color="blue")
# -- node printHandlers
g.es_print('handlers for',moduleName,'...')
g.es_print('all plugin handlers...')
g.es_print('','%25s %s' % (tag,key))
# -- node printPlugins
g.es_print('enabled plugins...')
g.es_print('',key)
# -- node registerExclusiveHandler
g.es("*** Two exclusive handlers for","'%s'" % (tag))
# ---- @thin leoPymacs.py
g.es_print('','-------------------- @thin leoPymacs.py',color='red')
# -- node open
g.es_print('','leoPymacs.open:','no file name')
g.es_print('','leoPymacs.open:',c)
g.es_print('','leoPymacs.open:','can not open',fileName)
# ---- @thin leoTangle.py
g.es_print('','-------------------- @thin leoTangle.py',color='red')
# -- node < < call tangle_done.run() or untangle_done.run() > >
g.es("can not execute","tangle_done.run()")
g.es("can not execute","tangle_done.run()")
# -- node initTangleCommand
g.es("tangling...")
# -- node initUntangleCommand
g.es("untangling...")
# -- node tangle
g.es("looking for a parent to tangle...")
g.es("tangling parent")
g.es("tangle complete")
# -- node tangleAll
g.es("tangle complete")
# -- node tangleMarked
g.es("tangle complete")
# -- node untangle
g.es("untangle complete")
# -- node untangleAll
g.es("untangle complete")
# -- node untangleMarked
g.es("untangle complete")
# -- node untangleRoot (calls cleanup)
g.es('','@root ' + path)
# -- node < < return if @silent or unknown language > >
g.es("@comment disables untangle for",path, color="blue")
# g.es('','@%s' % (self.print_mode),"inhibits untangle for",path, color="blue")
g.es('','@%s' % (self_DOT_print_mode),"inhibits untangle for",path, color="blue")
# -- node < < Read the file into file_buf  > > in untangleRoot
g.es("error reading:",path)
# -- node tangle.put_all_roots
g.es("can not create temp file")
g.es("unchanged:",file_name)
# -- node st_check
# g.es('',' ' * 4,'warning:',lp,'',section.name,'',rp,'has been defined but not used.')
g.es('',' ' * 4,'warning:',lp,'',section_DOT_name,'',rp,'has been defined but not used.')
# -- node < <check for duplicate code definitions > >
g.es('warning: possible duplicate definition of:',s)
# -- node ust_warn_about_orphans
# g.es("warning:",'%s%s%s' % (lp,part.name,rp),"is not in the outline")
g.es("warning:",'%s%s%s' % (lp,part_DOT_name,rp),"is not in the outline")
# -- node update_def (pass 2)
# g.es("***Updating:",p.headString())
g.es("***Updating:",p_DOT_headString_PARENS_)
# -- node < < Test for @comment and @language > >
g.es("ignoring: @comment",z)
# -- node < < handle absolute @path > >
g.es("relative_path_base_directory:",base)
g.es("relative path in @path directive:",relative_path)
# -- node < < Test for @header and @noheader > >
g.es("conflicting @header and @noheader directives")
# -- node < < handle absolute path > >
g.es("relative_path_base_directory:",base)
g.es('',kind,"directory:",dir2)
# ---- @thin leoTest.py
g.es_print('','-------------------- @thin leoTest.py',color='red')
# -- node runTimerOnNode
# g.es_print("count:",count,"time/count:",ratio,'',p.headString())
g.es_print("count:",count,"time/count:",ratio,'',p_DOT_headString_PARENS_)
# -- node runTests
g.es('running',kind,'unit tests',color='blue')
g.es_print('no @test or @suite nodes in selected outline')
# -- node checkFileSyntax
g.es("syntax error in:",fileName,color="blue")
# -- node checkFileTabs
g.es_print("Token error in",fileName,color="blue")
g.es_print('',msg)
g.es_print("Indentation error in",fileName,"line",badline,color="blue")
g.es_print('',message)
g.es_print("offending line...")
g.es_print('',line)
# -- node importAllModulesInPath
g.es("path does not exist:",path)
# ---- @thin leoUndo.py
g.es_print('','-------------------- @thin leoUndo.py',color='red')
# -- node < < set newBead if we can't share the previous bead > >
g.es('exception in','setUndoRedoTypingParams',color='blue')
# -- node redoGroup
g.es("redo",count,"instances")
# -- node undoGroup
g.es("undo",count,"instances")
g.app.translateToUpperCase=False
#@nonl
#@-node:ekr.20080220082727:@scan_g.es_results
#@+node:ekr.20031218072017.1978:app.setLeoID
def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = not g.app.unitTesting
    << return if we can set leoID from sys.leoID >>
    << return if we can set leoID from "leoID.txt" >>
    << return if we can set leoID from os.getenv('USER') >>
    << put up a dialog requiring a valid id >>
    << attempt to create leoID.txt >>
#@+node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose and not g.app.unitTesting:
        g.es_print("leoID=",g.app.leoID,spaces=False,color='red')
    # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
    g.app.leoID = g.app.leoID.replace('.','-')
    return
else:
    g.app.leoID = None
#@-node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
#@+node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
                g.app.leoID = g.app.leoID.replace('.','-')
                if verbose and not g.app.unitTesting:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                return
            elif verbose and not g.app.unitTesting:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es_print('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
#@+node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
try:
    theId = os.getenv('USER')
    if theId:
        if verbose and not g.app.unitTesting:
            g.es("using os.getenv('USER'):",repr(theId),color='red')
        g.app.leoID = theId
        # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
        g.app.leoID = g.app.leoID.replace('.','-')
        return

except Exception:
    pass
#@-node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
#@+node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
# New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()

# Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
g.app.leoID = g.app.leoID.replace('.','-')

# g.trace(g.app.leoID)
g.es('leoID=',repr(g.app.leoID),spaces=False,color="blue")
#@-node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                g.es_print('',tag,'created in',theDir,color='red')
                return
        except IOError:
            pass

        g.es('can not create',tag,'in',theDir,color='red')
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@-node:ekr.20031218072017.1978:app.setLeoID
#@+node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
                g.app.leoID = g.app.leoID.replace('.','-')
                if verbose and not g.app.unitTesting:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                return
            elif verbose and not g.app.unitTesting:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es_print('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                g.es_print('',tag,'created in',theDir,color='red')
                return
        except IOError:
            pass

        g.es('can not create',tag,'in',theDir,color='red')
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@+node:ekr.20070426092031:Consider another way to compute home directory
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4281562
By: ktenney

I don't know if this is a resolved issue, here's another approach,
looks like a good one.

email link
http://murl.se/24201

python.org os.path doc
http://murl.se/24202

>>> import os
>>> lin_key, win_key = "home", "Documents"
>>> homedir = os.path.expanduser('~')
>>> if os.name == 'nt': os_key = win_key
>>> if os.name == 'posix': os_key = lin_key
>>> print homedir.find(os_key) > -1
True

#@-node:ekr.20070426092031:Consider another way to compute home directory
#@+node:ekr.20070227094232:getLeoID
def getLeoID (self):

    import os
    import sys

    g = self.g ; tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = False and not g.app.unitTesting
    << try to get leoID from sys.leoID >>
    if not g.app.leoID:
        << try to get leoID from "leoID.txt" >>
    if not g.app.leoID:
        << try to get leoID from os.getenv('USER') >>
    return g.app.leoID
#@+node:ekr.20070227094232.1:<< try to get leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose: g.es("leoID=",g.app.leoID,spaces=False,color='red')
#@nonl
#@-node:ekr.20070227094232.1:<< try to get leoID from sys.leoID>>
#@+node:ekr.20070227094232.2:<< try to get leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                if verbose:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                break
            elif verbose:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20070227094232.2:<< try to get leoID from "leoID.txt" >>
#@+node:ekr.20070227094232.3:<< try to get leoID from os.getenv('USER') >>
try:
    theId = os.getenv('USER')
    if theId:
        if verbose: g.es_print("using os.getenv('USER'):",repr(theId),color='red')
        g.app.leoID = theId

except Exception:
    pass
#@-node:ekr.20070227094232.3:<< try to get leoID from os.getenv('USER') >>
#@-node:ekr.20070227094232:getLeoID
#@+node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
def openLeoSettings (self,event=None):
    '''Open leoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('leoSettings.leo')

def openMyLeoSettings (self,event=None):
    '''Open myLeoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('myLeoSettings.leo')

def openSettingsHelper(self,name):
    c = self
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)
    ok = g.os_path_exists(fileName)
    if ok:
        ok, frame = g.openWithFileName(fileName,c)
        if ok: return

    # Look in homeDir second.
    if configDir == loadDir:
        g.es('',name,"not found in",configDir)
    else:
        fileName = g.os_path_join(homeDir,name)
        ok = g.os_path_exists(fileName)
        if ok:
            ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es('',name,"not found in",configDir,"or",homeDir)
#@-node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():

    """Returns the user's home directory."""

    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
#@-node:ekr.20041117151301:computeHomeDir
#@-node:ekr.20080407090400.4:Found: homeDir
#@-node:ekr.20080407090400.3:Added install nodes re Leo's home directory
#@+node:ekr.20080408060320.792:Disallow non-ascii characters in minibuffer
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@-node:ekr.20080408060320.792:Disallow non-ascii characters in minibuffer
#@-node:ekr.20080408060320.783:Features
#@-node:ekr.20080408060320.4:4.5 a1
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
