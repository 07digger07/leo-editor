.. @+leo-ver=5-thin
.. @+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
.. @@language rest

.. @+all
.. @+node:ekr.20141108083107.6: ** b1
.. @+node:ekr.20141108045647.2: *3* Removed stand-alone globals
.. @+node:ekr.20141108083107.4: *3* The spell checker handles apostrophes correctly
@language rest

Previously, when checking "didn't" the spell checker would complain that
"didn" wasn't in the dictionary. Now it checks (and accepts) "didn't".

We have all been putting up with this annoyance for *far* to long. Changing
just two lines of code was all that was required.
.. @+node:ekr.20141108090310.8: *3* Added support for command history
@language rest

After Alt-x puts you in the minibuffer, you can now use UpArrow and
DownArrow keys to cycle through previous "complex" commands, that is,
commands entered via Alt-x<command-name><return>.

For example, Alt-x UpArrow is roughly equivalent to Ctrl-p.

This completes one of the top four wishlist items at:
https://github.com/leo-editor/leo-editor/issues/93
.. @+node:ekr.20061031170011.3: *4* k.Minibuffer
# These may be overridden, but this code is now gui-independent.
.. @+node:ekr.20061031170011.9: *5* k.extendLabel
def extendLabel(self,s,select=False,protect=False):

    trace = False and not g.unitTesting

    k = self ; c = k.c ; w = self.w
    if not (w and s): return

    if trace: g.trace(s)

    c.widgetWantsFocusNow(w)

    w.insert('end',s)

    if select:
        i,j = k.getEditableTextRange()
        w.setSelectionRange(i,j,insert=j)

    if protect:
        k.protectLabel()
.. @+node:ekr.20061031170011.13: *5* k.getEditableTextRange
def getEditableTextRange (self):

    k = self ; w = self.w
    s = w.getAllText()
    i = len(k.mb_prefix)
    j = len(s)
    return i,j
.. @+node:ekr.20061031170011.5: *5* k.getLabel
def getLabel (self,ignorePrompt=False):

    k = self ; w = self.w
    if not w: return ''

    s = w.getAllText()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''
.. @+node:ekr.20080408060320.791: *5* k.killLine
def killLine (self,protect=True):

    k = self
    w = k.w
    s = w.getAllText()
    s = s[:len(k.mb_prefix)]
    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n,n,insert=n)
    if protect:
        k.mb_prefix = s
.. @+node:ekr.20061031131434.135: *5* k.minibufferWantsFocus
# def minibufferWantsFocus(self):

    # c = self.c
    # c.widgetWantsFocus(c.miniBufferWidget)
.. @+node:ekr.20061031170011.6: *5* k.protectLabel
def protectLabel (self):

    k = self ; w = self.w
    if not w: return

    k.mb_prefix = w.getAllText()

.. @+node:ekr.20061031170011.7: *5* k.resetLabel
def resetLabel (self):
    '''Reset the minibuffer label.'''
    k = self
    c,w = k.c,k.w
    k.setLabelGrey('')
    k.mb_prefix = ''
    if w:    
        w.setSelectionRange(0,0,insert=0)
        state = k.unboundKeyAction
        if c.vim_mode and c.vimCommands:
            c.vimCommands.show_status()
        else:
            k.setLabelBlue(label='%s State' % (state.capitalize()))
.. @+node:ekr.20080408060320.790: *5* k.selectAll
def selectAll (self):

    '''Select all the user-editable text of the minibuffer.'''

    w = self.w
    i,j = self.getEditableTextRange()
    w.setSelectionRange(i,j,insert=j)


.. @+node:ekr.20061031170011.8: *5* k.setLabel
def setLabel (self,s,protect=False):
    '''Set the label of the minibuffer.'''
    trace = False and not g.app.unitTesting
    k,w = self,self.w
    if w:
        if trace: g.trace(repr(s),g.callers())
        w.setAllText(s)
        n = len(s)
        w.setSelectionRange(n,n,insert=n)
        if protect:
            k.mb_prefix = s
    elif trace:
        g.trace('*** no w ***')
.. @+node:ekr.20061031170011.10: *5* k.setLabelBlue
def setLabelBlue (self,label):
    '''Set the minibuffer label.'''
    trace = False and not g.unitTesting
    k = self ; w = k.w
    if trace: g.trace('label:',label,g.callers())
    if w:
        w.setStyleClass('')  # normal state, not warning or error
        if label is not None:
            k.setLabel(label,protect=True)
    elif trace:
        g.trace('*** no w ***')
.. @+node:ekr.20061031170011.11: *5* k.setLabelGrey
def setLabelGrey (self,label=None):

    k = self ; w = self.w
    if not w: return

    w.setStyleClass( 'minibuffer_warning')

    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
.. @+node:ekr.20080510153327.2: *5* k.setLabelRed
def setLabelRed (self,label=None,protect=False):

    k = self ; w = self.w
    if not w: return

    w.setStyleClass('minibuffer_error')

    if label is not None:
        k.setLabel(label,protect)
.. @+node:ekr.20140822051549.18298: *5* k.setStatusLabel
def setStatusLabel(self,s):
    '''
    Set the label to s.
    
    Use k.setStatusLabel, not k.setLael, to report the status of a Leo
    command. This allows the option to use g.es instead of the minibuffer
    to report status.
    '''
    k = self
    k.setLabel(s,protect=False)
.. @+node:ekr.20061031170011.12: *5* k.updateLabel
def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''

    trace = False or g.trace_minibuffer and not g.app.unitTesting
    k = self ; c = k.c ; w = self.w
    ch = (event and event.char) or ''
    if trace: g.trace('ch',ch,'k.stroke',k.stroke)

    if ch and ch not in ('\n','\r'):
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange()
        ins = w.getInsertPoint()
        # g.trace(i,j,ins)
        if i != j:
            w.delete(i,j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) > len(k.mb_prefix):
                w.delete(i-1)
                i-=1
        else:
            w.insert(ins,ch)
            i = ins+1
.. @+node:ekr.20141109072407.10: *3* fixed bug 1159490: "Open with" fails to copy changes by external editor back to Leo-Editor node
@language rest

https://bugs.launchpad.net/leo-editor/+bug/1159490

The solution is to change the following setting in leoSettings.leo::
    
    @bool open_with_save_on_update = True
.. @-all

# Put this @language after the @all as a kind of permanent unit test.

.. @@language python # Override the default .txt coloring.

.. @@pagewidth 60
.. @-leo
