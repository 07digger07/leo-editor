.. @+leo-ver=5-thin
.. @+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
.. @+all
.. @+node:ekr.20150417044242.1: ** 5.2-b1
.. @+node:ekr.20150512102759.1: *3* Code
.. @+node:ekr.20150512102801.1: *4* Decorators simplify Leo's command dispatching
Please read carefully if you write plugins or are one of Leo's core developers.  Everyone else can safely ignore this post.

The present (g.new_dispatch) project simplifies Leo's code as follows:

1. Decorators will define all Leo commands.  All getPublicCommands methods will disappear, along with their association lists of command names and bound methods.

2. Leo will never call c.universalCallback.

I understand neither it's docstring, nor its code, nor why it is needed. Leo will be better off without it and the corresponding 'wrap' argument to k.registerCommand. This wrapper gives rise to wretched code::

    @g.command('cke-text-open')
    def cmd_OpenEditor(kwargs, at_rich=False):
        '''Open the rich text editor, hide the regular editor.'''
        c = kwargs['c'] if isinstance(kwargs, dict) else kwargs

Apparently, kwargs might be two different kinds of objects depending on who calls the function.  This kind of code must go.  In an emergency, code could add ivars/attributes to exiting events, but even that would be too complex by half.

3. The Plugin class in plugins_menu.py creates Leo commands for functions whose names start with ``cmd_``.  It took me hours yesterday to figure out that this was happening.

<< Look for additional commands >> creates yet another wrapper, with yet another signature. The wrapper now has a more conforming signature and a better name::

    def plugins_menu_wrapper(kwargs, cmd=cmd):
        return cmd(kwargs['c'])

This signature allows a unit test to pass even when plugins_menu_wrapper is not wrapped again.

Happily, all of this is going to go away. ``@g.command`` will define all commands in plugins. No more invisible ``cmd_`` naming convention.

4. class AtButtonCallback now supports the __name__ attribute using a new __getattr__ method. This allows k.registerCommand not to know about the AtButtonCallback wrapper.

5. The LeoKeyEvent class now has a get method.  Code can now call event.get('c') in all cases.  Probably ditto for kwargs.get('c').

**Summary**

The new_dispatch project simplifies some of the most complex code in Leo.  It is worth a week's work.

I followed three principles while simplifying the code:

1. Eliminate malignant if statements::

    c = kwargs['c'] if isinstance(kwargs, dict) else kwargs

proliferates implementation details from one part of Leo to another.  As a result, it becomes much harder to change code without side effects.  I have been dealing with such side effects all week.

2. Regularize interfaces.

- ``@cmd`` or ``@g.command`` decorators will define all Leo commands.
- The ``cmd_`` convention will disappear, along with the complex code that creates it.
- event.get('c') will work in any code decorated by ``@cmd`` or ``@g.command``.
- AtButtonCallback instances now have a __name__.

3. Regularize objects.

Changing the interface of an object by wrapping it is unacceptable. c.universalCallback must go.

.. @+node:ekr.20150501041440.1: *4* Reorganized Leo's commands files
The leo/commands directory contains the new code.
.. @+node:ekr.20150427042446.1: *3* Features
.. @+node:ekr.20150412053053.1: *4* Finished leoOPML plugin
.. @+node:ekr.20150420130845.1: *4* Added File:Print menus
jasonic

Leo deserves good friendly printing features which anyone can use. At the moment we have a confusing patchwork of choices. Printing Leo seems to be both harder and easier than  first meets the eye.

print-to-web (htmlize) should definitely be on Leo's missing PRINT MENU.

Having a little library of export scripts--well named, documented and intended to aid printing woudl go a long way. Thesse scripts anyone coiuld be called by onayone given a Leo Outline, accessing a navabr button. PRINT MENU or list. Or they can just insert the appropriate script  into an outline giving finer grained print control on the fly.
.. @+node:ekr.20150416060248.1: *4* Allow Leo directives in @data abbreviations-subst-env
The fix was to create a dummy root position in abbrev.init_env.
.. @+node:ekr.20150422124650.1: *4* Added c.backup
Useful for per-file backups.
.. @+node:ekr.20150425135844.1: *4* Added support for @data history-list
If you aren't using the @data history-list setting chances are that you missing a big chance to simplify your workflow. At one time I thought the history list was a minor feature.  I could not have been more wrong.

The body of the @data history-list node should contain a list of command names, one per line.  This list can include commands created by @command/@button nodes.

You execute items in the history list by doing Alt-X followed by an up arrow to get the first item in the list, or one or more down arrows to get later items in the list.  The last item you execute from this list goes to the head of the list.  Once you have executed an item, Ctrl-P (repeat complex command) will re-execute it.

The history list works well for commands that aren't quite worth a separate key binding, but that nevertheless you find you using quite often.

Even better, the history list is a perfect complement to @button and @command nodes that are tailored for a particular outline. For example, there is a button called cfa-code in leoPy.leo that executes the clone-find-all-flattened command starting at the top-level "Code" node.
.. @+node:ekr.20150426052139.1: *4* Added @ifenv, improved @ifplatform & @ifhostname
@language rest
@wrap

Here are the details:

@ifenv name, one-or-more-comma-separated values
 
Includes descendant settings if os.getenv(name) matches any of the values.

- Case is significant in the *name* of the environment variable.
- Case is ignored in the *values*.

Examples:

@ifenv HOSTNAME,bob
    Enables descendant settings if os.environ('HOSTNAME') is 'Bob' or 'bob'
   
@ifenv EDITOR,leo,lion
    Enables descendant settings if os.environ('Editor') is 'Leo' or 'Lion', etc.

@ifplatform name,  one-or-more-comma-separated values.
  
Includes descendant settings if sys.platform matches any of the values, ignoring case.

Examples:

@ifplatform darwin,linux2
    Enables descendant settings for MacOS and Linux.

@ifplatform win32
    Enables descendant settings for Windows
  
@ifhostname name

Includes descendant settings if os.environ('HOSTNAME') == name

@ifhostname !name

Includes descendant settings if os.environ('HOSTNAME') != name
.. @+node:ekr.20150211131925.4: *4* abbreviations now support auto-close quotes
https://groups.google.com/d/msg/leo-editor/yJLz-p3I4mY/Pqa1phYN_10J
.. @+node:ekr.20150325052301.1: *4* Added enhancement 165: vim-open-file command
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/165

Later: preserve cursor positions.

All the changes were to the ExternalFilesController class.
.. @+node:ekr.20150530084545.1: *4* Added support for @beautify and @nobeautify
These directives are inherited as usual.
.. @+node:ekr.20150529182422.1: *4* Rewrote Leo's Python beautifier
@language rest
@wrap




.. @+node:ekr.20150602154330.1: *5* Post 0
An amazing collapse in complexity has just happened. I wrote a new, much simpler, token-based beautifier last night.  The parse-tree based beautifier will be retired.

Aha 1: The token-based beautifier can use the same code generators as the parse-tree based beautifier.

This collapses the complexity of token handlers, a huge breakthrough. This complexity doomed the old token-based code.

Aha 2: token handlers can easily parse incoming tokens using a state stack.

The StateToken class will be almost identical to the OutputToken class. Instances will have state string and state-related data. The state string makes it easy to inspect the stack.

With a token-based approach, two big problems instantly disappear:

1. How to associate tokens with nodes in the parse tree.
2. How to parenthesize expressions properly.

The token-based beautifier will only ever insert or delete whitespace outside of comments and strings.  This naturally preserves all essential tokens, including the user's desired parens.

The rest of this post is an entry in Leo's Engineering Notebook. It discusses technical details. Feel free to ignore.

The compare_ast function

The code is in leoAst.py.  It is taken from stackoverflow, modified to show the line numbers of mismatched nodes.

The testing code for both beautifiers uses compare_ast to check that beautification hasn't altered the meaning of the program.

compare_ast revealed the following problem in the Ast-based beautifier...

The parse tree must be traversed in token order

Yes, the 1 to 1 correspondence between string tokens and Ast.Str nodes makes it "easy" to associate string tokens with string nodes. Alas, to make this work, the code must visit Ast Str nodes in the same order that string tokens appear in the source.

It was straightforward to modify the traversers in the AstFullTraverser base class to make this happen. But now we have a hidden global constraint on tree traversal, an unpleasant maintenance problem.

Continued strings

Continued strings affect the association of tokens with Ast.Str nodes.  I'm glad not to have sort this all out. The problem is much less serious in the token-based beautifier because the line numbers of tokens don't matter!

Parentheses

To make the Ast-based code work, the code generators had to fully parenthesize all operators. This is ridiculous: we want to retain the user's parens!

Recreating the user's parentheses is a very difficult problem in the Ast world. Yes, this problem can (and has been) solved, but it simply doesn't exist in the token world.

How to parse tokens

The parse stack will start with a 'outer-level' state token.  This ensures that state_stack [-1] will always exist.

Token handlers will work as follows:

'class' and 'def' tokens ('name' tokens) will push 'class' and 'def' state on the state stack.

When a  'def' token is on the top of the stack, incoming '(', ('op') tokens will push 'def-args' state token on the stack.  This token will have a parenthesis count.  Nested '(' and ')' tokens will increment and decrement this count. A ')' token that reduces the count to zero will remove the 'def-args' token.

This scheme will allow whitespace to be handled differently in function arguments and other parenthesized expressions.  For example, the code generators may split long argument lists into several lines.

Other kinds of state tokens can be added as need. For example, we will want to keep track of blank lines, and split long lines.

Token handlers can handle all states without an explosion in complexity.

Summary

Using tokens eliminates big troubles inherent in Ast-based approaches.

The old token handlers were unbearably complex. The new token handlers delegate look-behind and look-ahead to the code generators.  As a result, new token handlers are easy to write and maintain, a huge breakthrough.

Token handlers can easily parse incoming tokens using a state stack. Python's syntax makes it straightforward to keep track of argument list, etc.

Very little work remains. I expect to finish the token-based beautifier in a day or three. The new beautifier should be substantially faster than the old.
.. @+node:ekr.20150602154110.1: *5* Post 1
**Executive summary**

- The beautifier just works for all code except aligned dictionary definitions.
- The beautifier never attempts to make difficult choices.
- The beautifier never splits lines.
- @nobeautify protects a node and its descendants from unwanted beautification.
- @beautify re-enables beautification.
- The code will work on either Python 2 or 3.

The rest of this post discusses the details...

**Sweet Spot**

Earlier today I had intended to continue work on this project.  But after seeing the code in action I realized that adding more settings and "frills" could be a step backwards.

The present code handles all the uncontroversial parts of pep8 as expected, while leaving all difficult, ambiguous or idiosyncratic decisions to the user.

With just one exception, discussed below, the present code should just work for everybody without the need for other preferences!  This is a happy surprise.

**What the beautifies does**

The beautifier follows the pep 8 recommendations for whitespace. It ensures that names, operators, strings and comments are separated by zero or one blanks, as expected::

    def spam(a, b, c=5, *args, **keys):
        foo(a, 25, b=2)
        a = b + c - 5
        b = -d
        if 0 < b < 26:
            ...

Leo follows the pep 8 recommendations for blank lines, with minor variations due to Leo's node structure.

Optionally, the beautifier can remove blank lines within classes and defs, controlled by the one and only one beautifier setting::

    @bool tidy-keep-blank-lines = False

That's all!

**What the beautifier doesn't do**

The beautifier never creates new lines! The beautifier never adds or changes:

- Line breaks for "long" lines.
- Line breaks in function argument lists.
- Leading whitespace in continued argument lines.
- Line breaks call arguments.
- Leading whitespace in continue function call arguments.
- Whitespace (including line breaks) within statements.

Yesterday I saw that I had seriously misunderstood the pep 8 recommendations for indentation.  pep 8 allows much more flexibility than I thought.

The beautifier will leave all of the following unchanged, whether or not they conform to the pep 8 recommendation::

    def function1 (a, b, c):
        pass
    
    def function2 (
    a = 2, # a comment
    b = 3, # another comment
    ):
        pass
    
    def function3 (
        a = 2, # a comment
        b = 3, # another comment
    ):
        pass
    
    def function4(
                  a = 2, # a comment
                  b = 3, # another comment
                 ):
        pass

Similarly, the beautifier will not touch arguments in function calls.

In short, *the beautifier won't mess with your code*! There is one exception...

**Formatting dict definitions**

At present, the beautifier unaligns dict definitions.  It will convert::

    cmd_instance_dict = {
        'AbbrevCommands':    ['c', 'abbrevCommands'],
        'AtFile':            ['c', 'atFileCommands'],
        ...
    }

to::

    cmd_instance_dict = {
        'AbbrevCommands': ['c', 'abbrevCommands'],
        'AtFile': ['c', 'atFileCommands'],
        ...
    }

The workaround is to disable formatting for such nodes with the new @nobeautify directive.  There is also an @beautify directive. These two directives work together as usual.

The tokens provided by Python's tokenizer might provide enough data to preserve indentation in such cases.  I'll check before declaring the beautifier fully complete.

**Summary**

The present beautifier is maximally useful with just one setting. Except for dictionary definitions, the beautifier does what is expected, leaving difficult or idiosyncratic cases completely at the user's discretion. Git can revert unwanted changes to dicts.

Further "improvements" to the beautifier would imply settings that most people will neither know about nor understand. The present beautifier is almost as easy to use as the camera with the giant red button ;-)
 
The @bool tidy-keep-blank-lines setting tells the beautifier whether to remove blank lines within classes, functions and methods.  The beautifier inserts reasonable blanks lines between classes, functions and methods in almost all cases.

The @nobeautify directive protects code from unwanted beautification.

The @beautify/@nobeautify directives act on a node and its descendants, as usual.
.. @+node:ekr.20150602154128.1: *5* Post 2
As of Rev ac94cab, there are no known serious bugs in the beautifier commands.

As previously discussed, the beautifier will just work for most people. The only setting is @bool tidy-keep-blank-lines = False.

This post completes the documentation for Leo's beautify commands, paying close attention to details.

Commands

beautify-node: beautifies Python code in a single node.
beautify-tree: beautifies Python code a node and its descendants.
beautify-c: beautifies C code in a node and its descendants.

These commands skip any nodes for which @language python (or c) is not in effect.

The Python beautifiers (beautify-tree and beautify-node) are safe.  They can never alter the meaning of a program because they compare the parse trees of the original and beautified code. The code remains unchanged if there is a mismatch. Such beautifier errors produce debugging dumps. Please report any such errors to me.

The Python beautifiers work only on syntactically correct code.  They issue a warning and do nothing for syntactically incorrect code.

The Python beautifies convert Leonine syntax (directives, section references and @doc parts) to comments, possibly with a trailing "pass" statement.  Usually this produces syntactically correct text.  As discussed below, the trailing "pass" can create SyntaxError's.

Directives

@beautify: enables beautification in a node.
@nobeautify: disables beautification in a node.

These directives apply to a node and its descendants, until overridden later in a descendants.

Both these directives may appear in the same node.  Such ambiguous directives do not affect the beautification of descendant nodes.  If both directives appear in a node, the first directive determines whether the node will be beautified.  So:

@beautify
...
@nobeautify

beautifies the entire node.  Otoh,

@nobeautify
...
@beautify


skips beautification of the entire node. Yes, this is less precise than one could imagine, but it's good enough for now.

Note: The beautify-c command ignores these directives.

Rough edges

The following 5 problems are relatively minor.  They apply only to the Python beautifiers. The workaround in most cases is to use @nobeautify.

1. Syntax Errors

The pass hack converts:

if 1:
    << a section >>

to:

if 1:
    #!!!!! << a section >>
    pass

which is usually, but not always, syntactically correct Python. Here is an example from Leo's core:

patterns = [
    << Sherlock patterns for pylint >>
]

The pass hack produces syntactically incorrect code:

patterns = [
    #!!!!! << Sherlock patterns for pylint >>
    pass
]

2. Alignment

The beautifier eliminates blanks used to align code.  For example:

d = {
    key1:     value1,
    longKey2: value2,
}

The beautifier might preserve such lines, but there are no plans at present to do so.

The regular expression: =([ ])*\{([^}])*$ will discover complex dictionaries that you may want to protect with @nobeautify.

3. Operator priority

Pep 8 suggests considering eliminating blanks around higher-priority operators.  The beautifier puts blank lines about all operators, except unary operators.

This is a difficult problem of style, for which no approach works in all cases.  Surprisingly, retaining blanks around '*' usually looks best in Leo's own code.

4. @clean & @auto

Consider adding @nobeautify for all @auto/@clean nodes, on the theory that such nodes are not primarily your responsibility.  But adding @nobeautify is completely up to you.

5. Extra blank lines

The beautifier will sometimes insert extra spaces between class/def lines and preceding comments.  The workaround is to move such comments into the class or def, including the docstring.  This is a minor issue, so it can usually be ignored.

Stand-alone version

You may invoke the Python beautifier from the command line. The stand-alone version of the beautifier is lightly tested.

You can run leoBeautify.py from any directory, provided that a copy of leoGlobals.py exists in the same directory.

Run the stand-alone beautifier as follows:

python -m leoBeautify file1, file2, ...

To get a usage message, do:

python -m leoBeautify -h

This produces:

Usage: python leoBeautify -m file1, file2, ...

Options:
  -h, --help             show this help message and exit
  -d, --debug            print the list of files and exit
  -k, --keep-blank-lines keep-blank-lines

Enough is enough

This project happened because PythonTidy doesn't work with Python 3 and autopep8 is too slow, so in some sense it was necessary.  And discovering the new code generator pattern was hugely satisfying. However, it's time for a break.  Please don't ask me to do more now.

The following could be done only at the cost of more settings and debates about what the default settings should be.

    Splitting long lines.
    Improve spacing around operators.
    Moving or indenting comment lines.

All these involve significant personal judgements and preferences. Pep 8 explicitly allows various approaches.

Maybe

On a relatively slow machine, beautify-tree beautifies all files in LeoPy.leo in 17.4 seconds.  I am dithering about adding a setting that would beautify files automatically when saving an outline. Naturally, @beautify and @nobeautify would be handled as usual.

Summary

    For the first time ever, Leo's beautify commands work properly with Leonine syntax.
    All files in leoPy.leo can now be beautified without fuss.
    Except for spacing around operators, the beautifier mostly leaves your code as it is.
    The beautifier makes no difficult choices. It will honor your choices.
    No further improvements are planned.  You are unlikely to convince me to do more.
.. @+node:ekr.20150427042510.1: *3* Bugs Fixed
.. @+node:ekr.20150417045902.1: *4* Recover from orphan bit in leoPyBad.leo
Rev dc1bf6f

The orphan bit was set in @file leoGlobals.py.
This prevented the file from being updated.

Changed:
- at.read.
- at.readAll
- fc.putVnode no longer writes orphan bits.
. VNode constants section: # unused    = 0x10 # (was orphanBit)
.. @+node:ekr.20150417053733.1: *4* Fixed @tabwidth bug
Using c.tab_width is wrong: it is the *default* tab width.

Created c.getTabWidth()
.. @+node:ekr.20150403035558.1: *4* Fixed bug 169: import-file does not preserve gnx of root @file node
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/169
import-file does not preserve gnx of root @file node

The fix was a special case in at.readStartNode.
.. @+node:ekr.20150428112500.1: *4* Fixed abbreviation bugs and improved abbreviations
@language rest
@wrap

The fixes were in abbrev.expandAbbrev and helpers.

Rev 585d2f4 improves abbreviations as follows:

- Match longest prefix first: e;; no longer interferes with date;;
- Predefine 'x' as the empty string before executing abbreviation scripts.
- Split @data abbreviations-subst-env into separate nodes.
- Defined do() and insert() functions in @data abbreviations-subst-env as follows::

@language python

    def do(commandName):
        '''Execute a command by name.'''
        c.k.simulateCommand(commandName,event=None)
    
    def insert(s):
        '''Insert the string s in the current widget.'''
        try:
            w = c.abbrevCommands.w
            if w:
                i = w.getInsertPoint()
                w.insert(i,s)
        except AttributeError:
            pass
            
@language rest
@wrap

Note:  Because of a glitch in how abbreviations scripts are created, you can't do::

    do(['command1','command2'])

even though c.k.simulateCommand allows list arguments.  Instead, do this::

    do('command1');do('command2');

The following abbreviations insert matching characters (no need to do x='' in them)::

    (={|{insert('()');do('back-char')}|}
    [={|{insert('[]');do('back-char')}|}
    {={|{insert('{}');do('back-char')}|}

This is an implementation of auto-close-quotes, done entirely with abbreviations! For example, typing '(' inserts '()' and puts the cursor between the parens.

I personally dislike these abbreviations.  I find it harder to skip past the ')' than to type it later.  ymmv.
.. @+node:ekr.20150428153124.1: *4* Removed warning in at.read about orphan bits
.. @+node:ekr.20150430175300.1: *4* Improved Ctrl-LtArrow
Ctrl-LtArrow and Ctrl-RtArrow leave the cursor at the start of a word.
This is the way most editors work.

The fix was in moveWordHelper.
.. @+node:ekr.20150509180744.1: *4* Fixed remove-blank-lines command
It now works when there is no text selection.
.. @-all
.. @@killbeautify
.. @@language rest
.. @@wrap
.. @@pagewidth 60
.. @-leo
