.. @+leo-ver=5-thin
.. @+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
.. @+all
.. @+node:ekr.20180214040850.1: ** re: (5.8) delete in other direction
.. @+node:ekr.20031218072017.1549: *3* c_oc.cutOutline
@g.commander_command('cut-node')
def cutOutline(self, event=None):
    '''Delete the selected outline and send it to the clipboard.'''
    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline(op_name="Cut Node")
        c.recolor()
.. @+node:ekr.20031218072017.1193: *3* c_oc.deleteOutline
@g.commander_command('delete-node')
def deleteOutline(self, event=None, op_name="Delete Node"):
    """Deletes the selected outline."""
    c, u = self, self.undoer
    p = c.p
    if not p: return
    c.endEditing() # Make sure we capture the headline for Undo.
    if False: # c.config.getBool('select-next-after-delete'):
        # #721: Optionally select next node after delete.
        if p.hasVisNext(c): newNode = p.visNext(c)
        elif p.hasParent(): newNode = p.parent()
        else: newNode = p.back() # _not_ p.visBack(): we are at the top level.
    else:
        # Legacy: select previous node if possible.
        if p.hasVisBack(c): newNode = p.visBack(c)
        else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return
    undoData = u.beforeDeleteNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.doDelete(newNode)
    c.setChanged(True)
    u.afterDeleteNode(newNode, op_name, undoData, dirtyVnodeList=dirtyVnodeList)
    c.redraw(newNode)
    c.validateOutline()
.. @+node:ekr.20031218072017.2960: *3* c.canCutOutline & canDeleteHeadline
def canDeleteHeadline(self):
    c = self; p = c.p
    if c.hoistStack:
        bunch = c.hoistStack[0]
        if p == bunch.p: return False
    if False: # c.config.getBool('select-next-after-delete'):
        # #721: Optionally select next node after delete.
        return p.hasParent() or p.hasBack()
    else:
        return p.hasParent() or p.hasThreadBack() or p.hasNext()

canCutOutline = canDeleteHeadline
.. @+node:ekr.20050412084055: *3* u.undoDeleteNode
def undoDeleteNode(self):
    u = self; c = u.c
    if u.oldBack:
        u.p._linkAfter(u.oldBack)
    elif u.oldParent:
        u.p._linkAsNthChild(u.oldParent, 0)
    else:
        oldRoot = c.rootPosition()
        u.p._linkAsRoot(oldRoot)
    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)
.. @+node:ekr.20080416161551.211: *3* p.moveToVisNext & helper
def moveToVisNext(self, c):
    """Move a position to the position of the next visible node."""
    trace = False and not g.unitTesting
    p = self
    limit, limitIsVisible = c.visLimit()
    while p:
        if trace: g.trace('1', p.h)
        if p.hasChildren():
            if p.isExpanded():
                p.moveToFirstChild()
            else:
                p.moveToNodeAfterTree()
        elif p.hasNext():
            p.moveToNext()
        else:
            p.moveToThreadNext()
        if trace: g.trace('2', p and p.h)
        if p:
            if limit and self.checkVisNextLimit(limit,p):
                return None
            if p.isVisible(c):
                return p.copy()
    return p
.. @+node:ekr.20090715145956.6167: *4* checkVisNextLimit
def checkVisNextLimit(self, limit, p):
    '''Return True is p is outside limit of visible nodes.'''
    return limit != p and not limit.isAncestorOf(p)
.. @+node:ekr.20080416161551.210: *3* p.moveToVisBack & helper
def moveToVisBack(self, c):
    """Move a position to the position of the previous visible node."""
    trace = False and not g.unitTesting
    verbose = False
    p = self
    limit, limitIsVisible = c.visLimit()
    if trace and verbose:
        g.trace(p, 'limit', limit, 'limitIsVisible', limitIsVisible)
    if trace: g.trace('***entry', 'parent', p.parent(), 'p', p)
    while p:
        # Short-circuit if possible.
        back = p.back()
        if trace: g.trace(
            'back', back, 'hasChildren', bool(back and back.hasChildren()),
            'isExpanded', bool(back and back.isExpanded()))
        if back and back.hasChildren() and back.isExpanded():
            p.moveToThreadBack()
        elif back:
            p.moveToBack()
        else:
            p.moveToParent() # Same as p.moveToThreadBack()
        if trace: g.trace(p.parent(), p)
        if p:
            if limit:
                done, val = self.checkVisBackLimit(limit, limitIsVisible, p)
                if done:
                    if trace and verbose: g.trace('done', p)
                    return val # A position or None
            if p.isVisible(c):
                if trace and verbose: g.trace('isVisible', p)
                return p
            else:
                if trace and verbose: g.trace('**** not visible', p)
    if trace: g.trace('*** return None ***')
    return p
.. @+node:ekr.20090715145956.6166: *4* checkVisBackLimit
def checkVisBackLimit(self, limit, limitIsVisible, p):
    '''Return done, p or None'''
    trace = False and not g.unitTesting
    c = p.v.context
    if limit == p:
        if trace: g.trace('at limit', p)
        if limitIsVisible and p.isVisible(c):
            return True, p
        else:
            return True, None
    elif limit.isAncestorOf(p):
        return False, None
    else:
        if trace: g.trace('outside limit tree', limit, p)
        return True, None

.. @+node:ekr.20180228110646.1: ** #748: Improve print-settings command
@language rest
@wrap

Skip tree-valued settings in print-settings command
https://github.com/leo-editor/leo-editor/issues/748

@language python
.. @+node:ekr.20120130101219.10182: *3* LM.computeBindingLetter
def computeBindingLetter(self, kind):
    # lm = self
    if not kind:
        return 'D'
    table = (
        ('M', 'myLeoSettings.leo'),
        (' ', 'leoSettings.leo'),
        ('F', '.leo'),
    )
    for letter, kind2 in table:
        if kind.lower().endswith(kind2.lower()):
            return letter
    if kind == 'register-command' or kind.find('mode') > -1:
        return '@'
    else:
        return 'D'
.. @+node:ekr.20150514063305.402: *3* printSettings
@cmd('print-settings')
def printSettings(self, event=None):
    '''
    Prints the value of every setting, except key bindings and commands and
    open-with tables. The following shows where the active setting came
    from:

    -     leoSettings.leo,
    -  @  @button, @command, @mode.
    - [D] default settings.
    - [F] indicates the file being loaded,
    - [M] myLeoSettings.leo,
    '''
    self.c.config.printSettings()
.. @+node:ekr.20070418073400: *3* c.config.printSettings
def printSettings(self):
    '''Prints the value of every setting, except key bindings and commands and open-with tables.
    The following shows where the active setting came from:

    -     leoSettings.leo,
    -  @  @button, @command, @mode.
    - [D] default settings.
    - [F] indicates the file being loaded,
    - [M] myLeoSettings.leo,

    '''
    legend = '''\
legend:
    leoSettings.leo
 @  @button, @command, @mode
[D] default settings
[F] loaded .leo File
[M] myLeoSettings.leo
'''
    c = self.c
    legend = g.adjustTripleString(legend, c.tab_width)
    result = []
    for name, val, c, letter in g.app.config.config_iter(c):
        kind = '   ' if letter == ' ' else '[%s]' % (letter)
        result.append('%s %s = %s\n' % (kind, name, val))
    # Use a single g.es statement.
    result.append('\n' + legend)
    if g.unitTesting:
        pass # print(''.join(result))
    else:
        g.es_print('', ''.join(result), tabName='Settings')
.. @+node:ekr.20120222103014.10314: *3* gcm.config_iter
def config_iter(self, c):
    '''Letters:
      leoSettings.leo
    D default settings
    F loaded .leo File
    M myLeoSettings.leo
    @ @button, @command, @mode.
    '''
    trace = False and not g.unitTesting
    lm = g.app.loadManager
    d = c.config.settingsDict if c else lm.globalSettingsDict
    limit = c.config.getInt('print-settings-at-data-limit')
    if limit is None:
        limit = 20 # A resonable default.
    # pylint: disable=len-as-condition
    for key in sorted(list(d.keys())):
        gs = d.get(key)
        assert g.isGeneralSetting(gs), gs
        if gs and gs.kind:
            letter = lm.computeBindingLetter(gs.path)
            val = gs.val
            if gs.kind == 'data':
                # #748: Remove comments
                aList = [' '*8 + z.rstrip() for z in val
                    if z.strip() and not z.strip().startswith('#')]
                if trace:
                    g.trace('@data =====', len(aList), key)
                    if 0 < len(aList) < limit:
                        g.printList(aList)
                if not aList:
                    val = '[]'
                elif limit == 0 or len(aList) < limit:
                    val = '\n    [\n' + '\n'.join(aList) + '\n    ]'
                    # The following doesn't work well.
                    # val = g.objToString(aList, indent=' '*4)
                else:
                    val = '<%s non-comment lines>' % len(aList)
            elif g.isString(val) and val.startswith('<?xml'):
                val = '<xml>'
            key2 = '@%-6s %s' % (gs.kind, key)
            yield key2, val, c, letter
.. @+node:ekr.20180301115205.1: ** Leo renders markdown well
@language md
@wrap

Provided markdown is installed, this renders correctly, and the links work:

# Test

![Splash Screen](../Icons/SplashScreen.ico)

![Bubbles](../Icons/bubbles.svg)

**hi**

[a link](http://leoeditor.com/).

You can embed HTML in Markdown!

<img style="float:right;" src="c:/leo.repo/leo-editor/leo/Icons/SplashScreen.ico" alt="Splash"> <p>
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. 
</p><p>
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
<p>

<br>
<br>
<br>

| Tables | &nbsp; &nbsp; &nbsp; Are &nbsp; &nbsp; &nbsp; | Cool |
|---:|:---:|:---|
| col 3 is  | help | $1600  |
| col 2 is  | centered | $12    |
| zebra  | are neat        | $1  |

```python
# Not always syntax colored.
def spam():
    pass
```
.. @+node:ekr.20180302093235.1: ** #763: Use html comments to support @file x.md
Use html comments to support @file x.md
https://github.com/leo-editor/leo-editor/issues/763
.. @+node:ekr.20120522160137.9909: *3* app.define_language_delims_dict
@nobeautify

def define_language_delims_dict(self):

    self.language_delims_dict = {
        # Internally, lower case is used for all language names.
        # Keys are languages, values are 1,2 or 3-tuples of delims.
        "actionscript"       : "// /* */", # jason 2003-07-03
        "ada"                : "--",
        "ada95"              : "--",
        "ahk"                : ";",
        "antlr"              : "// /* */",
        "apacheconf"         : "#",
        "apdl"               : "!",
        "applescript"        : "-- (* *)",
        "asp"                : "<!-- -->",
        "aspect_j"           : "// /* */",
        "assembly_macro32"   : ";",
        "assembly_mcs51"     : ";",
        "assembly_parrot"    : "#",
        "assembly_r2000"     : "#",
        "assembly_x86"       : ";",
        "autohotkey"         : "; /* */", # TL - AutoHotkey language
        "awk"                : "#",
        "b"                  : "// /* */",
        "batch"              : "REM_", # Use the REM hack.
        "bbj"                : "/* */",
        "bcel"               : "// /* */",
        "bibtex"             : "%",
        "c"                  : "// /* */", # C, C++ or objective C.
        "chill"              : "/* */",
        "clojure"            : ";", # 2013/09/25: Fix bug 879338.
        "cobol"              : "*",
        "coldfusion"         : "<!-- -->",
        "coffeescript"       : "#", # 2016/02/26.
        "config"             : "#", # Leo 4.5.1
        "cplusplus"          : "// /* */",
        "cpp"                : "// /* */",# C++.
        "csharp"             : "// /* */", # C#
        "css"                : "/* */", # 4/1/04
        "cweb"               : "@q@ @>", # Use the "cweb hack"
        "cython"             : "#",
        "d"                  : "// /* */",
        "dart"               : "// /* */", # Leo 5.0.
        "doxygen"            : "#",
        "eiffel"             : "--",
        "elisp"              : ";",
        "erlang"             : "%",
        "factor"             : "!_ ( )", # Use the rem hack.
        "forth"              : "\\_ _(_ _)", # Use the "REM hack"
        "fortran"            : "C",
        "fortran90"          : "!",
        "foxpro"             : "&&",
        "gettext"            : "# ",
        "groovy"             : "// /* */",
        "handlebars"         : "<!-- -->", # McNab: delegate to html.
        "haskell"            : "--_ {-_ _-}",
        "haxe"               : "// /* */",
        "hbs"                : "<!-- -->", # McNab: delegate to html.
        "html"               : "<!-- -->",
        "i4gl"               : "-- { }",
        "icon"               : "#",
        "idl"                : "// /* */",
        "inform"             : "!",
        "ini"                : ";",
        "inno_setup"         : ";",
        "interlis"           : "/* */",
        "io"                 : "// */",
        "java"               : "// /* */",
        "javascript"         : "// /* */", # EKR: 2011/11/12: For javascript import test.
        "javaserverpage"     : "<%-- --%>", # EKR: 2011/11/25 (See also, jsp)
        "jhtml"              : "<!-- -->",
        "jmk"                : "#",
        "jsp"                : "<%-- --%>",
        "kivy"               : "#", # PeckJ 2014/05/05
        "kshell"             : "#", # Leo 4.5.1.
        "latex"              : "%",
        "less"               : "/* */", # NcNab: delegate to css.
        "lilypond"           : "% %{ %}",
        "lisp"               : ";", # EKR: 2010/09/29
        "lotos"              : "(* *)",
        "lua"                : "--", # ddm 13/02/06
        "mail"               : ">",
        "makefile"           : "#",
        "maple"              : "//",
        "markdown"           : "<!-- -->", # EKR, 2018/03/03: html comments.
        "matlab"             : "%", # EKR: 2011/10/21
        "md"                 : "<!-- -->", # PeckJ: 2013/02/08
        "ml"                 : "(* *)",
        "modula3"            : "(* *)",
        "moin"               : "##",
        "mqsc"               : "*",
        "netrexx"            : "-- /* */",
        "noweb"              : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
        "nqc"                : "// /* */",
        "nsi"                : ";", # EKR: 2010/10/27
        "nsis2"              : ";",
        "objective_c"        : "// /* */",
        "objectrexx"         : "-- /* */",
        "occam"              : "--",
        "omnimark"           : ";",
        "pascal"             : "// { }",
        "perl"               : "#",
        "perlpod"            : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
        "php"                : "// /* */", # 6/23/07: was "//",
        "pike"               : "// /* */",
        "pl1"                : "/* */",
        "plain"              : "#", # We must pick something.
        "plsql"              : "-- /* */", # SQL scripts qt02537 2005-05-27
        "pop11"              : ";;; /* */",
        "postscript"         : "%",
        "povray"             : "// /* */",
        "powerdynamo"        : "// <!-- -->",
        "prolog"             : "% /* */",
        "psp"                : "<!-- -->",
        "ptl"                : "#",
        "pvwave"             : ";",
        "pyrex"              : "#",
        "python"             : "#",
        "r"                  : "#",
        "rapidq"             : "'", # fil 2004-march-11
        "rebol"              : ";", # jason 2003-07-03
        "redcode"            : ";",
        "rest"               : ".._",
        "rhtml"              : "<%# %>",
        "rib"                : "#",
        "rpmspec"            : "#",
        "rst"                : ".._",
        "rust"               : "// /* */",
        "ruby"               : "#", # thyrsus 2008-11-05
        "rview"              : "// /* */",
        "sas"                : "* /* */",
        "scala"              : "// /* */",
        "scheme"             : "; #| |#",
        "sdl_pr"             : "/* */",
        "sgml"               : "<!-- -->",
        "shell"              : "#",     # shell scripts
        "shellscript"        : "#",
        "shtml"              : "<!-- -->",
        "smalltalk"          : '" "', # Comments are enclosed in double quotes(!!)
        "smi_mib"            : "--",
        "splus"              : "#",
        "sqr"                : "!",
        "squidconf"          : "#",
        "ssharp"             : "#",
        "swig"               : "// /* */",
        "tcl"                : "#",
        "tcltk"              : "#",
        "tex"                : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
        "text"               : "#", # We must pick something.
        "texinfo"            : "@c",
        "tpl"                : "<!-- -->",
        "tsql"               : "-- /* */",
        "typescript"         : "// /* */", # For typescript import test.
        "unknown"            : "#", # Set when @comment is seen.
        "unknown_language"   : '#--unknown-language--', # For unknown extensions in @shadow files.
        "uscript"            : "// /* */",
        "vbscript"           : "'",
        "velocity"           : "## #* *#",
        "verilog"            : "// /* */",
        "vhdl"               : "--",
        "vim"                : "\"",
        "vimoutline"         : "#", # TL 8/25/08 Vim's outline plugin
        "xml"                : "<!-- -->",
        "xsl"                : "<!-- -->",
        "xslt"               : "<!-- -->",
        "yaml"               : "#",
        "zpt"                : "<!-- -->",

        # These aren't real languages, or have no delims...
        # "cvs_commit"         : "",
        # "dsssl"              : "; <!-- -->",
        # "embperl"            : "<!-- -->",  # Internal colorizing state.
        # "freemarker"         : "",
        # "hex"                : "",
        # "jcl"                : "",
        # "patch"              : "",
        # "phpsection"         : "<!-- -->",  # Internal colorizing state.
        # "props"              : "#",         # Unknown language.
        # "pseudoplain"        : "",
        # "relax_ng_compact"   : "#",         # An xml schema.
        # "rtf"                : "",
        # "svn_commit"         : "",
    }
.. @+node:ekr.20180305050514.1: ** #780: @tabwidth -2 in @data qt-gui-plugin-style-sheet crashes Leo
@tabwidth -2 in @data qt-gui-plugin-style-sheet crashes Leo on startup
https://github.com/leo-editor/leo-editor/issues/780
.. @+node:ekr.20140915062551.19510: *3* ssm.expand_css_constants & helpers
css_warning_given = False

def expand_css_constants(self, sheet, font_size_delta=None, settingsDict=None):
    '''Expand @ settings into their corresponding constants.'''
    trace = False and not g.unitTesting
    trace_dict = False
    trace_loop = True
    trace_result = False
    c = self.c
    # Warn once if the stylesheet uses old style style-sheet comment
    if settingsDict is None:
        if trace: g.trace('----- using c.config.settingsDict')
        settingsDict = c.config.settingsDict
    if trace_dict:
        g.trace('===== settingsDict.keys()...')
        g.printObj(sorted(settingsDict.keys()))
    constants, deltas = self.adjust_sizes(font_size_delta, settingsDict)
    sheet = self.replace_indicator_constants(sheet)
    for pass_n in range(10):
        to_do = self.find_constants_referenced(sheet)
        if not to_do:
            break
        if trace and trace_loop:
            g.trace('===== pass %s, to_do...' % (1+pass_n))
            g.printList(to_do)
        old_sheet = sheet
        sheet = self.do_pass(constants, deltas, settingsDict, sheet, to_do)
        if sheet == old_sheet:
            break
    else:
       g.trace('Too many iterations')
    if to_do:
        g.trace('Unresolved @constants')
        g.printObj(to_do)
    sheet = self.resolve_urls(sheet)
    sheet = sheet.replace('\\\n', '') # join lines ending in \
    if trace and trace_result:
        g.trace('returns...\n', sheet)
    return sheet
.. @+node:ekr.20150617085045.1: *4* ssm.adjust_sizes
def adjust_sizes(self, font_size_delta, settingsDict):
    '''Adjust constants to reflect c._style_deltas.'''
    trace = False and not g.unitTesting
    c = self.c
    constants = {} # old: self.find_constants_defined(sheet)
    deltas = c._style_deltas
    # legacy
    if font_size_delta:
        deltas['font-size-body'] = font_size_delta
    if trace:
        g.trace('c._style_deltas', c._style_deltas)
    for delta in c._style_deltas:
        # adjust @font-size-body by font_size_delta
        # easily extendable to @font-size-*
        val = c.config.getString(delta)
        passes = 10
        while passes and val and val.startswith('@'):
            key = g.app.config.canonicalizeSettingName(val[1:])
            val = settingsDict.get(key)
            if val:
                val = val.val
            passes -= 1
        if deltas[delta] and (val is not None):
            size = ''.join(i for i in val if i in '01234567890.')
            units = ''.join(i for i in val if i not in '01234567890.')
            size = max(1, int(size) + deltas[delta])
            constants["@" + delta] = "%s%s" % (size, units)
    return constants, deltas
.. @+node:ekr.20180316093159.1: *4* ssm.do_pass
def do_pass(self, constants, deltas, settingsDict, sheet, to_do):
    
    trace = False and not g.unitTesting
    trace_found = True
    to_do.sort(key=len, reverse=True)
    for const in to_do:
        value = None
        if const in constants:
            # This constant is about to be removed.
            value = constants[const]
            if const[1:] not in deltas and not self.css_warning_given:
                self.css_warning_given = True
                g.es_print("'%s' from style-sheet comment definition, " % const)
                g.es_print("please use regular @string / @color type @settings.")
        else:
            key = g.app.config.canonicalizeSettingName(const[1:])
                # lowercase, without '@','-','_', etc.
            value = settingsDict.get(key)
            if value is not None:
                # New in Leo 5.5: Do NOT add comments here.
                # They RUIN style sheets if they appear in a nested comment!
                    # value = '%s /* %s */' % (g.u(value.val), key)
                value = g.u(value.val)
                if trace and trace_found:
                   g.trace('found: %30s %s' % (key, g.truncate(repr(value), 30)))
            elif key in self.color_db:
                # New in Leo 5.5: Do NOT add comments here.
                # They RUIN style sheets if they appear in a nested comment!
                value = self.color_db.get(key)
                    # value = '%s /* %s */' % (value, key)
                if trace and trace_found:
                    g.trace('found: %30s %s' % (key, g.truncate(repr(value), 30)))
        if value:
            # Partial fix for #780.
            try:
                sheet = re.sub(
                    const + "(?![-A-Za-z0-9_])",
                        # don't replace shorter constants occuring in larger
                    value,
                    sheet,
                )
            except Exception:
                g.es_print('Exception handling style sheet')
                g.es_print(sheet)
                g.es_exception()
        else:
            pass
            # tricky, might be an undefined identifier, but it might
            # also be a @foo in a /* comment */, where it's harmless.
            # So rely on whoever calls .setStyleSheet() to do the right thing.
    return sheet
.. @+node:tbrown.20131120093739.27085: *4* ssm.find_constants_referenced
def find_constants_referenced(self, text):
    """find_constants - Return a list of constants referenced in the supplied text,
    constants match::

        @[A-Za-z_][-A-Za-z0-9_]*
        i.e. @foo_1-5

    :Parameters:
    - `text`: text to search
    """
    aList = sorted(set(re.findall(r"@[A-Za-z_][-A-Za-z0-9_]*", text)))
    # Exempt references to Leo constructs.
    for s in ('@button', '@constants', '@data', '@language'):
        if s in aList:
            aList.remove(s)
    return aList
.. @+node:tbrown.20130411121812.28335: *4* ssm.find_constants_defined (no longer used)
def find_constants_defined(self, text):
    r"""find_constants - Return a dict of constants defined in the supplied text.

    NOTE: this supports a legacy way of specifying @<identifiers>, regular
    @string and @color settings should be used instead, so calling this
    wouldn't be needed.  expand_css_constants() issues a warning when
    @<identifiers> are found in the output of this method.

    Constants match::

        ^\s*(@[A-Za-z_][-A-Za-z0-9_]*)\s*=\s*(.*)$
        i.e.
        @foo_1-5=a
            @foo_1-5 = a more here

    :Parameters:
    - `text`: text to search
    """
    pattern = re.compile(r"^\s*(@[A-Za-z_][-A-Za-z0-9_]*)\s*=\s*(.*)$")
    ans = {}
    text = text.replace('\\\n', '') # merge lines ending in \
    for line in text.split('\n'):
        test = pattern.match(line)
        if test:
            ans.update([test.groups()])
    # constants may refer to other constants, de-reference here
    change = True
    level = 0
    while change and level < 10:
        level += 1
        change = False
        for k in ans:
            # pylint: disable=unnecessary-lambda
            # process longest first so @solarized-base0 is not replaced
            # when it's part of @solarized-base03
            for o in sorted(ans, key=lambda x: len(x), reverse=True):
                if o in ans[k]:
                    change = True
                    ans[k] = ans[k].replace(o, ans[o])
    if level == 10:
        print("Ten levels of recursion processing styles, abandoned.")
        g.es("Ten levels of recursion processing styles, abandoned.")
    return ans
.. @+node:ekr.20150617090104.1: *4* ssm.replace_indicator_constants
def replace_indicator_constants(self, sheet):
    '''
    In the stylesheet, replace (if they exist)::

        image: @tree-image-closed
        image: @tree-image-open

    by::

        url(path/closed.png)
        url(path/open.png)

    path can be relative to ~ or to leo/Icons.

    Assuming that ~/myIcons/closed.png exists, either of these will work::

        @string tree-image-closed = nodes-dark/triangles/closed.png
        @string tree-image-closed = myIcons/closed.png

    Return the updated stylesheet.
    '''
    trace = False and not g.unitTesting
    close_path = self.find_icon_path('tree-image-closed')
    open_path = self.find_icon_path('tree-image-open')
    # Make all substitutions in the stylesheet.
    table = (
        (open_path,  re.compile(r'\bimage:\s*@tree-image-open', re.IGNORECASE)),
        (close_path, re.compile(r'\bimage:\s*@tree-image-closed', re.IGNORECASE)),
        # (open_path,  re.compile(r'\bimage:\s*at-tree-image-open', re.IGNORECASE)),
        # (close_path, re.compile(r'\bimage:\s*at-tree-image-closed', re.IGNORECASE)),
    )
    if trace:
        g.trace('open path: ', repr(open_path))
        g.trace('close_path:', repr(close_path))
    for path, pattern in table:
        for mo in pattern.finditer(sheet):
            old = mo.group(0)
            new = 'image: url(%s)' % path
            if trace: g.trace('found', old)
            sheet = sheet.replace(old, new)
    return sheet
.. @+node:ekr.20180320054305.1: *4* ssm.resolve_urls
def resolve_urls(self, sheet):
    '''Resolve all relative url's so they use absolute paths.'''
    trace = g.trace_themes and not g.unitTesting
    pattern = re.compile(r'url\((.*)\)')
    join = g.os_path_finalize_join
    directories = self.compute_icon_directories()
    paths_traced = False
    if trace:
        paths_traced = True
        g.trace('Search paths...')
        g.printObj(directories)
    # Pass 1: Find all replacements without changing the sheet.
    replacements = []
    for mo in pattern.finditer(sheet):
        url = mo.group(1)
        if url.startswith(':/'):
            url = url[2:]
        elif g.os_path_isabs(url):
            if trace: g.trace('ABS:', url)
            continue
        for directory in directories:
            path = join(directory, url)
            if g.os_path_exists(path):
                if trace: g.trace('%35s ==> %s' % (url, path))
                old = mo.group(0)
                new = 'url(%s)' % path
                replacements.append((old, new),)
                break
        else:
            g.trace('%35s ==> %s' % (url, 'NOT FOUND'))
            if not paths_traced:
                paths_traced = True
                g.trace('Search paths...')
                g.printObj(directories)
    # Pass 2: Now we can safely make the replacements.
    for old, new in reversed(replacements):
        sheet = sheet.replace(old, new)
    return sheet
.. @+node:ekr.20180308043032.1: ** #788: (fix bug) Add support for themes
https://github.com/leo-editor/leo-editor/issues/788

Until recent changes, these settings worked:

@color log_text_foreground_color = #93a1a1
@color log_text_background_color = #073642
@color log_error_color = #dc322f
@color log_warning_color = #268bd2
.. @+node:ekr.20180308045611.1: *3* re: g.log is a synonym for g.es
.. @+node:ekr.20150127060254.5: *4* g.log_to_file
def log_to_file(s, fn=None):
    '''Write a message to ~/test/leo_log.txt.'''
    # g.trace(s)
    if fn is None:
        fn = g.os_path_expanduser('~/test/leo_log.txt')
    if not s.endswith('\n'):
        s = s + '\n'
    try:
        with open(fn, 'a') as f:
            f.write(s)
    except Exception:
        g.es_exception()
.. @+node:ekr.20070626132332: *4* g.es
def es(*args, **keys):
    '''Put all non-keyword args to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''
    trace = False
    verbose = False
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    if trace and verbose: # Effective for debugging.
        print()
        print('***es', args, keys)
        print('***es', 'logInited', app.logInited, 'log', log and id(log))
        print('***es', g.callers())
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
        'nodeLink': None,
    }
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress':
        return # New in 4.3.
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    newline = d.get('newline')
    s = g.translateArgs(args, d)
    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            # This makes the output of unit tests match the output of scripts.
            g.pr(s, newline=newline)
    elif log and app.logInited:
        if newline:
            s += '\n'
        log.put(s, color=color, tabName=tabName, nodeLink=d['nodeLink'])
        # Count the number of *trailing* newlines.
        for ch in s:
            if ch == '\n': log.newlines += 1
            else: log.newlines = 0
    else:
        app.logWaiting.append((s, color, newline, d),)
        
log = es

.. @+node:ekr.20120928142052.10116: *3* g.actualColor
def actualColor(color):
    '''Return the actual color corresponding to the requested color.'''
    trace = False and not g.unitTesting
    c = g.app.log and g.app.log.c
    # Careful: c.config may not yet exist.
    if not c or not c.config:
        return color
    # Don't change absolute colors.
    if color and color.startswith('#'):
        return color
    # #788: Translate colors to theme-defined colors.
    if color is None:
        # Prefer text_foreground_color'
        color2 = c.config.getColor('log_text_foreground_color')
        if trace: g.trace(repr(color), '=> text_foreground_color', color2)
        if color2: return color2
        # Fall back to log_black_color.
        color2 = c.config.getColor('log_black_color')
        if trace: g.trace(repr(color), '=> log_black_color', color2)
        return color2 or 'black'
    if color == 'black':
        # Prefer log_black_color.
        color2 = c.config.getColor('log_black_color')
        if trace: g.trace(repr(color), '=> log_black_color', color2)
        if color2: return color2
        # Fall back to log_text_foreground_color.
        color2 = c.config.getColor('log_text_foreground_color')
        if trace: g.trace(repr(color), '=> text_foreground_color', color2)
        return color2 or 'black'
    color2 = c.config.getColor('log_%s_color' % color)
    if trace: g.trace("log_%s_color" % (color), color2)
    return color2 or color
.. @+node:ekr.20100914094836.5892: *3* g.error, g.note, g.warning, g.red, g.blue
def blue(*args, **keys):
    g.es_print(color='blue', *args, **keys)

def error(*args, **keys):
    g.es_print(color='error', *args, **keys)

def note(*args, **keys):
    g.es_print(color='note', *args, **keys)

def red(*args, **keys):
    g.es_print(color='red', *args, **keys)

def warning(*args, **keys):
    g.es_print(color='warning', *args, **keys)
.. @+node:ekr.20070626132332: *3* g.es
def es(*args, **keys):
    '''Put all non-keyword args to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''
    trace = False
    verbose = False
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    if trace and verbose: # Effective for debugging.
        print()
        print('***es', args, keys)
        print('***es', 'logInited', app.logInited, 'log', log and id(log))
        print('***es', g.callers())
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
        'nodeLink': None,
    }
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress':
        return # New in 4.3.
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    newline = d.get('newline')
    s = g.translateArgs(args, d)
    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            # This makes the output of unit tests match the output of scripts.
            g.pr(s, newline=newline)
    elif log and app.logInited:
        if newline:
            s += '\n'
        log.put(s, color=color, tabName=tabName, nodeLink=d['nodeLink'])
        # Count the number of *trailing* newlines.
        for ch in s:
            if ch == '\n': log.newlines += 1
            else: log.newlines = 0
    else:
        app.logWaiting.append((s, color, newline, d),)
        
log = es

.. @+node:ekr.20110605121601.18322: *3* LeoQtLog.put
def put(self, s, color=None, tabName='Log', from_redirect=False, nodeLink=None):
    '''
    Put s to the Qt Log widget, converting to html.
    All output to the log stream eventually comes here.

    The from_redirect keyword argument is no longer used.
    '''
    trace = False and not g.unitTesting
    trace_entry = True
    trace_s = False
    c = self.c
    if g.app.quitting or not c or not c.exists:
        if trace:
            print('LeoQtLog.log.put fails: %r' % s)
        return
    # Note: g.actualColor does all color translation.
    if color:
        color = leoColor.getColor(color)
    if not color:
        # #788: First, fall back to 'log_black_color', not 'black.
        color = c.config.getColor('log_black_color')
        if not color:
            # Should never be necessary.
            color = 'black'
    self.selectTab(tabName or 'Log')
    # Must be done after the call to selectTab.
    w = self.logCtrl.widget # w is a QTextBrowser
    if w:
        if trace and trace_entry:
            print('LeoQtLog.log.put: %r' % s)
        sb = w.horizontalScrollBar()
        s = s.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
        if not self.wrap:
            # Use &nbsp; only when not wrapping!
            s = s.replace(' ', '&nbsp;')
        s = s.replace('\n', '<br>')
            # The caller is responsible for newlines!
        s = '<font color="%s">%s</font>' % (color, s)
        if nodeLink:
            url = nodeLink
            for scheme in 'file', 'unl':
                # QUrl requires paths start with '/'
                if url.startswith(scheme+'://') and not url.startswith(scheme+':///'):
                    url = url.replace('://', ':///', 1)
            s = '<a href="%s" title="%s">%s</a>' % (url, nodeLink, s)
        if trace and trace_s:
            print('LeoQtLog.put: %r' % (s))
        w.insertHtml(s)
        w.moveCursor(QtGui.QTextCursor.End)
        sb.setSliderPosition(0) # Force the slider to the initial position.
        w.repaint() # Slow, but essential.
    #
    # else:
        # # Does this ever happen?
        # g.app.logWaiting.append((s, color, True),)
        # g.pr(s, color=color, newline=True)
.. @+node:ekr.20180314074520.1: ** ---- normalize paths
.. @+node:ekr.20031218072017.2145: *3* g.os_path_ Wrappers
@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.
.. @+node:ekr.20180314120442.1: *4* g.glob_glob
def glob_glob (pattern):
    '''Return the regularized glob.glob(pattern)'''
    aList = glob.glob(pattern)
    if g.isWindows:
        aList = [z.replace('\\','/') for z in aList]
    return aList
.. @+node:ekr.20031218072017.2146: *4* g.os_path_abspath
def os_path_abspath(path):
    """Convert a path to an absolute path."""
    path = g.toUnicodeFileEncoding(path)
    path = path.replace('\x00','') # Fix Pytyon 3 bug on Windows 10.
    path = os.path.abspath(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20031218072017.2147: *4* g.os_path_basename
def os_path_basename(path):
    """Return the second half of the pair returned by split(path)."""
    path = g.toUnicodeFileEncoding(path)
    path = os.path.basename(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20031218072017.2148: *4* g.os_path_dirname
def os_path_dirname(path):
    """Return the first half of the pair returned by split(path)."""
    path = g.toUnicodeFileEncoding(path)
    path = os.path.dirname(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20031218072017.2149: *4* g.os_path_exists
def os_path_exists(path):
    """Return True if path exists."""
    path = g.toUnicodeFileEncoding(path)
    path = path.replace('\x00','') # Fix Pytyon 3 bug on Windows 10.
    return os.path.exists(path)
.. @+node:ekr.20080922124033.6: *4* g.os_path_expandExpression & helper
def os_path_expandExpression(s, **keys):
    '''Expand all {{anExpression}} in c's context.'''
    trace = False and g.unitTesting
    c = keys.get('c')
    if not c:
        g.trace('can not happen: no c', g.callers())
        return s
    if not s:
        if trace: g.trace('no s')
        return ''
    s = g.toUnicode(s)
    # find and replace repeated path expressions
    previ, aList = 0, []
    while previ < len(s):
        i = s.find('{{', previ)
        j = s.find('}}', previ)
        if -1 < i < j:
            # Add anything from previous index up to '{{'
            if previ < i:
                aList.append(s[previ:i])
            # Get expression and find substitute
            exp = s[i + 2: j].strip()
            if exp:
                try:
                    s2 = replace_path_expression(c, exp)
                    if trace: g.trace('%r ==> %r' % (exp, s2))
                    aList.append(s2)
                except Exception:
                    g.es('Exception evaluating {{%s}} in %s' % (exp, s.strip()))
                    g.es_exception(full=True, c=c)
            # Prepare to search again after the last '}}'
            previ = j+2
        else:
            # Add trailing fragment (fragile in case of mismatched '{{'/'}}')
            aList.append(s[previ:])
            break
    val = ''.join(aList)
    if g.isWindows:
        val = val.replace('\\','/')
    if trace: g.trace(' returns', val)
    return val
.. @+node:ekr.20180120140558.1: *5* g.replace_path_expression
def replace_path_expression(c, expr):
    ''' local function to replace a single path expression.'''
    d = {
        'c': c,
        'g': g,
        # 'getString': c.config.getString,
        'p': c.p,
        'os': os,
        'sep': os.sep,
        'sys': sys,
    }
    val = eval(expr, d)
    return g.toUnicode(val, encoding='utf-8', reportErrors=True)
.. @+node:ekr.20080921060401.13: *4* g.os_path_expanduser
def os_path_expanduser(path):
    """wrap os.path.expanduser"""
    path = g.toUnicodeFileEncoding(path)
    result = os.path.normpath(os.path.expanduser(path))
    if g.isWindows:
        path = path.replace('\\','/')
    return result
.. @+node:ekr.20080921060401.14: *4* g.os_path_finalize
def os_path_finalize(path, **keys):
    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.
    There is no corresponding os.path method
    '''
    c = keys.get('c')
    expanduser = keys.get('expanduser', True)
        # 2014/09/17: Allow expanduser to be False.
    if c: path = g.os_path_expandExpression(path, **keys)
    if expanduser:
        path = g.os_path_expanduser(path)
    path = path.replace('\x00','') # Fix Pytyon 3 bug on Windows 10.
    path = os.path.abspath(path)
    path = os.path.normpath(path)
    if g.isWindows:
        path = path.replace('\\','/')
    # calling os.path.realpath here would cause problems in some situations.
    return path
.. @+node:ekr.20140917154740.19483: *4* g.os_path_finalize_join
def os_path_finalize_join(*args, **keys):
    '''Do os.path.join(*args), then finalize the result.'''
    c = keys.get('c')
    if c:
        args = [g.os_path_expandExpression(z, **keys)
            for z in args if z]
    path = os.path.normpath(os.path.abspath(
        g.os_path_join(*args, **keys))) # Handles expanduser
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20031218072017.2150: *4* g.os_path_getmtime
def os_path_getmtime(path):
    """Return the modification time of path."""
    path = g.toUnicodeFileEncoding(path)
    try:
        return os.path.getmtime(path)
    except Exception:
        return 0
.. @+node:ekr.20080729142651.2: *4* g.os_path_getsize
def os_path_getsize(path):
    '''Return the size of path.'''
    path = g.toUnicodeFileEncoding(path)
    return os.path.getsize(path)
.. @+node:ekr.20031218072017.2151: *4* g.os_path_isabs
def os_path_isabs(path):
    """Return True if path is an absolute path."""
    path = g.toUnicodeFileEncoding(path)
    return os.path.isabs(path)
.. @+node:ekr.20031218072017.2152: *4* g.os_path_isdir
def os_path_isdir(path):
    """Return True if the path is a directory."""
    path = g.toUnicodeFileEncoding(path)
    return os.path.isdir(path)
.. @+node:ekr.20031218072017.2153: *4* g.os_path_isfile
def os_path_isfile(path):
    """Return True if path is a file."""
    path = g.toUnicodeFileEncoding(path)
    return os.path.isfile(path)
.. @+node:ekr.20031218072017.2154: *4* g.os_path_join
def os_path_join(*args, **keys):
    '''
    The same as os.path.join, but safe for unicode.
    In addition, it supports the !! and . conventions.
    '''
    trace = False and not g.unitTesting
    c = keys.get('c')
    expanduser = keys.get('expanduser', True)
        # 2014/09/17: Allow expanduser to be False.
    uargs = [g.toUnicodeFileEncoding(arg) for arg in args]
    if trace: g.trace('1', uargs)
    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)
    if expanduser:
        uargs = [g.os_path_expanduser(z) for z in uargs if z]
    if trace: g.trace('2', uargs)
    if uargs:
        try:
            path = os.path.join(*uargs)
        except TypeError:
            g.trace(uargs, args, keys, g.callers())
            raise
    else:
        path = '' # 2017/11/12: don't crash.
    if trace: g.trace('3', path)
    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path)
    path = path.replace('\x00','') # Fix Pytyon 3 bug on Windows 10.
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20031218072017.2156: *4* g.os_path_normcase
def os_path_normcase(path):
    """Normalize the path's case."""
    path = g.toUnicodeFileEncoding(path)
    path = os.path.normcase(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20031218072017.2157: *4* g.os_path_normpath
def os_path_normpath(path):
    """Normalize the path."""
    path = g.toUnicodeFileEncoding(path)
    path = os.path.normpath(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20180314081254.1: *4* g.os_path_normslashes
def os_path_normslashes(path):
    if g.isWindows and path:
        path = path.replace('\\','/')
    return path
    
    
.. @+node:ekr.20080605064555.2: *4* g.os_path_realpath
def os_path_realpath(path):
    '''Return the canonical path of the specified filename, eliminating any
    symbolic links encountered in the path (if they are supported by the
    operating system).
    '''
    path = g.toUnicodeFileEncoding(path)
    path = os.path.realpath(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20031218072017.2158: *4* g.os_path_split
def os_path_split(path):
    path = g.toUnicodeFileEncoding(path)
    head, tail = os.path.split(path)
    head = g.toUnicodeFileEncoding(head)
    tail = g.toUnicodeFileEncoding(tail)
    return head, tail
.. @+node:ekr.20031218072017.2159: *4* g.os_path_splitext
def os_path_splitext(path):
    path = g.toUnicodeFileEncoding(path)
    head, tail = os.path.splitext(path)
    head = g.toUnicodeFileEncoding(head)
    tail = g.toUnicodeFileEncoding(tail)
    return head, tail
.. @+node:ekr.20090829140232.6036: *4* g.os_startfile
def os_startfile(fname):
    @others

    if fname.find('"') > -1:
        quoted_fname = "'%s'" % fname
    else:
        quoted_fname = '"%s"' % fname
    if sys.platform.startswith('win'):
        # pylint: disable=no-member
        os.startfile(quoted_fname)
            # Exists only on Windows.
    elif sys.platform == 'darwin':
        # From Marc-Antoine Parent.
        try:
            # Fix bug 1226358: File URL's are broken on MacOS:
            # use fname, not quoted_fname, as the argument to subprocess.call.
            subprocess.call(['open', fname])
        except OSError:
            pass # There may be a spurious "Interrupted system call"
        except ImportError:
            os.system('open %s' % (quoted_fname))
    else:
        # Linux
        # The buffering argument to NamedTempFile does not exist on Python 2.
        try:
            ree = None
            wre = tempfile.NamedTemporaryFile()
            ree = io.open(wre.name, 'rb', buffering=0)
        except IOError:
            g.trace('error opening temp file for %r' % fname)
            if ree: ree.close()
            return
        try:
            subPopen = subprocess.Popen(['xdg-open', fname], stderr=wre, shell=False)
        except Exception:
            g.es_print('error opening %r' % fname)
            g.es_exception()
        try:
            itoPoll = g.IdleTime((lambda ito: itPoll(fname, ree, subPopen, g, ito)), delay=1000)
            itoPoll.start()
            # Let the Leo-Editor process run
            # so that Leo-Editor is usable while the file is open.
        except Exception:
            g.es_exception('exception executing g.startfile for %r' % fname)
.. @+node:bob.20170516112250.1: *5* stderr2log()
def stderr2log(g, ree, fname):
    """ Display stderr output in the Leo-Editor log pane

    Arguments:
        g:  Leo-Editor globals
        ree:  Read file descriptor for stderr
        fname:  file pathname

    Returns:
        None
    """

    while True:
        emsg = ree.read().decode('utf-8')
        if emsg:
            g.es_print_error('xdg-open {fn} caused output to stderr:\n{em}'.format(fn=fname, em=emsg))
        else:
            break
.. @+node:bob.20170516112304.1: *5* itPoll()
def itPoll(fname, ree, subPopen, g, ito):
    """ Poll for subprocess done

    Arguments:
        fname:  File name
        ree:  stderr read file descriptor
        subPopen:  URL open subprocess object
        g: Leo-Editor globals
        ito: Idle time object for itPoll()

    Returns:
        None
    """

    stderr2log(g, ree, fname)
    rc = subPopen.poll()
    if not rc is None:
        ito.stop()
        ito.destroy_self()
        if rc != 0:
            g.es_print('xdg-open {fn} failed with exit code {ec}'.format(fn=fname, ec=rc))
        stderr2log(g, ree, fname)
        ree.close()

.. @+node:ekr.20031218072017.2160: *4* g.toUnicodeFileEncoding
def toUnicodeFileEncoding(path):
    # Fix bug 735938: file association crash
    if path and g.isString(path):
        path = path.replace('\\', os.sep)
        # Yes, this is correct.  All os_path_x functions return Unicode strings.
        return g.toUnicode(path)
    else:
        return g.u('')
.. @+node:ekr.20031218072017.2986: *3* c.fileName & relativeFileName & shortFileName
# Compatibility with scripts

def fileName(self):
    s = self.mFileName
    if g.isWindows:
        s = s.replace('\\','/')
    return s

def relativeFileName(self):
    return self.mRelativeFileName or self.mFileName

def shortFileName(self):
    return g.shortFileName(self.mFileName)

shortFilename = shortFileName
.. @+node:ekr.20180315020503.1: ** #812: g.glob_glob problems
g.glob_glob may have broken bookmarks/urls/unls on Windows
https://github.com/leo-editor/leo-editor/issues/812

PickleShareDB.keys should definitely not call g.glob_glob.
.. @+node:ekr.20140711071454.17654: *3* g.recursiveUNLFind
def recursiveUNLFind(unlList, c, depth=0, p=None, maxdepth=0, maxp=None,
                     soft_idx=False, hard_idx=False):
    """
    Internal part of recursiveUNLSearch which doesn't change the
    selected position or call c.frame.bringToFront()

    returns found, depth, p, where:

        - found is True if a full match was found
        - depth is the depth of the best match
        - p is the position of the best match

    NOTE: maxdepth is max depth seen in recursion so far, not a limit on
          how far we will recurse.  So it should default to 0 (zero).

    - `unlList`: list of 'headline', 'headline:N', or 'headline:N,M'
      elements, where N is the node's position index and M the zero based
      count of like named nodes, eg. 'foo:2', 'foo:4,1', 'foo:12,3'
    - `c`: outline
    - `soft_idx`: use index when matching name not found
    - `hard_idx`: use only indexes, ignore node names
    - `depth`: part of recursion, don't set explicitly
    - `p`: part of recursion, don't set explicitly
    - `maxdepth`: part of recursion, don't set explicitly
    - `maxp`: part of recursion, don't set explicitly
    """
    if depth == 0:
        nds = list(c.rootPosition().self_and_siblings())
        unlList = [i.replace('--%3E', '-->') for i in unlList if i.strip()]
        # drop empty parts so "-->node name" works
    else:
        nds = list(p.children())
    heads = [i.h for i in nds]
    # work out order in which to try nodes
    order = []
    nth_sib = nth_same = nth_line_no = nth_col_no = None
    try:
        target = unlList[depth]
    except IndexError:
        target = ''
    try:
        target = pos_pattern.sub('', unlList[depth])
        nth_sib, nth_same, nth_line_no, nth_col_no = recursiveUNLParts(unlList[depth])
        pos = nth_sib is not None
    except IndexError:
        # Fix bug https://github.com/leo-editor/leo-editor/issues/36
        pos = False
    if pos:
        use_idx_mode = True # ok to use hard/soft_idx
        target = re.sub(pos_pattern, "", target).replace('--%3E', '-->')
        if hard_idx:
            if nth_sib < len(heads):
                order.append(nth_sib)
        else:
            # First we try the nth node with same header
            if nth_same:
                nths = [n for n, i in enumerate(heads) if i == target]
                if nth_same < len(nths) and heads[nths[nth_same]] == target:
                    order.append(nths[nth_same])
            # Then we try *all* other nodes with same header
            order += [n for n, s in enumerate(heads)
                        if n not in order and s == target]
            # Then position based, if requested
            if soft_idx and nth_sib < len(heads):
                order.append(nth_sib)
    elif hard_idx:
        pass # hard_idx mode with no idx in unl, go with empty order list
    else:
        order = range(len(nds))
        target = target.replace('--%3E', '-->')
        use_idx_mode = False # not ok to use hard/soft_idx
        # note, the above also fixes calling with soft_idx=True and an old UNL

    for ndi in order:
        nd = nds[ndi]
        if (
            target == nd.h or
            (use_idx_mode and (soft_idx or hard_idx) and ndi == nth_sib)
        ):
            if depth + 1 == len(unlList): # found it
                return True, maxdepth, nd
            else:
                if maxdepth < depth + 1:
                    maxdepth = depth + 1
                    maxp = nd.copy()
                found, maxdepth, maxp = g.recursiveUNLFind(
                    unlList, c, depth + 1, nd,
                    maxdepth, maxp, soft_idx=soft_idx, hard_idx=hard_idx)
                if found:
                    return found, maxdepth, maxp
                # else keep looking through nds
    if depth == 0 and maxp: # inexact match
        g.es('Partial UNL match')
    if soft_idx and depth + 2 < len(unlList):
        aList = []
        for p in c.all_unique_positions():
            if any([p.h.replace('--%3E', '-->') in unl for unl in unlList]):
                aList.append((p.copy(), p.get_UNL(False, False, True)))
        maxcount = 0
        singleMatch = True
        for iter_unl in aList:
            count = 0
            compare_list = unlList[:]
            for header in reversed(iter_unl[1].split('-->')):
                if (re.sub(pos_pattern, "", header).replace('--%3E', '-->') ==
                     compare_list[-1]
                ):
                    count = count + 1
                    compare_list.pop(-1)
                else:
                    break
            if count > maxcount:
                p = iter_unl[0]
                singleMatch = True
            elif count == maxcount:
                singleMatch = False
        if maxcount and singleMatch:
            maxp = p
            maxdepth = p.level()
    return False, maxdepth, maxp
.. @+node:ekr.20150525123715.1: *3* class ProjectUtils
class ProjectUtils(object):
    '''A class to compute the files in a project.'''
    # To do: get project info from @data nodes.
    @others
.. @+node:ekr.20150525123715.2: *4* pu.files_in_dir
def files_in_dir(self, theDir, recursive=True, extList=None, excludeDirs=None):
    '''
    Return a list of all Python files in the directory.
    Include all descendants if recursiveFlag is True.
    Include all file types if extList is None.
    '''
    # import glob
    import os
    # if extList is None: extList = ['.py']
    if excludeDirs is None: excludeDirs = []
    result = []
    if recursive:
        for root, dirs, files in os.walk(theDir):
            for z in files:
                fn = g.os_path_finalize_join(root, z)
                junk, ext = g.os_path_splitext(fn)
                if not extList or ext in extList:
                    result.append(fn)
            if excludeDirs and dirs:
                for z in dirs:
                    if z in excludeDirs:
                        dirs.remove(z)
    else:
        for ext in extList:
            result.extend(g.glob_glob('%s.*%s' % (theDir, ext)))
    return sorted(list(set(result)))
.. @+node:ekr.20150525123715.3: *4* pu.get_project_directory
def get_project_directory(self, name):
    # Ignore everything after the first space.
    i = name.find(' ')
    if i > -1:
        name = name[: i].strip()
    leo_path, junk = g.os_path_split(__file__)
    d = {
        # Change these paths as required for your system.
        'coverage': r'C:\Python26\Lib\site-packages\coverage-3.5b1-py2.6-win32.egg\coverage',
        'leo': r'C:\leo.repo\leo-editor\leo\core',
        'lib2to3': r'C:\Python26\Lib\lib2to3',
        'pylint': r'C:\Python26\Lib\site-packages\pylint',
        'rope': r'C:\Python26\Lib\site-packages\rope-0.9.4-py2.6.egg\rope\base',
        'test': g.os_path_finalize_join(g.app.loadDir, '..', 'test-proj'),
    }
    dir_ = d.get(name.lower())
    # g.trace(name,dir_)
    if not dir_:
        g.trace('bad project name: %s' % (name))
    if not g.os_path_exists(dir_):
        g.trace('directory not found:' % (dir_))
    return dir_ or ''
.. @+node:ekr.20171213071416.1: *4* pu.leo_core_files
def leo_core_files(self):
    '''Return all the files in Leo's core.'''
    trace = False
    loadDir = g.app.loadDir
    # Compute directories.
    commands_dir = g.os_path_finalize_join(loadDir, '..', 'commands')
    plugins_dir = g.os_path_finalize_join(loadDir, '..', 'plugins')
    # Compute files.
    core_files = g.glob_glob('%s%s%s' % (loadDir, os.sep, '*.py'))
    for exclude in ['format-code.py',]:
        core_files = [z for z in core_files if not z.endswith(exclude)]
    command_files = g.glob_glob('%s%s%s' % (commands_dir, os.sep, '*.py'))
    plugins_files = g.glob_glob('%s%s%s' % (plugins_dir, os.sep, 'qt_*.py'))
    # Compute the result.
    files = core_files + command_files + plugins_files
    files = [z for z in files if not z.endswith('__init__.py')]
    if trace: g.printList(files)
    return files
.. @+node:ekr.20150525123715.4: *4* pu.project_files
@nobeautify

def project_files(self, name, force_all=False):
    '''Return a list of all files in the named project.'''
    # Ignore everything after the first space.
    i = name.find(' ')
    if i > -1:
        name = name[: i].strip()
    leo_path, junk = g.os_path_split(__file__)
    if name == 'leo':
        # Get the leo files directly.
        return self.leo_core_files()
    else:
        # Import the appropriate module.
        try:
            m = importlib.import_module(name, name)
            theDir = g.os_path_dirname(m.__file__)
        except ImportError:
            g.trace('package not found', name)
            return []
    d = {
        'coverage': (['.py'], ['.bzr', 'htmlfiles']),
        'lib2to3':  (['.py'], ['tests']),
        'pylint':   (['.py'], ['.bzr', 'test']),
        'rope':     (['.py'], ['.bzr']),
    }
    data = d.get(name.lower())
    if not data:
        g.trace('bad project name: %s' % (name))
        return []
    extList, excludeDirs = data
    files = self.files_in_dir(theDir,
        recursive=True,
        extList=extList,
        excludeDirs=excludeDirs,
    )
    if files:
        if g.app.runningAllUnitTests and len(files) > 1 and not force_all:
            return [files[0]]
    if not files:
        g.trace('no files found for %s in %s' % (name, theDir))
    if g.app.runningAllUnitTests and len(files) > 1 and not force_all:
        return [files[0]]
    else:
        return files
.. @+node:ekr.20140813052702.18194: *3* class FileNameChooser
class FileNameChooser(object):
    '''A class encapsulation file selection & completion logic.'''
    # pylint: disable=no-self-argument
    # The first argument is fnc.
    @others
.. @+node:ekr.20140813052702.18195: *4* fnc.__init__
def __init__(fnc, c):
    '''Ctor for FileNameChooser class.'''
    # g.trace('(FileNameChooser)',c.shortFileName(),g.callers())
    fnc.c = c
    fnc.k = c.k
    assert c and c.k
    fnc.log = c.frame.log or g.NullObject()
    fnc.callback = None
    fnc.filterExt = None
    fnc.log = None # inited later.
    fnc.prompt = None
    fnc.tabName = None
.. @+node:ekr.20140813052702.18196: *4* fnc.compute_tab_list
def compute_tab_list(fnc):
    '''Compute the list of completions.'''
    trace = False and not g.unitTesting
    path = fnc.get_label()
    # Fix bug 215: insert-file-name doesn't process ~
    # https://github.com/leo-editor/leo-editor/issues/215
    path = g.os_path_expanduser(path)
    sep = os.path.sep
    if g.os_path_exists(path):
        if trace: g.trace('existing directory', path)
        if g.os_path_isdir(path):
            if path.endswith(os.sep):
                aList = g.glob_glob(path + '*')
            else:
                aList = g.glob_glob(path + sep + '*')
            tabList = [z + sep if g.os_path_isdir(z) else z for z in aList]
        else:
            # An existing file.
            tabList = [path]
    else:
        if trace: g.trace('does not exist', path)
        if path and path.endswith(sep):
            path = path[: -1]
        aList = g.glob_glob(path + '*')
        tabList = [z + sep if g.os_path_isdir(z) else z for z in aList]
    if fnc.filterExt:
        for ext in fnc.filterExt:
            tabList = [z for z in tabList if not z.endswith(ext)]
    junk, common_prefix = g.itemsMatchingPrefixInList(path, tabList)
    if trace: g.trace('common_prefix', common_prefix)
    return common_prefix, tabList
.. @+node:ekr.20140813052702.18197: *4* fnc.do_back_space
def do_back_space(fnc):
    '''Handle a back space.'''
    w = fnc.c.k.w
    if w and w.hasSelection():
        # s = w.getAllText()
        i, j = w.getSelectionRange()
        w.delete(i, j)
        s = fnc.get_label()
    else:
        s = fnc.get_label()
        if s:
            s = s[: -1]
        fnc.set_label(s)
    if s:
        common_prefix, tabList = fnc.compute_tab_list()
        # Do *not* extend the label to the common prefix.
    else:
        tabList = []
    fnc.show_tab_list(tabList)
.. @+node:ekr.20140813052702.18198: *4* fnc.do_char
def do_char(fnc, char):
    '''Handle a non-special character.'''
    w = fnc.c.k.w
    if w and w.hasSelection:
        # s = w.getAllText()
        i, j = w.getSelectionRange()
        w.delete(i, j)
        w.setInsertPoint(i)
        w.insert(i, char)
    else:
        fnc.extend_label(char)
    common_prefix, tabList = fnc.compute_tab_list()
    fnc.show_tab_list(tabList)
    if common_prefix:
        if 0:
            # This is a bit *too* helpful.
            # It's too easy to type ahead by mistake.
            # Instead, completion should happen only when the user types <tab>.
            fnc.set_label(common_prefix)
        # Recompute the tab list.
        common_prefix, tabList = fnc.compute_tab_list()
        fnc.show_tab_list(tabList)
        if len(tabList) == 1:
            # Automatically complete the typing only if there is only one item in the list.
            fnc.set_label(common_prefix)
    else:
        # Restore everything.
        fnc.set_label(fnc.get_label()[: -1])
        fnc.extend_label(char)
.. @+node:ekr.20140813052702.18199: *4* fnc.do_tab
def do_tab(fnc):
    '''Handle tab completion.'''
    old = fnc.get_label()
    common_prefix, tabList = fnc.compute_tab_list()
    fnc.show_tab_list(tabList)
    if len(common_prefix) > len(old):
        fnc.set_label(common_prefix)
.. @+node:ekr.20140813052702.18200: *4* fnc.get_file_name (entry)
def get_file_name(fnc, event, callback, filterExt, prompt, tabName):
    '''Get a file name, supporting file completion.'''
    trace = False and not g.unitTesting
    c, k = fnc.c, fnc.c.k
    tag = 'get-file-name'
    state = k.getState(tag)
    char = event.char if event else ''
    if trace:
        g.trace('state', state, 'char', char or '<**no char**>')
    if state == 0:
        # Re-init all ivars.
        fnc.log = c.frame.log or g.NullObject()
        fnc.callback = callback
        fnc.filterExt = filterExt or ['.pyc', '.bin',]
        fnc.prompt = prompt
        fnc.tabName = tabName
        # Init the label and state.
        if k.functionTail:
            path = k.functionTail.strip()
            fnc.set_label(g.os_path_finalize_join(os.curdir, path))
        else:
            fnc.set_label(g.os_path_finalize(os.curdir) + os.sep)
        k.setState(tag, 1, fnc.get_file_name)
        fnc.log.selectTab(fnc.tabName)
        junk, tabList = fnc.compute_tab_list()
        fnc.show_tab_list(tabList)
        c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n', 'Return'):
        fnc.log.deleteTab(fnc.tabName)
        path = fnc.get_label()
        k.keyboardQuit()
        if fnc.callback:
            # pylint: disable=not-callable
            fnc.callback(path)
        else:
            g.trace('no callback')
    elif char in ('\t', 'Tab'):
        fnc.do_tab()
        c.minibufferWantsFocus()
    elif char in ('\b', 'BackSpace'):
        fnc.do_back_space()
        c.minibufferWantsFocus()
    elif k.isPlainKey(char):
        fnc.do_char(char)
    else:
        pass
.. @+node:ekr.20140813052702.18201: *4* fnc.extend/get/set_label
def extend_label(fnc, s):
    '''Extend the label by s.'''
    fnc.c.k.extendLabel(s, select=False, protect=False)

def get_label(fnc):
    '''Return the label, not including the prompt.'''
    return fnc.c.k.getLabel(ignorePrompt=True)

def set_label(fnc, s):
    '''Set the label after the prompt to s. The prompt never changes.'''
    fnc.c.k.setLabel(fnc.prompt, protect=True)
    fnc.c.k.extendLabel(s or '', select=False, protect=False)
.. @+node:ekr.20140813052702.18202: *4* fnc.show_tab_list
def show_tab_list(fnc, tabList):
    '''Show the tab list in the log tab.'''
    fnc.log.clearTab(fnc.tabName)
    s = g.os_path_finalize(os.curdir) + os.sep
    # g.es('',s,tabName=fnc.tabName)
    for path in tabList:
        theDir, fileName = g.os_path_split(path)
        s = theDir if path.endswith(os.sep) else fileName
        s = fileName or g.os_path_basename(theDir) + os.sep
        g.es('', s, tabName=fnc.tabName)
.. @+node:ekr.20180315024614.1: *3* Found:g.glob_glob
# flattened, word, ignore-case, head, body

# found 14 nodes
.. @+node:ekr.20100208223942.5982: *4* keys & helpers (PickleShareDB)
# Called by clear, and during unit testing.

def keys(self, globpat=None):
    """Return all keys in DB, or all keys matching a glob"""
    trace = False and not g.unitTesting
    if globpat is None:
        files = self._walkfiles(self.root)
    else:
        # Do not call g.glob_glob here.
        files = [z for z in join(self.root, globpat)]
    result = [self._normalized(p) for p in files if isfile(p)]
    if trace: g.trace('(PickleShareDB)', len(result), result)
    return result
.. @+node:ekr.20100208223942.5976: *5* _normalized
def _normalized(self, p):
    """ Make a key suitable for user's eyes """
    # os.path.relpath doesn't work here.
    return self._relpathto(self.root, p).replace('\\', '/')
.. @+node:ekr.20100208223942.10460: *5* _relpathto
# Used only by _normalized.

def _relpathto(self, src, dst):
    """ Return a relative path from self to dst.

    If there is no relative path from self to dst, for example if
    they reside on different drives in Windows, then this returns
    dst.abspath().
    """
    origin = abspath(src)
    dst = abspath(dst)
    orig_list = self._splitall(normcase(origin))
    # Don't normcase dst!  We want to preserve the case.
    dest_list = self._splitall(dst)
    if orig_list[0] != normcase(dest_list[0]):
        # Can't get here from there.
        return dst
    # Find the location where the two paths start to differ.
    i = 0
    for start_seg, dest_seg in zip(orig_list, dest_list):
        if start_seg != normcase(dest_seg):
            break
        i += 1
    # Now i is the point where the two paths diverge.
    # Need a certain number of "os.pardir"s to work up
    # from the origin to the point of divergence.
    segments = [os.pardir] * (len(orig_list) - i)
    # Need to add the diverging part of dest_list.
    segments += dest_list[i:]
    if segments:
        return join(*segments)
    else:
        # If they happen to be identical, use os.curdir.
        return os.curdir
.. @+node:ekr.20100208223942.10462: *5* _splitall
# Used by relpathto.

def _splitall(self, s):
    """ Return a list of the path components in this path.

    The first item in the list will be a path.  Its value will be
    either os.curdir, os.pardir, empty, or the root directory of
    this path (for example, '/' or 'C:\\').  The other items in
    the list will be strings.

    path.path.joinpath(*result) will yield the original path.
    """
    parts = []
    loc = s
    while loc != os.curdir and loc != os.pardir:
        prev = loc
        loc, child = split(prev)
        if loc == prev:
            break
        parts.append(child)
    parts.append(loc)
    parts.reverse()
    return parts
.. @+node:ekr.20180315024728.1: *4* Looks correct
.. @+node:ekr.20140813052702.18196: *5* fnc.compute_tab_list
def compute_tab_list(fnc):
    '''Compute the list of completions.'''
    trace = False and not g.unitTesting
    path = fnc.get_label()
    # Fix bug 215: insert-file-name doesn't process ~
    # https://github.com/leo-editor/leo-editor/issues/215
    path = g.os_path_expanduser(path)
    sep = os.path.sep
    if g.os_path_exists(path):
        if trace: g.trace('existing directory', path)
        if g.os_path_isdir(path):
            if path.endswith(os.sep):
                aList = g.glob_glob(path + '*')
            else:
                aList = g.glob_glob(path + sep + '*')
            tabList = [z + sep if g.os_path_isdir(z) else z for z in aList]
        else:
            # An existing file.
            tabList = [path]
    else:
        if trace: g.trace('does not exist', path)
        if path and path.endswith(sep):
            path = path[: -1]
        aList = g.glob_glob(path + '*')
        tabList = [z + sep if g.os_path_isdir(z) else z for z in aList]
    if fnc.filterExt:
        for ext in fnc.filterExt:
            tabList = [z for z in tabList if not z.endswith(ext)]
    junk, common_prefix = g.itemsMatchingPrefixInList(path, tabList)
    if trace: g.trace('common_prefix', common_prefix)
    return common_prefix, tabList
.. @+node:ekr.20160520093506.1: *5* get_files (LinterTable)
def get_files(self, pattern):
    '''Return the list of absolute file names matching the pattern.'''
    aList = sorted([
        fn for fn in g.glob_glob(pattern)
            if g.os_path_isfile(fn) and g.shortFileName(fn) != '__init__.py'])
    return aList
.. @+node:ekr.20120219154958.10483: *5* LM.computeFilesList
def computeFilesList(self, options, fileName):
    '''Return the list of files on the command line.'''
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = g.glob_glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return [g.os_path_normslashes(z) for z in result]
.. @+node:ekr.20140724064952.18037: *5* LM.createImporterData & helper
def createImporterData(self):
    '''Create the data structures describing importer plugins.'''
    trace = False and not g.unitTesting
    trace_exception = False
    # Allow plugins to be defined in ~/.leo/plugins.
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(
            g.app.loadDir, '..', 'plugins', 'importers', '*.py')
        for fn in g.glob_glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    module_name = sfn[: -3]
                    # Important: use importlib to give imported modules
                    # their fully qualified names.
                    m = importlib.import_module(
                        'leo.plugins.importers.%s' % module_name)
                    self.parse_importer_dict(sfn, m)
                except Exception:
                    if trace and trace_exception:
                        g.es_exception()
                    g.warning('can not import leo.plugins.importers.%s' % (
                        module_name))
    if trace:
        g.trace('g.app.atAutoDict')
        g.printDict(g.app.atAutoDict)
        g.trace('g.app.classDispatchDict')
        g.printDict(g.app.classDispatchDict)
.. @+node:ekr.20140723140445.18076: *6* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    '''
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    '''
    trace = False and not g.unitTesting
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if trace:
            g.trace('%20s: %20s %s' % (sfn, scanner_name, ', '.join(extensions)))
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
                if trace: g.trace(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning('leo/plugins/importers/%s has no importer_dict' % sfn)
.. @+node:ekr.20140728040812.17990: *5* LM.createWritersData & helper
def createWritersData(self):
    '''Create the data structures describing writer plugins.'''
    trace = False # and not g.unitTesting
    trace = trace and 'createWritersData' not in g.app.debug_dict
    if trace:
        # Suppress multiple traces.
        g.app.debug_dict['createWritersData'] = True
    g.app.writersDispatchDict = {}
    g.app.atAutoWritersDict = {}
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(g.app.loadDir,
            '..', 'plugins', 'writers', '*.py')
        for fn in g.glob_glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    # Important: use importlib to give imported modules their fully qualified names.
                    m = importlib.import_module('leo.plugins.writers.%s' % sfn[: -3])
                    self.parse_writer_dict(sfn, m)
                except Exception:
                    g.es_exception()
                    g.warning('can not import leo.plugins.writers.%s' % sfn)
    if trace:
        g.trace('LM.writersDispatchDict')
        g.printDict(g.app.writersDispatchDict)
        g.trace('LM.atAutoWritersDict')
        g.printDict(g.app.atAutoWritersDict)
    # Creates problems: https://github.com/leo-editor/leo-editor/issues/40

.. @+node:ekr.20140728040812.17991: *6* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    '''
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    '''
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class %s in %s:' % (
                        sfn, s, aClass.__name__, m.__file__))
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace('%s: duplicate %s class' % (sfn, ext),
                        aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning('leo/plugins/writers/%s has no writer_dict' % sfn)
.. @+node:ekr.20140525065558.15806: *5* modules (RopeController)
def modules(self):
    '''Return full path names of all Leo modules.'''
    aList = g.glob_glob(g.os_path_join(g.app.loadDir, '*.py'))
    return sorted(aList)
.. @+node:ekr.20160518074545.8: *5* plugins (LinterTable)
def plugins(self):
    '''Return a list of all important plugins.'''
    aList = []
    for theDir in ('', 'importers', 'writers'):
        pattern = g.os_path_finalize_join(self.loadDir, 'plugins', theDir, '*.py')
        aList.extend(self.get_files(pattern))
        # Don't use get_files here.
        # for fn in g.glob_glob(pattern):
            # sfn = g.shortFileName(fn)
            # if sfn != '__init__.py':
                # sfn = os.sep.join([theDir, sfn]) if theDir else sfn
                # aList.append(sfn)
    remove = [
        # 2016/05/20: *do* include gui-related plugins.
        # This allows the -a option not to doubly-include gui-related plugins.
            # 'free_layout.py', # Gui-related.
            # 'nested_splitter.py', # Gui-related.
        'gtkDialogs.py', # Many errors, not important.
        'leofts.py', # Not (yet) in leoPlugins.leo.
        'qtGui.py', # Dummy file
        'qt_main.py', # Created automatically.
        'rst3.py', # Obsolete
    ]
    remove = [g.os_path_finalize_join(self.loadDir, 'plugins', fn) for fn in remove]
    aList = sorted([z for z in aList if z not in remove])
    # Remove all gui related items.
    # for z in sorted(aList):
        # if z.startswith('qt_'):
            # aList.remove(z)
    # g.trace('\n'.join(aList))
    return sorted(set(aList))
.. @+node:ekr.20150525123715.2: *5* pu.files_in_dir
def files_in_dir(self, theDir, recursive=True, extList=None, excludeDirs=None):
    '''
    Return a list of all Python files in the directory.
    Include all descendants if recursiveFlag is True.
    Include all file types if extList is None.
    '''
    # import glob
    import os
    # if extList is None: extList = ['.py']
    if excludeDirs is None: excludeDirs = []
    result = []
    if recursive:
        for root, dirs, files in os.walk(theDir):
            for z in files:
                fn = g.os_path_finalize_join(root, z)
                junk, ext = g.os_path_splitext(fn)
                if not extList or ext in extList:
                    result.append(fn)
            if excludeDirs and dirs:
                for z in dirs:
                    if z in excludeDirs:
                        dirs.remove(z)
    else:
        for ext in extList:
            result.extend(g.glob_glob('%s.*%s' % (theDir, ext)))
    return sorted(list(set(result)))
.. @+node:ekr.20171213071416.1: *5* pu.leo_core_files
def leo_core_files(self):
    '''Return all the files in Leo's core.'''
    trace = False
    loadDir = g.app.loadDir
    # Compute directories.
    commands_dir = g.os_path_finalize_join(loadDir, '..', 'commands')
    plugins_dir = g.os_path_finalize_join(loadDir, '..', 'plugins')
    # Compute files.
    core_files = g.glob_glob('%s%s%s' % (loadDir, os.sep, '*.py'))
    for exclude in ['format-code.py',]:
        core_files = [z for z in core_files if not z.endswith(exclude)]
    command_files = g.glob_glob('%s%s%s' % (commands_dir, os.sep, '*.py'))
    plugins_files = g.glob_glob('%s%s%s' % (plugins_dir, os.sep, 'qt_*.py'))
    # Compute the result.
    files = core_files + command_files + plugins_files
    files = [z for z in files if not z.endswith('__init__.py')]
    if trace: g.printList(files)
    return files
.. @+node:ekr.20051104075904.91: *5* TM.getAllPluginFilenames
def getAllPluginFilenames(self):
    path = g.os_path_join(g.app.loadDir, "..", "plugins")
    files = g.glob_glob(g.os_path_join(path, "*.py"))
    files = [g.os_path_finalize(f) for f in files]
    files.sort()
    return files
.. @+node:ekr.20051104075904.102: *5* TM.importAllModulesInPath
def importAllModulesInPath(self, path, exclude=None):
    tm = self
    if exclude is None: exclude = []
    path = g.os_path_finalize(path)
    if not g.os_path_exists(path):
        g.es("path does not exist:", path)
        return []
    path2 = g.os_path_join(path, "leo*.py")
    files = g.glob_glob(path2)
    files2 = []
    for theFile in files:
        for z in exclude:
            if theFile.endswith(z):
                break
        else:
            files2.append(theFile)
    modules = []
    for theFile in files2:
        module = tm.safeImportModule(theFile)
        if module:
            modules.append(module)
    # g.trace(modules)
    return modules
.. @+node:ekr.20180314175459.1: ** #783: print- commands fail under pythonw
@language rest
@wrap

Settings/Print Binding Command Fails When Leo Runs Under pythonw
https://github.com/leo-editor/leo-editor/issues/783

When running under pythonw, Print Bindings, Print Commands, and Print Settings fail with

 IOError: [Errno 9] Bad file descriptor

Under running under python, these commands work as expected. This occurs both from the Settings menu and when using the commands. However, Print Plugin-info works correctly.

It would seem that the code handles stdout wrongly.

@language python
.. @+node:ekr.20180314180145.1: *3* Script: launch leow
import os
os.system("leow")
.. @+node:ekr.20100908125007.6027: *3* plugins.printPluginsInfo
def printPluginsInfo(self, c):
    '''Print the file name responsible for loading a plugin.

    This is the first .leo file containing an @enabled-plugins node
    that enables the plugin.'''
    d = self.loadedModulesFilesDict
    tabName = 'Plugins'
    c.frame.log.selectTab(tabName)
    data = []; n = 4
    for moduleName in d:
        fileName = d.get(moduleName)
        n = max(n, len(moduleName))
        data.append((moduleName, fileName),)
    lines = ['%*s %s\n' % (-n, s1, s2) for(s1, s2) in data]
    g.es('', ''.join(lines), tabName=tabName)
.. @+node:ekr.20061031131434.119: *3* k.printBindings & helper
@cmd('print-bindings')
def printBindings(self, event=None):
    '''Print all the bindings presently in effect.'''
    k = self; c = k.c
    d = k.bindingsDict; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[ ] leoSettings.leo
[D] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] @mode, @button, @command

'''
    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend, c.tab_width)
    data = []
    for stroke in sorted(d):
        assert g.isStroke(stroke), stroke
        aList = d.get(stroke, [])
        for si in aList:
            assert g.isShortcutInfo(si), si
            s1 = '' if si.pane == 'all' else si.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = si.commandName
            s4 = si.kind or '<no hash>'
            data.append((s1, s2, s3, s4),)
    # Print keys by type:
    result = []
    result.append('\n' + legend)
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Ctrl', 'Alt+Shift', 'Alt', # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift', 'Ctrl+Meta', 'Ctrl+Shift', 'Ctrl', # Ctrl+Key: done by Ctrl.
        'Meta+Key', 'Meta+Shift', 'Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1, s2, s3, s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append('***** %s...\n' % prefix)
        self.printBindingsHelper(result, data2, prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result, data, prefix=None)
    if not g.unitTesting:
        g.es_print('', ''.join(result), tabName=tabName)
    k.showStateAndMode()
    return result # for unit test.
.. @+node:ekr.20061031131434.120: *4* printBindingsHelper
def printBindingsHelper(self, result, data, prefix):
    lm = g.app.loadManager
    data.sort(key=lambda x: x[1])
    data2, n = [], 0
    for pane, key, commandName, kind in data:
        key = key.replace('+Key', '')
        # g.trace('%10s %s' % (key, repr(kind)))
        letter = lm.computeBindingLetter(kind)
        pane = '%s: ' % (pane) if pane else ''
        left = pane + key # pane and shortcut fields
        n = max(n, len(left))
        data2.append((letter, left, commandName),)
    for z in data2:
        letter, left, commandName = z
        result.append('%s %*s %s\n' % (letter, -n, left, commandName))
    if data:
        result.append('\n')
.. @+node:ekr.20080710101653.1: *3* g.pr
# see: http://www.diveintopython.org/xml_processing/unicode.html

def pr(*args, **keys):
    '''
    Print all non-keyword args. This is a wrapper for the print statement.

    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''
    # Compute the effective args.
    d = {'commas': False, 'newline': True, 'spaces': True}
    d = doKeywordArgs(keys, d)
    newline = d.get('newline')
    stdout = sys.stdout if sys.stdout and g.unitTesting else sys.__stdout__
        # Unit tests require sys.stdout.
    if not stdout:
        # Fix #541.
        return
    if sys.platform.lower().startswith('win'):
        encoding = 'ascii' # 2011/11/9.
    elif getattr(stdout, 'encoding', None):
        # sys.stdout is a TextIOWrapper with a particular encoding.
        encoding = stdout.encoding
    else:
        encoding = 'utf-8'
    s = translateArgs(args, d)
        # Translates everything to unicode.
    func = g.toUnicode if g.isPython3 else g.toEncodedString
    s = func(s, encoding=encoding, reportErrors=False)
    if newline:
        s += g.u('\n') if g.isPython3 else '\n'
    # Python's print statement *can* handle unicode, but
    # sitecustomize.py must have sys.setdefaultencoding('utf-8')
    try:
        # 783: print-* commands fail under pythonw.
        # https://github.com/leo-editor/leo-editor/issues/783.
        stdout.write(s)
    except Exception:
        pass
.. @+node:ekr.20180318033946.1: ** #822: Put outline tabs below the main window bar
Put outline tabs below the main window bar.
https://github.com/leo-editor/leo-editor/issues/822

.. @+node:ekr.20110605121601.18137: *3* class  DynamicWindow (QtWidgets.QMainWindow)
class DynamicWindow(QtWidgets.QMainWindow):
    '''
    A class representing all parts of the main Qt window.

    **Important**: when using tabs, the LeoTabbedTopLevel widget
    is the top-level window, **not** this QMainWindow!

    c.frame.top is a DynamicWindow object.

    For --gui==qttabs:
        c.frame.top.parent is a TabbedFrameFactory
        c.frame.top.leo_master is a LeoTabbedTopLevel

    All leoQtX classes use the ivars of this Window class to
    support operations requested by Leo's core.
    '''
    @others
.. @+node:ekr.20110605121601.18138: *4*  ctor (DynamicWindow)
def __init__(self, c, parent=None):
    '''Ctor for the DynamicWindow class.  The main window is c.frame.top'''
        # Called from LeoQtFrame.finishCreate.
        # For qttabs gui, parent is a LeoTabbedTopLevel.
    # g.trace('(DynamicWindow)',g.callers())
    QtWidgets.QMainWindow.__init__(self, parent)
    self.leo_c = c
    self.leo_master = None # Set in construct.
    self.leo_menubar = None # Set in createMenuBar.
    self.leo_ui = None # Set in construct.
    c._style_deltas = defaultdict(lambda: 0) # for adjusting styles dynamically
    # g.trace('(DynamicWindow)',g.listToString(dir(self),sort=True))
.. @+node:ekr.20110605121601.18172: *4* do_leo_spell_btn_*
def doSpellBtn(self, btn):
    getattr(self.leo_c.spellCommands.handler.tab, btn)()

def do_leo_spell_btn_Add(self):
    self.doSpellBtn('onAddButton')

def do_leo_spell_btn_Change(self):
    self.doSpellBtn('onChangeButton')

def do_leo_spell_btn_Find(self):
    self.doSpellBtn('onFindButton')

def do_leo_spell_btn_FindChange(self):
    self.doSpellBtn('onChangeThenFindButton')

def do_leo_spell_btn_Hide(self):
    self.doSpellBtn('onHideButton')

def do_leo_spell_btn_Ignore(self):
    self.doSpellBtn('onIgnoreButton')
.. @+node:ekr.20110605121601.18139: *4* dw.construct & helpers
def construct(self, master=None):
    """ Factor 'heavy duty' code out from the DynamicWindow ctor """
    # g.trace('(DynamicWindow)')
    c = self.leo_c
    self.leo_master = master
        # A LeoTabbedTopLevel for tabbed windows.
        # None for non-tabbed windows.
    # Init the base class.
    ui_file_name = c.config.getString('qt_ui_file_name')
    self.useScintilla = c.config.getBool('qt-use-scintilla')
    if not ui_file_name:
        ui_file_name = 'qt_main.ui'
    ui_description_file = g.app.loadDir + "/../plugins/" + ui_file_name
    # g.pr('DynamicWindw.__init__,ui_description_file)
    assert g.os_path_exists(ui_description_file)
    self.reloadSettings()
    main_splitter, secondary_splitter = self.createMainWindow()
    self.iconBar = self.addToolBar("IconBar")
    self.set_icon_bar_orientation(c)
    # #266 A setting to hide the icon bar.
    # Calling reloadSettings again would also work.
    if not self.show_iconbar:
        self.iconBar.hide()
    self.leo_menubar = self.menuBar()
    self.statusBar = QtWidgets.QStatusBar()
    self.setStatusBar(self.statusBar)
    orientation = c.config.getString('initial_split_orientation')
    self.setSplitDirection(main_splitter, secondary_splitter, orientation)
    if hasattr(c, 'styleSheetManager'):
        c.styleSheetManager.set_style_sheets(top=self, all=True)

def reloadSettings(self):
    c = self.leo_c
    c.registerReloadSettings(self)
    self.bigTree = c.config.getBool('big_outline_pane')
    self.show_iconbar = c.config.getBool('show_iconbar', default=True)
    if getattr(self, 'iconBar', None):
        if self.show_iconbar:
            self.iconBar.show()
        else:
            self.iconBar.hide()
.. @+node:ekr.20140915062551.19519: *5* dw.set_icon_bar_orientation
def set_icon_bar_orientation(self, c):
    '''Set the orientation of the icon bar based on settings.'''
    d = {
        'bottom': QtCore.Qt.BottomToolBarArea,
        'left': QtCore.Qt.LeftToolBarArea,
        'right': QtCore.Qt.RightToolBarArea,
        'top': QtCore.Qt.TopToolBarArea,
    }
    where = c.config.getString('qt-toolbar-location')
    if where:
        where = d.get(where)
        if where: self.addToolBar(where, self.iconBar)
.. @+node:ekr.20110605121601.18141: *4* dw.createMainWindow & helpers
def createMainWindow(self):
    '''
    Create the component ivars of the main window.
    Copied/adapted from qt_main.py.
    Called instead of uic.loadUi(ui_description_file, self)
    '''
    dw = self
    self.leo_ui = self
    self.setMainWindowOptions()
    self.createCentralWidget()
    main_splitter, secondary_splitter = self.createMainLayout(self.centralwidget)
        # Creates .verticalLayout
    if self.bigTree:
        self.createBodyPane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        treeFrame = self.createOutlinePane(main_splitter)
        main_splitter.addWidget(treeFrame)
        main_splitter.addWidget(secondary_splitter)
    else:
        self.createOutlinePane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        self.createBodyPane(main_splitter)
    self.createMiniBuffer(self.centralwidget)
    self.createMenuBar()
    self.createStatusBar(dw)
    # Signals
    QtCore.QMetaObject.connectSlotsByName(dw)
    return main_splitter, secondary_splitter
.. @+node:ekr.20110605121601.18142: *5* dw.top-level
.. @+node:ekr.20110605121601.18143: *6* dw.createBodyPane
def createBodyPane(self, parent):
    '''Create the body pane.'''
    # Create widgets.
    c = self.leo_c
    bodyFrame = self.createFrame(parent, 'bodyFrame')
    innerFrame = self.createFrame(bodyFrame, 'innerBodyFrame',
        hPolicy=QtWidgets.QSizePolicy.Expanding)
    sw = self.createStackedWidget(innerFrame, 'bodyStackedWidget')
    page2 = QtWidgets.QWidget()
    self.setName(page2, 'bodyPage2')
    body = self.createText(page2, 'richTextEdit') # A LeoQTextBrowser
    # Pack.
    vLayout = self.createVLayout(page2, 'bodyVLayout', spacing=6)
    grid = self.createGrid(bodyFrame, 'bodyGrid')
    innerGrid = self.createGrid(innerFrame, 'bodyInnerGrid')
    if c.config.getBool('use-gutter', default=False):
        lineWidget = qt_text.LeoLineTextWidget(c, body)
        vLayout.addWidget(lineWidget)
    else:
        vLayout.addWidget(body)
    sw.addWidget(page2)
    innerGrid.addWidget(sw, 0, 0, 1, 1)
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    self.verticalLayout.addWidget(parent)
    # Official ivars
    self.text_page = page2
    self.stackedWidget = sw # used by LeoQtBody
    self.richTextEdit = body
    self.leo_body_frame = bodyFrame
    self.leo_body_inner_frame = innerFrame
.. @+node:ekr.20110605121601.18144: *6* dw.createCentralWidget
def createCentralWidget(self):
    '''Create the central widget.'''
    dw = self
    w = QtWidgets.QWidget(dw)
    w.setObjectName("centralwidget")
    dw.setCentralWidget(w)
    # Official ivars.
    self.centralwidget = w
.. @+node:ekr.20110605121601.18145: *6* dw.createLogPane & helpers
def createLogPane(self, parent):
    '''Create all parts of Leo's log pane.'''
    # Create widgets.
    c = self.leo_c
    logFrame = self.createFrame(parent, 'logFrame',
        vPolicy=QtWidgets.QSizePolicy.Minimum)
    innerFrame = self.createFrame(logFrame, 'logInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred,
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    tabWidget = self.createTabWidget(innerFrame, 'logTabWidget')
    # Pack.
    innerGrid = self.createGrid(innerFrame, 'logInnerGrid')
    innerGrid.addWidget(tabWidget, 0, 0, 1, 1)
    outerGrid = self.createGrid(logFrame, 'logGrid')
    outerGrid.addWidget(innerFrame, 0, 0, 1, 1)
    # Embed the Find tab in a QScrollArea.
    findScrollArea = QtWidgets.QScrollArea()
    findScrollArea.setObjectName('findScrollArea')
    # Find tab.
    findTab = QtWidgets.QWidget()
    findTab.setObjectName('findTab')
    # Fix #516:
    use_minibuffer = c.config.getBool('minibuffer-find-mode', default=False)
    use_dialog = c.config.getBool('use_find_dialog', default=False)
    if not use_minibuffer and not use_dialog:
        tabWidget.addTab(findScrollArea, 'Find')
    # Do this later, in LeoFind.finishCreate
    self.findScrollArea = findScrollArea
    self.findTab = findTab
    # Spell tab.
    spellTab = QtWidgets.QWidget()
    spellTab.setObjectName('spellTab')
    tabWidget.addTab(spellTab, 'Spell')
    self.createSpellTab(spellTab)
    tabWidget.setCurrentIndex(1)
    # Official ivars
    self.tabWidget = tabWidget # Used by LeoQtLog.
.. @+node:ekr.20131118172620.16858: *7* dw.finishCreateLogPane
def finishCreateLogPane(self):
    '''It's useful to create this late, because c.config is now valid.'''
    # self.findTab exists even if there is not Find tab in the Log pane.
    assert self.findTab
    self.createFindTab(self.findTab, self.findScrollArea)
    self.findScrollArea.setWidget(self.findTab)
.. @+node:ekr.20110605121601.18146: *6* dw.createMainLayout
def createMainLayout(self, parent):
    '''Create the layout for Leo's main window.'''
    # c = self.leo_c
    vLayout = self.createVLayout(parent, 'mainVLayout', margin=3)
    main_splitter = splitter_class(parent)
    main_splitter.setOrientation(QtCore.Qt.Vertical)
    secondary_splitter = splitter_class(main_splitter)
    secondary_splitter.setOrientation(QtCore.Qt.Horizontal)
    # Official ivar:
    self.verticalLayout = vLayout
    self.setSizePolicy(secondary_splitter)
    self.verticalLayout.addWidget(main_splitter)
    return main_splitter, secondary_splitter
.. @+node:ekr.20110605121601.18147: *6* dw.createMenuBar
def createMenuBar(self):
    '''Create Leo's menu bar.'''
    dw = self
    w = QtWidgets.QMenuBar(dw)
    w.setNativeMenuBar(False)
    w.setGeometry(QtCore.QRect(0, 0, 957, 22))
    w.setObjectName("menubar")
    dw.setMenuBar(w)
    # Official ivars.
    self.leo_menubar = w
.. @+node:ekr.20110605121601.18148: *6* dw.createMiniBuffer
def createMiniBuffer(self, parent):
    '''Create the widgets for Leo's minibuffer area.'''
    # Create widgets.
    frame = self.createFrame(self.centralwidget, 'minibufferFrame',
        hPolicy=QtWidgets.QSizePolicy.MinimumExpanding,
        vPolicy=QtWidgets.QSizePolicy.Fixed)
    frame.setMinimumSize(QtCore.QSize(100, 0))
    label = self.createLabel(frame, 'minibufferLabel', 'Minibuffer:')

    class VisLineEdit(QtWidgets.QLineEdit):
        """In case user has hidden minibuffer with gui-minibuffer-hide"""

        def focusInEvent(self, event):
            self.parent().show()
            QtWidgets.QLineEdit.focusInEvent(self, event)
                # EKR: 2014/06/28: Call the base class method.
        def restore_selection(self):
            w = self
            i, j, ins = self._sel_and_insert
            if i == j:
                w.setCursorPosition(i)
            else:
                length = j - i
                # Set selection is a QLineEditMethod
                if ins < j:
                    w.setSelection(j, -length)
                else:
                    w.setSelection(i, length)

        def focusOutEvent(self, event):
            self.store_selection()
            QtWidgets.QLineEdit.focusOutEvent(self, event)
        def store_selection(self):
            w = self
            ins = w.cursorPosition()
            if w.hasSelectedText():
                i = w.selectionStart()
                s = w.selectedText()
                s = g.u(s)
                j = i + len(s)
            else:
                i = j = ins
            w._sel_and_insert = (i, j, ins)

    lineEdit = VisLineEdit(frame)
    lineEdit._sel_and_insert = (0, 0, 0)
    lineEdit.setObjectName('lineEdit') # name important.
    # Pack.
    hLayout = self.createHLayout(frame, 'minibufferHLayout', spacing=4)
    hLayout.setContentsMargins(3, 2, 2, 0)
    hLayout.addWidget(label)
    hLayout.addWidget(lineEdit)
    self.verticalLayout.addWidget(frame)
    label.setBuddy(lineEdit)
    # Official ivars.
    self.lineEdit = lineEdit
    # self.leo_minibuffer_frame = frame
    # self.leo_minibuffer_layout = layout
.. @+node:ekr.20110605121601.18149: *6* dw.createOutlinePane
def createOutlinePane(self, parent):
    '''Create the widgets and ivars for Leo's outline.'''
    # Create widgets.
    treeFrame = self.createFrame(parent, 'outlineFrame',
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    innerFrame = self.createFrame(treeFrame, 'outlineInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred)
    treeWidget = self.createTreeWidget(innerFrame, 'treeWidget')
    grid = self.createGrid(treeFrame, 'outlineGrid')
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    innerGrid = self.createGrid(innerFrame, 'outlineInnerGrid')
    innerGrid.addWidget(treeWidget, 0, 0, 1, 1)
    # Official ivars...
    self.treeWidget = treeWidget
    return treeFrame
.. @+node:ekr.20110605121601.18150: *6* dw.createStatusBar
def createStatusBar(self, parent):
    '''Create the widgets and ivars for Leo's status area.'''
    w = QtWidgets.QStatusBar(parent)
    w.setObjectName("statusbar")
    parent.setStatusBar(w)
    # Official ivars.
    self.statusBar = w
.. @+node:ekr.20110605121601.18151: *6* dw.setMainWindowOptions
def setMainWindowOptions(self):
    '''Set default options for Leo's main window.'''
    dw = self
    dw.setObjectName("MainWindow")
    dw.resize(691, 635)
    dw.setDockNestingEnabled(False)
    dw.setDockOptions(
        QtWidgets.QMainWindow.AllowTabbedDocks |
        QtWidgets.QMainWindow.AnimatedDocks)
.. @+node:ekr.20110605121601.18152: *5* dw.widgets
.. @+node:ekr.20110605121601.18153: *6* dw.createButton
def createButton(self, parent, name, label):
    w = QtWidgets.QPushButton(parent)
    w.setObjectName(name)
    w.setText(self.tr(label))
    return w
.. @+node:ekr.20110605121601.18154: *6* dw.createCheckBox
def createCheckBox(self, parent, name, label):
    w = QtWidgets.QCheckBox(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
.. @+node:ekr.20110605121601.18155: *6* dw.createFrame
def createFrame(self, parent, name,
    hPolicy=None, vPolicy=None,
    lineWidth=1,
    shadow=QtWidgets.QFrame.Plain,
    shape=QtWidgets.QFrame.NoFrame,
):
    '''Create a Qt Frame.'''
    w = QtWidgets.QFrame(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setFrameShape(shape)
    w.setFrameShadow(shadow)
    w.setLineWidth(lineWidth)
    self.setName(w, name)
    return w
.. @+node:ekr.20110605121601.18156: *6* dw.createGrid
def createGrid(self, parent, name, margin=0, spacing=0):
    w = QtWidgets.QGridLayout(parent)
    w.setContentsMargins(QtCore.QMargins(margin, margin, margin, margin))
        # 2014/08/24: honor margin argument.
    w.setSpacing(spacing)
    self.setName(w, name)
    return w
.. @+node:ekr.20110605121601.18157: *6* dw.createHLayout & createVLayout
def createHLayout(self, parent, name, margin=0, spacing=0):
    hLayout = QtWidgets.QHBoxLayout(parent)
    hLayout.setSpacing(spacing)
    hLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(hLayout, name)
    return hLayout

def createVLayout(self, parent, name, margin=0, spacing=0):
    vLayout = QtWidgets.QVBoxLayout(parent)
    vLayout.setSpacing(spacing)
    vLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(vLayout, name)
    return vLayout
.. @+node:ekr.20110605121601.18158: *6* dw.createLabel
def createLabel(self, parent, name, label):
    w = QtWidgets.QLabel(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
.. @+node:ekr.20110605121601.18159: *6* dw.createLineEdit
def createLineEdit(self, parent, name, disabled=True):
    w = QtWidgets.QLineEdit(parent)
    w.setObjectName(name)
    w.leo_disabled = disabled # Inject the ivar.
    # g.trace(disabled,w,g.callers())
    return w
.. @+node:ekr.20110605121601.18160: *6* dw.createRadioButton
def createRadioButton(self, parent, name, label):
    w = QtWidgets.QRadioButton(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
.. @+node:ekr.20110605121601.18161: *6* dw.createStackedWidget
def createStackedWidget(self, parent, name,
    lineWidth=1,
    hPolicy=None, vPolicy=None,
):
    w = QtWidgets.QStackedWidget(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setAcceptDrops(True)
    w.setLineWidth(1)
    self.setName(w, name)
    return w
.. @+node:ekr.20110605121601.18162: *6* dw.createTabWidget
def createTabWidget(self, parent, name, hPolicy=None, vPolicy=None):
    w = QtWidgets.QTabWidget(parent)
    # tb = w.tabBar()
    # tb.setTabsClosable(True)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    self.setName(w, name)
    return w
.. @+node:ekr.20110605121601.18163: *6* dw.createText
def createText(self, parent, name,
    # hPolicy=None,vPolicy=None,
    lineWidth=0,
    shadow=QtWidgets.QFrame.Plain,
    shape=QtWidgets.QFrame.NoFrame,
):
    # Create a text widget.
    c = self.leo_c
    if name == 'richTextEdit' and self.useScintilla and Qsci:
        # Do this in finishCreate, when c.frame.body exists.
        w = Qsci.QsciScintilla(parent)
        self.scintilla_widget = w
    else:
        w = qt_text.LeoQTextBrowser(parent, c, None)
        # self.setSizePolicy(w,kind1=hPolicy,kind2=vPolicy)
        w.setFrameShape(shape)
        w.setFrameShadow(shadow)
        w.setLineWidth(lineWidth)
        self.setName(w, name)
    return w
.. @+node:ekr.20110605121601.18164: *6* dw.createTreeWidget
def createTreeWidget(self, parent, name):
    c = self.leo_c
    w = LeoQTreeWidget(c, parent)
    self.setSizePolicy(w)
    # 12/01/07: add new config setting.
    multiple_selection = c.config.getBool('qt-tree-multiple-selection', default=True)
    if multiple_selection:
        w.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        w.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
    else:
        w.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        w.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectItems)
    w.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    w.setHeaderHidden(False)
    self.setName(w, name)
    return w
.. @+node:ekr.20110605121601.18165: *5* dw.log tabs
.. @+node:ekr.20110605121601.18167: *6* dw.createSpellTab
def createSpellTab(self, parent):
    # dw = self
    vLayout = self.createVLayout(parent, 'spellVLayout', margin=2)
    spellFrame = self.createFrame(parent, 'spellFrame')
    vLayout2 = self.createVLayout(spellFrame, 'spellVLayout')
    grid = self.createGrid(None, 'spellGrid', spacing=2)
    table = (
        ('Add', 'Add', 2, 1),
        ('Find', 'Find', 2, 0),
        ('Change', 'Change', 3, 0),
        ('FindChange', 'Change,Find', 3, 1),
        ('Ignore', 'Ignore', 4, 0),
        ('Hide', 'Hide', 4, 1),
    )
    for(ivar, label, row, col) in table:
        name = 'spell_%s_button' % label
        button = self.createButton(spellFrame, name, label)
        grid.addWidget(button, row, col)
        func = getattr(self, 'do_leo_spell_btn_%s' % ivar)
        button.clicked.connect(func)
        # This name is significant.
        setattr(self, 'leo_spell_btn_%s' % (ivar), button)
    self.leo_spell_btn_Hide.setCheckable(False)
    spacerItem = QtWidgets.QSpacerItem(20, 40,
        QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    grid.addItem(spacerItem, 5, 0, 1, 1)
    listBox = QtWidgets.QListWidget(spellFrame)
    self.setSizePolicy(listBox,
        kind1=QtWidgets.QSizePolicy.MinimumExpanding,
        kind2=QtWidgets.QSizePolicy.Expanding)
    listBox.setMinimumSize(QtCore.QSize(0, 0))
    listBox.setMaximumSize(QtCore.QSize(150, 150))
    listBox.setObjectName("leo_spell_listBox")
    grid.addWidget(listBox, 1, 0, 1, 2)
    spacerItem1 = QtWidgets.QSpacerItem(40, 20,
        QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    grid.addItem(spacerItem1, 2, 2, 1, 1)
    lab = self.createLabel(spellFrame, 'spellLabel', 'spellLabel')
    grid.addWidget(lab, 0, 0, 1, 2)
    vLayout2.addLayout(grid)
    vLayout.addWidget(spellFrame)
    listBox.itemDoubleClicked.connect(self.do_leo_spell_btn_FindChange)
    # Official ivars.
    self.spellFrame = spellFrame
    self.spellGrid = grid
    self.leo_spell_widget = parent # 2013/09/20: To allow bindings to be set.
    self.leo_spell_listBox = listBox # Must exist
    self.leo_spell_label = lab # Must exist (!!)
.. @+node:ekr.20110605121601.18166: *6* dw.createFindTab & helpers
def createFindTab(self, parent, tab_widget):
    '''Create a Find Tab in the given parent.'''
    # g.trace('***(DynamicWindow)***', parent, tab_widget)
    c, dw = self.leo_c, self
    fc = c.findCommands
    assert not fc.ftm
    fc.ftm = ftm = FindTabManager(c)
    grid = self.create_find_grid(parent)
    row = 0 # The index for the present row.
    row = dw.create_find_header(grid, parent, row)
    row = dw.create_find_findbox(grid, parent, row)
    row = dw.create_find_replacebox(grid, parent, row)
    max_row2 = 1
    max_row2 = dw.create_find_checkboxes(grid, parent, max_row2, row)
    row = dw.create_find_buttons(grid, parent, max_row2, row)
    row = dw.create_help_row(grid, parent, row)
    # Status row
    dw.create_find_status(grid, parent, row)
    row += 1
    dw.override_events()
    # Last row: Widgets that take all additional vertical space.
    w = QtWidgets.QWidget()
    grid.addWidget(w, row, 0)
    grid.addWidget(w, row, 1)
    grid.addWidget(w, row, 2)
    grid.setRowStretch(row, 100)
    # Official ivars (in addition to checkbox ivars).
    self.leo_find_widget = tab_widget # A scrollArea.
    ftm.init_widgets()
.. @+node:ekr.20131118152731.16847: *7* dw.create_find_grid
def create_find_grid(self, parent):
    grid = self.createGrid(parent, 'findGrid', margin=10, spacing=10)
    grid.setColumnStretch(0, 100)
    grid.setColumnStretch(1, 100)
    grid.setColumnStretch(2, 10)
    grid.setColumnMinimumWidth(1, 75)
    grid.setColumnMinimumWidth(2, 175)
    return grid
.. @+node:ekr.20131118152731.16849: *7* dw.create_find_header
def create_find_header(self, grid, parent, row):
    if False:
        dw = self
        lab1 = dw.createLabel(parent, 'findHeading', 'Find/Change Settings...')
        grid.addWidget(lab1, row, 0, 1, 2, QtCore.Qt.AlignLeft)
            # AlignHCenter
        row += 1
    return row
.. @+node:ekr.20131118152731.16848: *7* dw.create_find_findbox
def create_find_findbox(self, grid, parent, row):
    '''Create the Find: label and text area.'''
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_findbox is None
    ftm.find_findbox = w = dw.createLineEdit(parent, 'findPattern', disabled=fc.expert_mode)
    lab2 = self.createLabel(parent, 'findLabel', 'Find:')
    grid.addWidget(lab2, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
.. @+node:ekr.20131118152731.16850: *7* dw.create_find_replacebox
def create_find_replacebox(self, grid, parent, row):
    '''Create the Replace: label and text area.'''
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_replacebox is None
    ftm.find_replacebox = w = dw.createLineEdit(parent, 'findChange', disabled=fc.expert_mode)
    lab3 = dw.createLabel(parent, 'changeLabel', 'Replace:') # Leo 4.11.1.
    grid.addWidget(lab3, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
.. @+node:ekr.20131118152731.16851: *7* dw.create_find_checkboxes
def create_find_checkboxes(self, grid, parent, max_row2, row):
    '''Create check boxes and radio buttons.'''
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm

    def mungeName(kind, label):
        # The returned value is the namve of an ivar.
        kind = 'check_box_' if kind == 'box' else 'radio_button_'
        name = label.replace(' ', '_').replace('&', '').lower()
        return '%s%s' % (kind, name)
    # Rows for check boxes, radio buttons & execution buttons...

    d = {
        'box': dw.createCheckBox,
        'rb': dw.createRadioButton,
    }
    table = (
        # Note: the Ampersands create Alt bindings when the log pane is enable.
        # The QShortcut class is the workaround.
        # First row.
        ('box', 'whole &Word', 0, 0),
        ('rb', '&Entire outline', 0, 1),
        # Second row.
        ('box', '&Ignore case', 1, 0),
        ('rb', '&Suboutline only', 1, 1),
        # Third row.
        ('box', 'wrap &Around', 2, 0),
        ('rb', '&Node only', 2, 1),
        # Fourth row.
        ('box', 'rege&Xp', 3, 0),
        ('box', 'search &Headline', 3, 1),
        # Fifth row.
        ('box', 'mark &Finds', 4, 0),
        ('box', 'search &Body', 4, 1),
        # Sixth row.
        ('box', 'mark &Changes', 5, 0),
        # a,b,c,e,f,h,i,n,rs,w
    )
    for kind, label, row2, col in table:
        max_row2 = max(max_row2, row2)
        name = mungeName(kind, label)
        func = d.get(kind)
        assert func
        # Fix the greedy checkbox bug:
        label = label.replace('&', '')
        w = func(parent, name, label)
        grid.addWidget(w, row + row2, col)
        # The the checkbox ivars in dw and ftm classes.
        assert getattr(ftm, name) is None
        setattr(ftm, name, w)
    return max_row2
.. @+node:ekr.20131118152731.16852: *7* dw.create_find_buttons
def create_find_buttons(self, grid, parent, max_row2, row):
    c, dw = self.leo_c, self
    k = c.k
    ftm = c.findCommands.ftm

    def mungeName(label):
        kind = 'push-button'
        name = label.replace(' ', '').replace('&', '')
        return '%s%s' % (kind, name)
    # Create Buttons in column 2 (Leo 4.11.1.)

    table = (
        (0, 2, 'findButton', 'Find Next', 'find-next'),
        (1, 2, 'findPreviousButton', 'Find Previous', 'find-prev'),
        (2, 2, 'findAllButton', 'Find All', 'find-all'),
        (3, 2, 'changeButton', 'Replace', 'replace'),
        (4, 2, 'changeThenFindButton', 'Replace Then Find', 'replace-then-find'),
        (5, 2, 'changeAllButton', 'Replace All', 'replace-all'),
        # (6,2,'helpForFindCommands','Help','help-for-find-commands'),
    )
    # findTabHandler does not exist yet.
    for row2, col, func_name, label, cmd_name in table:

        def find_tab_button_callback(event, c=c, func_name=func_name):
            # h will exist when the Find Tab is open.
            fc = c.findCommands
            func = getattr(fc, func_name, None)
            if func: func()
            else: g.trace('* does not exist:', func_name)

        name = mungeName(label)
        # Prepend the shortcut if it exists:
        stroke = k.getShortcutForCommandName(cmd_name)
        if stroke:
            label = '%s:  %s' % (label, k.prettyPrintKey(stroke))
        if 1: # Not bad.
            w = dw.createButton(parent, name, label)
            grid.addWidget(w, row + row2, col)
        else:
            # grid.addLayout(layout,row+row2,col)
            # layout = dw.createHLayout(frame,name='button_layout',margin=0,spacing=0)
            # frame.setLayout(layout)
            frame = dw.createFrame(parent, name='button:%s' % label)
            w = dw.createButton(frame, name, label)
            grid.addWidget(frame, row + row2, col)
        # Connect the button with the command.
        w.clicked.connect(find_tab_button_callback)
        # Set the ivar.
        ivar = '%s-%s' % (cmd_name, 'button')
        ivar = ivar.replace('-', '_')
        assert getattr(ftm, ivar) is None
        setattr(ftm, ivar, w)
    row += max_row2
    row += 2
    return row
.. @+node:ekr.20131118152731.16853: *7* dw.create_help_row
def create_help_row(self, grid, parent, row):
    # Help row.
    if False:
        w = self.createLabel(parent,
            'findHelp', 'For help: <alt-x>help-for-find-commands<return>')
        grid.addWidget(w, row, 0, 1, 3)
        row += 1
    return row
.. @+node:ekr.20150618072619.1: *7* dw.create_find_status
def create_find_status(self, grid, parent, row):
    '''Create the status line.'''
    dw = self
    status_label = dw.createLabel(parent, 'status-label', 'Status')
    status_line = dw.createLineEdit(parent, 'find-status', disabled=True)
    grid.addWidget(status_label, row, 0)
    grid.addWidget(status_line, row, 1, 1, 2)
    # Official ivars.
    dw.find_status_label = status_label
    dw.find_status_edit = status_line
.. @+node:ekr.20131118172620.16891: *7* dw.override_events
def override_events(self):
    # dw = self
    c = self.leo_c
    fc = c.findCommands
    ftm = fc.ftm
    # Define class EventWrapper.
    @others
    EventWrapper(c, w=ftm.find_findbox, next_w=ftm.find_replacebox, func=fc.findNextCommand)
    EventWrapper(c, w=ftm.find_replacebox, next_w=ftm.find_next_button, func=fc.findNextCommand)
    table = (
        ('findNextCommand', 'find-next'),
        ('findPrevCommand', 'find-prev'),
        ('findAll', 'find-all'),
        ('changeCommand', 'replace'),
        ('changeThenFind', 'replace-then-find'),
        ('changeAll', 'replace-all'),
    )
    for func_name, cmd_name in table:
        ivar = '%s-%s' % (cmd_name, 'button')
        ivar = ivar.replace('-', '_')
        w = getattr(ftm, ivar, None)
        func = getattr(fc, func_name, None)
        if w and func:
            # g.trace(cmd_name, ivar, bool(w), func and func.__name__)
            next_w = ftm.check_box_whole_word if cmd_name == 'replace-all' else None
            EventWrapper(c, w=w, next_w=next_w, func=func)
        else:
            g.trace('**oops**')
    # Finally, checkBoxMarkChanges goes back to ftm.find_findBox.
    EventWrapper(c, w=ftm.check_box_mark_changes, next_w=ftm.find_findbox, func=None)
.. @+node:ekr.20131118172620.16892: *8* class EventWrapper
class EventWrapper(object):
    @others
.. @+node:ekr.20131119204029.18406: *9* ctor
def __init__(self, c, w, next_w, func):
    self.c = c
    self.d = self.create_d() # Keys: strokes; values: command-names.
    self.w = w
    self.next_w = next_w
    self.eventFilter = qt_events.LeoQtEventFilter(c, w, 'EventWrapper')
    self.func = func
    self.oldEvent = w.event
    w.event = self.wrapper
.. @+node:ekr.20131120054058.16281: *9* create_d
def create_d(self):
    '''Create self.d dictionary.'''
    c = self.c
    d = {}
    table = (
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
        # New in Leo 5.2: Support these in the Find Dialog.
        'find-all',
        'find-next',
        'find-prev',
        'hide-find-tab',
        'replace',
        'replace-all',
        'replace-then-find',
        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
    )
    for cmd_name in table:
        stroke = c.k.getShortcutForCommandName(cmd_name)
        # if not stroke: g.trace('missing',cmd_name)
        if stroke:
            d[stroke.s] = cmd_name
    return d
.. @+node:ekr.20131118172620.16893: *9* wrapper
def wrapper(self, event):
    trace = False
    e = QtCore.QEvent
    type_ = event.type()
    # Must intercept KeyPress for events that generate FocusOut!
    if type_ == e.KeyPress:
        return self.keyPress(event)
    elif type_ == e.KeyRelease:
        return self.keyRelease(event)
    elif trace and type_ not in (12, 170):
        # (5,10,11,12,110,127,128,129,170):
        # http://qt-project.org/doc/qt-4.8/qevent.html#Type-enum
        g.trace(type_)
    return self.oldEvent(event)
.. @+node:ekr.20131118172620.16894: *9* keyPress
def keyPress(self, event):
    trace = False
    s = g.u(event.text())
    if 0: # This doesn't work.
        eat = isinstance(self.w, (QtWidgets.QCheckBox, QtWidgets.QRadioButton))
        g.trace('eat', eat, w)
        if eat and s in ('\n', '\r'):
            return True
    out = s and s in '\t\r\n'
    # if trace: g.trace(out, repr(s))
    if out:
        # Move focus to next widget.
        if s == '\t':
            if self.next_w:
                if trace: g.trace('tab widget', self.next_w)
                self.next_w.setFocus(QtCore.Qt.TabFocusReason)
            else:
                # Do the normal processing.
                return self.oldEvent(event)
        elif self.func:
            if trace: g.trace('return func', self.func.__name__)
            self.func()
        return True
    else:
        ef = self.eventFilter
        tkKey, ch, ignore = ef.toTkKey(event)
        stroke = ef.toStroke(tkKey, ch) # ch not used.
        cmd_name = self.d.get(stroke)
        if trace: g.trace(cmd_name, s, tkKey, stroke)
        if cmd_name:
            self.c.k.simulateCommand(cmd_name)
            return True
        else:
            # Do the normal processing.
            return self.oldEvent(event)
.. @+node:ekr.20131118172620.16895: *9* keyRelease
def keyRelease(self, event):
    return self.oldEvent(event)
.. @+node:ekr.20110605121601.18168: *5* dw.utils
.. @+node:ekr.20110605121601.18169: *6* dw.setName
def setName(self, widget, name):
    if name:
        # if not name.startswith('leo_'):
            # name = 'leo_' + name
        widget.setObjectName(name)
.. @+node:ekr.20110605121601.18170: *6* dw.setSizePolicy
def setSizePolicy(self, widget, kind1=None, kind2=None):
    if kind1 is None: kind1 = QtWidgets.QSizePolicy.Ignored
    if kind2 is None: kind2 = QtWidgets.QSizePolicy.Ignored
    sizePolicy = QtWidgets.QSizePolicy(kind1, kind2)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(
        widget.sizePolicy().hasHeightForWidth())
    widget.setSizePolicy(sizePolicy)
.. @+node:ekr.20110605121601.18171: *6* dw.tr
def tr(self, s):
    # pylint: disable=no-member
    if isQt5:
        # QApplication.UnicodeUTF8 no longer exists.
        return QtWidgets.QApplication.translate('MainWindow', s, None)
    else:
        return QtWidgets.QApplication.translate(
            'MainWindow',
            s,
            None,
            QtWidgets.QApplication.UnicodeUTF8)
.. @+node:ekr.20110605121601.18179: *4* dw.Event handlers
.. @+node:ekr.20110605121601.18140: *5* dw.closeEvent
def closeEvent(self, event):
    '''Handle a close event in the Leo window.'''
    trace = False and not g.unitTesting
    c = self.leo_c
    if not c.exists:
        # Fixes double-prompt bug on Linux.
        if trace: g.trace('destroyed')
        event.accept()
    elif c.inCommand:
        if trace: g.trace('in command')
        c.requestCloseWindow = True
    else:
        if trace: g.trace('closing')
        ok = g.app.closeLeoWindow(c.frame)
        if ok:
            event.accept()
        else:
            event.ignore()
.. @+node:ekr.20110605121601.18173: *4* dw.select
def select(self, c):
    '''Select the window or tab for c. self is c.frame.top.'''
    if self.leo_master:
        # A LeoTabbedTopLevel.
        self.leo_master.select(c)
    else:
        w = c.frame.body.wrapper
        g.app.gui.set_focus(c, w)
.. @+node:ekr.20110605121601.18178: *4* dw.setGeometry
def setGeometry(self, rect):
    '''Set the window geometry, but only once when using the qttabs gui.'''
    if g.app.qt_use_tabs:
        m = self.leo_master
        assert self.leo_master
        # Only set the geometry once, even for new files.
        if not hasattr(m, 'leo_geom_inited'):
            m.leo_geom_inited = True
            self.leo_master.setGeometry(rect)
            QtWidgets.QMainWindow.setGeometry(self, rect)
    else:
        QtWidgets.QMainWindow.setGeometry(self, rect)
.. @+node:ekr.20110605121601.18177: *4* dw.setLeoWindowIcon
def setLeoWindowIcon(self):
    """ Set icon visible in title bar and task bar """
    self.setWindowIcon(QtGui.QIcon(g.app.leoDir + "/Icons/leoapp32.png"))
.. @+node:ekr.20110605121601.18174: *4* dw.setSplitDirection
def setSplitDirection(self, main_splitter, secondary_splitter, orientation):
    '''Set the orientations of the splitters in the Leo main window.'''
    # c = self.leo_c
    vert = orientation and orientation.lower().startswith('v')
    # g.trace('orientation', orientation, 'vert', vert)
    h, v = QtCore.Qt.Horizontal, QtCore.Qt.Vertical
    orientation1 = v if vert else h
    orientation2 = h if vert else v
    main_splitter.setOrientation(orientation1)
    secondary_splitter.setOrientation(orientation2)
.. @+node:ekr.20130804061744.12425: *4* dw.setWindowTitle
if 0: # Override for debugging only.

    def setWindowTitle(self, s):
        g.trace('***(DynamicWindow)', s, self.parent())
        # Call the base class method.
        QtWidgets.QMainWindow.setWindowTitle(self, s)
.. @+node:ekr.20180307134551.1: ** #766: Create Theme menu, etc.
https://github.com/leo-editor/leo-editor/issues/766
.. @+node:ekr.20041120074536: *3* c.config.settingsRoot
def settingsRoot(self, theme=False):
    '''Return the position of the @settings tree.'''
    c = self.c
    for p in c.all_unique_positions():
        if p.h.rstrip() == "@settings":
            if not theme:
                return p.copy()
            # Look for an inner @theme node
            for p2 in p.subtree():
                if g.match_word(p2.h, 0, '@theme'):
                    return p2.copy()
    return None
.. @+node:ekr.20031218072017.1623: *3* c_file.new
@g.commander_command('new')
def new(self, event=None, gui=None):
    '''Create a new Leo window.'''
    import leo.core.leoApp as leoApp
    lm = g.app.loadManager
    old_c = self
    # Clean out the update queue so it won't interfere with the new window.
    self.outerUpdate()
    # Send all log messages to the new frame.
    g.app.setLog(None)
    g.app.lockLog()
    # Retain all previous settings. Very important for theme code.
    c = g.app.newCommander(
        fileName=None,
        gui=gui,
        previousSettings=leoApp.PreviousSettings(
            settingsDict=lm.globalSettingsDict,
            shortcutsDict=lm.globalShortcutsDict,
        ))    
    frame = c.frame
    g.app.unlockLog()
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio, frame.secondary_ratio)
        # Resize the _new_ frame.
    c.frame.createFirstTreeNode()
    lm.createMenu(c)
    lm.finishOpen(c)
    g.app.writeWaitingLog(c)
    g.doHook("new", old_c=old_c, c=c, new_c=c)
    c.setLog()
    c.setChanged(False) # Fix #387
    c.redraw()
    return c # For unit tests and scripts.
.. @+node:ekr.20180312043352.2: *3* c_file.open_theme_file
@g.commander_command('open-theme-file')
def open_theme_file(self, event):
    '''Open a theme file and apply the theme.'''
    c = event and event.get('c')
    if not c: return
    themes_dir = g.os_path_finalize_join(g.app.loadDir, '..', 'themes')
    fn = g.app.gui.runOpenFileDialog(c,
        title="Open Theme File",
        filetypes=[
             g.fileFilters("LEOFILES"),
            ("All files", "*"),
        ],
        defaultextension=g.defaultLeoFileExtension(c),
        startpath=themes_dir,
    )
    if not fn:
        return
    leo_dir = g.os_path_finalize_join(g.app.loadDir, '..', '..')
    os.chdir(leo_dir)
    command = 'leo "%s"' % fn
    os.system(command)
    # os.system("start cmd /c %s" % command)
        # /c terminates after the command.
        # /k leaves window open.
        # /d specifis starting directory.
    os.chdir(leo_dir)
.. @+node:ekr.20180318133620.1: *3* LM.computeThemeFilePath & helper
def computeThemeFilePath(self):
    '''Return the absolute path to the theme .leo file.'''
    lm = self
    resolve = self.resolve_theme_path
    # Step 1: Use the --theme file if it exists
    path = resolve(lm.options.get('theme_path'), tag='--theme')
    if path: return path
    # Step 2: look for the @string theme-name setting in the first loaded file.
    # This is a hack, but especially useful for test*.leo files in leo/themes.
    if 1:
        path = lm.files and lm.files[0]
        if path and g.os_path_exists(path):
            # Tricky: we must call lm.computeLocalSettings *here*.
            theme_c = lm.openSettingsFile(path)
            settings_d, junk_shortcuts_d = lm.computeLocalSettings(
                c=theme_c,
                settings_d=lm.globalSettingsDict,
                shortcuts_d=lm.globalShortcutsDict,
                localFlag=False,
            )
            setting = settings_d.get_string_setting('theme-name')
            if setting:
                tag = theme_c.shortFileName()
                path = resolve(setting, tag=tag)
                if path: return path
    # Finally, use the setting in myLeoSettings.leo.
    setting = lm.globalSettingsDict.get_string_setting('theme-name')
    tag = 'myLeoSettings.leo'
    return resolve(setting, tag=tag)
.. @+node:ekr.20180321124503.1: *4* LM.resolve_theme_path
def resolve_theme_path(self, fn, tag):
    '''Search theme directories for the given .leo file.'''
    trace = False and not g.unitTesting # and g.trace_themes
    if not fn:
        return None
    if not fn.endswith('.leo'):
        fn += '.leo'
    if trace:
        print('')
        g.trace('%s: %s' % (tag, fn))
    for directory in self.computeThemeDirectories():
        path = g.os_path_join(directory, fn)
            # Normalizes slashes, etc.
        if g.os_path_exists(path):
            if trace: g.trace('%s is  in %s\n' % (fn, directory))
            return path
        elif trace: g.trace('%s not in %s' % (fn, directory))
    print('theme .leo file not found: %s' % fn)
    return None
.. @+node:ekr.20120213081706.10382: *3* LM.readGlobalSettingsFiles
def readGlobalSettingsFiles(self):
    '''Read leoSettings.leo and myLeoSettings.leo using a null gui.'''
    trace = g.trace_themes and not g.unitTesting
    lm = self
    # Open the standard settings files with a nullGui.
    # Important: their commanders do not exist outside this method!
    paths = [lm.computeLeoSettingsPath(), lm.computeMyLeoSettingsPath()]
    old_commanders = g.app.commanders()
    commanders = [lm.openSettingsFile(path) for path in paths]
    commanders = [z for z in commanders if z]
    settings_d, shortcuts_d = lm.createDefaultSettingsDicts()
    for c in commanders:
        # Merge the settings dicts from c's outline into
        # *new copies of* settings_d and shortcuts_d.
        settings_d, shortcuts_d = lm.computeLocalSettings(
            c, settings_d, shortcuts_d, localFlag=False)
    # Adjust the name.
    shortcuts_d.setName('lm.globalShortcutsDict')
    # g.trace('===== settings 1 keys:', len(settings_d.d.keys()))
    lm.globalSettingsDict = settings_d
    lm.globalShortcutsDict = shortcuts_d
    # Add settings from --theme or @string theme-name files.
    # This must be done *after* reading myLeoSettigns.leo.
    theme_path = lm.computeThemeFilePath()
    if theme_path:
        theme_c = lm.openSettingsFile(theme_path)
        if theme_c:
            # Merge theme_c's settings into globalSettingsDict.
            settings_d, junk_shortcuts_d = lm.computeLocalSettings(
                theme_c, settings_d, shortcuts_d, localFlag=False)
            lm.globalSettingsDict = settings_d
            # Set global vars
            g.app.theme_directory = g.os_path_dirname(theme_path)
                # Used by the StyleSheetManager.
            if 0:
                # Not necessary **provided** that theme .leo files
                # set @string theme-name to the name of the .leo file.
                g.app.theme_color = settings_d.get_string_setting('color-theme')
                g.app.theme_name = settings_d.get_string_setting('theme-name')
                if trace:
                    print('')
                    g.trace('=====\n')
                    print(' g.app.theme_path: %s' % g.app.theme_directory)
                    print(' g.app.theme_name: %s' % g.app.theme_name)
                    print('g.app.theme_color: %s' % g.app.theme_color)
                    print('')
    # Clear the cache entries for the commanders.
    # This allows this method to be called outside the startup logic.
    for c in commanders:
        if c not in old_commanders:
            g.app.forgetOpenFile(c.fileName())
.. @+node:ekr.20120219154958.10486: *3* LM.scanOptions & helpers
def scanOptions(self, fileName, pymacs):
    '''Handle all options, remove them from sys.argv and set lm.options.'''
    trace = False
    lm = self
    lm.old_argv = sys.argv[:]
    parser = optparse.OptionParser(
        usage="usage: launchLeo.py [options] file1, file2, ...")
        # Automatically implements the --help option.
    # Parse the options, and remove them from sys.argv.
    self.addOptionsToParser(parser)
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]]
    sys.argv.extend(args)
    if trace:
        print('scanOptions: options...')
        g.printDict({
            key: value for key, value in options.__dict__.items() if value
        })
    # Handle simple args...
    self.doSimpleOptions(options)
    # Compute the lm.files ivar.
    lm.files = lm.computeFilesList(options, fileName)
    # Compute the return values.
    script = None if pymacs else self.doScriptOption(options, parser)
    d = {
        'gui': lm.doGuiOption(options),
        'load_type': lm.doLoadTypeOption(options),
        'screenshot_fn': lm.doScreenShotOption(options),
            # --screen-shot=fn
        'script': script,
        'select': options.select and options.select.strip('"'),
            # --select=headline
        'theme_path': options.theme,
            # --theme=name
        'version': options.version,
            # --version: print the version and exit.
        'windowFlag': script and options.script_window, 
        'windowSize': lm.doWindowSizeOption(options),
    }
    if trace:
        print('scanOptions: returns...')
        g.printObj(d)
    return d
.. @+node:ekr.20180312150559.1: *4* LM.addOptionsToParser
@nobeautify

def addOptionsToParser(self, parser):
    
    add = parser.add_option
    
    def add_bool(option, help, dest=None):
        add(option, action='store_true', dest=dest, help=help)
        
    def add_other(option, help, dest=None, m=None):
        add(option, dest=dest, help=help, metavar=m)

    add_bool('--debug',         'enable debug mode')
    add_bool('--diff',          'use Leo as an external git diff')
    add_bool('--fullscreen',    'start fullscreen')
    add_bool('--ipython',       'enable ipython support')
    add_bool('--fail-fast',     'stop unit tests after the first failure')
    add_other('--gui',          'gui to use (qt/qttabs/console/null)')
    add_bool('--listen-to-log', 'start log_listener.py on startup')
    add_other('--load-type',    '@<file> type for non-outlines', m='TYPE')
    add_bool('--maximized',     'start maximized')
    add_bool('--minimized',     'start minimized')
    add_bool('--no-cache',      'disable reading of cached files')
    add_bool('--no-plugins',    'disable all plugins')
    add_bool('--no-splash',     'disable the splash screen')
    add_other('--screen-shot',  'take a screen shot and then exit', m='PATH')
    add_other('--script',       'execute a script and then exit', m="PATH")
    add_bool('--script-window', 'execute script using default gui')
    add_other('--select',       'headline or gnx of node to select', m='ID')
    add_bool('--session-restore','restore session tabs at startup')
    add_bool('--session-save',  'save session tabs on exit')
    add_bool('--silent',        'disable all log messages')
    add_other('--theme',        'use the named theme file', m='NAME')
    add_bool('--trace-binding', 'trace key bindings')
    add_bool('--trace-focus',   'trace changes of focus')
    add_bool('--trace-plugins', 'trace imports of plugins')
    add_other('--trace-setting', 'trace where named setting is set', m="NAME")
    add_bool('--trace-shutdown', 'trace shutdown logic')
    add_bool('--trace-themes',  'trace theme init logic')
    add_other('--window-size',  'initial window size (height x width)', m='SIZE')
    # Multiple bool values.
    add('-v', '--version', action='store_true',
        help='print version number and exit')
.. @+node:ekr.20120219154958.10483: *4* LM.computeFilesList
def computeFilesList(self, options, fileName):
    '''Return the list of files on the command line.'''
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = g.glob_glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return [g.os_path_normslashes(z) for z in result]
.. @+node:ekr.20180312150805.1: *4* LM.doGuiOption
def doGuiOption(self, options):
    gui = options.gui
    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            g.app.qt_use_tabs = True
        elif gui in ('console', 'curses', 'text', 'qt', 'null'):
                # text: cursesGui.py, curses: cursesGui2.py.
            g.app.qt_use_tabs = False
        else:
            print('scanOptions: unknown gui: %s.  Using qt gui' % gui)
            gui = 'qt'
            g.app.qt_use_tabs = False
    elif sys.platform == 'darwin':
        gui = 'qt'
        g.app.qt_use_tabs = False
    else:
        gui = 'qttabs'
        g.app.qt_use_tabs = True
    assert gui
    g.app.guiArgName = gui
    return gui
.. @+node:ekr.20180312152329.1: *4* LM.doLoadTypeOption
def doLoadTypeOption(self, options):
    
    s = options.load_type
    s = s.lower() if s else 'edit'
    return '@' + s

    
.. @+node:ekr.20180312152609.1: *4* LM.doScreenShotOption
def doScreenShotOption(self, options):

    trace = False
    # --screen-shot=fn
    s = options.screen_shot
    if s:
        s = s.strip('"')
    if trace: print('scanOptions: screen_shot', s)
    return s
.. @+node:ekr.20180312153008.1: *4* LM.doScriptOption
def doScriptOption(self, options, parser):

    trace = False
    # --script
    script = options.script
    if script:
        fn = g.os_path_finalize_join(g.app.loadDir, script)
        script, e = g.readFileIntoString(fn, kind='script:')
        if trace: print('scanOptions: script path',repr(fn))
    else:
        script = None
        if trace: print('scanOptions: no script')
    return script
.. @+node:ekr.20180312151544.1: *4* LM.doSimpleOptions
def doSimpleOptions(self, options):
    '''These args just set g.app ivars.'''
    trace = False
    # --debug
    g.app.debug = options.debug
    # --fail-fast
    g.app.failFast = options.fail_fast
    # --fullscreen
    g.app.start_fullscreen = options.fullscreen
    # --git-diff
    g.app.diff = options.diff
    # --listen-to-log
    g.app.listen_to_log_flag = options.listen_to_log
    # --ipython
    g.app.useIpython = options.ipython
    if trace: print('scanOptions: g.app.useIpython', g.app.useIpython)
    # --maximized
    g.app.start_maximized = options.maximized
    # --minimized
    g.app.start_minimized = options.minimized
    # --no-cache
    if options.no_cache:
        if trace: print('scanOptions: disabling caching')
        g.enableDB = False
    # --no-plugins
    if options.no_plugins:
        if trace: print('scanOptions: disabling plugins')
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = (
        not options.no_splash and
        not options.minimized)
    # --session-restore & --session-save
    g.app.restore_session = bool(options.session_restore)
    g.app.save_session = bool(options.session_save)
    # --silent
    g.app.silentMode = options.silent
    # --trace-binding
    g.app.trace_binding = options.trace_binding
    # --trace-focus
    g.app.trace_focus = options.trace_focus
    # --trace-plugins
    g.app.trace_plugins = options.trace_plugins
    # --trace-setting=setting
    g.app.trace_setting = options.trace_setting
        # g.app.config does not exist yet.
    # --trace-shutdown
    g.app.trace_shutdown = options.trace_shutdown
    # --trace-themes
    g.trace_themes = options.trace_themes

   
.. @+node:ekr.20180312154839.1: *4* LM.doWindowSizeOption
def doWindowSizeOption(self, options):
    
    # --window-size
    trace = False
    windowSize = options.window_size
    if windowSize:
        if trace: print('scanOptions: windowSize', repr(windowSize))
        try:
            h, w = windowSize.split('x')
            windowSize = int(h), int(w)
        except ValueError:
            windowSize = None
            print('scanOptions: bad --window-size:', windowSize)
    return windowSize
.. @+node:ekr.20120205022040.17771: *3* td getters
def get(self, key, default=None):
    self._checkKeyType(key)
    if default is None and self.isList:
        default = []
    return self.d.get(key, default)
    
# New in Leo 5.7.1
def get_setting(self, key):
    key = key.replace('-','').replace('_','')
    gs = self.get(key)
    val = gs and gs.val
    return val
    
# New in Leo 5.7.1
def get_string_setting(self, key):
    val = self.get_setting(key)
    return g.toUnicode(val) if val and g.isString(val) else None

def keys(self):
    return self.d.keys()

def name(self):
    return self._name
.. @+node:ekr.20180319115001.1: ** #808: Loading Images in Themes is Broken
https://github.com/leo-editor/leo-editor/issues/808
.. @+node:ekr.20180319152119.1: *3* << LeoApp: global theme data >>
self.theme_directory = None
    # The directory from which the theme file was loaded, if any.
    # Set only by LM.readGlobalSettingsFiles.
    # Used by the StyleSheetManager class.
    
# Not necessary **provided** that theme .leo files
# set @string theme-name to the name of the .leo file.
if 0:
    self.theme_color = None
    self.theme_name = None
.. @+node:ekr.20140913054442.17860: *3* class StyleSheetManager
class StyleSheetManager(object):
    '''A class to manage (reload) Qt style sheets.'''
    @others
.. @+node:ekr.20180316091829.1: *4*  ssm.Birth
.. @+node:ekr.20140912110338.19371: *5* ssm.__init__
def __init__(self, c, safe=False):
    '''Ctor the ReloadStyle class.'''
    self.c = c
    self.color_db = leoColor.leo_color_database
    self.safe = safe
    self.settings_p = g.findNodeAnywhere(c, '@settings')
    self.mng = StyleClassManager()
    # This warning is inappropriate in some contexts.
        # if not self.settings_p:
            # g.es("No '@settings' node found in outline.  See:")
            # g.es("http://leoeditor.com/tutorial-basics.html#configuring-leo")
.. @+node:ekr.20170222051716.1: *5* ssm.reload_settings
def reload_settings(self, sheet=None):
    '''
    Recompute and apply the stylesheet.
    Called automatically by the reload-settings commands.
    '''
    trace = False and not g.unitTesting
    tag = '(StyleSheetManager)'
    if not sheet:
        sheet = self.get_style_sheet_from_settings()
    if sheet:
        w = self.get_master_widget()
        if trace: g.trace(tag, 'Found', len(sheet))
        w.setStyleSheet(sheet)
    elif trace:
        g.trace(tag, 'Not Found')
    # self.c.redraw()

reloadSettings = reload_settings
.. @+node:ekr.20180316091500.1: *4* ssm.Paths...
.. @+node:ekr.20180316065346.1: *5* ssm.compute_icon_directories
def compute_icon_directories(self):
    '''
    Return a list of *existing* directories that could contain theme-related icons.
    '''
    exists = g.os_path_exists
    home = g.app.homeDir
    join = g.os_path_finalize_join
    leo = join(g.app.loadDir, '..')
    table = [
        join(home, '.leo', 'Icons'),
        # join(home, '.leo'),
        join(leo, 'themes', 'Icons'),
        join(leo, 'themes'),
        join(leo, 'Icons'),
    ]
    table = [z for z in table if exists(z)]
    for directory in self.compute_theme_directories():
        if directory not in table:
            table.append(directory)
        directory2 = join(directory, 'Icons')
        if directory2 not in table:
            table.append(directory2)
    return [g.os_path_normslashes(z) for z in table if g.os_path_exists(z)]
.. @+node:ekr.20180315101238.1: *5* ssm.compute_theme_directories
def compute_theme_directories(self):
    '''
    Return a list of *existing* directories that could contain theme .leo files.
    '''
    lm = g.app.loadManager
    table = lm.computeThemeDirectories()[:]
    directory = g.os_path_normslashes(g.app.theme_directory)
    if directory and directory not in table:
        table.insert(0, directory)
    return table
        # All entries are known to exist and have normalized slashes.
.. @+node:ekr.20170307083738.1: *5* ssm.find_icon_path
def find_icon_path(self, setting):
    '''Return the path to the open/close indicator icon.'''
    trace = False and not g.unitTesting
    c = self.c
    s = c.config.getString(setting)
    if not s:
        return None # Not an error.
    for directory in self.compute_icon_directories():
        if trace: g.trace('directory', directory)
        path = g.os_path_finalize_join(directory, s)
        if g.os_path_exists(path):
            if trace: g.trace('Found %20s %s' % (setting, path))
            return path
    g.es_print('no icon found for:', setting)
    return None
.. @+node:ekr.20180316091920.1: *4* ssm.Settings
.. @+node:ekr.20110605121601.18176: *5* ssm.default_style_sheet
def default_style_sheet(self):
    '''Return a reasonable default style sheet.'''
    # Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords
    g.trace('===== using default style sheet =====')
    return '''\

/* A QWidget: supports only background attributes.*/
QSplitter::handle {
    background-color: #CAE1FF; /* Leo's traditional lightSteelBlue1 */
}
QSplitter {
    border-color: white;
    background-color: white;
    border-width: 3px;
    border-style: solid;
}
QTreeWidget {
    background-color: #ffffec; /* Leo's traditional tree color */
}
QsciScintilla {
    background-color: pink;
}
'''
.. @+node:ekr.20140916170549.19551: *5* ssm.get_data
def get_data(self, setting):
    '''Return the value of the @data node for the setting.'''
    c = self.c
    return c.config.getData(setting, strip_comments=False, strip_data=False) or []
.. @+node:ekr.20140916170549.19552: *5* ssm.get_style_sheet_from_settings
def get_style_sheet_from_settings(self):
    '''
    Scan for themes or @data qt-gui-plugin-style-sheet nodes.
    Return the text of the relevant node.
    '''
    aList1 = self.get_data('qt-gui-plugin-style-sheet')
    aList2 = self.get_data('qt-gui-user-style-sheet')
    if aList2: aList1.extend(aList2)
    sheet = ''.join(aList1)
    sheet = self.expand_css_constants(sheet)
    return sheet
.. @+node:ekr.20140915194122.19476: *5* ssm.print_style_sheet
def print_style_sheet(self):
    '''Show the top-level style sheet.'''
    w = self.get_master_widget()
    sheet = w.styleSheet()
    print('style sheet for: %s...\n\n%s' % (w, sheet))
.. @+node:ekr.20110605121601.18175: *5* ssm.set_style_sheets
def set_style_sheets(self, all=True, top=None, w=None):
    '''Set the master style sheet for all widgets using config settings.'''
    trace = False and not g.unitTesting
    if g.app.loadedThemes:
        if trace: g.trace('===== Return')
        return
    c = self.c
    if top is None: top = c.frame.top
    selectors = ['qt-gui-plugin-style-sheet']
    if all:
        selectors.append('qt-gui-user-style-sheet')
    sheets = []
    for name in selectors:
        sheet = c.config.getData(name, strip_comments=False)
            # don't strip `#selector_name { ...` type syntax
        if sheet:
            if '\n' in sheet[0]:
                sheet = ''.join(sheet)
            else:
                sheet = '\n'.join(sheet)
        if sheet and sheet.strip():
            line0 = '\n/* ===== From %s ===== */\n\n' % (name)
            sheet = line0 + sheet
            sheets.append(sheet)
    if sheets:
        sheet = "\n".join(sheets)
        # store *before* expanding, so later expansions get new zoom
        c.active_stylesheet = sheet
        sheet = self.expand_css_constants(sheet)
        if not sheet: sheet = self.default_style_sheet()
        if w is None:
            w = self.get_master_widget(top)
        if trace: g.trace(w, len(sheet))
        w.setStyleSheet(sheet)
    else:
        if trace: g.trace('no style sheet')
.. @+node:ekr.20180316091943.1: *4* ssm.Stylesheet
# Computations on stylesheets themeselves.
.. @+node:ekr.20140915062551.19510: *5* ssm.expand_css_constants & helpers
css_warning_given = False

def expand_css_constants(self, sheet, font_size_delta=None, settingsDict=None):
    '''Expand @ settings into their corresponding constants.'''
    trace = False and not g.unitTesting
    trace_dict = False
    trace_loop = True
    trace_result = False
    c = self.c
    # Warn once if the stylesheet uses old style style-sheet comment
    if settingsDict is None:
        if trace: g.trace('----- using c.config.settingsDict')
        settingsDict = c.config.settingsDict
    if trace_dict:
        g.trace('===== settingsDict.keys()...')
        g.printObj(sorted(settingsDict.keys()))
    constants, deltas = self.adjust_sizes(font_size_delta, settingsDict)
    sheet = self.replace_indicator_constants(sheet)
    for pass_n in range(10):
        to_do = self.find_constants_referenced(sheet)
        if not to_do:
            break
        if trace and trace_loop:
            g.trace('===== pass %s, to_do...' % (1+pass_n))
            g.printList(to_do)
        old_sheet = sheet
        sheet = self.do_pass(constants, deltas, settingsDict, sheet, to_do)
        if sheet == old_sheet:
            break
    else:
       g.trace('Too many iterations')
    if to_do:
        g.trace('Unresolved @constants')
        g.printObj(to_do)
    sheet = self.resolve_urls(sheet)
    sheet = sheet.replace('\\\n', '') # join lines ending in \
    if trace and trace_result:
        g.trace('returns...\n', sheet)
    return sheet
.. @+node:ekr.20150617085045.1: *6* ssm.adjust_sizes
def adjust_sizes(self, font_size_delta, settingsDict):
    '''Adjust constants to reflect c._style_deltas.'''
    trace = False and not g.unitTesting
    c = self.c
    constants = {} # old: self.find_constants_defined(sheet)
    deltas = c._style_deltas
    # legacy
    if font_size_delta:
        deltas['font-size-body'] = font_size_delta
    if trace:
        g.trace('c._style_deltas', c._style_deltas)
    for delta in c._style_deltas:
        # adjust @font-size-body by font_size_delta
        # easily extendable to @font-size-*
        val = c.config.getString(delta)
        passes = 10
        while passes and val and val.startswith('@'):
            key = g.app.config.canonicalizeSettingName(val[1:])
            val = settingsDict.get(key)
            if val:
                val = val.val
            passes -= 1
        if deltas[delta] and (val is not None):
            size = ''.join(i for i in val if i in '01234567890.')
            units = ''.join(i for i in val if i not in '01234567890.')
            size = max(1, int(size) + deltas[delta])
            constants["@" + delta] = "%s%s" % (size, units)
    return constants, deltas
.. @+node:ekr.20180316093159.1: *6* ssm.do_pass
def do_pass(self, constants, deltas, settingsDict, sheet, to_do):
    
    trace = False and not g.unitTesting
    trace_found = True
    to_do.sort(key=len, reverse=True)
    for const in to_do:
        value = None
        if const in constants:
            # This constant is about to be removed.
            value = constants[const]
            if const[1:] not in deltas and not self.css_warning_given:
                self.css_warning_given = True
                g.es_print("'%s' from style-sheet comment definition, " % const)
                g.es_print("please use regular @string / @color type @settings.")
        else:
            key = g.app.config.canonicalizeSettingName(const[1:])
                # lowercase, without '@','-','_', etc.
            value = settingsDict.get(key)
            if value is not None:
                # New in Leo 5.5: Do NOT add comments here.
                # They RUIN style sheets if they appear in a nested comment!
                    # value = '%s /* %s */' % (g.u(value.val), key)
                value = g.u(value.val)
                if trace and trace_found:
                   g.trace('found: %30s %s' % (key, g.truncate(repr(value), 30)))
            elif key in self.color_db:
                # New in Leo 5.5: Do NOT add comments here.
                # They RUIN style sheets if they appear in a nested comment!
                value = self.color_db.get(key)
                    # value = '%s /* %s */' % (value, key)
                if trace and trace_found:
                    g.trace('found: %30s %s' % (key, g.truncate(repr(value), 30)))
        if value:
            # Partial fix for #780.
            try:
                sheet = re.sub(
                    const + "(?![-A-Za-z0-9_])",
                        # don't replace shorter constants occuring in larger
                    value,
                    sheet,
                )
            except Exception:
                g.es_print('Exception handling style sheet')
                g.es_print(sheet)
                g.es_exception()
        else:
            pass
            # tricky, might be an undefined identifier, but it might
            # also be a @foo in a /* comment */, where it's harmless.
            # So rely on whoever calls .setStyleSheet() to do the right thing.
    return sheet
.. @+node:tbrown.20131120093739.27085: *6* ssm.find_constants_referenced
def find_constants_referenced(self, text):
    """find_constants - Return a list of constants referenced in the supplied text,
    constants match::

        @[A-Za-z_][-A-Za-z0-9_]*
        i.e. @foo_1-5

    :Parameters:
    - `text`: text to search
    """
    aList = sorted(set(re.findall(r"@[A-Za-z_][-A-Za-z0-9_]*", text)))
    # Exempt references to Leo constructs.
    for s in ('@button', '@constants', '@data', '@language'):
        if s in aList:
            aList.remove(s)
    return aList
.. @+node:tbrown.20130411121812.28335: *6* ssm.find_constants_defined (no longer used)
def find_constants_defined(self, text):
    r"""find_constants - Return a dict of constants defined in the supplied text.

    NOTE: this supports a legacy way of specifying @<identifiers>, regular
    @string and @color settings should be used instead, so calling this
    wouldn't be needed.  expand_css_constants() issues a warning when
    @<identifiers> are found in the output of this method.

    Constants match::

        ^\s*(@[A-Za-z_][-A-Za-z0-9_]*)\s*=\s*(.*)$
        i.e.
        @foo_1-5=a
            @foo_1-5 = a more here

    :Parameters:
    - `text`: text to search
    """
    pattern = re.compile(r"^\s*(@[A-Za-z_][-A-Za-z0-9_]*)\s*=\s*(.*)$")
    ans = {}
    text = text.replace('\\\n', '') # merge lines ending in \
    for line in text.split('\n'):
        test = pattern.match(line)
        if test:
            ans.update([test.groups()])
    # constants may refer to other constants, de-reference here
    change = True
    level = 0
    while change and level < 10:
        level += 1
        change = False
        for k in ans:
            # pylint: disable=unnecessary-lambda
            # process longest first so @solarized-base0 is not replaced
            # when it's part of @solarized-base03
            for o in sorted(ans, key=lambda x: len(x), reverse=True):
                if o in ans[k]:
                    change = True
                    ans[k] = ans[k].replace(o, ans[o])
    if level == 10:
        print("Ten levels of recursion processing styles, abandoned.")
        g.es("Ten levels of recursion processing styles, abandoned.")
    return ans
.. @+node:ekr.20150617090104.1: *6* ssm.replace_indicator_constants
def replace_indicator_constants(self, sheet):
    '''
    In the stylesheet, replace (if they exist)::

        image: @tree-image-closed
        image: @tree-image-open

    by::

        url(path/closed.png)
        url(path/open.png)

    path can be relative to ~ or to leo/Icons.

    Assuming that ~/myIcons/closed.png exists, either of these will work::

        @string tree-image-closed = nodes-dark/triangles/closed.png
        @string tree-image-closed = myIcons/closed.png

    Return the updated stylesheet.
    '''
    trace = False and not g.unitTesting
    close_path = self.find_icon_path('tree-image-closed')
    open_path = self.find_icon_path('tree-image-open')
    # Make all substitutions in the stylesheet.
    table = (
        (open_path,  re.compile(r'\bimage:\s*@tree-image-open', re.IGNORECASE)),
        (close_path, re.compile(r'\bimage:\s*@tree-image-closed', re.IGNORECASE)),
        # (open_path,  re.compile(r'\bimage:\s*at-tree-image-open', re.IGNORECASE)),
        # (close_path, re.compile(r'\bimage:\s*at-tree-image-closed', re.IGNORECASE)),
    )
    if trace:
        g.trace('open path: ', repr(open_path))
        g.trace('close_path:', repr(close_path))
    for path, pattern in table:
        for mo in pattern.finditer(sheet):
            old = mo.group(0)
            new = 'image: url(%s)' % path
            if trace: g.trace('found', old)
            sheet = sheet.replace(old, new)
    return sheet
.. @+node:ekr.20180320054305.1: *6* ssm.resolve_urls
def resolve_urls(self, sheet):
    '''Resolve all relative url's so they use absolute paths.'''
    trace = g.trace_themes and not g.unitTesting
    pattern = re.compile(r'url\((.*)\)')
    join = g.os_path_finalize_join
    directories = self.compute_icon_directories()
    paths_traced = False
    if trace:
        paths_traced = True
        g.trace('Search paths...')
        g.printObj(directories)
    # Pass 1: Find all replacements without changing the sheet.
    replacements = []
    for mo in pattern.finditer(sheet):
        url = mo.group(1)
        if url.startswith(':/'):
            url = url[2:]
        elif g.os_path_isabs(url):
            if trace: g.trace('ABS:', url)
            continue
        for directory in directories:
            path = join(directory, url)
            if g.os_path_exists(path):
                if trace: g.trace('%35s ==> %s' % (url, path))
                old = mo.group(0)
                new = 'url(%s)' % path
                replacements.append((old, new),)
                break
        else:
            g.trace('%35s ==> %s' % (url, 'NOT FOUND'))
            if not paths_traced:
                paths_traced = True
                g.trace('Search paths...')
                g.printObj(directories)
    # Pass 2: Now we can safely make the replacements.
    for old, new in reversed(replacements):
        sheet = sheet.replace(old, new)
    return sheet
.. @+node:ekr.20140912110338.19372: *5* ssm.munge
def munge(self, stylesheet):
    '''
    Return the stylesheet without extra whitespace.

    To avoid false mismatches, this should approximate what Qt does.
    To avoid false matches, this should not munge too much.
    '''
    s = ''.join([s.lstrip().replace('  ', ' ').replace(' \n', '\n')
        for s in g.splitLines(stylesheet)])
    return s.rstrip()
        # Don't care about ending newline.
.. @+node:ekr.20180317062556.1: *4* sss.Theme files
.. @+node:ekr.20180316092116.1: *4* ssm.Widgets
.. @+node:ekr.20140913054442.19390: *5* ssm.get_master_widget
def get_master_widget(self, top=None):
    '''
    Carefully return the master widget.
    For --gui=qttabs, c.frame.top.leo_master is a LeoTabbedTopLevel.
    For --gui=qt,     c.frame.top is a DynamicWindow.
    '''
    if top is None: top = self.c.frame.top
    master = top.leo_master or top
    return master
.. @+node:ekr.20140913054442.19391: *5* ssm.set selected_style_sheet
def set_selected_style_sheet(self):
    '''For manual testing: update the stylesheet using c.p.b.'''
    if not g.unitTesting:
        c = self.c
        sheet = c.p.b
        sheet = self.expand_css_constants(sheet)
        w = self.get_master_widget(c.frame.top)
        w.setStyleSheet(sheet)
.. @+node:ekr.20031218072017.2145: *3* g.os_path_ Wrappers
@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.
.. @+node:ekr.20180314120442.1: *4* g.glob_glob
def glob_glob (pattern):
    '''Return the regularized glob.glob(pattern)'''
    aList = glob.glob(pattern)
    if g.isWindows:
        aList = [z.replace('\\','/') for z in aList]
    return aList
.. @+node:ekr.20031218072017.2146: *4* g.os_path_abspath
def os_path_abspath(path):
    """Convert a path to an absolute path."""
    path = g.toUnicodeFileEncoding(path)
    path = path.replace('\x00','') # Fix Pytyon 3 bug on Windows 10.
    path = os.path.abspath(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20031218072017.2147: *4* g.os_path_basename
def os_path_basename(path):
    """Return the second half of the pair returned by split(path)."""
    path = g.toUnicodeFileEncoding(path)
    path = os.path.basename(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20031218072017.2148: *4* g.os_path_dirname
def os_path_dirname(path):
    """Return the first half of the pair returned by split(path)."""
    path = g.toUnicodeFileEncoding(path)
    path = os.path.dirname(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20031218072017.2149: *4* g.os_path_exists
def os_path_exists(path):
    """Return True if path exists."""
    path = g.toUnicodeFileEncoding(path)
    path = path.replace('\x00','') # Fix Pytyon 3 bug on Windows 10.
    return os.path.exists(path)
.. @+node:ekr.20080922124033.6: *4* g.os_path_expandExpression & helper
def os_path_expandExpression(s, **keys):
    '''Expand all {{anExpression}} in c's context.'''
    trace = False and g.unitTesting
    c = keys.get('c')
    if not c:
        g.trace('can not happen: no c', g.callers())
        return s
    if not s:
        if trace: g.trace('no s')
        return ''
    s = g.toUnicode(s)
    # find and replace repeated path expressions
    previ, aList = 0, []
    while previ < len(s):
        i = s.find('{{', previ)
        j = s.find('}}', previ)
        if -1 < i < j:
            # Add anything from previous index up to '{{'
            if previ < i:
                aList.append(s[previ:i])
            # Get expression and find substitute
            exp = s[i + 2: j].strip()
            if exp:
                try:
                    s2 = replace_path_expression(c, exp)
                    if trace: g.trace('%r ==> %r' % (exp, s2))
                    aList.append(s2)
                except Exception:
                    g.es('Exception evaluating {{%s}} in %s' % (exp, s.strip()))
                    g.es_exception(full=True, c=c)
            # Prepare to search again after the last '}}'
            previ = j+2
        else:
            # Add trailing fragment (fragile in case of mismatched '{{'/'}}')
            aList.append(s[previ:])
            break
    val = ''.join(aList)
    if g.isWindows:
        val = val.replace('\\','/')
    if trace: g.trace(' returns', val)
    return val
.. @+node:ekr.20180120140558.1: *5* g.replace_path_expression
def replace_path_expression(c, expr):
    ''' local function to replace a single path expression.'''
    d = {
        'c': c,
        'g': g,
        # 'getString': c.config.getString,
        'p': c.p,
        'os': os,
        'sep': os.sep,
        'sys': sys,
    }
    val = eval(expr, d)
    return g.toUnicode(val, encoding='utf-8', reportErrors=True)
.. @+node:ekr.20080921060401.13: *4* g.os_path_expanduser
def os_path_expanduser(path):
    """wrap os.path.expanduser"""
    path = g.toUnicodeFileEncoding(path)
    result = os.path.normpath(os.path.expanduser(path))
    if g.isWindows:
        path = path.replace('\\','/')
    return result
.. @+node:ekr.20080921060401.14: *4* g.os_path_finalize
def os_path_finalize(path, **keys):
    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.
    There is no corresponding os.path method
    '''
    c = keys.get('c')
    expanduser = keys.get('expanduser', True)
        # 2014/09/17: Allow expanduser to be False.
    if c: path = g.os_path_expandExpression(path, **keys)
    if expanduser:
        path = g.os_path_expanduser(path)
    path = path.replace('\x00','') # Fix Pytyon 3 bug on Windows 10.
    path = os.path.abspath(path)
    path = os.path.normpath(path)
    if g.isWindows:
        path = path.replace('\\','/')
    # calling os.path.realpath here would cause problems in some situations.
    return path
.. @+node:ekr.20140917154740.19483: *4* g.os_path_finalize_join
def os_path_finalize_join(*args, **keys):
    '''Do os.path.join(*args), then finalize the result.'''
    c = keys.get('c')
    if c:
        args = [g.os_path_expandExpression(z, **keys)
            for z in args if z]
    path = os.path.normpath(os.path.abspath(
        g.os_path_join(*args, **keys))) # Handles expanduser
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20031218072017.2150: *4* g.os_path_getmtime
def os_path_getmtime(path):
    """Return the modification time of path."""
    path = g.toUnicodeFileEncoding(path)
    try:
        return os.path.getmtime(path)
    except Exception:
        return 0
.. @+node:ekr.20080729142651.2: *4* g.os_path_getsize
def os_path_getsize(path):
    '''Return the size of path.'''
    path = g.toUnicodeFileEncoding(path)
    return os.path.getsize(path)
.. @+node:ekr.20031218072017.2151: *4* g.os_path_isabs
def os_path_isabs(path):
    """Return True if path is an absolute path."""
    path = g.toUnicodeFileEncoding(path)
    return os.path.isabs(path)
.. @+node:ekr.20031218072017.2152: *4* g.os_path_isdir
def os_path_isdir(path):
    """Return True if the path is a directory."""
    path = g.toUnicodeFileEncoding(path)
    return os.path.isdir(path)
.. @+node:ekr.20031218072017.2153: *4* g.os_path_isfile
def os_path_isfile(path):
    """Return True if path is a file."""
    path = g.toUnicodeFileEncoding(path)
    return os.path.isfile(path)
.. @+node:ekr.20031218072017.2154: *4* g.os_path_join
def os_path_join(*args, **keys):
    '''
    The same as os.path.join, but safe for unicode.
    In addition, it supports the !! and . conventions.
    '''
    trace = False and not g.unitTesting
    c = keys.get('c')
    expanduser = keys.get('expanduser', True)
        # 2014/09/17: Allow expanduser to be False.
    uargs = [g.toUnicodeFileEncoding(arg) for arg in args]
    if trace: g.trace('1', uargs)
    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)
    if expanduser:
        uargs = [g.os_path_expanduser(z) for z in uargs if z]
    if trace: g.trace('2', uargs)
    if uargs:
        try:
            path = os.path.join(*uargs)
        except TypeError:
            g.trace(uargs, args, keys, g.callers())
            raise
    else:
        path = '' # 2017/11/12: don't crash.
    if trace: g.trace('3', path)
    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path)
    path = path.replace('\x00','') # Fix Pytyon 3 bug on Windows 10.
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20031218072017.2156: *4* g.os_path_normcase
def os_path_normcase(path):
    """Normalize the path's case."""
    path = g.toUnicodeFileEncoding(path)
    path = os.path.normcase(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20031218072017.2157: *4* g.os_path_normpath
def os_path_normpath(path):
    """Normalize the path."""
    path = g.toUnicodeFileEncoding(path)
    path = os.path.normpath(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20180314081254.1: *4* g.os_path_normslashes
def os_path_normslashes(path):
    if g.isWindows and path:
        path = path.replace('\\','/')
    return path
    
    
.. @+node:ekr.20080605064555.2: *4* g.os_path_realpath
def os_path_realpath(path):
    '''Return the canonical path of the specified filename, eliminating any
    symbolic links encountered in the path (if they are supported by the
    operating system).
    '''
    path = g.toUnicodeFileEncoding(path)
    path = os.path.realpath(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\','/')
    return path
.. @+node:ekr.20031218072017.2158: *4* g.os_path_split
def os_path_split(path):
    path = g.toUnicodeFileEncoding(path)
    head, tail = os.path.split(path)
    head = g.toUnicodeFileEncoding(head)
    tail = g.toUnicodeFileEncoding(tail)
    return head, tail
.. @+node:ekr.20031218072017.2159: *4* g.os_path_splitext
def os_path_splitext(path):
    path = g.toUnicodeFileEncoding(path)
    head, tail = os.path.splitext(path)
    head = g.toUnicodeFileEncoding(head)
    tail = g.toUnicodeFileEncoding(tail)
    return head, tail
.. @+node:ekr.20090829140232.6036: *4* g.os_startfile
def os_startfile(fname):
    @others

    if fname.find('"') > -1:
        quoted_fname = "'%s'" % fname
    else:
        quoted_fname = '"%s"' % fname
    if sys.platform.startswith('win'):
        # pylint: disable=no-member
        os.startfile(quoted_fname)
            # Exists only on Windows.
    elif sys.platform == 'darwin':
        # From Marc-Antoine Parent.
        try:
            # Fix bug 1226358: File URL's are broken on MacOS:
            # use fname, not quoted_fname, as the argument to subprocess.call.
            subprocess.call(['open', fname])
        except OSError:
            pass # There may be a spurious "Interrupted system call"
        except ImportError:
            os.system('open %s' % (quoted_fname))
    else:
        # Linux
        # The buffering argument to NamedTempFile does not exist on Python 2.
        try:
            ree = None
            wre = tempfile.NamedTemporaryFile()
            ree = io.open(wre.name, 'rb', buffering=0)
        except IOError:
            g.trace('error opening temp file for %r' % fname)
            if ree: ree.close()
            return
        try:
            subPopen = subprocess.Popen(['xdg-open', fname], stderr=wre, shell=False)
        except Exception:
            g.es_print('error opening %r' % fname)
            g.es_exception()
        try:
            itoPoll = g.IdleTime((lambda ito: itPoll(fname, ree, subPopen, g, ito)), delay=1000)
            itoPoll.start()
            # Let the Leo-Editor process run
            # so that Leo-Editor is usable while the file is open.
        except Exception:
            g.es_exception('exception executing g.startfile for %r' % fname)
.. @+node:bob.20170516112250.1: *5* stderr2log()
def stderr2log(g, ree, fname):
    """ Display stderr output in the Leo-Editor log pane

    Arguments:
        g:  Leo-Editor globals
        ree:  Read file descriptor for stderr
        fname:  file pathname

    Returns:
        None
    """

    while True:
        emsg = ree.read().decode('utf-8')
        if emsg:
            g.es_print_error('xdg-open {fn} caused output to stderr:\n{em}'.format(fn=fname, em=emsg))
        else:
            break
.. @+node:bob.20170516112304.1: *5* itPoll()
def itPoll(fname, ree, subPopen, g, ito):
    """ Poll for subprocess done

    Arguments:
        fname:  File name
        ree:  stderr read file descriptor
        subPopen:  URL open subprocess object
        g: Leo-Editor globals
        ito: Idle time object for itPoll()

    Returns:
        None
    """

    stderr2log(g, ree, fname)
    rc = subPopen.poll()
    if not rc is None:
        ito.stop()
        ito.destroy_self()
        if rc != 0:
            g.es_print('xdg-open {fn} failed with exit code {ec}'.format(fn=fname, ec=rc))
        stderr2log(g, ree, fname)
        ree.close()

.. @+node:ekr.20031218072017.2160: *4* g.toUnicodeFileEncoding
def toUnicodeFileEncoding(path):
    # Fix bug 735938: file association crash
    if path and g.isString(path):
        path = path.replace('\\', os.sep)
        # Yes, this is correct.  All os_path_x functions return Unicode strings.
        return g.toUnicode(path)
    else:
        return g.u('')
.. @+node:ekr.20180318133620.1: *3* LM.computeThemeFilePath & helper
def computeThemeFilePath(self):
    '''Return the absolute path to the theme .leo file.'''
    lm = self
    resolve = self.resolve_theme_path
    # Step 1: Use the --theme file if it exists
    path = resolve(lm.options.get('theme_path'), tag='--theme')
    if path: return path
    # Step 2: look for the @string theme-name setting in the first loaded file.
    # This is a hack, but especially useful for test*.leo files in leo/themes.
    if 1:
        path = lm.files and lm.files[0]
        if path and g.os_path_exists(path):
            # Tricky: we must call lm.computeLocalSettings *here*.
            theme_c = lm.openSettingsFile(path)
            settings_d, junk_shortcuts_d = lm.computeLocalSettings(
                c=theme_c,
                settings_d=lm.globalSettingsDict,
                shortcuts_d=lm.globalShortcutsDict,
                localFlag=False,
            )
            setting = settings_d.get_string_setting('theme-name')
            if setting:
                tag = theme_c.shortFileName()
                path = resolve(setting, tag=tag)
                if path: return path
    # Finally, use the setting in myLeoSettings.leo.
    setting = lm.globalSettingsDict.get_string_setting('theme-name')
    tag = 'myLeoSettings.leo'
    return resolve(setting, tag=tag)
.. @+node:ekr.20180321124503.1: *4* LM.resolve_theme_path
def resolve_theme_path(self, fn, tag):
    '''Search theme directories for the given .leo file.'''
    trace = False and not g.unitTesting # and g.trace_themes
    if not fn:
        return None
    if not fn.endswith('.leo'):
        fn += '.leo'
    if trace:
        print('')
        g.trace('%s: %s' % (tag, fn))
    for directory in self.computeThemeDirectories():
        path = g.os_path_join(directory, fn)
            # Normalizes slashes, etc.
        if g.os_path_exists(path):
            if trace: g.trace('%s is  in %s\n' % (fn, directory))
            return path
        elif trace: g.trace('%s not in %s' % (fn, directory))
    print('theme .leo file not found: %s' % fn)
    return None
.. @+node:ekr.20120213081706.10382: *3* LM.readGlobalSettingsFiles
def readGlobalSettingsFiles(self):
    '''Read leoSettings.leo and myLeoSettings.leo using a null gui.'''
    trace = g.trace_themes and not g.unitTesting
    lm = self
    # Open the standard settings files with a nullGui.
    # Important: their commanders do not exist outside this method!
    paths = [lm.computeLeoSettingsPath(), lm.computeMyLeoSettingsPath()]
    old_commanders = g.app.commanders()
    commanders = [lm.openSettingsFile(path) for path in paths]
    commanders = [z for z in commanders if z]
    settings_d, shortcuts_d = lm.createDefaultSettingsDicts()
    for c in commanders:
        # Merge the settings dicts from c's outline into
        # *new copies of* settings_d and shortcuts_d.
        settings_d, shortcuts_d = lm.computeLocalSettings(
            c, settings_d, shortcuts_d, localFlag=False)
    # Adjust the name.
    shortcuts_d.setName('lm.globalShortcutsDict')
    # g.trace('===== settings 1 keys:', len(settings_d.d.keys()))
    lm.globalSettingsDict = settings_d
    lm.globalShortcutsDict = shortcuts_d
    # Add settings from --theme or @string theme-name files.
    # This must be done *after* reading myLeoSettigns.leo.
    theme_path = lm.computeThemeFilePath()
    if theme_path:
        theme_c = lm.openSettingsFile(theme_path)
        if theme_c:
            # Merge theme_c's settings into globalSettingsDict.
            settings_d, junk_shortcuts_d = lm.computeLocalSettings(
                theme_c, settings_d, shortcuts_d, localFlag=False)
            lm.globalSettingsDict = settings_d
            # Set global vars
            g.app.theme_directory = g.os_path_dirname(theme_path)
                # Used by the StyleSheetManager.
            if 0:
                # Not necessary **provided** that theme .leo files
                # set @string theme-name to the name of the .leo file.
                g.app.theme_color = settings_d.get_string_setting('color-theme')
                g.app.theme_name = settings_d.get_string_setting('theme-name')
                if trace:
                    print('')
                    g.trace('=====\n')
                    print(' g.app.theme_path: %s' % g.app.theme_directory)
                    print(' g.app.theme_name: %s' % g.app.theme_name)
                    print('g.app.theme_color: %s' % g.app.theme_color)
                    print('')
    # Clear the cache entries for the commanders.
    # This allows this method to be called outside the startup logic.
    for c in commanders:
        if c not in old_commanders:
            g.app.forgetOpenFile(c.fileName())
.. @+node:ekr.20120219154958.10486: *3* LM.scanOptions & helpers
def scanOptions(self, fileName, pymacs):
    '''Handle all options, remove them from sys.argv and set lm.options.'''
    trace = False
    lm = self
    lm.old_argv = sys.argv[:]
    parser = optparse.OptionParser(
        usage="usage: launchLeo.py [options] file1, file2, ...")
        # Automatically implements the --help option.
    # Parse the options, and remove them from sys.argv.
    self.addOptionsToParser(parser)
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]]
    sys.argv.extend(args)
    if trace:
        print('scanOptions: options...')
        g.printDict({
            key: value for key, value in options.__dict__.items() if value
        })
    # Handle simple args...
    self.doSimpleOptions(options)
    # Compute the lm.files ivar.
    lm.files = lm.computeFilesList(options, fileName)
    # Compute the return values.
    script = None if pymacs else self.doScriptOption(options, parser)
    d = {
        'gui': lm.doGuiOption(options),
        'load_type': lm.doLoadTypeOption(options),
        'screenshot_fn': lm.doScreenShotOption(options),
            # --screen-shot=fn
        'script': script,
        'select': options.select and options.select.strip('"'),
            # --select=headline
        'theme_path': options.theme,
            # --theme=name
        'version': options.version,
            # --version: print the version and exit.
        'windowFlag': script and options.script_window, 
        'windowSize': lm.doWindowSizeOption(options),
    }
    if trace:
        print('scanOptions: returns...')
        g.printObj(d)
    return d
.. @+node:ekr.20180312150559.1: *4* LM.addOptionsToParser
@nobeautify

def addOptionsToParser(self, parser):
    
    add = parser.add_option
    
    def add_bool(option, help, dest=None):
        add(option, action='store_true', dest=dest, help=help)
        
    def add_other(option, help, dest=None, m=None):
        add(option, dest=dest, help=help, metavar=m)

    add_bool('--debug',         'enable debug mode')
    add_bool('--diff',          'use Leo as an external git diff')
    add_bool('--fullscreen',    'start fullscreen')
    add_bool('--ipython',       'enable ipython support')
    add_bool('--fail-fast',     'stop unit tests after the first failure')
    add_other('--gui',          'gui to use (qt/qttabs/console/null)')
    add_bool('--listen-to-log', 'start log_listener.py on startup')
    add_other('--load-type',    '@<file> type for non-outlines', m='TYPE')
    add_bool('--maximized',     'start maximized')
    add_bool('--minimized',     'start minimized')
    add_bool('--no-cache',      'disable reading of cached files')
    add_bool('--no-plugins',    'disable all plugins')
    add_bool('--no-splash',     'disable the splash screen')
    add_other('--screen-shot',  'take a screen shot and then exit', m='PATH')
    add_other('--script',       'execute a script and then exit', m="PATH")
    add_bool('--script-window', 'execute script using default gui')
    add_other('--select',       'headline or gnx of node to select', m='ID')
    add_bool('--session-restore','restore session tabs at startup')
    add_bool('--session-save',  'save session tabs on exit')
    add_bool('--silent',        'disable all log messages')
    add_other('--theme',        'use the named theme file', m='NAME')
    add_bool('--trace-binding', 'trace key bindings')
    add_bool('--trace-focus',   'trace changes of focus')
    add_bool('--trace-plugins', 'trace imports of plugins')
    add_other('--trace-setting', 'trace where named setting is set', m="NAME")
    add_bool('--trace-shutdown', 'trace shutdown logic')
    add_bool('--trace-themes',  'trace theme init logic')
    add_other('--window-size',  'initial window size (height x width)', m='SIZE')
    # Multiple bool values.
    add('-v', '--version', action='store_true',
        help='print version number and exit')
.. @+node:ekr.20120219154958.10483: *4* LM.computeFilesList
def computeFilesList(self, options, fileName):
    '''Return the list of files on the command line.'''
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = g.glob_glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return [g.os_path_normslashes(z) for z in result]
.. @+node:ekr.20180312150805.1: *4* LM.doGuiOption
def doGuiOption(self, options):
    gui = options.gui
    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            g.app.qt_use_tabs = True
        elif gui in ('console', 'curses', 'text', 'qt', 'null'):
                # text: cursesGui.py, curses: cursesGui2.py.
            g.app.qt_use_tabs = False
        else:
            print('scanOptions: unknown gui: %s.  Using qt gui' % gui)
            gui = 'qt'
            g.app.qt_use_tabs = False
    elif sys.platform == 'darwin':
        gui = 'qt'
        g.app.qt_use_tabs = False
    else:
        gui = 'qttabs'
        g.app.qt_use_tabs = True
    assert gui
    g.app.guiArgName = gui
    return gui
.. @+node:ekr.20180312152329.1: *4* LM.doLoadTypeOption
def doLoadTypeOption(self, options):
    
    s = options.load_type
    s = s.lower() if s else 'edit'
    return '@' + s

    
.. @+node:ekr.20180312152609.1: *4* LM.doScreenShotOption
def doScreenShotOption(self, options):

    trace = False
    # --screen-shot=fn
    s = options.screen_shot
    if s:
        s = s.strip('"')
    if trace: print('scanOptions: screen_shot', s)
    return s
.. @+node:ekr.20180312153008.1: *4* LM.doScriptOption
def doScriptOption(self, options, parser):

    trace = False
    # --script
    script = options.script
    if script:
        fn = g.os_path_finalize_join(g.app.loadDir, script)
        script, e = g.readFileIntoString(fn, kind='script:')
        if trace: print('scanOptions: script path',repr(fn))
    else:
        script = None
        if trace: print('scanOptions: no script')
    return script
.. @+node:ekr.20180312151544.1: *4* LM.doSimpleOptions
def doSimpleOptions(self, options):
    '''These args just set g.app ivars.'''
    trace = False
    # --debug
    g.app.debug = options.debug
    # --fail-fast
    g.app.failFast = options.fail_fast
    # --fullscreen
    g.app.start_fullscreen = options.fullscreen
    # --git-diff
    g.app.diff = options.diff
    # --listen-to-log
    g.app.listen_to_log_flag = options.listen_to_log
    # --ipython
    g.app.useIpython = options.ipython
    if trace: print('scanOptions: g.app.useIpython', g.app.useIpython)
    # --maximized
    g.app.start_maximized = options.maximized
    # --minimized
    g.app.start_minimized = options.minimized
    # --no-cache
    if options.no_cache:
        if trace: print('scanOptions: disabling caching')
        g.enableDB = False
    # --no-plugins
    if options.no_plugins:
        if trace: print('scanOptions: disabling plugins')
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = (
        not options.no_splash and
        not options.minimized)
    # --session-restore & --session-save
    g.app.restore_session = bool(options.session_restore)
    g.app.save_session = bool(options.session_save)
    # --silent
    g.app.silentMode = options.silent
    # --trace-binding
    g.app.trace_binding = options.trace_binding
    # --trace-focus
    g.app.trace_focus = options.trace_focus
    # --trace-plugins
    g.app.trace_plugins = options.trace_plugins
    # --trace-setting=setting
    g.app.trace_setting = options.trace_setting
        # g.app.config does not exist yet.
    # --trace-shutdown
    g.app.trace_shutdown = options.trace_shutdown
    # --trace-themes
    g.trace_themes = options.trace_themes

   
.. @+node:ekr.20180312154839.1: *4* LM.doWindowSizeOption
def doWindowSizeOption(self, options):
    
    # --window-size
    trace = False
    windowSize = options.window_size
    if windowSize:
        if trace: print('scanOptions: windowSize', repr(windowSize))
        try:
            h, w = windowSize.split('x')
            windowSize = int(h), int(w)
        except ValueError:
            windowSize = None
            print('scanOptions: bad --window-size:', windowSize)
    return windowSize
.. @+node:tbrown.20130316075512.28478: *3* qt_gui.getImageFinder
dump_given = False

def getImageFinder(self, name):
    '''Theme aware image (icon) path searching.'''
    trace = g.trace_themes and not g.unitTesting
    exists = g.os_path_exists
    getString = g.app.config.getString
    
    def dump(var, val):
        print('%20s: %s' % (var, val))
        
    join = g.os_path_join
    #
    # "Just works" for --theme and theme .leo files *provided* that
    # theme .leo files actually contain these settings!
    #
    theme_name1 = getString('color-theme')
    theme_name2 = getString('theme-name')
    roots = [
        g.os_path_join(g.computeHomeDir(), '.leo'),
        g.computeLeoDir(),
    ]
    theme_subs = [
        "themes/{theme}/Icons",
        "themes/{theme}",
        "Icons/{theme}",
    ]
    bare_subs = ["Icons", "."]
        # "." for icons referred to as Icons/blah/blah.png
    paths = []
    for theme_name in (theme_name1, theme_name2):
        for root in roots:
            for sub in theme_subs:
                paths.append(join(root, sub.format(theme=theme_name)))
    for root in roots:
        for sub in bare_subs:
            paths.append(join(root, sub))
    table = [z for z in paths if exists(z)]
    if trace and not self.dump_given:
        self.dump_given = True
        getString = g.app.config.getString
        print('')
        g.trace('...')
        # dump('g.app.theme_color', g.app.theme_color)
        dump('@string color_theme', getString('color_theme'))
        # dump('g.app.theme_name', g.app.theme_name)
        dump('@string theme_name', getString('theme_name'))
        print('directory table...')
        g.printObj(table)
        print('')
    for base_dir in table:
        path = join(base_dir, name)
        if exists(path):
            if trace: g.trace('%s is  in %s\n' % (name, base_dir))
            return path
        elif trace:
            g.trace(name, 'not in', base_dir)
    g.trace('not found:', name)
    return None
.. @+node:ekr.20140915062551.19510: *3* ssm.expand_css_constants & helpers
css_warning_given = False

def expand_css_constants(self, sheet, font_size_delta=None, settingsDict=None):
    '''Expand @ settings into their corresponding constants.'''
    trace = False and not g.unitTesting
    trace_dict = False
    trace_loop = True
    trace_result = False
    c = self.c
    # Warn once if the stylesheet uses old style style-sheet comment
    if settingsDict is None:
        if trace: g.trace('----- using c.config.settingsDict')
        settingsDict = c.config.settingsDict
    if trace_dict:
        g.trace('===== settingsDict.keys()...')
        g.printObj(sorted(settingsDict.keys()))
    constants, deltas = self.adjust_sizes(font_size_delta, settingsDict)
    sheet = self.replace_indicator_constants(sheet)
    for pass_n in range(10):
        to_do = self.find_constants_referenced(sheet)
        if not to_do:
            break
        if trace and trace_loop:
            g.trace('===== pass %s, to_do...' % (1+pass_n))
            g.printList(to_do)
        old_sheet = sheet
        sheet = self.do_pass(constants, deltas, settingsDict, sheet, to_do)
        if sheet == old_sheet:
            break
    else:
       g.trace('Too many iterations')
    if to_do:
        g.trace('Unresolved @constants')
        g.printObj(to_do)
    sheet = self.resolve_urls(sheet)
    sheet = sheet.replace('\\\n', '') # join lines ending in \
    if trace and trace_result:
        g.trace('returns...\n', sheet)
    return sheet
.. @+node:ekr.20150617085045.1: *4* ssm.adjust_sizes
def adjust_sizes(self, font_size_delta, settingsDict):
    '''Adjust constants to reflect c._style_deltas.'''
    trace = False and not g.unitTesting
    c = self.c
    constants = {} # old: self.find_constants_defined(sheet)
    deltas = c._style_deltas
    # legacy
    if font_size_delta:
        deltas['font-size-body'] = font_size_delta
    if trace:
        g.trace('c._style_deltas', c._style_deltas)
    for delta in c._style_deltas:
        # adjust @font-size-body by font_size_delta
        # easily extendable to @font-size-*
        val = c.config.getString(delta)
        passes = 10
        while passes and val and val.startswith('@'):
            key = g.app.config.canonicalizeSettingName(val[1:])
            val = settingsDict.get(key)
            if val:
                val = val.val
            passes -= 1
        if deltas[delta] and (val is not None):
            size = ''.join(i for i in val if i in '01234567890.')
            units = ''.join(i for i in val if i not in '01234567890.')
            size = max(1, int(size) + deltas[delta])
            constants["@" + delta] = "%s%s" % (size, units)
    return constants, deltas
.. @+node:ekr.20180316093159.1: *4* ssm.do_pass
def do_pass(self, constants, deltas, settingsDict, sheet, to_do):
    
    trace = False and not g.unitTesting
    trace_found = True
    to_do.sort(key=len, reverse=True)
    for const in to_do:
        value = None
        if const in constants:
            # This constant is about to be removed.
            value = constants[const]
            if const[1:] not in deltas and not self.css_warning_given:
                self.css_warning_given = True
                g.es_print("'%s' from style-sheet comment definition, " % const)
                g.es_print("please use regular @string / @color type @settings.")
        else:
            key = g.app.config.canonicalizeSettingName(const[1:])
                # lowercase, without '@','-','_', etc.
            value = settingsDict.get(key)
            if value is not None:
                # New in Leo 5.5: Do NOT add comments here.
                # They RUIN style sheets if they appear in a nested comment!
                    # value = '%s /* %s */' % (g.u(value.val), key)
                value = g.u(value.val)
                if trace and trace_found:
                   g.trace('found: %30s %s' % (key, g.truncate(repr(value), 30)))
            elif key in self.color_db:
                # New in Leo 5.5: Do NOT add comments here.
                # They RUIN style sheets if they appear in a nested comment!
                value = self.color_db.get(key)
                    # value = '%s /* %s */' % (value, key)
                if trace and trace_found:
                    g.trace('found: %30s %s' % (key, g.truncate(repr(value), 30)))
        if value:
            # Partial fix for #780.
            try:
                sheet = re.sub(
                    const + "(?![-A-Za-z0-9_])",
                        # don't replace shorter constants occuring in larger
                    value,
                    sheet,
                )
            except Exception:
                g.es_print('Exception handling style sheet')
                g.es_print(sheet)
                g.es_exception()
        else:
            pass
            # tricky, might be an undefined identifier, but it might
            # also be a @foo in a /* comment */, where it's harmless.
            # So rely on whoever calls .setStyleSheet() to do the right thing.
    return sheet
.. @+node:tbrown.20131120093739.27085: *4* ssm.find_constants_referenced
def find_constants_referenced(self, text):
    """find_constants - Return a list of constants referenced in the supplied text,
    constants match::

        @[A-Za-z_][-A-Za-z0-9_]*
        i.e. @foo_1-5

    :Parameters:
    - `text`: text to search
    """
    aList = sorted(set(re.findall(r"@[A-Za-z_][-A-Za-z0-9_]*", text)))
    # Exempt references to Leo constructs.
    for s in ('@button', '@constants', '@data', '@language'):
        if s in aList:
            aList.remove(s)
    return aList
.. @+node:tbrown.20130411121812.28335: *4* ssm.find_constants_defined (no longer used)
def find_constants_defined(self, text):
    r"""find_constants - Return a dict of constants defined in the supplied text.

    NOTE: this supports a legacy way of specifying @<identifiers>, regular
    @string and @color settings should be used instead, so calling this
    wouldn't be needed.  expand_css_constants() issues a warning when
    @<identifiers> are found in the output of this method.

    Constants match::

        ^\s*(@[A-Za-z_][-A-Za-z0-9_]*)\s*=\s*(.*)$
        i.e.
        @foo_1-5=a
            @foo_1-5 = a more here

    :Parameters:
    - `text`: text to search
    """
    pattern = re.compile(r"^\s*(@[A-Za-z_][-A-Za-z0-9_]*)\s*=\s*(.*)$")
    ans = {}
    text = text.replace('\\\n', '') # merge lines ending in \
    for line in text.split('\n'):
        test = pattern.match(line)
        if test:
            ans.update([test.groups()])
    # constants may refer to other constants, de-reference here
    change = True
    level = 0
    while change and level < 10:
        level += 1
        change = False
        for k in ans:
            # pylint: disable=unnecessary-lambda
            # process longest first so @solarized-base0 is not replaced
            # when it's part of @solarized-base03
            for o in sorted(ans, key=lambda x: len(x), reverse=True):
                if o in ans[k]:
                    change = True
                    ans[k] = ans[k].replace(o, ans[o])
    if level == 10:
        print("Ten levels of recursion processing styles, abandoned.")
        g.es("Ten levels of recursion processing styles, abandoned.")
    return ans
.. @+node:ekr.20150617090104.1: *4* ssm.replace_indicator_constants
def replace_indicator_constants(self, sheet):
    '''
    In the stylesheet, replace (if they exist)::

        image: @tree-image-closed
        image: @tree-image-open

    by::

        url(path/closed.png)
        url(path/open.png)

    path can be relative to ~ or to leo/Icons.

    Assuming that ~/myIcons/closed.png exists, either of these will work::

        @string tree-image-closed = nodes-dark/triangles/closed.png
        @string tree-image-closed = myIcons/closed.png

    Return the updated stylesheet.
    '''
    trace = False and not g.unitTesting
    close_path = self.find_icon_path('tree-image-closed')
    open_path = self.find_icon_path('tree-image-open')
    # Make all substitutions in the stylesheet.
    table = (
        (open_path,  re.compile(r'\bimage:\s*@tree-image-open', re.IGNORECASE)),
        (close_path, re.compile(r'\bimage:\s*@tree-image-closed', re.IGNORECASE)),
        # (open_path,  re.compile(r'\bimage:\s*at-tree-image-open', re.IGNORECASE)),
        # (close_path, re.compile(r'\bimage:\s*at-tree-image-closed', re.IGNORECASE)),
    )
    if trace:
        g.trace('open path: ', repr(open_path))
        g.trace('close_path:', repr(close_path))
    for path, pattern in table:
        for mo in pattern.finditer(sheet):
            old = mo.group(0)
            new = 'image: url(%s)' % path
            if trace: g.trace('found', old)
            sheet = sheet.replace(old, new)
    return sheet
.. @+node:ekr.20180320054305.1: *4* ssm.resolve_urls
def resolve_urls(self, sheet):
    '''Resolve all relative url's so they use absolute paths.'''
    trace = g.trace_themes and not g.unitTesting
    pattern = re.compile(r'url\((.*)\)')
    join = g.os_path_finalize_join
    directories = self.compute_icon_directories()
    paths_traced = False
    if trace:
        paths_traced = True
        g.trace('Search paths...')
        g.printObj(directories)
    # Pass 1: Find all replacements without changing the sheet.
    replacements = []
    for mo in pattern.finditer(sheet):
        url = mo.group(1)
        if url.startswith(':/'):
            url = url[2:]
        elif g.os_path_isabs(url):
            if trace: g.trace('ABS:', url)
            continue
        for directory in directories:
            path = join(directory, url)
            if g.os_path_exists(path):
                if trace: g.trace('%35s ==> %s' % (url, path))
                old = mo.group(0)
                new = 'url(%s)' % path
                replacements.append((old, new),)
                break
        else:
            g.trace('%35s ==> %s' % (url, 'NOT FOUND'))
            if not paths_traced:
                paths_traced = True
                g.trace('Search paths...')
                g.printObj(directories)
    # Pass 2: Now we can safely make the replacements.
    for old, new in reversed(replacements):
        sheet = sheet.replace(old, new)
    return sheet
.. @+node:ekr.20180325023020.1: ** re: backup git issues
.. @+node:ekr.20180126043905.1: *3* g.getGitIssues
def getGitIssues(c,
    base_url=None,
    label_list=None,
    include_body=False,
    milestone=None,
    state=None, # in (None, 'closed', 'open')
):
    '''Get a list of issues from Leo's GitHub site.'''
    if base_url is None:
        base_url = 'https://api.github.com/repos/leo-editor/leo-editor/issues'
    if isinstance(label_list, (list, tuple)):
        root = c.lastTopLevel().insertAfter()
        root.h = 'Issues for ' + milestone if milestone else 'Backup'
        GitIssueController().backup_issues(base_url, c, root)
        root.expand()
        c.selectPosition(root)
        c.redraw()
        g.trace('done')
    else:
        g.trace('label_list must be a list or tuple', repr(label_list))
.. @+node:ekr.20180126044602.1: *4* class GitIssueController
class GitIssueController(object):
    '''
    A class encapsulating the retrieval of GitHub issues.
    
    The GitHub api: https://developer.github.com/v3/issues/
    '''
    @others
.. @+node:ekr.20180325023336.1: *5* git.backup_issues
def backup_issues(self, base_url, c, root, state=None):
    
    self.base_url = base_url
    self.root = root
    self.include_body = True
    self.milestone = None
    if state is None:
        for state in ('closed', 'open'):
            organizer = root.insertAsLastChild()
            organizer.h = '%s issues...' % state
            self.get_all_issues(organizer, state)
    elif state in ('closed', 'open'):
        self.get_all_issues(root, state)
    else:
        g.es_print('state must be in (None, "open", "closed")')
.. @+node:ekr.20180325024334.1: *5* git.get_all_issues
def get_all_issues(self, root, state, limit=100):
    '''Get all issues for the base url.'''
    trace = False
    import requests
    label = None
    assert state in ('open', 'closed')
    page_url = self.base_url + '?&state=%s&page=%s'
    page, total = 1, 0
    while True:
        url =  page_url % (state, page)
        r = requests.get(url)
        try:
            done, n = self.get_one_page(label, page, r, root)
            if trace and page == 1:
                self.print_header(r)
        except AttributeError:
            g.trace('Possible rate limit')
            self.print_header(r)
            g.es_exception()
            break
        total += n
        if done:
            break
        page += 1
        if page > limit:
            g.trace('too many pages')
            break
.. @+node:ekr.20180126044850.1: *5* git.get_issues
def get_issues(self, base_url, include_body, label_list, milestone, root, state):
    '''Create a list of issues for each label in label_list.'''
    self.base_url = base_url
    self.include_body = include_body
    self.milestone = milestone
    self.root = root
    self.state = state # in (None, 'closed', 'open')
    for label in label_list:
        self.get_one_issue(label)
.. @+node:ekr.20180126043719.3: *5* git.get_one_issue
def get_one_issue(self, label, limit=20):
    '''Create a list of issues with the given label.'''
    import requests
    root = self.root.insertAsLastChild()
    page, total = 1, 0
    page_url = self.base_url + '?labels=%s&state=closed&page=%s'
    while True:
        url =  page_url % (label, page)
        r = requests.get(url)
        try:
            done, n = self.get_one_page(label, page, r, root)
            # if page == 1: self.print_header(r)
        except AttributeError:
            g.trace('Possible rate limit')
            self.print_header(r)
            g.es_exception()
            break
        total += n
        if done:
            break
        page += 1
        if page > limit:
            g.trace('too many pages')
            break
    root.h = '%s %s issues for milestone %s' % (total, label, self.milestone)
.. @+node:ekr.20180126043719.4: *5* git.get_one_page
def get_one_page(self, label, page, r, root):
    
    trace = True
    if self.milestone:
        aList = [
            z for z in r.json()
                if z.get('milestone') is not None and
                    self.milestone==z.get('milestone').get('title')
        ]
    else:
        aList = [z for z in r.json()]
    for d in aList:
        n, title = d.get('number'), d.get('title')
        p = root.insertAsNthChild(0)
        p.h = '#%s: %s' % (n, title)
        p.b = '%s/%s\n' % (self.base_url, n)
        if self.include_body:
            p.b += d.get('body').strip()
    link = r.headers.get('Link')
    done = not link or link.find('rel="next"') == -1
    if trace: g.trace('%12s %2s %2s done: %s' % (label, page, len(aList), done))
    return done, len(aList)
.. @+node:ekr.20180127092201.1: *5* git.print_header
def print_header(self, r):
    
    # r.headers is a CaseInsensitiveDict
    # so g.printObj(r.headers) is just repr(r.headers)
    if 0:
        print('Link', r.headers.get('Link'))
    else:
        for key in r.headers:
            print('%35s: %s' % (key, r.headers.get(key)))
.. @+node:ekr.20180325025502.1: *3* g.backupGitIssues
def backupGitIssues(c, base_url=None):
    '''Get a list of issues from Leo's GitHub site.'''
    import time

    if base_url is None:
        base_url = 'https://api.github.com/repos/leo-editor/leo-editor/issues'
    
    root = c.lastTopLevel().insertAfter()
    root.h = 'Backup of issues: %s' % time.strftime("%Y/%m/%d")
    GitIssueController().backup_issues(base_url, c, root)
    root.expand()
    c.selectPosition(root)
    c.redraw()
    g.trace('done')
   
.. @+node:ekr.20180126044602.1: *3* class GitIssueController
class GitIssueController(object):
    '''
    A class encapsulating the retrieval of GitHub issues.
    
    The GitHub api: https://developer.github.com/v3/issues/
    '''
    @others
.. @+node:ekr.20180325023336.1: *4* git.backup_issues
def backup_issues(self, base_url, c, root, state=None):
    
    self.base_url = base_url
    self.root = root
    self.include_body = True
    self.milestone = None
    if state is None:
        for state in ('closed', 'open'):
            organizer = root.insertAsLastChild()
            organizer.h = '%s issues...' % state
            self.get_all_issues(organizer, state)
    elif state in ('closed', 'open'):
        self.get_all_issues(root, state)
    else:
        g.es_print('state must be in (None, "open", "closed")')
.. @+node:ekr.20180325024334.1: *4* git.get_all_issues
def get_all_issues(self, root, state, limit=100):
    '''Get all issues for the base url.'''
    trace = False
    import requests
    label = None
    assert state in ('open', 'closed')
    page_url = self.base_url + '?&state=%s&page=%s'
    page, total = 1, 0
    while True:
        url =  page_url % (state, page)
        r = requests.get(url)
        try:
            done, n = self.get_one_page(label, page, r, root)
            if trace and page == 1:
                self.print_header(r)
        except AttributeError:
            g.trace('Possible rate limit')
            self.print_header(r)
            g.es_exception()
            break
        total += n
        if done:
            break
        page += 1
        if page > limit:
            g.trace('too many pages')
            break
.. @+node:ekr.20180126044850.1: *4* git.get_issues
def get_issues(self, base_url, include_body, label_list, milestone, root, state):
    '''Create a list of issues for each label in label_list.'''
    self.base_url = base_url
    self.include_body = include_body
    self.milestone = milestone
    self.root = root
    self.state = state # in (None, 'closed', 'open')
    for label in label_list:
        self.get_one_issue(label)
.. @+node:ekr.20180126043719.3: *4* git.get_one_issue
def get_one_issue(self, label, limit=20):
    '''Create a list of issues with the given label.'''
    import requests
    root = self.root.insertAsLastChild()
    page, total = 1, 0
    page_url = self.base_url + '?labels=%s&state=closed&page=%s'
    while True:
        url =  page_url % (label, page)
        r = requests.get(url)
        try:
            done, n = self.get_one_page(label, page, r, root)
            # if page == 1: self.print_header(r)
        except AttributeError:
            g.trace('Possible rate limit')
            self.print_header(r)
            g.es_exception()
            break
        total += n
        if done:
            break
        page += 1
        if page > limit:
            g.trace('too many pages')
            break
    root.h = '%s %s issues for milestone %s' % (total, label, self.milestone)
.. @+node:ekr.20180126043719.4: *4* git.get_one_page
def get_one_page(self, label, page, r, root):
    
    trace = True
    if self.milestone:
        aList = [
            z for z in r.json()
                if z.get('milestone') is not None and
                    self.milestone==z.get('milestone').get('title')
        ]
    else:
        aList = [z for z in r.json()]
    for d in aList:
        n, title = d.get('number'), d.get('title')
        p = root.insertAsNthChild(0)
        p.h = '#%s: %s' % (n, title)
        p.b = '%s/%s\n' % (self.base_url, n)
        if self.include_body:
            p.b += d.get('body').strip()
    link = r.headers.get('Link')
    done = not link or link.find('rel="next"') == -1
    if trace: g.trace('%12s %2s %2s done: %s' % (label, page, len(aList), done))
    return done, len(aList)
.. @+node:ekr.20180127092201.1: *4* git.print_header
def print_header(self, r):
    
    # r.headers is a CaseInsensitiveDict
    # so g.printObj(r.headers) is just repr(r.headers)
    if 0:
        print('Link', r.headers.get('Link'))
    else:
        for key in r.headers:
            print('%35s: %s' % (key, r.headers.get(key)))
.. @+node:ekr.20180327112019.1: ** #840: config.getData(foo) strips comments inconsistently
https://github.com/leo-editor/leo-editor/issues/840
.. @+node:ekr.20120215072959.12527: *3* c.config.getData
def getData(self, setting, strip_comments=True, strip_data=True):
    '''Return a list of non-comment strings in the body text of @data setting.'''
    data = self.get(setting, "data")
    # New in Leo 4.11: parser.doData strips only comments now.
    # New in Leo 4.12: parser.doData strips *nothing*.
    if data and strip_comments:
        data = [z for z in data if not z.strip().startswith('#')]
    if data and strip_data:
        data = [z.strip() for z in data if z.strip()]
    return data
.. @+node:ekr.20071214140900.1: *3* gcm.getData & getOutlineData
def getData(self, setting, strip_comments=True, strip_data=True):
    '''Return a list of non-comment strings in the body text of @data setting.'''
    data = self.get(setting, "data")
    # New in Leo 4.12.1: add two keyword arguments, with legacy defaults.
    if data and strip_comments:
        data = [z for z in data if not z.strip().startswith('#')]
    if data and strip_data:
        data = [z.strip() for z in data if z.strip()]
    return data

def getOutlineData(self, setting):
    '''Return the pastable (xml text) of the entire @outline-data tree.'''
    return self.get(setting, "outlinedata")
.. @+node:ekr.20180327100702.1: ** ===== Allow @path in body text
.. @+node:ekr.20161028035902.1: *3* << LeoApp: error messages >>
self.menuWarningsGiven = False
    # True: supress warnings in menu code.
self.unicodeErrorGiven = True
    # True: suppres unicode tracebacks.
.. @+node:ekr.20080923070954.4: *3* at.scanAllDirectives
def scanAllDirectives(self,
    p,
    forcePythonSentinels=False,
    importing=False,
    issuePathWarning=False,
    reading=False,
):
    '''
    Scan p and p's ancestors looking for directives,
    setting corresponding AtFile ivars.
    '''
    trace = False and not g.unitTesting
    at, c = self, self.c
    g.app.atPathInBodyWarning = None
    << set ivars >>
    lang_dict = {'language': at.language, 'delims': delims,}
    table = (
        ('encoding', at.encoding, g.scanAtEncodingDirectives),
        # ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lang-dict', None, g.scanAtCommentAndAtLanguageDirectives),
        ('lineending', None, g.scanAtLineendingDirectives),
        ('pagewidth', c.page_width, g.scanAtPagewidthDirectives),
        ('path', None, c.scanAtPathDirectives),
        ('tabwidth', c.tab_width, g.scanAtTabwidthDirectives),
    )
    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key, default, func in table:
        val = func(aList)
        d[key] = default if val is None else val
    # Post process.
    lineending = d.get('lineending')
    lang_dict = d.get('lang-dict')
    if lang_dict:
        delims = lang_dict.get('delims')
        at.language = lang_dict.get('language')
        if trace: g.trace('1', at.language, delims)
    else:
        # No language directive.  Look for @<file> nodes.
        language = g.getLanguageFromAncestorAtFileNode(p) or 'python'
        delims = g.set_delims_from_language(language)
        if trace: g.trace('2', repr(language), delims)
    at.encoding = d.get('encoding')
    at.explicitLineEnding = bool(lineending)
    at.output_newline = lineending or g.getOutputNewline(c=c)
    at.page_width = d.get('pagewidth')
    at.default_directory = d.get('path')
    at.tab_width = d.get('tabwidth')
    if not importing and not reading:
        # Don't override comment delims when reading!
        << set comment strings from delims >>
    # For unit testing.
    d = {
        "all": all,
        "encoding": at.encoding,
        "language": at.language,
        "lineending": at.output_newline,
        "pagewidth": at.page_width,
        "path": at.default_directory,
        "tabwidth": at.tab_width,
    }
    if trace:
        # g.trace('forcePythonSentinels', forcePythonSentinels)
        g.trace('returns', d.get('language'), p.h, g.callers())
    return d
.. @+node:ekr.20080923070954.14: *4* << Set ivars >> (at.scanAllDirectives)
at.page_width = c.page_width
at.tab_width = c.tab_width
at.default_directory = None # 8/2: will be set later.
if c.target_language:
    c.target_language = c.target_language.lower()
delims = g.set_delims_from_language(c.target_language)
at.language = c.target_language
at.encoding = c.config.default_derived_file_encoding
at.output_newline = g.getOutputNewline(c=c) # Init from config settings.
.. @+node:ekr.20080923070954.13: *4* << Set comment strings from delims >> (at.scanAllDirectives)
if forcePythonSentinels:
    # Force Python language.
    delim1, delim2, delim3 = g.set_delims_from_language("python")
    self.language = "python"
else:
    delim1, delim2, delim3 = delims
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    # 2016/11/25: Issue an error only if at.language has been set.
    # This suppresses a message from the markdown importer.
    if not g.app.unitTesting and at.language:
        g.trace(repr(at.language), g.callers())
        g.es_print("unknown language: using Python comment delimiters")
        g.es_print("c.target_language:", c.target_language)
    at.startSentinelComment = "#" # This should never happen!
    at.endSentinelComment = ""
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
.. @+node:ekr.20080828103146.15: *3* c.scanAtPathDirectives
def scanAtPathDirectives(self, aList):
    '''Scan aList for @path directives.
    Return a reasonable default if no @path directive is found.'''
    trace = False and not g.unitTesting
        # This is called at idle time, so it's not very useful.
    verbose = True
    c = self
    c.scanAtPathDirectivesCount += 1 # An important statistic.
    if trace and verbose: g.trace('**entry', g.callers(4))
    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory: # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!": base = g.app.loadDir
        elif base and base == ".": base = c.openDirectory
    if trace and verbose:
        g.trace('base   ', base)
        g.trace('loadDir', g.app.loadDir)
    absbase = c.os_path_finalize_join(g.app.loadDir, base)
    if trace and verbose: g.trace('absbase', absbase)
    # Step 2: look for @path directives.
    paths = []
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        warning = d.get('@path_in_body')
        if trace and path:
            g.trace('**** d', d)
            g.trace('**** @path path', path)
        if path is not None: # retain empty paths for warnings.
            # Convert "path" or <path> to path.
            path = g.stripPathCruft(path)
            if path and not warning:
                paths.append(path)
            # We will silently ignore empty @path directives.
    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()
    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose:
        g.printList(paths, tag='c.scanAtPathDirectives: raw paths')
    path = c.os_path_finalize_join(*paths)
    if trace and verbose: g.trace('joined path:', path)
    if trace: g.trace('returns', path)
    return path or g.getBaseDirectory(c)
        # 2010/10/22: A useful default.
.. @+node:ekr.20090214075058.9: *3* g.get_directives_dict (must be fast)
# The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].
g_noweb_root = re.compile(
    '<' + '<' + '*' + '>' + '>' + '=',
    re.MULTILINE)

def get_directives_dict(p, root=None):
    """
    Scan p for @directives found in globalDirectiveList.

    Returns a dict containing the stripped remainder of the line
    following the first occurrence of each recognized directive
    """
    trace = False and not g.unitTesting
        # This is called at idle time, so it's not very useful.
    verbose = False
    if trace and verbose: g.trace('*' * 20, p.h)
    if root: root_node = root[0]
    c = p and p.v and p.v.context
    d = {}
    # Do this every time so plugins can add directives.
    pat = g.compute_directives_re()
    directives_pat = re.compile(pat, re.MULTILINE)
    # The headline has higher precedence because it is more visible.
    for kind, s in (('head', p.h), ('body', p.b)):
        anIter = directives_pat.finditer(s)
        for m in anIter:
            word = m.group(1).strip()
            i = m.start(1)
            if word in d: continue
            j = i + len(word)
            if j < len(s) and s[j] not in ' \t\n':
                continue
                    # Not a valid directive: just ignore it.
                    # A unit test tests that @path:any is invalid.
            k = g.skip_line(s, j)
            val = s[j: k].strip()
            if trace and c and p == c.p:
                g.trace('%20s %s' % (word, val))
            if word in ('root-doc', 'root-code'):
                d['root'] = val # in addition to optioned version
            d[word] = val
            # New in Leo 5.7.1: @path is allowed in body text.
            # This is very useful when doing recursive imports.
    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"] = 0 # value not immportant
            else:
                g.es('%s= may only occur in a topmost node (i.e., without a parent)' % (
                    g.angleBrackets('*')))
            break
    if trace and verbose:
        g.trace('%4d' % (len(p.h) + len(p.b)))
    return d
.. @+node:ekr.20090214075058.10: *4* g.compute_directives_re
def compute_directives_re():
    '''
    Return an re pattern which word matches all Leo directives.
    Only g.get_directives_dict uses this pattern.
    '''
    global globalDirectiveList
    # EKR: 2016/03/30: Use a pattern that guarantees word matches.
    aList = [r'\b%s\b' % (z) for z in globalDirectiveList
                if z != 'others']
    return "^@(%s)" % "|".join(aList)
.. @+node:ekr.20180327151141.1: ** New feature: Add @path in body text during recursive imports
.. @+node:ekr.20130823083943.12559: *3* c.recursiveImport
def recursiveImport(self, dir_, kind,
    add_path=True,
    recursive=True,
    safe_at_file=True,
    theTypes=None,
    # force_at_others=False, # tag:no-longer-used
):
    << docstring >>
    c = self
    if g.os_path_exists(dir_):
        # Import all files in dir_ after c.p.
        try:
            import leo.core.leoImport as leoImport
            cc = leoImport.RecursiveImportController(c, kind,
                add_path=add_path,
                recursive=recursive,
                safe_at_file=safe_at_file,
                theTypes=['.py'] if not theTypes else theTypes,
                # force_at_others = force_at_others,  # tag:no-longer-used
            )
            cc.run(dir_)
        finally:
            c.redraw()
    else:
        g.es_print('Does not exist: %s' % (dir_))
.. @+node:ekr.20130823083943.12614: *4* << docstring >>
'''
Recursively import all python files in a directory and clean the results.

Parameters::
    dir_              The root directory or file to import.
    kind              One of ('@clean','@edit','@file','@nosent').
    add_path=True     True: add a full @path directive to @<file> nodes.
    recursive=True    True: recurse into subdirectories.
    safe_at_file=True True: produce @@file nodes instead of @file nodes.
    theTypes=None     A list of file extensions to import.
                      None is equivalent to ['.py']

This method cleans imported files as follows:

- Replace backslashes with forward slashes in headlines.
- Remove empty nodes.
- Add @path directives that reduce the needed path specifiers in descendant nodes.
- Add @file to nodes or replace @file with @@file.
'''
.. @+node:ekr.20130823083943.12596: *3* class RecursiveImportController
class RecursiveImportController(object):
    '''Recursively import all python files in a directory and clean the result.'''
    @others
.. @+node:ekr.20130823083943.12615: *4* ric.ctor (RecursiveImportController)
def __init__(self, c, kind,
    # force_at_others = False, #tag:no-longer-used
    add_path=True,
    recursive=True,
    safe_at_file=True,
    theTypes=None,
):
    '''Ctor for RecursiveImportController class.'''
    self.c = c
    self.add_path = add_path
    self.kind = kind
        # in ('@auto', '@clean', '@edit', '@file', '@nosent')
    # self.force_at_others = force_at_others #tag:no-longer-used
    self.recursive = recursive
    self.root = None
    self.safe_at_file = safe_at_file
    self.theTypes = theTypes
.. @+node:ekr.20130823083943.12613: *4* ric.run & helpers
def run(self, dir_):
    '''
    Import all files whose extension matches self.theTypes in dir_.
    In fact, dir_ can be a path to a single file.
    '''
    if self.kind not in ('@auto', '@clean', '@edit', '@file', '@nosent'):
        g.es('bad kind param', self.kind, color='red')
    try:
        c = self.c
        p1 = self.root = c.p
        t1 = time.time()
        g.app.disable_redraw = True
        bunch = c.undoer.beforeChangeTree(p1)
        # Leo 5.6: Always create a new last top-level node.
        last = c.lastTopLevel()
        parent = last.insertAfter()
        parent.v.h = 'imported files'
        # Leo 5.6: Special case for a single file.
        self.n_files = 0
        if g.os_path_isfile(dir_):
            g.es_print('\nimporting file:', dir_)
            self.import_one_file(dir_, parent)
        else:
            self.import_dir(dir_, parent)
            self.post_process(parent, dir_)
        c.undoer.afterChangeTree(p1, 'recursive-import', bunch)
    except Exception:
        g.es_print('Exception in recursive import')
        g.es_exception()
    finally:
        g.app.disable_redraw = False
        for p2 in parent.self_and_subtree():
            p2.contract()
        c.redraw(parent)
    t2 = time.time()
    n = len(list(parent.self_and_subtree()))
    g.es_print('imported %s node%s in %s file%s in %2.2f seconds' % (
        n, g.plural(n), self.n_files, g.plural(self.n_files), t2 - t1))
.. @+node:ekr.20130823083943.12597: *5* ric.import_dir
def import_dir(self, dir_, parent):
    '''Import selected files from dir_, a directory.'''
    trace = False and not g.unitTesting
    limit = True # True: only one file per directory.
    if g.os_path_isfile(dir_):
        files = [dir_]
    else:
        g.es_print('importing directory:', dir_)
        files = os.listdir(dir_)
    dirs, files2 = [], []
    for path in files:
        try:
            # Fix #408. Catch path exceptions.
            # The idea here is to keep going on small errors.
            path = g.os_path_join(dir_, path, expanduser=False)
            if g.os_path_isfile(path):
                name, ext = g.os_path_splitext(path)
                if ext in self.theTypes:
                    files2.append(path)
            elif self.recursive:
                dirs.append(path)
        except OSError:
            g.es_print('Exception computing', path)
            g.es_exception()
    if files or dirs:
        assert parent and parent.v != self.root.v, g.callers()
        parent = parent.insertAsLastChild()
        parent.v.h = dir_
        if files2:
            for f in files2:
                self.import_one_file(f, parent=parent)
                if trace and limit: break
        if dirs:
            assert self.recursive
            for dir_ in sorted(dirs):
                self.import_dir(dir_, parent)
.. @+node:ekr.20170404103953.1: *5* ric.import_one_file
def import_one_file(self, path, parent):
    '''Import one file to the last top-level node.'''
    c = self.c
    self.n_files += 1
    assert parent and parent.v != self.root.v, g.callers()
    if self.kind == '@edit':
        p = parent.insertAsLastChild()
        p.v.h = path.replace('\\', '/')
        s, e = g.readFileIntoString(path, kind=self.kind)
        p.v.b = s
        return
    elif self.kind == '@auto':
        p = parent.insertAsLastChild()
        p.v.h = path.replace('\\', '/')
        p.clearDirty()
    else:
        c.importCommands.importFilesCommand(
            files=[path],
            # force_at_others = self.force_at_others, #tag:no-longer-used
            parent=parent,
            redrawFlag=False,
            shortFn=True,
            treeType='@file', # '@auto','@clean','@nosent' cause problems.
        )
        p = parent.lastChild()
        p.h = self.kind + p.h[5:]
            # Bug fix 2017/10/27: honor the requested kind.
    if self.safe_at_file:
        p.v.h = '@' + p.v.h
.. @+node:ekr.20130823083943.12607: *5* ric.post_process & helpers
def post_process(self, p, prefix):
    '''
    Traverse p's tree, replacing all nodes that start with prefix
    by the smallest equivalent @path or @file node.
    '''
    trace = False and not g.unitTesting
    if trace: t1 = time.time()
    self.fix_back_slashes(p)
    prefix = prefix.replace('\\', '/')
    if self.kind not in ('@auto', '@edit'):
        self.remove_empty_nodes(p)
    if p.firstChild():
        self.minimize_headlines(p.firstChild(), prefix)
    self.clear_dirty_bits(p)
    if trace:
        t2 = time.time()
        g.trace('%2.2f sec' % (t2-t1))
.. @+node:ekr.20130823083943.12608: *6* ric.clear_dirty_bits
def clear_dirty_bits(self, p):
    c = self.c
    c.setChanged(False)
    for p in p.self_and_subtree():
        p.clearDirty()
.. @+node:ekr.20130823083943.12609: *6* ric.dump_headlines
def dump_headlines(self, p):
    # show all headlines.
    for p in p.self_and_subtree():
        print(p.h)
.. @+node:ekr.20130823083943.12610: *6* ric.fix_back_slashes
def fix_back_slashes(self, p):
    '''Convert backslash to slash in all headlines.'''
    for p in p.self_and_subtree():
        s = p.h.replace('\\', '/')
        if s != p.h:
            p.v.h = s
.. @+node:ekr.20130823083943.12611: *6* ric.minimize_headlines & helper
file_pattern = re.compile(r'^(([@])+(auto|clean|edit|file|nosent))')

def minimize_headlines(self, p, prefix):
    '''Create @path nodes to minimize the paths required in descendant nodes.'''
    if prefix and not prefix.endswith('/'):
        prefix = prefix + '/'
    m = self.file_pattern.match(p.h)
    if m:
        # It's an @file node of some kind. Strip off the prefix.
        kind = m.group(0)
        path = p.h[len(kind):].strip()
        stripped = self.strip_prefix(path, prefix)
        p.h = '%s %s' % (kind, stripped or path)
        # Put the *full* @path directive in the body.
        if self.add_path and prefix:
            tail = g.os_path_dirname(stripped).rstrip('/')
            p.b = '@path %s%s\n%s'  % (prefix, tail, p.b)
    else:
        # p.h is a path.
        path = p.h
        stripped = self.strip_prefix(path, prefix)
        p.h = '@path %s' % (stripped or path)
        for p in p.children():
            self.minimize_headlines(p, prefix + stripped)

.. @+node:ekr.20170404134052.1: *7* ric.strip_prefix
def strip_prefix(self, path, prefix):
    '''Strip the prefix from the path and return the result.'''
    if path.startswith(prefix):
        return path[len(prefix):]
    else:
        return '' # A signal.

.. @+node:ekr.20130823083943.12612: *6* ric.remove_empty_nodes
def remove_empty_nodes(self, p):
    '''Remove empty nodes. Not called for @auto or @edit trees.'''
    c = self.c
    aList = [p2 for p2 in p.self_and_subtree()
        if not p2.b and not p2.hasChildren()]
    if aList:
        c.deletePositionsInList(aList, redraw=False)
.. @+node:ekr.20130823083943.12611: *3* ric.minimize_headlines & helper
file_pattern = re.compile(r'^(([@])+(auto|clean|edit|file|nosent))')

def minimize_headlines(self, p, prefix):
    '''Create @path nodes to minimize the paths required in descendant nodes.'''
    if prefix and not prefix.endswith('/'):
        prefix = prefix + '/'
    m = self.file_pattern.match(p.h)
    if m:
        # It's an @file node of some kind. Strip off the prefix.
        kind = m.group(0)
        path = p.h[len(kind):].strip()
        stripped = self.strip_prefix(path, prefix)
        p.h = '%s %s' % (kind, stripped or path)
        # Put the *full* @path directive in the body.
        if self.add_path and prefix:
            tail = g.os_path_dirname(stripped).rstrip('/')
            p.b = '@path %s%s\n%s'  % (prefix, tail, p.b)
    else:
        # p.h is a path.
        path = p.h
        stripped = self.strip_prefix(path, prefix)
        p.h = '@path %s' % (stripped or path)
        for p in p.children():
            self.minimize_headlines(p, prefix + stripped)

.. @+node:ekr.20170404134052.1: *4* ric.strip_prefix
def strip_prefix(self, path, prefix):
    '''Strip the prefix from the path and return the result.'''
    if path.startswith(prefix):
        return path[len(prefix):]
    else:
        return '' # A signal.

.. @-all
.. @@nosearch
.. @@killbeautify
.. @@language rest
.. @@wrap
.. @@pagewidth 60
.. @-leo
