#@+leo-ver=5-thin
#@+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
#@+all
#@+node:ekr.20111103205308.9698: ** Unit tests
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)

s1 = '''
<table id="1"> <table id="2">
<contents/>
</table>
</table>
'''

s2 = '''
<table id="1"> 
<table id="2">
<contents/>
</table>
</table>
'''

t1 = 
assert result == expected,'expected...\n%s\ngot...\n%s' % (
    repr(expected),repr(result))
#@+node:ekr.20100907115157.5905: *3* @ignore Ancient tests
#@+node:ekr.20100208095423.5940: *4* @test leoCache
import leo.core.leoCache as leoCache

cacher = leoCache.cacher(c)

if 0:
    import os
    os.system('cls')

assert cacher.test()
#@+node:ekr.20100906165118.5915: *4* @test leoInkCommands
ic = c.inkscapeCommands
screenshot = r'c:\leo.repo\inkcall\some_screen_shot.png'
template_fn = r'c:\leo.repo\inkcall\template.svg'
png_fn = r'c:\leo.repo\inkcall\output.png'
svg_fn = r'c:\leo.repo\inkcall\temp.svg'
callouts = [
        "This goes here",
        "These are those, but slightly longer",
        "Then you pull this, but this text needs to be longer for testing",]
ic.run(
    screenshot,
    callouts=callouts,
    numbers=[2,4,17],
    edit_flag = True, # True: call inkscape to edit the working file.
    png_fn=png_fn, # Optional: Name of output png file.
    svg_fn=svg_fn, # Optional: Name of working svg file.
    template_fn=template_fn, # Optional: Name of template svg file.
)
#@+node:ekr.20111102123707.9629: *4* @ignore test of marked unit-test trees
#@+node:ekr.20111102123707.9630: *5* @test assert False
assert False
#@+node:ekr.20111102123707.9631: *5* @test assert True
assert True
#@+node:ekr.20111107092526.9799: *4* @test detection of external unit tests
# This test is redundant, and another test sets import_html_tags

# print('g.app.isExternalUnitTest',g.app.isExternalUnitTest)
if g.app.isExternalUnitTest:
    fn = c.shortFileName()
    assert fn.endswith('dynamicUnitTest.leo'),fn
    data = c.config.getData('import_html_tags')
    assert len(data) == 85 # length of data in leoSettings.leo.
else:
    data = c.config.getData('import_html_tags')
    assert len(data) == 85,len(data)
#@+node:ekr.20111107092526.9800: *5* doTests...
def doTests(c,all=None,marked=None,p=None,verbosity=1):

    trace = False ; verbose = False
    if all:
        p = c.rootPosition()
    elif not p:
        p = c.p
    p1 = c.p.copy() # 2011/10/31: always restore the selected position.
    
    g.trace(g.app.isExternalUnitTest)
    
    # This seems a bit risky when run in unitTest.leo.
    # c.save() # Eliminate the need for ctrl-s.
    
    if trace: g.trace('marked',marked,'c',c)

    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)

        # New in Leo 4.4.8: ignore everything in @ignore trees.
        last = None if all else p.nodeAfterTree()
        
        aList = findAllUnitTestNodes(c,p,last,all,marked,
            lookForMark=False,lookForNodes=True)
       
        found = False
        for p in aList:
            if isTestNode(p):
                if trace: g.trace('adding',p.h)
                test = makeTestCase(c,p)
            elif isSuiteNode(p): # @suite
                if trace: g.trace('adding',p.h)
                test = makeTestSuite(c,p)
            else:
                test = None
            if test:
                suite.addTest(test)
                found = True
        
        # Verbosity: 1: print just dots.
        if not found:
            # 2011/10/30: run the body of p as a unit test.
            test = makeTestCase(c,c.p)
            if test:
                suite.addTest(test)
                found = True
        if found:
            res = unittest.TextTestRunner(verbosity=verbosity).run(suite)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
                c.cacher.db[key] = archive
        else:
            g.es_print('no %s@test or @suite nodes in %s outline' % (
                g.choose(marked,'marked ',''),
                g.choose(all,'entire','selected')),color='red')
    finally:
        c.setChanged(changed) # Restore changed state.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.contractAllHeadlines()
            c.redraw(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20111107092526.9801: *6* class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20111107092526.9802: *7* __init__ (generalTestCase)
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@+node:ekr.20111107092526.9803: *7*  fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@+node:ekr.20111107092526.9804: *7* tearDown
def tearDown (self):

    pass

    # Restore the outline.
    self.c.outerUpdate()
#@+node:ekr.20111107092526.9805: *7* setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p.copy()) # 2010/02/03
#@+node:ekr.20111107092526.9806: *7* runTest (generalTestCase)
def runTest (self,define_g = True):

    trace = False
    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)
    
    if c.shortFileName() == 'dynamicUnitTest.leo':
        c.write_script_file = True

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p and p.copy(),'self':self,}
    else:
        d = {'self':self,}

    script = script + '\n'
    if trace: g.trace('p: %s c: %s write script: %s script:\n%s' % (
        p and p.h,c.shortFileName(),c.write_script_file,script))

    # Execute the script. Let the unit test handle any errors!
    # 2011/11/02: pass the script sources to exec or execfile.
    if c.write_script_file:
        scriptFile = c.writeScriptFile(script)
        if g.isPython3:
            exec(compile(script,scriptFile,'exec'),d)
        else:
            execfile(scriptFile,d)
    else:
        exec(script,d)
#@+node:ekr.20111107092526.9807: *7* shortDescription
def shortDescription (self):

    s = self.p.h

    # g.trace(s)

    return s + '\n'
#@+node:ekr.20111107092526.9808: *6* makeTestSuite (leoTest)
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()
    # g.trace('c.write_script_file',c.write_script_file)
    script = g.getScript(c,p).strip()
    if not script:
        print("no script in %s" % h)
        return None
    try:
        if 0: #debugging
            n,lines = 0,g.splitLines(script)
            for line in lines:
                print(n,line)
                n += 1
                
        # 2011/11/02: make script sources available.
        d = {'c':c,'g':g,'p':p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            if g.isPython3:
                exec(compile(script,scriptFile,'exec'),d)
            else:
                execfile(scriptFile,d)
        else:
            exec(script + '\n',d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("makeTestSuite: %s script did not set g.app.scriptDict" % p.h)
        return suite
    except Exception:
        print('makeTestSuite: exception creating test cases for %s' % p.h)
        g.es_exception()
        return None
#@+node:ekr.20111107092526.9809: *6* makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.b.strip():
        return generalTestCase(c,p)
    else:
        return None
#@+node:ekr.20111107092526.9810: *5* main & helpers (leoDynamicTest.py)
def main ():

    trace = False
    readSettings = True 
    tag = 'leoDynamicTests.leo'
    if trace: t1 = time.time()

    # Setting verbose=True prints messages that would be sent to the log pane.
    path,gui,silent = scanOptions()
    # print('(leoDynamicTest.py:main)','silent',silent)

    # Not loading plugins and not reading settings speeds things up considerably.
    bridge = leoBridge.controller(gui=gui,
        loadPlugins=False, # Must be False: plugins will fail when run externally.
        readSettings=True, # True adds about 0.3 seconds.  Is it useful?
        silent=True,
        verbose=False)

    if trace:
         t2 = time.time()
         print('%s open bridge:  %0.2fsec' % (tag,t2-t1))

    if bridge.isOpen():
        g = bridge.globals()
        g.app.silentMode = silent
        g.app.isExternalUnitTest = True
        path = g.os_path_finalize_join(g.app.loadDir,'..','test',path)
        c = bridge.openLeoFile(path)
        if trace:
            t3 = time.time()
            print('%s open file: %0.2fsec' % (tag,t3-t2))
        runUnitTests(c,g)
#@+node:ekr.20111107092526.9811: *6* runUnitTests
def runUnitTests (c,g):

    p = c.rootPosition()
    #g.es_print('running dynamic unit tests...')
    c.selectPosition(p)
    c.debugCommands.runAllUnitTestsLocally()
#@+node:ekr.20111107092526.9812: *6* scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('--path',dest='path')
    parser.add_option('--gui',dest="gui")
    parser.add_option('--silent',action="store_true",dest="silent")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)

    # -- path
    # We can't finalize the path here, because g does not exist ye.
    path = options.path or 'dynamicUnitTest.leo'

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('qttabs','qt'):
        gui = 'nullGui'

    # --silent
    silent = options.silent

    return path,gui,silent
#@+node:ekr.20111116161118.10248: *3* Recent tests
#@+node:ekr.20111104132424.9909: *4* @test assert True
# It's useful to have this do-nothing test.

assert True
#@+node:ekr.20111107092526.9819: *4* @test cls
g.cls() # Clear the screen
#@+node:ekr.20111110085739.10265: *4* @test html string
s = '''\
<HTML>
<head>
    <title>Bodystring</title>
</head>
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
</html>
'''

html_tags = ('body','head','html','table',) # 'div',
setting = 'import_html_tags'

# Settings now work when run externally.
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.app.unitTestDict ['expectedErrors'] = 0

showTree = True

c.importCommands.htmlUnitTest(p,s=s,showTree=showTree)

if showTree:
    # g.cls()
    for p in p.subtree():
        print('\n***** %s\n' %p.h)
        print(p.b)
#@+node:ekr.20120112100822.10003: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120112100822.10004: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120112100822.10005: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120112100822.10006: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120203153754.10033: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120203153754.10034: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120203153754.10035: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120203153754.10036: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120204061120.10061: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120204061120.10062: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120204061120.10063: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120204061120.10064: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20111109151106.9746: *4* @test htmlScanner.filterTokens
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)
strip = hs.stripTokens
dump  = hs.formatTokens

s1 = '''<table id="1"><table id="2">
<contents/>
</table>
</table>'''

s2 = '<table id="1"><table id="2"><contents/></table></table>'
    
t1 = hs.tokenize(s1)
t2 = hs.tokenize(s2)
f1 = hs.filterTokens(t1)
f2 = hs.filterTokens(t2)

assert strip(f1) == strip(f2),'f1...\n%s\nf2...\n%s' % (
    dump(f1),dump(f2))
    
if 0:
    print(dump(f1))
#@+node:ekr.20111110084957.10092: *4* @test import dataN.html
fn = r'c:\recent\data.html'

# fn = r'c:\recent\data-smaller.html'
# fn = r'c:\recent\data666.html'

# These all pass on data.html:
    # html_tags = ('html','head','body',)
    # html_tags = ('html','head','body','table',)
    # html_tags = ('html','head','body','table','div',)
    # html_tags = ('html','head','body','table','div','script',)
    # html_tags = ('html','head','body','table','div','script','link',)
    # html_tags = ('html','head','body','table','div','script','link','p',)

html_tags = ('html','head','body','table','div','script','p','td','tr',)

# Settings now work when run externally.
setting = 'import_html_tags'
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.cls()

c.importCommands.importFilesCommand(files=[fn], treeType='@file')
#@+node:ekr.20111109105907.9795: *4* @test unicode stuff
@first # -*- coding: utf-8 -*-

table = (
    'test',
    'Ä 궯 奠',
    'Ä 궯 奠 after', # fails with cp6501: after is duplicated.
)

print('*'*20)
print('isPython3: %s' % g.isPython3)

for s in table:
    if g.isPython3:
        s = s.encode('ascii','replace') # create bytes.
    g.es(repr(s))
    g.es(s)
    g.pr ('g.pr(s)       : %s' % s)
    g.pr ('g.pr(repr(s)) : %s' % repr(s))
    print('print(s)      : %s' % s)
    print('print(repr(s)): %s' % s)
#@+node:ekr.20111113064104.9841: *4* @test external text operations
assert g.app.isExternalUnitTest

body = c.frame.body
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl

w = body.bodyCtrl
w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111112131605.9789: *4* @test nullBody text operations
# print('isExternalUnitTest',g.app.isExternalUnitTest)

if g.app.isExternalUnitTest:
    body = c.frame.body
else:
    import leo.core.leoCommands as leoCommands
    import leo.core.leoFrame as leoFrame
    import leo.core.leoGui as leoGui
    
    # Important: external unit tests should execute in this environment.
    nullGui   = leoGui.nullGui('null gui')
    nullFrame = leoFrame.nullFrame(title='nullFrame title',gui=nullGui)
    c2 = leoCommands.Commands(nullFrame,fileName='<empty fileName>')
    nullFrame.c = c2
    body = leoFrame.nullBody(frame=nullFrame,parentFrame=None)
    assert repr(body).startswith('<leo.core.leoFrame.nullBody')

# Now test some basic operations.
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl
w = body.bodyCtrl

w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111115155710.9835: *4* @test g.python_tokenize
# h = 'g.python_tokenize'
# p = p.firstChild()
# assert p.h == h
tokens = g.python_tokenize(p.b,line_numbers=False)

# tokens = [(kind,val) for (kind,val,line_number) in tokens]

# First, the basic check
tokens1 = [val for kind,val in tokens]
s = ''.join(tokens1)
assert p.b == s,repr(s)

if 0:
    for z in tokens:
        kind,val = z
        print('%6s %s' % (kind,repr(val)))
        
# Next, start filtering.
tokens = [(kind,g.choose(kind=='string','"S"',val)) for kind,val in tokens]

if 0: # Delete whitespace.
    tokens = [(kind,val) for (kind,val) in tokens if kind != 'ws']
    tokens = [(kind,g.choose(kind=='id',val+' ',val)) for (kind,val) in tokens]

# Last: stringize.
tokens = [val for kind,val in tokens if kind != 'comment']
# print(''.join(tokens))

if 1: # Print lines containing '='
    s = ''.join(tokens)
    for ch in '()[]{}<>.,:=+-/':
        s = s.replace(' '+ch,ch)
    aList = [z for z in g.splitLines(s)
        if z.find('=') > -1] # and not z.find('+=')>-1 and not z.find('-=')>-1]
    print(''.join(aList))
    
#@+node:ekr.20111204110514.10287: *4* @test p.moveToFirst/LastChild
def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()

child = p.firstChild()
assert child
setup(child)
p2 = child.insertAfter()
p2.h = "test"
try:
    assert c.positionExists(p2),p2
    p2.moveToFirstChildOf(child)
    assert c.positionExists(p2),p2
    p2.moveToLastChildOf(child)
    assert c.positionExists(p2),p2
finally:
    if 1:
        setup(child)
    c.redraw(p)
#@+node:ekr.20111210100047.10306: *5* child
#@+node:ekr.20111116161118.10247: *3* Old lint tests
#@+node:ekr.20111116103733.9845: *4*  Naming tests
# http://docs.python.org/reference/executionmodel.html#naming-and-binding

if 0:
    def test():
        a = b
        b = 1 # UnboundLocalError
        
print('***')
          
def test():
    global g2
    g2 = 4
    def test2():
        print(g2)
    test2()
    g2 = 3
    print(g2)
    
g2 = 'g2'
print(g2)

test()
#@+node:ekr.20111116103733.9846: *5* << define s>>
s = '''



'''

s = g.adjustTripleString(s,-4)
#@+node:ekr.20111116103733.9839: *4* @test create lots of data structures
# A simple prototype of data-centric design.
# 0.023 sec to create 100,000 dicts.
# 0.230 sec to create 1,000,000 dicts.

import time

t1 = time.clock()
n = 1000000

d = {}
for z in range(n):
    d[n] = {'n':n,}

t2 = time.clock()
print('Created %s dicts in %2.3f sec.' % (n,t2-t1))
#@+node:ekr.20111116103733.9844: *4* @test dumper (to outNodes)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outNodes.txt'

outStream = open(out,'w')
u.AstDumper().dumpFileAsNodes(fn,outStream)
#@+node:ekr.20111116103733.9840: *4* @test dumper (to outString)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outString.txt'

outStream = open(out,'w')
u.AstDumper(brief=True).dumpFileAsString(fn,outStream)
#@+node:ekr.20111116103733.9838: *4* @test speed of AstTraverser (one file)
import leo.core.leoGlobals as g
import leo.core.leoInspect as leoInspect
import ast
import time

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
    
t1 = time.clock()
s = open(fn,'r').read()
t2 = time.clock()
tree = ast.parse(s,filename=fn,mode='exec')
t3 = time.clock()
leoInspect.AstTraverser(fn).visit(tree)
t4 = time.clock()

if 1:
    print('read:     %2.3f sec.' % (t2-t1))
    print('parse:    %2.3f sec.' % (t3-t2))
    print('traverse: %2.3f sec.' % (t4-t3))
    print('total:    %2.3f sec.' % (t4-t1))
#@+node:ekr.20111128103520.10237: *3* Tests of @shadow from unitTest.leo
#@+node:ekr.20111128103520.10238: *4* @@shadow ../test/unittest/at-shadow-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10239: *5* spam
def spam():
    pass
#@+node:ekr.20111128103520.10240: *5* eggs
def eggs():
    pass
#@+node:ekr.20111128103520.10241: *4* @@shadow unittest/at-shadow-line-number-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10242: *5* child
def child():
    pass
#@+node:ekr.20111128103520.10243: *4* @test @shadow: shape of tree
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow ../test/unittest/at-shadow-test.py'
    p = g.findNodeAnywhere(c,h)
    assert p
    
    table = (
        (p.firstChild(),'spam'),
        (p.firstChild().next(),'eggs')
    )
    
    assert not p.isDirty(),p.h # Do not ignore this failure!
    
    for p2,h2 in table:
        assert len(p2.h) == len(h2)
#@+node:ekr.20111128103520.10244: *4* @test goto-global-line @shadow
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow unittest/at-shadow-line-number-test.py'
    root1 = g.findNodeAnywhere(c,h)
    assert root1
    assert root1.isAnyAtFileNode()
    
    fileName,lines,n,root2 = c.goToLineNumber(c).setup_file(n=6,p=root1)
    assert fileName == h[8:],'fileName'
    assert root2 == root1
    
    if 0:
        print('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
            root and root.h,isRaw,n,len(lines)))
#@+node:ekr.20111116103733.9818: *3* LeoInspect tests
#@+node:ekr.20111116103733.10672: *4* @test leoInspect with multiple files
import leo.core.leoInspect as inspect

import os

<< define old_s >>
<< define s >>

g.cls()

aList = (
    'leoAtFile.py',
    'leoEditCommands.py',
)
inspect.test(c,aList,print_stats=False,s=None,print_times=True)
#@+node:ekr.20111116103733.10451: *5* << define old_s >>
# import leo.core.leoGlobals
# import leo.core.leoGlobals as g
# from leo.core.leoGlobals import pr as pr2
# from leo.core.leoGlobals import trace

s_old = '''\
import sys

aGlobal = 5
# aGlobal2 is not explicitly defined.

c = [z for z in 'abc']

def myFunc():
    n1,n2,n3,junk,junk=sys.version_info
    a = self.b
    for z in a:
        print(z)
    with A() as a:
        print(a,b)
        
def test():
    a = b # UnboundLocalError.
    b = 1
    c = 2 # Any def will do at present.
    print(g)
    print(c.frame.body)
    print(c.frame.body.xxx.yyy)
    print(b.yyy) # no check will be made.
    print(xxx.yyy)
    for c in 'abc':
        print(c,b)
        print(g)


class myClass:
    
    def __init__(self,c):
        self.a = True
        self.b = None
        c.frame.xxxx
        
    def spam(self,a,b,c=5,*args,**keys):
        global aGlobal2
        aGlobal2 = 'abc'
        self.a = b
        self.a = x
        
    def no_self(a):
        pass
        
    def test_lambda(self):
        f = lambda a,b: a

    def test_comprehension(self):
        z2 = [z for z in 'abc']
        
aGlobal3 = 4 # This should be defined everywhere.

def test():
    # a = ','.join(['a','b'])
    p = 5
    # print(p.parent().h)
    # print(g.app.windowList[0])
    print(p)
    print(g)

'''

# import leo.core.leoCommands as leoCommands
#@+node:ekr.20111116103733.10452: *5* << define s >>
s = '''\

import leo.core.leoGlobals as g

def test(c):
    a = 5
    f = c.frame
    c.frame.body.bodyCtrl = w

'''

s = g.adjustTripleString(s,-4)
# print(s)
#@+node:ekr.20111116103733.10450: *5* test
def test(c,files,print_stats=True,s=None,print_times=True):
   
    t1 = time.clock()
    sd = SemanticData(controller=None)

    if s: # Use test string.
        fn = '<test file>'
        InspectTraverser(c,fn,sd,s).traverse(s)
    else:
        for fn in files:
            print(g.shortFileName(fn))
            s = LeoCoreFiles().get_source(fn)
            if s:
                InspectTraverser(c,fn,sd,s).traverse(s)
            else:
                print('file not found: %s' % (fn))
           
    sd.total_time = time.clock()-t1
    
    if print_times: sd.print_times()
    if print_stats: sd.print_stats()
#@+node:ekr.20111116103733.10449: *4* @test leoInspect.module.classes
import leo.core.leoInspect as inspect

dump_modules = False
print_modules = True
print_functions = False
print_stats = False
print_times = True

if dump_modules or print_stats:
    g.cls()

m = inspect.module(c,'leoEditCommands.py',sd=None,
    print_stats=print_stats,print_times=print_times)
    
for o in m.classes():
    if dump_modules:
        o.dump(verbose=False)
    if print_modules:
        print(o)
    if print_functions:
        for f in o.functions:
            print('  %s' % f)
#@+node:ekr.20111116161118.10212: *4* @test leoInspect.module.classes 2
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(c,'leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.classes():
    print(z)
#@+node:ekr.20111116161118.10218: *4* @test leoInspect.module.defs
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(c,'leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.defs():
    print(z)
#@+node:ekr.20111116161118.10181: *4* @test leoInspect.module.statements
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(c,'leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.statements():
    print(z)
#@+node:ekr.20111116161118.10230: *4* @test leoInspect (leoEditCommands.py)
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(fn='leoEditCommands.py')

def show(o):
    print('%-5s %s' % (o.line_number(),o.format()))

var = '.widget'
func = 'w.insert'

if 0:
    
    print('\nAssignments to %s...\n' % (var))
    for o in m.assignments_to(var):
        show(o)
        
    print('\nAssignments using %s...\n' % (var))
    for o in m.assignments_using(var):
        show(o)
        
    print('\nCalls to %s...\n' % (func))
    for o in m.calls_to(func):
        show(o)
        
    if 1:
        classes = m.classes()
        for d in classes[0].defs():
            print('')
            print(d)
            for z in d.statements():
                # print(z.tree())
                # print(z.sd.dump_ast(z.tree()))
                lines = g.splitLines(z.format())
                for line in lines:
                    print('  %s' % (line))
#@+node:ekr.20111127153202.10231: *4* @test speed of AstTraverser (all Leo core files)
import leo.core.leoGlobals as g
import leo.core.leoInspect as inspect
import ast
import time

read_time,parse_time,traverse_time = 0.0,0.0,0.0
t_start = time.clock()
count = 0
for fn in inspect.LeoCoreFiles().files:
    count += 1
    t2 = time.clock()
    s = open(fn,'r').read()
    t3 = time.clock()
    tree = ast.parse(s,filename=fn,mode='exec')
    t4 = time.clock()
    inspect.AstTraverser(fn).visit(tree)
    t5 = time.clock()
    read_time += t3-t2
    parse_time += t4-t3
    traverse_time += t5-t4
t_end = time.clock()
total_time = t_end-t_start
if 1:
    print('files:    %s' % (count))
    print('read:     %2.3f sec.' % (read_time))
    print('parse:    %2.3f sec.' % (parse_time))
    print('traverse: %2.3f sec.' % (traverse_time))
    print('total:    %2.3f sec.' % (total_time))
#@+node:ekr.20111127090852.10227: *4* @test leoInspect (all core files)
import leo.core.leoInspect as inspect
import time

sd = inspect.SemanticData()
start_time = time.clock()

count = 0
for fn in inspect.LeoCoreFiles().files:
    # print(fn)
    m = inspect.module(fn,sd=sd)
    count += 1

end_time = time.clock()
total_time = end_time-start_time

if 1:
    print('files: %s' % (count))
    print('total: %2.3f sec.' % (total_time))
if 1:
    sd.print_stats()
#@+node:ekr.20111117031039.10762: *4* @test leoInspect.module (s)
import leo.core.leoInspect as inspect

g.cls()

def show(o,indent):
    # print('\n%s\n' % o.sd.dump_ast(o.tree()))
    print('%s%s' % (' '*4*indent,o.format()))

<< define s >>
print('Input...\n%s\n' % (s.rstrip()))

m = inspect.module(s=s)

if 1:
    print(show(m,0))

print('\nAssignments to a...\n')
for o in m.assignments_to('a'):
    print(o.format())
    
print('\nAssignments using d...\n')
for o in m.assignments_using('d'):
    print(o.format())
    
print('\nCalls to f...\n')
for o in m.calls_to('f'):
    print(o.format())

if 1:
    for s in m.statements():
        show(s,0)
    
    for f in m.functions():
        show(f,0)
        for z in f.statements():
            show(z,1)
    
    for cls in m.classes():
        show(cls,0)
        for d in cls.defs():
            show(d,1)
            for z in d.statements():
                show(z,1)
#@+node:ekr.20111117031039.10763: *5* << define s >>
s = '''
x.y = b(arg1,arg2=5,*args,**args).c[1:2:3].d
a=b+c
f(a=1,b=2,*args,**keys)
'''


# def outer_function(a,b=99,c=88,*args,**keys):
    # print('hello')
    
# class myClass:
    # def method():
        # pass
    
#@+node:ekr.20111116103733.9838: *4* @test speed of AstTraverser (one file)
import leo.core.leoGlobals as g
import leo.core.leoInspect as leoInspect
import ast
import time

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
    
t1 = time.clock()
s = open(fn,'r').read()
t2 = time.clock()
tree = ast.parse(s,filename=fn,mode='exec')
t3 = time.clock()
leoInspect.AstTraverser(fn).visit(tree)
t4 = time.clock()

if 1:
    print('read:     %2.3f sec.' % (t2-t1))
    print('parse:    %2.3f sec.' % (t3-t2))
    print('traverse: %2.3f sec.' % (t4-t3))
    print('total:    %2.3f sec.' % (t4-t1))
#@+node:ekr.20120116073928.10114: *3* Unit tests for settings
#@+node:ekr.20120126050844.10386: *4* @ignore print dicts unit tests
#@+node:ekr.20120117095916.10124: *5* @test printMenusList
def printMenusList(aList,level=0):
    
    for z in aList:
        a,b,c = z
        print('*** kind',a)
        if type(b) in (type(()),type([])):
            for z2 in b:
                a1,b1,c1 = z2
                if a1.startswith('@menu') and type(b1) in (type(()),type([])):
                    print()
                    print('*** inner menu: %s' % (level+1))
                    print(a1)
                    for z3 in b1:
                        print(z3)
                    if c1: print(c1)
                else:
                    print(z2)
            if c: print(c)
        else:
            print(b)
        print()
        break #
        
printMenusList(c.config.getMenusList())
       
#@+node:ekr.20120117095916.10140: *5* @test printInverseBindingDict
print('\ninverseBindingDict...\n')

d = c.k.computeInverseBindingDict()

for key in sorted(list(d.keys())):

    if 1 == len(d.get(key)):
        print(key,d.get(key))
    else:
        print()
        print(key)
        print(d.get(key))
        print()
#@+node:ekr.20120123113111.10925: *5* @test printBindingsDict
import leo.core.leoConfig as leoConfig # for ShortcutInfo
    
partial = True

d = c.k.bindingsDict
    # Keys are shortcuts; values are *lists* leoConfig.ShortcutInfo objects.
    
print('\nk.bindingsDict%s...\n' % ' (partial)' if partial else '')
    
for key in list(sorted(d.keys())):
    aList = d.get(key,[])
    for b in aList:
        assert isinstance(b,leoConfig.ShortcutInfo)
        if not partial or b.kind != 'leosettings.leo':
            print(b)
#@+node:ekr.20120117095916.10141: *5* @test printMasterBindingsDict
partial = True

panes = ('all','body','button','log','tree','text',
    'command','insert','overwrite',)

d = c.k.masterBindingsDict
    # Keys are scope names (in panes) or mode names.
    # Values are dicts:
        # keys are strokes; values are leoConfig.ShortcutInfo objects.
        
print('\nk.masterBindingsDict%s...\n' % ' (partial)' if partial else '')

for pane in sorted(list(d.keys())):
    kind = 'pane' if pane in panes else 'mode'
    print('%s: %s...' % (kind,pane))
    d2 = d.get(pane)
    for stroke in sorted(list(d2.keys())):
        b = d2.get(stroke)
        if not partial or b.kind != 'leosettings.leo':
            print('%6s %25s %17s %s' % (b.pane,stroke,b.kind,b.commandName))
            assert b.pane == pane
            assert b.stroke == stroke
    print()
#@+node:ekr.20120126080450.10187: *4* @ignore passed
#@+node:ekr.20120126080450.10189: *5* @test mode-related info
@

g.app.config.modeCommandsDict
    Keys are command names: enter-x-mode.
    Values are inner dictionaries:
        Keys are command names, values are lists of ShortcutInfo nodes.
@c

d = g.app.config.modeCommandsDict
    
for key in sorted(d.keys()):
    print('*** mode ***',key)
    d2 = d.get(key)
    for key2 in sorted(d2.keys()):
        aList = d2.get(key2)
        print(key2)
        for si in aList:
            print('   ',si)
#@+node:ekr.20120120095156.10262: *5* @test types of contents of settings dicts
@
ivar                    Keys                Values
----                    ----                ------
c.commandsDict          command names (1)   functions
k.inverseCommandsDict   func.__name__       command names
k.bindingsDict          shortcuts           list of ShortcutInfo objects
k.masterBindingsDict    scope names (2)     inner masterBindingDicts (3)
k.masterGuiBindingsDict strokes             list of widgets in which stoke is bound
k.settingsNameDict (4)  settings.lower()    "Real" Tk specifiers
inverseBindingDict (5)  command names       lists of tuples (pane,key)
modeCommandsDict (6)    command name (7)    inner modeCommandsDicts (8)

Notes:
(1) Command names are minibuffer names (strings)
(2) Scope names are 'all','text',etc.
(3) inner masterBindingDicts: Keys are strokes; values are ShortcutInfo objects.
(4) k.settingsNameDict has no inverse.
(5) inverseBindingDict is **not** an ivar: it is computed by k.computeInverseBindingDict.
(6) A global dict: g.app.gui.modeCommandsDict
(7) enter-x-command
(8) Keys are command names, values are lists of ShortcutInfo objects.
@c

si_type = c.k.ShortcutInfo
disabled_func_type = None # Should be any bound method.
k = c.k

@others

test_dict_of_objects(c.commandsDict,type('s'),disabled_func_type,'commandsDict')
test_dict_of_objects(k.inverseCommandsDict,type('s'),type('s'),'inverseCommandsDict')
test_dict_of_lists(k.bindingsDict,si_type,'bindingsDict')
test_dict_of_dicts(k.masterBindingsDict,si_type,'masterBindingsDict')
test_dict_of_lists(k.masterGuiBindingsDict,None,'masterGuiBindingsDict')
test_dict_of_objects(k.settingsNameDict,type('s'),type('s'),'settingsNameDict')
test_dict_of_lists(k.computeInverseBindingDict(),type(tuple()),'inverseBindingDict')

# Test individual dicts separately.
d = g.app.config.modeCommandsDict
test_dict_of_dicts(d,None,'modeCommandsDict')
for key in sorted(d.keys()):
    d2 = d.get(key)
    test_dict_of_lists(d2,si_type,'inner modeCommandsDict')
        # This requires a hack to special-case the
        # '*entry-commands*' and '*command-prompt*' keys.
#@+node:ekr.20120126080450.10193: *6* test_dict_of_dicts
def test_dict_of_dicts(d,theType,tag):

    assert d,tag

    for key in d.keys():
        d2 = d.get(key)
        assert type(d2) == type({})
        for key in d2.keys():
            obj = d2.get(key)
            if theType:
                assert type(obj) == theType,repr(obj)
#@+node:ekr.20120126080450.10191: *6* test_dict_of_lists
def test_dict_of_lists(d,theType,tag):

    assert d,tag

    for key in d.keys():
        obj = d.get(key)
        if key in ('*entry-commands*','*command-prompt*'):
            # Special case for g.app.config.modeCommandsDict
            assert type(obj)==type([]),repr(obj)
        else:
            assert type(obj) == type([])
            # Don't check types of list elements if theType is None.
            if theType:
                for z in obj:
                    assert type(z)==theType,'key: %s obj: %s' % (key,repr(obj))
#@+node:ekr.20120126080450.10195: *6* test_dict_of_objects
def test_dict_of_objects(d,keyType,valueType,tag):

    assert d,tag

    for key in d.keys():
        assert type(key) == keyType,repr(key)
        obj = d.get(key)
        # Don't check type of obj if valueType is None.
        if valueType:
            assert type(obj) == valueType,'\nobj: %s\nvalueType: %s' % (repr(obj),valueType)
#@+node:ekr.20120126080450.10194: *6* Unused
# import types
# types.ListType does not exist in Python 3.x.
# assert isinstance(aList,list().__class__)
#@+node:ekr.20120127084215.10238: *5* @test merge_settings_dicts
@others

# import os ; os.system('cls')
    
d1 = g.app.config.immutable_leo_settings_shortcuts_dict
d2 = g.app.config.immutable_my_leo_settings_shortcuts_dict
d3 = g.app.config.merge_settings_dicts(d1,d2)

if False:
    patterns = (
        'backward-find-character-extend-selection',
    )
    for pattern in patterns:
        print(dump_dict(d1,pattern,tag='d1'))
        print(dump_dict(d2,pattern,tag='d2'))
        print(dump_dict(d3,pattern,tag='d3'))

test(d1,d2,d3)
#@+node:ekr.20120127145909.10227: *6* dump & dump_dict (@test merge_settings_dicts)
def dump(aList,pattern=None,tag=None):
    
    return '\n'.join([repr(z) for z in aList])
    

def dump_dict(d,pattern=None,tag=None):
    
    result = [] # '\ndump of %s...' % (tag)
    
    for key in d.keys():
        if pattern in (key,None):
            result.append(key)
            aList = d.get(key)
            for z in aList:
                result.append('    %s' % (z))
                
    return '\n'.join(result)
#@+node:ekr.20120127084215.10239: *6* test (@test merge_settings_dicts)
def test(old_d,new_d,result_d):
    
    '''Test that result_d is the result of upating old_d with new_d.
    
    This test is tricky: only inverted dicts have ShortcutInfo nodes as keys.'''
    
    invert,uninvert = g.app.config.invert,g.app.config.uninvert

    # Compute the inversions of all the dicts.
    inv_old,inv_new,inv_res = invert(old_d),invert(new_d),invert(result_d)
    
    # Part 1: Ensure we test all keys.
    keys = list(inv_old.keys())
    keys.extend(list(inv_new.keys()))
    keys.extend(list(inv_res.keys()))
    keys = sorted(list(set(keys)))
    assert None not in keys
    for key in inv_old.keys(): assert key in keys,key
    for key in inv_new.keys(): assert key in keys,key
    for key in inv_res.keys(): assert key in keys,key
    
    # Part 2: Carefully test the inverted result.
    def si_name_key(si): return si.commandName or ''

    for key in keys:
        # Compute the *sorted* list of 
        res_list = sorted(inv_res.get(key,[]),key=si_name_key)
        old_list = sorted(inv_old.get(key,[]),key=si_name_key)
        new_list = sorted(inv_new.get(key,[]),key=si_name_key)
        assert res_list,'no res_list.get(%s)' % (key)
        # if new_list: print(key,dump(new_list))
        if new_list:
            assert new_list == res_list,'key %s\nnew:\n%s\nres:\n%s' % (
                key,dump(new_list),dump(res_list))
        else:
            assert old_list == res_list,'key %s\nold:\n%s\nres:\n%s' % (
                key,dump(old_list),dump(res_list))
    
    # Part 3: Test that result_d == uninvert(invert(result_d)).
    # A.  They must have the same keys.
    unv_res = uninvert(inv_res)
    assert sorted(list(result_d.keys())) == sorted(list(unv_res.keys()))

    # B. The values of for each key must match after being sorted.
    def si_stroke_key(si): return si.stroke or ''
        
    for key in sorted(result_d.keys()):
        res_list = sorted(result_d.get(key,[]),key=si_stroke_key)
        unv_list = sorted( unv_res.get(key,[]),key=si_stroke_key)
        assert res_list == unv_list,'key %s\nres:\n%s\nunv:\n%s' % (
            key,dump(res_list),dump(unv_list))
   
#@+node:ekr.20120203153754.10032: *5* @test KeyStroke
ks = c.k.KeyStroke

@others

a1 = ks('a')
a2 = ks('a')
b1 = ks('b')
assert a1 == a2
d = {}
d[a1] = a1.s
d[a2] = a2.s
d[b1] = b1.s

for key in sorted(d):
    print(key,d.get(key))
#@+node:ekr.20120205022040.17748: *5* @test g.TypedDict
d = g.TypedDictOfLists('ks',type('s'),type(9))
d.add('a',1)
d.add('a',2)
d.add('b',3)

print(d)
for s in sorted(d.keys()):
    print(s,d.get(s,[]))

print('after replace...')
d.replace('a',[8,9,10])

for s in sorted(d.keys()):
    print(s,d.get(s,[]))
#@+node:ekr.20120215062153.14233: *3* @mark-for-unit-tests
#@+node:ekr.20080412053100.5: *4* @settings
#@+node:ekr.20080412053100.4: *5* @bool fixedWindow = False
#@+node:ekr.20100902154544.5872: *5* @bool enable-abbreviations = True
#@+node:ekr.20111123042248.12701: *5* @enabled-plugins
# Leo loads plugins in the order they appear here.

# Highly-recommended plugins:

plugins_menu.py
free_layout.py # needs to be early
viewrendered.py
mod_scripting.py
#@+node:ekr.20111031081007.9985: *5* @shortcuts
run-selected-unit-tests-externally = Alt-4 # Standard binding, unchanged.
run-marked-unit-tests-externally = Alt-5
run-marked-unit-tests-locally = Alt-6
#@+node:ekr.20110621074459.14908: ** 4.10
#@+node:ekr.20120304065838.15590: *3* Features
#@+node:ekr.20120301053039.15579: *4* Instant abbreviations (~a)
@nocolor-node

Rev 5051 contains a *major* improvement in Leo's abbreviation code.
It is simpler, and more general than before.

The downside is that you will likely have to revise your
abbreviations.  I believe the extra work will be well worthwhile.

Here are the changes:

1. Abbreviations may consist of *any* sequence of characters,
including whitespace or "special" characters. You may include
whitespace characters in definitions using the '\t' and '\n' escapes.
However, whitespace may only appear at the *end* of definitions.

2. You must take care to disambiguate abbreviations if one is a prefix
of another.

Here is an example of both points.  As always, you define
abbreviations in the body of an @global-abbreviation node or
@abbreviation node::

    nc =@nocolor\n
    nc\n=@nocolor\n
    nc\t=@nocolor\n

    ncn=@nocolor-node\n

As you can see, the definitions uses whitespace at the end
of the definition of "nc" to prevent it from being expanded
when typing "ncn".

3. The reason I call these abbreviations "instant" is that they can be
triggered on *any* keystroke, not just the end of a "word".  This
allows you to define::

    teh=the

Hurray!

4. Two rules limit scans.  They are useful and shouldn't cause
hardships.

A.  The backspace and delete characters *never* trigger substitutions.

B. The scan for definitions ends at the first newline
character. Therefore, whitespace will have effect only at
the *end* of a definition.

**Important**: these rules can cause problems when *defining*
abbreviations:  it's easy to trigger an unwanted definition.  The
solution is to use rule 4B:

I want to type::

    ncn=@nocolor-node\n

But I **cant** type this directly if nc is already defined!  The trick
is to type::

   nxcn=@nocolor-node\n

and then delete the leading x with a backspace character.

Of course, you could also turn abbrevions off while defining abbreviations...

Instant abbreviations solve the problems with Brazilian
keyboards. Just define::

    ~a=ã
    ~A=Ã
    etc.

This works regardless of keyboard, regardless of OS, etc.
You might want to define::

    ~\a=~a
    ~\A=~A

in the somewhat unlikely event that you want to type ~a rather than,
say, ~+a.  Of course, you don't need these, provided you remember to
type ~xa <Right><Delete> :-)
#@+node:ekr.20050920084036.27: *5* expandAbbrev
def expandAbbrev (self,event,stroke):

    '''Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.

    Words start with '@'.
    '''

    trace = False and not g.unitTesting
    k = self.k ; c = self.c
    ch = event and event.char or ''
    w = self.editWidget(event,forceFocus=False)
    if not w: return False
    if w.hasSelection(): return False
    
    assert g.isStrokeOrNone(stroke)

    if stroke in ('BackSpace','Delete'):
        if trace: g.trace(stroke)
        return False

    d = {'Return':'\n','Tab':'\t','space':' ','underscore':'_'}
    if stroke:
        ch = d.get(stroke.s,stroke.s)
        if len(ch) > 1:
            if (stroke.find('Ctrl+') > -1 or
                stroke.find('Alt+') > -1 or
                stroke.find('Meta+') > -1
            ):
                ch = ''
            else:
                ch = event and event.char or ''
    else:
        ch = event.char
        
    if trace: g.trace('ch',repr(ch),'stroke',repr(stroke))
    
    # New code allows *any* sequence longer than 1 to be an abbreviation.
    # Any whitespace stops the search.
    s = w.getAllText()
    j = w.getInsertPoint()
    i = j-1
    while len(s) > i >= 0 and s[i] not in ' \t\n':
        prefix = s[i:j]
        word = prefix+ch
        val,tag = self.abbrevs.get(word,(None,None))
        if trace: g.trace(repr(word),val,tag)
        if val:
            # Require a word match if the abbreviation is itself a word.
            if ch in ' \t\n': word = word.rstrip()
            if word.isalnum() and word[0].isalpha():
                if i == 0 or s[i-1] in ' \t\n':
                    break
                else:
                    i -= 1
            else:
                break
        else: i -= 1
    else:
        return False

    if trace: g.trace('**inserting',repr(val))
    oldSel = j,j
    c.frame.body.onBodyChanged(undoType='Typing',oldSel=oldSel)
    if i != j: w.delete(i,j)
    w.insert(i,val)
    c.frame.body.forceFullRecolor() # 2011/10/21
    c.frame.body.onBodyChanged(undoType='Abbreviation',oldSel=oldSel)

    return True
#@+node:ekr.20100901080826.6001: *5* addAbbrevHelper
def addAbbrevHelper (self,s,tag=''):
    
    '''Enter the abbreviation 's' into the self.abbrevs dict.'''

    if not s.strip(): return

    try:
        d = self.abbrevs
        data = s.split('=')
        # name = data[0].strip()
        # 2012/02/29: Do *not* strip ws, and allow the user to specify ws.
        name = data[0].replace('\\t','\t').replace('\\n','\n')
        val = '='.join(data[1:])
        if val.endswith('\n'): val = val[:-1]
        val = val.replace('\\n','\n')
        old,tag = d.get(name,(None,None),)
        if old and old != val and not g.unitTesting:
            g.es_print('redefining abbreviation',name,
                '\nfrom',repr(old),'to',repr(val))
        d [name] = val,tag
    except ValueError:
        g.es_print('bad abbreviation: %s' % s)
#@+node:ekr.20120304065838.15591: *3* Bugs
#@+node:ekr.20120229094652.15179: *4* Made sure global @command & @button nodes work
#@+node:ekr.20070925144337: *5* doButtons
def doButtons (self,p,kind,name,val):

    '''Handle an @buttons tree.'''

    trace = False and not g.unitTesting
    aList = [] ; c = self.c ; tag = '@button'
    seen = []
    after = p.nodeAfterTree()
    while p and p != after:
        if p.v in seen:
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            seen.append(p.v)
            p.moveToNodeAfterTree()
        else:
            seen.append(p.v)
            if g.match_word(p.h,0,tag):
                # We can not assume that p will be valid when it is used.
                script = g.getScript(c,p,
                    useSelectedText=False,
                    forcePythonSentinels=True,
                    useSentinels=True)
                aList.append((p.h,script),)
            p.moveToThreadNext()

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    if aList:
        g.app.config.atCommonButtonsList.extend(aList)
            # Bug fix: 2011/11/24: Extend the list, don't replace it.
        g.app.config.buttonsFileName = c and c.shortFileName() or '<no settings file>'

    if trace: g.trace(len(aList),c.shortFileName())

    d,key = g.app.config.unitTestDict,'config.doButtons-file-names'
    aList = d.get(key,[])
    aList.append(c.shortFileName())
    d[key] = aList
#@+node:ekr.20080312071248.6: *5* doCommands
def doCommands (self,p,kind,name,val):

    '''Handle an @commands tree.'''

    trace = False and not g.unitTesting
    aList = [] ; c = self.c ; tag = '@command'
    seen = []
    after = p.nodeAfterTree()
    while p and p != after:
        if p.v in seen:
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            seen.append(p.v)
            p.moveToNodeAfterTree()
        else:
            seen.append(p.v)
            if g.match_word(p.h,0,tag):
                # We can not assume that p will be valid when it is used.
                script = g.getScript(c,p,
                    useSelectedText=False,
                    forcePythonSentinels=True,
                    useSentinels=True)
                aList.append((p.h,script),)
            p.moveToThreadNext()

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    if aList:
        g.app.config.atCommonCommandsList.extend(aList)
            # Bug fix: 2011/11/24: Extend the list, don't replace it.
    if trace: g.trace(len(aList),c.shortFileName())
    
    d,key = g.app.config.unitTestDict,'config.doCommands-file-names'
    aList = d.get(key,[])
    aList.append(c.shortFileName())
    d[key] = aList
#@+node:ekr.20120229094652.19497: *4* Fixed Bug 930726:expandNodeAndGoToFirstChild only expands or only goes to first child
https://bugs.launchpad.net/leo-editor/+bug/930726

Bug: If the node is not expanded already, then the position
is left on the parent, not the first child.

Function expandNodeAndGoToFirstChild() is referenced only
once in LeoPyRef.leo. This reference is in table of public
Leo commands.

The node in which expandNodeAndGoToFirstChild() is defined
also contains the definition of function
expandNodeOrGoToFirstChild(). At present these two functions
are equivalent. The comments including the header for the
node imply that they should not be equivalent and that
expandNodeAndGoToFirstChild() is not correctly implemented.
#@+node:ekr.20040930064232.1: *5* expandNodeAnd/OrGoToFirstChild
def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.p

    if p.hasChildren():
        if p.isExpanded():
            c.selectPosition(p.firstChild())
        else:
            c.expandNode()
            # Fix bug 930726
            # expandNodeAndGoToFirstChild only expands or only goes to first child .
            c.selectPosition(p.firstChild())

    c.treeFocusHelper()

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.p
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode() # Calls redraw_after_expand.
        else:
            c.redraw_after_expand(p.firstChild(),setFocus=True)
#@+node:ekr.20111026091322.16494: *4* Fixed Bug 869429 (undo & redo when deleting nodes from contextmenu)
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/869429
Undo and Redo delete from context menu does not redo properly

The fix was to deletenodes_rclick in contextmenu.py.
The fallback position should be c.rootPosition()

===== Original report.

Delete (node) in context_menu (right click on headline) has unexpected undo /
redo effects.

Redo after Undo often fails, but you can Undo again, without the
ReDo taking effect, which mans an extra node is created.

In essence: -1 delete,
+1 Undo (restore node),
0 ReDo (should redelete but does nothing),
+1 Undo

(again) = 1 Should = 0 (delete, undelete, redelete, undo redelete) Deleting a
node through Outline menu works differently and properly. The undo code in the
two delete methods must be different

===== Terry

The undo code in the two delete methods must be different

It's different because the context menu delete can delete multiple
nodes at once.

I wrote the context menu delete, but I don't understand the undo system
that well - it's possible it just doesn't support a redo of something
like this.
#@+node:ekr.20031218072017.1193: *5* c.deleteOutline
def deleteOutline (self,event=None,op_name="Delete Node"):

    """Deletes the selected outline."""

    c = self ; cc = c.chapterController ; u = c.undoer
    p = c.p
    if not p: return

    c.endEditing() # Make sure we capture the headline for Undo.

    if p.hasVisBack(c): newNode = p.visBack(c)
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    if cc: # Special cases for @chapter and @chapters nodes.
        chapter = '@chapter ' ; chapters = '@chapters ' 
        h = p.h
        if h.startswith(chapters):
            if p.hasChildren():
                return cc.note('Can not delete @chapters node with children.')
        elif h.startswith(chapter):
            name = h[len(chapter):].strip()
            if name:
                # Bug fix: 2009/3/23: Make sure the chapter exists!
                # This might be an @chapter node outside of @chapters tree.
                theChapter = cc.chaptersDict.get(name)
                if theChapter:
                    return cc.removeChapterByName(name)

    undoData = u.beforeDeleteNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.doDelete(newNode)
    c.setChanged(True)
    u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    c.redraw(newNode)

    c.validateOutline()
#@+node:ekr.20031218072017.3069: *5* changeAll (leoFind)
def changeAll(self):

    # g.trace('leoFind',g.callers())

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.p
    w = self.s_ctrl
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    u.beforeChangeGroup(current,undoType)
    while 1:
        pos1, pos2 = self.findNextMatch()
        if pos1 is None: break
        count += 1
        self.batchChange(pos1,pos2)
        s = w.getAllText()
        i,j = g.getLine(s,pos1)
        line = s[i:j]
        # self.printLine(line,allFlag=True)
    p = c.p
    u.afterChangeGroup(p,undoType,reportFlag=True)
    g.es("changed:",count,"instances")
    c.redraw(p)
    self.restore(saveData)
#@+node:ekr.20050318085432.6: *5* redoGroup
def redoGroup (self):

    '''Process beads until the matching 'afterGroup' bead is seen.'''

    trace = False and not g.unitTesting
    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
        g.trace(bunch)
    else:
        for z in bunch.items:
            self.setIvarsFromBunch(z)
            if z.redoHelper:
                if trace: g.trace(z.redoHelper.__name__,p.h)
                z.redoHelper() ; count += 1
            else:
                g.trace('oops: no redo helper for %s %s' % (u.undoType,p.h))

    u.groupCount -= 1

    u.updateMarks('new') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty()

    if not g.unitTesting:
        g.es("redo",count,"instances")

    c.selectPosition(p)
    if newSel:
        i,j = newSel
        c.frame.body.setSelectionRange(i,j)
#@+node:ekr.20050318085713: *5* undoGroup
def undoGroup (self):

    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    trace = False and not g.unitTesting
    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0

    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
        g.trace(bunch)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        for z in reversedItems:
            self.setIvarsFromBunch(z)
            if z.undoHelper:
                if trace: g.trace(z.undoHelper.__name__,p.h)
                z.undoHelper() ; count += 1
            else:
                g.trace('oops: no undo helper for %s %s' % (u.undoType,p.h))

    u.groupCount -= 1

    u.updateMarks('old') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.

    if not g.unitTesting:
        g.es("undo",count,"instances")

    c.selectPosition(p)
    if oldSel:
        i,j = oldSel
        c.frame.body.setSelectionRange(i,j)
#@+node:ekr.20120303051059.9928: *4* vim and xemacs plugins now work smoothly with contextmenu plugin.
@language rest

- Open contextmenu plugin at first use (not at startup).

- Disable contextmenu dialog for temp files.

Here is the checkin log for rev 5066:

Several changes so that the vim and xemacs plugins work well with contextmenu plugin.

- vim.py and xemacs.py load contextmenu.py if necessary the first time they open a temp file.

- contextmenu.py (edit_node_on_idle) suppresses the "conflicts dialog" if the file's path is in
  [z.get('path') for z in g.app.openWithFiles]

All expected unit tests pass, as do hand tests of the vim and xemacs plugins.

#@+node:ekr.20120304065838.14231: *4* Investigated bug 805288:ctr - tab locks up in log pane
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/805288

If the log tab is active in the log pane ctrl-tab will
toggle through the body, tree and log panes. If any other
tab is active the key combination will freeze in the log
pane.

Note: ctrl-tab could be bound to several things:
    
1. tab-cycle-focus cycles between the tabs representing .leo files.
   It (correctly) always puts focus in the body pane:
       
2. Presumably, this bug refers to either cycle-focus or cycle-all-focus.
   Both work at present.
#@+node:ekr.20120304065838.15587: *4* Fixed bug 823267:when a tab is closed focus may go to a tab other than the visible one
@language rest

https://bugs.launchpad.net/leo-editor/+bug/823267

When tabs are closed with the close tab 'X' on the tab, focus
should go to whichever tab becomes visible, but it doesn't,
it goes to an arbitrary tab which may not be visible. If you
then hit Alt-X expecting to cut the highlighted node in the
visible tab, you cut a node you can't see in a different
commander.

What I did:
    
- Refactored part of g.app.closeLeoWindow into g.app.selectLeoWindow.
- Added the new_c argument to g.app.closeLeoWindow and c.close.
- Changed several event handlers in TabbedFrameFactor so that they
  call g.app.selectLeoWindow as appropriate.

@language python
#@+node:ekr.20031218072017.2833: *5* c.close
def close (self,event=None,new_c=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame,new_c=new_c)
#@+node:ekr.20031218072017.2609: *5* app.closeLeoWindow
def closeLeoWindow (self,frame,new_c=None):

    """Attempt to close a Leo window.

    Return False if the user veto's the close."""

    trace = False and not g.unitTesting
    c = frame.c

    if trace: g.trace(frame.c,g.callers(4))

    c.endEditing() # Commit any open edits.

    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    g.app.recentFilesManager.writeRecentFilesFile(c)
        # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.

    g.doHook("close-frame",c=c)
        # This may remove frame from the window list.

    if frame in g.app.windowList:
        g.app.destroyWindow(frame)

    if g.app.windowList:
        c2 = new_c or g.app.windowList[0].c
        g.app.selectLeoWindow(c2)
       
    elif not g.app.unitTesting:
        g.app.finishQuit()

    return True # The window has been closed.
#@+node:ekr.20120304065838.15588: *5* app.selectLeoWindow
def selectLeoWindow (self,c):
    
    trace = False and not g.unitTesting
    assert c
    if trace: g.trace(c.frame.title)
    
    frame = c.frame
    frame.deiconify()
    frame.lift()
    c.setLog()
    
    master = hasattr(frame.top,'leo_master') and frame.top.leo_master

    if master: # 2011/11/21: selecting the new tab ensures focus is set.
        # frame.top.leo_master is a TabbedTopLevel.
        master.select(c)

    c.bodyWantsFocus()
    c.outerUpdate()
#@+node:ekr.20110605121601.18467: *5* deleteFrame (TabbedFrameFactory)
def deleteFrame(self, wdg):
    
    trace = False and not g.unitTesting
    if not wdg: return

    if wdg not in self.leoFrames:
        # probably detached tab
        self.masterFrame.delete(wdg)
        return
        
    if trace: g.trace('old',wdg.leo_c.frame.title)
        # wdg is a DynamicWindow.
    
    tabw = self.masterFrame
    idx = tabw.indexOf(wdg)
    tabw.removeTab(idx)
    del self.leoFrames[wdg]

    wdg2 = tabw.currentWidget()
    if wdg2:
        if trace: g.trace('new',wdg2 and wdg2.leo_c.frame.title)
        g.app.selectLeoWindow(wdg2.leo_c)
    
    tabw.tabBar().setVisible(
        self.alwaysShowTabs or tabw.count() > 1)
#@+node:ekr.20110605121601.18470: *5* signal handlers (TabbedFrameFactory)
def slotCloseRequest(self,idx):
    
    trace = False and not g.unitTesting
    tabw = self.masterFrame
    w = tabw.widget(idx)
    f = self.leoFrames[w]
    c = f.c
    if trace: g.trace(f.title)
    c.close(new_c=None)
        # 2012/03/04: Don't set the frame here.
        # Wait until the next slotCurrentChanged event.
        # This keeps the log and the QTabbedWidget in sync.

def slotCurrentChanged(self, idx):

    # Two events are generated, one for the tab losing focus,
    # and another event for the tab gaining focus.
    trace = False and not g.unitTesting
    tabw = self.masterFrame
    w = tabw.widget(idx)
    f = self.leoFrames.get(w)
    if f:
        if trace: g.trace(f.title)
        tabw.setWindowTitle(f.title)
        g.app.selectLeoWindow(f.c)
            # 2012/03/04: Set the frame now.
#@+node:ekr.20120304214900.9938: *4* Fixed bug 917814: Switching Log Pane tabs is done incompletely
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/917814

Switching Log Pane tabs is not done cleanly and completely. To see this do the following:

1) Start Leo-Editor
2) Shift-Ctrl-F. This brings the Nav tab to the foreground and
   leaves the focus in the search string field of the Nav pane.
3) Click on the Log tab of the Log pane.
4) Ctrl-A. This causes the following messags to be displayed in the Log tab of the Log pane:

exception executing command
Traceback (most recent call last):
  File "/home/bob/bzrWork/trunk/leo/core/leoCommands.py", line 419, in doCommand
    val = command(event)
  File "/home/bob/bzrWork/trunk/leo/core/leoEditCommands.py", line 5755, in selectAllText
    return w.selectAllText()
  File "/home/bob/bzrWork/trunk/leo/core/leoFrame.py", line 168, in selectAllText
    def selectAllText (self,insert=None): self.widget and self.widget.selectAllText(insert)
AttributeError: 'LeoQuickSearchWidget' object has no attribute 'selectAllText'


That is, it appears that the focus is on the Log tab and the
intention is to select-all in the log tab, but Leo-Editor
tries to select-all in the Nav pane.

Strangely, doing a Ctrl-A in the Nav tab of the Log pane
seems to do nothing---no errors, no select.

-------
Ubuntu 11.10 with Fluxbox window manager
Leo Log Window
Leo 4.9.1 devel, build 4928, 2012-01-14 11:27:18
Python 2.7.2, qt version 4.7.3
linux2
setting leoID from os.getenv('USER'): 'bob'
load dir: /home/bob/bzrWork/trunk/leo/core
global config dir: /home/bob/bzrWork/trunk/leo/config
home dir: /home/bob
reading settings in /home/bob/bzrWork/trunk/leo/config/leoSettings.leo
reading settings in /home/bob/.leo/myLeoSettings.leo
reading settings in /home/bob/.leo/workbook.leo
reading: /home/bob/.leo/workbook.leo
#@+node:ekr.20110605121601.18331: *5* selectTab & helper (leoQtLog)
def selectTab (self,tabName,createText=True,widget=None,wrap='none'):
    # createText is used by leoLog.selectTab.

    '''Create the tab if necessary and make it active.'''

    trace = False and not g.unitTesting
    c = self.c ; w = self.tabWidget
    
    if trace: g.trace(tabName,g.callers())

    # Step 1: See if the tab exits.
    ok = self.selectHelper(tabName)
    if ok: return

    # Step 2: create tab if necessary.
    self.createTab(tabName,widget=widget,wrap=wrap)
    self.selectHelper(tabName)
#@+node:ekr.20110605121601.18332: *6* selectHelper (leoQtLog)
def selectHelper (self,tabName):

    trace = False and not g.unitTesting
    c,w = self.c,self.tabWidget

    for i in range(w.count()):
        if tabName == w.tabText(i):
            w.setCurrentIndex(i)
            
            widget = w.widget(i)
            
            # 2011/11/21: Set the .widget ivar only if there is a wrapper.
            wrapper = hasattr(widget,'leo_log_wrapper') and widget.leo_log_wrapper
            if wrapper:
                self.widget = wrapper
            if trace: g.trace(tabName,'widget',widget,'wrapper',wrapper)
            
            # Do *not* set focus here!
                # c.widgetWantsFocus(tab_widget)

            if tabName == 'Spell':
                # the base class uses this as a flag to see if
                # the spell system needs initing
                self.frameDict['Spell'] = widget
                
            self.tabName = tabName # 2011/11/20
            return True
    else:
        self.tabName = None # 2011/11/20
        if trace: g.trace('** not found',tabName)
        return False
#@+node:ekr.20120304214900.9940: *5* Event handler (leoQtLog)
def onCurrentChanged(self,idx):
    
    trace = False and not g.unitTesting

    tabw = self.tabWidget
    w = tabw.widget(idx)
    
    # Fixes bug 917814: Switching Log Pane tabs is done incompletely
    wrapper = hasattr(w,'leo_log_wrapper') and w.leo_log_wrapper
    if wrapper: self.widget = wrapper
        
    if trace: g.trace(idx,tabw.tabText(idx),wrapper)
#@+node:ekr.20110605121601.18312: *5* class leoQtLog (leoLog)
class leoQtLog (leoFrame.leoLog):

    """A class that represents the log pane of a Qt window."""

    @others
#@+node:ekr.20110605121601.18313: *6* leoQtLog Birth
#@+node:ekr.20110605121601.18314: *7* leoQtLog.__init__
def __init__ (self,frame,parentFrame):

    # g.trace('(leoQtLog)',frame,parentFrame)

    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)

    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    # self.logCtrl = None # The text area for log messages.
        # logCtrl is now a property of the base leoLog class.

    self.contentsDict = {} # Keys are tab names.  Values are widgets.
    self.eventFilters = [] # Apparently needed to make filters work!
    self.logDict = {} # Keys are tab names text widgets.  Values are the widgets.
    self.menu = None # A menu that pops up on right clicks in the hull or in tabs.

    self.tabWidget = tw = c.frame.top.leo_ui.tabWidget
        # The Qt.QTabWidget that holds all the tabs.
    
    # Fixes bug 917814: Switching Log Pane tabs is done incompletely.
    tw.connect(tw,QtCore.SIGNAL('currentChanged(int)'),self.onCurrentChanged)

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),True,False)

    if 0: # Not needed to make onActivateEvent work.
        # Works only for .tabWidget, *not* the individual tabs!
        theFilter = leoQtEventFilter(c,w=tw,tag='tabWidget')
        tw.installEventFilter(theFilter)

    self.setFontFromConfig()
    self.setColorFromConfig()
#@+node:ekr.20110605121601.18315: *7* leoQtLog.finishCreate
def finishCreate (self):

    c = self.c ; log = self ; w = self.tabWidget

    # Remove unneeded tabs.
    for name in ('Tab 1','Page'):
        for i in range(w.count()):
            if name == w.tabText(i):
                w.removeTab(i)
                break

    # Rename the 'Tab 2' tab to 'Find'.
    for i in range(w.count()):
        if w.tabText(i) in ('Find','Tab 2'):
            w.setTabText(i,'Find')
            self.contentsDict['Find'] = w.currentWidget()
            break

    # Create the log tab as the leftmost tab.
    # log.selectTab('Log')
    log.createTab('Log')
    logWidget = self.contentsDict.get('Log')
    logWidget.setWordWrapMode(
        g.choose(self.wrap,
            QtGui.QTextOption.WordWrap,
            QtGui.QTextOption.NoWrap))

    for i in range(w.count()):
        if w.tabText(i) == 'Log':
            w.removeTab(i)
    w.insertTab(0,logWidget,'Log')

    c.searchCommands.openFindTab(show=False)
    c.spellCommands.openSpellTab()
#@+node:ekr.20110605121601.18316: *7* leoQtLog.getName
def getName (self):
    return 'log' # Required for proper pane bindings.
#@+node:ekr.20110605121601.18317: *6* Do nothings (leoQtLog)
#@+node:ekr.20110605121601.18318: *7* Config (leoQtLog)
# These will probably be replaced by style sheets.

def configureBorder(self,border):               pass
def configureFont(self,font):                   pass
def getFontConfig (self):                       pass
def setColorFromConfig (self):                  pass
def SetWidgetFontFromConfig (self,logCtrl=None): pass
def saveAllState (self):                        pass
def restoreAllState (self,d):                   pass
#@+node:ekr.20110605121601.18319: *7* Focus & update (leoQtLog)
def onActivateLog (self,event=None):    pass
def hasFocus (self):                    return None
def forceLogUpdate (self,s):            pass
#@+node:ekr.20120304214900.9940: *6* Event handler (leoQtLog)
def onCurrentChanged(self,idx):
    
    trace = False and not g.unitTesting

    tabw = self.tabWidget
    w = tabw.widget(idx)
    
    # Fixes bug 917814: Switching Log Pane tabs is done incompletely
    wrapper = hasattr(w,'leo_log_wrapper') and w.leo_log_wrapper
    if wrapper: self.widget = wrapper
        
    if trace: g.trace(idx,tabw.tabText(idx),wrapper)
#@+node:ekr.20111120124732.10184: *6* isLogWidget (leoQtLog)
def isLogWidget(self,w):
    
    val = w == self or w in list(self.contentsDict.values())
    # g.trace(val,w)
    return val
#@+node:ekr.20110605121601.18321: *6* put & putnl (leoQtLog)
#@+node:ekr.20110605121601.18322: *7* put (leoQtLog)
# All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):

    c = self.c
    if g.app.quitting or not c or not c.exists:
        print('qtGui.log.put fails',repr(s))
        return

    if color:
        color = leoColor.getColor(color,'black')
    else:
        color = leoColor.getColor('black')

    self.selectTab(tabName or 'Log')

    # Note: this must be done after the call to selectTab.
    w = self.logCtrl.widget
        # w is a QTextBrowser

    if w:
        sb = w.horizontalScrollBar()
        pos = sb.sliderPosition()
        # g.trace(pos,sb,g.callers())
        s=s.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
        if not self.wrap: # 2010/02/21: Use &nbsp; only when not wrapping!
            s = s.replace(' ','&nbsp;')
        s = s.rstrip().replace('\n','<br>')
        s = '<font color="%s">%s</font>' % (color,s)
        w.append(s)
        w.moveCursor(QtGui.QTextCursor.End)
        sb.setSliderPosition(0) # Force the slider to the initial position.
    else:
        # put s to logWaiting and print s
        g.app.logWaiting.append((s,color),)
        if g.isUnicode(s):
            s = g.toEncodedString(s,"ascii")
        print(s)
#@+node:ekr.20110605121601.18323: *7* putnl (leoQtLog)
def putnl (self,tabName='Log'):

    if g.app.quitting:
        return

    if tabName:
        self.selectTab(tabName)

    w = self.logCtrl.widget
    
    if w:
        sb = w.horizontalScrollBar()
        pos = sb.sliderPosition()
        # Not needed!
            # contents = w.toHtml()
            # w.setHtml(contents + '\n')
        w.moveCursor(QtGui.QTextCursor.End)
        sb.setSliderPosition(pos)
        w.repaint() # Slow, but essential.
    else:
        # put s to logWaiting and print  a newline
        g.app.logWaiting.append(('\n','black'),)
#@+node:ekr.20110605121601.18324: *6* Tab (leoQtLog)
#@+node:ekr.20110605121601.18325: *7* clearTab
def clearTab (self,tabName,wrap='none'):

    w = self.logDict.get(tabName)
    if w:
        w.clear() # w is a QTextBrowser.
#@+node:ekr.20110605121601.18326: *7* createTab (leoQtLog)
def createTab (self,tabName,widget=None,wrap='none'):
    """ Create a new tab in tab widget

    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """

    trace = False and not g.unitTesting
    c = self.c
    
    if trace: g.trace(tabName,widget and g.app.gui.widget_name(widget) or '<no widget>')

    if widget is None:

        widget = LeoQTextBrowser(parent=None,c=c,wrapper=self)
            # widget is subclass of QTextBrowser.
        contents = leoQTextEditWidget(widget=widget,name='log',c=c)
            # contents a wrapper.
        widget.leo_log_wrapper = contents
            # Inject an ivar into the QTextBrowser that points to the wrapper.
            
        if trace: g.trace('** creating',tabName,'self.widget',contents,'wrapper',widget)
        
        widget.setWordWrapMode(
            g.choose(self.wrap,
                QtGui.QTextOption.WordWrap,
                QtGui.QTextOption.NoWrap))

        widget.setReadOnly(False) # Allow edits.
        self.logDict[tabName] = widget
        if tabName == 'Log':
            self.widget = contents # widget is an alias for logCtrl.
            widget.setObjectName('log-widget')

        if True: # 2011/05/28.
            # Set binding on all text widgets.
            theFilter = leoQtEventFilter(c,w=self,tag='log')
            self.eventFilters.append(theFilter) # Needed!
            widget.installEventFilter(theFilter)
            
        if True and tabName == 'Log':
    
            assert c.frame.top.__class__.__name__ == 'DynamicWindow'
            find_widget = c.frame.top.leo_find_widget
            
            # 2011/11/21: A hack: add an event filter.
            find_widget.leo_event_filter = leoQtEventFilter(c,w=widget,tag='find-widget')
            find_widget.installEventFilter(find_widget.leo_event_filter)
            if trace: g.trace('** Adding event filter for Find',find_widget)
            
            # 2011/11/21: A hack: make the find_widget an official log widget.
            self.contentsDict['Find']=find_widget
    
        self.contentsDict[tabName] = widget
        self.tabWidget.addTab(widget,tabName)
    else:
        contents = widget
            # Unlike text widgets, contents is the actual widget.
        widget.leo_log_wrapper = contents
            # The leo_log_wrapper is the widget itself.
        if trace: g.trace('** using',tabName,widget)
        
        if 1: # Now seems to work.
            theFilter = leoQtEventFilter(c,w=contents,tag='tabWidget')
            self.eventFilters.append(theFilter) # Needed!
            widget.installEventFilter(theFilter)
    
        self.contentsDict[tabName] = contents
        self.tabWidget.addTab(contents,tabName)

    return contents
#@+node:ekr.20110605121601.18327: *7* cycleTabFocus (leoQtLog)
def cycleTabFocus (self,event=None):

    '''Cycle keyboard focus between the tabs in the log pane.'''
    
    trace = False and not g.unitTesting
    c = self.c
    w = self.tabWidget

    i = w.currentIndex()
    i += 1
    if i >= w.count():
        i = 0

    tabName = w.tabText(i)
    
    self.selectTab(tabName,createText=False)
    if trace: g.trace(i,tabName)

#@+node:ekr.20110605121601.18328: *7* deleteTab
def deleteTab (self,tabName,force=False):

    c = self.c ; w = self.tabWidget

    if force or tabName not in ('Log','Find','Spell'):
        for i in range(w.count()):
            if tabName == w.tabText(i):
                w.removeTab(i)
                break

    self.selectTab('Log')
    c.invalidateFocus()
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18329: *7* hideTab
def hideTab (self,tabName):

    self.selectTab('Log')
#@+node:ekr.20111122080923.10185: *7* orderedTabNames (leoQtLog)
def orderedTabNames (self):
    
    '''Return a list of tab names in the order in which they appear in the QTabbedWidget.'''
    
    w = self.tabWidget

    return [w.tabText(i) for i in range(w.count())]

#@+node:ekr.20110605121601.18330: *7* numberOfVisibleTabs (leoQtLog)
def numberOfVisibleTabs (self):

    return len([val for val in self.contentsDict.values() if val != None])
        # **Note**: the base-class version of this uses frameDict.
#@+node:ekr.20110605121601.18331: *7* selectTab & helper (leoQtLog)
def selectTab (self,tabName,createText=True,widget=None,wrap='none'):
    # createText is used by leoLog.selectTab.

    '''Create the tab if necessary and make it active.'''

    trace = False and not g.unitTesting
    c = self.c ; w = self.tabWidget
    
    if trace: g.trace(tabName,g.callers())

    # Step 1: See if the tab exits.
    ok = self.selectHelper(tabName)
    if ok: return

    # Step 2: create tab if necessary.
    self.createTab(tabName,widget=widget,wrap=wrap)
    self.selectHelper(tabName)
#@+node:ekr.20110605121601.18332: *8* selectHelper (leoQtLog)
def selectHelper (self,tabName):

    trace = False and not g.unitTesting
    c,w = self.c,self.tabWidget

    for i in range(w.count()):
        if tabName == w.tabText(i):
            w.setCurrentIndex(i)
            
            widget = w.widget(i)
            
            # 2011/11/21: Set the .widget ivar only if there is a wrapper.
            wrapper = hasattr(widget,'leo_log_wrapper') and widget.leo_log_wrapper
            if wrapper:
                self.widget = wrapper
            if trace: g.trace(tabName,'widget',widget,'wrapper',wrapper)
            
            # Do *not* set focus here!
                # c.widgetWantsFocus(tab_widget)

            if tabName == 'Spell':
                # the base class uses this as a flag to see if
                # the spell system needs initing
                self.frameDict['Spell'] = widget
                
            self.tabName = tabName # 2011/11/20
            return True
    else:
        self.tabName = None # 2011/11/20
        if trace: g.trace('** not found',tabName)
        return False
#@+node:ekr.20110605121601.18333: *6* leoQtLog color tab stuff
def createColorPicker (self,tabName):

    g.es('color picker not ready for qt',color='blue')
#@+node:ekr.20110605121601.18334: *6* leoQtLog font tab stuff
#@+node:ekr.20110605121601.18335: *7* createFontPicker
def createFontPicker (self,tabName):

    log = self
    QFont = QtGui.QFont
    font,ok = QtGui.QFontDialog.getFont()
    if not (font and ok): return

    style = font.style()
    table = (
        (QFont.StyleNormal,'normal'),
        (QFont.StyleItalic,'italic'),
        (QFont.StyleOblique,'oblique'))
    for val,name in table:
        if style == val:
            style = name ; break
    else: style = ''

    weight = font.weight()
    table = (
        (QFont.Light,'light'),
        (QFont.Normal,'normal'),
        (QFont.DemiBold,'demibold'),
        (QFont.Bold	,'bold'),
        (QFont.Black,'black'))
    for val,name in table:
        if weight == val:
            weight = name ; break
    else: weight = ''

    table = (
        ('family',str(font.family())),
        ('size  ',font.pointSize()),
        ('style ',style),
        ('weight',weight),
    )

    for key,val in table:
        if val:
            g.es(key,val,tabName='Fonts')
#@+node:ekr.20110605121601.18336: *7* createBindings (fontPicker)
def createBindings (self):
    
    pass
#@+node:ekr.20110605121601.18337: *7* getFont
def getFont(self,family=None,size=12,slant='roman',weight='normal'):

    return g.app.config.defaultFont
#@+node:ekr.20110605121601.18338: *7* setFont
def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):

    pass
#@+node:ekr.20110605121601.18339: *7* hideFontTab
def hideFontTab (self,event=None):

    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@+node:ekr.20111026091322.16496: *4* Investigated Bug 844953: copy-clone-pasted node appears in other tab
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/844953

1. Open two empty files with the LEO revision 4451/trunk using the qttabs GUI and save them both.
2. Create a new node and write "Abc" in its head.
3. Select "Copy Node" from the outline menu.
4. Select "Paste Node As Clone" from the outline menu:
   Node is not inserted as clone, but inserted as a copy in the second file/tab.

Sometimes even a standard Copy-Paste action results in the node being inserted in the other file.


===== EKR: It's working for me.

It may be an Ubuntu Unity issue. If so, it will likely be
hard to fix. I haven't got time for such nonsense now. Any
fix will have to wait.

#@+node:ekr.20031218072017.1548: *5* c.Cut & Paste Outlines
#@+node:ekr.20031218072017.1549: *6* c.cutOutline
def cutOutline (self,event=None):

    '''Delete the selected outline and send it to the clipboard.'''

    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline("Cut Node")
        c.recolor()
#@+node:ekr.20031218072017.1550: *6* c.copyOutline
def copyOutline (self,event=None):

    '''Copy the selected outline to the clipboard.'''

    # Copying an outline has no undo consequences.
    c = self
    c.endEditing()
    s = c.fileCommands.putLeoOutline()
    g.app.gui.replaceClipboardWith(s)
#@+node:ekr.20031218072017.1551: *6* c.pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    '''Paste an outline into the present outline from the clipboard.
    Nodes do *not* retain their original identify.'''

    trace = True and not g.unitTesting
    c = self
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
        
    vnodeInfoDict = c.computeVnodeInfoDict() if pasteAsClone else {}
    
    # create a *position* to be pasted.
    if isLeo:
        pasted = c.fileCommands.getLeoOutlineFromClipboard(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,c.p)

    if not pasted: return None
    
    if pasteAsClone:
        copiedBunchList = c.computeCopiedBunchList(pasted,vnodeInfoDict)
    else:
        copiedBunchList = []

    undoData = c.undoer.beforeInsertNode(c.p,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)

    c.validateOutline()
    
    
    c.selectPosition(pasted)
    pasted.setDirty()
    c.setChanged(True)

    if 1:
        # This makes no sense: getLeoOutlineFromClipboard already does this.
        # ***But**, we can't change anything significant until we demonstrate the problem!
    
        # paste as first child if back is expanded.
        back = pasted.back()
        #### back = c.p.back()
    
        if back and back.hasChildren() and back.isExpanded():
            # 2011/06/21: fixed hanger: test back.hasChildren().
            pasted.moveToNthChildOf(back,0)
        # c.setRootPosition()

    if pasteAsClone:
        # Set dirty bits for ancestors of *all* pasted nodes.
        # Note: the setDescendentsDirty flag does not do what we want.
        for p in pasted.self_and_subtree():
            p.setAllAncestorAtFileNodesDirty(
                setDescendentsDirty=False)

    c.undoer.afterInsertNode(pasted,undoType,undoData)
    c.redraw(pasted)
    c.recolor()
    
    return pasted # For unit testing.
#@+node:ekr.20050418084539: *7* c.computeVnodeInfoDict
@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of nodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

def computeVnodeInfoDict (self):
    
    c,d = self,{}
    for v in c.all_unique_nodes():
        if v not in d:
            d[v] = g.Bunch(v=v,head=v.h,body=v.b)

    return d
#@+node:ekr.20050418084539.2: *7* c.computeCopiedBunchList
def computeCopiedBunchList(self,pasted,vnodeInfoDict):

    # Create a dict containing only copied vnodes.
    d = {}
    for p in pasted.self_and_subtree():
        d[p.v] = p.v
    
    # g.trace(sorted(list(d.keys())))
    
    aList = []
    for v in vnodeInfoDict:
        if d.get(v):
            bunch = vnodeInfoDict.get(v)
            aList.append(bunch)
    
    return aList
#@+node:EKR.20040610130943: *6* pasteOutlineRetainingClones
def pasteOutlineRetainingClones (self,event=None):

    '''Paste an outline into the present outline from the clipboard.
    Nodes *retain* their original identify.'''

    c = self

    return c.pasteOutline(reassignIndices=False)
#@+node:ekr.20031218072017.4117: *5* defineMenuCallback
def defineMenuCallback(self,command,name,minibufferCommand):
    
    c = self.c

    if minibufferCommand:

        # Create a dummy event as a signal to doCommand.
        event = g.app.gui.create_key_event(c,None,None,None)

        # The first parameter must be event, and it must default to None.
        def minibufferMenuCallback(event=event,self=self,command=command,label=name):
            c = self.c
            return c.doCommand(command,label,event)

        return minibufferMenuCallback

    else:

        # The first parameter must be event, and it must default to None.
        def legacyMenuCallback(event=None,self=self,command=command,label=name):
            c = self.c # 2012/03/04.
            c.check_event(event)
            return c.doCommand(command,label)

        return legacyMenuCallback
#@+node:ekr.20110605121601.18340: *5* class leoQtMenu (leoMenu)
class leoQtMenu (leoMenu.leoMenu):

    @others
#@+node:ekr.20110605121601.18341: *6* leoQtMenu.__init__
def __init__ (self,frame,label):

    assert frame
    assert frame.c

    # Init the base class.
    leoMenu.leoMenu.__init__(self,frame)
    
    self.leo_menu_label = label.replace('&','').lower()

    # called from createMenuFromConfigList,createNewMenu,new_menu,qtMenuWrapper.ctor.
    # g.trace('(leoQtMenu) %s' % (self.leo_menu_label or '<no label!>'))

    self.frame = frame
    self.c = c = frame.c

    self.menuBar = c.frame.top.menuBar()
    assert self.menuBar is not None

    # Inject this dict into the commander.
    if not hasattr(c,'menuAccels'):
        setattr(c,'menuAccels',{})

    if 0:
        self.font = c.config.getFontFromParams(
            'menu_text_font_family', 'menu_text_font_size',
            'menu_text_font_slant',  'menu_text_font_weight',
            c.config.defaultMenuFontSize)
#@+node:ekr.20110605121601.18342: *6* Tkinter menu bindings
# See the Tk docs for what these routines are to do
#@+node:ekr.20110605121601.18343: *7* Methods with Tk spellings
#@+node:ekr.20110605121601.18344: *8* add_cascade (leoQtMenu)
def add_cascade (self,parent,label,menu,underline):

    """Wrapper for the Tkinter add_cascade menu method.

    Adds a submenu to the parent menu, or the menubar."""
    
    # menu and parent are a qtMenuWrappers.
    c = self.c ; leoFrame = c.frame
    n = underline
    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]

    menu.setTitle(label)

    if parent:
        parent.addMenu(menu) # QMenu.addMenu.
    else:
        self.menuBar.addMenu(menu)
        
    label = label.replace('&','').lower()
    menu.leo_menu_label = label

    return menu
#@+node:ekr.20110605121601.18345: *8* add_command (leoQtMenu) (Called by createMenuEntries)
def add_command (self,**keys):

    """Wrapper for the Tkinter add_command menu method."""
    
    trace = False and not g.unitTesting # and label.startswith('Paste')

    c = self.c
    accel = keys.get('accelerator') or ''
    command = keys.get('command')
    commandName = keys.get('commandName')
    label = keys.get('label')
    n = keys.get('underline')
    menu = keys.get('menu') or self
    if not label: return
    
    if trace: g.trace(label)
        # command is always add_commandCallback,
        # defined in c.add_command.

    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    if accel:
        label = '%s\t%s' % (label,accel)

    action = menu.addAction(label)
    
    # 2012/01/20: Inject the command name into the action
    # so that it can be enabled/disabled dynamically.
    action.leo_command_name = commandName

    if command:
        def qt_add_command_callback(label=label,command=command):
            # g.trace(command)
            return command()

        QtCore.QObject.connect(action,
            QtCore.SIGNAL("triggered()"),qt_add_command_callback)
#@+node:ekr.20110605121601.18346: *8* add_separator (leoQtMenu)
def add_separator(self,menu):

    """Wrapper for the Tkinter add_separator menu method."""

    if menu:
        action = menu.addSeparator()
        action.leo_menu_label = '*seperator*'
#@+node:ekr.20110605121601.18347: *8* delete (leoQtMenu)
def delete (self,menu,realItemName='<no name>'):

    """Wrapper for the Tkinter delete menu method."""

    # g.trace(menu)

    # if menu:
        # return menu.delete(realItemName)
#@+node:ekr.20110605121601.18348: *8* delete_range (leoQtMenu)
def delete_range (self,menu,n1,n2):

    """Wrapper for the Tkinter delete menu method."""

    # Menu is a subclass of QMenu and leoQtMenu.

    # g.trace(menu,n1,n2,g.callers(4))

    for z in menu.actions()[n1:n2]:
        menu.removeAction(z)
#@+node:ekr.20110605121601.18349: *8* destroy (leoQtMenu)
def destroy (self,menu):

    """Wrapper for the Tkinter destroy menu method."""

    # if menu:
        # return menu.destroy()
#@+node:ekr.20110605121601.18350: *8* index (leoQtMenu)
def index (self,label):

    '''Return the index of the menu with the given label.'''
    # g.trace(label)

    return 0
#@+node:ekr.20110605121601.18351: *8* insert (leoQtMenu)
def insert (self,menuName,position,label,command,underline=None):

    # g.trace(menuName,position,label,command,underline)

    menu = self.getMenu(menuName)

    if menu and label:
        n = underline or 0
        if -1 > n > len(label):
            label = label[:n] + '&' + label[n:]
        action = menu.addAction(label)
        if command:
            def insert_callback(label=label,command=command):
                command()
            QtCore.QObject.connect(
                action,QtCore.SIGNAL("triggered()"),insert_callback)
#@+node:ekr.20110605121601.18352: *8* insert_cascade (leoQtMenu)
def insert_cascade (self,parent,index,label,menu,underline):

    """Wrapper for the Tkinter insert_cascade menu method."""

    # g.trace(label,menu)

    menu.setTitle(label)
    
    label.replace('&','').lower()
    menu.leo_menu_label = label # was leo_label

    if parent:
        parent.addMenu(menu)
    else:
        self.menuBar.addMenu(menu)
        
    action = menu.menuAction()
    if action:
        action.leo_menu_label = label
    else:
        g.trace('no action for menu',label)

    return menu
#@+node:ekr.20110605121601.18353: *8* new_menu (leoQtMenu)
def new_menu(self,parent,tearoff=False,label=''): # label is for debugging.

    """Wrapper for the Tkinter new_menu menu method."""

    c = self.c ; leoFrame = self.frame

    # g.trace(parent,label)

    # Parent can be None, in which case it will be added to the menuBar.
    menu = qtMenuWrapper(c,leoFrame,parent,label)

    return menu
#@+node:ekr.20110605121601.18354: *7* Methods with other spellings (Qtmenu)
#@+node:ekr.20110605121601.18355: *8* clearAccel
def clearAccel(self,menu,name):

    pass

    # if not menu:
        # return

    # realName = self.getRealMenuName(name)
    # realName = realName.replace("&","")

    # menu.entryconfig(realName,accelerator='')
#@+node:ekr.20110605121601.18356: *8* createMenuBar (Qtmenu)
def createMenuBar(self,frame):

    '''Create all top-level menus.
    The menuBar itself has already been created.'''

    self.createMenusFromTables()
#@+node:ekr.20110605121601.18357: *8* createOpenWithMenu (QtMenu)
def createOpenWithMenu(self,parent,label,index,amp_index):

    '''Create the File:Open With submenu.

    This is called from leoMenu.createOpenWithMenuFromTable.'''

    # Use the existing Open With menu if possible.
    # g.trace(parent,label,index)

    menu = self.getMenu('openwith')

    if not menu:
        menu = self.new_menu(parent,tearoff=False,label=label)
        menu.insert_cascade(parent,index,
            label,menu,underline=amp_index)

    return menu
#@+node:ekr.20110605121601.18358: *8* disable/enableMenu (leoQtMenu) (not used)
def disableMenu (self,menu,name):
    self.enableMenu(menu,name,False)

def enableMenu (self,menu,name,val):
    
    '''Enable or disable the item in the menu with the given name.'''
    
    trace = False and name.startswith('Paste') and not g.unitTesting
    
    if trace: g.trace(val,name,menu)

    if menu and name:
        val = bool(val)
        # g.trace('%5s %s %s' % (val,name,menu))
        for action in menu.actions():
            s = g.toUnicode(action.text()).replace('&','')
            if s.startswith(name):
                action.setEnabled(val)
                break
        else:
            if trace: g.trace('not found:',name)
#@+node:ekr.20110605121601.18359: *8* getMenuLabel
def getMenuLabel (self,menu,name):

    '''Return the index of the menu item whose name (or offset) is given.
    Return None if there is no such menu item.'''

    # At present, it is valid to always return None.
#@+node:ekr.20110605121601.18360: *8* setMenuLabel
def setMenuLabel (self,menu,name,label,underline=-1):

    def munge(s):
        return g.u(s or '').replace('&','')

    # menu is a qtMenuWrapper.
    # g.trace('menu',menu,'name: %20s label: %s' % (name,label))
    if not menu: return

    realName  = munge(self.getRealMenuName(name))
    realLabel = self.getRealMenuName(label)
    for action in menu.actions():
        s = munge(action.text())
        s = s.split('\t')[0]
        if s == realName:
            action.setText(realLabel)
            break
#@+node:ekr.20110605121601.18361: *6* Activate menu commands
def activateMenu (self,menuName):

    '''Activate the menu with the given name'''

    c = self.c
    menu = self.getMenu(menuName)
    # g.trace(menuName,menu)
    if menu:
        top = c.frame.top.leo_ui
        pos = menu.pos() # Doesn't do any good.
        r = top.geometry()
        pt = QtCore.QPoint(r.x()+pos.x(),r.y())
        menu.exec_(pt)
#@+node:ekr.20110605121601.18362: *6* getMacHelpMenu
def getMacHelpMenu (self,table):

    return None
#@+node:ekr.20061031131434.145: *5* k.Master event handlers
#@+node:ekr.20061031131434.105: *6* k.masterCommand & helpers
def masterCommand (self,commandName=None,event=None,func=None,stroke=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = (False or g.trace_masterCommand) and not g.unitTesting
    verbose = True
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    if event: c.check_event(event)

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.

    char = ch = event and event.char or ''
    w = event and event.w
    
    # 2011/10/28: compute func if not given.
    if commandName and not func:
        func = c.commandsDict.get(commandName)
        
    # Important: it is *not* an error for func to be None.
    k.func = func
    commandName = commandName or func and func.__name__ or '<no function>'
    k.funcReturn = None # For unit testing.
    << define specialKeysyms >>
    special = char in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: # Useful.
        g.trace('stroke: %s ch: %s func: %s' % (
            stroke,repr(ch),func and func.__name__))

    if inserted:
        k.setLossage(ch,stroke)

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startRecordingMacro(event)
        # 2011/06/06: Show the key, if possible.
        # return

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return

    if special: # Don't pass these on.
        return

    # if k.regx.iter:
        # try:
            # k.regXKey = char
            # k.regx.iter.next() # EKR: next() may throw StopIteration.
        # except StopIteration:
            # pass
        # return

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event,stroke)
        if expanded: return

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return # (for Tk) 'break'
    elif k.inState():
        return # (for Tk) 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
#@+node:ekr.20061031131434.106: *7* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
#@+node:ekr.20061031131434.110: *7* k.handleDefaultChar
def handleDefaultChar(self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting
    verbose = False

    if trace and verbose:
        g.trace('widget_name',name,'stroke',stroke,'enable alt-ctrl',self.enable_alt_ctrl_bindings)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        # not k.enable_alt_ctrl_bindings and # Old code: this isn't an alt-ctrl key!
        k.ignore_unbound_non_ascii_keys and # Bug fix: 2011/11/23
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
        return # (for Tk) 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return # (for Tk) 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return # (for Tk) 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return # (for Tk) 'break'
    elif name.startswith('log'):
        # Bug fix: 2011/11/21: Because of universal bindings
        # we may not be able to insert anything into w.
        import leo.core.leoFrame as leoFrame
        if issubclass(w.__class__,leoFrame.HighLevelInterface):
            i = w.logCtrl.getInsertPoint()
            if not stroke:
                stroke = event and event.stroke
            if stroke:
                s = stroke.toGuiChar()
                w.logCtrl.insert(i,s)
        else:
            if trace: g.trace('Not a HighLevelInterface object',w)
        return # None
    else:
        # Let the widget handle the event.
        return # None
#@+node:ekr.20061031131434.146: *6* k.masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event):

    '''This is the handler for almost all key bindings.'''
    
    trace = (False or g.trace_masterKeyHandler) and not g.app.unitTesting
    traceGC = g.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True
    
    k,c = self,self.c ; gui = g.app.gui
    c.check_event(event)
    << define vars >>
    
    assert g.isStrokeOrNone(stroke)

    if char in special_keys:
        if trace and verbose: g.trace('char',char)
        return None
    
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:',repr(stroke),'char:',
        repr(event and event.char),
        'ch:',repr(event and event.char),
        'state',state,'state2',k.unboundKeyAction)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if c.macroCommands.recordingMacro:
            c.macroCommands.endMacro()
            return # (for Tk) 'break'
        else:
            return k.masterCommand(commandName='keyboard-quit',
                event=event,func=k.keyboardQuit,stroke=stroke)

    if k.inState():
        if trace: g.trace('   state %-10s %s' % (stroke,state))
        done,val = k.doMode(event,state,stroke)
        if done: return val

    if traceGC: g.printNewObjects('masterKey 2')
            
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key',stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            return k.handleUnboundKeys(event,char,stroke)

    # 2011/02/08: Use getPandBindings for *all* keys.
    si = k.getPaneBinding(stroke,w)
    if si:
        assert g.isShortcutInfo(si),si
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound',stroke,si.func.__name__)
        return k.masterCommand(event=event,
            commandName=si.commandName,func=si.func,stroke=si.stroke)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace: g.trace(' unbound',stroke)
        return k.handleUnboundKeys(event,char,stroke)
#@+node:ekr.20061031131434.147: *7* << define vars >>
w = event and event.widget
char = event and event.char or ''
stroke = event and event.stroke or None
w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@+node:ekr.20061031131434.108: *7* callStateFunction
def callStateFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; val = None 
    ch = event and event.char or ''
    stroke = event and event.stroke or ''

    if trace: g.trace(k.state.kind,'ch',ch,'stroke',stroke,
        'ignore_unbound_non_ascii_keys',k.ignore_unbound_non_ascii_keys)
        
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns',repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@+node:ekr.20091230094319.6244: *7* doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns',repr(val))
        if val == 'do-standard-keys':
            return False,None # 2011/06/17.
        else:
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert g.isShortcutInfo(si),si
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=si.commandName,func=si.func,
                modeName=state,nextMode=si.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            g.warning('unbound key ends mode',stroke) # 2011/02/02
            k.endMode()
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler',handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True,'break'
#@+node:ekr.20091230094319.6240: *7* getPaneBinding
def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    verbose = False
    k = self ; w_name = k.c.widget_name(w)
    # keyStatesTuple = ('command','insert','overwrite')
    state = k.unboundKeyAction
    
    assert g.isStroke(stroke)

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command','insert','overwrite') and state == key or # 2010/02/09
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key,name,stroke,stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si),si
                    table = ('previous-line','next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case',si.commandName)
                    else:
                        if trace: g.trace('key: %7s name: %6s  found %s = %s' % (
                            key,name,repr(si.stroke),si.commandName))
                        return si

    return None
#@+node:ekr.20061031131434.152: *7* handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = (False or g.trace_masterKeyHandler) and not g.app.unitTesting

    # Special case for bindings handled in k.getArg:
        
    assert g.isStroke(stroke)

    if state in ('getArg','full-command'):
        if stroke in ('\b','BackSpace','\r','Linefeed','\n','Return','\t','Tab','Escape',):
            return False
        if k.isFKey(stroke):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si),si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane),si.commandName,stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName,event=event,func=si.func,stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@+node:ekr.20110209083917.16004: *7* isAutoCompleteChar
def isAutoCompleteChar (self,stroke):
    
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''

    k = self ; state = k.unboundKeyAction
    
    assert g.isStrokeOrNone(stroke)
    
    if stroke and state in ('insert','overwrite'):
        for key in (state,'body','log','text','all'):
            d = k.masterBindingsDict.get(key,{})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                    assert g.isShortcutInfo(si),si
                    if si.commandName == 'auto-complete':
                        return True
    return False
#@+node:ekr.20080510095819.1: *7* k.handleUnboundKeys
def handleUnboundKeys (self,event,char,stroke):

    trace = False and not g.unitTesting
    verbose = True
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')
    
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    
    assert g.isStroke(stroke)

    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char),repr(stroke)))

    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode',stroke)
        return None
        
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key',stroke)
        return None

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event=event,stroke=stroke)

    elif (not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char),repr(stroke))
        return None

    elif k.ignore_unbound_non_ascii_keys and (
        len(char) > 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char),repr(stroke))
        return None

    elif (
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore',stroke)
        return None

    else:
        if trace: g.trace('no func',repr(char),repr(stroke))
        return k.masterCommand(event=event,stroke=stroke)
#@+node:ekr.20111102072143.10016: *5* createMasterMenuCallback
def createMasterMenuCallback(self,dynamicMenu,command,commandName):
    
    trace = False and not g.unitTesting
    c = self.c
    
    def setWidget():
        w = c.frame.getFocus()
        if w and sys.platform.startswith('darwin'):
             # 2012/01/11: redirect (MacOS only).
            wname = c.widget_name(w) or ''
            if wname.startswith('head'):
                w = c.frame.tree.edit_widget(c.p)
        return w

    if dynamicMenu:
        if command:
            def masterDynamicMenuCallback (c=c,command=command):
                # 2012/01/07: set w here.
                w = setWidget()
                if trace: g.trace(command.__name__,w) 
                event = g.app.gui.create_key_event(c,None,None,w)
                return c.k.masterCommand(func=command,event=event)
            return masterDynamicMenuCallback
        else:
            g.internalError('no callback for dynamic menu item.')
            def dummyMasterMenuCallback():
                pass
            return dummyMasterMenuCallback
    else:
        def masterStaticMenuCallback (c=c,commandName=commandName):
            # 2011/10/28: Use only the command name to dispatch the command.
            # 2012/01/07: Bug fix: set w here.
            w = setWidget()
            if trace: g.trace(commandName,w,c)
            event = g.app.gui.create_key_event(c,None,None,w)
            return c.k.masterCommand(commandName=commandName,event=event)
        return masterStaticMenuCallback
#@+node:ekr.20110605121601.18460: *5* onAboutToShow & helpers (qtMenuWrapper)
def onAboutToShow(self,*args,**keys):
    
    trace = False and not g.unitTesting ; verbose = True
    name = self.leo_menu_label
    if not name: return

    for action in self.actions():
        commandName = hasattr(action,'leo_command_name') and action.leo_command_name
        if commandName:
            if trace: g.trace(commandName)
            self.leo_update_shortcut(action,commandName)
            self.leo_enable_menu_item(action,commandName)
            self.leo_update_menu_label(action,commandName)
   
#@+node:ekr.20120120095156.10261: *6* leo_enable_menu_item
def leo_enable_menu_item (self,action,commandName):

    func = self.c.frame.menu.enable_dict.get(commandName)

    if action and func:
        val = func()
        # g.trace('%5s %20s %s' % (val,commandName,val))
        action.setEnabled(bool(val))
        
#@+node:ekr.20120124115444.10190: *6* leo_update_menu_label
def leo_update_menu_label(self,action,commandName):
    
    c = self.c
    
    if action and commandName == 'mark':
        action.setText('UnMark' if c.p.isMarked() else 'Mark')
        self.leo_update_shortcut(action,commandName)
            # Set the proper shortcut.
#@+node:ekr.20120120095156.10260: *6* leo_update_shortcut
def leo_update_shortcut(self,action,commandName):
    
    trace = False and not g.unitTesting
    c = self.c ; k = c.k
    
    if action:
        s = action.text()
        parts = s.split('\t')
        if len(parts) >= 2: s = parts[0]
        key,aList = c.config.getShortcut(commandName)
        if aList:
            result = []
            for si in aList:
                assert g.isShortcutInfo(si),si
                # Don't show mode-related bindings.
                if not si.isModeBinding():
                    accel = k.prettyPrintKey(si.stroke)
                    if trace: g.trace('%20s %s' % (accel,si.dump()))
                    result.append(accel)
                    # Break here if we want to show only one accerator.
            action.setText('%s\t%s' % (s,', '.join(result)))
        else:
            action.setText(s)
    else:
        g.trace('can not happen: no action for %s' % (commandName))
#@+node:ekr.20031218072017.1559: *5* fc.getLeoOutlineFromClipboard & helpers
def getLeoOutlineFromClipboard (self,s,reassignIndices=True):

    '''Read a Leo outline from string s in clipboard format.'''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; current = c.p ; check = not reassignIndices
    checkAfterRead = False or c.config.getBool('check_outline_after_read')

    self.initReadIvars() # 2010/02/05

    # Save the hidden root's children.
    children = c.hiddenRootNode.children

    # 2011/12/10: never recreate the gnxDict.
        # self.gnxDict = {}
    
    # 2011/12/12: save and clear gnxDict.
    # This ensures that new indices will be used for all nodes.
    if reassignIndices:
        oldGnxDict = self.gnxDict
        self.gnxDict = {}
    else:
        # Make sure all pasted nodes are entered into the gnxDict.
        x = g.app.nodeIndices
        for v in c.all_unique_nodes():
            index = x.toString(v.fileIndex)
            self.gnxDict[index] = v

    self.usingClipboard = True
    try:
        # This encoding must match the encoding used in putLeoOutline.
        s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)
        if trace: g.trace(s)

        # readSaxFile modifies the hidden root.
        v = self.readSaxFile(
            theFile=None, fileName='<clipboard>',
            silent=True, # don't tell about stylesheet elements.
            inClipboard=True,reassignIndices=reassignIndices,s=s)
        if not v:
            return g.es("the clipboard is not valid ",color="blue")
    finally:
        self.usingClipboard = False

    # Restore the hidden root's children
    c.hiddenRootNode.children = children

    # Unlink v from the hidden root.
    v.parents.remove(c.hiddenRootNode)

    p = leoNodes.position(v)

    # Important: we must not adjust links when linking v
    # into the outline.  The read code has already done that.
    if current.hasChildren() and current.isExpanded():
        if check and not self.checkPaste(current,p):
            return None
        p._linkAsNthChild(current,0,adjust=False)
    else:
        if check and not self.checkPaste(current.parent(),p):
            return None
        p._linkAfter(current,adjust=False)

    if reassignIndices:
        self.gnxDict = oldGnxDict
            # 2011/12/12: restore gnxDict.
        for p2 in p.self_and_subtree():
            v = p2.v
            v.fileIndex = index = g.app.nodeIndices.getNewIndex()
            self.gnxDict[index] = v

    if trace and verbose:
        g.trace('**** dumping outline...')
        c.dumpOutline()

    if checkAfterRead:
        g.trace('checking outline after paste',color='blue')
        c.checkOutline(event=None,verbose=True,unittest=False,full=True)

    c.selectPosition(p)
    self.initReadIvars() # 2010/02/05
    return p

getLeoOutline = getLeoOutlineFromClipboard # for compatibility
#@+node:ekr.20080410115129.1: *6* checkPaste
def checkPaste (self,parent,p):

    '''Return True if p may be pasted as a child of parent.'''

    if not parent: return True

    parents = [z.copy() for z in parent.self_and_parents()]

    for p in p.self_and_subtree():
        for z in parents:
            # g.trace(p.h,id(p.v),id(z.v))
            if p.v == z.v:
                g.es('Invalid paste: nodes may not descend from themselves',color="blue")
                return False

    return True
#@+node:ekr.20031218072017.1551: *5* c.pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    '''Paste an outline into the present outline from the clipboard.
    Nodes do *not* retain their original identify.'''

    trace = True and not g.unitTesting
    c = self
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
        
    vnodeInfoDict = c.computeVnodeInfoDict() if pasteAsClone else {}
    
    # create a *position* to be pasted.
    if isLeo:
        pasted = c.fileCommands.getLeoOutlineFromClipboard(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,c.p)

    if not pasted: return None
    
    if pasteAsClone:
        copiedBunchList = c.computeCopiedBunchList(pasted,vnodeInfoDict)
    else:
        copiedBunchList = []

    undoData = c.undoer.beforeInsertNode(c.p,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)

    c.validateOutline()
    
    
    c.selectPosition(pasted)
    pasted.setDirty()
    c.setChanged(True)

    if 1:
        # This makes no sense: getLeoOutlineFromClipboard already does this.
        # ***But**, we can't change anything significant until we demonstrate the problem!
    
        # paste as first child if back is expanded.
        back = pasted.back()
        #### back = c.p.back()
    
        if back and back.hasChildren() and back.isExpanded():
            # 2011/06/21: fixed hanger: test back.hasChildren().
            pasted.moveToNthChildOf(back,0)
        # c.setRootPosition()

    if pasteAsClone:
        # Set dirty bits for ancestors of *all* pasted nodes.
        # Note: the setDescendentsDirty flag does not do what we want.
        for p in pasted.self_and_subtree():
            p.setAllAncestorAtFileNodesDirty(
                setDescendentsDirty=False)

    c.undoer.afterInsertNode(pasted,undoType,undoData)
    c.redraw(pasted)
    c.recolor()
    
    return pasted # For unit testing.
#@+node:ekr.20050418084539: *6* c.computeVnodeInfoDict
@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of nodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

def computeVnodeInfoDict (self):
    
    c,d = self,{}
    for v in c.all_unique_nodes():
        if v not in d:
            d[v] = g.Bunch(v=v,head=v.h,body=v.b)

    return d
#@+node:ekr.20050418084539.2: *6* c.computeCopiedBunchList
def computeCopiedBunchList(self,pasted,vnodeInfoDict):

    # Create a dict containing only copied vnodes.
    d = {}
    for p in pasted.self_and_subtree():
        d[p.v] = p.v
    
    # g.trace(sorted(list(d.keys())))
    
    aList = []
    for v in vnodeInfoDict:
        if d.get(v):
            bunch = vnodeInfoDict.get(v)
            aList.append(bunch)
    
    return aList
#@-all

# Put this @language after the @all as a kind of permanent unit test.

#@@language python # Override the default .txt coloring.

#@@pagewidth 60
#@-leo
