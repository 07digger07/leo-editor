.. @+leo-ver=5-thin
.. @+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
.. @@language rest

.. @+all
.. @+node:ekr.20131111061547.16464: ** vim project
@language rest

To do: 

- Document: use separate .leo file to test vim (ekr-vim.leo)
- change vim-mode to vim-normal-mode, vim-insert-mode and vim-overwrite-mode.
- vim_dot.
- Simulate a box cursor by always selecting one character.

@language python

https://groups.google.com/forum/#!topic/leo-editor/OSe0_D5tmJQ

http://stackoverflow.com/questions/7325052/can-someone-explain-to-me-why-the-dot-command-is-so-useful-in-vim
.. @+node:ekr.20100113075303.6270: *3* Vim problems (from TL)
# None of these is easily solvable in Leo's present environment.
.. @+node:ekr.20100112051224.6239: *4* Displaying mode help
The "--> mode-help" command has the following issues related to the
display of the "Help" tab:

1. Key label always capitalized.

Vim commands are mapped to both lower-case and upper-case keys but always appear
mapped to upper-case keys within the "Help" tab.

2. Layout of tab's contents.

To improve readability and better support narrow tab cards, display the mode's
label without the "enter-" and "-mode" text and place the key label before the
mode label.

For example, the following entries would change from::
    enter-vi-delete-line-mode d
    enter-vi-delete-to-begin-of-word-mode b
to::
    d : vi-delete-line
    b : vi-delete-to-begin-of-word
.. @+node:ekr.20100112051224.6225: *4* Repeat last cursor movement command
Support the ';' key: repeat the last "To character" or "Find character" command.
.. @+node:ekr.20100113075303.6271: *4* Need mode-oriented bindings
Mapping a number to a command or an @mode node works but can not be used as it
prevents the number from being entered as text while in Vi's insert state.

Binding 'bksp' key to back-char to move back a character in command mode
prevents 'bksp' from deleting characters in text edit mode.
.. @+node:ekr.20080616110054.2: *4* Support vim dot command
The ability to repeat the last editing related command by pressing the period
key is not supported and there is no workaround in place.

Binding keys within nodes:

Some commands can be "easily" repeated by having the command's mode
bind itself to the period key.  This is not currently working.  

Support commands requesting input:

Add companion commands that reuse input.  For example, a zap-to-
character-again command could exist which will reuse the key entered
in the last zap-to-character command.  With this support, the mode
that performs the initial command would assign the period key to a
companion mode that is identical to the initial mode but with the zap-
to-character command replaced by the zap-to-character-again command.

Commands requiring companion commands are:
  zap-to-character
  find-character
  backward-find-character
  (Any others?)

Notes:

- The copy of the character should be saved somewhere that does NOT affect the
  contents of the clipboard.

- The same or a separate storage location can be used for all commands to retain
  a copy of the character entered by the user. It doesn't matter since only the
  last command is assigned to the period key to be re-executed.
.. @+node:ekr.20100112051224.6238: *4* Some commands do not work in headline
Leo functions exist which unconditionally set focus to the body pane
regardless of the active pane.

For example, bracket matching commands ("%" key) do not work within
a node's headline text.  Instead, the command is performed on the
node's body text.

Using the "undo" command (key 'u') to undo a change to a node's headline text
only works correctly after another node has been selected. It appears that
changes made to a node's headline text are not recorded in Leo's change history
until the edited node has lost focus.
.. @+node:ekr.20100112051224.6222: *4* Commands requesting user input
Commands requesting user input must be the last command executed within an @mode
node. This prevents the implementation of commands such as "yank to <character>"
that requires a "copy to clipboard" operation after the "find-character"
command.

======

Maybe we just need more commands...
.. @+node:ekr.20100112051224.6223: *4* Editing node headlines using @mode nodes
Commands modifying or selecting headline text do not work correctly within a
@mode node.

This eliminates accurate implementation of vi's delete/change/substitute/yank
object commands. As a workaround, the commands are currently written to only
select the text. The user must perform the subsequent delete, change,
substitute, and yank.
.. @+node:ekr.20100112051224.6246: *4* Missing commands/features
.. @+node:ekr.20100112051224.6234: *5* Move current line (to screen position)
Vi has a collection of "z<movement>" commands that will move the
current line to the top, middle, and bottom of the screen.  They are
not supported in Leo.
.. @+node:ekr.20100112051224.6235: *5* Move body text up/down
Vi maps keys to scroll the text up/down one line and by half the
number of visible lines.  Leo does not support this.

.. @+node:ekr.20110529115328.18247: *5* Block cursor
Having worked with Tk text canvases more that Qt, there still seem to
be things that it had that have to be worked around as the Qt people
just haven't seen the need for.

One is the block cursor, I giving Leo Vim like functionality, it would
be nice if one where supported, theses new kids just don't understand
something so primitive I guess.
.. @+node:ekr.20110202094848.12568: *5* Named marks
Another is named marks, in Vim you can store a number of cursor
locations, and recall them to jump around in your code.  This was also
useful in filling out templates as each stop could be given a name
mark.  This helped make filling out a template easier as you weren't
stuck in a linear filling in the blanks in a set order, template stops
where linked in rings, you could jump from the last stop back to the
first and make and changes you wanted on a second go round.  Gravity
of marks made things easier to inspect to determine what stops where
used and which ones were being bypassed.

As these things had an actual presence in the text buffer, it going to
be a little harder to come up with a reasonable work around.
.. @+node:ekr.20110115062009.6025: *4* Commands that work differently in Vim
.. @+node:ekr.20100112051224.6236: *5* Two kinds of words
Vi supports two types of words in its commands:

1. Words that consist of only a subset of the character set and
2. words that consist of all characters except the space and tab characters.

Leo's always considers a word to consist of a subset of characters
although some word related commands include different characters
than others.
.. @+node:ekr.20090629183608.8446: *5* Copy/paste/yank/delete
Yank vs. Yank:
Vi's "yank" commands copy the selected text TO the clipboard.
Leo's "yank" commands insert text FROM the clipboard.

copy-text in modes:
Leo's copy-text command does not work within a mode.  As a result,
all "copy to clipboard" capability is being implemented using the
kill-<object> command followed by Leo's "yank" command to put the
text back.

paste-text in modes:
The paste-text command does not work within an @mode node.  Leo's
"yank" command is used instead.

delete-node does not copy node to clipboard:
A copy-node command is issued to copy the node to the clipboard
followed by the delete-node command.
.. @+node:ekr.20100521090440.5887: *4* Generalize minibuffer code
@nocolor-node

From Tom L

This is hardwired for the first parameter.  Things I need to expand
this:

1. put in a variable that cycles through the tabStops

2. In this mock up, you are entering the parameters in the minibuffer,
a more advanced version would collect each keypress and put it in the
body at the current tabStop, a tab would finalize the entry and
advance to the next stop, no text other than the 'help', ends up in
the minibuffer.

Sinc I'm only modifying existing code without real understanding of
what Leo is doing, any guidance would be appreciated.

Tom
.. @+node:ekr.20100112051224.6226: *4* Vim-related: Range prefix to commands/objects (k.getArgs)
The ability to specify a numeric range prefix is not supported. For example,
entering "3dd" will not delete the next three lines and "20G" will not move the
cursor to the 20th line in the file.

The ability to specify a numeric range prefix to an object is not supported. For
example, the "d2fx" command should Delete up to and including the 2nd Found "x"
character.
.. @+node:ekr.20131105122124.16479: *3* vim reference card
@killcolor
.. @+node:ekr.20131105122124.16482: *4*  keys (do not sort!!)
    <BS>        delete the character in front of the cursor
N   <Del>       delete N characters under and after the cursor
    <Del>       delete the character under the cursor
    <Del>       while entering a count: delete last character
    <Down>      recall newer command-line that starts with current command
    <Esc>       abandon command-line (if 'wildchar' is <Esc>, type it twice)
    <Left>      (motion) cursor left
    <Right>     (motion) cursor right
    <S-Down>    recall newer command-line from history
    <S-Left>    (motion) cursor one word left
    <S-Right>   (motion) cursor one word right
    <S-Up>      recall older command-line from history
    <Up>        recall older command-line that starts with current command

N   CTRL-^                  Edit alternate file N (equivalent to ":e #N").
N   CTRL-A                  add N to the number at or after the cursor
N   CTRL-B                  window N pages Backwards (upwards)
    CTRL-B                  (motion?) cursor to beginning of command-line
    CTRL-BREAK              MS-DOS: during searches: interrupt the search
    CTRL-C                  during searches: interrupt the search
N   CTRL-D                  window N lines Downwards (default: 1/2 window)
N   CTRL-E                  window N lines downwards (default: 1)
    CTRL-E                  (motion?) cursor to end of command-line
N   CTRL-F                  (motion) window N pages Forwards (downwards)
    CTRL-G                  show current file name (with path) and cursor position
N   CTRL-I                  (motion) go to Nth newer position in jump list
    CTRL-K {char1} {char2}  enter digraph
    CTRL-L                  Clear and redraw the screen.
N   CTRL-O                  (motion) go to Nth older position in jump list
N   CTRL-R                  redo last N undone changes
    CTRL-R <0-9a-z"%:->     insert contents of register <0-9a-z"%:->
N   CTRL-T                  (motion) Jump back from Nth older tag in tag list
N   CTRL-U                  window N lines Upwards (default: 1/2 window)
    CTRL-U                  remove all characters
    CTRL-V                  highlight blockwise or stop highlighting
    CTRL-V                  start highlighting blockwise   }  highlighted text
    CTRL-V {char}           insert {char} literally
    CTRL-V {number}         enter decimal value of character (up to three digits)
    CTRL-W                  delete the word in front of the cursor
    CTRL-W +                Increase current window height
    CTRL-W -                Decrease current window height
    CTRL-W =                Make all windows equal height
    CTRL-W CTRL-W           Move cursor to window below (wrap)
    CTRL-W CTRL-^           Split window and edit alternate file
    CTRL-W R                Rotate windows upwards
    CTRL-W W                Move cursor to window above (wrap)
    CTRL-W ]                Split window and jump to tag under cursor
    CTRL-W _                Set current window height (default: very high)
    CTRL-W b                Move cursor to bottom window
    CTRL-W c  or :cl[ose]   Make buffer hidden and close window
    CTRL-W f                Split window and edit file name under the cursor
    CTRL-W j                Move cursor to window below
    CTRL-W k                Move cursor to window above
    CTRL-W n  or :new       Create new empty window
    CTRL-W o  or :on[ly]    Make current window only one on the screen
    CTRL-W p                Move cursor to previous active window
    CTRL-W q  or :q[uit]    Quit editing and close window
    CTRL-W r                Rotate windows downwards
    CTRL-W s                Split window into two parts
    CTRL-W t                Move cursor to top window
    CTRL-W x                Exchange current window with next one
N   CTRL-X                  subtract N from the number at or after the cursor
N   CTRL-Y                  window N lines upwards (default: 1)
    CTRL-Z                  Same as ":stop!"
    CTRL-]                  Jump to the tag under cursor, unless changes have been made
    
    0               (motion) to first character in the line (also: <Home> key)
VIS ~               switch case for highlighted text
N   ~               switch case for N characters and advance cursor
N   +               (motion) down N lines, on the first non-blank character (also: CTRL-M and <CR>)
N   _               (motion) down N-1 lines, on the first non-blank character
N   -               (motion) up N lines, on the first non-blank character
N   ,               (motion) repeat the last "f", "F", "t", or "T" N times in opposite direction
N   .               (motion?) repeat last change (with count replaced with N)
N   ;               (motion) repeat the last "f", "F", "t", or "T" N times
N   (               (motion) N sentences backward
N   )               (motion) N sentences forward
N   {               (motion) N paragraphs backward
N   }               (motion) N paragraphs forward
N   |               (motion) to column N (default: 1)
    `"              (motion) go to the position when last editing this file
    '<a-zA-Z0-9[]'"<>>  (motion) same as `, but on the first non-blank in the line
    `<              (motion) go to the start of the (previous) Visual area
    `<0-9>          (motion) go to the position where Vim was last exited
    `<A-Z>          (motion) go to mark <A-Z> in any file
    `<a-z>          (motion) go to mark <a-z> within current file
    `>              (motion) go to the end of the (previous) Visual area
    `[              (motion) go to the start of the previously operated or put text
    `]              (motion) go to the end of the previously operated or put text
    ``              (motion) go to the position before the last jump
N   $               (motion) go to the last character in the line (N-1 lines lower) (also: <End> key)
    ^               (motion) go to first non-blank character in the line
N   %               (motion) goto line N percentage down in the file.  N must be given, otherwise it is the % command.
    %               (motion) find the next brace, bracket, comment, or "#if"/ "#else"/"#endif" in this line and go to its match
    
N   <{motion}       move the lines that are moved over with {motion} one shiftwidth left
N   >{motion}       move the lines that are moved over with {motion} one shiftwidth right
N   <<              move N lines one shiftwidth left
N   >>              move N lines one shiftwidth right

N   #                           (motion) search backward for the identifier under the cursor
N   *                           (motion) search forward for the identifier under the cursor
N   /<CR>                       (motion) repeat last search, in the forward direction
N   /{pattern}[/[offset]]<CR>   (motion) search forward for the Nth occurrence of {pattern}
N   ?<CR>                       (motion) repeat last search, in the backward direction
N   ?{pattern}[?[offset]]<CR>   (motion) search backward for the Nth occurrence of {pattern}

N   @<a-z>          execute the contents of register <a-z> (N times)
N   @@              (motion?) repeat previous @<a-z> (N times)

    "<char>         use register <char> for the next delete, yank, or put

N   [#              (motion) N times back to unclosed "#if" or "#else"
N   [(              (motion) N times back to unclosed '('
N   [*              (motion) N times back to start of comment "/*"
N   [[              (motion) N sections backward, at start of section
N   []              (motion) N sections backward, at end of section
N   [p              (motion?) like P, but adjust indent to current line
N   [{              (motion) N times back to unclosed '{'
N   ]#              (motion) N times forward to unclosed "#else" or "#endif"
N   ])              (motion) N times forward to unclosed ')'
N   ]*              (motion) N times forward to end of comment "*/"
N   ][              (motion) N sections forward, at end of section
N   ]]              (motion) N sections forward, at start of section
N   ]p              (motion?) like p, but adjust indent to current line
N   ]}              (motion) N times forward to unclosed '}'

N   A               append text at the end of the line (N times)
N   B               (motion) N blank-separated WORDS backward
N   C               change to end-of-line (and N-1 more lines)
N   D               delete to end-of-line (and N-1 more lines)
N   E               (motion) forward to the end of the Nth blank-separated WORD
N   F<char>         (motion) to the Nth occurrence of <char> to the left
N   G               (motion) goto line N (default: last line), on the first non-blank character
N   H               (motion?) go to the Nth line in the window, on the first non-blank
N   I               insert text before the first non-blank in the line (N times)
N   J               (motion?) join N-1 lines (delete newlines)
VIS J               (motion?) join the highlighted lines
    K               lookup keyword under the cursor with 'keywordprg' program (default: "man")
    M               (motion?) go to the middle line in the window, on the first non-blank
N   L               (motion?) go to the Nth line from the bottom, on the first non-blank
N   N               (motion) repeat last search, in opposite direction
N   O               open a new line above the current line, append text (N times)
N   P               put a register before the cursor position (N times)
N   R               enter Replace mode (repeat the entered text N times)
N   S               change N lines
N   T<char>         (motion) till before the Nth occurrence of <char> to the left
    U               restore last changed line
VIS U               make highlighted text uppercase
    V               highlight linewise or stop highlighting
    V               start highlighting linewise    }  operator to affect
N   W               (motion) N blank-separated WORDS forward
N   X               delete N characters before the cursor
N   Y               yank N lines
    ZQ              Same as ":q!".
    ZZ              Same as ":x".
N   a               append text after the cursor (N times)
N   b               (motion) N words backward
N   cc              change N lines
N   c{motion}       change the text that is moved over with {motion}
VIS c               change the highlighted text
VIS d               delete the highlighted text
N   dd              delete N lines
N   d{motion}       delete the text that is moved over with {motion}
N   e               (motion) forward to the end of the Nth word
N   f<char>         (motion) to the Nth occurrence of <char> to the right
    g CTRL-G        show cursor column, line, and character position
N   g^              (motion) to first non-blank character in screen line (differs from "^" when lines wrap)
    g~{motion}      switch case for the text that is moved over with {motion}
N   g#              (motion) like "#", but also find partial matches
N   g$              (motion) to last character in screen line (differs from "$" when lines wrap)
N   g*              (motion) like "*", but also find partial matches
N   g0              (motion) to first character in screen line (differs from "0" when lines wrap)
    gD              (motion) goto global declaration of identifier under the cursor
N   gE              (motion) backward to the end of the Nth blank-separated WORD
N   gI              insert text in column 1 (N times)
    gU{motion}      make the text that is moved over with {motion} uppercase
    ga              show ascii value of character under cursor in decimal, hex, and octal
    gd              (motion) goto local declaration of identifier under the cursor
    gf  or ]f       Edit the file whose name is under the cursor
N   ge              (motion) backward to the end of the Nth word
N   gg              (motion) goto line N (default: first line), on the first non-blank character
N   gj              (motion) down N screen lines (differs from "j" when line wraps)
N   gk              (motion) up N screen lines (differs from "k" when line wraps)
N   gq{motion}      format the lines that are moved over with {motion} to 'textwidth' length
N   gs              Goto Sleep for N seconds
    gu{motion}      make the text that is moved over with {motion} lowercase
    gv              start highlighting on previous visual area
N   h               (motion) left (also: CTRL-H, <BS>, or <Left> key)
N   i               insert text before the cursor (N times) (also: <Insert>)
N   j               (motion) down N lines (also: CTRL-J, CTRL-N, <NL>, and <Down>)
N   k               (motion) up N lines (also: CTRL-P and <Up>)
N   l               (motion) right (also: <Space> or <Right> key)
N   n               (motion?) repeat last search
    m<a-zA-Z>       mark current position with mark <a-zA-Z>
N   o               open a new line below the current line, append text (N times)
    o               (motion?) exchange cursor position with start of highlighting
N   p               put a register after the cursor position (N times)
    q               stop recording
    q<A-Z>          record typed characters, appended to register <a-z>
    q<a-z>          record typed characters into register <a-z>
N   r<char>         replace N characters with <char>
N   s               change N characters
N   t<char>         (motion) till before the Nth occurrence of <char> to the right
N   u               undo last N changes
VIS u               make highlighted text lowercase
    v               highlight characters or stop highlighting
    v               start highlighting characters  }  move cursor and use
N   w               (motion) N words forward
N   x               delete N characters under and after the cursor
N   yy              yank N lines 
N   y{motion}       yank the text moved over with {motion} 
VIS y               yank the highlighted text 
    z- or zb        redraw, current line at bottom of window
    z. or zz        redraw, current line at center of window
    z<CR> or zt     redraw, current line at top of window
N   zh              scroll screen N characters to the right
N   zl              scroll screen N characters to the left
.. @+node:ekr.20131108082341.18235: *4* motion keys
    CTRL-B  (motion?) cursor to beginning of command-line
    CTRL-E  (motion?) cursor to end of command-line
    N   .   (motion?) repeat last change (with count replaced with N)
N   [p      (motion?) like P, but adjust indent to current line
N   ]p      (motion?) like p, but adjust indent to current line
    
    <Left>  (motion) cursor left
    <Right> (motion) cursor right
    <S-Left>/<S-Right>  (motion) cursor one word left/right
    
N   CTRL-F  (motion) window N pages Forwards (downwards)
N   CTRL-I  (motion) go to Nth newer position in jump list
N   CTRL-O  (motion) go to Nth older position in jump list
N   CTRL-T  (motion) Jump back from Nth older tag in tag list
    0       (motion) to first character in the line (also: <Home> key)
N   +       (motion) down N lines, on the first non-blank character (also: CTRL-M and <CR>)
N   _       (motion) down N-1 lines, on the first non-blank character
N   -       (motion) up N lines, on the first non-blank character
N   ,       (motion) repeat the last "f", "F", "t", or "T" N times in opposite direction
N   ;       (motion) repeat the last "f", "F", "t", or "T" N times
N   (       (motion) N sentences backward
N   )       (motion) N sentences forward
N   {       (motion) N paragraphs backward
N   }       (motion) N paragraphs forward
N   |       (motion) to column N (default: 1)

    `"                  (motion) go to the position when last editing this file
    '<a-zA-Z0-9[]'"<>>  (motion) same as `, but on the first non-blank in the line
    `<                  (motion?) go to the start of the (previous) Visual area
    `<0-9>              (motion) go to the position where Vim was last exited
    `<A-Z>              (motion) go to mark <A-Z> in any file
    `<a-z>              (motion) go to mark <a-z> within current file
    `>                  (motion) go to the end of the (previous) Visual area
    `[                  (motion) go to the start of the previously operated or put text
    `]                  (motion) go to the end of the previously operated or put text
    ``                  (motion) go to the position before the last jump

N   $       (motion) go to the last character in the line (N-1 lines lower) (also: <End> key)
    ^       (motion) go to first non-blank character in the line
N   %       (motion) goto line N percentage down in the file.  N must be given, otherwise it is the % command.
    %       (motion) find the next brace, bracket, comment, or "#if"/ "#else"/"#endif" in this line and go to its match
    
N   #       (motion) search backward for the identifier under the cursor
N   *       (motion) search forward for the identifier under the cursor
N   /<CR>   (motion) repeat last search, in the forward direction

N   /{pattern}[/[offset]]<CR>   (motion) search forward for the Nth occurrence of {pattern}
N   ?<CR>                       (motion) repeat last search, in the backward direction
N   ?{pattern}[?[offset]]<CR>   (motion) search backward for the Nth occurrence of {pattern}

N   [#      (motion) N times back to unclosed "#if" or "#else"
N   [(      (motion) N times back to unclosed '('
N   [*      (motion) N times back to start of comment "/*"
N   [[      (motion) N sections backward, at start of section
N   []      (motion) N sections backward, at end of section
N   [{      (motion) N times back to unclosed '{'

N   ]#      (motion) N times forward to unclosed "#else" or "#endif"
N   ])      (motion) N times forward to unclosed ')'
N   ]*      (motion) N times forward to end of comment "*/"
N   ][      (motion) N sections forward, at end of section
N   ]]      (motion) N sections forward, at start of section
N   ]}      (motion) N times forward to unclosed '}'

N   B       (motion) N blank-separated WORDS backward
N   E       (motion) forward to the end of the Nth blank-separated WORD
N   F<char> (motion) to the Nth occurrence of <char> to the left
N   G       (motion) goto line N (default: last line), on the first non-blank character
N   H       (motion?) go to the Nth line in the window, on the first non-blank
N   J       (motion?) join N-1 lines (delete newlines)
VIS J       (motion?) join the highlighted lines
    M       (motion?) go to the middle line in the window, on the first non-blank
N   L       (motion?) go to the Nth line from the bottom, on the first non-blank
N   N       (motion) repeat last search, in opposite direction
N   T<char> (motion) till before the Nth occurrence of <char> to the left
N   W       (motion) N blank-separated WORDS forward

N   b       (motion) N words backward
N   e       (motion) forward to the end of the Nth word
N   f<char> (motion) to the Nth occurrence of <char> to the right
N   g^      (motion) to first non-blank character in screen line (differs from "^" when lines wrap)
N   g#      (motion) like "#", but also find partial matches
N   g$      (motion) to last character in screen line (differs from "$" when lines wrap)
N   g*      (motion) like "*", but also find partial matches
N   g0      (motion) to first character in screen line (differs from "0" when lines wrap)
    gD      (motion) goto global declaration of identifier under the cursor
N   gE      (motion) backward to the end of the Nth blank-separated WORD
    gd      (motion) goto local declaration of identifier under the cursor
N   ge      (motion) backward to the end of the Nth word
N   gg      (motion) goto line N (default: first line), on the first non-blank character
N   gj      (motion) down N screen lines (differs from "j" when line wraps)
N   gk      (motion) up N screen lines (differs from "k" when line wraps)
N   h       (motion) left (also: CTRL-H, <BS>, or <Left> key)
N   j       (motion) down N lines (also: CTRL-J, CTRL-N, <NL>, and <Down>)
N   k       (motion) up N lines (also: CTRL-P and <Up>)
N   l       (motion) right (also: <Space> or <Right> key)
N   n       (motion?) repeat last search
    o       (motion?) exchange cursor position with start of highlighting
N   t<char> (motion) till before the Nth occurrence of <char> to the right
N   w       (motion) N words forward
.. @+node:ekr.20131108082341.18226: *4* motions
@color

w   to start of next word, excluding it's first character.
e   to end of next word, including it's last character.
$   to end of line, including the last character.
0   to start of line

Motions may include repeat count:

d2w
2dd
d2d

From: http://bullium.com/support/vim.html#motion

Basic motion commands:

N h
N j or Ctrl-N
N k or Ctrl-P
0 or <Home>
^ 
$ or <End>
g0 or
g<Home> 	
g^
g$ or g<End>
f{char}
F{char}
t{char}
T{char}
; 	Repeat latest f, t, F or T [count] times.
, 	Repeat latest f, t, F or T in opposite direction [count] times.
-
N + or CTRL-M or <CR>
N _
<C-End> or G
N <C-Home> or gg
N <S-Right> or w
N <C-Right> or W
N e 	Forward to the end of word [count]
E 	Forward to the end of WORD [count]
<S-Left> or
b 	[count] words backward
<C-Left> or
B 	[count] WORDS backward
ge 	Backward to the end of word [count]
gE 	Backward to the end of WORD [count]

These commands move over words or WORDS.

A word consists of a sequence of letters, digits and underscores, or a
sequence of other non-blank characters, separated with white space (spaces,
tabs, ). This can be changed with the 'iskeyword' option.

A WORD consists of a sequence of non-blank characters, separated with white
space. An empty line is also considered to be a word and a WORD.

N ( 	    
N ) 	    
N { 	    
N } 	
N ]] 	    
N ][ 	    
N [[ 	    
N [] 	
.. @+node:ekr.20131105122124.16483: *4* vim regex
                                           Value of magic option
                                           ---------------------
                        meaning            magic       nomagic

           matches any single character      .            \.
                  matches start of line      ^            ^
                    matches end of line      $            $
                  matches start of word      \<           \<
                    matches end of word      \>           \>
   matches a single char from the range      [a-z]        \[a-z]
 matches a single char not in the range      [^a-z]       \[^a-z]
             matches an identifier char      \i           \i
              idem but excluding digits      \I           \I
            matches a keyword character      \k           \k
              idem but excluding digits      \K           \K
           matches a filename character      \f           \f
              idem but excluding digits      \F           \F
          matches a printable character      \p           \p
              idem but excluding digits      \P           \P

                          matches <Esc>      \e           \e
                          matches <Tab>      \t           \t
                           matches <CR>      \r           \r
                           matches <BS>      \b           \b

matches 0 or more of the preceding atom      *            \*
matches 1 or more of the preceding atom      \+           \+
   matches 0 or 1 of the preceding atom      \=           \=
                 separates two branches      \|           \|
           group a pattern into an atom      \(\)         \(\)
.. @+node:ekr.20131105122124.16484: *4* keys in insert mode
    char                action in Insert mode
    ----                --------------------- 
 
    <Esc>               end Insert mode, back to Normal mode
    <BS> or CTRL-H      delete the character before the cursor
    {char1} <BS> {char2}    enter digraph if 'digraph' option set
    <Del>               delete the character under the cursor
    <End>               cursor after last character in the line
    <Home>              cursor to first character in the line
    <NL> or <CR>        begin new line
    
    cursor keys         move cursor left/right/up/down
    shift-left/right    one word left/right
    shift-up/down       one screenful backward/forward

    CTRL-@              insert previously inserted text and stop insert
    CTRL-A              insert previously inserted text
    CTRL-B              toggle 'revins' (reverse insert) option
    CTRL-C              like <Esc>, but do not do an abbreviation
    CTRL-D              delete one shiftwidth of indent in front of the current line
0   CTRL-D              delete all indent in the current line
^   CTRL-D              delete all indent in the current line, restore indent in next line
    CTRL-E              insert the character from below the cursor
    CTRL-K {char1} {char2}  enter digraph
    CTRL-M or CTRL-J    begin new line
    CTRL-N              insert next match of identifier before the cursor
    CTRL-O {command}    execute {command}
    CTRL-P              insert previous match of identifier before the cursor
    CTRL-R <0-9a-z%:.-"> insert contents of register <0-9a-z%:.-">
    CTRL-T              insert one shiftwidth of indent in front of the current line
    CTRL-U              delete all entered characters in the current line
    CTRL-V <char>..     insert character literally, or enter decimal byte value
    CTRL-W              delete word before the cursor
    CTRL-X ...          complete the word before the cursor in various ways
    CTRL-Y              insert the character from above the cursor
.. @+node:ekr.20131105122124.16485: *4* complex
N  !{motion}{command}<CR>  filter the lines that are moved over through {command}
N  !!{command}<CR>         filter N lines through {command}
   {visual}!{command}<CR>  filter the highlighted lines through {command}
   :[range]! {command}<CR> filter [range] lines through {command}
N  ={motion}               filter the lines that are moved over through "indent"
N  ==                      filter N lines through "indent"
   {visual}=               filter the highlighted lines through "indent"
   
:[range]s[ubstitute]/{pattern}/{string}/[g][c]
:[range]s[ubstitute] [g][c]
   &         Repeat previous ":s" on current line without options
:[range]ret[ab][!] [tabstop]
.. @+node:ekr.20131105122124.16486: *4* text object
Used only in Visual mode or after an operator

a            Select current word
A            Select current WORD
s            Select current sentence
p            Select current paragraph
S            Select current block (from "[(" to "])")
P            Select current block (from "[{" to "]}")
.. @+node:ekr.20131105122124.16487: *4* offsets after search command
[num]       [num] lines downwards, in column 1
+[num]      [num] lines downwards, in column 1
-[num]      [num] lines upwards, in column 1
e[+num]     [num] characters to the right of the end of the match
e[-num]     [num] characters to the left of the end of the match
s[+num]     [num] characters to the right of the start of the match
s[-num]     [num] characters to the left of the start of the match
b[+num]     [num] characters to the right of the start (begin) of the match
b[-num]     [num] characters to the left of the start (begin) of the match
;{search command}   execute {search command} next


/test/+1		one line below "test", in column 1
/test/e			on the last t of "test"
/test/s+2		on the 's' of "test"
/test/b-3		three characters before "test"
.. @+node:ekr.20131105122124.16488: *4* Examples
:%g/^a/-1join     join lines starting with character 'a' to previous line
:%g/^ *$/d        delete empty lines
:%v/vim/m 1       move lines not matching the word 'vim' to line 1
:%g/^a/+1d        delete lines after the ones starting with character 'a'

:so[urce] {file}    Read Ex commands from {file}.
:so[urce]! {file}   Read Vim commands from {file}.
:sl[eep] [N]        don't do anything for N seconds
.. @+node:ekr.20131105122124.16489: *4* Options overview

name       short name   explanation
----       ----------   -----------
aleph          al       ASCII code of the letter Aleph (RIGHTLEFT)
autoindent     ai       take indent for new line from previous line
autowrite      aw       automatically write file if changed
backspace      bs       how backspace works at start of line
backup         bk       keep backup file after overwriting a file
backupdir      bdir     list of directories for the backup file
backupext      bex      extension used for the backup file
binary         bin      edit binary file mode
bioskey        biosk    MS-DOS: use bios calls for input characters
breakat        brk      characters that may cause a line break
cindent        cin      do C program indenting
cinkeys        cink     keys that trigger indent when 'cindent' is set
cinoptions     cino     how to do indenting when 'cindent' is set
cinwords       cinw     words where 'si' and 'cin' add an indent
cmdheight      ch       number of lines to use for the command-line
columns        co       number of columns in the display
comments       com      patterns that can start a comment line
compatible     cp       behave Vi-compatibly as much as possible
cpoptions      cpo      flags for Vi-compatible behaviour
define         def      pattern to be used to find a macro definition
dictionary     dict     list of filenames used for keyword completion
digraph        dg       enable the entering of digraphs in Insert mode
directory      dir      list of directory names for the swapfile
edcompatible   ed       toggle flags of ":substitute" command
endofline      eol      write end-of-line for last line in file
equalalways    ea       windows are automatically made the same size
equalprg       ep       external program to use for "=" command
errorbells     eb       ring the bell for error messages
errorfile      ef       name of the error file for the QuickFix mode
errorformat    efm      description of the lines in the error file
esckeys        ek       recognize function keys in Insert mode
expandtab      et       use spaces when <Tab> is inserted
exrc                    read .vimrc and .exrc in the current directory
formatoptions  fo       how automatic formatting is to be done
formatprg      fp       name of external program used with "gq" command
gdefault       gd       the ":substitute" flag 'g' is default on
guifont        gfn      GUI: Name(s) of font(s) to be used
guioptions     go       GUI: Which components and options are used
guipty                  GUI: try to use a pseudo-tty for ":!" commands
helpfile       hf       name of this help file
helpheight     hh       minimum height of a new help window
hidden         hid      don't unload buffer when it is abandoned
highlight      hl       sets highlighting mode for various occasions
history        hi       number of command-lines that are remembered
hkmap          hk       Hebrew keyboard mapping (RIGHTLEFT)
icon                    set icon of the window to the name of the file
ignorecase     ic       ignore case in search patterns
include        inc      pattern to be used to find an include file
incsearch      is       highlight match while typing search pattern
infercase      inf      adjust case of match for keyword completion
insertmode     im       start the edit of a file in Insert mode
isfname        isf      characters included in filenames and pathnames
isident        isi      characters included in identifiers
isprint        isp      printable characters
iskeyword      isk      characters included in keywords
joinspaces     js       two spaces after a period with a join command
keywordprg     kp       program to use for the "K" command
langmap        lmap     alphabetic characters for other language mode
laststatus     ls       tells when last window has status lines
linebreak      lbr      wrap long lines at a blank
lines                   number of lines in the display
lisp                    automatic indenting for Lisp
list                    show <Tab> and end-of-line
magic                   changes special characters in search patterns
makeprg        mp       program to use for the ":make" command
maxmapdepth    mmd      maximum recursive depth for mapping
maxmem         mm       maximum memory (in Kbyte) used for one buffer
maxmemtot      mmt      maximum memory (in Kbyte) used for all buffers
modeline       ml       recognize modelines at start or end of file
modelines      mls      number of lines checked for modelines
modified       mod      buffer has been modified
more                    pause listings when the whole screen is filled
mouse                   enable the use of mouse clicks
mousetime      mouset   max time between mouse double-click
number         nu       print the line number in front of each line
paragraphs     para     nroff macros that separate paragraphs
paste                   allow pasting text
patchmode      pm       keep the oldest version of a file
path           pa       list of directories searched with "gf" et.al.
readonly       ro       disallow writing the buffer
remap                   allow mappings to work recursively
report                  threshold for reporting nr. of lines changed
restorescreen  rs       Win32: restore screen when exiting
revins         ri       inserting characters will work backwards
rightleft      rl       window is right-to-left oriented (RIGHTLEFT)
ruler          ru       show cursor line and column in the status line
scroll         scr      lines to scroll with CTRL-U and CTRL-D
scrolljump     sj       minimum number of lines to scroll
scrolloff      so       minimum nr. of lines above and below cursor
sections       sect     nroff macros that separate sections
secure                  secure mode for reading .vimrc in current dir
shell          sh       name of shell to use for external commands
shellcmdflag   shcf     flag to shell to execute one command
shellpipe      sp       string to put output of ":make" in error file
shellquote     shq      quote character(s) for around shell command
shellredir     srr      string to put output of filter in a temp file
shelltype      st       Amiga: influences how to use a shell
shiftround     sr       round indent to multiple of shiftwidth
shiftwidth     sw       number of spaces to use for (auto)indent step
shortmess      shm      list of flags, reduce length of messages
shortname      sn       non-MS-DOS: File names assumed to be 8.3 chars
showbreak      sbr      string to use at the start of wrapped lines
showcmd        sc       show (partial) command in status line
showmatch      sm       briefly jump to matching bracket if insert one
showmode       smd      message on status line to show current mode
sidescroll     ss       minimum number of columns to scroll horizontal
smartcase      scs      no ignore case when pattern has uppercase
smartindent    si       smart autoindenting for C programs. For perl
                        script editing set this option and the following
                        key mapping: inoremap # x<BS># 
smarttab       sta      use 'shiftwidth' when inserting <Tab>
splitbelow     sb       new window from split is below the current one
startofline    sol      commands move cursor to first blank in line
suffixes       su       suffixes that are ignored with multiple match
swapsync       sws      how to sync swapfile
tabstop        ts       number of spaces that <Tab> in file uses
taglength      tl       number of significant characters for a tag
tagrelative    tr       filenames in tag file are relative
tags           tag      list of filenames used by the tag command
term                    name of the terminal
terse                   shorten some messages
textauto       ta       set 'textmode' automatically when reading file
textmode       tx       lines are separated by <CR><NL>
textwidth      tw       maximum width of text that is being inserted
tildeop        top      tilde command "~" behaves like an operator
timeout        to       time out on mappings and key codes
ttimeout                time out on mappings
timeoutlen     tm       time out time in milliseconds
ttimeoutlen    ttm      time out time for key codes in milliseconds
title                   set title of window to the name of the file
ttybuiltin     tbi      use built-in termcap before external termcap
ttyfast        tf       indicates a fast terminal connection
ttyscroll      tsl      maximum number of lines for a scroll
ttytype        tty      alias for 'term'
undolevels     ul       maximum number of changes that can be undone
updatecount    uc       after this many characters flush swapfile
updatetime     ut       after this many milliseconds flush swapfile
viminfo        vi       use .viminfo file upon startup and exiting
visualbell     vb       use visual bell instead of beeping
warn                    warn for shell command when buffer was changed
weirdinvert    wi       for terminals that have weird inversion method
whichwrap      ww       allow specified keys to cross line boundaries
wildchar       wc       command-line character for wildcard expansion
winheight      wh       minimum number of lines for the current window
wrap                    long lines wrap and continue on the next line
wrapmargin     wm       chars from the right where wrapping starts
wrapscan       ws       searches wrap around the end of the file
writeany       wa       write to file with no need for "!" override
writebackup    wb       make a backup before overwriting a file
writedelay     wd       delay this many msec for each char (for debug)
.. @+node:ekr.20131105122124.16490: *4* Command-line completion
'wildchar' (default: <Tab>)
    do completion on the pattern in front of the cursor. If there are
    multiple matches, beep and show the first one; further 'wildchar' will
    show the next ones.
                   
CTRL-A  insert all names that match pattern in front of cursor
CTRL-D  list all names that match the pattern in front of the cursor
CTRL-L  insert longest common part of names that match pattern
CTRL-N  after 'wildchar' with multiple matches: go to next match
CTRL-P  after 'wildchar' with multiple matches: go to previous match
.. @+node:ekr.20131105122124.16491: *4* Special Ex characters

|           separates two commands (not for ":global" and ":!")
"           begins comment

%           current filename (only where filename is expected)
#[number]   alternate filename [number] (only where filename is expected)

Note: The next four are typed literally; these are not special keys!

<cword>     word under the cursor (only where filename is expected)
<cWORD>     WORD under the cursor (only where filename is expected)
<cfile>     file name under the cursor (only where filename is expected)
<afile>     file name for autocommand (only where filename is expected)

After "%", "#", "<cfile>", or "<afile>"
:p          full path
:h          head
:t          tail
:r          root
:e          extension
.. @+node:ekr.20131105122124.16492: *4* Ex ranges
,               separates two line numbers
;               idem, set cursor to the first line number
                before interpreting the second one
{number}        an absolute line number
.               the current line
$               the last line in the file
%               equal to 1,$ (the entire file)
*               equal to '<,'> (visual area)
't              position of mark t
/{pattern}[/]   the next line where {pattern} matches
?{pattern}[?]   the previous line where {pattern} matches
+[num]          add [num] to the preceding line number (default: 1)
-[num]          subtract [num] from the preceding line number (default: 1)
.. @+node:ekr.20131105122124.16493: *4* Starting vim
38 -- Starting VIM


vim [options]                start editing with an empty buffer
vim [options] {file ..}      start editing one or more files
vim [options] -t {tag}       edit the file associated with {tag}
vim [options] -e [fname]     start editing in QuickFix mode, display the first error


39 -- Vim Command Line Arguments


-g                  start GUI (also allows other options)

+[num]              put the cursor at line [num] (default: last line)
+{command}          execute {command} after loading the file
+/{pat} {file ..}   put the cursor at the first occurrence of {pat}
-v                  read-only mode (View), implies -n
-R                  read-only mode, same as -v
-b                  binary mode
-l                  lisp mode
-H                  Hebrew mode ('hkmap' and 'rightleft' are set)
-r                  give list of swap files
-r {file ..}        recover aborted edit session
-n                  do not create swapfile
-o [N]              open N windows (default: one for each file)
-x                  Amiga: do not restart VIM to open a window (for
                        e.g., mail)
-s {scriptin}       first read commands from the file {scriptin}
-w {scriptout}      write typed chars to file {scriptout} (append)
-W {scriptout}      write typed chars to file {scriptout} (overwrite)
-T {terminal}       set terminal name
-d {device}         Amiga: open {device} to be used as a console
-u {vimrc}          read inits from {vimrc} instead of other inits
-i {viminfo}        read info from {viminfo} instead of other files
--                  end of options, other arguments are file names

Automatic option setting when editing a file

vim:{set-arg}: ..       In the first and last lines of the
                        file (see 'ml' option), {set-arg} is
                        given as an argument to ":set"
                        
Automatic execution of commands on certain events.

:au                     List all autocommands
:au {event}             List all autocommands for {event}
:au {event} {pat}       List all autocommands for {event} with {pat}
:au {event} {pat} {cmd} Enter new autocommands for {event} with {pat}
:au!                    Remove all autocommands
:au! {event}            Remove all autocommands for {event}
:au! * {pat}            Remove all autocommands for {pat}
:au! {event} {pat}      Remove all autocommands for {event} with {pat}
:au! {event} {pat} {cmd}  Remove all autocommands for {event} with {pat} and enter new one
.. @+node:ekr.20131105122124.16494: *4* : commands unsorted
:marks                  print the active marks
:ju[mps]                print the jump list
:ta[g][!] {tag}         Jump to tag {tag}
:[count]ta[g][!]        Jump to [count]'th newer tag in tag list
:[count]po[p][!]        Jump back from [count]'th older tag in tag list
:tags                   Print tag list
:dig[raphs]                                 show current list of digraphs
:dig[raphs] {char1}{char2} {number} ...     add digraph(s) to the list
:r [file]               insert the contents of [file] below the cursor
:r! {command}           insert the standard output of {command} below the cursor
:[range]d [x]           delete [range] lines [into register x]
:reg                    show the contents of all registers
:reg {arg}              show the contents of registers mentioned in {arg}
:[range]ce[nter] [width] center the lines in [range]
:[range]le[ft] [indent]  left-align the lines in [range] [with indent]
:[range]ri[ght] [width]  right-align the lines in [range]
:@<a-z>                 execute the contents of register <a-z> as an Ex command
:@@                     repeat previous :@<a-z>
:[range]g[lobal]/{pattern}/[cmd] 
:[range]g[lobal]!/{pattern}/[cmd]     or    :[range]v/{pattern}/[cmd]
:ma[p] {lhs} {rhs}          Map {lhs} to {rhs} in Normal and Visual mode.
:ma[p]! {lhs} {rhs}         Map {lhs} to {rhs} in Insert and Command-line mode.
:no[remap][!] {lhs} {rhs}   Same as ":map", no remapping for this {rhs}
:unm[ap] {lhs}              Remove the mapping of {lhs} for Normal and Visual mode.
:unm[ap]! {lhs}             Remove the mapping of {lhs} for Insert and Command-line mode.
:ma[p] [lhs]         List mappings (starting with [lhs]) for Normal and Visual mode.
:ma[p]! [lhs]        List mappings (starting with [lhs]) for Insert and Command-line mode.
:cmap/:cunmap/:cnoremap 
:imap/:iunmap/:inoremap
:nmap/:nunmap/:nnoremap
:vmap/:vunmap/:vnoremap
:mk[exrc][!] [file]  write current mappings, abbreviations, and settings to [file] (default: ".exrc"; use ! to overwrite)
:mkv[imrc][!] [file] same as ":mkexrc", but with default ".vimrc"
:mapc[lear]          remove mappings for Normal and Visual mode
:mapc[lear]!         remove mappings for Insert and Cmdline mode
:imapc[lear]         remove mappings for Insert mode
:vmapc[lear]         remove mappings for Visual mode
:nmapc[lear]         remove mappings for Normal mode
:cmapc[lear]         remove mappings for Cmdline mode

:ab[breviate] {lhs} {rhs}  add abbreviation for {lhs} to {rhs}
:ab[breviate] {lhs}        show abbr's that start with {lhs}
:ab[breviate]              show all abbreviations
:una[bbreviate] {lhs}      remove abbreviation for {lhs}
:norea[bbrev] [lhs] [rhs]  like ":ab", but don't remap [rhs]
:iab/:iunab/:inoreab       like ":ab", but only for Insert mode
:cab/:cunab/:cnoreab       like ":ab", but only for Command-line mode
:abc[lear]                 remove all abbreviations
:cabc[lear]                remove all abbr's for Cmdline mode
:iabc[lear]                remove all abbr's for Insert mode
:se[t]                  Show all modified options.
:se[t] all              Show all options.
:se[t] {option}         Set toggle option on, show string or number option.
:se[t] no{option}       Set toggle option off.
:se[t] inv{option}      invert toggle option.
:se[t] {option}={value} Set string or number option to {value}.
:se[t] {option}?        Show value of {option}.
:se[t] {option}&        Reset {option} to its default value.
:fix[del]               Set value of 't_kD' according to value of 't_kb'.
:sh[ell]        start a shell
:!{command}     execute {command} with a shell
:cc [nr]        display error [nr] (default is the same again)
:cn             display the next error
:cp             display the previous error
:cl             list all errors
:cf             read errors from the file 'errorfile'
:cq             quit without writing and return error code (to the compiler)
:make [args]    start make, read errors, and jump to first error
:ve[rsion]      show exact version number of this Vim
:mode N         MS-DOS: set screen mode to N (number, C80, C4350, etc.)
:norm[al][!] {commands} Execute Normal mode commands.
:e[dit]              Edit the current file, unless changes have been made.
:e[dit]!             Edit the current file always.  Discard any changes.
:e[dit] {file}       Edit {file}, unless changes have been made.
:e[dit]! {file}      Edit {file} always.  Discard any changes.
:pwd                 Print the current directory name.
:cd [path]           Change the current directory to [path].
:f[ile]              Print the current filename and the cursor position.
:f[ile] {name}       Set the current filename to {name}.
:files               Show alternate filenames.

:argu[ment] N       edit file N
:n[ext]             edit next file
:n[ext] {arglist}   define new arg list and edit first file
:N[ext]             edit previous file
:rew[ind][!]        edit first file
:last               edit last file
:sar[gument] N      edit file N (new window)
:sn[ext]            edit next file (new window)
:sn[ext] {arglist}  define new arg list and edit first file (new window)
:sN[ext]            Edit previous file (new window)
:srew[ind]          Edit first file (new window)
:slast              Edit last file (new window)


:ar[gs]              Print the argument list, with the current file in "[]".
:all  or :sall       Open a window for every file in the arg list.
:wn[ext][!]          Write file and edit next file.
:wn[ext][!] {file}   Write to {file} and edit next file, unless {file} exists.  With !, overwrite existing file.
:wN[ext][!] [file]   Write file and edit previous file.
:[range]w[rite][!]            Write to the current file.
:[range]w[rite] {file}        Write to {file}, unless it already exists.
:[range]w[rite]! {file}       Write to {file}.  Overwrite an existing file.
:[range]w[rite][!] >>         Append to the current file.
:[range]w[rite][!] >> {file}  Append to {file}.
:[range]w[rite] !{cmd}        Execute {cmd} with [range] lines as standard input.
:wall[!]                      write all changed buffers

:q[uit]               Quit current buffer.
:q[uit]!              Quit current buffer always.
:qall                 Exit Vim, unless changes have been made.
:qall!                Exit Vim always, discard any changes.
:cq                   Quit without writing and return error code.

:wq[!]                Write the current file and exit.
:wq[!] {file}         Write to {file} and exit.
:x[it][!] [file]      Like ":wq" but write only when changes have been made
:xall[!]  or :wqall[!]  Write all changed buffers and exit
:st[op][!]              Suspend VIM or start new shell. If 'aw' option is set and [!] not given write the buffer.

:rv[iminfo] [file]      Read info from viminfo file [file]
:rv[iminfo]! [file]     idem, overwrite exisiting info
:wv[iminfo] [file]      Add info to viminfo file [file]
:wv[iminfo]! [file]     Write info to viminfo file [file]

:split                  Split window into two parts
:split {file}           Split window and edit {file} in one of them

:buffers  or  :files    list all known buffer and file names
:ball     or  :sball    edit all args/buffers
:unhide   or  :sunhide  edit all loaded buffers

:bunload[!] [N]         unload buffer [N] from memory
:bdelete[!] [N]         unload buffer [N] and delete it from the buffer list

:[N]buffer [N]      to arg/buf N
:[N]bnext [N]       to Nth next arg/buf
:[N]bNext [N]       to Nth previous arg/buf
:[N]bprevious [N]   to Nth previous arg/buf
:brewind            to first arg/buf
:blast              to last arg/buf
:[N]bmod [N]        to Nth modified buf

:[N]sbuffer [N]     to arg/buf N (in new window)
:[N]sbnext [N]      to Nth next arg/buf (in new window)
:[N]sbNext [N]      to Nth previous arg/buf (in new window)
:[N]sbprevious [N]  to Nth previous arg/buf (in new window)
:sbrewind           to first arg/buf (in new window)
:sblast             to last arg/buf (in new window)
:[N]sbmod [N]       to Nth modified buf (in new window)
.. @+node:ekr.20131105122124.16495: *4* : commands merged (do not sort!)
:!{command}                     execute {command} with a shell
:@<a-z>                         execute the contents of register <a-z> as an Ex command
:@@                             repeat previous :@<a-z>
:N[ext]                         edit previous file
:ab[breviate]                   show all abbreviations
:ab[breviate] {lhs}             show abbr's that start with {lhs}
:ab[breviate] {lhs} {rhs}       add abbreviation for {lhs} to {rhs}
:abc[lear]                      remove all abbreviations
:all  or :sall                  open a window for every file in the arg list.
:ar[gs]                         print the argument list, with the current file in "[]".
:argu[ment] N                   edit file N
:[N]bNext [N]                   to Nth previous arg/buf
:ball     or  :sball            edit all args/buffers
:bdelete[!] [N]                 unload buffer [N] and delete it from the buffer list
:blast                          to last arg/buf
:[N]bmod [N]                    to Nth modified buf
:[N]bnext [N]                   to Nth next arg/buf
:[N]bprevious [N]               to Nth previous arg/buf
:[N]buffer [N]                  to arg/buf N
:brewind                        to first arg/buf
:buffers  or  :files            list all known buffer and file names
:bunload[!] [N]                 unload buffer [N] from memory
:cab/:cunab/:cnoreab            like ":ab", but only for Command-line mode
:cabc[lear]                     remove all abbr's for Cmdline mode
:cc [nr]                        display error [nr] (default is the same again)
:cd [path]                      change the current directory to [path].
:[range]ce[nter] [width]        center the lines in [range]
:cf                             read errors from the file 'errorfile'
:cl                             list all errors
:cmap/:cunmap/:cnoremap 
:cmapc[lear]                    remove mappings for Cmdline mode
:cn                             display the next error
:cp                             display the previous error
:cq                             quit without writing and return error code.
:cq                             quit without writing and return error code (to the compiler)
:[range]d [x]                   delete [range] lines [into register x]
:dig[raphs]                     show current list of digraphs
:dig[raphs] {char1}{char2} {number} ...     add digraph(s) to the list
:e[dit]                         edit the current file, unless changes have been made.
:e[dit] {file}                  edit {file}, unless changes have been made.
:e[dit]!                        edit the current file always.  Discard any changes.
:e[dit]! {file}                 edit {file} always.  Discard any changes.
:f[ile]                         print the current filename and the cursor position.
:f[ile] {name}                  set the current filename to {name}.
:files                          show alternate filenames.
:fix[del]                       set value of 't_kD' according to value of 't_kb'.
:[range]g[lobal]!/{pattern}/[cmd]
:[range]g[lobal]/{pattern}/[cmd] 
:iab/:iunab/:inoreab            like ":ab", but only for Insert mode
:iabc[lear]                     remove all abbr's for Insert mode
:imap/:iunmap/:inoremap
:imapc[lear]                    remove mappings for Insert mode
:ju[mps]                        print the jump list
:last                           edit last file
:[range]le[ft] [indent]         left-align the lines in [range] [with indent]
:ma[p] [lhs]                    list mappings (starting with [lhs]) for Normal and Visual mode.
:ma[p] {lhs} {rhs}              map {lhs} to {rhs} in Normal and Visual mode.
:ma[p]! [lhs]                   list mappings (starting with [lhs]) for Insert and Command-line mode.
:ma[p]! {lhs} {rhs}             map {lhs} to {rhs} in Insert and Command-line mode.
:make [args]                    start make, read errors, and jump to first error
:mapc[lear]                     remove mappings for Normal and Visual mode
:mapc[lear]!                    remove mappings for Insert and Cmdline mode
:marks                          print the active marks
:mk[exrc][!] [file]             write current mappings, abbreviations, and settings to [file] (default: ".exrc"; use ! to overwrite)
:mkv[imrc][!] [file]            same as ":mkexrc", but with default ".vimrc"
:mode N                         MS-DOS: set screen mode to N (number, C80, C4350, etc.)
:n[ext]                         edit next file
:n[ext] {arglist}               define new arg list and edit first file
:nmap/:nunmap/:nnoremap
:nmapc[lear]                    remove mappings for Normal mode
:no[remap][!] {lhs} {rhs}       same as ":map", no remapping for this {rhs}
:norea[bbrev] [lhs] [rhs]       like ":ab", but don't remap [rhs]
:norm[al][!] {commands}         execute Normal mode commands.
:[count]po[p][!]                jump back from [count]'th older tag in tag list
:pwd                            print the current directory name.
:q[uit]                         quit current buffer.
:q[uit]!                        quit current buffer always.
:qall                           exit Vim, unless changes have been made.
:qall!                          exit Vim always, discard any changes.
:r [file]                       insert the contents of [file] below the cursor
:r! {command}                   insert the standard output of {command} below the cursor
:reg                            show the contents of all registers
:reg {arg}                      show the contents of registers mentioned in {arg}
:rew[ind][!]                    edit first file
:[range]ri[ght] [width]         right-align the lines in [range]
:rv[iminfo] [file]              read info from viminfo file [file]
:rv[iminfo]! [file]             idem, overwrite exisiting info
:sN[ext]                        edit previous file (new window)
:sar[gument] N                  edit file N (new window)
:sblast                         to last arg/buf (in new window)
:[N]sbNext [N]                  to Nth previous arg/buf (in new window)
:[N]sbmod [N]                   to Nth modified buf (in new window)
:[N]sbnext [N]                  to Nth next arg/buf (in new window)
:[N]sbprevious [N]              to Nth previous arg/buf (in new window)
:[N]sbuffer [N]                 to arg/buf N (in new window)
:sbrewind                       to first arg/buf (in new window)
:se[t]                          show all modified options.
:se[t] all                      show all options.
:se[t] inv{option}              invert toggle option.
:se[t] no{option}               set toggle option off.
:se[t] {option}                 set toggle option on, show string or number option.
:se[t] {option}&                reset {option} to its default value.
:se[t] {option}={value}         set string or number option to {value}.
:se[t] {option}?                show value of {option}.
:sh[ell]                        start a shell
:slast                          edit last file (new window)
:sn[ext]                        edit next file (new window)
:sn[ext] {arglist}              define new arg list and edit first file (new window)
:split                          Split window into two parts
:split {file}                   Split window and edit {file} in one of them
:srew[ind]                      Edit first file (new window)
:st[op][!]                      Suspend VIM or start new shell. If 'aw' option is set and [!] not given write the buffer.
:[count]ta[g][!]                jump to [count]'th newer tag in tag list
:ta[g][!] {tag}                 jump to tag {tag}
:tags                           print tag list
:una[bbreviate] {lhs}           remove abbreviation for {lhs}
:unhide   or  :sunhide          edit all loaded buffers
:unm[ap] {lhs}                  remove the mapping of {lhs} for Normal and Visual mode.
:unm[ap]! {lhs}                 remove the mapping of {lhs} for Insert and Command-line mode.
:[range]v/{pattern}/[cmd]
:ve[rsion]                      show exact version number of this Vim
:vmap/:vunmap/:vnoremap
:vmapc[lear]                    remove mappings for Visual mode
:[range]w[rite] !{cmd}          execute {cmd} with [range] lines as standard input.
:[range]w[rite] {file}          write to {file}, unless it already exists.
:[range]w[rite]! {file}         write to {file}.  Overwrite an existing file.
:[range]w[rite][!]              write to the current file.
:[range]w[rite][!] >>           append to the current file.
:[range]w[rite][!] >> {file}    append to {file}.
:wN[ext][!] [file]              write file and edit previous file.
:wall[!]                        write all changed buffers
:wn[ext][!]                     write file and edit next file.
:wn[ext][!] {file}              write to {file} and edit next file, unless {file} exists.  With !, overwrite existing file.
:wq[!]                          write the current file and exit.
:wq[!] {file}                   write to {file} and exit.
:wv[iminfo] [file]              add info to viminfo file [file]
:wv[iminfo]! [file]             write info to viminfo file [file]
:x[it][!] [file]                like ":wq" but write only when changes have been made
:xall[!]  or :wqall[!]          Write all changed buffers and exit
.. @+node:ekr.20131113045621.16547: *3* class VimCommands
class VimCommands:
    '''
    A class that handles most aspects of vim simulation in Leo.
    
    - vr.create_dicts creates dictionaries from vim-related @data nodes.
    - vr.create_dicst also creates a dispatch dictionary associating
      the first letter of each vim command with a vr method.
    - vr.scan uses those tables to parse a command into its components.
      vr.scan returns a status in ('oops','scan','done').
    - vr.exec_ executes a completed command.
    
    k.getVimArg accumulates vim commands while status is 'scan'
    (ignoring characters when status is 'oops') and calls vr.exec_
    when status is 'done'.
    '''

    @others
.. @+node:ekr.20131111105746.16545: *4*  vc.Birth
.. @+node:ekr.20131109170017.16507: *5* vc.ctor
def __init__(self,c):

    self.init_ivars(c)
    self.create_dicts()
.. @+node:ekr.20131109170017.46983: *5* vc.create_dicts & helpers
def create_dicts(self):

    dump = False
    # Compute tails first.
    self.command_tails_d = self.create_command_tails_d(dump)
    self.motion_tails_d  = self.create_motion_tails_d(dump)
    # Then motions.
    self.motions_d = self.create_motions_d(dump)
    # Then commands.
    self.commands_d = self.create_commands_d(dump)
    # Can be done any time.
    self.dispatch_d = self.create_dispatch_d()
    # Check dict contents.
    self.check_dicts()
    # Check ivars.
    for ivar in (
        'command_tails_d','commands_d',
        'dispatch_d',
        'motion_tails_d','motions_d',
    ):
        assert hasattr(self,ivar),ivar

    
.. @+node:ekr.20131110050932.16536: *6* check_dicts
def check_dicts(self):
    
    # Check user settings.
    d = self.commands_d
    for key in sorted(d.keys()):
        d2 = d.get(key)
        ch = d2.get('ch')
        pattern = d2.get('tail_pattern')
        aList = d2.get('tail_chars')
        if aList and len(aList) > 1 and None in aList and not pattern:
            g.trace('ambiguous entry for %s: %s' % (ch,d2))
.. @+node:ekr.20131110050932.16529: *6* create_command_tails_d
def create_command_tails_d(self,dump):

    # @data vim-command-tails
    d = {}
    data = self.getData('vim-command-tails')
    for s in data:
        kind,command = self.split_arg_line(s)
        if command:
            ch = command[0] # Keys are single characters.
            if kind in self.tail_kinds:
                d[ch] = kind
            else:
                g.trace('bad kind: %s' % s)
        else:
            g.trace('bad command: %s' % s)
    if False or dump: self.dump('command_tails_d',d)
    return d
.. @+node:ekr.20131110050932.16532: *6* create_commands_d
def create_commands_d(self,dump):
    
    # @data vim-commands
    trace = False
    d = {} # Keys are single characters, values are inner dicts.
    data = self.getData('vim-commands')
    for s in data:
        func,command = self.split_arg_line(s)
        command = command.strip()
        if command:
            # 1. Get the inner dict.
            ch = command[0]
            tail = command[1:] or None
            d2 = d.get(ch,{})
            if d2:
                assert d2.get('ch') == ch
            else:
                d2['ch']=ch
            # if ch == '#': g.pdb()
            # Remember the command name
            d2['command_name'] = func
            # Append the tail (including None) to d2['tail_chars']
            aList = d2.get('tail_chars',[])
            if tail is not None:
                if tail in aList:
                    g.trace('duplicate command tail: %s' % tail)
                else:
                    aList.append(tail)
            # Set d2['tail_pattern'] and append None to aList if there is a pattern.
            pattern = self.command_tails_d.get(ch)
            if pattern:
                d2['tail_pattern'] = pattern
                if not None in aList:
                    aList.append(None)
            d2['tail_chars']=aList
            d[ch] = d2
        else:
            g.trace('missing command chars: %s' % (s))
    if trace or dump: self.dump('command_d',d)
    return d
.. @+node:ekr.20131110050932.16530: *6* create_motion_tails_d
def create_motion_tails_d(self,dump):

    # @data vim-motion-tails
    d = {}
    data = self.getData('vim-motion-tails')
    for s in data:
        kind,command = self.split_arg_line(s)
        command = command.strip()
        if command:
            ch = command[0] # Keys are single characters.
            if kind in self.tail_kinds:
                d[ch] = kind
            else:
                g.trace('bad kind: %s' % s)
        else:
            g.trace('bad command: %s' % s)
    if False or dump: self.dump('motion_tails_d',d)
    return d
.. @+node:ekr.20131110050932.16531: *6* create_motions_d
def create_motions_d(self,dump):
    
    # @data vim-motions
    d = {} # Keys are single characters, values are inner dicts.
    data = self.getData('vim-motions')
    for command in data:
        command = command.strip()
        ch = command[:1]
        tail = command[1:] or None
        d2 = d.get(ch,{})
        if d2:
            assert d2.get('ch') == ch
        else:
            d2['ch']=ch
        aList = d2.get('tail_chars',[])
        if tail in aList:
            g.trace('duplicate motion tail: %s' % tail)
        else:
            aList.append(tail)
            d2['tail_chars']=aList
         # Also set d2['tail_pattern'] if tail is None.
        if tail is None:
            if d2.get('tail_pattern'):
                g.trace('duplicate entry for %r' % (ch))
            else:
                d2['tail_pattern'] = self.motion_tails_d.get(ch,'')
        d[ch] = d2
    if False or dump: self.dump('motions_d',d)
    return d
.. @+node:ekr.20131111061547.16460: *6* create_dispatch_d
def create_dispatch_d(self):
    oops = self.oops
    d = {
    # brackets.
    'vim_lcurly':   oops,
    'vim_lparen':   oops,
    'vim_lsquare':  oops,
    'vim_rcurly':   oops,
    'vim_rparen':   oops,
    'vim_rsquare':  oops,
    # Special chars.
    'vim_at':       self.vim_at,
    'vim_backtick': oops,
    'vim_caret':    oops,
    'vim_comma':    oops,
    'vim_dollar':   oops,
    'vim_dot':      oops,
    'vim_dquote':   oops,
    'vim_langle':   oops,
    'vim_minus':    oops,
    'vim_percent':  oops,
    'vim_plus':     oops,
    'vim_pound':    oops,
    'vim_question': oops,
    'vim_rangle':   oops,
    'vim_semicolon': oops,
    'vim_slash':    oops,
    'vim_star':     oops,
    'vim_tilda':    oops,
    'vim_underscore': oops,
    'vim_vertical': oops,
    # Letters and digits.
    'vim_0': oops,
    'vim_A': oops,
    'vim_B': oops,
    'vim_C': oops,
    'vim_D': oops,
    'vim_E': oops,
    'vim_F': oops,
    'vim_G': oops,
    'vim_H': oops,
    'vim_I': oops,
    'vim_J': oops,
    'vim_K': oops,
    'vim_M': oops,
    'vim_L': oops,
    'vim_N': oops,
    'vim_O': oops,
    'vim_P': oops,
    'vim_R': oops,
    'vim_S': oops,
    'vim_T': oops,
    'vim_U': oops,
    'vim_V': oops,
    'vim_W': oops,
    'vim_X': oops,
    'vim_Y': oops,
    'vim_Z': oops,
    'vim_a': oops,
    'vim_b': oops,
    'vim_c': oops,
    'vim_d': self.vim_d,
    'vim_g': oops,
    'vim_h': self.vim_h,
    'vim_i': oops,
    'vim_j': self.vim_j,
    'vim_k': self.vim_k,
    'vim_l': self.vim_l,
    'vim_n': oops,
    'vim_m': self.vim_m,
    'vim_o': oops,
    'vim_p': oops,
    'vim_q': oops,
    'vim_r': oops,
    'vim_s': oops,
    'vim_t': oops,
    'vim_u': oops,
    'vim_v': oops,
    'vim_w': oops,
    'vim_x': oops,
    'vim_y': oops,
    'vim_z': oops,
    }
    return d
.. @+node:ekr.20131109170017.46985: *6* getData
def getData(self,s):
    
    trace = False and not g.unitTesting
    c = self.c
    if 0: # Good for testing: can change the @data node on the fly.
        p = g.findNodeAnywhere(c,'@data %s' % s)
        if p:
            return [s for s in g.splitLines(p.b) if s.strip() and not s.startswith('#')]
        else:
            if trace: g.trace('not found: %s' % s)
            return []
    else:
        return c.config.getData(s) or []
.. @+node:ekr.20131111105746.16547: *5* vc.init_ivars
def init_ivars(self,c):
    
    self.c = c
    # Internal ivars.
    self.event = None
    self.w = c.frame.body and c.frame.body.bodyCtrl # A QTextBrowser.
    # Ivars describing command syntax.
    self.chars = [ch for ch in string.printable if 32 <= ord(ch) < 128]
    # g.trace(''.join(self.chars))
    self.letters = string.ascii_letters
    self.motion_kinds = ['char','letter','register'] # selectors in @data vim-*-tails.
    self.register_names = string.ascii_letters
    self.tail_kinds = ['char','letter','motion','pattern','register',]
    # Ivars accessible via commands.
    self.dot = '' # The previous command in normal mode.
    self.extend = False # True: extending selection.
    self.register_d = {} # Keys are letters; values are strings.
    # Status isvars set by self.exec_
    self.command = None
    self.func = None
    self.tail = None
    self.n1 = None
    self.n2 = None
.. @+node:ekr.20131111105746.16546: *4*  vc.helpers
.. @+node:ekr.20131109170017.46984: *5* vc.dump
def dump(self,name,d):
    '''Dump a dictionary.'''
    print('\nDump of %s' % name)
    for key in sorted(d.keys()):
        val = d.get(key)
        if type(val) in (type([]),type((),)):
            val = ' '.join([z for z in val if z])
            print('%5s %s' % (key,val))
        elif type(val) == type({}):
            result = []
            for key2 in sorted(val.keys()):
                val2 = val.get(key2)
                if type(val2) in (type([]),type((),)):
                    # val2 = ','.join([repr(z) if z is None else z for z in val2])
                    val2 = self.repr_list(val2)
                pad = ' '*2
                if val2:
                    result.append('%s%s %s' % (pad,key2,val2))
            val3 = '\n'.join(result)
            if len(result) == 1:
                print('%s %s' % (key,val3))
            else:
                print('%s\n%s' % (key,val3))
        else:
            print('%5s %s' % (key,val))
.. @+node:ekr.20131111054309.16528: *5* vc.exec_
def exec_(self,command,n1,n2,tail):
    
    trace = False
    d = self.commands_d.get(command,{})
        # Keys are single letters.
    command_name = d.get('command_name')
    func = self.dispatch_d.get(command_name,self.oops)
    # Set ivars describing the command.
    self.command = command
    self.func = func
    self.n1 = n1
    self.n2 = n2
    self.tail = tail
    if trace: self.trace_command()
    for i in range(n1 or 1):
        func()
.. @+node:ekr.20131111061547.16461: *5* vc.oops
def oops(self):
    
    self.trace_command()
    
.. @+node:ekr.20131112061353.16542: *5* vc.repr_list
def repr_list(self,aList):

    return ','.join([repr(z) if z is None else z for z in aList])
.. @+node:ekr.20131111061547.18011: *5* vc.runAtIdle
# For testing: ensure that this always gets called.

def runAtIdle (self,aFunc):
    '''
    Run aFunc at idle time.
    This can not be called in some contexts.
    '''
    if QtCore:
        QtCore.QTimer.singleShot(0,aFunc)
.. @+node:ekr.20131110050932.16533: *5* vc.scan & helpers
def scan(self,s):
    
    trace = False ; verbose = True
    n1,n2,tail,status = None,None,None,'oops'
    i,n1 = self.scan_count(s)
    full_command = s[i:]
    if not full_command:
        status = 'scan' # Still looking for the start of a command.
        if trace: g.trace('s: %s status: %s (no command)' % (s,status))
        return status,n1,full_command,n2,tail
    tail = full_command[1:]
    ch = command = full_command[0]
    d = self.commands_d.get(ch)
        # d is an innder dict.
    if not d:
        if trace: g.trace('s: %s status: %s (invalid command)' % (s,status))
        return 'oops',n1,command,n2,tail
    tails = d.get('tail_chars') or []
        # A list of strings that can follow ch.
        # May include None, in which case pattern may fire.
    pattern = d.get('tail_pattern')
    if trace and verbose: g.trace('command: %s pattern: %s tail: %s tails: [%s]' % (
        command,pattern,repr(tail),self.repr_list(tails)))
    if tail:
        status,n2,tail = self.match_tails(full_command,pattern,tails)
    elif None in tails and pattern:
        status = 'scan'
    else:
        status = 'scan' if tails else 'done'
    if trace: g.trace('s: %s status: %s n1: %s command: %s n2: %s tail: %s' % (
        s,status,n1,command,n2,tail))
    assert command is None or len(command) == 1
        # Commands are single letters!
    return status,n1,command,n2,tail
.. @+node:ekr.20131112061353.16543: *6* vc.match_motion_tails
def match_motion_tails(self,tail,pattern,tails):
    
    trace = False
    # Simpler than match_tails because the tail can have no motion pattern.
    if pattern == 'motion':
        g.trace('can not happen',pattern,tail)
    if trace: g.trace('s: %s pattern: %s tails: [%s]' % (
        tail,pattern or 'None',self.repr_list(tails)))
    if tail:
        if tail in tails:
            status = 'done' # A complete match.  Pattern irrelevant.
        else:
            # First, see if tail is a prefix of any item of tails.
            for item in tails:
                if item is not None and item.startswith(tail):
                    status = 'scan'
                    break
            else:
                if None in tails:
                    # Handle the None case. Match the tail against the pattern.
                    status,junk,junk = self.scan_any_pattern(pattern,tail)
                else:
                    status = 'oops'
    elif None in tails:
        status = 'scan' if pattern else 'done'
    else:
        status = 'scan' if tails else 'oops'
    assert status in ('done','oops','scan'),status
    return status
    
.. @+node:ekr.20131112061353.16541: *6* vc.match_tails
def match_tails(self,s,pattern,tails):
    '''s is the tail of a command. See if it matches any tail in tails.'''
    trace = False
    n2,status,tail = None,'oops',None
    if trace: g.trace('s: %s tails: [%s]' % (s or 'None',self.repr_list(tails)))
    if s[1:] in tails:
        if trace: g.trace('complete match: %s' % s)
        return 'done',n2,s # A complete match.  Pattern irrelevant.
    # See if any head string (longest first!) is a prefix of any tail.
    i = len(s)
    while i >= 0:
        head = s[1:i]
        i -= 1
        for tail in tails:
            if tail is not None and tail.startswith(head):
                if trace: g.trace('prefix match: %s head: %s tail %s' % (
                    s,head,tail))
                motion = s[i+1:]
                if motion:
                    if None in tails and pattern:
                        status,tail,n2 = self.scan_any_pattern(pattern,motion)
                        if trace: g.trace('pattern match: %s %s head: %s tail: %s' % (
                            s,status,head,tail))
                        return status,n2,tail
                    else:
                        if trace: g.trace('**None not in tails**: %s head %s tail: %s' % (
                            s,head,tail))
                        return 'oops',n2,s
                else:
                    return 'scan',n2,s
    # Handle the None case. Try to match any tail against the pattern.
    if None in tails and pattern:
        status,tail,n2 = self.scan_any_pattern(pattern,s[1:])
        if trace: g.trace('pattern match: %s %s' % (status,s))
        return status,n2,tail
    else:
        if trace: g.trace('no match: %s' % s)
        return 'oops',n2,s
.. @+node:ekr.20131110050932.16559: *6* vc.scan_any_pattern
def scan_any_pattern(self,pattern,s):
    '''Scan s, looking for the indicated pattern.'''
    trace = False
    if trace: g.trace(pattern,s)
    if pattern == 'motion':
        status,n2,result = self.scan_motion(s)
    elif s and len(s) == 1 and (
        pattern == 'char' and s in self.chars or
        pattern == 'letter' and s in self.letters or
        pattern == 'register' and s in self.register_names
    ):
        n2,result,status = None,s,'done'
    else:
        n2,result,status = None,s,'oops'
    if trace: g.trace(status,pattern,s,result,n2)
    return status,result,n2
.. @+node:ekr.20131110050932.16540: *6* vc.scan_count
def scan_count(self,s):

    # Zero is a command.  It does not start repeat counts.
    if s and s[0].isdigit() and s[0] != '0':
        i  = 0
        while i < len(s) and s[i].isdigit():
            i += 1
        return i,int(s[:i])
    else:
        return 0,None
.. @+node:ekr.20131110050932.16558: *6* vc.scan_motion
def scan_motion(self,s):
    
    trace = False
    i,n2 = self.scan_count(s)
    motion = s[i:]
    if motion:
        ch = motion[:1]
        tail = motion[1:]
        d = self.motions_d.get(ch,{})
            # motions_d: keys are single characters, values are inner dicts.
        tails = d.get('tail_chars',[])
        pattern = d.get('tail_pattern')
        status = self.match_motion_tails(tail,pattern,tails)
    else:
        status = 'scan'
    if trace: g.trace(status,n2,motion)
    return status,n2,motion
.. @+node:ekr.20131112104359.16686: *6* vc.simulate_typing
def simulate_typing (self,s):
    '''Simulate typing of command s.
    Return (status,head) for increasing prefixes of s, including s.
    '''
    
    trace = False
    i = 1
    while i < len(s):
        head = s[:i]
        i += 1
        if trace: g.trace('scan',s,head)
        yield 'scan',head
    if trace: g.trace('done',s)
    yield 'done',s
.. @+node:ekr.20131110050932.16501: *6* vc.split_arg_line
def split_arg_line(self,s):
    '''
    Split line s into a head and tail.
    The head is a python id; the tail is everything else.
    '''
    i = g.skip_id(s,0,chars='_')
    head = s[:i]
    tail = s[i:].strip()
    return head,tail
.. @+node:ekr.20131111061547.16462: *5* vc.trace_command
def trace_command(self):
    
    func_name = self.func and self.func.__name__ or 'oops'
    print('%s func: %s command: %r n1: %r n2: %r tail: %r' % (
        g.callers(1),func_name,self.command,self.n1,self.n2,self.tail))
.. @+node:ekr.20131111061547.16467: *4* vc.commands
.. @+node:ekr.20131111061547.16468: *5* vim_h/j/k/l
.. @+node:ekr.20131111171616.16498: *6* vim_d
def vim_d(self):
    
    g.trace(self.command,self.tail)
.. @+node:ekr.20131111061547.18012: *6* vim_h
def vim_h(self):
    '''Move cursor left.'''
    if self.extend:
        self.c.editCommands.backCharacterExtendSelection(self.event)
    else:
        self.c.editCommands.backCharacter(self.event)
.. @+node:ekr.20131111061547.18013: *6* vim_j
def vim_j(self):
    '''Move cursor down.'''
    if self.extend:
        self.c.editCommands.nextLineExtendSelection(self.event)
    else:
        self.c.editCommands.nextLine(self.event)
.. @+node:ekr.20131111061547.18014: *6* vim_k
def vim_k(self):
    '''Move cursor up.'''
    if self.extend:
        self.c.editCommands.prevLineExtendSelection(self.event)
    else:
        self.c.editCommands.prevLine(self.event)
.. @+node:ekr.20131111061547.18015: *6* vim_l
def vim_l(self):
    '''Move cursor right.'''
    if self.extend:
        self.c.editCommands.forwardCharacterExtendSelection(self.event)
    else:
        self.c.editCommands.forwardCharacter(self.event)
.. @+node:ekr.20131111105746.16544: *5* vim_dot
def vim_dot(self):
    
    g.trace()
.. @+node:ekr.20131111171616.16496: *5* vim_at
def vim_at(self):
    
    g.trace(self.command,self.tail)
.. @+node:ekr.20131111171616.16497: *5* vim_m
def vim_m(self):
    
    g.trace(self.command,self.tail)
.. @+node:ekr.20131111161433.16516: *3* @test vr.exec_ (also in unitTest.leo)
import imp
import leo.core.leoVim as leoVim
imp.reload(leoVim)
vc = leoVim.VimCommands(c)
vc.extend = False # Can only execute once.
    # we would like to force useSelectedText = False in g.getScript
table = (
    # '3h', # works
    # '4l', # works
    # '1j', # works
    # 'k', # works
    # 'ma', # works
    # '@a', # works
    '8dta',
)
for s in table:
    status,n1,command,n2,motion = vc.scan(s)
    # print('status',status,'command',command)
    if status == 'done':
        vc.exec_(command,n1,n2,motion)
    else:
        print('status: %s %s' % (status,s))
        vc.command = s
        vc.n1 = n1
        vc.n2 = n2
        vc.motion = motion
        vc.oops()

if g.unitTesting:
    # Unit testing messes up the focus.
    vc.runAtIdle(c.bodyWantsFocusNow)
.. @+node:ekr.20131112061353.16538: *3* @test vr.scan
import leo.core.leoVim as leoVim
if 1: # When running from leoPy.leo
    import imp
    imp.reload(leoVim)
import time
trace = False
trace_time = False
<< define test tables >>
vc = leoVim.VimCommands(c)
test_table = (
    ('done',complete_table),
    ('scan',incomplete_table),
    ('oops',error_table),
)
if trace_time: t1 = time.clock()
n = 0
for i in range(1):
    for expected,table in test_table:
        for s in table:
            if table == complete_table:
                command = s
                for expected,command2 in vc.simulate_typing(command):
                    status,n1,command3,n2,motion = vc.scan(command2)
                    n += 1
                    if trace:
                        err = '   ' if status == expected else '***'
                        print('%s%s %s' % (err,status,command2))
                    else:
                        assert status == expected,'expected %s, got %s command: %s' % (
                        expected,status,command2)
            else:
                for prefix in ('','1023456789'):
                    command = prefix + s
                    status,n1,command2,n2,motion = vc.scan(command)
                    n += 1
                    if trace:
                        err = '   ' if status == expected else '***'
                        print('%s%s %s' % (err,status,command))
                    else:
                        assert status == expected,'expected %s, got %s command: %s' % (
                        expected,status,command)
if trace_time:
    delta = time.clock()-t1
    print("%s %6.6f sec." % (n,delta/n))

.. @+node:ekr.20131112061353.16539: *4* << define test tables >>
# To do: handle d2d, 2dd, etc.
if 0: # Individual test:
    complete_table = ('ta',)
        # Note: gu is complete, so gu[] is an invalid test.
    incomplete_table = () # 'd3','d4t','dt',
    error_table = ()
else:
    complete_table = (
        '0',
        'N',
        '#',
        'gg','gk','dd',
        'd3j',
        '2dta', # d is not (yet) a motion
        'dFb',
        'gu',
        'g[]',
        'ta',
        't!',
    )
    incomplete_table = (
        'g',
        '[',
        ']',
        '25',
        'd3t',
        'd3',
    )
    error_table = (
        'gX','ZA',
    )
.. @+node:ekr.20131112152450.16537: *3* k.getVimArg
def getVimArg(self,event,specialStroke=None,specialFunc=None):
    '''Handle all keys in the minibuffer when c.vim_mode is True.'''
    ### help=False,
    ### helpHandler=None
    trace = False # and not g.unitTesting
    verbose = False
    k,c = self,self.c
    k = self ; c = k.c
    vr = c.vimCommands
    prompt = 'Normal Mode: ' ###
    recording = c.macroCommands.recordingMacro
    state = k.getState('vim-mode')
    if trace: g.trace('**',k.getLabel(),state)
    c.check_event(event)
    ch = char = event and event.char or ''
    stroke = event and event.stroke or None
    if trace: g.trace('state',state,char) # 'recording',recording,
    # if recording:
        # c.macroCommands.startRecordingMacro(event)
    # if state > 0:
        # k.setLossage(char,stroke)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('vim-mode',1,handler=k.getVimArg)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = None ### help
        k.mb_helpHandler = None ### helpHandler
    # Unlike fullCommand, we *do* have a key.
    elif char == 'Ins' or k.isFKey(char):
        pass
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n','Return'):
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        k.callAltXFunction(k.mb_event)
        # if k.mb_help:
            # s = k.getLabel()
            # commandName = s[len(helpPrompt):].strip()
            # k.clearState()
            # k.resetLabel()
            # if k.mb_helpHandler: k.mb_helpHandler(commandName)
        # else:
            # k.callAltXFunction(k.mb_event)
    # elif char in ('\t','Tab'):
        # if trace and verbose: g.trace('***Tab')
        # k.doTabCompletion(list(c.commandsDict.keys()),allow_empty_completion=True)
        # c.minibufferWantsFocus()
    elif char in ('\b','BackSpace'):
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(list(c.commandsDict.keys()))
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        if trace: g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        if trace: g.trace('new prefix',k.mb_tabListPrefix)
    # Examine each keystroke to see if we have a complete command.
    if state != 0:
        command = k.getLabel(ignorePrompt=True)
        status,n1,command2,n2,tail = vr.scan(command)
        if trace: g.trace('status: %s %s command: %s n1: %s n2: %s tail: %s' % (
            status,command,command2,n1,n2,tail))
        if status == 'done':
            k.resetLabel()
            k.setLabelBlue('%s' % (prompt),protect=True)
            vr.exec_(command2,n1,n2,tail)
        elif status == 'oops':
            # ring bell?
            if trace: g.trace('invalid char') ###
        c.bodyWantsFocus()
.. @+node:ekr.20061031131434.74: *3* class keyHandlerClass
class keyHandlerClass:

    '''A class to support emacs-style commands.'''

    @others
.. @+node:ekr.20061031131434.75: *4*  k.Birth
.. @+node:ekr.20061031131434.76: *5* k.__init__
def __init__ (self,c):

    '''Create a key handler for c.'''

    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: print('k.__init__')

    self.c = c
    self.dispatchEvent = None
    self.inited = False         # Set at end of finishCreate.
    self.swap_mac_keys = False  #### How to init this ????
    self.w = None
            # Note: will be None for nullGui.

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '

    # Access to data types defined in leoKeys.py
    self.KeyStroke = g.KeyStroke

    # Define all ivars...
    self.defineExternallyVisibleIvars()
    self.defineInternalIvars()
    self.defineSettingsIvars()

    if g.new_modes:
        self.modeController = ModeController(c)

    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None # Set by AutoCompleter.start.

    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction() # 2011/02/09
.. @+node:ekr.20061031131434.78: *5* k.defineExternallyVisibleIvars
def defineExternallyVisibleIvars(self):

    self.abbrevOn = False
        # True: abbreviations are on.
    self.arg = ''
        # The value returned by k.getArg.
    self.argSelectedText = '' # The selected text in state 0.
    self.commandName = None # The name of the command being executed.
    self.funcReturn = None # For k.simulateCommand
    self.getArgEscapeFlag = False # A signal that the user escaped getArg in an unusual way.
    self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
    self.inputModeBindings = {}
    self.inputModeName = '' # The name of the input mode, or None.
    self.inverseCommandsDict = {}
        # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
    self.modePrompt = '' # The mode promopt.
    self.negativeArg = False
    self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
    # self.regx = g.bunch(iter=None,key=None)
    self.repeatCount = None
    self.state = g.bunch(kind=None,n=None,handler=None)
.. @+node:ekr.20061031131434.79: *5* k.defineInternalIvars
def defineInternalIvars(self):

    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.

    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of ShortcutInfo's.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are ShortcutInfo's.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;

    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    self.mb_help = False

    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.fullCommandKey = None
    self.universalArgKey = None

    # Keepting track of the characters in the mini-buffer...
    self.arg_completion = True
    self.mb_event = None
    self.mb_history = []
    self.mb_prefix = ''
    self.mb_tabListPrefix = ''
    self.mb_tabList = []
    self.mb_tabListIndex = -1
    self.mb_prompt = ''

    self.func = None
    self.previous = []
    self.stroke = None

    # For onIdleTime...
    self.idleCount = 0

    # For modes...
    self.afterGetArgState = None
    self.argTabList = []
    self.getArgEscapes = []
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
.. @+node:ekr.20080509064108.7: *5* k.defineMultiLineCommands
def defineMultiLineCommands (self):

    k = self

    k.multiLineCommandList = [
        # editCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # keyHandlerCommandsClass
        'repeat-complex-command',
        # killBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # queryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # rectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # registerCommandsClass
        'jump-to-register',
        'point-to-register',
        # searchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
.. @+node:ekr.20120217070122.10479: *5* k.defineSettingIvars
def defineSettingsIvars(self):

    # Part 1: These were in the ctor.
    c = self.c
    getBool  = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter           = getBool('enable_autocompleter_initially')
    self.enable_calltips                = getBool('enable_calltips_initially')
    self.ignore_caps_lock               = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color    = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_foreground_color    = getColor('minibuffer_foreground_color') or 'black'
    self.minibuffer_warning_color       = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color         = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys                  = getBool('swap_mac_keys')

    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings       = c.config.getBool('enable_alt_ctrl_bindings')

    # Part 2: These were in finishCreate.

    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body_text_background_color') or 'white'
    fg = c.config.getColor('body_text_foreground_color') or 'black'

    self.command_mode_bg_color    = getColor('command_mode_bg_color') or bg
    self.command_mode_fg_color    = getColor('command_mode_fg_color') or fg
    self.insert_mode_bg_color     = getColor('insert_mode_bg_color') or bg
    self.insert_mode_fg_color     = getColor('insert_mode_fg_color') or fg
    self.overwrite_mode_bg_color  = getColor('overwrite_mode_bg_color') or bg
    self.overwrite_mode_fg_color  = getColor('overwrite_mode_fg_color') or fg
    self.unselected_body_bg_color = getColor('unselected_body_bg_color') or bg
    self.unselected_body_fg_color = getColor('unselected_body_fg_color') or bg

    # g.trace(self.c.shortFileName())
.. @+node:ekr.20080509064108.6: *5* k.defineSingleLineCommands
def defineSingleLineCommands (self):

    k = self

    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # editCommandsClass
        'back-to-indentation',
        'back-to-home', # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # keyHandlerCommandsClass
        # 'auto-complete',
        'negative-argument',
        'number-command',
        'number-command-0',
        'number-command-1',
        'number-command-2',
        'number-command-3',
        'number-command-4',
        'number-command-5',
        'number-command-6',
        'number-command-7',
        'number-command-8',
        'universal-argument',
        # killBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # macroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere',              # 2011/06/07
        'set-find-node-only',               # 2011/06/07
        'set-find-suboutline-only',         # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
        # registerCommandsClass
        'append-to-register',
        'copy-to-register',
        'insert-register',
        'prepend-to-register',
    ]
.. @+node:ekr.20070123085931: *5* k.defineSpecialKeys
def defineSpecialKeys (self):

    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''

    k = self

    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&" : "ampersand",
        "^" : "asciicircum",
        "~" : "asciitilde",
        "*" : "asterisk",
        "@" : "at",
        "\\": "backslash",
        "|" : "bar",
        "{" : "braceleft",
        "}" : "braceright",
        "[" : "bracketleft",
        "]" : "bracketright",
        ":" : "colon",      # removed from code.
        "," : "comma",
        "$" : "dollar",
        "=" : "equal",
        "!" : "exclam",     # removed from code.
        ">" : "greater",
        "<" : "less",
        "-" : "minus",
        "#" : "numbersign",
        '"' : "quotedbl",
        "'" : "quoteright",
        "(" : "parenleft",
        ")" : "parenright", # removed from code.
        "%" : "percent",
        "." : "period",     # removed from code.
        "+" : "plus",
        "?" : "question",
        "`" : "quoteleft",
        ";" : "semicolon",
        "/" : "slash",
        " " : "space",      # removed from code.
        "_" : "underscore",
    }

    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s

    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict:
        k.guiBindNamesInverseDict [k.guiBindNamesDict.get(key)] = key
.. @+node:ekr.20070123143428: *5* k.defineTkNames
def defineTkNames (self):

    k = self

    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left','Right','Up','Down',
        # Page up/down keys.
        'Next','Prior',
        # Home end keys.
        'Home','End'
        # Modifier keys.
        'Caps_Lock','Num_Lock',
        # F-keys.
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        # All others.
        'Begin','Break','Clear','Delete','Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace','Linefeed','Return','Tab',
    )

    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp'    : 'BackSpace', # Dubious: should be '\b'
        'dnarrow' : 'Down',
        'esc'     : 'Escape',
        'ltarrow' : 'Left',
        'pageup'  : 'Prior',
        'pagedn'  : 'Next',
        'rtarrow' : 'Right',
        'uparrow' : 'Up',
    }

    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict [s.lower()] = s

@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
.. @+node:ekr.20061031131434.80: *5* k.finishCreate & helpers
def finishCreate (self):

    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''

    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: print('k.finishCreate')

    k = self ; c = k.c
    self.w = c.frame.miniBufferWidget
        # Will be None for nullGui.

    k.createInverseCommandsDict()
    k.makeAllBindings()
    self.inited = True

    k.setDefaultInputState()
    k.resetLabel()
.. @+node:ekr.20061031131434.81: *6* createInverseCommandsDict
def createInverseCommandsDict (self):

    '''Add entries to k.inverseCommandsDict using c.commandDict.

    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict:
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))

        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())
.. @+node:ekr.20061101071425: *5* oops
def oops (self):

    g.trace('Should be defined in subclass:',g.callers(4))
.. @+node:ekr.20110209093958.15413: *5* setDefaultEditingKeyAction (New)
def setDefaultEditingAction (self):

    k = self ; c = k.c

    action = c.config.getString('default_editing_state') or 'insert'
    action.lower()

    if action not in ('command','insert','overwrite'):
        g.trace('ignoring default_editing_state: %s' % (action))
        action = 'insert'

    self.defaultEditingAction = action
.. @+node:ekr.20061031131434.82: *5* setDefaultUnboundKeyAction
def setDefaultUnboundKeyAction (self,allowCommandState=True):

    k = self ; c = k.c

    # g.trace(g.callers())

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()

    if defaultAction == 'command' and not allowCommandState:
        self.unboundKeyAction = 'insert'
    elif defaultAction in ('command','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % (defaultAction))
        self.unboundKeyAction = 'insert'

    # g.trace(self.unboundKeyAction)

    self.defaultUnboundKeyAction = self.unboundKeyAction

    k.setInputState(self.defaultUnboundKeyAction)
.. @+node:ekr.20061031131434.88: *4* k.Binding
.. @+node:ekr.20061031131434.89: *5* k.bindKey & helpers
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False,tag=None):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.

    tag gives the source of the binding.

    '''

    trace = False and not g.unitTesting
    k = self
    if not k.check_bind_key(commandName,pane,shortcut):
        return False
    aList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %17s %s' % (pane,shortcut,tag,commandName))
    try:
        if not shortcut:
            stroke = None
        elif g.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s,stroke
        else:
            stroke = k.strokeFromSetting(shortcut)

        si = g.ShortcutInfo(kind=tag,pane=pane,
            func=callback,commandName=commandName,stroke=stroke)

        if shortcut: #####
            k.bindKeyToDict(pane,shortcut,si)
        if shortcut and not modeFlag:
            aList = k.remove_conflicting_definitions(
                aList,commandName,pane,shortcut)
            # 2013/03/02: a real bug fix.
        aList.append(si)
        if shortcut:
            assert stroke
            k.bindingsDict [stroke] = aList
            if trace: g.trace(shortcut,aList)
        return True
    except Exception: # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
.. @+node:ekr.20120130074511.10228: *6* k.check_bind_key
def check_bind_key(self,commandName,pane,shortcut):

     #k = self
    if not shortcut:
        return False
    assert g.isStroke(shortcut)

    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter','leave'):
        if shortcut.lower().find(s) > -1:
            g.warning('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut))
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    else:
        return True
.. @+node:ekr.20120130074511.10227: *6* k.kill_one_shortcut
def kill_one_shortcut (self,stroke):

    '''Update the dicts so that c.config.getShortcut(name) will return None
    for all names *presently* bound to the stroke.'''

    k = self ; c = k.c
    lm = g.app.loadManager
    # A crucial shortcut: inverting and uninverting dictionaries is slow.
    # Important: the comparison is valid regardless of the type of stroke.
    if stroke in (None,'None','none'):
        return
    assert g.isStroke(stroke),stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.ShortcutInfo)
    inv_d = lm.invert(d)
    # aList = inv_d.get(stroke,[])
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
.. @+node:ekr.20061031131434.92: *6* k.remove_conflicting_definitions
def remove_conflicting_definitions (self,aList,commandName,pane,shortcut):

    trace = False and not g.unitTesting
    k = self
    result = []
    for si in aList:
        assert g.isShortcutInfo(si),si
        if pane in ('button','all',si.pane):
            if trace:
                # This is too annoying to report here. See bug 951921.
                g.es_print('c for %s in %s' % (
                    si.stroke,k.c.shortFileName()))
                g.es_print('previous: %s new: %s' % (si.commandName,commandName))
            k.kill_one_shortcut(shortcut)
        else:
            result.append(si)
    return result
.. @+node:ekr.20061031131434.93: *6* k.bindKeyToDict
def bindKeyToDict (self,pane,stroke,si):

    '''Update k.masterBindingsDict for the stroke.'''

    # New in Leo 4.4.1: Allow redefintions.
    k = self
    assert g.isStroke(stroke),stroke
    d = k.masterBindingsDict.get(pane,{})
    d[stroke] = si
    k.masterBindingsDict [pane] = d
.. @+node:ekr.20061031131434.94: *6* k.bindOpenWith
def bindOpenWith (self,d):

    '''Register an open-with command.'''

    k = self ; c = k.c

    shortcut = d.get('shortcut')
    name = d.get('name')

    # g.trace(d)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,d=d):
        return c.openWith(d=d)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='all',verbose=False)
.. @+node:ekr.20061031131434.95: *5* k.checkBindings
def checkBindings (self):

    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''

    k = self ; c = k.c

    if not c.config.getBool('warn_about_missing_settings'): return

    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&','')
        if not c.config.exists(key,'shortcut'):
            if abbrev:
                g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))
.. @+node:ekr.20061031131434.97: *5* k.completeAllBindings
def completeAllBindings (self,w=None):

    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''

    # g.trace(w)

    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke),repr(stroke)
        k.makeMasterGuiBinding(stroke,w=w)
.. @+node:ekr.20061031131434.96: *5* k.completeAllBindingsForWidget
def completeAllBindingsForWidget (self,w):
    
    '''Make all a master gui binding for widget w.'''

    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke),repr(stroke)
        k.makeMasterGuiBinding(stroke,w=w)
.. @+node:ekr.20070218130238: *5* k.dumpMasterBindingsDict
def dumpMasterBindingsDict (self):
    
    '''Dump k.masterBindingsDict.'''

    k = self ; d = k.masterBindingsDict

    g.pr('\nk.masterBindingsDict...\n')

    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            si = d2.get(key2)
            assert g.isShortcutInfo(si),si
            g.pr('%20s %s' % (key2,si.commandName))
.. @+node:ekr.20061031131434.99: *5* k.initAbbrev & helper
def initAbbrev (self):

    k = self ; c = k.c ; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName,key)

.. @+node:ekr.20130924035029.12741: *6* k.initOneAbbrev
def initOneAbbrev (self,commandName,key):
    
    '''Enter key as an abbreviation for commandName in c.commandsDict.'''

    c,k = self.c,self
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s',key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            # g.trace(key,commandName,func.__name__)
            c.commandsDict [key] = func
            # k.inverseCommandsDict[func.__name__] = key
        else:
            g.warning('bad abbrev:',key,'unknown command name:',commandName)
.. @+node:ekr.20061031131434.101: *5* k.initSpecialIvars
def initSpecialIvars (self):

    '''Set ivars for special keystrokes from previously-existing bindings.'''

    k = self ; c = k.c
    trace = False or c.config.getBool('trace_bindings_verbose')
    warn  = c.config.getBool('warn_about_missing_settings')

    for ivar,commandName in (
        ('fullCommandKey',  'full-command'),
        ('abortAllModesKey','keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
        ('autoCompleteForceKey','auto-complete-force'),
    ):
        junk, aList = c.config.getShortcut(commandName)
        aList,found = aList or [], False
        for pane in ('text','all'):
            for si in aList:
                assert g.isShortcutInfo(si),si
                if si.pane == pane:
                    if trace: g.trace(commandName,si.stroke)
                    setattr(k,ivar,si.stroke)
                    found = True; break
        if not found and warn:
            g.trace('no setting for %s' % commandName)
.. @+node:ekr.20061031131434.98: *5* k.makeAllBindings
def makeAllBindings (self):
    
    '''Make all key bindings in all of Leo's panes.'''

    k = self ; c = k.c
    k.bindingsDict = {}
    if g.new_modes:
        k.modeController.addModeCommands()
    else:
        k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    k.completeAllBindings()
    k.checkBindings()
.. @+node:ekr.20061031131434.102: *5* k.makeBindingsFromCommandsDict & helper
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if trace:
        g.trace('makeBindingsFromCommandsDict entry')
        t1 = time.time()

    # Step 1: Create d2.
    # Keys are strokes. Values are lists of si with si.stroke == stroke.
    d = c.commandsDict
    d2 = g.TypedDictOfLists(
        name='makeBindingsFromCommandsDict helper dict',
        keyType=g.KeyStroke,valType=g.ShortcutInfo)

    for commandName in sorted(d.keys()):
        command = d.get(commandName)
        key, aList = c.config.getShortcut(commandName)
        for si in aList:
            assert isinstance(si,g.ShortcutInfo)
            # Important: si.stroke is already canonicalized.
            stroke = si.stroke
            si.commandName = commandName
            if stroke:
                assert g.isStroke(stroke)
                d2.add(stroke,si)

    # Step 2: make the bindings.
    if trace: t2 = time.time()

    for stroke in sorted(d2.keys()):
        aList2 = d2.get(stroke)
        for si in aList2:
            assert isinstance(si,g.ShortcutInfo)
            commandName = si.commandName
            command = c.commandsDict.get(commandName)
            tag = si.kind
            pane = si.pane
            if stroke and not pane.endswith('-mode'):
                k.bindKey(pane,stroke,command,commandName,tag=tag)

    if trace:
        t3 = time.time()
        g.trace('%0.2fsec' % (t2-t1))
        g.trace('%0.2fsec' % (t3-t2))
.. @+node:ekr.20061031131434.103: *5* k.makeMasterGuiBinding
def makeMasterGuiBinding (self,stroke,w=None):

    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''

    k = self ; c = k.c ; f = c.frame
    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas = f.tree and hasattr(f.tree,'canvas') and f.tree.canvas   or None
        widgets = (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(stroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [stroke] = aList
.. @+node:ekr.20061031131434.104: *4* k.Dispatching
.. @+node:ekr.20061031131434.111: *5* fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    trace = False and not g.unitTesting
    verbose = True
    k = self ; c = k.c
    if c.vim_mode:
        return k.getVimArg(event)
    recording = c.macroCommands.recordingMacro
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    c.check_event(event)
    ch = char = event and event.char or ''
    stroke = event and event.stroke or None
    if trace and verbose: g.trace(g.callers())
    if trace: g.trace('recording',recording,'state',state,char)
    if recording:
        c.macroCommands.startRecordingMacro(event)
    if state > 0:
        k.setLossage(char,stroke)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif char == 'Ins' or k.isFKey(char):
        pass
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n','Return'):
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif char in ('\t','Tab'):
        if trace and verbose: g.trace('***Tab')
        k.doTabCompletion(list(c.commandsDict.keys()),allow_empty_completion=True)
        c.minibufferWantsFocus()
    elif char in ('\b','BackSpace'):
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)
.. @+node:ekr.20061031131434.112: *6* callAltXFunction
def callAltXFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event and event.widget
        if hasattr(w,'permanent') and not w.permanent:
            g.es('Can not execute commands from headlines')
        else:
            c.widgetWantsFocusNow(event and event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(commandName)
    else:
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
.. @+node:ekr.20061031131434.113: *5* k.endCommand
def endCommand (self,commandName):

    '''Make sure Leo updates the widget following a command.

    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        if not k.inState():
            k.commandName = None
            c.editCommandsManager.initAllEditCommanders()
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # g.pr('endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers())
            k.newMinibufferWidget = None
.. @+node:ekr.20061031131434.114: *4* k.Externally visible commands
.. @+node:ekr.20061031131434.115: *5* digitArgument & universalArgument
def universalArgument (self,event):

    '''Prompt for a universal argument.'''
    k = self
    k.setLabelBlue('Universal Argument: ',protect=True)
    k.universalDispatcher(event)

def digitArgument (self,event):

    '''Prompt for a digit argument.'''
    k = self
    k.setLabelBlue('Digit Argument: ',protect=True)
    k.universalDispatcher(event)
.. @+node:ekr.20070613133500: *5* k.menuCommandKey
def menuCommandKey (self,event=None):

    # This method must exist, but it never gets called.
    pass 
.. @+node:ekr.20061031131434.117: *5* negativeArgument (redo?)
def negativeArgument (self,event):

    '''Prompt for a negative digit argument.'''

    g.trace('not ready yet')

    # k = self ; state = k.getState('neg-arg')

    # if state == 0:
        # k.setLabelBlue('Negative Argument: ',protect=True)
        # k.setState('neg-arg',1,k.negativeArgument)
    # else:
        # k.clearState()
        # k.resetLabel()
        # func = k.negArgFunctions.get(k.stroke)
        # if func:
            # func(event)
.. @+node:ekr.20061031131434.118: *5* numberCommand
def numberCommand (self,event,stroke,number):

    '''Enter a number prefix for commands.'''

    k = self ; c = self.c
    k.stroke = stroke
    w = event and event.widget
    k.universalDispatcher(event)
    g.app.gui.event_generate(c,chr(number),chr(number),w)
    return

def numberCommand0 (self,event):
    '''Execute command number 0.'''
    return self.numberCommand (event,None,0)

def numberCommand1 (self,event):
    '''Execute command number 1.'''
    return self.numberCommand (event,None,1)

def numberCommand2 (self,event):
    '''Execute command number 2.'''
    return self.numberCommand (event,None,2)

def numberCommand3 (self,event):
    '''Execute command number 3.'''
    return self.numberCommand (event,None,3)

def numberCommand4 (self,event):
    '''Execute command number 4.'''
    return self.numberCommand (event,None,4)

def numberCommand5 (self,event):
    '''Execute command number 5.'''
    return self.numberCommand (event,None,5)

def numberCommand6 (self,event):
    '''Execute command number 6.'''
    return self.numberCommand (event,None,6)

def numberCommand7 (self,event):
    '''Execute command number 7.'''
    return self.numberCommand (event,None,7)

def numberCommand8 (self,event):
    '''Execute command number 8.'''
    return self.numberCommand (event,None,8)

def numberCommand9 (self,event):
    '''Execute command number 9.'''
    return self.numberCommand (event,None,9)
.. @+node:ekr.20061031131434.119: *5* k.printBindings & helper
def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[ ] leoSettings.leo
[D] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] mode

'''

    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend,c.tab_width)
    data = []
    for stroke in sorted(d):
        assert g.isStroke(stroke),stroke
        aList = d.get(stroke,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            s1 = '' if si.pane=='all' else si.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = si.commandName
            s4 = si.kind or '<no hash>'
            data.append((s1,s2,s3,s4),)

    # Print keys by type:
    result = []
    result.append('\n'+legend)
    for prefix in (
        'Alt+Ctrl+Shift','Alt+Ctrl','Alt+Shift','Alt', # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift','Ctrl+Meta','Ctrl+Shift','Ctrl', # Ctrl+Key: done by Ctrl.
        'Meta+Key','Meta+Shift','Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1,s2,s3,s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append('***** %s...\n' % prefix)
        self.printBindingsHelper(result,data2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result,data,prefix=None)
    if not g.unitTesting:
        g.es('',''.join(result),tabName=tabName)
    k.showStateAndMode()
    return result # for unit test.
.. @+node:ekr.20061031131434.120: *6* printBindingsHelper
def printBindingsHelper (self,result,data,prefix):

    lm = g.app.loadManager

    data.sort(key=lambda x: x[1])

    data2,n = [],0
    for pane,key,commandName,kind in data:
        key = key.replace('+Key','')
        # g.trace(key,kind)
        letter = lm.computeBindingLetter(kind)
        pane = '%s: ' % (pane) if pane else ''
        left = pane+key # pane and shortcut fields
        n = max(n,len(left))
        data2.append((letter,left,commandName),)

    for z in data2:
        letter,left,commandName = z
        result.append('%s %*s %s\n' % (letter,-n,left,commandName))

    if data:
        result.append('\n')
.. @+node:ekr.20120520174745.9867: *5* k.printButtons
def printButtons (self,event=None):

    '''Print all @button and @command commands, their bindings and their source.'''

    k = self ; c = k.c
    tabName = '@buttons && @commands'
    c.frame.log.clearTab(tabName)

    def put(s):
        g.es('',s,tabName=tabName)

    data = []
    for aList in [c.config.getButtons(),c.config.getCommands()]:
        for z in aList:
            p,script = z
            c = p.v.context
            tag = 'M' if c.shortFileName().endswith('myLeoSettings.leo') else 'G'
            data.append((p.h,tag),)

    for aList in [g.app.config.atLocalButtonsList,g.app.config.atLocalCommandsList]:
        for p in aList:
            data.append((p.h,'L'),)

    result = ['%s %s' % (z[1],z[0]) for z in sorted(data)]
    put('\n'.join(result))

    legend = '''\

legend:
G leoSettings.leo
L local .leo File
M myLeoSettings.leo
'''
    legend = g.adjustTripleString(legend,c.tab_width)
    put(''.join(legend))
.. @+node:ekr.20061031131434.121: *5* k.printCommands
def printCommands (self,event=None):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c ; tabName = 'Commands'

    c.frame.log.clearTab(tabName)

    inverseBindingDict = k.computeInverseBindingDict()
    data,n = [],0
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName,[('',''),])
        for z in dataList:
            pane, key = z
            pane = '%s ' % (pane) if pane != 'all:' else ''
            key = k.prettyPrintKey(key).replace('+Key','')
            s1 = pane + key
            s2 = commandName
            n = max(n,len(s1))
            data.append((s1,s2),)

    # This isn't perfect in variable-width fonts.
    lines = ['%*s %s\n' % (-n,s1,s2) for s1,s2 in data]
    g.es('',''.join(lines),tabName=tabName)
.. @+node:ekr.20061031131434.122: *5* k.repeatComplexCommand & helper
def repeatComplexCommand (self,event):

    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command',1,handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.warning('no previous command')

.. @+node:ekr.20131017100903.16689: *6* repeatComplexCommandHelper
def repeatComplexCommandHelper (self,event):

    k = self ; c = k.c
    char = event and event.char or ''
    if char in ('\n','Return') and k.mb_history:
        last = k.mb_history [0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict [last](event)
    else:
        # g.trace('oops')
        return k.keyboardQuit()
.. @+node:ekr.20061031131434.123: *5* set-xxx-State
def setCommandState (self,event):
    '''Enter the 'command' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('command',set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setInsertState (self,event):
    '''Enter the 'insert' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('insert',set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setOverwriteState (self,event):
    '''Enter the 'overwrite' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('overwrite',set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()
.. @+node:ekr.20061031131434.124: *5* toggle-input-state
def toggleInputState (self,event=None):

    '''The toggle-input-state command.'''

    k = self ; c = k.c
    default = c.config.getString('top_level_unbound_key_action') or 'insert'
    state = k.unboundKeyAction

    if default == 'insert':
        state = g.choose(state=='insert','command','insert')
    elif default == 'overwrite':
        state = g.choose(state=='overwrite','command','overwrite')
    else:
        state = g.choose(state=='command','insert','command') # prefer insert to overwrite.

    k.setInputState(state)
    k.showStateAndMode()
.. @+node:ekr.20061031131434.125: *4* k.Externally visible helpers
.. @+node:ekr.20061031131434.128: *5* k.getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):
    '''
    Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''
    trace = False and not g.app.unitTesting
    k = self ; c = k.c
    state = k.getState('getArg')
    c.check_event(event)
    # Remember these events also.
    if c.macroCommands.recordingMacro and state > 0:
        c.macroCommands.startRecordingMacro(event)
    char = event and event.char or ''
    if state > 0:
        k.setLossage(char,stroke)
    if trace: g.trace(
        'state',state,'char',repr(char),'stroke',repr(stroke),
        'isPlain',k.isPlainKey(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif (
        char in ('\n','Return',) or
        k.oneCharacterArg or 
        stroke and stroke in k.getArgEscapes or
        char == '\t' and char in k.getArgEscapes # The Find Easter Egg.
    ):
        if trace:
            g.trace('***escape***','char',repr(char),
                stroke,k.getArgEscapes,k.afterGetArgState)
            # g.trace(g.callers())
        if char == '\t' and char in k.getArgEscapes:
            k.getArgEscapeFlag = True
        if stroke and stroke in k.getArgEscapes:
            k.getArgEscapeFlag = True
        if k.oneCharacterArg:
            k.arg = char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        if trace: g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif char in('\t','Tab'):
        if trace: g.trace('***tab***')
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif char in ('\b','BackSpace'):
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        pass
        # 2011/03/01: ignore F-keys. Ignoring all except plain keys would kill unicode searches.
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
.. @+node:ekr.20061031131434.129: *6* << init altX vars >> k.getArg
k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
.. @+node:ekr.20131112152450.16537: *5* k.getVimArg
def getVimArg(self,event,specialStroke=None,specialFunc=None):
    '''Handle all keys in the minibuffer when c.vim_mode is True.'''
    ### help=False,
    ### helpHandler=None
    trace = False # and not g.unitTesting
    verbose = False
    k,c = self,self.c
    k = self ; c = k.c
    vr = c.vimCommands
    prompt = 'Normal Mode: ' ###
    recording = c.macroCommands.recordingMacro
    state = k.getState('vim-mode')
    if trace: g.trace('**',k.getLabel(),state)
    c.check_event(event)
    ch = char = event and event.char or ''
    stroke = event and event.stroke or None
    if trace: g.trace('state',state,char) # 'recording',recording,
    # if recording:
        # c.macroCommands.startRecordingMacro(event)
    # if state > 0:
        # k.setLossage(char,stroke)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('vim-mode',1,handler=k.getVimArg)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = None ### help
        k.mb_helpHandler = None ### helpHandler
    # Unlike fullCommand, we *do* have a key.
    elif char == 'Ins' or k.isFKey(char):
        pass
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n','Return'):
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        k.callAltXFunction(k.mb_event)
        # if k.mb_help:
            # s = k.getLabel()
            # commandName = s[len(helpPrompt):].strip()
            # k.clearState()
            # k.resetLabel()
            # if k.mb_helpHandler: k.mb_helpHandler(commandName)
        # else:
            # k.callAltXFunction(k.mb_event)
    # elif char in ('\t','Tab'):
        # if trace and verbose: g.trace('***Tab')
        # k.doTabCompletion(list(c.commandsDict.keys()),allow_empty_completion=True)
        # c.minibufferWantsFocus()
    elif char in ('\b','BackSpace'):
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(list(c.commandsDict.keys()))
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        if trace: g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        if trace: g.trace('new prefix',k.mb_tabListPrefix)
    # Examine each keystroke to see if we have a complete command.
    if state != 0:
        command = k.getLabel(ignorePrompt=True)
        status,n1,command2,n2,tail = vr.scan(command)
        if trace: g.trace('status: %s %s command: %s n1: %s n2: %s tail: %s' % (
            status,command,command2,n1,n2,tail))
        if status == 'done':
            k.resetLabel()
            k.setLabelBlue('%s' % (prompt),protect=True)
            vr.exec_(command2,n1,n2,tail)
        elif status == 'oops':
            # ring bell?
            if trace: g.trace('invalid char') ###
        c.bodyWantsFocus()
.. @+node:ekr.20061031131434.130: *5* k.keyboardQuit
def keyboardQuit (self,event=None,setFocus=True,mouseClick=False):

    '''This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    if trace: g.trace(g.callers())

    if g.app.quitting:
        return

    # 2011/05/30: We may be called from Qt event handlers.
    # Make sure to end editing!
    c.endEditing() 

    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')

    if k.inputModeName:
        k.endMode()

    # Complete clear the state.
    k.state.kind = None
    k.state.n = None

    k.clearState()
    k.resetLabel()

    if setFocus:
        c.bodyWantsFocus()

    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    # This was what caused the unwanted scrolling.
    k.showStateAndMode(setFocus=setFocus)
.. @+node:ekr.20061031131434.126: *5* k.manufactureKeyPressForCommandName (changed)
def manufactureKeyPressForCommandName (self,w,commandName):

    '''Implement a command by passing a keypress to the gui.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    stroke = k.getShortcutForCommandName(commandName)
    if not stroke:
        shortcut = None
    elif g.isStroke(stroke):
        shortcut = stroke.s
    else:
        stroke = k.strokeFromSetting(stroke)
        shortcut = stroke.s

    assert g.isString(shortcut)

    if trace and shortcut: g.trace(
        'shortcut',repr(shortcut),'commandName',commandName)

    if shortcut and w:
        # g.trace(stroke)
        g.app.gui.set_focus(c,w)
        g.app.gui.event_generate(c,None,shortcut,w)
    else:
        message = 'no shortcut for %s' % (commandName)
        if g.app.unitTesting:
            raise AttributeError(message)
        else:
            g.error(message)
.. @+node:ekr.20071212104050: *5* k.overrideCommand
def overrideCommand (self,commandName,func):

    # Override entries in c.k.masterBindingsDict
    k = self
    d = k.masterBindingsDict
    for key in d:
        d2 = d.get(key)
        for key2 in d2:
            si = d2.get(key2)
            assert g.isShortcutInfo(si),si
            if si.commandName == commandName:
                si.func=func
                d2[key2] = si
.. @+node:ekr.20061031131434.131: *5* k.registerCommand
def registerCommand (self,commandName,shortcut,func,
    pane='all',verbose=False, wrap=True):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.

    '''

    trace = False and not g.unitTesting ; verbose = False
    k = self ; c = k.c

    if trace: g.trace(commandName,shortcut)

    if wrap:
        func = c.universalCallback(func)
    f = c.commandsDict.get(commandName)

    if f and f.__name__ != 'dummyCallback' and trace and verbose:
        g.error('redefining',commandName)

    assert not g.isStroke(shortcut)

    c.commandsDict [commandName] = func
    fname = func.__name__
    k.inverseCommandsDict [fname] = commandName
    if trace and fname != 'minibufferCallback':
        g.trace('leoCommands %24s = %s' % (fname,commandName))

    if shortcut:
        if trace: g.trace('shortcut',shortcut)
        stroke = k.strokeFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a stroke from leoSettings.leo.
        stroke = None
        junk,aList = c.config.getShortcut(commandName)
        for si in aList:
            assert g.isShortcutInfo(si),si
            assert g.isStrokeOrNone(si.stroke)
            if si.stroke and not si.pane.endswith('-mode'):
                # if trace: g.trace('*** found',si)
                stroke = si.stroke
                break

    if stroke:
        if trace: g.trace('stroke',stroke,'pane',pane,commandName)
        ok = k.bindKey (pane,stroke,func,commandName,tag='register-command') # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if trace and verbose and ok and not g.app.silentMode:
            g.blue('','@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)))
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
    elif trace and verbose and not g.app.silentMode:
        g.blue('','@command: %s' % (commandName))

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
.. @+node:ekr.20061031131434.127: *5* k.simulateCommand
def simulateCommand (self,commandName):

    k = self ; c = k.c

    commandName = commandName.strip()
    if not commandName: return

    aList = commandName.split(None)
    if len(aList) == 1:
        k.givenArgs = []
    else:
        commandName = aList[0]
        k.givenArgs = aList[1:]

    # g.trace(commandName,k.givenArgs)
    func = c.commandsDict.get(commandName)

    if func:
        # g.trace(commandName,func.__name__)
        if commandName.startswith('specialCallback'):
            event = None # A legacy function.
        else: # Create a dummy event as a signal.
            event = g.app.gui.create_key_event(c,None,None,None)

        k.masterCommand(event=event,func=func)
        if c.exists:
            return k.funcReturn
        else:
            return None
    else:
        if g.app.unitTesting:
            raise AttributeError
        else:
            g.error('simulateCommand: no command for %s' % (commandName))
            return None
.. @+node:ekr.20061031131434.145: *4* k.Master event handlers
.. @+node:ekr.20061031131434.105: *5* k.masterCommand & helpers
def masterCommand (self,commandName=None,event=None,func=None,stroke=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.
    This returns None, but may set k.funcReturn.
    '''

    k = self ; c = k.c
    trace = (False or g.trace_masterCommand) and not g.unitTesting
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')
    if event: c.check_event(event)
    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    char = ch = event and event.char or ''
    # 2011/10/28: compute func if not given.
    if commandName and not func:
        func = c.commandsDict.get(commandName)
    # Important: it is *not* an error for func to be None.
    k.func = func
    commandName = commandName or func and func.__name__ or '<no function>'
    k.funcReturn = None # For unit testing.
    << define specialKeysyms >>
    special = char in specialKeysyms
    inserted = not special
    if trace: # Useful.
        g.trace('stroke: %s ch: %s func: %s' % (
            stroke,repr(ch),func and func.__name__))
    if inserted:
        k.setLossage(ch,stroke)
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startRecordingMacro(event)
        # 2011/06/06: Show the key, if possible.
    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return
    if special: # Don't pass these on.
        return
    # if k.regx.iter:
        # try:
            # k.regXKey = char
            # k.regx.iter.next() # EKR: next() may throw StopIteration.
        # except StopIteration:
            # pass
        # return
    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event,stroke)
        if expanded: return
    if func: # Func is an argument.
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
    elif k.inState():
        pass #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
.. @+node:ekr.20061031131434.106: *6* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
.. @+node:ekr.20061031131434.110: *6* k.handleDefaultChar
def handleDefaultChar(self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting
    verbose = False
    if trace and verbose:
        g.trace('widget_name',name,'stroke',stroke,
        'enable alt-ctrl',self.enable_alt_ctrl_bindings)
    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        # not k.enable_alt_ctrl_bindings and # Old code: this isn't an alt-ctrl key!
        k.ignore_unbound_non_ascii_keys and # Bug fix: 2011/11/23
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
    elif name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
    elif name.startswith('log'):
        # Bug fix: 2011/11/21: Because of universal bindings
        # we may not be able to insert anything into w.
        import leo.core.leoFrame as leoFrame
        if issubclass(w.__class__,leoFrame.HighLevelInterface):
            i = w.logCtrl.getInsertPoint()
            if not stroke:
                stroke = event and event.stroke
            if stroke:
                s = stroke.toGuiChar()
                w.logCtrl.insert(i,s)
        elif trace: g.trace('Not a HighLevelInterface object',w)
    else:
        pass # Ignore the event
.. @+node:ekr.20061031131434.146: *5* k.masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event):

    '''This is the handler for almost all key bindings.'''

    trace = (False or g.trace_masterKeyHandler) and not g.app.unitTesting
    traceGC = g.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True
    k,c = self,self.c
    c.check_event(event)
    << define vars >>
    assert g.isStrokeOrNone(stroke)
    if char in special_keys:
        if trace and verbose: g.trace('char',char)
        return None

    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:',repr(stroke),'char:',
        repr(event and event.char),
        'ch:',repr(event and event.char),
        'state',state,'state2',k.unboundKeyAction)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if hasattr(c,'screenCastController') and c.screenCastController:
            c.screenCastController.quit()
        if c.macroCommands.recordingMacro:
            c.macroCommands.endMacro()
        else:
            k.masterCommand(commandName='keyboard-quit',
                event=event,func=k.keyboardQuit,stroke=stroke)
        return
    if k.inState():
        if trace: g.trace('   state %-15s %s' % (state,stroke))
        done = k.doMode(event,state,stroke)
        if done: return

    if traceGC: g.printNewObjects('masterKey 2')

    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key',stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            k.handleUnboundKeys(event,char,stroke)
            return

    # 2011/02/08: Use getPandBindings for *all* keys.
    si = k.getPaneBinding(stroke,w)
    if si:
        assert g.isShortcutInfo(si),si
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound',stroke,si.func.__name__)
        k.masterCommand(event=event,
            commandName=si.commandName,func=si.func,stroke=si.stroke)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace: g.trace(' unbound',stroke)
        k.handleUnboundKeys(event,char,stroke)
.. @+node:ekr.20061031131434.147: *6* << define vars >>
w = event and event.widget
char = event and event.char or ''
stroke = event and event.stroke or None
# w_name = c.widget_name(w)
state = k.state.kind
special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1
isPlain =  k.isPlainKey(stroke)
.. @+node:ekr.20061031131434.108: *6* callStateFunction
def callStateFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; val = None 
    ch = event and event.char or ''
    stroke = event and event.stroke or ''
    if trace: g.trace(k.state.kind,'ch',ch,'stroke',stroke,
        'ignore_unbound_non_ascii_keys',k.ignore_unbound_non_ascii_keys)
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns',repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.error('callStateFunction: no state function for',k.state.kind)
    return val
.. @+node:ekr.20091230094319.6244: *6* doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self
    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete','vim-mode'):
        if k.handleMiniBindings(event,state,stroke):
            return True
    # Second, honor general modes.
    # Handle vim mode.
    if k.c.vim_mode and state in ('full-command','vim-mode'):
        if trace: g.trace('vim-mode',state)
        k.getVimArg(event)
        return True
    elif state == 'getArg':
        k.getArg(event,stroke=stroke)
        return True
    elif state == 'getFileName':
        k.getFileName(event)
        return True
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns',repr(val))
        return val != 'do-standard-keys'
    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert g.isShortcutInfo(si),si
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=si.commandName,func=si.func,
                modeName=state,nextMode=si.nextMode)
            return True
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            if 0: # 2012/05/20: I dislike this warning.
                g.warning('unbound key ends mode',stroke) # 2011/02/02
            k.endMode()
            return False
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler',handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True
.. @+node:ekr.20091230094319.6240: *6* getPaneBinding
def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    verbose = True
    k = self ; w_name = k.c.widget_name(w)
    # keyStatesTuple = ('command','insert','overwrite')
    state = k.unboundKeyAction
    assert g.isStroke(stroke)
    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))
    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command','insert','overwrite') and state == key or # 2010/02/09
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key,name,stroke,stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si),si
                    table = ('previous-line','next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case',si.commandName)
                    else:
                        if trace: g.trace('key: %7s name: %6s  found %s = %s' % (
                            key,name,repr(si.stroke),si.commandName))
                        return si
    return None
.. @+node:ekr.20061031131434.152: *6* handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = (False or g.trace_masterKeyHandler) and not g.app.unitTesting
    # Special case for bindings handled in k.getArg:
    assert g.isStroke(stroke),repr(stroke)
    if state in ('getArg','full-command'):
        if stroke in ('\b','BackSpace','\r','Linefeed','\n','Return','\t','Tab','Escape',):
            return False
        if k.isFKey(stroke):
            return False
    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si),si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane),si.commandName,stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName,event=event,func=si.func,stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True
    return False
.. @+node:ekr.20110209083917.16004: *6* isAutoCompleteChar
def isAutoCompleteChar (self,stroke):

    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''

    k = self ; state = k.unboundKeyAction

    assert g.isStrokeOrNone(stroke)

    if stroke and state in ('insert','overwrite'):
        for key in (state,'body','log','text','all'):
            d = k.masterBindingsDict.get(key,{})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                    assert g.isShortcutInfo(si),si
                    if si.commandName == 'auto-complete':
                        return True
    return False
.. @+node:ekr.20080510095819.1: *6* k.handleUnboundKeys
def handleUnboundKeys (self,event,char,stroke):

    trace = False and not g.unitTesting
    verbose = True
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    assert g.isStroke(stroke)
    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char),repr(stroke)))
    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))
    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode',stroke)
        return
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key',stroke)
        return
    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        k.masterCommand(event=event,stroke=stroke)
        return
    elif (not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char),repr(stroke))
        return
    elif k.ignore_unbound_non_ascii_keys and (
        len(char) > 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char),repr(stroke))
        return
    elif (
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore',stroke)
        return
    else:
        if trace: g.trace('no func',repr(char),repr(stroke))
        k.masterCommand(event=event,stroke=stroke)
        return
.. @+node:ekr.20061031170011.3: *4* k.Minibuffer
# These may be overridden, but this code is now gui-independent.
.. @+node:ekr.20061031131434.135: *5* k.minibufferWantsFocus
# def minibufferWantsFocus(self):

    # c = self.c
    # c.widgetWantsFocus(c.miniBufferWidget)
.. @+node:ekr.20061031170011.5: *5* k.getLabel
def getLabel (self,ignorePrompt=False):

    k = self ; w = self.w
    if not w: return ''

    s = w.getAllText()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''
.. @+node:ekr.20080408060320.791: *5* k.killLine
def killLine (self,protect=True):

    k = self
    w = k.w
    s = w.getAllText()
    s = s[:len(k.mb_prefix)]
    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n,n,insert=n)
    if protect:
        k.mb_prefix = s
.. @+node:ekr.20061031170011.6: *5* k.protectLabel
def protectLabel (self):

    k = self ; w = self.w
    if not w: return

    k.mb_prefix = w.getAllText()

.. @+node:ekr.20061031170011.7: *5* k.resetLabel
def resetLabel (self):

    k = self ; w = self.w
    k.setLabelGrey('')
    k.mb_prefix = ''

    if w:    
        w.setSelectionRange(0,0,insert=0)
        state = k.unboundKeyAction
        k.setLabelBlue(label='%s State' % (state.capitalize()),protect=True)
.. @+node:ekr.20061031170011.8: *5* k.setLabel
def setLabel (self,s,protect=False):

    trace = (False or g.trace_minibuffer) and not g.app.unitTesting
    k = self
    w = k.w
    if not w: return

    if trace: g.trace(repr(s),w)
    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n,n,insert=n)
    if protect:
        k.mb_prefix = s
.. @+node:ekr.20061031170011.9: *5* k.extendLabel
def extendLabel(self,s,select=False,protect=False):

    trace = False and not g.unitTesting

    k = self ; c = k.c ; w = self.w
    if not (w and s): return

    if trace: g.trace(s)

    c.widgetWantsFocusNow(w)

    w.insert('end',s)

    if select:
        i,j = k.getEditableTextRange()
        w.setSelectionRange(i,j,insert=j)

    if protect:
        k.protectLabel()
.. @+node:ekr.20080408060320.790: *5* k.selectAll
def selectAll (self):

    '''Select all the user-editable text of the minibuffer.'''

    w = self.w
    i,j = self.getEditableTextRange()
    w.setSelectionRange(i,j,insert=j)


.. @+node:ekr.20061031170011.10: *5* k.setLabelBlue
def setLabelBlue (self,label=None,protect=False):

    k = self ; w = k.w
    if not w: return

    # w.setBackgroundColor(self.minibuffer_background_color) # 'lightblue')

    w.setBothColors(
        self.minibuffer_background_color,
        self.minibuffer_foreground_color)

    if label is not None:
        k.setLabel(label,protect)
.. @+node:ekr.20061031170011.11: *5* k.setLabelGrey
def setLabelGrey (self,label=None):

    k = self ; w = self.w
    if not w: return

    w.setBackgroundColor(self.minibuffer_warning_color) # 'lightgrey')

    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
.. @+node:ekr.20080510153327.2: *5* k.setLabelRed
def setLabelRed (self,label=None,protect=False):

    k = self ; w = self.w
    if not w: return

    w.setBothColors(
        self.minibuffer_warning_color,
        self.minibuffer_error_color)

    if label is not None:
        k.setLabel(label,protect)
.. @+node:ekr.20061031170011.12: *5* k.updateLabel
def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''

    trace = False or g.trace_minibuffer and not g.app.unitTesting
    k = self ; c = k.c ; w = self.w
    ch = (event and event.char) or ''
    if trace: g.trace('ch',ch,'k.stroke',k.stroke)

    if ch and ch not in ('\n','\r'):
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange()
        ins = w.getInsertPoint()
        # g.trace(i,j,ins)
        if i != j:
            w.delete(i,j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) > len(k.mb_prefix):
                w.delete(i-1)
                i-=1
        else:
            w.insert(ins,ch)
            i = ins+1
.. @+node:ekr.20061031170011.13: *5* k.getEditableTextRange
def getEditableTextRange (self):

    k = self ; w = self.w
    s = w.getAllText()
    i = len(k.mb_prefix)
    j = len(s)
    return i,j
.. @+node:ekr.20120208064440.10190: *4* k.Modes (no change)
.. @+node:ekr.20061031131434.100: *5* k.addModeCommands (enterModeCallback)
def addModeCommands (self):

    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    trace = False and not g.unitTesting

    if trace: g.trace('(k)')

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.

    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        if trace: g.trace(f.__name__,key,'len(c.commandsDict.keys())',len(list(c.commandsDict.keys())))
.. @+node:ekr.20061031131434.157: *5* k.badMode
def badMode(self,modeName):

    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)
.. @+node:ekr.20061031131434.158: *5* k.createModeBindings
def createModeBindings (self,modeName,d,w):

    '''Create mode bindings for the named mode using dictionary d for w, a text widget.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    assert d.name().endswith('-mode')
    for commandName in d.keys():
        if commandName in ('*entry-commands*','*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:',commandName,'Referenced from',modeName)
            continue
        aList = d.get(commandName,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            stroke = si.stroke
            # Important: si.val is canonicalized.
            if stroke and stroke not in ('None','none',None):
                if trace:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        si.nextMode)

                assert g.isStroke(stroke)

                k.makeMasterGuiBinding(stroke)

                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.ShortcutInfo(
                    kind = 'mode<%s>' % (modeName), # 2012/01/23
                    commandName=commandName,
                    func=func,
                    nextMode=si.nextMode,
                    stroke=stroke)
                k.masterBindingsDict [ modeName ] = d2
.. @+node:ekr.20120208064440.10179: *5* k.endMode
def endMode(self):

    k = self ; c = k.c

    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode') # Changes focus to the body pane

    k.endCommand(k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode() # Restores focus.

    if w:
        c.widgetWantsFocusNow(w)
.. @+node:ekr.20061031131434.160: *5* k.enterNamedMode
def enterNamedMode (self,event,commandName):

    k = self ; c = k.c
    modeName = commandName[6:]
    c.inCommand = False # Allow inner commands in the mode.
    k.generalModeHandler(event,modeName=modeName)
.. @+node:ekr.20061031131434.161: *5* k.exitNamedMode
def exitNamedMode (self,event=None):

    '''Exit an input mode.'''

    k = self

    if k.inState():
        k.endMode()

    k.showStateAndMode()
.. @+node:ekr.20061031131434.165: *5* k.modeHelp & helper (revise helper)
def modeHelp (self,event):

    '''The mode-help command.

    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.'''

    k = self ; c = k.c
    c.endEditing()
    # g.trace(k.inputModeName)
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-'+k.inputModeName)
        k.modeHelpHelper(d)
    if not k.silentMode:
        c.minibufferWantsFocus()
.. @+node:ekr.20061031131434.166: *6* modeHelpHelper
def modeHelpHelper (self,d):

    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data,n = [],0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*','*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for si in aList:
                assert g.isShortcutInfo(si),si
                stroke = si.stroke
                if stroke not in (None,'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n,len(s1))
                    data.append((s1,s2),)

    data.sort()
    modeName = k.inputModeName.replace('-',' ')
    if modeName.endswith('mode'):
        modeName = modeName[:-4].strip()

    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('','%s\n\n' % (prompt.kind.strip()),tabName=tabName)
    else:
        g.es('','%s mode\n\n' % modeName,tabName=tabName)

    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('','%*s %s' % (n,s1,s2),tabName=tabName)
.. @+node:ekr.20061031131434.164: *5* k.reinitMode (call k.createModeBindings???)
def reinitMode (self,modeName):

    k = self
    d = k.modeBindingsDict
    k.inputModeName = modeName
    w = g.choose(k.silentMode,k.modeWidget,k.w)
    k.createModeBindings(modeName,d,w)
    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName+': ',protect=True)
.. @+node:ekr.20120208064440.10199: *5* k.generalModeHandler (OLD)
def generalModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None,prompt=None):

    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting

    if trace: g.trace(modeName,'state',state)

    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        self.initMode(event,modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c,None,None,k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName,1,handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event,nextMode) # Enter another mode.
.. @+node:ekr.20061031131434.156: *4* k.Modes (changed)
.. @+node:ekr.20061031131434.163: *5* k.initMode (changed)
def initMode (self,event,modeName):

    k = self ; c = k.c
    trace = (False or g.trace_modes) and not g.unitTesting

    if not modeName:
        g.trace('oops: no modeName')
        return

    if g.new_modes:
        mode = k.modeController.getMode(modeName)
        if mode:
            mode.initMode()
        else:
            g.trace('***** oops: no mode',modeName)
    else:
        d = g.app.config.modeCommandsDict.get('enter-'+modeName)
        if not d:
            self.badMode(modeName)
            return
        else:
            k.modeBindingsDict = d
            si = d.get('*command-prompt*')
            if si:
                prompt = si.kind # A kludge.
            else:
                prompt = modeName
            if trace: g.trace('modeName: %s prompt: %s d.keys(): %s' % (
                modeName,prompt,sorted(list(d.keys()))))

        k.inputModeName = modeName
        k.silentMode = False

        aList = d.get('*entry-commands*',[])
        if aList:
            for si in aList:
                assert g.isShortcutInfo(si),si
                commandName = si.commandName
                if trace: g.trace('entry command:',commandName)
                k.simulateCommand(commandName)
                # Careful, the command can kill the commander.
                if g.app.quitting or not c.exists: return
                # New in Leo 4.5: a startup command can immediately transfer to another mode.
                if commandName.startswith('enter-'):
                    if trace: g.trace('redirect to mode',commandName)
                    return

        # Create bindings after we know whether we are in silent mode.
        w = g.choose(k.silentMode,k.modeWidget,k.w)
        k.createModeBindings(modeName,d,w)
        k.showStateAndMode(prompt=prompt)
.. @+node:ekr.20120208064440.10201: *5* k.NEWgeneralModeHandler (NEW MODES)
def NEWgeneralModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None,prompt=None):

    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting
    if trace: g.trace(modeName,'state',state)

    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        self.initMode(event,modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c,None,None,k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName,1,handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event,nextMode) # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                # if g.app.quitting or not c.exists: return
.. @+node:ekr.20061031131434.167: *4* k.Shared helpers
.. @+node:ekr.20061031131434.175: *5* k.computeCompletionList
# Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace,allow_empty_completion=False):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)
    c.frame.log.clearTab(tabName)

    if trace:
        g.trace('command',command)
        g.trace('common_prefix',common_prefix)
        g.trace('k.mb_tabList',k.mb_tabList)

    if not k.mb_tabList and allow_empty_completion:
        if command:
            # 2012/05/20: Put up an *empty* list as a visual cue.
            k.mb_tabList = []
            g.es('','\n',tabName=tabName)
        else:
            # 2012/05/20: Return *all* completions if the command is empty.
            k.mb_tabList = sorted(defaultTabList)
            common_prefix = ''

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.
        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)

        inverseBindingDict = k.computeInverseBindingDict()
        data,n = [],0
        for commandName in k.mb_tabList:
            dataList = inverseBindingDict.get(commandName,[('',''),])
            for z in dataList:
                pane,key = z
                s1a = '%s ' % (pane) if pane != 'all:' else ''
                s1b = k.prettyPrintKey(key)
                s1 = s1a + s1b
                s2 = commandName
                data.append((s1,s2),)
                n = max(n,len(s1))
        aList = ['%*s %s' % (-n,s1,s2) for s1,s2 in data]
        g.es('','\n'.join(aList),tabName=tabName)
    c.bodyWantsFocus()
.. @+node:ekr.20061031131434.177: *5* k.doBackSpace
# Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList,completion=True):

    '''Cut back to previous prefix and update prefix.'''

    trace = False and not g.unitTesting
    k = self
    w = self.w
    ins = w.getInsertPoint()
    if trace: g.trace(
        'ins',ins,'k.mb_prefix',repr(k.mb_prefix),'w',w)
    if ins <= len(k.mb_prefix):
        # g.trace('at start')
        return
    # Step 1: actually delete the character.
    i,j = w.getSelectionRange()
    if i == j:
        ins -= 1
        w.delete(ins)
        w.setSelectionRange(ins,ins,insert=ins)
    else:
        ins = i
        w.delete(i,j)
        w.setSelectionRange(i,i,insert=ins)
    # Step 2: compute completions.
    if not completion: return
    if k.c.vim_mode: return
    k.mb_tabListPrefix = w.getAllText()
    k.computeCompletionList(defaultCompletionList,backspace=True)
.. @+node:ekr.20061031131434.178: *5* k.doTabCompletion
# Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList,redraw=True,allow_empty_completion=False):

    '''Handle tab completion when the user hits a tab.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel().strip()

    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        if trace: g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex >= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        if redraw:
            if trace: g.trace('** recomputing default completions')
            k.computeCompletionList(defaultTabList,
                backspace=False,
                allow_empty_completion=allow_empty_completion)

    c.minibufferWantsFocus()
.. @+node:ekr.20061031131434.168: *5* k.getFileName & helpers
def getFileName (self,event=None,handler=None,prefix='',filterExt='.leo'):

    '''Similar to k.getArg, but uses completion to indicate files on the file system.'''

    k = self ; c = k.c
    tag = 'getFileName' ; state = k.getState(tag)
    tabName = 'Completion'

    char = event and event.char or ''
    # g.trace('state',state,'char',char)

    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        k.getFileNameHandler = handler
        k.setState(tag,1,k.getFileName)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        c.frame.log.clearTab(tabName)
        c.minibufferWantsFocus()
    elif char in ('\n','Return'):
        k.arg = k.getLabel(ignorePrompt=True)
        handler = k.getFileNameHandler
        c.frame.log.deleteTab(tabName)
        if handler: handler(event)
    elif char in ('\t','Tab'):
        k.doFileNameTab()
        c.minibufferWantsFocus()
    elif char in ('\b','BackSpace'):
        k.doFileNameBackSpace() 
        c.minibufferWantsFocus()
    else:
        k.doFileNameChar(event)
.. @+node:ekr.20061031131434.169: *6* << init altX vars >>
k.filterExt = filterExt
k.mb_prefix = (prefix or k.getLabel())
k.mb_prompt = prefix or k.getLabel()
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
theDir = g.os_path_finalize(os.curdir)
k.extendLabel(theDir,select=False,protect=False)

k.mb_tabListPrefix = k.getLabel()
.. @+node:ekr.20061031131434.170: *6* k.doFileNameBackSpace
def doFileNameBackSpace (self):

    '''Cut back to previous prefix and update prefix.'''

    k = self
    if 0:
        g.trace(
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    if len(k.mb_tabListPrefix) > len(k.mb_prefix):
        k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
        k.setLabel(k.mb_tabListPrefix)
.. @+node:ekr.20061031131434.171: *6* k.doFileNameChar
def doFileNameChar (self,event):

    k = self

    # Clear the list, any other character besides tab indicates that a new prefix is in effect.
    k.mb_tabList = []
    k.updateLabel(event)
    k.mb_tabListPrefix = k.getLabel()

    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
    else:
        # Restore everything.
        old = k.getLabel(ignorePrompt=True)[:-1]
        k.setLabel(k.mb_prompt + old)
.. @+node:ekr.20061031131434.172: *6* k.doFileNameTab
def doFileNameTab (self):

    k = self
    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
.. @+node:ekr.20061031131434.173: *6* k.computeFileNameCompletionList
# This code must not change mb_tabListPrefix.
def computeFileNameCompletionList (self):

    k = self ; c = k.c ; tabName = 'Completion'
    path = k.getLabel(ignorePrompt=True)
    sep = os.path.sep
    tabList = []
    for f in glob.glob(path+'*'):
        if g.os_path_isdir(f):
            tabList.append(f + sep)
        else:
            junk,ext = g.os_path_splitext(f)
            if not ext or ext == k.filterExt:
                tabList.append(f)
    k.mb_tabList = tabList
    junk,common_prefix = g.itemsMatchingPrefixInList(path,tabList)
    if tabList:
        c.frame.log.clearTab(tabName)
        k.showFileNameTabList()
    return common_prefix
.. @+node:ekr.20061031131434.174: *6* k.showFileNameTabList
def showFileNameTabList (self):

    k = self ; tabName = 'Completion'

    for path in k.mb_tabList:
        theDir,fileName = g.os_path_split(path)
        s = g.choose(path.endswith('\\'),theDir,fileName)
        s = fileName or g.os_path_basename(theDir) + '\\'
        g.es('',s,tabName=tabName)
.. @+node:ekr.20110609161752.16459: *5* k.setLossage
def setLossage (self,ch,stroke):

    trace = False and not g.unitTesting
    # k = self
    if trace: g.trace(repr(stroke),g.callers())
    if ch or stroke:
        if len(g.app.lossage) > 99:
            g.app.lossage.pop()
    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0,(ch,stroke),)
.. @+node:ekr.20061031131434.180: *5* k.traceBinding (not used)
def traceBinding (self,si,shortcut,w):

    k = self ; c = k.c ; gui = g.app.gui
    if not c.config.getBool('trace_bindings'): return

    theFilter = c.config.getString('trace_bindings_filter') or ''
    if theFilter and shortcut.lower().find(theFilter.lower()) == -1: return

    pane_filter = c.config.getString('trace_bindings_pane_filter')
    if not pane_filter or pane_filter.lower() == si.pane:
        g.trace(si.pane,shortcut,si.commandName,gui.widget_name(w))
.. @+node:ekr.20061031131434.181: *4* k.Shortcuts & bindings
.. @+node:ekr.20061031131434.176: *5* k.computeInverseBindingDict
def computeInverseBindingDict (self):

    k = self ; d = {}

    # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict.keys():
        assert g.isStroke(stroke),repr(stroke)
        aList = k.bindingsDict.get(stroke,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            shortcutList = d.get(si.commandName,[])

            # The shortcutList consists of tuples (pane,stroke).
            # k.inverseBindingDict has values consisting of these tuples.
            aList = k.bindingsDict.get(stroke,g.ShortcutInfo(kind='dummy',pane='all'))
                    # Important: only si.pane is required below.
            for si in aList:
                assert g.isShortcutInfo(si),si
                pane = '%s:' % (si.pane)
                data = (pane,stroke)
                if data not in shortcutList:
                    shortcutList.append(data)

            d [si.commandName] = shortcutList

    return d
.. @+node:ekr.20061031131434.179: *5* k.getShortcutForCommand/Name
def getShortcutForCommandName (self,commandName):

    k = self ; c = k.c
    command = c.commandsDict.get(commandName)
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke),repr(stroke)
            aList = k.bindingsDict.get(stroke,[])
            for si in aList:
                assert g.isShortcutInfo(si),si
                if si.commandName == commandName:
                    return stroke
    return None

def getShortcutForCommand (self,command):

    k = self
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke),repr(stroke)
            aList = k.bindingsDict.get(stroke,[])
            for si in aList:
                assert g.isShortcutInfo(si),si
                if si.commandName == command.__name__:
                    return stroke
    return None
.. @+node:ekr.20090518072506.8494: *5* k.isFKey
def isFKey (self,stroke):

    # k = self
    if not stroke: return False
    assert g.isString(stroke) or g.isStroke(stroke)
    s = stroke.s if g.isStroke(stroke) else stroke
    s = s.lower()
    return s.startswith('f') and len(s) <= 3 and s[1:].isdigit()
.. @+node:ekr.20061031131434.182: *5* k.isPlainKey
def isPlainKey (self,stroke):

    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''

    k = self
    if not stroke: return False

    assert g.isString(stroke) or g.isStroke(stroke)
    shortcut = stroke.s if g.isStroke(stroke) else stroke

    # altgr combos (Alt+Ctrl) are always plain keys
    if shortcut.startswith('Alt+Ctrl+') and not self.enable_alt_ctrl_bindings:
        return True

    for z in ('Alt','Ctrl','Command','Meta'):
        if shortcut.find(z) != -1:            
            return False
    else:
        # Careful, allow bare angle brackets for unit tests.
        if shortcut.startswith('<') and shortcut.endswith('>'):
            shortcut = shortcut[1:-1]

        isPlain = (
            len(shortcut) == 1 or
            len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
            # A hack: allow Return to be bound to command.
            shortcut in ('Tab','\t')
        )

        # g.trace(isPlain,repr(shortcut))
        return isPlain and not self.isFKey(shortcut)
.. @+node:ekr.20061031131434.191: *5* k.prettyPrintKey
def prettyPrintKey (self,stroke,brief=False):

    trace = False and not g.unitTesting
    k = self
    if not stroke:
        s = ''
    elif g.isStroke(stroke):
        s = stroke.s
    else:
        s = stroke

    if not s: return ''

    shift = s.find("shift") >= 0 or s.find("shft") >= 0

    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if trace: g.trace('fields',fields)
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    if s.endswith(' '):
        s = s[:-1]+'Space' # 2010/11/06

    return s
.. @+node:ekr.20061031131434.184: *5* k.strokeFromSetting
def strokeFromSetting (self,setting,addKey=True):

    k = self

    trace = False and not g.unitTesting # and setting.lower().find('ctrl-x') > -1
    verbose = False
    if not setting:
        return None

    assert g.isString(setting)

    s = g.stripBrackets(setting.strip())
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>

    if trace and verbose:
        g.trace('%20s %s' % (setting,shortcut),g.callers())

    return g.KeyStroke(shortcut) if shortcut else None

canonicalizeShortcut = strokeFromSetting # For compatibility.
### strokeFromSetting = shortcutFromSetting
.. @+node:ekr.20061031131434.185: *6* << define cmd, ctrl, alt, shift >>
s2 = s.lower()

cmd   = s2.find("cmd") >= 0     or s2.find("command") >= 0
ctrl  = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt   = s2.find("alt") >= 0
shift = s2.find("shift") >= 0   or s2.find("shft") >= 0
meta  = s2.find("meta") >= 0
.. @+node:ekr.20061031131434.186: *6* << swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
.. @+node:ekr.20061031131434.187: *6* << convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
.. @+node:ekr.20061031131434.188: *6* << compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", repr(s),repr(setting))
            g.trace(g.callers())
        return None

if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if addKey and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(),last)
.. @+node:ekr.20061031131434.189: *6* << compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (meta,'Meta+'),
    (shift,'Shift+'),
    (True, last),
)

# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val) for flag,val in table if flag])
.. @+node:ekr.20110606004638.16929: *5* k.stroke2char
def stroke2char (self,stroke):

    '''Convert a stroke to an (insertable) char.

    This method allows Leo to use strokes everywhere.'''

    trace = False and not g.unitTesting
    k = self

    if not stroke: return ''
    s = stroke.s

    # Allow bare angle brackets for unit tests.
    if s.startswith('<') and s.endswith('>'):
        s = s[1:-1]

    if len(s) == 0: return ''
    if len(s) == 1: return s

    for z in ('Alt','Ctrl','Command','Meta'):
        if s.find(z) != -1:            
            return ''
            # This is not accurate: leoQtEventFilter retains
            # the spelling of Alt-Ctrl keys because of the
            # @bool enable_alt_ctrl_bindings setting.

    # Special case the gang of four, plus 'Escape',
    d = {
        'BackSpace':'\b',
        'Escape':'Escape',
        'Linefeed':'\r',
        'Return':'\n',
        'Tab':'\t',
    }
    ch = d.get(s)
    if ch: return ch

    # First, do the common translations.
    ch = k.guiBindNamesInverseDict.get(s)
    if ch:
        if trace: g.trace(repr(stroke),repr(ch))
        return ch

    # A much-simplified form of code in k.strokeFromSetting.
    shift = s.find('Shift+') > -1 or s.find('Shift-') > -1
    s = s.replace('Shift+','').replace('Shift-','')

    last = s #  Everything should have been stripped.

    if len(s) == 1 and s.isalpha():
        if shift:
            s = last.upper()
        else:
            s = last.lower()

    val = g.choose(len(s)==1,s,'')

    if trace: g.trace(repr(stroke),repr(val)) # 'shift',shift,
    return val
.. @+node:ekr.20061031131434.193: *4* k.States
.. @+node:ekr.20061031131434.194: *5* clearState
def clearState (self):

    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
.. @+node:ekr.20061031131434.196: *5* getState
def getState (self,kind):

    k = self
    val = g.choose(k.state.kind == kind,k.state.n,0)
    # g.trace(state,'returns',val)
    return val
.. @+node:ekr.20061031131434.195: *5* getStateHandler
def getStateHandler (self):

    return self.state.handler
.. @+node:ekr.20061031131434.197: *5* getStateKind
def getStateKind (self):

    return self.state.kind
.. @+node:ekr.20061031131434.198: *5* inState
def inState (self,kind=None):

    k = self

    if kind:
        return k.state.kind == kind and k.state.n != None
    else:
        return k.state.kind and k.state.n != None
.. @+node:ekr.20080511122507.4: *5* setDefaultInputState
def setDefaultInputState (self):

    k = self ; state = k.defaultUnboundKeyAction

    # g.trace(state)

    k.setInputState(state)
.. @+node:ekr.20110209093958.15411: *5* setEditingState
def setEditingState (self):

    k = self ; state = k.defaultEditingAction

    # g.trace(state)

    k.setInputState(state)
.. @+node:ekr.20061031131434.133: *5* setInputState
def setInputState (self,state,set_border=False):

    c,k = self.c,self
    k.unboundKeyAction = state

    if set_border and c.frame and c.frame.body:
        w = c.frame.body.bodyCtrl
        if hasattr(w,'widget'):
            g.app.gui.add_border(c,w.widget)
.. @+node:ekr.20061031131434.199: *5* k.setState
def setState (self,kind,n,handler=None):

    trace = False and not g.unitTesting
    k = self
    if kind and n != None:
        if trace: g.trace('**** setting %s %s %s' % (
            kind,n,handler and handler.__name__),g.callers())
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        if trace: g.trace('clearing')
        k.clearState()
    # k.showStateAndMode()
.. @+node:ekr.20061031131434.192: *5* k.showStateAndMode
def showStateAndMode(self,w=None,prompt=None,setFocus=True):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return
    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return

    isText = g.app.gui.isTextWidget(w)

    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return

    wname = g.app.gui.widget_name(w).lower()

    # 2011/02/12: get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree,'getWrapper'):
            if hasattr(w,'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2,item=None)
            isText = bool(w) # A benign hack.

    if trace: g.trace('state: %s, text?: %s, w: %s' % (
        state,isText,w))

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    else:
        s = '%s State' % state.capitalize()
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'

    if trace: g.trace('w',w,'s',s)

    if s:
        k.setLabelBlue(label=s,protect=True)
    if w and isText:
        k.showStateColors(inOutline,w)
        k.showStateCursor(state,w)
.. @+node:ekr.20080512115455.1: *5* k.showStateColors (changed)
def showStateColors (self,inOutline,w):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    if c.use_focus_border:
        return

    # This is now deprecated.
    state = k.unboundKeyAction
    if state not in ('insert','command','overwrite'):
        g.trace('bad input state',state)

    w_name = g.app.gui.widget_name(w)

    if w_name.startswith('body'):
        w = c.frame.body
    elif w_name.startswith('head'):
        pass
    else:
        # Don't recolor the minibuffer, log panes, etc.
        if trace: g.trace('not body or head')
        return
    if state == 'insert':
        bg = k.insert_mode_bg_color
        fg = k.insert_mode_fg_color
    elif state == 'command':
        bg = k.command_mode_bg_color
        fg = k.command_mode_fg_color
    elif state == 'overwrite':
        bg = k.overwrite_mode_bg_color
        fg = k.overwrite_mode_fg_color
    else:
        bg = fg = 'red'

    if hasattr(w,'setEditorColors'):
        # Note: fg color has no effect on Qt at present.
        w.setEditorColors(bg=bg,fg=fg)
    else:
        try:
            w.configure(bg=bg,fg=fg)
        except Exception:
            pass # g.es_exception()
.. @+node:ekr.20110202111105.15439: *5* showStateCursor
def showStateCursor (self,state,w):

    # g.trace(state,w)

    pass


.. @+node:ekr.20061031131434.200: *4* k.universalDispatcher & helpers
def universalDispatcher (self,event):

    '''Handle accumulation of universal argument.'''

    << about repeat counts >>
    c,k = self.c,self
    state = k.getState('u-arg')
    stroke = event and event.stroke or None

    if state == 0:
        k.dispatchEvent = event
        # The call should set the label.
        k.setState('u-arg',1,k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        # stroke = k.stroke # Warning: k.stroke is always Alt-u
        char = event and event.char or ''
        # g.trace(state,char)
        if char == 'Escape':
            k.keyboardQuit()
        elif char == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif char.isdigit() or char == '-':
            k.updateLabel(event)
        elif char in (
            'Alt_L','Alt_R',
            'Control_L','Control_R',
            'Meta_L','Meta_R',
            'Shift_L','Shift_R',
        ):
            k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            val = k.getLabel(ignorePrompt=True)
            try:                n = int(val) * k.repeatCount
            except ValueError:  n = 1
            k.clearState()
            event = k.dispatchEvent
            k.executeNTimes(event,n)
            k.keyboardQuit()
    elif state == 2:
        k.doControlU(event,stroke)
.. @+node:ekr.20061031131434.201: *5* << about repeat counts >>
@nocolor

@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
.. @+node:ekr.20061031131434.202: *5* k.executeNTimes
def executeNTimes (self,event,n):

    trace = False and not g.unitTesting
    c,k = self.c,self

    w = event and event.widget

    stroke = event and event.stroke or None
    if not stroke: return

    if stroke == k.fullCommandKey:
        for z in range(n):
            k.fullCommand(event)
    else:
        si = k.getPaneBinding(stroke,event and event.widget)
        if si:
            assert g.isShortcutInfo(si),si
            if trace: g.trace('repeat',n,'method',si.func.__name__,
                'stroke',stroke,'widget',w)
            for z in range(n):
                event = g.app.gui.create_key_event(c,None,event,stroke,w)
                k.masterCommand(commandName=None,event=event,func=si.func,stroke=stroke)
        else:
            for z in range(n):
                k.masterKeyHandler(event)
.. @+node:ekr.20061031131434.203: *5* doControlU
def doControlU (self,event,stroke):

    k = self ; c = k.c

    ch = event and event.char or ''

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if ch == '(':
        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
.. @+node:ekr.20131112152450.16536: ** 4.11.1
.. @+node:ekr.20131112061353.16544: *3* Added @bool force_execute_entire_body
@language rest

Added support for @bool force_execute_entire_body, default False.
When True, the execute_script command forces whole text to be the text.

The c.forceExecuteEntireBody ivar can be toggled by scripts.
.. @+node:ekr.20131111060930.18015: *3* fixed documentation of ctrl-tab
http://mail.google.com/mail/u/0/#inbox/1423c5445471eeb2

The Command reference was wrong.
.. @+node:ekr.20131114051702.16540: *3* Added support for @outline-data
- Restored c.config.getData.
- Added gcm.getOutlineData, c.config.getOutlineData.
- Added parser.doOutlineData and getOutlineDataHelper.
.. @+node:ekr.20131108082341.16371: *3* Added support for @outline-data tree-abbreviations
@language rest

https://groups.google.com/forum/#!topic/leo-editor/OSe0_D5tmJQ

What I did:
    
- Added (complex) code to support scanning after tree substitutions.
- Added support for @data tree-abbreviations.
    - The body contains a list of the abbreviation names.
    - The children should contain nodes matching each abbreviation name.
        The children of *those* nodes are pasted as the last children
        of the present node when the tree abbreviation fires.
- Added ParserBaseClass.doTreeAbbreviationData, called from PBC.doData.
- Added abbrevClass.init_tree_abbrev and helpers.
- Refactored and changed expandAbbrev: added ac.expand_text and ac.expand_tree.
- Added some flags to c.pasteOutline and c.promote,
  These flags disable unwanted actions when expanding tree abbreviations.

@language python
.. @+node:ekr.20131121115406.16356: *3* ** Added new Find tab
.. @+node:ekr.20131116122602.16664: *3* Got focus border working again
Changed add_border and remove_border in qtGui.py
.. @+node:ekr.20131120115900.16325: *3* Added join-irc-leo command
.. @+node:ekr.20131120193808.16326: *3* Allow comments after @data setting-name
Changed ParserBaseClass.parseHeadline so it ignores everything after @data
name.
.. @+node:ekr.20131120193808.17513: *3* Allow comment lines in @item nodes
The first line is significant.  All others are comments.

The fix was to ParserBaseClass.doItems.
.. @+node:ekr.20131121050226.16330: *3* Improved debugging capabilities
Disambiguated various debug switches.

The master debug switches are now::
    
    g.app.debug_app
    g.app.debug_widgets

Added leoQtEventFilter.traceWidget.

Added toggle-debug button in my copy of leoPy.leo.
.. @+node:ekr.20131115120119.17434: *3* Improved tab pane
@language rest

What I did:
    
- Created LeoBaseTabWidget, containing most of the code of LeoTabbedTopLevel.
- LeoTabbedTopLevel derives from this new class.
    
- leoQtLog.__init__ now calls tw.setMovable(True).
  This allows Log pane tabs to be rearranged.
  
- Changed dw.createTabWidget. The changes have as yet no effect:

    def createTabWidget (self,parent,name,hPolicy=None,vPolicy=None):
    
        # w = LeoBaseTabWidget(parent)
        w = QtGui.QTabWidget(parent)
        tb = w.tabBar()
        # tb.setTabsClosable(True)
        self.setSizePolicy(w,kind1=hPolicy,kind2=vPolicy)
        self.setName(w,name)
        return w
.. @+node:ekr.20131121115406.16357: *3* Fixed greedy checkbox bug
@language rest

When the Find pane is active, Alt-x toggles the regex check box, etc.

There is no obvious way to disable the widget when the pane is deactivated.
It must be possible, but perhaps it is not worth it.

The solution was simply to remove the keyboard hints from the Find pane!

.. @-all

# Put this @language after the @all as a kind of permanent unit test.

.. @@language python # Override the default .txt coloring.

.. @@pagewidth 60
.. @-leo
