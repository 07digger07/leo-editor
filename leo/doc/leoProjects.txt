.. @+leo-ver=5-thin
.. @+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
.. @+all
.. @+node:ekr.20160502072908.1: ** 5.4 projects
.. @+node:ekr.20160501154818.1: *3* Bugs
.. @+node:ekr.20160917121434.1: *4* Fixed #241: QMimeData object error
@language rest
@wrap

See https://gitlab.com/pteam/pteam-qtbase/commit/74a20b77a67ec4d5a8be0f59302075d34151dc05

Created new LeoQtGui.setClipboardSelection method, which at present does nothing for PyQt5.
This appears to be the only way to avoid the following message:
    
    "Data set on unsupported clipboard mode. QMimeData object will be deleted."

@language python
.. @+node:ekr.20110605121601.18485: *5* LeoQtGui.Clipboard


.. @+node:ekr.20160917125946.1: *6* LeoQtGui.replaceClipboardWith
def replaceClipboardWith(self, s):
    '''Replace the clipboard with the string s.'''
    trace = False and not g.unitTesting
    cb = self.qtApp.clipboard()
    if cb:
        # cb.clear()  # unnecessary, breaks on some Qt versions
        s = g.toUnicode(s)
        QtWidgets.QApplication.processEvents()
        # Fix #241: QMimeData object error
        cb.setText(QString(s))
        QtWidgets.QApplication.processEvents()
        if trace: g.trace(len(s), type(s), s[: 25])
    else:
        g.trace('no clipboard!')
.. @+node:ekr.20160917125948.1: *6* LeoQtGui.getTextFromClipboard
def getTextFromClipboard(self):
    '''Get a unicode string from the clipboard.'''
    trace = False and not g.unitTesting
    cb = self.qtApp.clipboard()
    if cb:
        QtWidgets.QApplication.processEvents()
        s = cb.text()
        if trace: g.trace(len(s), type(s), s[: 25])
        # Fix bug 147: Python 3 clipboard encoding
        s = g.u(s)
            # Don't call g.toUnicode here!
            # s is a QString, which isn't exactly a unicode string!
        return s
    else:
        g.trace('no clipboard!')
        return ''
.. @+node:ekr.20160917130023.1: *6* LeoQtGui.setClipboardSelection
def setClipboardSelection(self, s):
    '''
    Set the clipboard selection to s.
    There are problems with PyQt5.
    '''
    if isQt5:
        # Alas, returning reopens bug 218: https://github.com/leo-editor/leo-editor/issues/218
        return 
    if s:
        # This code generates a harmless, but annoying warning on PyQt5.
        cb = self.qtApp.clipboard()
        cb.setText(QString(s), mode=cb.Selection)
.. @+node:ekr.20050312114529: *5* c.insert/removeComments
.. @+node:ekr.20131103054650.16535: *6* c.hasAmbiguousLangauge
def hasAmbiguousLanguage(self, p):
    '''Return True if p.b contains different @language directives.'''
    # c = self
    languages, tag = set(), '@language'
    for s in g.splitLines(p.b):
        if g.match_word(s, 0, tag):
            i = g.skip_ws(s, len(tag))
            j = g.skip_id(s, i)
            word = s[i: j]
            languages.add(word)
    return len(list(languages)) > 1
.. @+node:ekr.20131103054650.16536: *6* c.getLanguageAtCursor
def getLanguageAtCursor(self, p, language):
    '''
    Return the language in effect at the present insert point.
    Use the language argument as a default if no @language directive seen.
    '''
    c = self
    tag = '@language'
    w = c.frame.body.wrapper
    ins = w.getInsertPoint()
    n = 0
    for s in g.splitLines(p.b):
        # g.trace(ins,n,repr(s))
        if g.match_word(s, 0, tag):
            i = g.skip_ws(s, len(tag))
            j = g.skip_id(s, i)
            language = s[i: j]
        if n <= ins < n + len(s):
            break
        else:
            n += len(s)
    # g.trace(ins,n,language)
    return language
.. @+node:ekr.20050312114529.1: *6* c.addComments
@cmd('add-comments')
def addComments(self, event=None):
    << addComments docstring >>
    c = self; p = c.p
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    if not lines:
        g.warning('no text selected')
        return
    # The default language in effect at p.
    language = c.frame.body.colorizer.scanColorDirectives(p)
    if c.hasAmbiguousLanguage(p):
        language = c.getLanguageAtCursor(p, language)
    # g.trace(language,p.h)
    d1, d2, d3 = g.set_delims_from_language(language)
    d2 = d2 or ''; d3 = d3 or ''
    if d1:
        openDelim, closeDelim = d1 + ' ', ''
    else:
        openDelim, closeDelim = d2 + ' ', ' ' + d3
    # Comment out non-blank lines.
    indent = c.config.getBool('indent_added_comments', default=True)
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line, 0)
            if indent:
                result.append(line[0: i] + openDelim + line[i:].replace('\n', '') + closeDelim + '\n')
            else:
                result.append(openDelim + line.replace('\n', '') + closeDelim + '\n')
        else:
            result.append(line)
    result = ''.join(result)
    c.updateBodyPane(head, result, tail, undoType='Add Comments', oldSel=None, oldYview=oldYview)
.. @+node:ekr.20111115111842.9789: *7* << addComments docstring >>
@pagewidth 50
'''
Converts all selected lines to comment lines using
the comment delimiters given by the applicable @language directive.

Inserts single-line comments if possible; inserts
block comments for languages like html that lack
single-line comments.

@bool indent_added_comments

If True (the default), inserts opening comment
delimiters just before the first non-whitespace
character of each line. Otherwise, inserts opening
comment delimiters at the start of each line.

*See also*: delete-comments.
'''
.. @+node:ekr.20050312114529.2: *6* c.deleteComments
@cmd('delete-comments')
def deleteComments(self, event=None):
    << deleteComments docstring >>
    c = self; p = c.p
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.warning('no text selected')
        return
    # The default language in effect at p.
    language = c.frame.body.colorizer.scanColorDirectives(p)
    if c.hasAmbiguousLanguage(p):
        language = c.getLanguageAtCursor(p, language)
    d1, d2, d3 = g.set_delims_from_language(language)
    if d1:
        # Remove the single-line comment delim in front of each line
        d1b = d1 + ' '
        n1, n1b = len(d1), len(d1b)
        for s in lines:
            i = g.skip_ws(s, 0)
            if g.match(s, i, d1b):
                result.append(s[: i] + s[i + n1b:])
            elif g.match(s, i, d1):
                result.append(s[: i] + s[i + n1:])
            else:
                result.append(s)
    else:
        # Remove the block comment delimiters from each line.
        n2, n3 = len(d2), len(d3)
        for s in lines:
            i = g.skip_ws(s, 0)
            j = s.find(d3, i + n2)
            if g.match(s, i, d2) and j > -1:
                first = i + n2
                if g.match(s, first, ' '): first += 1
                last = j
                if g.match(s, last - 1, ' '): last -= 1
                result.append(s[: i] + s[first: last] + s[j + n3:])
            else:
                result.append(s)
    result = ''.join(result)
    c.updateBodyPane(head, result, tail, undoType='Delete Comments', oldSel=None, oldYview=oldYview)
.. @+node:ekr.20111115111842.9790: *7* << deleteComments docstring >>
@pagewidth 50
'''
Removes one level of comment delimiters from all
selected lines.  The applicable @language directive
determines the comment delimiters to be removed.

Removes single-line comments if possible; removes
block comments for languages like html that lack
single-line comments.

*See also*: add-comments.
'''
.. @+node:ekr.20031218072017.1838: *5* c.updateBodyPane (handles changeNodeContents)
def updateBodyPane(self, head, middle, tail, undoType, oldSel, oldYview):
    '''Handle changed text in the body pane.'''
    c, p = self, self.p
    body = c.frame.body
    # Update the text and notify the event handler.
    body.setSelectionAreas(head, middle, tail)
    # Expand the selection.
    head = head or ''
    middle = middle or ''
    tail = tail or ''
    i = len(head)
    j = max(i, len(head) + len(middle) - 1)
    newSel = i, j
    body.wrapper.setSelectionRange(i, j)
    # This handles the undo.
    body.onBodyChanged(undoType, oldSel=oldSel or newSel, oldYview=oldYview)
    # Update the changed mark and icon.
    c.setChanged(True)
    if p.isDirty():
        dirtyVnodeList = []
    else:
        dirtyVnodeList = p.setDirty()
    c.redraw_after_icons_changed()
    # Scroll as necessary.
    if oldYview:
        body.wrapper.setYScrollPosition(oldYview)
    else:
        body.wrapper.seeInsertPoint()
    body.wrapper.setFocus()
    c.recolor()
    return dirtyVnodeList
.. @+node:ekr.20031218072017.4037: *5* LeoBody.setSelectionAreas
def setSelectionAreas(self, before, sel, after):
    '''
    Replace the body text by before + sel + after and
    set the selection so that the sel text is selected.
    '''
    body = self
    w = body.wrapper
    # 2012/02/05: save/restore Yscroll position.
    pos = w.getYScrollPosition()
    s = w.getAllText()
    before = before or ''
    sel = sel or ''
    after = after or ''
    w.delete(0, len(s))
    w.insert(0, before + sel + after)
    i = len(before)
    j = max(i, len(before) + len(sel) - 1)
    # g.trace(i,j,repr(sel))
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(pos)
    return i, j
.. @+node:ekr.20110605121601.18096: *5* qtew.setSelectionRange
def setSelectionRange(self, i, j, insert=None, s=None):
    '''Set the selection range and the insert point.'''
    trace = False and not g.unitTesting
    traceTime = False and not g.unitTesting
    # Part 1
    if traceTime: t1 = time.time()
    w = self.widget
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)
    if s is None:
        s = self.getAllText()
    n = len(s)
    i = max(0, min(i, n))
    j = max(0, min(j, n))
    if insert is None:
        ins = max(i, j)
    else:
        ins = self.toPythonIndex(insert)
        ins = max(0, min(ins, n))
    if traceTime:
        delta_t = time.time() - t1
        if delta_t > 0.1: g.trace('part1: %2.3f sec' % (delta_t))
    # Part 2:
    if traceTime: t2 = time.time()
    # 2010/02/02: Use only tc.setPosition here.
    # Using tc.movePosition doesn't work.
    tc = w.textCursor()
    if i == j:
        tc.setPosition(i)
    elif ins == j:
        # Put the insert point at j
        tc.setPosition(i)
        tc.setPosition(j, tc.KeepAnchor)
    elif ins == i:
        # Put the insert point at i
        tc.setPosition(j)
        tc.setPosition(i, tc.KeepAnchor)
    else:
        # 2014/08/21: It doesn't seem possible to put the insert point somewhere else!
        tc.setPosition(j)
        tc.setPosition(i, tc.KeepAnchor)
    w.setTextCursor(tc)
    # Fix bug 218: https://github.com/leo-editor/leo-editor/issues/218
    if hasattr(g.app.gui, 'setClipboardSelection'):
        g.app.gui.setClipboardSelection(s[i:j])
    # Remember the values for v.restoreCursorAndScroll.
    v = self.c.p.v # Always accurate.
    v.insertSpot = ins
    if i > j: i, j = j, i
    assert(i <= j)
    v.selectionStart = i
    v.selectionLength = j - i
    v.scrollBarSpot = spot = w.verticalScrollBar().value()
    if trace: g.trace('i: %s j: %s ins: %s spot: %s %s' % (i, j, ins, spot, v.h))
    if traceTime:
        delta_t = time.time() - t2
        tot_t = time.time() - t1
        if delta_t > 0.1: g.trace('part2: %2.3f sec' % (delta_t))
        if tot_t > 0.1: g.trace('total: %2.3f sec' % (tot_t))
# setSelectionRangeHelper = setSelectionRange
.. @+node:ekr.20150514063305.297: *5* moveToCharacterHelper
def moveToCharacterHelper(self, event, spot, extend):
    w = self.editWidget(event)
    if not w:
        return
    if hasattr(w, 'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot, extend=extend)
    else:
        i = w.getInsertPoint()
        if spot == 'left':
            i = max(0, i - 1)
            self.moveToHelper(event, i, extend=extend)
        elif spot == 'right':
            i = min(i + 1, len(w.getAllText()))
            self.moveToHelper(event, i, extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
.. @+node:ekr.20150514063305.287: *5* extendHelper
def extendHelper(self, w, extend, spot, upOrDown=False):
    '''
    Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''
    trace = False and not g.unitTesting
    verbose = False
    c, p = self.c, self.c.p
    extend = extend or self.extendMode
    ins = w.getInsertPoint()
    i, j = w.getSelectionRange()
    if trace: g.trace(
        'extend', extend, 'ins', ins, 'sel=', i, j,
        'spot=', spot, 'moveSpot', self.moveSpot)
    # Reset the move spot if needed.
    if self.moveSpot is None or p.v != self.moveSpotNode:
        if trace: g.trace('no spot')
        self.setMoveCol(w, ins if extend else spot) # sets self.moveSpot.
    elif extend:
        # 2011/05/20: Fix bug 622819
        # Ctrl-Shift movement is incorrect when there is an unexpected selection.
        if i == j:
            if trace: g.trace('extend and no sel')
            self.setMoveCol(w, ins) # sets self.moveSpot.
        elif self.moveSpot in (i, j) and self.moveSpot != ins:
            if trace and verbose: g.trace('extend and movespot matches')
            # The bug fix, part 1.
        else:
            # The bug fix, part 2.
            # Set the moveCol to the *not* insert point.
            if ins == i: k = j
            elif ins == j: k = i
            else: k = ins
            if trace: g.trace('extend and unexpected spot', k)
            self.setMoveCol(w, k) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2, j2 = g.getLine(s, spot)
            line = s[i2: j2]
            row, col = g.convertPythonIndexToRowCol(s, spot)
            if True: # was j2 < len(s)-1:
                n = min(self.moveCol, max(0, len(line) - 1))
            else:
                n = min(self.moveCol, max(0, len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s, row, n)
        else: # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w, spot) # sets self.moveSpot.
    if extend:
        if trace: g.trace('range', spot, self.moveSpot)
        if spot < self.moveSpot:
            w.setSelectionRange(spot, self.moveSpot, insert=spot)
        else:
            w.setSelectionRange(self.moveSpot, spot, insert=spot)
    else:
        if trace: g.trace('insert point', spot)
        w.setSelectionRange(spot, spot, insert=spot)
    w.seeInsertPoint()
    c.frame.updateStatusLine()
.. @+node:ekr.20110605121601.18077: *5* qtew.leoMoveCursorHelper & helper
def leoMoveCursorHelper(self, kind, extend=False, linesPerPage=15):
    '''QTextEditWrapper.'''
    trace = False and not g.unitTesting
    w = self.widget
    tc = QtGui.QTextCursor
    d = {
        'exchange': True, # Dummy.
        'down': tc.Down, 'end': tc.End, 'end-line': tc.EndOfLine,
        'home': tc.Start, 'left': tc.Left, 'page-down': tc.Down,
        'page-up': tc.Up, 'right': tc.Right, 'start-line': tc.StartOfLine,
        'up': tc.Up,
    }
    kind = kind.lower()
    op = d.get(kind)
    mode = tc.KeepAnchor if extend else tc.MoveAnchor
    if not op:
        return g.trace('can not happen: bad kind: %s' % kind)
    if kind in ('page-down', 'page-up'):
        self.pageUpDown(op, mode)
    elif kind == 'exchange': # exchange-point-and-mark
        cursor = w.textCursor()
        anchor = cursor.anchor()
        pos = cursor.position()
        cursor.setPosition(pos, tc.MoveAnchor)
        cursor.setPosition(anchor, tc.KeepAnchor)
        w.setTextCursor(cursor)
    else:
        if not extend:
            # Fix an annoyance. Make sure to clear the selection.
            cursor = w.textCursor()
            cursor.clearSelection()
            w.setTextCursor(cursor)
        w.moveCursor(op, mode)
    # 2012/03/25.  Add this common code.
    self.seeInsertPoint()
    if trace: g.trace(kind, 'extend', extend, 'yscroll', w.getYScrollPosition())
    self.rememberSelectionAndScroll()
    # Fix bug 218: https://github.com/leo-editor/leo-editor/issues/218
    cursor = w.textCursor()
    sel = cursor.selection().toPlainText()
    if sel and hasattr(g.app.gui, 'setClipboardSelection'):
        g.app.gui.setClipboardSelection(sel)
    self.c.frame.updateStatusLine()
.. @+node:btheado.20120129145543.8180: *6* qtew.pageUpDown
def pageUpDown(self, op, moveMode):
    '''The QTextEdit PageUp/PageDown functionality seems to be "baked-in"
       and not externally accessible.  Since Leo has its own keyhandling
       functionality, this code emulates the QTextEdit paging.  This is
       a straight port of the C++ code found in the pageUpDown method
       of gui/widgets/qtextedit.cpp'''
    control = self.widget
    cursor = control.textCursor()
    moved = False
    lastY = control.cursorRect(cursor).top()
    distance = 0
    # move using movePosition to keep the cursor's x
    while True:
        y = control.cursorRect(cursor).top()
        distance += abs(y - lastY)
        lastY = y
        moved = cursor.movePosition(op, moveMode)
        if (not moved or distance >= control.height()):
            break
    tc = QtGui.QTextCursor
    sb = control.verticalScrollBar()
    if moved:
        if (op == tc.Up):
            cursor.movePosition(tc.Down, moveMode)
            sb.triggerAction(QtWidgets.QAbstractSlider.SliderPageStepSub)
        else:
            cursor.movePosition(tc.Up, moveMode)
            sb.triggerAction(QtWidgets.QAbstractSlider.SliderPageStepAdd)
    control.setTextCursor(cursor)
.. @+node:ekr.20160918052809.1: *4* Fixed #270: Vim keys don't always work after double Alt+Tab
call c.vimCommands.quit()
.. @+node:ekr.20160918060654.1: *5* vc.on_activate
def on_activate(vc):
    '''Handle an activate event.'''
    # Fix #270: Vim keys don't always work after double Alt+Tab.
    vc.quit()
    vc.show_status()
    # This seems not to be needed.
    # vc.c.k.keyboardQuit(setFocus=True)
.. @+node:ekr.20140802120757.17999: *5* vc.quit
def quit(vc):
    '''
    Abort any present command.
    Don't set the dot and enter normal mode.
    '''
    trace = (False or vc.trace) and not g.unitTesting
    if trace: g.trace(vc.stroke)
    # Undoably preserve any changes to the body.
    # g.trace('no change! old vc.state:',vc.state)
    vc.save_body()
    vc.init_state_ivars()
    vc.state = 'normal'
    vc.show_status()
    vc.return_value = True
.. @+node:ekr.20110605121601.18480: *5* LeoQtGui.onActivateEvent
# Called from eventFilter

def onActivateEvent(self, event, c, obj, tag):
    '''
    Restore the focus when the Leo window is activated.
    Called several times for each window activation.
    '''
    trace = False and not g.unitTesting
    if trace:
        g.trace(g.app.gui.get_focus())
    self.active = True
        # Used only by c.idle_focus_helper.
    # Fix #270: Vim keys don't always work after double Alt+Tab.
    if c.exists and not g.app.killed and c.vimCommands:
        c.vimCommands.on_activate()
    if 0: # Cause problems elsewhere.
        trace = False and not g.unitTesting
        if c.exists and self.deactivated_name:
            self.active = True
            w_name = self.deactivated_name
            self.deactivated_name = None
            if trace: g.trace(w_name)
            if c.p.v:
                c.p.v.restoreCursorAndScroll()
            if w_name.startswith('tree') or w_name.startswith('head'):
                c.treeWantsFocusNow()
            else:
                c.bodyWantsFocusNow()
    g.doHook('activate', c=c, p=c.p, v=c.p, event=event)
.. @+node:ekr.20110605121601.18481: *5* LeoQtGui.onDeactiveEvent
deactivated_name = ''

def onDeactivateEvent(self, event, c, obj, tag):
    '''
    Gracefully deactivate the Leo window.
    Called several times for each window activation.
    '''
    trace = False and not g.unitTesting
    if trace:
        g.trace(g.app.gui.get_focus())
    self.active = False
        # Used only by c.idle_focus_helper.
    if 0: # Cause problems elsewhere.
        trace = False and not g.unitTesting
        if c.exists and not self.deactivated_name:
            self.deactivated_name = self.widget_name(self.get_focus())
            self.active = False
            if trace: g.trace(self.deactivated_name)
            c.k.keyboardQuit(setFocus=False)
                # The best way to retain as much focus as possible.
    g.doHook('deactivate', c=c, p=c.p, v=c.p, event=event)
.. @+node:ekr.20061031131434.146: *5* k.masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler(self, event):
    '''The master key handler for almost all key bindings.'''
    trace = False and not g.app.unitTesting
    traceGC = False and not g.app.unitTesting
    verbose = True
    k, c = self, self.c
    c.check_event(event)
    << define vars >>
    assert g.isStrokeOrNone(stroke)
    if char in special_keys:
        if trace and verbose: g.trace('char', char)
        return
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:', repr(stroke), 'char:',
        repr(event and event.char),
        'ch:', repr(event and event.char),
        'state', state, 'state2', k.unboundKeyAction)
    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if hasattr(c, 'screenCastController') and c.screenCastController:
            c.screenCastController.quit()
        if c.macroCommands.recordingMacro:
            c.macroCommands.endMacro()
        else:
            k.masterCommand(commandName='keyboard-quit',
                event=event, func=k.keyboardQuit, stroke=stroke)
        return
    # Always handle modes regardless of vim.
    if k.inState():
        if trace: g.trace('   state %-15s %s' % (state, stroke))
        done = k.doMode(event, state, stroke)
        if done: return
    # Handle vim keys only if not in a state.
    if c.vim_mode and c.vimCommands:
        ok = c.vimCommands.do_key(event)
        if trace: g.trace('vc.do_key returns', ok)
        if ok: return
    if traceGC: g.printNewObjects('masterKey 2')
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if w_name.startswith('canvas'):
            # 2016/04/09: experimental.
            if trace: g.trace('plain key in tree')
        elif self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key', stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            k.handleUnboundKeys(event, char, stroke)
            return
    # 2011/02/08: Use getPaneBindings for *all* keys.
    si = k.getPaneBinding(stroke, w)
    if si:
        assert g.isShortcutInfo(si), si
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound', stroke, si.func.__name__)
        k.masterCommand(event=event,
            commandName=si.commandName, func=si.func, stroke=si.stroke)
    elif w_name.startswith('canvas'):
        # 2016/04/09: experimental.
        if trace: g.trace('unbound plain key in tree: search')
        k.searchTree(char)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace: g.trace(' unbound', stroke)
        k.handleUnboundKeys(event, char, stroke)
.. @+node:ekr.20061031131434.147: *6* << define vars >>
w = event and event.widget
char = event and event.char or ''
stroke = event and event.stroke or None
w_name = c.widget_name(w)
if w_name.startswith('log'):
    # A hack: send the event to the text part of the log.
    w = event.widget = c.frame.log.logCtrl
state = k.state.kind
special_keys = (
    'Alt_L', 'Alt_R',
    'Caps_Lock', 'Control_L', 'Control_R',
    'Meta_L', 'Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L', 'Shift_R',
    'Win_L', 'Win_R',
)
self.master_key_count += 1
isPlain = k.isPlainKey(stroke)
.. @+node:ekr.20061031131434.108: *6* k.callStateFunction
def callStateFunction(self, event):
    trace = False and not g.unitTesting
    k = self; val = None
    ch = event and event.char or ''
    stroke = event and event.stroke or ''
    if trace: g.trace(k.state.kind, 'ch', ch, 'stroke', stroke,
        'ignore_unbound_non_ascii_keys', k.ignore_unbound_non_ascii_keys)
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns', repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b', '\n', '\r', '\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            # if trace: g.trace(k.state.handler.__name__)
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.error('callStateFunction: no state function for', k.state.kind)
    return val
.. @+node:ekr.20091230094319.6244: *6* k.doMode
def doMode(self, event, state, stroke):
    trace = False and not g.unitTesting
    k = self
    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'):
        if k.handleMiniBindings(event, state, stroke):
            return True
    # Second, honor general modes.
    if state == 'getArg':
        k.getArg(event, stroke=stroke)
        return True
    elif state in ('getFileName', 'get-file-name'):
        if trace: g.trace(event, state, stroke)
        k.getFileName(event)
        return True
    elif state in ('full-command', 'auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function', k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns', repr(val))
        return val != 'do-standard-keys'
    # Third, pass keys to user modes.
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert g.isShortcutInfo(si), si
            if trace: g.trace('calling generalModeHandler', stroke)
            k.generalModeHandler(event,
                commandName=si.commandName, func=si.func,
                modeName=state, nextMode=si.nextMode)
            return True
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            if 0: # 2012/05/20: I dislike this warning.
                g.warning('unbound key ends mode', stroke) # 2011/02/02
            k.endMode()
            return False
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler', handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True
.. @+node:ekr.20091230094319.6240: *6* k.getPaneBinding
def getPaneBinding(self, stroke, w):
    trace = False and not g.unitTesting
    verbose = True
    k = self; w_name = k.c.widget_name(w)
    # keyStatesTuple = ('command','insert','overwrite')
    state = k.unboundKeyAction
    assert g.isStroke(stroke)
    if trace: g.trace('w_name', repr(w_name), 'stroke', stroke, 'w', w,
        'isTextWrapper(w)', g.isTextWrapper(w))
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'), # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command', 'insert', 'overwrite') and state == key or # 2010/02/09
            key in ('text', 'all') and g.isTextWrapper(w) or
            key in ('button', 'all')
        ):
            d = k.masterBindingsDict.get(key, {})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key, name, stroke, stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    table = ('previous-line', 'next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case', si.commandName)
                    else:
                        if trace: g.trace('key: %7s name: %6s  found %s = %s' % (
                            key, name, repr(si.stroke), si.commandName))
                        return si
    return None
.. @+node:ekr.20061031131434.152: *6* k.handleMiniBindings
def handleMiniBindings(self, event, state, stroke):
    k = self; c = k.c
    trace = False and not g.app.unitTesting
    # Special case for bindings handled in k.getArg:
    assert g.isStroke(stroke), repr(stroke)
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    if state in ('getArg', 'full-command'):
        if stroke in ('\b', 'BackSpace', '\r', 'Linefeed', '\n', 'Return', '\t', 'Tab', 'Escape',):
            return False
        if k.isFKey(stroke):
            return False
    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key', stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini', 'all', 'text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane), stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane), si.commandName, stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke), 'mini binding', si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName, event=event, func=si.func, stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True
    return False
.. @+node:ekr.20080510095819.1: *6* k.handleUnboundKeys
def handleUnboundKeys(self, event, char, stroke):
    trace = False and not g.unitTesting
    verbose = True
    k = self; c = k.c
    modesTuple = ('insert', 'overwrite')
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    assert g.isStroke(stroke)
    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char), repr(stroke)))
    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))
    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode', stroke)
        return
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key', stroke)
        return
    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode', repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
    elif(not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char), repr(stroke))
        return
    elif k.ignore_unbound_non_ascii_keys and (
        len(char) > 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char), repr(stroke))
        return
    elif(
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore', stroke)
        return
    else:
        if trace: g.trace('no func', repr(char), repr(stroke))
        k.masterCommand(event=event, stroke=stroke)
        return
.. @+node:ekr.20110209083917.16004: *6* k.isAutoCompleteChar
def isAutoCompleteChar(self, stroke):
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''
    k = self; state = k.unboundKeyAction
    assert g.isStrokeOrNone(stroke)
    if stroke and state in ('insert', 'overwrite'):
        for key in (state, 'body', 'log', 'text', 'all'):
            d = k.masterBindingsDict.get(key, {})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke, 'si: %s stroke: %s' % (si, stroke)
                    assert g.isShortcutInfo(si), si
                    if si.commandName == 'auto-complete':
                        return True
    return False
.. @+node:ekr.20160409035115.1: *6* k.searchTree
def searchTree(self, char):
    '''Search all visible nodes for a headline starting with stroke.'''
    trace = False and not g.unitTesting
    if trace: g.trace(char)
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        '''Return True if p contains char.'''
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) > -1

    # Start at c.p, then retry everywhere.
    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if trace: g.trace(p.h)
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            else:
                p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) > -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
.. @+node:ekr.20061031131434.130: *5* k.keyboardQuit
@cmd('keyboard-quit')
def keyboardQuit(self, event=None, setFocus=True, mouseClick=False):
    '''
    This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.
    '''
    trace = False and not g.unitTesting
    k = self; c = k.c
    if trace: g.trace(g.callers())
    if g.app.quitting:
        return
    # 2011/05/30: We may be called from Qt event handlers.
    # Make sure to end editing!
    c.endEditing()
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    if k.inputModeName:
        k.endMode()
    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
    k.clearState()
    k.resetLabel()
    if setFocus:
        c.bodyWantsFocus()
    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    if c.vim_mode and c.vimCommands:
        c.vimCommands.reset(setFocus=setFocus)
    else:
        # This was what caused the unwanted scrolling.
        k.showStateAndMode(setFocus=setFocus)
.. @+node:ekr.20160501154952.1: *4* Fixed #272: optionally delay syntax coloring
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/272

Syntax coloring happens *initially* at idle-time.
pqsh.setDocument queues pqsh.delayedRehighlight to run at idle time.

Most of the time is spent in LeoTree.set_body_text_after_select.
There is probably not much that can be done about that.

@language python
.. @+node:ekr.20160501172340.1: *5* ref
.. @+node:ekr.20140825132752.18554: *6* << class PythonQSyntaxHighlighter >>
class PythonQSyntaxHighlighter(object):
    '''
    Python implementation of QtGui.QSyntaxHighlighter.

    This allows incremental coloring of text at idle time, trading slower
    overall speed for much faster response time.
    '''
    @others
.. @+node:ekr.20140825132752.18561: *7* pqsh.Birth & death
def __init__(self, parent, c=None, delay=10, limit=50):
    '''
    Ctor for QSyntaxHighlighter class.
    Parent is a QTextDocument or QTextEdit: it becomes the owner of the QSyntaxHighlighter.
    '''
    # g.trace('(PythonQSyntaxBrowser)', parent)
    # Ivars corresponding to QSH ivars...
    self.c = c # The commander.
    self.cb = None # The current block: a QTextBlock.
    self.d = None # The QTextDocument attached to this colorizers.
    self.formats = [] # An array of QTextLayout.FormatRange objects.
    self.inReformatBlocks = False
    self.rehighlightPending = False
    # Ivars for reformatBlocks and idle_handler...
    self.idle_active = False # True if the idle_handler should colorize.
    self.r_block = None # The block to be colorized.
    self.r_end = None # The ultimate ending position.
    self.r_delay = delay # The waiting time, in msec. for self.timer.
    self.r_force = False # True if the next block must be recolored.
    self.r_limit = limit # The max number of lines to color at one time.
    self.timer = g.IdleTime(
        handler=self.idle_handler,
        delay=self.r_delay,
        tag='pqsh.idle_handler')
    # Attach the parent's QTextDocument and set self.d.
    self.setDocument(parent)
.. @+node:ekr.20140825132752.18588: *7* pqsh.Entry points
.. @+node:ekr.20140827112712.18469: *8* pqsh.kill
def kill(self):
    '''Kill any queued coloring.'''
    trace = False and not g.unitTesting
    if self.idle_active:
        if trace: g.trace('(PythonQSyntaxHighlighter)')
        self.idle_active = False
        if self.timer:
            self.timer.stop()
.. @+node:ekr.20140825132752.18566: *8* pqsh.rehighlight
def rehighlight(self):
    '''Color the whole document.'''
    trace = False and not g.unitTesting
    c, d = self.c, self.d
    if d:
        n = d.characterCount()
        if 0 < c.max_pre_loaded_body_chars < n:
            if trace: g.trace('big text: no color', c.p.h)
        elif n > 1000*10:

            def rehightlight_callback(c=c, d=d, p=c.p, self=self):
                if p == c.p:
                    if trace: g.trace('=====', n, p.h)
                    cursor = QtGui.QTextCursor(d)
                    self.rehighlight_helper(cursor, QtGui.QTextCursor.End)
                else:
                    if trace: g.trace('node not selected', p.h)

            QtCore.QTimer.singleShot(200, rehightlight_callback)
        else:
            if trace: g.trace(n)
            cursor = QtGui.QTextCursor(d)
            self.rehighlight_helper(cursor, QtGui.QTextCursor.End)
.. @+node:ekr.20140825132752.18568: *8* pqsh.rehighlightBlock (not used)
def rehighlightBlock(self, block):
    '''Reapplies the highlighting to the given QTextBlock block.'''
    d = self.d
    if d and self.is_valid(block) and block.document() == d:
        self.rehighlightPending = d.rehighlightPending
        cursor = QtGui.QTextCursor(block)
        g.trace(g.u(block.text()))
        self.rehighlight_helper(cursor, QtGui.QTextCursor.EndOfBlock)
        if self.rehighlightPending:
            d.rehighlightPending = self.rehighlightPending
.. @+node:ekr.20140825132752.18591: *8* pqsh.rehighlight_helper
def rehighlight_helper(self, cursor, operation):
        # QtGui.QTextCursor &cursor
        # QtGui.QTextCursor.MoveOperation operation
    self.inReformatBlocks = True
    try:
        cursor.beginEditBlock()
        from_ = cursor.position()
        cursor.movePosition(operation)
        self.reformatBlocks(from_, 0, cursor.position() - from_)
        cursor.endEditBlock()
    finally:
        self.inReformatBlocks = False
.. @+node:ekr.20140825132752.18590: *7* pqsh.Getters & Setters
.. @+node:ekr.20140825132752.18582: *8* pqsh.currentBlock & currentBlockUserData
def currentBlock(self):
    '''Returns the current text block.'''
    return self.cb

def currentBlockUserData(self):
    '''Returns the QTextBlockUserData object attached to the current text block.'''
    return self.cb.userData() if self.is_valid(self.cb) else None
.. @+node:ekr.20140825132752.18580: *8* pqsh.currentBlockState & previousBlockState
def currentBlockState(self):
    '''Returns the state of the current block or -1.'''
    return self.cb.userState() if self.is_valid(self.cb) else - 1

def previousBlockState(self):
    '''Returns the end state previous text block or -1'''
    if self.is_valid(self.cb):
        previous = self.cb.previous()
        return previous.userState() if self.is_valid(previous) else - 1
    else:
        return -1
.. @+node:ekr.20140825132752.18565: *8* pqsh.document
def document(self):
    '''Returns the QTextDocument on which this syntax highlighter is installed.'''
    return self.d
.. @+node:ekr.20140825132752.18575: *8* pqsh.format
def format(self, pos):
    '''Return the format at the given position in the current text block.'''
    if 0 <= pos < len(self.formatChanges):
        return self.formatChanges[pos]
    else:
        return QtGui.QTextCharFormat()
.. @+node:ekr.20140825132752.18576: *8* pqsh.setCurrentBlockState & setCurrentBlockUserData
def setCurrentBlockState(self, newState):
    '''Sets the state of the current text block.'''
    if self.is_valid(self.cb):
        self.cb.setUserState(newState)

def setCurrentBlockUserData(self, data):
    '''Set the user data of the current text block.'''
    if self.is_valid(self.cb):
        self.cb.setUserData(data)
.. @+node:ekr.20140825132752.18564: *8* pqsh.setDocument
def setDocument(self, parent):
    '''Install self on the given QTextDocument.'''
    d = self.d
    if d:
        d.contentsChange.disconnect()
        cursor = QtGui.QTextCursor(d)
        cursor.beginEditBlock()
        blk = d.begin()
        while self.is_valid(blk): # blk: QTextBlock
            blk.layout().clearAdditionalFormats()
            blk = blk.next()
        cursor.endEditBlock()
    self.d = d = parent.document()
    assert isinstance(d, QtGui.QTextDocument), d
    if d:
        d.contentsChange.connect(self.q_reformatBlocks)
        d.rehighlightPending = True
            # Set d's pending flag.
        QtCore.QTimer.singleShot(0, self.delayedRehighlight)
.. @+node:ekr.20140825132752.18584: *8* pqsh.setFormat (start,count,format)
def setFormat(self, start, count, format):
    '''Remember the requested formatting.'''
    trace = False and not g.unitTesting
    verbose = False
    if start >= 0:
        r = QtGui.QTextLayout.FormatRange()
        r.start, r.length, r.format = start, count, format
        self.formats.append(r)
        if trace and verbose: g.trace('%3s %3s %s %s' % (
            start, count, self.format_to_color(format), self.cb.text()))
    elif trace:
        g.trace('bad start value', repr(start), g.callers())
# Not used by Leo...
# def setFormat(self,start,count,color):
    # format = QTextCharFormat()
    # format.setForeground(color)
    # setFormat(start,count,format)
# def setFormat(self,start,count,font):
    # format = QTextCharFormat()
    # format.setFont(font)
    # self.setFormat(start,count,format)
.. @+node:ekr.20140825132752.18589: *7* pqsh.Helpers
# These helpers are the main reason QSyntaxHighlighter exists.
# Getting this code exactly right is the main challenge for PythonQSyntaxHighlighter.
.. @+node:ekr.20140825132752.18557: *8* pqsh.applyFormatChanges
def applyFormatChanges(self):
    '''Apply self.formats to the current layout.'''
    if self.formats:
        layout = self.cb.layout()
        layout.setAdditionalFormats(self.formats)
        self.formats = []
        self.d.markContentsDirty(self.cb.position(), self.cb.length())
.. @+node:ekr.20140825132752.18592: *8* pqsh.delayedRehighlight
def delayedRehighlight(self): # inline
    '''Queued rehighlight.'''
    # g.trace('=====',self.rehighlightPending)
    if self.rehighlightPending:
        self.rehighlightPending = False
        self.rehighlight()
.. @+node:ekr.20140826120657.18649: *8* pqsh.format_to_color
def format_to_color(self, format):
    '''Return the foreground color of the given character format.'''
    return str(format.foreground().color().name())
.. @+node:ekr.20140826120657.18650: *8* pqsh.highlightBlock
def highlightBlock(self, s):
    g.trace('must be defined in subclasses.' '')
.. @+node:ekr.20140827063632.18569: *8* pqsh.idle_handler
def idle_handler(self, timer):
    trace = False and not g.unitTesting
    verbose = True
    if not self.idle_active:
        # Shortcut everything else.
        return
    c = self.c
    if trace and verbose:
        s = g.u(self.r_block.text()).lstrip()
        g.trace('force: %5s s: %s' % (self.r_force, s[: 20]))
    # This is defensive code.  Apparently it is never needed.
    # This is the only place c is used, so the c argument to the ctor is optional.
    if c:
        if c.p == self.r_p:
            self.reformat_blocks_helper()
        elif trace:
            self.idle_active = False
            g.trace('node changed: old: %s new: %s' % (
                self.r_p and self.r_p.h[: 10], c.p and c.p.h[: 10]))
.. @+node:ekr.20140826120657.18648: *8* pqsh.is_valid
def is_valid(self, obj):
    return obj and obj.isValid()
.. @+node:ekr.20140825132752.18558: *8* pqsh.q_reformatBlocks
def q_reformatBlocks(self, from_, charsRemoved, charsAdded):
    if not self.inReformatBlocks:
        # g.trace(from_,charsRemoved,charsAdded)
        self.reformatBlocks(from_, charsRemoved, charsAdded)
.. @+node:ekr.20140827074435.18570: *8* pqsh.reformat_blocks_helper
def reformat_blocks_helper(self):
    '''The common code shared by reformatBlocks and idle_handler.'''
    block = self.r_block
    n, start = 0, False
    while self.is_valid(block) and (block.position() < self.r_end or self.r_force):
        n += 1
        if n >= self.r_limit > 0 and self.timer:
            start = True
            break
        else:
            before_state = block.userState()
            self.reformatBlock(block)
            self.r_force = block.userState() != before_state
            block = self.r_block = block.next()
    self.formatChanges = []
    self.idle_active = start
    if self.timer and start:
        self.timer.start()
    elif self.timer:
        self.timer.stop()
        # g.trace('--end',g.app.allow_see,self.c.p and self.c.p.h or None)
        # Fix bug 78: find-next match not always scrolled into view.
        # https://github.com/leo-editor/leo-editor/issues/78
        w = self.c.frame.body.wrapper
        if g.app.allow_delayed_see and w:
            w.seeInsertPoint()
        g.app.allow_delayed_see = False
.. @+node:ekr.20140825132752.18560: *8* pqsh.reformatBlock
def reformatBlock(self, block):
    trace = False and not g.unitTesting
    if self.is_valid(self.cb) and not isQt5:
        g.trace('can not happen: called recursively')
    else:
        self.cb = block
        self.formats = []
        for i in range(block.length()):
            r = QtGui.QTextLayout.FormatRange()
            r.start, r.length, r.format = i, 1, QtGui.QTextCharFormat()
            self.formats.append(r)
        if trace: g.trace(str(block.text()))
        self.highlightBlock(block.text())
        self.applyFormatChanges()
        self.cb = QtGui.QTextBlock()
.. @+node:ekr.20140825132752.18559: *8* pqsh.reformatBlocks (main line)
def reformatBlocks(self, from_, charsRemoved, charsAdded):
    '''Main line: Reformat the lines in the indicated range.'''
    self.rehighlightPending = False
    block = self.d.findBlock(from_)
    if not self.is_valid(block):
        return
    # Set the ivars for reformat_blocks_helper.
    adjust = 1 if charsRemoved > 0 else 0
    lastBlock = self.d.findBlock(from_ + charsAdded + adjust)
    if self.is_valid(lastBlock):
        self.r_end = lastBlock.position() + lastBlock.length()
    else:
        self.r_end = self.d.blockCount()
    self.r_block = block
    self.r_p = self.c.p.copy()
    self.r_force = False
    # Delegate the colorizing to shared helper.
    self.reformat_blocks_helper()
.. @+node:tbrown.20140919120654.24038: *6* class BigTextController
class BigTextController(object):
    @others
.. @+node:tbrown.20140919120654.24039: *7* btc.__init__
def __init__(self, c):
    '''Ctor for BigTextController.'''
    self.active_flag = None # True: warning text/buttons are visible.
    self.c = c
    self.inhibit = set() # Set of inhibited vnodes.
    self.layout = None
    self.old_p = None
    self.old_w = None # A LeoQTextBrowser.
    self.p = None
    self.parent = None
    self.s = None
    self.w = None
.. @+node:ekr.20141019133149.18299: *7* btc.add_buttons
def add_buttons(self, old_p, p):
    '''Init the big text controller for node p.'''
    c = self.c
    w = c.frame.body.wrapper.widget
    parent = w.parent() # A QWidget
    layout = parent.layout()
    # Set ivars
    self.active_flag = True
    self.layout = layout
    self.old_p = old_p
    self.old_w = w # A LeoQTextBrowser.
    self.p = p
    self.parent = parent
    self.s = p.b
    self.widgets = {}
        # Keys are strings, values are buttons.
    if p.v not in self.inhibit:
        self.create_widgets()
            # Create the big-text widgets.
    # g.trace('----- (LeoBigTextDialog)',len(self.s),self.w)
.. @+node:ekr.20141018081615.18272: *7* btc.create_widgets
def create_widgets(self):
    '''Create the big-text buttons and text warning area.'''
    c = self.c
    self.active_flag = True
    warning = self.warning_message()
    if 1: # essential
        self.old_w.setPlainText(self.p.b)
    else: # can lose data.
        self.old_w.setPlainText(
            '@nocolor-node\n\nBig text not loaded: %s characters. Limit is %s' % (
            len(self.p.b), c.max_pre_loaded_body_chars))
    self.w = w = QtWidgets.QWidget() # No parent needed.
    layout = QtWidgets.QVBoxLayout() # No parent needed.
    w.setLayout(layout)
    w.text = tw = QtWidgets.QTextBrowser()
    tw.setText(warning)
    tw.setObjectName('bigtextwarning')
    self.widgets['bigtextwarning'] = tw
    layout.addWidget(tw)
    table = [
            ('remove', 'Remove These Buttons', self.remove),
            ('load_nc', 'Load Text With @killcolor', self.load_nc),
            ('more', 'Double limit for this session', self.more),
            ('copy', 'Copy body to clipboard', self.copy),
    ]
    if self.s.startswith('@killcolor'):
        del table[1]
    for key, label, func in table:
        self.widgets[key] = button = QtWidgets.QPushButton(label)
        layout.addWidget(button)

        def button_callback(checked, func=func):
            func()

        button.clicked.connect(button_callback)
    # layout.addItem(QtWidgets.QSpacerItem(
        # 10, 10, vPolicy=QtWidgets.QSizePolicy.Expanding))
    self.layout.addWidget(w)
    w.show()
.. @+node:tbrown.20140919120654.24040: *7* btc.copy
def copy(self):
    '''Copy self.s (c.p.b) to the clipboard.'''
    g.app.gui.replaceClipboardWith(self.s)
.. @+node:ekr.20141018081615.18276: *7* btc.go_away
def go_away(self):
    '''Delete all buttons and self.'''
    # g.trace(self.w or 'None')
    self.active_flag = False
    c = self.c
    if self.w:
        # Does not work.
        # self.old_w.setPlainText(self.p.b)
        self.layout.removeWidget(self.w)
        self.w.deleteLater()
        self.w = None
    c.bodyWantsFocusNow()
.. @+node:ekr.20141019133149.18298: *7* btc.is_qt_body
def is_qt_body(self):
    '''Return True if the body widget is a QTextEdit.'''
    c = self.c
    w = c.frame.body.wrapper.widget
    val = isinstance(w, qt_text.LeoQTextBrowser)
        # c.frame.body.wrapper.widget is a LeoQTextBrowser.
        # c.frame.body.wrapper is a QTextEditWrapper or QScintillaWrapper.
    # g.trace(self.c.shortFileName(),val)
    return val
.. @+node:ekr.20141019133149.18296: *7* btc.is_big_text
def is_big_text(self, p):
    '''True if p.b is large and the text widget supports big text buttons.'''
    c = self.c
    if c.max_pre_loaded_body_chars > 0:
        wrapper = c.frame.body.wrapper
        w = wrapper and wrapper.widget
        val = w and len(p.b) > c.max_pre_loaded_body_chars
    else:
        val = False
    # g.trace(c.shortFileName(),p.h,val)
    return val
.. @+node:tbrown.20140919120654.24042: *7* btc.load_nc
def load_nc(self):
    '''Load the big text with a leading @killcolor directive.'''
    c, p = self.c, self.c.p
    if not c.positionExists(p):
        return
    self.wait_message()
    # Recreate the entire select code.
    tag = "@killcolor\n"
    if not p.b.startswith(tag):
        p.b = tag + p.b
    w = self.c.frame.body.wrapper
    self.go_away()
    w.setInsertPoint(0)
    w.seeInsertPoint()
    c.bodyWantsFocusNow()
    c.recolor_now()
.. @+node:tbrown.20140919120654.24043: *7* btc.more
def more(self):
    '''
    Double the big text limit for this session.
    Load the text if the text is less than this limit.
    '''
    c = self.c
    c.max_pre_loaded_body_chars *= 2
    if len(c.p.b) < c.max_pre_loaded_body_chars:
        self.wait_message()
        self.inhibit.add(c.p.v)
        self.go_away()
        c.selectPosition(self.p)
    else:
        tw = self.widgets.get('bigtextwarning')
        tw.setText(self.warning_message())
        g.es('limit is now: %s' % c.max_pre_loaded_body_chars)
.. @+node:ekr.20141020112451.18341: *7* btc.remove
def remove(self):
    '''Remove the buttons and inhibit them hereafter.'''
    c = self.c
    self.inhibit.add(c.p.v)
    self.go_away()
.. @+node:ekr.20141019133149.18295: *7* btc.should_add_buttons
def should_add_buttons(self, old_p, p):
    '''Return True if big-text buttons should be added.'''
    if g.app.unitTesting:
        return False # Don't add buttons during testing.
    if self.c.undoer.undoing:
        return False # Suppress buttons during undo.
    if self.active_flag:
        return False # Buttons already created.
    if p.v in self.inhibit:
        return False # Buttons are inhibited for this vnode.
    return self.is_big_text(p) and self.is_qt_body()
.. @+node:ekr.20141019190455.18296: *7* btc.should_go_away
def should_go_away(self, p):
    '''Return True if big-text buttons should be removed.'''
    if self.c.undoer.undoing:
        return False # Suppress buttons during undo.
    else:
        return self.active_flag and not self.is_big_text(p)
.. @+node:tbrown.20140919120654.24044: *7* btc.wait_message
def wait_message(self):
    '''Issue a message asking the user to wait until all text loads.'''
    g.es(
        "Loading large text, please wait\n"
        "until scrollbar stops shrinking", color='red')
.. @+node:ekr.20141018081615.18279: *7* btc.warning_message
def warning_message(self):
    '''Return the warning message.'''
    c = self.c
    s = '''\
Loading big text: %s characters. Limit is %s.

Beware of a Qt bug: You will **lose data** if you change the text
before it is fully loaded (before the scrollbar stops moving).

To disable these buttons set @int max-pre-loaded-body-chars = 0
'''
    s = s.rstrip() % (len(self.s), c.max_pre_loaded_body_chars)
    return g.adjustTripleString(s, c.tab_width)
.. @+node:ekr.20160501172516.1: *6* Found:def recolor
# flattened, word, ignore-case, head, body
.. @+node:ekr.20110605121601.18640: *7* recolor (entry point)
def recolor(self, s):
    '''
    Recolor a *single* line, s.
    Qt calls this method repeatedly to colorizer all the text.
    '''
    trace = False and not g.unitTesting
    traceCallers = False; traceLine = True
    traceState = False; traceReturns = False
    # Update the counts.
    self.recolorCount += 1
    if self.colorizer.changingText:
        if trace and traceReturns: g.trace('changingText')
        return
    if not self.colorizer.flag:
        if trace and traceReturns: g.trace('not flag')
        return
    self.lineCount += 1
    # Get the previous state.
    self.totalChars += len(s)
    n = self.prevState() # The state at the end of the previous line.
    if trace:
        if traceLine and traceState:
            g.trace('%3s %2s %s %s' % (self.lineCount, n, self.showState(n), repr(s)))
        elif traceLine:
            g.trace('%3s %2s %s' % (self.lineCount, n, repr(s)))
        if traceCallers:
            # Called from colorize:rehightlight,highlightBlock
            g.trace(g.callers())
    if s.strip() or self.showInvisibles:
        self.mainLoop(n, s)
    else:
        self.setState(n) # Required
.. @+node:ekr.20031218072017.3677: *7* LeoBody.Coloring
def forceFullRecolor(self):
    self.forceFullRecolorFlag = True

def getColorizer(self):
    return self.colorizer

def updateSyntaxColorer(self, p):
    return self.colorizer.updateSyntaxColorer(p.copy())

def recolor(self, p, incremental=False):
    self.c.requestRecolorFlag = True
    self.c.incrementalRecolorFlag = incremental

recolor_now = recolor
.. @+node:ekr.20160501172713.1: *6* Found:setHighlighter
# flattened, word, ignore-case, head, body
.. @+node:ekr.20090608081524.6109: *7* LeoTree.set_body_text_after_select
def set_body_text_after_select(self, p, old_p, traceTime, force=False):
    '''Set the text after selecting a node.'''
    trace = False and not g.unitTesting
    trace_pass = False
    trace_time = (True or traceTime)
    if trace_time: t1 = time.time()
    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c
    w = c.frame.body.wrapper
    s = p.v.b # Guaranteed to be unicode.
    # Part 1: get the old text.
    old_s = w.getAllText()
    if trace: g.trace('=====', len(s), p.h)
    if trace and trace_time:
        t2 = time.time()
        print('  part1: getAllText %4.2f sec' % (t2-t1))
    if not force and p and p == old_p and s == old_s:
        if trace and trace_pass: g.trace('*pass', len(s), p.h, old_p.h)
        return
    # Part 2: set the new text.
    # w.setAllText destroys all color tags, so do a full recolor.
    if 0 < c.max_pre_loaded_body_chars < len(s):
        # Don't load the text if not wanted.
        if trace and trace_time:
            t3 = time.time()
            print('  part2: setAllText %4.2f sec' % (t3-t2))
    else:
        w.setAllText(s, h = p.h)
        if trace and trace_time:
            t3 = time.time()
            print('  part2: setAllText %4.2f sec' % (t3-t2))
        # Part 3: colorize.
        # We can't call c.recolor_now here.
        colorizer = c.frame.body.colorizer
        if hasattr(colorizer, 'setHighlighter'):
            if colorizer.setHighlighter(p):
                self.frame.body.recolor(p)
        else:
            self.frame.body.recolor(p)
    if trace and trace_time:
        t4 = time.time()
        print('  part3: colorize   %4.2f sec' % (t4-t3))
        print('  total:            %4.2f sec' % (t4-t1))
    # This is now done after c.p has been changed.
        # p.restoreCursorAndScroll()
.. @+node:ekr.20031218072017.2220: *7* entry points
def colorize(self, p, incremental=False, interruptable=True):
    self.count += 1 # Used by unit tests.
    return 'ok' # Used by unit tests.

def disable(self): pass

def enable(self): pass

def kill(self): pass

def setHighlighter(self, p): return False

def showInvisibles(self): pass

def write_colorizer_cache(self, p): pass
# External unit tests require the standard (ColorizerMixin) methods for these:
    # def scanColorDirectives(self,p): pass
    # def updateSyntaxColorer (self,p): pass
    # def useSyntaxColoring(self,p): return False
.. @+node:ekr.20110605121601.18561: *7* setHighlighter
# Called *only* from LeoTree.setBodyTextAfterSelect

def setHighlighter(self, p):
    if self.enabled:
        self.flag = self.updateSyntaxColorer(p)
        return self.flag
.. @+node:ekr.20140904043623.18535: *7* class ColorizerAPI
class ColorizerAPI(object):
    '''The required API of c.frame.body.colorizer.'''

    def __init__(self, c, widget): pass

    def colorize(self, p, incremental=False, interruptable=True): return 'ok'
    # def disable (self,p): pass
    # def enable (self,p): pass

    def kill(self): pass

    def scanColorDirectives(self, p): return 'python'

    def setHighlighter(self, p): return True

    def updateSyntaxColorer(self, p): return True

    def useSyntaxColoring(self, p): return True

    def write_colorizer_cache(self, p): pass
.. @+node:ekr.20110605121601.18556: *6* scanColorDirectives (LeoQtColorizer) & helper
def scanColorDirectives(self, p):
    '''Set self.language based on the directives in p's tree.'''
    trace = False and not g.unitTesting
    c = self.c
    if c is None: return None # self.c may be None for testing.
    root = p.copy()
    self.colorCacheFlag = False
    self.language = None
    self.rootMode = None # None, "code" or "doc"
    for p in root.self_and_parents():
        theDict = g.get_directives_dict(p)
        # if trace: g.trace(p.h,theDict)
        << Test for @colorcache >>
        << Test for @language >>
        << Test for @root, @root-doc or @root-code >>
    # 2011/05/28: If no language, get the language from any @<file> node.
    if self.language:
        if trace: g.trace('found @language %s %s' % (self.language, self.languageList))
        return self.language
    #  Attempt to get the language from the nearest enclosing @<file> node.
    self.language = g.getLanguageFromAncestorAtFileNode(root)
    if not self.language:
        if trace: g.trace('using default', c.target_language)
        self.language = c.target_language
    return self.language # For use by external routines.
.. @+node:ekr.20121003152523.10126: *7* << Test for @colorcache >>
# The @colorcache directive is a per-node directive.
if p == root:
    self.colorCacheFlag = 'colorcache' in theDict
    # g.trace('colorCacheFlag: %s' % self.colorCacheFlag)
.. @+node:ekr.20110605121601.18557: *7* << Test for @language >>
if 'language' in theDict:
    s = theDict["language"]
    aList = self.findLanguageDirectives(p)
    # In the root node, we use the first (valid) @language directive,
    # no matter how many @language directives the root node contains.
    # In ancestor nodes, only unambiguous @language directives
    # set self.language.
    if p == root or len(aList) == 1:
        self.languageList = list(set(aList))
        self.language = aList and aList[0] or []
        break
.. @+node:ekr.20110605121601.18558: *7* << Test for @root, @root-doc or @root-code >>
if 'root' in theDict and not self.rootMode:
    s = theDict["root"]
    if g.match_word(s, 0, "@root-code"):
        self.rootMode = "code"
    elif g.match_word(s, 0, "@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = "doc" if doc else "code"
.. @+node:ekr.20110605121601.18559: *7* findLanguageDirectives
def findLanguageDirectives(self, p):
    '''Scan p's body text for *valid* @language directives.

    Return a list of languages.'''
    # Speed not very important: called only for nodes containing @language directives.
    trace = False and not g.unitTesting
    aList = []
    for s in g.splitLines(p.b):
        if g.match_word(s, 0, '@language'):
            i = len('@language')
            i = g.skip_ws(s, i)
            j = g.skip_id(s, i)
            if j > i:
                word = s[i: j]
                if self.isValidLanguage(word):
                    aList.append(word)
                else:
                    if trace: g.trace('invalid', word)
    if trace: g.trace(aList)
    return aList
.. @+node:ekr.20110605121601.18560: *7* isValidLanguage
def isValidLanguage(self, language):
    fn = g.os_path_join(g.app.loadDir, '..', 'modes', '%s.py' % (language))
    return g.os_path_exists(fn)
.. @+node:ekr.20090214075058.9: *6* g.get_directives_dict (must be fast)
# The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].
g_noweb_root = re.compile('<' + '<' + '*' + '>' + '>' + '=',
                          re.MULTILINE)

def get_directives_dict(p, root=None):
    """
    Scan p for @directives found in globalDirectiveList.

    Returns a dict containing the stripped remainder of the line
    following the first occurrence of each recognized directive
    """
    trace = False and not g.unitTesting
    verbose = False
    if trace and verbose: g.trace('*' * 20, p.h)
    if root: root_node = root[0]
    c = p and p.v and p.v.context
    d = {}
    # Do this every time so plugins can add directives.
    pat = g.compute_directives_re()
    directives_pat = re.compile(pat, re.MULTILINE)
    # The headline has higher precedence because it is more visible.
    for kind, s in (('head', p.h), ('body', p.b)):
        anIter = directives_pat.finditer(s)
        for m in anIter:
            word = m.group(1).strip()
            i = m.start(1)
            if word in d: continue
            j = i + len(word)
            if j < len(s) and s[j] not in ' \t\n':
                continue
                    # Not a valid directive: just ignore it.
                    # A unit test tests that @path:any is invalid.
            k = g.skip_line(s, j)
            val = s[j: k].strip()
            if trace and c and p == c.p:
                g.trace('%20s %s' % (word, val))
            if word in ('root-doc', 'root-code'):
                d['root'] = val # in addition to optioned version
            d[word] = val
            # Warn about @path in the body text of @<file> nodes.
            if (kind == 'body' and
                word == 'path' and
                p.isAnyAtFileNode()
            ):
                g.app.atPathInBodyWarning = p.h
                d['@path_in_body'] = p.h
                if trace: g.trace('@path in body', p.h)
    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"] = 0 # value not immportant
            else:
                g.es('%s= may only occur in a topmost node (i.e., without a parent)' % (
                    g.angleBrackets('*')))
            break
    if trace and verbose:
        g.trace('%4d' % (len(p.h) + len(p.b)))
    return d
.. @+node:ekr.20090214075058.10: *7* g.compute_directives_re
def compute_directives_re():
    '''
    Return an re pattern which word matches all Leo directives.
    Only g.get_directives_dict uses this pattern.
    '''
    global globalDirectiveList
    # EKR: 2016/03/30: Use a pattern that guarantees word matches.
    aList = [r'\b%s\b' % (z) for z in globalDirectiveList
                if z != 'others']
    return "^@(%s)" % "|".join(aList)
.. @+node:ekr.20160501155912.1: *5* changed
.. @+node:ekr.20141018081615.18272: *6* btc.create_widgets
def create_widgets(self):
    '''Create the big-text buttons and text warning area.'''
    c = self.c
    self.active_flag = True
    warning = self.warning_message()
    if 1: # essential
        self.old_w.setPlainText(self.p.b)
    else: # can lose data.
        self.old_w.setPlainText(
            '@nocolor-node\n\nBig text not loaded: %s characters. Limit is %s' % (
            len(self.p.b), c.max_pre_loaded_body_chars))
    self.w = w = QtWidgets.QWidget() # No parent needed.
    layout = QtWidgets.QVBoxLayout() # No parent needed.
    w.setLayout(layout)
    w.text = tw = QtWidgets.QTextBrowser()
    tw.setText(warning)
    tw.setObjectName('bigtextwarning')
    self.widgets['bigtextwarning'] = tw
    layout.addWidget(tw)
    table = [
            ('remove', 'Remove These Buttons', self.remove),
            ('load_nc', 'Load Text With @killcolor', self.load_nc),
            ('more', 'Double limit for this session', self.more),
            ('copy', 'Copy body to clipboard', self.copy),
    ]
    if self.s.startswith('@killcolor'):
        del table[1]
    for key, label, func in table:
        self.widgets[key] = button = QtWidgets.QPushButton(label)
        layout.addWidget(button)

        def button_callback(checked, func=func):
            func()

        button.clicked.connect(button_callback)
    # layout.addItem(QtWidgets.QSpacerItem(
        # 10, 10, vPolicy=QtWidgets.QSizePolicy.Expanding))
    self.layout.addWidget(w)
    w.show()
.. @+node:ekr.20141018081615.18276: *6* btc.go_away
def go_away(self):
    '''Delete all buttons and self.'''
    # g.trace(self.w or 'None')
    self.active_flag = False
    c = self.c
    if self.w:
        # Does not work.
        # self.old_w.setPlainText(self.p.b)
        self.layout.removeWidget(self.w)
        self.w.deleteLater()
        self.w = None
    c.bodyWantsFocusNow()
.. @+node:ekr.20141018081615.18279: *6* btc.warning_message
def warning_message(self):
    '''Return the warning message.'''
    c = self.c
    s = '''\
Loading big text: %s characters. Limit is %s.

Beware of a Qt bug: You will **lose data** if you change the text
before it is fully loaded (before the scrollbar stops moving).

To disable these buttons set @int max-pre-loaded-body-chars = 0
'''
    s = s.rstrip() % (len(self.s), c.max_pre_loaded_body_chars)
    return g.adjustTripleString(s, c.tab_width)
.. @+node:ekr.20090608081524.6109: *6* LeoTree.set_body_text_after_select
def set_body_text_after_select(self, p, old_p, traceTime, force=False):
    '''Set the text after selecting a node.'''
    trace = False and not g.unitTesting
    trace_pass = False
    trace_time = (True or traceTime)
    if trace_time: t1 = time.time()
    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c
    w = c.frame.body.wrapper
    s = p.v.b # Guaranteed to be unicode.
    # Part 1: get the old text.
    old_s = w.getAllText()
    if trace: g.trace('=====', len(s), p.h)
    if trace and trace_time:
        t2 = time.time()
        print('  part1: getAllText %4.2f sec' % (t2-t1))
    if not force and p and p == old_p and s == old_s:
        if trace and trace_pass: g.trace('*pass', len(s), p.h, old_p.h)
        return
    # Part 2: set the new text.
    # w.setAllText destroys all color tags, so do a full recolor.
    if 0 < c.max_pre_loaded_body_chars < len(s):
        # Don't load the text if not wanted.
        if trace and trace_time:
            t3 = time.time()
            print('  part2: setAllText %4.2f sec' % (t3-t2))
    else:
        w.setAllText(s, h = p.h)
        if trace and trace_time:
            t3 = time.time()
            print('  part2: setAllText %4.2f sec' % (t3-t2))
        # Part 3: colorize.
        # We can't call c.recolor_now here.
        colorizer = c.frame.body.colorizer
        if hasattr(colorizer, 'setHighlighter'):
            if colorizer.setHighlighter(p):
                self.frame.body.recolor(p)
        else:
            self.frame.body.recolor(p)
    if trace and trace_time:
        t4 = time.time()
        print('  part3: colorize   %4.2f sec' % (t4-t3))
        print('  total:            %4.2f sec' % (t4-t1))
    # This is now done after c.p has been changed.
        # p.restoreCursorAndScroll()
.. @+node:ekr.20140825132752.18566: *6* pqsh.rehighlight
def rehighlight(self):
    '''Color the whole document.'''
    trace = False and not g.unitTesting
    c, d = self.c, self.d
    if d:
        n = d.characterCount()
        if 0 < c.max_pre_loaded_body_chars < n:
            if trace: g.trace('big text: no color', c.p.h)
        elif n > 1000*10:

            def rehightlight_callback(c=c, d=d, p=c.p, self=self):
                if p == c.p:
                    if trace: g.trace('=====', n, p.h)
                    cursor = QtGui.QTextCursor(d)
                    self.rehighlight_helper(cursor, QtGui.QTextCursor.End)
                else:
                    if trace: g.trace('node not selected', p.h)

            QtCore.QTimer.singleShot(200, rehightlight_callback)
        else:
            if trace: g.trace(n)
            cursor = QtGui.QTextCursor(d)
            self.rehighlight_helper(cursor, QtGui.QTextCursor.End)
.. @+node:ekr.20110605121601.18092: *6* qtew.setAllText
def setAllText(self, s, h=None):
    '''Set the text of body pane.'''
    trace = False and not g.unitTesting
    trace_time = True and not g.unitTesting
    c, w = self.c, self.widget
    if h is None: h = c.p and c.p.h or '<no p>'
    if trace and not trace_time: g.trace(len(s), h)
    colorizer = c.frame.body.colorizer
    highlighter = colorizer.highlighter
    # Be careful: Scintilla doesn't have a colorer.
    colorer = highlighter and highlighter.colorer
    if colorer: colorer.initFlag = True
    try:
        if trace and trace_time:
            t1 = time.time()
        self.changingText = True # Disable onTextChanged.
        colorizer.changingText = True # Disable colorizer.
        # g.trace('read/write text')
        w.setReadOnly(False)
        w.setPlainText(s)
        # w.update()
            # 2014/08/30: w.update does not ensure that all text is loaded
            # before the user starts editing it!
        if trace and trace_time:
            delta_t = time.time() - t1
            g.trace('%4.2f sec. %6s chars %s' % (delta_t, len(s), h))
    finally:
        self.changingText = False
        colorizer.changingText = False
.. @+node:ekr.20160502085421.1: *4* Fixed #275: clone-marked/copy-marked/move-marked
https://github.com/leo-editor/leo-editor/issues/275

There is still a need for generalized commands that work anywhere:

- (done) clone-marked-here (called clone-marked-nodes)
- (todo) copy-marked-here
- (done) move-marked-here (called move-marked-nodes)

EKR:
- These commands would move the cloned/moved/copied nodes after c.p, the presently selected node.
- The command would find all marked nodes, regardless of chapter.
- The commands would move the nodes after c.p, regardless of what chapter is in effect.
.. @+node:ekr.20160502174938.1: *5* ref
.. @+node:ekr.20141023110422.1: *6* find.createCloneFindAllNodes
def createCloneFindAllNodes(self, clones, flattened):
    '''
    Create a "Found" node as the last node of the outline.
    Clone all positions in the clones set a children of found.
    '''
    c = self.c
    # Create the found node.
    assert c.positionExists(c.lastTopLevel()), c.lastTopLevel()
    found = c.lastTopLevel().insertAfter()
    assert found
    assert c.positionExists(found), found
    found.h = 'Found:%s' % self.find_text
    status = self.getFindResultStatus(find_all=True)
    status = status.strip().lstrip('(').rstrip(')').strip()
    flat = 'flattened, ' if flattened else ''
    found.b = '# ' + flat + status
    # Clone nodes as children of the found node.
    for p in clones:
        # Create the clone directly as a child of found.
        p2 = p.copy()
        n = found.numberOfChildren()
        p2._linkAsNthChild(found, n, adjust=False)
    return found
.. @+node:ekr.20031218072017.3073: *6* find.findAll & helpers
def findAll(self, clone_find_all=False, clone_find_all_flattened=False):
    trace = False and not g.unitTesting
    c, flatten = self.c, clone_find_all_flattened
    clone_find = clone_find_all or flatten
    if flatten:
        undoType = 'Clone Find All Flattened'
    elif clone_find_all:
        undoType = 'Clone Find All'
    else:
        undoType = 'Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
        # Sets self.p and self.onlyPosition.
    if trace: g.trace(self.find_text)
    # Init suboutline-only for clone-find-all commands
    # Much simpler: does not set self.p or any other state.
    if self.pattern_match:
        ok = self.precompilePattern()
        if not ok: return
    if self.suboutline_only:
        p = c.p
        after = p.nodeAfterTree()
    else:
        # Always search the entire outline.
        p = c.rootPosition()
        after = None
    # Fix #292: Never collapse nodes during find-all commands.
    old_sparse_find = c.sparse_find
    try:
        c.sparse_find = False
        if clone_find:
            count = self.doCloneFindAll(after, data, flatten, p, undoType)
        else:
            self.p = p
            count = self.doFindAll(after, data, p, undoType)
        # c.contractAllHeadlines()
    finally:
        c.sparse_find = old_sparse_find
    if count:
        c.redraw()
    g.es("found", count, "matches for", self.find_text)
.. @+node:ekr.20160422072841.1: *7* find.doCloneFindAll & helpers
def doCloneFindAll(self, after, data, flatten, p, undoType):
    '''Handle the clone-find-all command, from p to after.'''
    c, u = self.c, self.c.undoer
    count, found = 0, None
    clones, skip = set(), set()
    while p and p != after:
        progress = p.copy()
        if p.v in skip:
            p.moveToThreadNext()
        else:
            count = self.doCloneFindAllHelper(clones, count, flatten, p, skip)
        assert p != progress
    if clones:
        undoData = u.beforeInsertNode(c.p)
        found = self.createCloneFindAllNodes(clones, flatten)
        u.afterInsertNode(found, undoType, undoData, dirtyVnodeList=[])
        assert c.positionExists(found, trace=True), found
        c.setChanged(True)
        c.selectPosition(found)
    else:
        self.restore(data)
    return count
.. @+node:ekr.20141023110422.1: *8* find.createCloneFindAllNodes
def createCloneFindAllNodes(self, clones, flattened):
    '''
    Create a "Found" node as the last node of the outline.
    Clone all positions in the clones set a children of found.
    '''
    c = self.c
    # Create the found node.
    assert c.positionExists(c.lastTopLevel()), c.lastTopLevel()
    found = c.lastTopLevel().insertAfter()
    assert found
    assert c.positionExists(found), found
    found.h = 'Found:%s' % self.find_text
    status = self.getFindResultStatus(find_all=True)
    status = status.strip().lstrip('(').rstrip(')').strip()
    flat = 'flattened, ' if flattened else ''
    found.b = '# ' + flat + status
    # Clone nodes as children of the found node.
    for p in clones:
        # Create the clone directly as a child of found.
        p2 = p.copy()
        n = found.numberOfChildren()
        p2._linkAsNthChild(found, n, adjust=False)
    return found
.. @+node:ekr.20160422071747.1: *8* find.doCloneFindAllHelper
def doCloneFindAllHelper(self, clones, count, flatten, p, skip):
    '''Handle the cff or cfa at node p.'''
    trace = False and not g.unitTesting
    verbose = False
    if trace and verbose: g.trace(p.h)
    if p.is_at_ignore() or re.search(r'(^@|\n@)nosearch\b', p.b):
        if trace: g.trace('===== skipping tree', p.h)
        p.moveToNodeAfterTree()
        return count
    found = self.findNextBatchMatch(p)
    if found:
        if trace and verbose: g.trace('found', p.h)
        clones.add(p.copy())
        count += 1
    if flatten:
        skip.add(p.v)
        p.moveToThreadNext()
    elif found:
        # Don't look at the node or it's descendants.
        for p2 in p.self_and_subtree():
            skip.add(p2.v)
        p.moveToNodeAfterTree()
    else:
        p.moveToThreadNext()
    return count
.. @+node:ekr.20160422073500.1: *7* find.doFindAll & helpers
def doFindAll(self, after, data, p, undoType):
    '''Handle the find-all command from p to after.'''
    c, u, w = self.c, self.c.undoer, self.s_ctrl
    both = self.search_body and self.search_headline
    count, found, result = 0, None, []
    while 1:
        pos, newpos = self.findNextMatch()
        if not self.p: self.p = c.p
        if pos is None: break
        count += 1
        s = w.getAllText()
        i, j = g.getLine(s, pos)
        line = s[i: j]
        if both:
            result.append('%s%s\n%s%s\n' % (
                '-' * 20, self.p.h,
                "head: " if self.in_headline else "body: ",
                line.rstrip()+'\n'))
        elif self.p.isVisited():
            result.append(line.rstrip()+'\n')
        else:
            result.append('%s%s\n%s' % ('-' * 20, self.p.h, line.rstrip()+'\n'))
            self.p.setVisited()
    if result:
        undoData = u.beforeInsertNode(c.p)
        found = self.createFindAllNode(result)
        u.afterInsertNode(found, undoType, undoData, dirtyVnodeList=[])
        c.selectPosition(found)
        c.setChanged(True)
    else:
        self.restore(data)
    return count
.. @+node:ekr.20150717105329.1: *8* find.createFindAllNode
def createFindAllNode(self, result):
    '''Create a "Found All" node as the last node of the outline.'''
    c = self.c
    found = c.lastTopLevel().insertAfter()
    assert found
    found.h = 'Found All:%s' % self.find_text
    status = self.getFindResultStatus(find_all=True)
    status = status.strip().lstrip('(').rstrip(')').strip()
    found.b = '# %s\n%s' % (status, ''.join(result))
    return found
.. @+node:ekr.20160224141710.1: *8* find.findNextBatchMatch
def findNextBatchMatch(self, p):
    '''Find the next batch match at p.'''
    trace = False and not g.unitTesting
    table = []
    if self.search_headline:
        table.append(p.h)
    if self.search_body:
        table.append(p.b)
    for s in table:
        if trace: g.trace('%3s %s' % (len(s), p.h))
        self.reverse = False
        pos, newpos = self.searchHelper(s, 0, len(s), self.find_text)
        if pos != -1: return True
    return False
.. @+node:ekr.20080416161551.215: *6* p._linkAsNthChild
def _linkAsNthChild(self, parent, n, adjust=True):
    '''(low-level position method) Link self as the n'th child of the parent.'''
    p = self
    parent_v = parent.v
    # Init the ivars.
    p.stack = parent.stack[:]
    p.stack.append((parent_v, parent._childIndex),)
    p._childIndex = n
    # New in Leo 5.1: ensure that p.gnx is unique in p's ancestors.
    if 0:
        for parent_v, junk in p.stack:
            g.trace(parent_v.gnx, parent_v.h)
    child = p.v
    child._addLink(n, parent_v, adjust=adjust)
.. @+node:ekr.20040303175026.9: *6* p.copyTreeAfter, copyTreeTo
# These used by unit tests, by the group_operations plugin,
# and by the files-compare-leo-files command.

# To do: use v.copyTree instead.

def copyTreeAfter(self):
    '''Copy p and insert it after itself.'''
    p = self
    p2 = p.insertAfter()
    p.copyTreeFromSelfTo(p2)
    return p2

def copyTreeFromSelfTo(self, p2):
    p = self
    p2.v._headString = p.h
    p2.v._bodyString = p.b
    # 2013/09/08: Fix bug 1019794: p.copyTreeFromSelfTo, should deepcopy p.v.u.
    p2.v.u = copy.deepcopy(p.v.u)
    # 2009/10/02: no need to copy arg to iter
    for child in p.children():
        child2 = p2.insertAsLastChild()
        child.copyTreeFromSelfTo(child2)
.. @+node:ekr.20031218072017.3344: *6* v.__init
def __init__(self, context, gnx=None):
    '''
    Ctor for the VNode class.
    To support ZODB, the code must set v._p_changed = 1 whenever
    v.unknownAttributes or any mutable VNode object changes.
    '''
    # The primary data: headline and body text.
    self._headString = g.u('newHeadline')
    self._bodyString = g.u('')
    # Structure data...
    self.children = []
        # Ordered list of all children of this node.
    self.parents = []
        # Unordered list of all parents of this node.
    # Other essential data...
    self.fileIndex = None
        # The immutable fileIndex (gnx) for this node. Set below.
    self.iconVal = 0
        # The present value of the node's icon.
    self.statusBits = 0
        # status bits
    # Information that is never written to any file...
    self.context = context # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.expandedPositions = []
        # Positions that should be expanded.
    self.insertSpot = None
        # Location of previous insert point.
    self.scrollBarSpot = None
        # Previous value of scrollbar position.
    self.selectionLength = 0
        # The length of the selected body text.
    self.selectionStart = 0
        # The start of the selected body text.
    # To make VNode's independent of Leo's core,
    # wrap all calls to the VNode ctor::
    #
    #   def allocate_vnode(c,gnx):
    #       v = VNode(c)
    #       g.app.nodeIndices.new_vnode_helper(c,gnx,v)
    g.app.nodeIndices.new_vnode_helper(context, gnx, self)
    assert self.fileIndex, g.callers()
.. @+node:ekr.20090804184658.6129: *6* v._addParentLinks
def _addParentLinks(self, parent):
    trace = False and not g.unitTesting
    v = self
    v.parents.append(parent)
    if trace:
        g.trace('v', v.h, 'parent', parent.h, g.callers())
        # '*** added parent', parent, 'to', v, 'len(parents)', len(v.parents))
    if len(v.parents) == 1:
        for child in v.children:
            child._addParentLinks(parent=v)
.. @+node:ekr.20160502174902.1: *5* New & changed
.. @+node:ekr.20090905110447.6098: *6* c.cloneMarked
@cmd('clone-marked-nodes')
def cloneMarked(self, event=None):
    """Clone all marked nodes as children of a new node."""
    c = self; u = c.undoer; p1 = c.p.copy()
    # Create a new node to hold clones.
    parent = p1.insertAfter()
    parent.h = 'Clones of marked nodes'
    cloned, n, p = [], 0, c.rootPosition()
    while p:
        # Careful: don't clone already-cloned nodes.
        if p == parent:
            p.moveToNodeAfterTree()
        elif p.isMarked() and p.v not in cloned:
            cloned.append(p.v)
            if 0: # old code
                # Calling p.clone would cause problems
                p.clone().moveToLastChildOf(parent)
            else: # New code.
                # Create the clone directly as a child of parent.
                p2 = p.copy()
                n = parent.numberOfChildren()
                p2._linkAsNthChild(parent, n, adjust=True)
            p.moveToNodeAfterTree()
            n += 1
        else:
            p.moveToThreadNext()
    if n:
        c.setChanged(True)
        parent.expand()
        c.selectPosition(parent)
        u.afterCloneMarkedNodes(p1)
    else:
        parent.doDelete()
        c.selectPosition(p1)
    if not g.unitTesting:
        g.blue('cloned %s nodes' % (n))
    c.redraw()
.. @+node:ekr.20160502090456.1: *6* c.copyMarked
@cmd('copy-marked-nodes')
def copyMarked(self, event=None):
    """Copy all marked nodes as children of a new node."""
    c = self; u = c.undoer; p1 = c.p.copy()
    # Create a new node to hold clones.
    parent = p1.insertAfter()
    parent.h = 'Copies of marked nodes'
    copied, n, p = [], 0, c.rootPosition()
    while p:
        # Careful: don't clone already-cloned nodes.
        if p == parent:
            p.moveToNodeAfterTree()
        elif p.isMarked() and p.v not in copied:
            copied.append(p.v)
            p2 = p.copyWithNewVnodes(copyMarked=True)
            p2._linkAsNthChild(parent, n, adjust=True)
            p.moveToNodeAfterTree()
            n += 1
        else:
            p.moveToThreadNext()
    if n:
        c.setChanged(True)
        parent.expand()
        c.selectPosition(parent)
        u.afterCopyMarkedNodes(p1)
    else:
        parent.doDelete()
        c.selectPosition(p1)
    if not g.unitTesting:
        g.blue('copied %s nodes' % (n))
    c.redraw()
.. @+node:ekr.20111005081134.15539: *6* c.moveMarked & helper
@cmd('move-marked-nodes')
def moveMarked(self, event=None):
    '''
    Move all marked nodes as children of a new node.
    This command is not undoable.
    Consider using clone-marked-nodes, followed by copy/paste instead.
    '''
    c = self
    p1 = c.p.copy()
    # Check for marks.
    for v in c.all_unique_nodes():
        if v.isMarked():
            break
    else:
        return g.warning('no marked nodes')
    result = g.app.gui.runAskYesNoDialog(c,
        'Move Marked Nodes?',
        message='move-marked-nodes is not undoable\nProceed?',
    )
    if result == 'no':
        return
    # Create a new *root* node to hold the moved nodes.
    # This node's position remains stable while other nodes move.
    parent = c.createMoveMarkedNode()
    assert not parent.isMarked()
    moved = []
    p = c.rootPosition()
    while p:
        assert parent == c.rootPosition()
        # Careful: don't move already-moved nodes.
        if p.isMarked() and not parent.isAncestorOf(p):
            moved.append(p.copy())
            next = p.positionAfterDeletedTree()
            p.moveToLastChildOf(parent)
                # This does not change parent's position.
            p = next
        else:
            p.moveToThreadNext()
    if moved:
        # Find a position p2 outside of parent's tree with p2.v == p1.v.
        # Such a position may not exist.
        p2 = c.rootPosition()
        while p2:
            if p2 == parent:
                p2.moveToNodeAfterTree()
            elif p2.v == p1.v:
                break
            else:
                p2.moveToThreadNext()
        else:
            # Not found.  Move to last top-level.
            p2 = c.lastTopLevel()
        parent.moveAfter(p2)
        # u.afterMoveMarkedNodes(moved, p1)
        if not g.unitTesting:
            g.blue('moved %s nodes' % (len(moved)))
        c.setChanged(True)
    # c.contractAllHeadlines()
        # Causes problems when in a chapter.
    c.selectPosition(parent)
    c.redraw()
.. @+node:ekr.20111005081134.15543: *7* c.createMoveMarkedNode
def createMoveMarkedNode(self):
    c = self
    oldRoot = c.rootPosition()
    p = oldRoot.insertAfter()
    p.moveToRoot(oldRoot)
    c.setHeadString(p, 'Moved marked nodes')
    return p
.. @+node:ekr.20160502095354.1: *6* p.copyWithNewVnodes
def copyWithNewVnodes(self, copyMarked=False):
    '''
    Return an **unliked** copy of p with a new vnode v.
    The new vnode is complete copy of v and all its descendants.
    '''
    p = self
    return Position(v=p.v.copyTree(copyMarked))
.. @+node:ekr.20160502175451.1: *6* u.afterCopyMarkedNodes
def afterCopyMarkedNodes(self, p):
    u = self; c = u.c
    if u.redoing or u.undoing:
        return
    bunch = u.createCommonBunch(p)
        # Sets
        # oldChanged = c.isChanged(),
        # oldDirty = p.isDirty(),
        # oldMarked = p.isMarked(),
        # oldSel = w and w.getSelectionRange() or None,
        # p = p.copy(),
    # Set types & helpers
    bunch.kind = 'copy-marked-nodes'
    bunch.undoType = 'copy-marked-nodes'
    # Set helpers
    bunch.undoHelper = u.undoCopyMarkedNodes
    bunch.redoHelper = u.redoCopyMarkedNodes
    bunch.newP = p.next()
    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()
    u.pushBead(bunch)
.. @+node:ekr.20160502175557.1: *6* u.redoCopyMarkedNodes
def redoCopyMarkedNodes(self):
    u = self; c = u.c
    c.selectPosition(u.p)
    c.copyMarked()
    u.newP = c.p
    u.newChanged = c.isChanged()
.. @+node:ekr.20160502175653.1: *6* u.undoCopyMarkedNodes
def undoCopyMarkedNodes(self):
    u = self
    next = u.p.next()
    assert next.h == 'Copies of marked nodes', (u.p.h, next.h)
    next.doDelete()
    u.p.setAllAncestorAtFileNodesDirty()
    u.c.selectPosition(u.p)
.. @+node:ekr.20160502100151.1: *6* v.copyTree
def copyTree(self, copyMarked=False):
    '''
    Return an all-new tree of vnodes that are copies of self and all its
    descendants.

    **Important**: the v.parents ivar must be [] for all nodes.
    v._addParentLinks will set all parents.
    '''
    v = self
    # Allocate a new vnode and gnx with empty children & parents.
    v2 = VNode(context=v.context, gnx=None)
    assert v2.parents == [], v2.parents
    assert v2.gnx
    assert v.gnx != v2.gnx
    # Copy vnode fields. Do **not** set v2.parents.
    v2._headString = v._headString
    v2._bodyString = v._bodyString
    v2.u = copy.deepcopy(v.u)
    if copyMarked and v.isMarked():
        v2.setMarked()
    # Recursively copy all descendant vnodes.
    for child in v.children:
        v2.children.append(child.copyTree(copyMarked))
    return v2
.. @+node:ekr.20160503055548.1: *5* checkin log
@language rest
@wrap

Completed #275: clone-marked/copy-marked/move-marked.

- Improved clone-marked-nodes and move-marked-nodes.
- Added copy-marked nodes.

These commands work as follows:

- They create an organizer node after c.p.
  (That's not always possible for move-marked-nodes,
  in which case the organizer node becomes the last top-level node).

- They find all marked nodes, regardless of chapter, and leave
  the presently selected chapter selected, if possible.

**Note**: The move-marked-nodes command is no longer undoable.
- The docstring suggests using clone-marked-nodes, followed by copy/paste.
- Moved the undo/redo methods to the attic.
- Modified @test move-marked-nodes so it doesn't check undo/redo.

Added the following new helper methods:

p.copyWithNewVnodes: calls v.copyTree.
v.copyTree: a clearer version of p.copyTreeFromSelfTo.
.. @+node:ekr.20160919142711.1: *4* Fixed #286: @rst-preformat directive is formatted into headline
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/286

The fix was to add '@pre-format' to lists in writeHeadlineHelper and initHeadlineCommands.

These nodes have been tagged with #286.
.. @+node:ekr.20160917194225.1: *4* Fixed #291: mod_autosave.py does not always save...
https://github.com/leo-editor/leo-editor/issues/291
.. @+node:ekr.20120217070122.10467: *5* c.initEventIvars
def initEventIvars(self):
    '''Init ivars relating to gui events.'''
    self.configInited = False
    self.doubleClickFlag = False
    self.exists = True
        # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    self.in_qt_dialog = False
        # True: in a qt dialog.
    self.loading = False
        # True: we are loading a file: disables c.setChanged()
    self.promptingForClose = False
        # True: lock out additional closing dialogs.
    self.suppressHeadChanged = False
        # True: prevent setting c.changed when switching chapters.
    # Flags for c.outerUpdate...
    self.incrementalRecolorFlag = False
    self.requestBringToFront = None # A commander, or None.
    self.requestCloseWindow = False
    self.requestRecolorFlag = False
    self.requestRedrawFlag = False
    self.requestedFocusWidget = None
    self.requestedIconify = '' # 'iconify','deiconify'
.. @+node:ekr.20031218072017.2992: *5* c.endEditing (calls tree.endEditLabel)
# Ends the editing in the outline.

def endEditing(self):
    trace = False and not g.unitTesting
    c = self
    p = c.p
    if p:
        if trace: g.trace(p.h, g.callers())
        c.frame.tree.endEditLabel()
    # The following code would be wrong; c.endEditing is a utility method.
    # k = c.k
    # if k:
        # k.setDefaultInputState()
        # # Recolor the *body* text, **not** the headline.
        # k.showStateAndMode(w=c.frame.body.wrapper)
.. @+node:ekr.20031218072017.3046: *5* fc.write_Leo_file & helpers
def write_Leo_file(self, fileName, outlineOnlyFlag, toString=False, toOPML=False):
    '''Write the .leo file.'''
    c, fc = self.c, self
    structure_errors = c.checkOutline()
    if structure_errors:
        g.error('Major structural errors! outline not written')
        return False
    if not outlineOnlyFlag or toOPML:
        g.app.recentFilesManager.writeRecentFilesFile(c)
        fc.writeAllAtFileNodesHelper() # Ignore any errors.
    if fc.isReadOnly(fileName):
        return False
    try:
        fc.putCount = 0
        fc.toString = toString
        if toString:
            ok = fc.writeToStringHelper(fileName)
        else:
            ok = fc.writeToFileHelper(fileName, toOPML)
    finally:
        fc.outputFile = None
        fc.toString = False
    return ok

write_LEO_file = write_Leo_file # For compatibility with old plugins.
.. @+node:ekr.20040324080359.1: *6* fc.isReadOnly
def isReadOnly(self, fileName):
    # self.read_only is not valid for Save As and Save To commands.
    if g.os_path_exists(fileName):
        try:
            if not os.access(fileName, os.W_OK):
                g.error("can not write: read only:", fileName)
                return True
        except Exception:
            pass # os.access() may not exist on all platforms.
    return False
.. @+node:ekr.20100119145629.6114: *6* fc.writeAllAtFileNodesHelper
def writeAllAtFileNodesHelper(self):
    '''Write all @<file> nodes and set orphan bits.'''
    c = self.c
    try:
        # 2010/01/19: Do *not* signal failure here.
        # This allows Leo to quit properly.
        c.atFileCommands.writeAll()
        return True
    except Exception:
        # Work around bug 1260415: https://bugs.launchpad.net/leo-editor/+bug/1260415
        g.es_error("exception writing external files")
        g.es_exception()
        g.es('Internal error writing one or more external files.', color='red')
        g.es('Please report this error to:', color='blue')
        g.es('https://groups.google.com/forum/#!forum/leo-editor', color='blue')
        g.es('All changes will be lost unless you', color='red')
        g.es('can save each changed file.', color='red')
        return False
.. @+node:ekr.20100119145629.6111: *6* fc.writeToFileHelper & helpers
def writeToFileHelper(self, fileName, toOPML):
    c = self.c; toZip = c.isZipped
    ok, backupName = self.createBackupFile(fileName)
    if not ok: return False
    fileName, theActualFile = self.createActualFile(fileName, toOPML, toZip)
    if not theActualFile: return False
    self.mFileName = fileName
    self.outputFile = StringIO() # Always write to a string.
    try:
        if toOPML:
            if hasattr(c, 'opmlController'):
                c.opmlController.putToOPML(owner=self)
            else:
                # This is not likely ever to be called.
                g.trace('leoOPML plugin not active.')
        else:
            self.putLeoFile()
        s = self.outputFile.getvalue()
        g.app.write_Leo_file_string = s # 2010/01/19: always set this.
        if toZip:
            self.writeZipFile(s)
        else:
            if g.isPython3:
                s = bytes(s, self.leo_file_encoding, 'replace')
            theActualFile.write(s)
            theActualFile.close()
            c.setFileTimeStamp(fileName)
            # raise AttributeError # To test handleWriteLeoFileException.
            # Delete backup file.
            if backupName and g.os_path_exists(backupName):
                self.deleteFileWithMessage(backupName, 'backup')
        return True
    except Exception:
        self.handleWriteLeoFileException(
            fileName, backupName, theActualFile)
        return False
.. @+node:ekr.20100119145629.6106: *7* fc.createActualFile
def createActualFile(self, fileName, toOPML, toZip):
    if toZip:
        self.toString = True
        theActualFile = None
    else:
        try:
            # 2010/01/21: always write in binary mode.
            theActualFile = open(fileName, 'wb')
        except IOError:
            g.es('can not open %s' % fileName)
            g.es_exception()
            theActualFile = None
    return fileName, theActualFile
.. @+node:ekr.20031218072017.3047: *7* fc.createBackupFile
def createBackupFile(self, fileName):
    '''
        Create a closed backup file and copy the file to it,
        but only if the original file exists.
    '''
    if g.os_path_exists(fileName):
        fd, backupName = tempfile.mkstemp(text=False)
        f = open(fileName, 'rb') # rb is essential.
        s = f.read()
        f.close()
        try:
            try:
                os.write(fd, s)
            finally:
                os.close(fd)
            ok = True
        except Exception:
            g.error('exception creating backup file')
            g.es_exception()
            ok, backupName = False, None
        if not ok and self.read_only:
            g.error("read only")
    else:
        ok, backupName = True, None
    return ok, backupName
.. @+node:ekr.20100119145629.6108: *7* fc.handleWriteLeoFileException
def handleWriteLeoFileException(self, fileName, backupName, theActualFile):
    c = self.c
    g.es("exception writing:", fileName)
    g.es_exception(full=True)
    if theActualFile:
        theActualFile.close()
    # Delete fileName.
    if fileName and g.os_path_exists(fileName):
        self.deleteFileWithMessage(fileName, '')
    # Rename backupName to fileName.
    if backupName and g.os_path_exists(backupName):
        g.es("restoring", fileName, "from", backupName)
        # No need to create directories when restoring.
        g.utils_rename(c, backupName, fileName)
    else:
        g.error('backup file does not exist!', repr(backupName))
.. @+node:ekr.20100119145629.6110: *6* fc.writeToStringHelper
def writeToStringHelper(self, fileName):
    try:
        self.mFileName = fileName
        self.outputFile = StringIO()
        self.putLeoFile()
        s = self.outputFile.getvalue()
        g.app.write_Leo_file_string = s
        return True
    except Exception:
        g.es("exception writing:", fileName)
        g.es_exception(full=True)
        g.app.write_Leo_file_string = ''
        return False
.. @+node:ekr.20070412095520: *6* fc.writeZipFile
def writeZipFile(self, s):
    # The name of the file in the archive.
    contentsName = g.toEncodedString(
        g.shortFileName(self.mFileName),
        self.leo_file_encoding, reportErrors=True)
    # The name of the archive itself.
    fileName = g.toEncodedString(
        self.mFileName,
        self.leo_file_encoding, reportErrors=True)
    # Write the archive.
    theFile = zipfile.ZipFile(fileName, 'w', zipfile.ZIP_DEFLATED)
    theFile.writestr(contentsName, s)
    theFile.close()
.. @+node:ekr.20160704084005.1: *4* Fixed #292: find-all commands collapse outline
https://github.com/leo-editor/leo-editor/issues/292

The new code temporarily sets c.sparse_find to False.
.. @+node:ekr.20160802091903.1: *4* Fixed #295: Enhancement request: after-headline-edit hook
https://github.com/leo-editor/leo-editor/issues/295
.. @+node:ekr.20160802074335.1: *5* Found:headkey1
# flattened, word, ignore-case, head, body
.. @+node:ekr.20040803072955.91: *6* onHeadChanged (Used by the leoBridge module)
# Tricky code: do not change without careful thought and testing.
# Important: This code *is* used by the leoBridge module.
# See also, nativeTree.onHeadChanged.

def onHeadChanged(self, p, undoType='Typing', s=None, e=None): # e used in qt_tree.py.
    '''
    Officially change a headline.
    Set the old undo text to the previous revert point.
    '''
    trace = False and not g.unitTesting
    c = self.c; u = c.undoer
    w = self.edit_widget(p)
    if c.suppressHeadChanged:
        if trace: g.trace('c.suppressHeadChanged')
        return
    if not w:
        if trace: g.trace('****** no w for p: %s', repr(p))
        return
    ch = '\n' # New in 4.4: we only report the final keystroke.
    if s is None: s = w.getAllText()
    if trace:
        g.trace('*** LeoTree', g.callers(5))
        g.trace(p and p.h, 'w', repr(w), 's', repr(s))
    << truncate s if it has multiple lines >>
    # Make the change official, but undo to the *old* revert point.
    oldRevert = self.revertHeadline
    changed = s != oldRevert
    self.revertHeadline = s
    p.initHeadString(s)
    if trace: g.trace('changed', changed, 'new', repr(s))
    if g.doHook("headkey1", c=c, p=p, v=p, ch=ch, changed=changed):
        return # The hook claims to have handled the event.
    if changed:
        undoData = u.beforeChangeNodeContents(p, oldHead=oldRevert)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.scanForTabWidth(p)
        c.frame.body.recolor(p, incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p, undoType, undoData,
            dirtyVnodeList=dirtyVnodeList, inHead=True)
    if changed:
        c.redraw_after_head_changed()
        # Fix bug 1280689: don't call the non-existent c.treeEditFocusHelper
    g.doHook("headkey2", c=c, p=p, v=p, ch=ch, changed=changed)
.. @+node:ekr.20040803072955.94: *7* << truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
# for i in (0,1):
    # if s and s[-1] == '\n':
        # if len(s) > 1: s = s[:-1]
        # else: s = ''
while s and s[-1] == '\n':
    s = s[: -1]
# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.warning("truncating headline to one line")
    s = s[: i]
limit = 1000
if len(s) > limit:
    g.warning("truncating headline to", limit, "characters")
    s = s[: limit]
s = g.toUnicode(s or '')
.. @+node:ekr.20110605121601.17912: *6* qtree.onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged(self, p, undoType='Typing', s=None, e=None):
    '''Officially change a headline.'''
    trace = False and not g.unitTesting
    trace_hook = True
    verbose = False
    c = self.c; u = c.undoer
    if not p:
        if trace and verbose: g.trace('** no p')
        return
    item = self.getCurrentItem()
    if not item:
        if trace and verbose: g.trace('** no item')
        return
    if not e:
        e = self.getTreeEditorForItem(item)
    if not e:
        if trace and verbose: g.trace('(nativeTree) ** not editing')
        return
    s = g.u(e.text())
    self.closeEditorHelper(e, item)
    oldHead = p.h
    changed = s != oldHead
    if trace and trace_hook:
        g.trace('headkey1: changed %s' % (changed), g.callers())
    if g.doHook("headkey1", c=c, p=c.p, v=c.p, s=s, changed=changed):
        return
    if changed:
        # New in Leo 4.10.1.
        if trace: g.trace('(nativeTree) new', repr(s), 'old', repr(p.h))
        << truncate s if it has multiple lines >>
        p.initHeadString(s)
        item.setText(0, s) # Required to avoid full redraw.
        undoData = u.beforeChangeNodeContents(p, oldHead=oldHead)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p, incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p, undoType, undoData,
            dirtyVnodeList=dirtyVnodeList, inHead=True) # 2013/08/26.
    g.doHook("headkey2", c=c, p=c.p, v=c.p, s=s, changed=changed)
    # This is a crucial shortcut.
    if g.unitTesting: return
    if changed:
        self.redraw_after_head_changed()
    if 0: # Don't do this: it interferes with clicks, and is not needed.
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    p.v.contentModified()
    c.outerUpdate()
.. @+node:ekr.20120409185504.10028: *7* << truncate s if it has multiple lines >>
# Remove trailing newlines before warning of truncation.
while s and s[-1] == '\n':
    s = s[: -1]
# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    s = s[: i]
    if s != oldHead:
        g.warning("truncating headline to one line")
limit = 1000
if len(s) > limit:
    s = s[: limit]
    if s != oldHead:
        g.warning("truncating headline to", limit, "characters")
.. @+node:ekr.20160802074759.1: *5* Found:onheadchanged
# flattened, word, ignore-case, head, body
.. @+node:ekr.20140907201613.18663: *6* class TreeAPI
class TreeAPI(object):
    '''The required API for c.frame.tree.'''

    def __init__(self, frame): pass
    # Must be defined in subclasses.

    def drawIcon(self, p): pass

    def editLabel(self, v, selectAll=False, selection=None): pass

    def edit_widget(self, p): return None

    def redraw(self, p=None, scroll=True, forceDraw=False): pass

    def redraw_now(self, p=None, scroll=True, forceDraw=False): pass

    def scrollTo(self, p): pass
    # May be defined in subclasses.

    def initAfterLoad(self): pass

    def afterSelectHint(self, p, old_p): pass

    def beforeSelectHint(self, p, old_p): pass

    def onHeadChanged(self, p, undoType='Typing', s=None, e=None): pass
    # Hints for optimization. The proper default is c.redraw()

    def redraw_after_contract(self, p=None): pass

    def redraw_after_expand(self, p=None): pass

    def redraw_after_head_changed(self): pass

    def redraw_after_icons_changed(self): pass

    def redraw_after_select(self, p=None): pass
    # Must be defined in the LeoTree class...
    # def OnIconDoubleClick (self,p):

    def OnIconCtrlClick(self, p): pass

    def editPosition(self): return None

    def endEditLabel(self): pass

    def getEditTextDict(self, v): return None

    def injectCallbacks(self): pass

    def onHeadlineKey(self, event): pass

    def select(self, p, scroll=True): pass

    def setEditPosition(self, p): pass

    def updateHead(self, event, w): pass
.. @+node:ekr.20040803072955.91: *6* onHeadChanged (Used by the leoBridge module)
# Tricky code: do not change without careful thought and testing.
# Important: This code *is* used by the leoBridge module.
# See also, nativeTree.onHeadChanged.

def onHeadChanged(self, p, undoType='Typing', s=None, e=None): # e used in qt_tree.py.
    '''
    Officially change a headline.
    Set the old undo text to the previous revert point.
    '''
    trace = False and not g.unitTesting
    c = self.c; u = c.undoer
    w = self.edit_widget(p)
    if c.suppressHeadChanged:
        if trace: g.trace('c.suppressHeadChanged')
        return
    if not w:
        if trace: g.trace('****** no w for p: %s', repr(p))
        return
    ch = '\n' # New in 4.4: we only report the final keystroke.
    if s is None: s = w.getAllText()
    if trace:
        g.trace('*** LeoTree', g.callers(5))
        g.trace(p and p.h, 'w', repr(w), 's', repr(s))
    << truncate s if it has multiple lines >>
    # Make the change official, but undo to the *old* revert point.
    oldRevert = self.revertHeadline
    changed = s != oldRevert
    self.revertHeadline = s
    p.initHeadString(s)
    if trace: g.trace('changed', changed, 'new', repr(s))
    if g.doHook("headkey1", c=c, p=p, v=p, ch=ch, changed=changed):
        return # The hook claims to have handled the event.
    if changed:
        undoData = u.beforeChangeNodeContents(p, oldHead=oldRevert)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.scanForTabWidth(p)
        c.frame.body.recolor(p, incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p, undoType, undoData,
            dirtyVnodeList=dirtyVnodeList, inHead=True)
    if changed:
        c.redraw_after_head_changed()
        # Fix bug 1280689: don't call the non-existent c.treeEditFocusHelper
    g.doHook("headkey2", c=c, p=p, v=p, ch=ch, changed=changed)
.. @+node:ekr.20040803072955.94: *7* << truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
# for i in (0,1):
    # if s and s[-1] == '\n':
        # if len(s) > 1: s = s[:-1]
        # else: s = ''
while s and s[-1] == '\n':
    s = s[: -1]
# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.warning("truncating headline to one line")
    s = s[: i]
limit = 1000
if len(s) > limit:
    g.warning("truncating headline to", limit, "characters")
    s = s[: limit]
s = g.toUnicode(s or '')
.. @+node:ekr.20040803072955.126: *6* LeoTree.endEditLabel
def endEditLabel(self):
    '''End editing of a headline and update p.h.'''
    trace = False and not g.unitTesting
    c = self.c; k = c.k; p = c.p
    if trace: g.trace('LeoTree', p and p.h, g.callers(4))
    self.setEditPosition(None) # That is, self._editPosition = None
    # Important: this will redraw if necessary.
    self.onHeadChanged(p)
    if 0: # Can't call setDefaultUnboundKeyAction here: it might put us in ignore mode!
        k.setDefaultInputState()
        k.showStateAndMode()
    if 0: # This interferes with the find command and interferes with focus generally!
        c.bodyWantsFocus()
.. @+node:ekr.20031218072017.3070: *6* find.changeSelection
# Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):
    c = self.c
    p = self.p or c.p # 2015/06/22
    wrapper = c.frame.body and c.frame.body.wrapper
    w = c.edit_widget(p) if self.in_headline else wrapper
    if not w:
        self.in_headline = False
        w = wrapper
    if not w: return
    oldSel = sel = w.getSelectionRange()
    start, end = sel
    if start > end: start, end = end, start
    if start == end:
        g.es("no text selected"); return False
    # g.trace(start,end)
    # Replace the selection in _both_ controls.
    start, end = oldSel
    change_text = self.change_text
    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text, groups)
    # change_text = change_text.replace('\\n','\n').replace('\\t','\t')
    change_text = self.replaceBackSlashes(change_text)
    for w2 in (w, self.s_ctrl):
        if start != end: w2.delete(start, end)
        w2.insert(start, change_text)
        w2.setInsertPoint(start if self.reverse else start + len(change_text))
    # Update the selection for the next match.
    w.setSelectionRange(start, start + len(change_text))
    c.widgetWantsFocus(w)
    # No redraws here: they would destroy the headline selection.
    if self.mark_changes:
        p.setMarked()
    if self.in_headline:
        c.frame.tree.onHeadChanged(p, 'Change')
    else:
        c.frame.body.onBodyChanged('Change', oldSel=oldSel)
    c.frame.tree.drawIcon(p) # redraw only the icon.
    return True
.. @+node:ekr.20060526201951: *7* makeRegexSubs
def makeRegexSubs(self, s, groups):
    r'''
    Carefully substitute group[i-1] for \i strings in s.
    The group strings may contain \i strings: they are *not* substituted.
    '''
    digits = '123456789'
    result = []; n = len(s)
    i = j = 0 # s[i:j] is the text between \i markers.
    while j < n:
        k = s.find('\\', j)
        if k == -1 or k + 1 >= n:
            break
        j = k + 1; ch = s[j]
        if ch in digits:
            j += 1
            result.append(s[i: k]) # Append up to \i
            i = j
            gn = int(ch) - 1
            if gn < len(groups):
                result.append(groups[gn]) # Append groups[i-1]
            else:
                result.append('\\%s' % ch) # Append raw '\i'
    result.append(s[i:])
    return ''.join(result)
.. @+node:ekr.20110605121601.17912: *6* qtree.onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged(self, p, undoType='Typing', s=None, e=None):
    '''Officially change a headline.'''
    trace = False and not g.unitTesting
    trace_hook = True
    verbose = False
    c = self.c; u = c.undoer
    if not p:
        if trace and verbose: g.trace('** no p')
        return
    item = self.getCurrentItem()
    if not item:
        if trace and verbose: g.trace('** no item')
        return
    if not e:
        e = self.getTreeEditorForItem(item)
    if not e:
        if trace and verbose: g.trace('(nativeTree) ** not editing')
        return
    s = g.u(e.text())
    self.closeEditorHelper(e, item)
    oldHead = p.h
    changed = s != oldHead
    if trace and trace_hook:
        g.trace('headkey1: changed %s' % (changed), g.callers())
    if g.doHook("headkey1", c=c, p=c.p, v=c.p, s=s, changed=changed):
        return
    if changed:
        # New in Leo 4.10.1.
        if trace: g.trace('(nativeTree) new', repr(s), 'old', repr(p.h))
        << truncate s if it has multiple lines >>
        p.initHeadString(s)
        item.setText(0, s) # Required to avoid full redraw.
        undoData = u.beforeChangeNodeContents(p, oldHead=oldHead)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p, incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p, undoType, undoData,
            dirtyVnodeList=dirtyVnodeList, inHead=True) # 2013/08/26.
    g.doHook("headkey2", c=c, p=c.p, v=c.p, s=s, changed=changed)
    # This is a crucial shortcut.
    if g.unitTesting: return
    if changed:
        self.redraw_after_head_changed()
    if 0: # Don't do this: it interferes with clicks, and is not needed.
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    p.v.contentModified()
    c.outerUpdate()
.. @+node:ekr.20120409185504.10028: *7* << truncate s if it has multiple lines >>
# Remove trailing newlines before warning of truncation.
while s and s[-1] == '\n':
    s = s[: -1]
# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    s = s[: i]
    if s != oldHead:
        g.warning("truncating headline to one line")
limit = 1000
if len(s) > limit:
    s = s[: limit]
    if s != oldHead:
        g.warning("truncating headline to", limit, "characters")
.. @+node:ekr.20110605121601.18418: *6* qtree.connectEditorWidget & helper
def connectEditorWidget(self, e, item):
    if not e:
        return g.trace('can not happen: no e')
    # Hook up the widget.
    wrapper = self.getWrapper(e, item)

    def editingFinishedCallback(e=e, item=item, self=self, wrapper=wrapper):
        # g.trace(wrapper,g.callers(5))
        c = self.c
        w = self.treeWidget
        self.onHeadChanged(p=c.p, e=e)
        w.setCurrentItem(item)

    e.editingFinished.connect(editingFinishedCallback)
    return wrapper # 2011/02/12
.. @+node:ekr.20160917045514.1: *4* Fixed #301: Log window doesn't get line separators
.. @+node:ekr.20070626132332: *5* g.es
def es(*args, **keys):
    '''Put all non-keyword args to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''
    trace = False
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    if trace: # Effective for debugging.
        print()
        print('***es', args, keys)
        print('***es', 'logInited', app.logInited, 'log', log and id(log))
        print('***es', g.callers())
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress': return # New in 4.3.
    elif log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    newline = d.get('newline')
    s = g.translateArgs(args, d)
    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            # This makes the output of unit tests match the output of scripts.
            # s = g.toEncodedString(s,'ascii')
            g.pr(s, newline=newline)
    elif log and app.logInited:
        log.put(s, color=color, tabName=tabName)
        for ch in s:
            if ch == '\n': log.newlines += 1
            else: log.newlines = 0
        if newline:
            g.ecnl(tabName=tabName) # only valid here
    # 2012/05/20: Don't do this.
    # elif app.logInited:
        # print(s.rstrip()) # Happens only rarely.
    elif newline:
        app.logWaiting.append((s + '\n', color),)
    else:
        app.logWaiting.append((s, color),)
.. @+node:ekr.20110605121601.18322: *5* LeoQtLog.put
def put(self, s, color=None, tabName='Log', from_redirect=False):
    '''All output to the log stream eventually comes here.'''
    trace = False and not g.unitTesting
    c = self.c
    if g.app.quitting or not c or not c.exists:
        print('LeoQtLog.log.put fails', repr(s))
        return
    if color:
        color = leoColor.getColor(color, 'black')
    else:
        color = leoColor.getColor('black')
    self.selectTab(tabName or 'Log')
    # Must be done after the call to selectTab.
    w = self.logCtrl.widget # w is a QTextBrowser
    if trace:
        print('LeoQtLog.put: %r' % (s))
    if w:
        sb = w.horizontalScrollBar()
        # pos = sb.sliderPosition()
        # g.trace(pos,sb,g.callers())
        s = s.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
        if not self.wrap: # 2010/02/21: Use &nbsp; only when not wrapping!
            s = s.replace(' ', '&nbsp;')
        if from_redirect:
            s = s.replace('\n', '<br>')
        else:
            s = s.rstrip().replace('\n', '<br>')
        s = '<font color="%s">%s</font>' % (color, s)
        if trace:
            # print('LeoQtLog.put: %4s redirect: %5s\n  %s' % (
                # len(s), from_redirect, s))
            print('LeoQtLog.put: %r' % (s))
        if from_redirect:
            w.insertHtml(s)
        else:
            # w.append(s)
                # w.append is a QTextBrowser method.
                # This works.
            # This also works.  Use it to see if it fixes #301:
            # Log window doesn't get line separators
            w.insertHtml(s+'<br>')
        w.moveCursor(QtGui.QTextCursor.End)
        sb.setSliderPosition(0) # Force the slider to the initial position.
    else:
        # put s to logWaiting and print s
        g.app.logWaiting.append((s, color),)
        if g.isUnicode(s):
            s = g.toEncodedString(s, "ascii")
        print(s)
.. @+node:ekr.20110605121601.18323: *5* LeoQtLog.putnl
def putnl(self, tabName='Log'):
    '''Put a newline to the Qt log.'''
    # This is not called normally.
    # print('LeoQtLog.put: %s' % g.callers())
    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    w = self.logCtrl.widget
    if w:
        sb = w.horizontalScrollBar()
        pos = sb.sliderPosition()
        # Not needed!
            # contents = w.toHtml()
            # w.setHtml(contents + '\n')
        w.moveCursor(QtGui.QTextCursor.End)
        sb.setSliderPosition(pos)
        w.repaint() # Slow, but essential.
    else:
        # put s to logWaiting and print  a newline
        g.app.logWaiting.append(('\n', 'black'),)
.. @+node:ekr.20160917051053.1: *5* Found:putnl
# flattened, word, ignore-case, head, body
.. @+node:ekr.20041012083237.3: *6* put and putnl (NullLog)
def put(self, s, color=None, tabName='Log', from_redirect=False):
    # print('(nullGui) print',repr(s))
    if self.enabled:
        try:
            g.pr(s, newline=False)
        except UnicodeError:
            s = s.encode('ascii', 'replace')
            g.pr(s, newline=False)

def putnl(self, tabName='Log'):
    if self.enabled:
        g.pr('')
.. @+node:ekr.20070302101304: *6* LeoLog.put & putnl
# All output to the log stream eventually comes here.

def put(self, s, color=None, tabName='Log', from_redirect=False):
    print(s)

def putnl(self, tabName='Log'):
    pass # print ('')
.. @+node:ekr.20031218072017.1474: *6* g.enl, ecnl & ecnls
def ecnl(tabName='Log'):
    g.ecnls(1, tabName)

def ecnls(n, tabName='Log'):
    log = app.log
    if log and not log.isNull:
        while log.newlines < n:
            g.enl(tabName)

def enl(tabName='Log'):
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl(tabName)
.. @+node:ekr.20110605121601.18323: *6* LeoQtLog.putnl
def putnl(self, tabName='Log'):
    '''Put a newline to the Qt log.'''
    # This is not called normally.
    # print('LeoQtLog.put: %s' % g.callers())
    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    w = self.logCtrl.widget
    if w:
        sb = w.horizontalScrollBar()
        pos = sb.sliderPosition()
        # Not needed!
            # contents = w.toHtml()
            # w.setHtml(contents + '\n')
        w.moveCursor(QtGui.QTextCursor.End)
        sb.setSliderPosition(pos)
        w.repaint() # Slow, but essential.
    else:
        # put s to logWaiting and print  a newline
        g.app.logWaiting.append(('\n', 'black'),)
.. @+node:ekr.20160917043524.1: *4* Fixed #302: revert to saved doesn't reset external file change monitoring
https://github.com/leo-editor/leo-editor/issues/302

@language rest
@wrap

It seems revert to saved, which reloads the whole outline, does not reset the external file change monitoring (timestamps?) so that editing and saving an
@<file> after the revert triggers spurious warnings about the file being
modified externally.

@language python
.. @+node:ekr.20120427064024.10064: *5* app.checkForOpenFile
def checkForOpenFile(self, c, fn):
    '''Warn if fn is already open and add fn to already_open_files list.'''
    d, tag = g.app.db, 'open-leo-files'
    if g.app.reverting:
        # Fix #302: revert to saved doesn't reset external file change monitoring
        g.app.already_open_files = []
    if d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting:
        return
    aList = g.app.db.get(tag) or []
    if fn in aList:
        # The file may be open in another copy of Leo, or not:
        # another Leo may have been killed prematurely.
        # Put the file on the global list.
        # A dialog will warn the user such files later.
        if fn not in g.app.already_open_files:
            g.es('may be open in another Leo:', color='red')
            g.es(fn)
            g.app.already_open_files.append(fn)
    else:
        g.app.rememberOpenFile(fn)
.. @+node:ekr.20120427064024.10068: *5* app.Detecting already-open files
.. @+node:ekr.20120427064024.10064: *6* app.checkForOpenFile
def checkForOpenFile(self, c, fn):
    '''Warn if fn is already open and add fn to already_open_files list.'''
    d, tag = g.app.db, 'open-leo-files'
    if g.app.reverting:
        # Fix #302: revert to saved doesn't reset external file change monitoring
        g.app.already_open_files = []
    if d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting:
        return
    aList = g.app.db.get(tag) or []
    if fn in aList:
        # The file may be open in another copy of Leo, or not:
        # another Leo may have been killed prematurely.
        # Put the file on the global list.
        # A dialog will warn the user such files later.
        if fn not in g.app.already_open_files:
            g.es('may be open in another Leo:', color='red')
            g.es(fn)
            g.app.already_open_files.append(fn)
    else:
        g.app.rememberOpenFile(fn)
.. @+node:ekr.20120427064024.10066: *6* app.forgetOpenFile
def forgetOpenFile(self, fn, force=False):
    '''Forget the open file, so that is no longer considered open.'''
    trace = self.trace_shutdown and not g.unitTesting
    d, tag = g.app.db, 'open-leo-files'
    if not d or not fn:
        # Fix https://github.com/leo-editor/leo-editor/issues/69
        return
    if not force and (d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting):
        return
    aList = d.get(tag) or []
    if fn in aList:
        aList.remove(fn)
        if trace:
            print('forgetOpenFile: %s' % g.shortFileName(fn))
            # for z in aList:
            #    print('  %s' % (z))
        d[tag] = aList
    else:
        if trace: print('forgetOpenFile: did not remove: %s' % (fn))
.. @+node:ekr.20120427064024.10065: *6* app.rememberOpenFile
def rememberOpenFile(self, fn):
    trace = False and not g.unitTesting
    d, tag = g.app.db, 'open-leo-files'
    if d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting:
        pass
    elif g.app.preReadFlag:
        pass
    else:
        aList = d.get(tag) or []
        # It's proper to add duplicates to this list.
        aList.append(fn)
        if trace:
            # Trace doesn't work well while initing.
            print('rememberOpenFile:added: %s' % (fn))
            for z in aList:
                print('  %s' % (z))
        d[tag] = aList
.. @+node:ekr.20150621062355.1: *6* app.runAlreadyOpenDialog
def runAlreadyOpenDialog(self, c):
    '''Warn about possibly already-open files.'''
    # g.trace(g.app.already_open_files)
    if g.app.already_open_files:
        aList = sorted(set(g.app.already_open_files))
        g.app.already_open_files = []
        g.app.gui.dismiss_splash_screen()
        message = (
            'The following files may already be open\n'
            'in another copy of Leo:\n\n' +
            '\n'.join(aList))
        g.app.gui.runAskOkDialog(c,
            title='Already Open Files',
            message=message,
            text="Ok")
.. @+node:ekr.20160919063539.1: *4* Fixed bug in ac.get_summary_list
This bug only shows up when using Python 3, because of different rules for scopes in comprehensions.
.. @+node:ekr.20160427103708.1: *4* Fixed expand-to-level bug
.. @+node:ekr.20160514170217.1: *4* Fixed syntax coloring nits
The colorizer now colorizers the following properly:

@language python

@staticmethod
@classmethod
basestring

.. @+node:ekr.20160502073033.1: *4* Investigated #273: Qt Bug involving large text nodes
Only minor improvements were made.

The ultimate source of the delay when selecting large text is *not* syntax coloring,
but instead the call to self.old_w.setPlainText(self.p.b) in btw.create_widgets.

Experiments show loading "dummy" text in btw.create_widgets can lead to data loss.
There are too many paths through the selection logic to attemp to "recover"
from the failure to load the body widget initially.

Obviously, data loss is a much bigger problem than slow load times.
I am going to declare this issue not to be solvable.
.. @+node:ekr.20160504150917.1: *3* Code
.. @+node:ekr.20160517182148.1: *4* @buttons for pyflakes & flake8
.. @+node:ekr.20160516074313.1: *5* @@button test-pyflakes @key=Ctrl-6
# g.cls()
import os
import pyflakes
import sys
import time
if 1:
    p = c.p
else:
    h = '@file leoApp.py'
    p = g.findNodeAnywhere(c, h)
assert p
@others
if c.isChanged():
    c.save()
PyflakesCommand(c).run(p=p)

.. @+node:ekr.20160516072613.2: *6* class PyflakesCommand
class PyflakesCommand(object):
    '''A class to run pyflakes on all Python @<file> nodes in c.p's tree.'''

    def __init__(self, c):
        '''ctor for PyflakesCommand class.'''
        self.c = c
        self.seen = [] # List of checked paths.

    @others
.. @+node:ekr.20160516072613.6: *7* pyflakes.check_all
def check_all(self, paths):
    '''Run pyflakes on fn.'''
    from pyflakes import api, reporter
    for fn in sorted(paths):
        # Report the file name.
        sfn = g.shortFileName(fn)
        s = g.readFileIntoEncodedString(fn, silent=False)
        if not s.strip():
            return
        r = reporter.Reporter(
            errorStream=sys.stderr,
            warningStream=sys.stderr,
            )
        errors = api.check(s, sfn, r)
        if False and errors:
            # Annoying.
            print('%s error%s in %s' % (errors, g.plural(errors), fn))
.. @+node:ekr.20160516072613.3: *7* pyflakes.find
def find(self, p):
    '''Return True and add p's path to self.seen if p is a Python @<file> node.'''
    found = False
    if p.isAnyAtFileNode():
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
        fn = p.anyAtFileNodeName()
        if fn.endswith('.py'):
            fn = g.os_path_finalize_join(path, fn)
            if fn not in self.seen:
                self.seen.append(fn)
                found = True
    return found
.. @+node:ekr.20160516072613.5: *7* pyflakes.run
def run(self, p=None):
    '''Run Pyflakes on all Python @<file> nodes in c.p's tree.'''
    c = self.c
    root = p or c.p
    # Make sure Leo is on sys.path.
    leo_path = g.os_path_finalize_join(g.app.loadDir, '..')
    if leo_path not in sys.path:
        sys.path.append(leo_path)
    # Run pyflakes on all Python @<file> nodes in root's tree.
    t1 = time.time()
    found = False
    for p in root.self_and_subtree():
        found |= self.find(p)
    # Look up the tree if no @<file> nodes were found.
    if not found:
        for p in root.parents():
            if self.find(p):
                found = True
                break
    # If still not found, expand the search if root is a clone.
    if not found:
        isCloned = any([p.isCloned() for p in root.self_and_parents()])
        if isCloned:
            for p in c.all_positions():
                if p.isAnyAtFileNode():
                    isAncestor = any([z.v == root.v for z in p.self_and_subtree()])
                    if isAncestor and self.find(p):
                        break
    paths = list(set(self.seen))
    if paths:
        self.check_all(paths)
    g.es_print('pyflakes: %s file%s in %s' % (
        len(paths), g.plural(paths), g.timeSince(t1)))
.. @+node:ekr.20160517134233.1: *5* @@button test-flake8 @key=Ctrl-7
# g.cls()
import flake8
import os
import sys
import time
if 1:
    p = c.p
else:
    h = '@file leoApp.py'
    p = g.findNodeAnywhere(c, h)
assert p
@others
if c.isChanged():
    c.save()
Flake8Command(c).run(p=p)

.. @+node:ekr.20160517133049.1: *6* class Flake8Command
class Flake8Command(object):
    '''A class to run flake8 on all Python @<file> nodes in c.p's tree.'''

    def __init__(self, c, quiet=False):
        '''ctor for Flake8Command class.'''
        self.c = c
        self.quiet = quiet
        self.seen = [] # List of checked paths.

    @others
.. @+node:ekr.20160517133049.2: *7* flake8.check_all
def check_all(self, paths):
    '''Run flake8 on all paths.'''
    from flake8 import engine, main
    config_file = self.get_flake8_config()
    if config_file:
        style = engine.get_style_guide(
            parse_argv=False,
            config_file=config_file,
        )
        report = style.check_files(paths=paths)
        # Set statistics here, instead of from the command line.
        options = style.options
        options.statistics = True
        options.total_errors = True
        # options.benchmark = True
        main.print_report(report, style)
.. @+node:ekr.20160517133049.3: *7* flake8.find
def find(self, p):
    '''Return True and add p's path to self.seen if p is a Python @<file> node.'''
    found = False
    if p.isAnyAtFileNode():
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
        fn = p.anyAtFileNodeName()
        if fn.endswith('.py'):
            fn = g.os_path_finalize_join(path, fn)
            if fn not in self.seen:
                self.seen.append(fn)
                found = True
    return found
.. @+node:ekr.20160517133049.4: *7* flake8.get_flake8_config
def get_flake8_config(self):
    '''Return the path to the pylint configuration file.'''
    trace = False and not g.unitTesting
    join = g.os_path_finalize_join
    dir_table = (
        g.app.homeDir,
        join(g.app.homeDir, '.leo'),
        join(g.app.loadDir, '..', '..', 'leo', 'test'),
    )
    if g.isPython3:
        base_table = ('flake8', 'flake8.txt')
    else:
        base_table = ('flake8',)
    for base in base_table:
        for path in dir_table:
            fn = g.os_path_abspath(join(path, base))
            if g.os_path_exists(fn):
                if trace: g.trace('found:', fn)
                return fn
    if not g.unitTesting:
        g.es_print('no flake8 configuration file found in\n%s' % (
            '\n'.join(dir_table)))
    return None
.. @+node:ekr.20160517133049.5: *7* flake8.run
def run(self, p=None):
    '''Run flake8 on all Python @<file> nodes in c.p's tree.'''
    c = self.c
    root = p or c.p
    # Make sure Leo is on sys.path.
    leo_path = g.os_path_finalize_join(g.app.loadDir, '..')
    if leo_path not in sys.path:
        sys.path.append(leo_path)
    # Run flake8 on all Python @<file> nodes in root's tree.
    t1 = time.time()
    found = False
    for p in root.self_and_subtree():
        found |= self.find(p)
    # Look up the tree if no @<file> nodes were found.
    if not found:
        for p in root.parents():
            if self.find(p):
                found = True
                break
    # If still not found, expand the search if root is a clone.
    if not found:
        isCloned = any([p.isCloned() for p in root.self_and_parents()])
        # g.trace(isCloned,root.h)
        if isCloned:
            for p in c.all_positions():
                if p.isAnyAtFileNode():
                    isAncestor = any([z.v == root.v for z in p.self_and_subtree()])
                    # g.trace(isAncestor,p.h)
                    if isAncestor and self.find(p):
                        break
    paths = list(set(self.seen))
    if paths:
        self.check_all(paths)
    g.es_print('flake8: %s file%s in %s' % (
        len(paths), g.plural(paths), g.timeSince(t1)))
.. @+node:ekr.20160516072613.1: *5* pyflakes command
@g.command('pyflakes')
def pyflakes_command(event):
    '''
    Run pyflakes on all nodes of the selected tree,
    or the first @<file> node in an ancestor.
    '''
    @others
        # define class PyFlakesCommand.
    c = event.get('c')
    if c:
        if c.isChanged():
            c.save()
        if pyflakes:
            PyflakesCommand(c).run()
        else:
            g.es_print('can not import pyflakes')
.. @+node:ekr.20160516072613.2: *6* class PyflakesCommand
class PyflakesCommand(object):
    '''A class to run pyflakes on all Python @<file> nodes in c.p's tree.'''

    def __init__(self, c):
        '''ctor for PyflakesCommand class.'''
        self.c = c
        self.seen = [] # List of checked paths.

    @others
.. @+node:ekr.20160516072613.6: *7* pyflakes.check_all
def check_all(self, paths):
    '''Run pyflakes on fn.'''
    from pyflakes import api, reporter
    for fn in sorted(paths):
        # Report the file name.
        sfn = g.shortFileName(fn)
        s = g.readFileIntoEncodedString(fn, silent=False)
        if not s.strip():
            return
        r = reporter.Reporter(
            errorStream=sys.stderr,
            warningStream=sys.stderr,
            )
        errors = api.check(s, sfn, r)
        if False and errors:
            # Annoying.
            print('%s error%s in %s' % (errors, g.plural(errors), fn))
.. @+node:ekr.20160516072613.3: *7* pyflakes.find
def find(self, p):
    '''Return True and add p's path to self.seen if p is a Python @<file> node.'''
    found = False
    if p.isAnyAtFileNode():
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
        fn = p.anyAtFileNodeName()
        if fn.endswith('.py'):
            fn = g.os_path_finalize_join(path, fn)
            if fn not in self.seen:
                self.seen.append(fn)
                found = True
    return found
.. @+node:ekr.20160516072613.5: *7* pyflakes.run
def run(self, p=None):
    '''Run Pyflakes on all Python @<file> nodes in c.p's tree.'''
    c = self.c
    root = p or c.p
    # Make sure Leo is on sys.path.
    leo_path = g.os_path_finalize_join(g.app.loadDir, '..')
    if leo_path not in sys.path:
        sys.path.append(leo_path)
    # Run pyflakes on all Python @<file> nodes in root's tree.
    t1 = time.time()
    found = False
    for p in root.self_and_subtree():
        found |= self.find(p)
    # Look up the tree if no @<file> nodes were found.
    if not found:
        for p in root.parents():
            if self.find(p):
                found = True
                break
    # If still not found, expand the search if root is a clone.
    if not found:
        isCloned = any([p.isCloned() for p in root.self_and_parents()])
        if isCloned:
            for p in c.all_positions():
                if p.isAnyAtFileNode():
                    isAncestor = any([z.v == root.v for z in p.self_and_subtree()])
                    if isAncestor and self.find(p):
                        break
    paths = list(set(self.seen))
    if paths:
        self.check_all(paths)
    g.es_print('pyflakes: %s file%s in %s' % (
        len(paths), g.plural(paths), g.timeSince(t1)))
.. @+node:ekr.20160517133001.1: *5* flake8 command
@g.command('flake8')
def flake8_command(event):
    '''
    Run flake8 on all nodes of the selected tree,
    or the first @<file> node in an ancestor.
    '''
    @others
        # define class Flake8Command.
    c = event.get('c')
    if c:
        if c.isChanged():
            c.save()
        if flake8:
            Flake8Command(c).run()
        else:
            g.es_print('can not import flake8')
.. @+node:ekr.20160517133049.1: *6* class Flake8Command
class Flake8Command(object):
    '''A class to run flake8 on all Python @<file> nodes in c.p's tree.'''

    def __init__(self, c, quiet=False):
        '''ctor for Flake8Command class.'''
        self.c = c
        self.quiet = quiet
        self.seen = [] # List of checked paths.

    @others
.. @+node:ekr.20160517133049.2: *7* flake8.check_all
def check_all(self, paths):
    '''Run flake8 on all paths.'''
    from flake8 import engine, main
    config_file = self.get_flake8_config()
    if config_file:
        style = engine.get_style_guide(
            parse_argv=False,
            config_file=config_file,
        )
        report = style.check_files(paths=paths)
        # Set statistics here, instead of from the command line.
        options = style.options
        options.statistics = True
        options.total_errors = True
        # options.benchmark = True
        main.print_report(report, style)
.. @+node:ekr.20160517133049.3: *7* flake8.find
def find(self, p):
    '''Return True and add p's path to self.seen if p is a Python @<file> node.'''
    found = False
    if p.isAnyAtFileNode():
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
        fn = p.anyAtFileNodeName()
        if fn.endswith('.py'):
            fn = g.os_path_finalize_join(path, fn)
            if fn not in self.seen:
                self.seen.append(fn)
                found = True
    return found
.. @+node:ekr.20160517133049.4: *7* flake8.get_flake8_config
def get_flake8_config(self):
    '''Return the path to the pylint configuration file.'''
    trace = False and not g.unitTesting
    join = g.os_path_finalize_join
    dir_table = (
        g.app.homeDir,
        join(g.app.homeDir, '.leo'),
        join(g.app.loadDir, '..', '..', 'leo', 'test'),
    )
    if g.isPython3:
        base_table = ('flake8', 'flake8.txt')
    else:
        base_table = ('flake8',)
    for base in base_table:
        for path in dir_table:
            fn = g.os_path_abspath(join(path, base))
            if g.os_path_exists(fn):
                if trace: g.trace('found:', fn)
                return fn
    if not g.unitTesting:
        g.es_print('no flake8 configuration file found in\n%s' % (
            '\n'.join(dir_table)))
    return None
.. @+node:ekr.20160517133049.5: *7* flake8.run
def run(self, p=None):
    '''Run flake8 on all Python @<file> nodes in c.p's tree.'''
    c = self.c
    root = p or c.p
    # Make sure Leo is on sys.path.
    leo_path = g.os_path_finalize_join(g.app.loadDir, '..')
    if leo_path not in sys.path:
        sys.path.append(leo_path)
    # Run flake8 on all Python @<file> nodes in root's tree.
    t1 = time.time()
    found = False
    for p in root.self_and_subtree():
        found |= self.find(p)
    # Look up the tree if no @<file> nodes were found.
    if not found:
        for p in root.parents():
            if self.find(p):
                found = True
                break
    # If still not found, expand the search if root is a clone.
    if not found:
        isCloned = any([p.isCloned() for p in root.self_and_parents()])
        # g.trace(isCloned,root.h)
        if isCloned:
            for p in c.all_positions():
                if p.isAnyAtFileNode():
                    isAncestor = any([z.v == root.v for z in p.self_and_subtree()])
                    # g.trace(isAncestor,p.h)
                    if isAncestor and self.find(p):
                        break
    paths = list(set(self.seen))
    if paths:
        self.check_all(paths)
    g.es_print('flake8: %s file%s in %s' % (
        len(paths), g.plural(paths), g.timeSince(t1)))
.. @+node:ekr.20160517134919.1: *4* Fixed compare_ast bug
.. @+node:ekr.20150526115312.1: *5* compare_ast
# http://stackoverflow.com/questions/3312989/
# elegant-way-to-test-python-asts-for-equality-not-reference-or-object-identity

def compare_ast(node1, node2):

    trace = False and not g.unitTesting

    def fail(node1, node2, tag):
        '''Report a failed mismatch in the beautifier. This is a bug.'''
        name1 = node1.__class__.__name__
        name2 = node2.__class__.__name__
        format = 'compare_ast failed: %s: %s %s %r %r'
        if name1 == 'str':
            print(format % (tag, name1, name2, node1, node2))
        elif name1 == 'Str':
            print(format % (tag, name1, name2, node1.s, node2.s))
        elif 1:
            format = 'compare_ast failed: %s: %s %s\n%r\n%r'
            print(format % (tag, name1, name2, node1, node2))
        else:
            format = 'compare_ast failed: %s: %s %s\n%r\n%r\n%r %r'
            attr1 = getattr(node1, 'lineno', '<no lineno>')
            attr2 = getattr(node2, 'lineno', '<no lineno>')
            print(format % (tag, name1, name2, node1, node2, attr1, attr2))

    # pylint: disable=unidiomatic-typecheck
    if type(node1) != type(node2):
        if trace: fail(node1, node2, 'type mismatch')
        return False
    # The types of node1 and node2 match. Recursively compare components.
    if isinstance(node1, ast.AST):
        for kind, var in vars(node1).items():
            if kind not in ('lineno', 'col_offset', 'ctx'):
                var2 = vars(node2).get(kind) # Bug fix: 2016/05/16.
                if not compare_ast(var, var2):
                    if trace: fail(var, var2, 'AST subnode mismatch')
                    return False
        return True
    elif isinstance(node1, list):
        if len(node1) != len(node2):
            if trace: fail(node1, node2, 'list len mismatch')
            return False
        for i in range(len(node1)):
            if not compare_ast(node1[i], node2[i]):
                if trace: fail(node1, node2, 'list element mismatch')
                return False
        return True
    elif node1 != node2:
        if trace: fail(node1, node2, 'node mismatch')
        return False
    else:
        return True
.. @+node:ekr.20160119090634.1: *5* mb.scan_comment
def scan_comment(self, s, i):
    '''Return the index of the character after a comment.'''
    trace = False and not g.unitTesting
    i1 = i
    start = self.start_comment if self.forward else self.end_comment
    end = self.end_comment if self.forward else self.start_comment
    offset = 1 if self.forward else - 1
    if g.match(s, i, start):
        if not self.forward:
            i1 += len(end)
        i += offset
        while 0 <= i < len(s):
            if g.match(s, i, end):
                i = i + len(end) if self.forward else i - 1
                if trace: g.trace('multi-line',s[min(i1,i):max(i1,i)])
                return i
            i += offset
        self.oops('unmatched multiline comment')
    elif self.forward:
        # Scan to the newline.
        target = '\n'
        while 0 <= i < len(s):
            if s[i] == '\n':
                i += 1
                if trace: g.trace('single-line',s[i1,i].rstrip())
                return i
            i += 1
    else:
        # Careful: scan to the *first* target on the line
        target = self.single_comment
        found = None
        i -= 1
        while 0 <= i < len(s) and s[i] != '\n':
            if g.match(s, i, target):
                if trace: g.trace('single-line',s[i:i1].rstrip())
                found = i
            i -= 1
        if found is None:
            self.oops('can not happen: unterminated single-line comment')
            found = 0
        return found
    return i
.. @+node:ekr.20160514121505.1: *4* Moved class defs out of @file nodes
And into subsidiary trees.
.. @+node:ekr.20160520153611.1: *4* Removed tabs from leo/modes/*.py
@language python

import glob
path = g.os_path_join(g.app.loadDir, '..', 'modes', '*.py')
# print(g.os_path_exists(path))
aList = glob.glob(path)
# print('\n'.join(sorted(aList)))
for fn in aList:
    f = open(fn, 'r')
    s1 = f.read()
    f.close()
    s2 = s1.replace('\t', '    ')
    if s1 != s2:
        print('changed: %s' % fn)
        f = open(fn, 'w')
        f.write(s2)
        f.close()
.. @+node:ekr.20160504150922.1: *4* Removed useUI switch
It hasn't been active for a long, long time.
.. @+node:ekr.20160502072925.1: *3* Features
.. @+node:ekr.20160429062804.1: *4* #032: Added freemind and mindjet imports
https://github.com/leo-editor/leo-editor/issues/32

The code:
https://github.com/leo-editor/snippets/tree/master/issue_attach/32

There are two ways to access these commands:

1. Using the general import-files command, via the minibuffer or the File:Import File menu.  This opens a dialog that picks the proper importer **based on the file's extension**.  mm.html files get the FreeMind importer. .csv files get the MindJet importer.

2. If these conventions don't suit you, you can use specific import-free-mind-files or import-mind-jet-files commands. These open a dialog in which the specific extension is pre-selected, but you can pick any file as usual.  In particular, it's possible to use the MindJet importer to open .ipynb files, which have .csv format.

In general, if you pick an invalid file, the importers will fail gracefully.
.. @+node:ekr.20160327112237.1: *4* #225: Added support for @auto x.json
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/225

@language python
.. @+node:ekr.20160504052133.1: *4* #225: Added upport @auto x.json
https://github.com/leo-editor/leo-editor/issues/225
.. @+node:ekr.20160504080548.1: *5* Unused
.. @+node:ekr.20160504060547.1: *6* @g.command(import-json-files)
@g.command('import-json-files')
def import_json_files(event):
    '''Prompt for .json files and import them.'''
    c = event.get('c')
    if c:
        JSON_Importer(c).prompt_for_files()
.. @+node:ekr.20160504052133.2: *6* Convert Leo outline to/from json
'''Write node & links version of json.'''

# from __future__ import print_function
import json

class JsonController(object):
    @others

g.cls()
jc = JsonController()
s = jc.to_json(c,p=None)
d = json.loads(s)

nodes = {}
print('nodes...')
for d2 in d.get('nodes'):
    gnx = d2.get('gnx')
    print('%-25s %s' % (d2.get('gnx'),d2.get('h')))
    nodes[gnx] = d2

keys = sorted(list(nodes.keys()))

if 0:
    print()
    print('keys',keys)

aList = d.get('top')
print()
print('top...')
for gnx in aList:
    assert gnx in keys,gnx
    d2 = nodes.get(gnx)
    print('%-25s %s' % (d2.get('gnx'),d2.get('h')))
.. @+node:ekr.20160504052133.3: *7* to_json
def to_json (self,c,p=None):

    '''Convert p's tree to JSON, or the entire outline if p is None.'''

    if p:
        top = [p.v.gnx]
        nodes = list(set([p.v for p in p.self_and_subtree()]))
    else:
        top = [v.gnx for v in c.hiddenRootNode.children]
        nodes = [v for v in c.all_unique_nodes()]

    nodes = [self.vnode_dict(v) for v in nodes]
    d = {'top':top,'nodes':nodes}
    s = json.dumps(d)
    return s
.. @+node:ekr.20160504052133.4: *7* vnode_dict
def vnode_dict (self, v):

    return {
        'gnx': v.gnx,
        'h':v.h, 'b':v.b,
        # 'ua': v.u,
        'children': [z.gnx for z in v.children]
    }
.. @+node:ekr.20160504060656.1: *6* class JSON_Importer
class JSON_Importer(object):
    '''A class to import .json files.'''

    def __init__(self, c):
        '''ctor for JSON_Importer class.'''
        self.c = c
    @others
.. @+node:ekr.20160504061314.2: *7* json.create_outline
def create_outline(self, path):
    c = self.c
    junk, fileName = g.os_path_split(path)
    undoData = c.undoer.beforeInsertNode(c.p)
    # Create the top-level headline.
    p = c.lastTopLevel().insertAfter()
    fn = g.shortFileName(path).strip()
    if fn.endswith('.json'):
        fn = fn[:-5]
    p.h = fn
    self.scan(path, p)
    c.undoer.afterInsertNode(p, 'Import', undoData)
    return p
.. @+node:ekr.20160504061314.3: *7* json.import_files
def import_files(self, files):
    '''Import a list of MindMap (.csv) files.'''
    c = self.c
    if files:
        self.tab_width = c.getTabWidth(c.p)
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            p = self.create_outline(fileName)
            p.contract()
            p.setDirty()
            c.setChanged(True)
        c.redraw(p)
.. @+node:ekr.20160504061314.4: *7* json.prompt_for_files
def prompt_for_files(self):
    '''Prompt for a list of MindJet (.csv) files and import them.'''
    c = self.c
    types = [
        ("JSON files", "*.json"),
        ("All files", "*"),
    ]
    names = g.app.gui.runOpenFileDialog(c,
        title="Import MindJet File",
        filetypes=types,
        defaultextension=".csv",
        multiple=True)
    c.bringToFront()
    if names:
        g.chdir(names[0])
        self.import_files(names)
.. @+node:ekr.20160504061314.5: *7* json.scan
def scan(self, path, target):
    '''Create an outline from a MindMap (.csv) file.'''
    c = self.c
    s = g.readFileIntoUnicodeString(path)
    if s is None:
        return
    d = json.loads(s)
    g.trace(sorted(d.keys()))
    # g.trace(d)
    nodes = {}
    g.trace('nodes...')
    for d2 in d.get('nodes', []):
        gnx = d2.get('gnx')
        print('%-25s %s' % (d2.get('gnx'), d2.get('h')))
        nodes[gnx] = d2
    keys = sorted(nodes.keys())
    if 0:
        print()
        print('keys', keys)
    aList = d.get('top', [])
    print()
    print('top...')
    for gnx in aList:
        assert gnx in keys, gnx
        d2 = nodes.get(gnx)
        print('%-25s %s' % (d2.get('gnx'), d2.get('h')))
    c.redraw()
.. @+node:ekr.20160504061707.2: *7* json.to_json
def to_json(self, c, p=None):
    '''Convert p's tree to JSON, or the entire outline if p is None.'''
    if p:
        top = [p.v.gnx]
        nodes = list(set([p.v for p in p.self_and_subtree()]))
    else:
        top = [v.gnx for v in c.hiddenRootNode.children]
        nodes = [v for v in c.all_unique_nodes()]
    nodes = [self.vnode_dict(v) for v in nodes]
    d = {'top': top, 'nodes': nodes}
    s = json.dumps(d)
    return s
.. @+node:ekr.20160504061707.3: *7* json.vnode_dict
def vnode_dict(self, v):
    return {
        'gnx': v.gnx,
        'h': v.h, 'b': v.b,
        # 'ua': v.u,
        'children': [z.gnx for z in v.children]
    }
.. @+node:ekr.20160504060333.1: *5* changed and new
.. @+node:ekr.20110530124245.18245: *6* c.importAnyFile & helper
@cmd('import-file')
def importAnyFile(self, event=None):
    '''Import one or more files.'''
    c = self
    ic = c.importCommands
    types = [
        ("All files", "*"),
        ("C/C++ files", "*.c"),
        ("C/C++ files", "*.cpp"),
        ("C/C++ files", "*.h"),
        ("C/C++ files", "*.hpp"),
        ("FreeMind files", "*.mm.html"),
        ("Java files", "*.java"),
        # ("JSON files", "*.json"),
        ("Mindjet files", "*.csv"),
        ("Lua files", "*.lua"),
        ("Pascal files", "*.pas"),
        ("Python files", "*.py")]
    names = g.app.gui.runOpenFileDialog(c,
        title="Import File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()
    if names:
        g.chdir(names[0])
    else:
        names = []
    if not names:
        if g.unitTesting:
            # a kludge for unit testing.
            c.init_error_dialogs()
            c.raise_error_dialogs(kind='read')
        return
    # New in Leo 4.9: choose the type of import based on the extension.
    c.init_error_dialogs()
    derived = [z for z in names if c.looksLikeDerivedFile(z)]
    others = [z for z in names if z not in derived]
    if derived:
        ic.importDerivedFiles(parent=c.p, paths=derived)
    for fn in others:
        junk, ext = g.os_path_splitext(fn)
        if ext.startswith('.'):
            ext = ext[1:]
        if ext == 'csv':
            ic.importMindMap([fn])
        elif ext in ('cw', 'cweb'):
            ic.importWebCommand([fn], "cweb")
        # Not useful. Use @auto x.json instead.
        # elif ext == 'json':
            # ic.importJSON([fn])
        elif fn.endswith('mm.html'):
            ic.importFreeMind([fn])
        elif ext in ('nw', 'noweb'):
            ic.importWebCommand([fn], "noweb")
        elif ext == 'txt':
            ic.importFlattenedOutline([fn])
        else:
            ic.importFilesCommand([fn], '@clean')
    c.raise_error_dialogs(kind='read')

# Compatibility
importAtFile = importAnyFile
importAtRoot = importAnyFile
importCWEBFiles = importAnyFile
importDerivedFile = importAnyFile
importFlattenedOutline = importAnyFile
importNowebFiles = importAnyFile
.. @+node:ekr.20110530124245.18248: *7* c.looksLikeDerivedFile
def looksLikeDerivedFile(self, fn):
    '''Return True if fn names a file that looks like an
    external file written by Leo.'''
    # c = self
    try:
        f = open(fn, 'r')
    except IOError:
        return False
    try:
        s = f.read()
    except Exception:
        s = ''
    finally:
        f.close()
    val = s.find('@+leo-ver=') > -1
    return val
.. @+node:ekr.20160504062833.1: *6* g.readFileToUnicodeString (new in Leo 5.4)
def readFileIntoUnicodeString(fn, silent=False):
    '''Return the raw contents of the file whose full path is fn.'''
    try:
        f = open(fn, 'rb')
        s = f.read()
        f.close()
        return g.toUnicode(s)
    except IOError:
        if not silent:
            g.error('can not open', fn)
    except Exception:
        g.error('readFileIntoUnicodeString: unexpected exception reading %s' % (fn))
        g.es_exception()
    return None
.. @+node:ekr.20160420052916.1: *4* #266: Added a setting to hide the icon bar
https://github.com/leo-editor/leo-editor/issues/266

Changed dw.construct.
.. @+node:ekr.20110605121601.18139: *5* dw.construct & helper
def construct(self, master=None):
    """ Factor 'heavy duty' code out from the DynamicWindow ctor """
    # g.trace('(DynamicWindow)')
    c = self.leo_c
    self.leo_master = master
        # A LeoTabbedTopLevel for tabbed windows.
        # None for non-tabbed windows.
    # Init the base class.
    ui_file_name = c.config.getString('qt_ui_file_name')
    self.useScintilla = c.config.getBool('qt-use-scintilla')
    if not ui_file_name:
        ui_file_name = 'qt_main.ui'
    ui_description_file = g.app.loadDir + "/../plugins/" + ui_file_name
    # g.pr('DynamicWindw.__init__,ui_description_file)
    assert g.os_path_exists(ui_description_file)
    self.bigTree = c.config.getBool('big_outline_pane')
    main_splitter, secondary_splitter = self.createMainWindow()
    self.iconBar = self.addToolBar("IconBar")
    self.set_icon_bar_orientation(c)
    # #266 A setting to hide the icon bar.
    show_iconbar = c.config.getBool('show_iconbar', default=True)
    if not show_iconbar:
        self.iconBar.hide()
    self.leo_menubar = self.menuBar()
    self.statusBar = QtWidgets.QStatusBar()
    self.setStatusBar(self.statusBar)
    orientation = c.config.getString('initial_split_orientation')
    self.setSplitDirection(main_splitter, secondary_splitter, orientation)
    if hasattr(c, 'styleSheetManager'):
        c.styleSheetManager.set_style_sheets(top=self, all=True)
.. @+node:ekr.20140915062551.19519: *6* dw.set_icon_bar_orientation
def set_icon_bar_orientation(self, c):
    '''Set the orientation of the icon bar based on settings.'''
    d = {
        'bottom': QtCore.Qt.BottomToolBarArea,
        'left': QtCore.Qt.LeftToolBarArea,
        'right': QtCore.Qt.RightToolBarArea,
        'top': QtCore.Qt.TopToolBarArea,
    }
    where = c.config.getString('qt-toolbar-location')
    if where:
        where = d.get(where)
        if where: self.addToolBar(where, self.iconBar)
.. @+node:ekr.20160429063430.1: *4* #272: optionally delay syntax coloring
https://github.com/leo-editor/leo-editor/issues/272

Syntax coloring happens *initially* at idle-time. pqsh.setDocument queues pqsh.delayedRehighlight to run at idle time.
.. @+node:ekr.20160429063322.1: *4* #275: Improved clone-marked/copy-marked/move-marked
https://github.com/leo-editor/leo-editor/issues/275

- Improved clone-marked-nodes and move-marked-nodes.
- Added copy-marked nodes.

Note: The move-marked-nodes command is no longer undoable.
The docstring suggests using clone-marked-nodes, followed by copy/paste.

These commands work as follows:

- They create an organizer node after c.p.
  (That's not always possible for move-marked-nodes,
  in which case the organizer node becomes the last top-level node).

- They find all marked nodes, regardless of chapter, and leave
  the presently selected chapter selected, if possible.
.. @+node:ekr.20160318113142.1: *4* #278: Created coffeescript importer
https://github.com/leo-editor/leo-editor/issues/278
.. @+node:ekr.20160506075450.1: *5* Notes
# Coffeescript compiler without node.js
# http://stackoverflow.com/questions/11575404/coffeescript-compiler-without-node-js

# You can run javascript in python with http://code.google.com/p/pyv8/. (link is dead)
# PyV8 binaries: https://github.com/emmetio/pyv8-binaries

# Bridge to PyV8
# https://pypi.python.org/pypi/PyV8

# https://github.com/leo-editor/leo-editor/issues/278
# A bridge to the coffeescript compiler
# Must install coffeescript first.
# https://pypi.python.org/pypi/CoffeeScript/1.1.2
import coffeescript
g.es(coffeescript)
.. @+node:ekr.20160504152032.1: *4* Added @bool plain-key-outline-search
.. @+node:ekr.20160409035115.1: *5* k.searchTree
def searchTree(self, char):
    '''Search all visible nodes for a headline starting with stroke.'''
    trace = False and not g.unitTesting
    if trace: g.trace(char)
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        '''Return True if p contains char.'''
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) > -1

    # Start at c.p, then retry everywhere.
    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if trace: g.trace(p.h)
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            else:
                p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) > -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
.. @+node:ekr.20160510132357.1: *4* Added installer that only installs file associations
You can find it here: https://sourceforge.net/projects/leo/files/Leo/5.3-final/.

It works for me on Windows 10. This completes #285.

This is useful for people who install Leo using git, or any other way except using the full Windows installer.  It creates file associations and (optionally) a desktop icon.

The installer prompts for both the already-installed Leo installation folder (leo-editor for those using git) and a top-level Python directory. Necessary for auto-launching Leo. It also asks whether you want to open Leo in a console.  On my system, pythonw.exe doesn't work for Anaconda3, so a "yes" is required.  I'll probably back-port some of these features to the full installer.
.. @+node:ekr.20160613110644.1: *4* Added support for meta key on MacOS
.. @+node:ekr.20110605121601.18542: *5* LeoQtEventFilter.toStroke
def toStroke(self, tkKey, ch): # ch is unused
    '''Convert the official tkKey name to a stroke.'''
    trace = False and not g.unitTesting
    s = tkKey
    table = (
        ('Alt-', 'Alt+'),
        ('Ctrl-', 'Ctrl+'),
        ('Control-', 'Ctrl+'),
        # Use Alt+Key-1, etc.  Sheesh.
        # ('Key-','Key+'),
        ('Meta-', 'Meta+'), # 2016/06/13: per Karsten Wolf.
        ('Shift-', 'Shift+')
    )
    for a, b in table:
        s = s.replace(a, b)
    if trace: g.trace('tkKey', tkKey, '-->', s)
    return s
.. @+node:ekr.20120204061120.10084: *5* LeoQtEventFilter.qtMods
def qtMods(self, event):
    '''Return the text version of the modifiers of the key event.'''
    modifiers = event.modifiers()
    # The order of this table must match the order created by k.strokeFromSetting.
    qt = QtCore.Qt
    # 2016/06/13: toStroke can now generate meta on MacOS.
    # In other words: only one version of this table is needed.
    table = (
        (qt.AltModifier, 'Alt'),
        (qt.ControlModifier, 'Control'),
        (qt.MetaModifier, 'Meta'),
        (qt.ShiftModifier, 'Shift'),
    )
    mods = [b for a, b in table if (modifiers & a)]
    return mods
.. @+node:ekr.20160514070737.1: *4* colorize basestring, @staticmethod & @classmethod
.. @+node:ekr.20110605121601.18614: *5* match_keywords
# This is a time-critical method.

def match_keywords(self, s, i):
    '''
    Succeed if s[i:] is a keyword.
    Returning -len(word) for failure greatly reduces the number of times this
    method is called.
    '''
    trace = False and not g.unitTesting
    traceFail = True
    self.totalKeywordsCalls += 1
    # g.trace(i,repr(s[i:]))
    # We must be at the start of a word.
    if i > 0 and s[i - 1] in self.word_chars:
        # if trace: g.trace('not at word start',s[i-1])
        return 0
    # Get the word as quickly as possible.
    j = i; n = len(s)
    chars = self.word_chars
    # 2013/11/04: A kludge just for Haskell:
    if self.language_name == 'haskell':
        chars["'"] = "'"
    while j < n and s[j] in chars:
        j += 1
    word = s[i: j]
    if not word:
        g.trace('can not happen', repr(s[i: max(j, i + 1)]), repr(s[i: i + 10]), g.callers())
        return 0
    if self.ignore_case: word = word.lower()
    kind = self.keywordsDict.get(word)
    if kind:
        self.colorRangeWithTag(s, i, j, kind)
        self.prev = (i, j, kind)
        result = j - i
        if trace: g.trace('success', word, kind, result)
        self.trace_match(kind, s, i, j)
        return result
    else:
        if trace and traceFail: g.trace('fail', word, kind)
        return -len(word) # An important new optimization.
.. @+node:ekr.20110605121601.18604: *5* match_leo_keywords
def match_leo_keywords(self, s, i):
    '''Succeed if s[i:] is a Leo keyword.'''
    # g.trace(i,g.get_line(s,i))
    self.totalLeoKeywordsCalls += 1
    if s[i] != '@':
        return 0
    # fail if something besides whitespace precedes the word on the line.
    i2 = i - 1
    while i2 >= 0:
        ch = s[i2]
        if ch == '\n':
            break
        elif ch in (' ', '\t'):
            i2 -= 1
        else:
            # g.trace('not a word 1',repr(ch))
            return 0
    # Get the word as quickly as possible.
    j = i + 1
    while j < len(s) and s[j] in self.word_chars:
        j += 1
    word = s[i + 1: j] # entries in leoKeywordsDict do not start with '@'.
    if j < len(s) and s[j] not in (' ', '\t', '\n'):
        # g.trace('not a word 2',repr(word))
        return 0 # Fail, but allow a rescan, as in objective_c.
    if self.leoKeywordsDict.get(word):
        kind = 'leokeyword'
        self.colorRangeWithTag(s, i, j, kind)
        self.prev = (i, j, kind)
        result = j - i + 1 # Bug fix: skip the last character.
        self.trace_match(kind, s, i, j)
        # g.trace('*** match',repr(s))
        return result
    else:
        # 2010/10/20: also check the keywords dict here.
        # This allows for objective_c keywords starting with '@'
        # This will not slow down Leo, because it is called
        # for things that look like Leo directives.
        word = '@' + word
        kind = self.keywordsDict.get(word)
        if kind:
            self.colorRangeWithTag(s, i, j, kind)
            self.prev = (i, j, kind)
            self.trace_match(kind, s, i, j)
            # g.trace('found',word)
            return j - i
        else:
            # g.trace('fail',repr(word),repr(self.word_chars))
            return -(j - i + 1) # An important optimization.
.. @+node:ekr.20160429065541.1: *4* Fixed timing stats for pylint-leo on Linux
Used time.time() instead of time.clock()
.. @+node:ekr.20160918113706.1: *5* Found:time.clock
# flattened, word, ignore-case, head, body
.. @+node:ekr.20140711111623.17798: *6* cc.run
def run(self):
    '''Convert an @file tree to @auto tree.'''
    trace = True and not g.unitTesting
    trace_s = False
    cc = self
    c = cc.c
    root, pd = cc.root, c.persistenceController
    # set the expected imported headline for all vnodes.
    t1 = time.time()
    cc.set_expected_imported_headlines(root)
    t2 = time.time()
    # Delete all previous @data nodes for this tree.
    cc.delete_at_data_nodes(root)
    t3 = time.time()
    # Ensure that all nodes of the tree are regularized.
    ok = pd.prepass(root)
    t4 = time.time()
    if not ok:
        g.es_print('Can not convert', root.h, color='red')
        if trace: g.trace(
            '\n  set_expected_imported_headlines: %4.2f sec' % (t2 - t1),
            # '\n  delete_at_data_nodes:          %4.2f sec' % (t3-t2),
            '\n  prepass:                         %4.2f sec' % (t4 - t3),
            '\n  total:                           %4.2f sec' % (t4 - t1))
        return
    # Create the appropriate @data node.
    at_auto_view = pd.update_before_write_foreign_file(root)
    t5 = time.time()
    # Write the @file node as if it were an @auto node.
    s = cc.strip_sentinels()
    t6 = time.time()
    if trace and trace_s:
        g.trace('source file...\n', s)
    # Import the @auto string.
    ok, p = cc.import_from_string(s)
    t7 = time.time()
    if ok:
        # Change at_auto_view.b so it matches p.gnx.
        at_auto_view.b = pd.at_data_body(p)
        # Recreate the organizer nodes, headlines, etc.
        pd.update_after_read_foreign_file(p)
        t8 = time.time()
        # if not ok:
            # p.h = '@@' + p.h
            # g.trace('restoring original @auto file')
            # ok,p = cc.import_from_string(s)
            # if ok:
                # p.h = '@@' + p.h + ' (restored)'
                # if p.next():
                    # p.moveAfter(p.next())
        t9 = time.time()
    else:
        t8 = t9 = time.time()
    if trace: g.trace(
        '\n  set_expected_imported_headlines: %4.2f sec' % (t2 - t1),
        # '\n  delete_at_data_nodes:          %4.2f sec' % (t3-t2),
        '\n  prepass:                         %4.2f sec' % (t4 - t3),
        '\n  update_before_write_foreign_file:%4.2f sec' % (t5 - t4),
        '\n  strip_sentinels:                 %4.2f sec' % (t6 - t5),
        '\n  import_from_string:              %4.2f sec' % (t7 - t6),
        '\n  update_after_read_foreign_file   %4.2f sec' % (t8 - t7),
        '\n  import_from_string (restore)     %4.2f sec' % (t9 - t8),
        '\n  total:                           %4.2f sec' % (t9 - t1))
    if p:
        c.selectPosition(p)
    c.redraw()
.. @+node:ekr.20160517133049.5: *6* flake8.run
def run(self, p=None):
    '''Run flake8 on all Python @<file> nodes in c.p's tree.'''
    c = self.c
    root = p or c.p
    # Make sure Leo is on sys.path.
    leo_path = g.os_path_finalize_join(g.app.loadDir, '..')
    if leo_path not in sys.path:
        sys.path.append(leo_path)
    # Run flake8 on all Python @<file> nodes in root's tree.
    t1 = time.time()
    found = False
    for p in root.self_and_subtree():
        found |= self.find(p)
    # Look up the tree if no @<file> nodes were found.
    if not found:
        for p in root.parents():
            if self.find(p):
                found = True
                break
    # If still not found, expand the search if root is a clone.
    if not found:
        isCloned = any([p.isCloned() for p in root.self_and_parents()])
        # g.trace(isCloned,root.h)
        if isCloned:
            for p in c.all_positions():
                if p.isAnyAtFileNode():
                    isAncestor = any([z.v == root.v for z in p.self_and_subtree()])
                    # g.trace(isAncestor,p.h)
                    if isAncestor and self.find(p):
                        break
    paths = list(set(self.seen))
    if paths:
        self.check_all(paths)
    g.es_print('flake8: %s file%s in %s' % (
        len(paths), g.plural(paths), g.timeSince(t1)))
.. @+node:ekr.20150528131012.5: *6* beautify-tree
@g.command('beautify-tree')
@g.command('pretty-print-tree')
def beautifyPythonTree(event):
    '''Beautify the Python code in the selected outline.'''
    c = event.get('c')
    p0 = event.get('p0')
    is_auto = bool(p0)
    p0 = p0 or c.p
    if should_kill_beautify(p0):
        return
    t1 = time.time()
    pp = PythonTokenBeautifier(c)
    prev_changed = 0
    for p in p0.self_and_subtree():
        if g.scanForAtLanguage(c, p) == "python":
            if p.isAnyAtFileNode():
                # Report changed nodes in previous @<file> node.
                if pp.n_changed_nodes != prev_changed and not is_auto:
                    if not g.unitTesting:
                        n = pp.n_changed_nodes - prev_changed
                        g.es_print('beautified %s node%s' % (
                            n, g.plural(n)))
                prev_changed = pp.n_changed_nodes
                if not is_auto:
                    g.es_print(p.h)
            pp.prettyPrintNode(p)
    # Report any nodes in the last @<file> tree.
    if not g.unitTesting:
        if pp.n_changed_nodes != prev_changed and not is_auto:
            n = pp.n_changed_nodes - prev_changed
            g.es_print('beautified %s node%s' % (
                n, g.plural(n)))
    pp.end_undo()
    t2 = time.time()
    # pp.print_stats()
    if not g.unitTesting:
        if is_auto:
            if pp.n_changed_nodes > 0:
                g.es_print('auto-beautified %s node%s in\n%s' % (
                    pp.n_changed_nodes,
                    g.plural(pp.n_changed_nodes),
                    p0.h))
        else:
            g.es_print('beautified total %s node%s in %4.2f sec.' % (
                pp.n_changed_nodes, g.plural(pp.n_changed_nodes), t2 - t1))
.. @+node:ekr.20150521114057.1: *6* test_beautifier (prints stats)
def test_beautifier(c, h, p, settings):
    '''Test Leo's beautifier code'''
    if not p:
        g.trace('not found: %s' % h)
        return
    s = g.getScript(c, p,
            useSelectedText=False,
            forcePythonSentinels=True,
            useSentinels=False)
    g.trace(h.strip())
    t1 = time.time()
    s1 = g.toEncodedString(s)
    node1 = ast.parse(s1, filename='before', mode='exec')
    t2 = time.time()
    readlines = g.ReadLinesClass(s).next
    tokens = list(tokenize.generate_tokens(readlines))
    t3 = time.time()
    beautifier = PythonTokenBeautifier(c)
    keep_blank_lines = settings.get('tidy-keep-blank-lines')
    if keep_blank_lines is not None:
        beautifier.delete_blank_lines = not keep_blank_lines
    s2 = beautifier.run(tokens)
    t4 = time.time()
    try:
        s2_e = g.toEncodedString(s2)
        node2 = ast.parse(s2_e, filename='before', mode='exec')
        ok = compare_ast(node1, node2)
    except Exception:
        g.es_exception()
        ok = False
    t5 = time.time()
    #  Update the stats
    beautifier.n_input_tokens += len(tokens)
    beautifier.n_output_tokens += len(beautifier.code_list)
    beautifier.n_strings += len(s2)
    beautifier.parse_time += (t2 - t1)
    beautifier.tokenize_time += (t3 - t2)
    beautifier.beautify_time += (t4 - t3)
    beautifier.check_time += (t5 - t4)
    beautifier.total_time += (t5 - t1)
    if settings.get('input_string'):
        print('==================== input_string')
        for i, z in enumerate(g.splitLines(s)):
            print('%4s %s' % (i + 1, z.rstrip()))
    if settings.get('input_lines'):
        print('==================== input_lines')
        dump_tokens(tokens, verbose=False)
    if settings.get('input_tokens'):
        print('==================== input_tokens')
        dump_tokens(tokens, verbose=True)
    if settings.get('output_tokens'):
        print('==================== code_list')
        for i, z in enumerate(beautifier.code_list):
            print('%4s %s' % (i, z))
    if settings.get('output_string'):
        print('==================== output_string')
        for i, z in enumerate(g.splitLines(s2)):
            if z == '\n':
                print('%4s' % (i + 1))
            elif z.rstrip():
                print('%4s %s' % (i + 1, z.rstrip()))
            else:
                print('%4s %r' % (i + 1, str(z)))
    if settings.get('stats'):
        beautifier.print_stats()
    if not ok:
        print('*************** fail: %s ***************' % (h))
    return beautifier
        # For statistics.
.. @+node:ekr.20150530061745.1: *6* main (external entry) & helpers
def main():
    '''External entry point for Leo's beautifier.'''
    t1 = time.time()
    base = g.os_path_abspath(os.curdir)
    files, options = scan_options()
    for path in files:
        path = g.os_path_finalize_join(base, path)
        beautify(options, path)
    print('beautified %s files in %4.2f sec.' % (len(files), time.time() - t1))
.. @+node:ekr.20150601170125.1: *7* beautify (stand alone)
def beautify(options, path):
    '''Beautify the file with the given path.'''
    fn = g.shortFileName(path)
    s, e = g.readFileIntoString(path)
    if not s:
        return
    print('beautifying %s' % fn)
    s1 = g.toEncodedString(s)
    node1 = ast.parse(s1, filename='before', mode='exec')
    readlines = g.ReadLinesClass(s).next
    tokens = list(tokenize.generate_tokens(readlines))
    beautifier = PythonTokenBeautifier(c=None)
    beautifier.delete_blank_lines = not options.keep
    s2 = beautifier.run(tokens)
    s2_e = g.toEncodedString(s2)
    node2 = ast.parse(s2_e, filename='before', mode='exec')
    if compare_ast(node1, node2):
        f = open(path, 'wb')
        f.write(s2_e)
        f.close()
    else:
        print('failed to beautify %s' % fn)
.. @+node:ekr.20150601162203.1: *7* scan_options & helper
def scan_options():
    '''Handle all options. Return a list of files.'''
    # This automatically implements the --help option.
    usage = "usage: python leoBeautify -m file1, file2, ..."
    parser = optparse.OptionParser(usage=usage)
    add = parser.add_option
    add('-d', '--debug', action='store_true', dest='debug',
        help='print the list of files and exit')
    add('-k', '--keep-blank-lines', action='store_true', dest='keep',
        help='keep-blank-lines')
    # Parse the options.
    options, files = parser.parse_args()
    if options.debug:
        # Print the list of files and exit.
        g.trace('files...', files)
        sys.exit(0)
    return files, options
.. @+node:ekr.20150514125218.11: *6* pylint.run
def run(self):
    '''Run Pylint on all Python @<file> nodes in c.p's tree.'''
    c, root = self.c, self.c.p
    rc_fn = self.get_rc_file()
    if not rc_fn:
        return
    # Make sure Leo is on sys.path.
    leo_path = g.os_path_finalize_join(g.app.loadDir, '..')
    if leo_path not in sys.path:
        sys.path.append(leo_path)
    # Run lint on all Python @<file> nodes in root's tree.
    t1 = time.time()
    found = False
    for p in root.self_and_subtree():
        found |= self.check(p, rc_fn)
    # Look up the tree if no @<file> nodes were found.
    if not found:
        for p in root.parents():
            if self.check(p, rc_fn):
                found = True
                break
    # If still not found, expand the search if root is a clone.
    if not found:
        isCloned = any([p.isCloned() for p in root.self_and_parents()])
        # g.trace(isCloned,root.h)
        if isCloned:
            for p in c.all_positions():
                if p.isAnyAtFileNode():
                    isAncestor = any([z.v == root.v for z in p.self_and_subtree()])
                    # g.trace(isAncestor,p.h)
                    if isAncestor and self.check(p, rc_fn):
                        break
    if self.wait:
        g.es_print('pylint: done %s' % g.timeSince(t1))
.. @+node:ekr.20160516072613.5: *6* pyflakes.run
def run(self, p=None):
    '''Run Pyflakes on all Python @<file> nodes in c.p's tree.'''
    c = self.c
    root = p or c.p
    # Make sure Leo is on sys.path.
    leo_path = g.os_path_finalize_join(g.app.loadDir, '..')
    if leo_path not in sys.path:
        sys.path.append(leo_path)
    # Run pyflakes on all Python @<file> nodes in root's tree.
    t1 = time.time()
    found = False
    for p in root.self_and_subtree():
        found |= self.find(p)
    # Look up the tree if no @<file> nodes were found.
    if not found:
        for p in root.parents():
            if self.find(p):
                found = True
                break
    # If still not found, expand the search if root is a clone.
    if not found:
        isCloned = any([p.isCloned() for p in root.self_and_parents()])
        if isCloned:
            for p in c.all_positions():
                if p.isAnyAtFileNode():
                    isAncestor = any([z.v == root.v for z in p.self_and_subtree()])
                    if isAncestor and self.find(p):
                        break
    paths = list(set(self.seen))
    if paths:
        self.check_all(paths)
    g.es_print('pyflakes: %s file%s in %s' % (
        len(paths), g.plural(paths), g.timeSince(t1)))
.. @+node:ekr.20060923202156: *6* c.onCanvasKey
def onCanvasKey(self, event):
    '''Navigate to the next headline starting with ch = event.char.
    If ch is uppercase, search all headlines; otherwise search only visible headlines.
    This is modelled on Windows explorer.'''
    # g.trace(event and event.char)
    if not event or not event.char or not event.char.isalnum():
        return
    c = self; p = c.p; p1 = p.copy()
    invisible = c.config.getBool('invisible_outline_navigation')
    ch = event and event.char or ''
    allFlag = ch.isupper() and invisible # all is a global (!?)
    if not invisible: ch = ch.lower()
    found = False
    extend = self.navQuickKey()
    attempts = (True, False) if extend else (False,)
    for extend2 in attempts:
        p = p1.copy()
        while 1:
            if allFlag:
                p.moveToThreadNext()
            else:
                p.moveToVisNext(c)
            if not p:
                p = c.rootPosition()
            if p == p1: # Never try to match the same position.
                # g.trace('failed',extend2)
                found = False; break
            newPrefix = c.navHelper(p, ch, extend2)
            if newPrefix:
                found = True; break
        if found: break
    if found:
        c.selectPosition(p)
        c.redraw_after_select(p)
        c.navTime = time.time()
        c.navPrefix = newPrefix
        # g.trace('extend',extend,'extend2',extend2,'navPrefix',c.navPrefix,'p',p.h)
    else:
        c.navTime = None
        c.navPrefix = ''
    c.treeWantsFocus()
.. @+node:ekr.20061002095711.1: *7* c.navQuickKey
def navQuickKey(self):
    '''return true if there are two quick outline navigation keys
    in quick succession.

    Returns False if @float outline_nav_extend_delay setting is 0.0 or unspecified.'''
    c = self
    deltaTime = c.config.getFloat('outline_nav_extend_delay')
    if deltaTime in (None, 0.0):
        return False
    else:
        nearTime = c.navTime and time.time() - c.navTime < deltaTime
        return nearTime
.. @+node:ekr.20061002095711: *7* c.navHelper
def navHelper(self, p, ch, extend):
    c = self; h = p.h.lower()
    if extend:
        prefix = c.navPrefix + ch
        return h.startswith(prefix.lower()) and prefix
    if h.startswith(ch):
        return ch
    # New feature: search for first non-blank character after @x for common x.
    if ch != '@' and h.startswith('@'):
        for s in ('button', 'command', 'file', 'thin', 'asis', 'nosent',):
            prefix = '@' + s
            if h.startswith('@' + s):
                while 1:
                    n = len(prefix)
                    ch2 = n < len(h) and h[n] or ''
                    if ch2.isspace():
                        prefix = prefix + ch2
                    else: break
                if len(prefix) < len(h) and h.startswith(prefix + ch.lower()):
                    return prefix + ch
    return ''
.. @+node:ekr.20150528171137.1: *6* ptb.prettyPrintNode
def prettyPrintNode(self, p):
    '''The driver for beautification: beautify a single node.'''
    # c = self.c
    # trace = False and not g.unitTesting
    if not should_beautify(p):
        # @nobeautify is in effect.
        return
    if not p.b:
        # Pretty printing might add text!
        return
    if not p.b.strip():
        # Do this *after* we are sure @beautify is in effect.
        self.replace_body(p, '')
        return
    t1 = time.time()
    # Replace Leonine syntax with special comments.
    comment_string, s0 = comment_leo_lines(p)
    try:
        s1 = g.toEncodedString(s0)
        node1 = ast.parse(s1, filename='before', mode='exec')
    except IndentationError:
        self.skip_message('IndentationError', p)
        return
    except SyntaxError:
        self.skip_message('SyntaxError', p)
        return
    except Exception:
        g.es_exception()
        self.skip_message('Exception', p)
        return
    t2 = time.time()
    readlines = g.ReadLinesClass(s0).next
    tokens = list(tokenize.generate_tokens(readlines))
    t3 = time.time()
    s2 = self.run(tokens)
    t4 = time.time()
    try:
        s2_e = g.toEncodedString(s2)
        node2 = ast.parse(s2_e, filename='before', mode='exec')
        ok = compare_ast(node1, node2)
    except Exception:
        g.es_exception()
        g.trace('Error in %s...\n%s' % (p.h, s2_e))
        self.skip_message('BeautifierError', p)
        return
    if not ok:
        self.skip_message('BeautifierError', p)
        return
    t5 = time.time()
    # Restore the tags after the compare
    s3 = uncomment_leo_lines(comment_string, p, s2)
    self.replace_body(p, s3)
    # Update the stats
    self.n_input_tokens += len(tokens)
    self.n_output_tokens += len(self.code_list)
    self.n_strings += len(s3)
    self.parse_time += (t2 - t1)
    self.tokenize_time += (t3 - t2)
    self.beautify_time += (t4 - t3)
    self.check_time += (t5 - t4)
    self.total_time += (t5 - t1)
.. @+node:ekr.20031218072017.2812: *6* c.__init__ & helpers
def __init__(self, fileName, relativeFileName=None, gui=None, previousSettings=None):
    trace = (False or g.trace_startup) and not g.unitTesting
    tag = 'Commands.__init__ %s' % (g.shortFileName(fileName))
    if trace and g.trace_startup: g.es_debug('(Commands)', g.shortFileName(fileName))
    c = self
    if trace and not g.trace_startup:
        t1 = time.time()
    # Official ivars.
    self._currentPosition = self.nullPosition()
    self._topPosition = self.nullPosition()
    self.frame = None
    self.gui = gui or g.app.gui
    self.ipythonController = None
        # Set only by the ipython plugin.
    # The order of these calls does not matter.
    c.initCommandIvars()
    c.initDebugIvars()
    c.initDocumentIvars()
    c.initEventIvars()
    c.initFileIvars(fileName, relativeFileName)
    c.initOptionsIvars()
    c.initObjectIvars()
    c.initSettings(previousSettings)
        # Init the settings *before* initing the objects.
    # Initialize all subsidiary objects, including subcommanders.
    c.initObjects(self.gui)
    assert c.frame
    assert c.frame.c
    if trace and not g.trace_startup:
        g.printDiffTime('%s: after controllers created' % (tag), t1)
    # Complete the init!
    c.finishCreate()
    if trace and not g.trace_startup:
        g.printDiffTime('%s: after c.finishCreate' % (tag), t1)
.. @+node:ekr.20120217070122.10475: *7* c.computeWindowTitle
def computeWindowTitle(self, fileName):
    '''Set the window title and fileName.'''
    if fileName:
        title = g.computeWindowTitle(fileName)
    else:
        s = "untitled"
        n = g.app.numberOfUntitledWindows
        if n > 0:
            s += str(n)
        title = g.computeWindowTitle(s)
        g.app.numberOfUntitledWindows = n + 1
    return title
.. @+node:ekr.20120217070122.10473: *7* c.initCommandIvars
def initCommandIvars(self):
    '''Init ivars used while executing a command.'''
    self.commandsDict = {}
        # Keys are command names, values are functions.
    self.disableCommandsMessage = ''
        # The presence of this message disables all commands.
    self.hookFunction = None
        #
    self.ignoreChangedPaths = False
        # True: disable path changed message in at.WriteAllHelper.
    self.inCommand = False
        # Interlocks to prevent premature closing of a window.
    self.isZipped = False
        # Set by g.openWithFileName.
    self.outlineToNowebDefaultFileName = "noweb.nw"
        # For Outline To Noweb dialog.
    # For tangle/untangle
    self.tangle_errors = 0
    # Default Tangle options
    self.use_header_flag = False
    self.output_doc_flag = False
    # For hoist/dehoist commands.
    self.hoistStack = []
        # Stack of nodes to be root of drawn tree.
        # Affects drawing routines and find commands.
    # For outline navigation.
    self.navPrefix = g.u('') # Must always be a string.
    self.navTime = None
.. @+node:ekr.20120217070122.10466: *7* c.initDebugIvars
def initDebugIvars(self):
    '''Init Commander debugging ivars.'''
    self.command_count = 0
    self.scanAtPathDirectivesCount = 0
    self.trace_focus_count = 0
.. @+node:ekr.20120217070122.10471: *7* c.initDocumentIvars
def initDocumentIvars(self):
    '''Init per-document ivars.'''
    self.expansionLevel = 0
        # The expansion level of this outline.
    self.expansionNode = None
        # The last node we expanded or contracted.
    self.nodeConflictList = []
        # List of nodes with conflicting read-time data.
    self.nodeConflictFileName = None
        # The fileName for c.nodeConflictList.
    self.user_dict = {}
        # Non-persistent dictionary for free use by scripts and plugins.
.. @+node:ekr.20120217070122.10467: *7* c.initEventIvars
def initEventIvars(self):
    '''Init ivars relating to gui events.'''
    self.configInited = False
    self.doubleClickFlag = False
    self.exists = True
        # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    self.in_qt_dialog = False
        # True: in a qt dialog.
    self.loading = False
        # True: we are loading a file: disables c.setChanged()
    self.promptingForClose = False
        # True: lock out additional closing dialogs.
    self.suppressHeadChanged = False
        # True: prevent setting c.changed when switching chapters.
    # Flags for c.outerUpdate...
    self.incrementalRecolorFlag = False
    self.requestBringToFront = None # A commander, or None.
    self.requestCloseWindow = False
    self.requestRecolorFlag = False
    self.requestRedrawFlag = False
    self.requestedFocusWidget = None
    self.requestedIconify = '' # 'iconify','deiconify'
.. @+node:ekr.20120217070122.10472: *7* c.initFileIvars
def initFileIvars(self, fileName, relativeFileName):
    '''Init file-related ivars of the commander.'''
    self.changed = False
        # True: the ouline has changed since the last save.
    self.ignored_at_file_nodes = []
        # List of nodes for error dialog.
    self.import_error_nodes = []
        #
    self.last_dir = None
        # The last used directory.
    self.mFileName = fileName or ''
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)
    self.mRelativeFileName = relativeFileName or ''
        #
    self.openDirectory = None
        #
    self.wrappedFileName = None
        # The name of the wrapped file, for wrapper commanders.
        # Set by LM.initWrapperLeoFile
.. @+node:ekr.20120217070122.10469: *7* c.initOptionsIvars
def initOptionsIvars(self):
    '''Init Commander ivars corresponding to user options.'''
    self.fixed = False
    self.fixedWindowPosition = []
    self.forceExecuteEntireBody = False
    self.focus_border_color = 'white'
    self.focus_border_width = 1 # pixels
    self.outlineHasInitialFocus = False
    self.page_width = 132
    self.sparse_find = True
    self.sparse_move = True
    self.sparse_spell = True
    self.stayInTreeAfterSelect = False
    self.tab_width = -4
    self.tangle_batch_flag = False
    self.target_language = "python"
    self.untangle_batch_flag = False
    self.use_body_focus_border = True
    self.use_focus_border = False
    self.vim_mode = False
.. @+node:ekr.20120217070122.10468: *7* c.initObjectIvars
def initObjectIvars(self):
    # These ivars are set later by leoEditCommands.createEditCommanders
    self.abbrevCommands = None
    self.bufferCommands = None
    self.editCommands = None
    self.db = {} # May be set to a PickleShare instance later.
    self.chapterCommands = None
    self.controlCommands = None
    self.convertCommands = None
    self.debugCommands = None
    self.editFileCommands = None
    self.gotoCommands = None
    self.helpCommands = None
    self.keyHandler = self.k = None
    self.keyHandlerCommands = None
    self.killBufferCommands = None
    self.leoCommands = None
    self.macroCommands = None
    self.miniBufferWidget = None
    self.printingController = None
    self.queryReplaceCommands = None
    self.rectangleCommands = None
    self.registerCommands = None
    self.searchCommands = None
    self.spellCommands = None
    self.leoTestManager = None
    self.vimCommands = None
.. @+node:ekr.20120217070122.10470: *7* c.initObjects
@nobeautify

def initObjects(self, gui):
    trace = (False or g.trace_startup) and not g.unitTesting
    c = self
    if trace: g.es_debug(c.shortFileName(), g.app.gui)
    gnx = 'hidden-root-vnode-gnx'
    assert not hasattr(c, 'fileCommands'), c.fileCommands

    class DummyFileCommands:
        def __init__(self):
            self.gnxDict = {}

    c.fileCommands = DummyFileCommands()
    self.hiddenRootNode = leoNodes.VNode(context=c, gnx=gnx)
    c.fileCommands = None
    # Create the gui frame.
    title = c.computeWindowTitle(c.mFileName)
    if not g.app.initing:
        g.doHook("before-create-leo-frame", c=c)
    self.frame = gui.createLeoFrame(c, title)
    assert self.frame
    assert self.frame.c == c
    import leo.core.leoHistory as leoHistory
    self.nodeHistory = leoHistory.NodeHistory(c)
    self.initConfigSettings()
    c.setWindowPosition() # Do this after initing settings.
    # Break circular import dependencies by importing here.
    # These imports take almost 3/4 sec in the leoBridge.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoBeautify as leoBeautify # So decorators are executed.
    assert leoBeautify # for pyflakes.
    import leo.core.leoCache as leoCache
    import leo.core.leoChapters as leoChapters
    # User commands...
    import leo.commands.abbrevCommands as abbrevCommands
    import leo.commands.bufferCommands as bufferCommands
    import leo.commands.controlCommands as controlCommands
    import leo.commands.convertCommands as convertCommands
    import leo.commands.debugCommands as debugCommands
    import leo.commands.editCommands as editCommands
    import leo.commands.editFileCommands as editFileCommands
    import leo.commands.gotoCommands as gotoCommands
    import leo.commands.helpCommands as helpCommands
    import leo.commands.keyCommands as keyCommands
    import leo.commands.killBufferCommands as killBufferCommands
    import leo.commands.macroCommands as macroCommands
    import leo.commands.rectangleCommands as rectangleCommands
    import leo.commands.registerCommands as registerCommands
    import leo.commands.spellCommands as spellCommands
    # Other subcommanders.
    import leo.core.leoFind as leoFind # Leo 4.11.1
    import leo.core.leoKeys as leoKeys
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoPersistence as leoPersistence
    import leo.core.leoPrinting as leoPrinting
    import leo.core.leoRst as leoRst
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoTest as leoTest
    import leo.core.leoUndo as leoUndo
    import leo.core.leoVim as leoVim
    # Define the subcommanders.
    self.keyHandler = self.k    = leoKeys.KeyHandlerClass(c)
    self.chapterController      = leoChapters.ChapterController(c)
    self.shadowController       = leoShadow.ShadowController(c)
    self.fileCommands           = leoFileCommands.FileCommands(c)
    self.findCommands           = leoFind.LeoFind(c)
    self.atFileCommands         = leoAtFile.AtFile(c)
    self.importCommands         = leoImport.LeoImportCommands(c)
    self.persistenceController  = leoPersistence.PersistenceDataController(c)
    self.printingController     = leoPrinting.PrintingController(c)
    self.rstCommands            = leoRst.RstCommands(c)
    self.tangleCommands         = leoTangle.TangleCommands(c)
    self.testManager            = leoTest.TestManager(c)
    self.vimCommands            = leoVim.VimCommands(c)
    # User commands
    self.abbrevCommands     = abbrevCommands.AbbrevCommandsClass(c)
    self.bufferCommands     = bufferCommands.BufferCommandsClass(c)
    self.controlCommands    = controlCommands.ControlCommandsClass(c)
    self.convertCommands    = convertCommands.ConvertCommandsClass(c)
    self.debugCommands      = debugCommands.DebugCommandsClass(c)
    self.editCommands       = editCommands.EditCommandsClass(c)
    self.editFileCommands   = editFileCommands.EditFileCommandsClass(c)
    self.gotoCommands       = gotoCommands.GoToCommands(c)
    self.helpCommands       = helpCommands.HelpCommandsClass(c)
    self.keyHandlerCommands = keyCommands.KeyHandlerCommandsClass(c)
    self.killBufferCommands = killBufferCommands.KillBufferCommandsClass(c)
    self.macroCommands      = macroCommands.MacroCommandsClass(c)
    self.rectangleCommands  = rectangleCommands.RectangleCommandsClass(c)
    self.registerCommands   = registerCommands.RegisterCommandsClass(c)
    self.spellCommands      = spellCommands.SpellCommandsClass(c)
    # Other objects
    self.cacher = leoCache.Cacher(c)
    self.cacher.initFileDB(self.mFileName)
    self.undoer = leoUndo.Undoer(self)
    import leo.plugins.free_layout as free_layout
    self.free_layout = free_layout.FreeLayoutController(c)
    if hasattr(g.app.gui, 'styleSheetManagerClass'):
        self.styleSheetManager = g.app.gui.styleSheetManagerClass(c)
    else:
        self.styleSheetManager = None
    if hasattr(g.app.gui, 'bigTextControllerClass'):
        self.bigTextController = g.app.gui.bigTextControllerClass(c)
    else:
        self.bigTextController = None
.. @+node:ekr.20140815160132.18837: *7* c.initSettings
def initSettings(self, previousSettings):
    '''Init the settings *before* initing the objects.'''
    c = self
    import leo.core.leoConfig as leoConfig
    c.config = leoConfig.LocalConfigManager(c, previousSettings)
    g.app.config.setIvarsFromSettings(c)
.. @+node:ekr.20150604163903.1: *6* run & helpers
def run(self, files):
    '''Process all files'''
    self.files = files
    t1 = time.time()
    for fn in files:
        s, e = g.readFileIntoString(fn)
        if s:
            self.tot_s += len(s)
            g.trace('%8s %s' % ("{:,}".format(len(s)), g.shortFileName(fn)))
                # Print len(s), with commas.
            # Fast, accurate:
            # 1.9 sec for parsing.
            # 2.5 sec for Null AstFullTraverer traversal.
            # 2.7 sec to generate all strings.
            # 3.8 sec to generate all reports.
            s1 = g.toEncodedString(s)
            self.tot_lines += len(g.splitLines(s))
                # Adds less than 0.1 sec.
            node = ast.parse(s1, filename='before', mode='exec')
            ShowDataTraverser(self, fn).visit(node)
            # elif 0: # Too slow, too clumsy: 3.3 sec for tokenizing
                # readlines = g.ReadLinesClass(s).next
                # for token5tuple in tokenize.generate_tokens(readlines):
                    # pass
            # else: # Inaccurate. 2.2 sec to generate all reports.
                # self.scan(fn, s)
        else:
            g.trace('skipped', g.shortFileName(fn))
    t2 = time.time()
        # Get the time exlusive of print time.
    self.show_results()
    g.trace('done: %4.1f sec.' % (t2 - t1))
.. @+node:ekr.20061002095711.1: *6* c.navQuickKey
def navQuickKey(self):
    '''return true if there are two quick outline navigation keys
    in quick succession.

    Returns False if @float outline_nav_extend_delay setting is 0.0 or unspecified.'''
    c = self
    deltaTime = c.config.getFloat('outline_nav_extend_delay')
    if deltaTime in (None, 0.0):
        return False
    else:
        nearTime = c.navTime and time.time() - c.navTime < deltaTime
        return nearTime
.. @+node:ekr.20160517182239.10: *6* main & helpers
def main(files):
    '''Call run on all tables in tables_table.'''
    from flake8 import engine
    config_file = get_flake8_config()
    if config_file:
        style = engine.get_style_guide(
            parse_argv=False, config_file=config_file)
        t1 = time.time()
        check_all(files, style)
        t2 = time.time()
        n = len(files)
        print('%s file%s, time: %5.2f sec.' % (n, g.plural(n), t2-t1))
.. @+node:ekr.20160517222900.1: *7* get_home
def get_home():
    """Returns the user's home directory."""
    home = g.os_path_expanduser("~")
        # Windows searches the HOME, HOMEPATH and HOMEDRIVE
        # environment vars, then gives up.
    if home and len(home) > 1 and home[0] == '%' and home[-1] == '%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1: -1], default=None)
    if home:
        # Important: This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_finalize(home)
        if (
            not g.os_path_exists(home) or
            not g.os_path_isdir(home)
        ):
            home = None
    return home
.. @+node:ekr.20160517222236.1: *7* get_flake8_config
def get_flake8_config():
    '''Return the path to the flake8 configuration file.'''
    trace = False and not g.unitTesting
    join = g.os_path_finalize_join
    homeDir = get_home()
    loadDir = g.os_path_finalize_join(g.__file__, '..', '..')
    base_table = ('flake8', 'flake8.txt')
    dir_table = (
        homeDir,
        join(homeDir, '.leo'),
        join(loadDir, '..', '..', 'leo', 'test'),
    )
    for base in base_table:
        for path in dir_table:
            fn = g.os_path_abspath(join(path, base))
            if g.os_path_exists(fn):
                if trace: g.trace('found:', fn)
                return fn
    print('no flake8 configuration file found in\n%s' % (
        '\n'.join(dir_table)))
    return None
.. @+node:ekr.20160517222332.1: *7* check_all
def check_all(files, style):
    '''Run flake8 on all paths.'''
    from flake8 import main
    # loadDir = g.os_path_finalize_join(g.__file__, '..', '..')
    # paths = []
    # for fn in files:
        # if dir_:
            # fn = g.os_path_join(loadDir, dir_, fn)
        # else:
            # fn = g.os_path_join(loadDir, fn)
        # fn = g.os_path_abspath(fn)
        # if not fn.endswith('.py'):
            # fn = fn+'.py'
        # if g.os_path_exists(fn):
            # # Make *sure* that we check files only once.
            # if fn in seen:
                # g.trace('already seen:', fn)
            # else:
                # seen.add(fn)
                # paths.append(fn)
        # else:
            # print('does not exist: %s' % (fn))

    # Set statistics here, instead of from the command line.
    # options = style.options
    # options.statistics = True
    # options.total_errors = True
    # options.benchmark = True
    report = style.check_files(paths=files)
    main.print_report(report, style)
.. @+node:ekr.20160518000549.10: *6* main
def main(files):
    '''Call run on all tables in tables_table.'''    
    t1 = time.time()
    for fn in files:
        # Report the file name.
        assert g.os_path_exists(fn), fn
        sfn = g.shortFileName(fn)
        s = g.readFileIntoEncodedString(fn, silent=False)
        if s and s.strip():
            r = reporter.Reporter(
                errorStream=sys.stderr,
                warningStream=sys.stderr,
                )
            api.check(s, sfn, r)
    t2 = time.time()
    n = len(files)
    print('%s file%s, time: %5.2f sec.' % (n, g.plural(n), t2-t1))
.. @+node:ekr.20140331201252.16859: *6* main & helpers
def main(files, verbose):
    '''Call run on all tables in tables_table.'''
    try:
        from pylint import lint
        assert lint
    except ImportError:
        print('pylint-leo.py: can not import pylint')
        return
    t1 = time.time()
    for fn in files:
        run(fn, verbose)
    t2 = time.time()
    n = len(files)
    print('%s file%s, time: %5.2f sec.' % (n, g.plural(n), t2-t1))
.. @+node:ekr.20100221142603.5644: *7* run (pylint-leo.py)
@nobeautify

def run(fn, verbose):
    '''Run pylint on fn.'''
    trace = False and not g.unitTesting
    # theDir is empty for the -f option.
    from pylint import lint
    assert lint
    rc_fn = os.path.abspath(os.path.join('leo','test','pylint-leo-rc.txt'))
    if not os.path.exists(rc_fn):
        print('pylint rc file not found: %s' % (rc_fn))
        return
    if verbose:
        path = g.os_path_dirname(fn)
        dirs = path.split(os.sep)
        theDir = dirs and dirs[-1] or ''
        print('pylint-leo.py: %s%s%s' % (theDir,os.sep,g.shortFileName(fn)))
    # Call pylint in a subprocess so Pylint doesn't abort *this* process.
    args = ','.join([
        "fn=r'%s'" % (fn),
        "rc=r'%s'" % (rc_fn),
    ])
    if 0: # Prints error number.
        args.append('--msg-template={path}:{line}: [{msg_id}({symbol}), {obj}] {msg}')
    command = '%s -c "import leo.core.leoGlobals as g; g.run_pylint(%s)"' % (
        sys.executable, args)
    t1 = time.time()
    g.execute_shell_commands(command)
    t2 = time.time()
    if trace:
        g.trace('%4.2f %s' % (t2-t1, g.shortFileName(fn)))
.. @+node:ekr.20100221142603.5644: *6* run (pylint-leo.py)
@nobeautify

def run(fn, verbose):
    '''Run pylint on fn.'''
    trace = False and not g.unitTesting
    # theDir is empty for the -f option.
    from pylint import lint
    assert lint
    rc_fn = os.path.abspath(os.path.join('leo','test','pylint-leo-rc.txt'))
    if not os.path.exists(rc_fn):
        print('pylint rc file not found: %s' % (rc_fn))
        return
    if verbose:
        path = g.os_path_dirname(fn)
        dirs = path.split(os.sep)
        theDir = dirs and dirs[-1] or ''
        print('pylint-leo.py: %s%s%s' % (theDir,os.sep,g.shortFileName(fn)))
    # Call pylint in a subprocess so Pylint doesn't abort *this* process.
    args = ','.join([
        "fn=r'%s'" % (fn),
        "rc=r'%s'" % (rc_fn),
    ])
    if 0: # Prints error number.
        args.append('--msg-template={path}:{line}: [{msg_id}({symbol}), {obj}] {msg}')
    command = '%s -c "import leo.core.leoGlobals as g; g.run_pylint(%s)"' % (
        sys.executable, args)
    t1 = time.time()
    g.execute_shell_commands(command)
    t2 = time.time()
    if trace:
        g.trace('%4.2f %s' % (t2-t1, g.shortFileName(fn)))
.. @+node:ekr.20090608081524.6109: *6* LeoTree.set_body_text_after_select
def set_body_text_after_select(self, p, old_p, traceTime, force=False):
    '''Set the text after selecting a node.'''
    trace = False and not g.unitTesting
    trace_pass = False
    trace_time = (True or traceTime)
    if trace_time: t1 = time.time()
    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c
    w = c.frame.body.wrapper
    s = p.v.b # Guaranteed to be unicode.
    # Part 1: get the old text.
    old_s = w.getAllText()
    if trace: g.trace('=====', len(s), p.h)
    if trace and trace_time:
        t2 = time.time()
        print('  part1: getAllText %4.2f sec' % (t2-t1))
    if not force and p and p == old_p and s == old_s:
        if trace and trace_pass: g.trace('*pass', len(s), p.h, old_p.h)
        return
    # Part 2: set the new text.
    # w.setAllText destroys all color tags, so do a full recolor.
    if 0 < c.max_pre_loaded_body_chars < len(s):
        # Don't load the text if not wanted.
        if trace and trace_time:
            t3 = time.time()
            print('  part2: setAllText %4.2f sec' % (t3-t2))
    else:
        w.setAllText(s, h = p.h)
        if trace and trace_time:
            t3 = time.time()
            print('  part2: setAllText %4.2f sec' % (t3-t2))
        # Part 3: colorize.
        # We can't call c.recolor_now here.
        colorizer = c.frame.body.colorizer
        if hasattr(colorizer, 'setHighlighter'):
            if colorizer.setHighlighter(p):
                self.frame.body.recolor(p)
        else:
            self.frame.body.recolor(p)
    if trace and trace_time:
        t4 = time.time()
        print('  part3: colorize   %4.2f sec' % (t4-t3))
        print('  total:            %4.2f sec' % (t4-t1))
    # This is now done after c.p has been changed.
        # p.restoreCursorAndScroll()
.. @+node:ekr.20160317054700.166: *6* st.run (main line) & helpers

def run(self, node):
    '''StubTraverser.run: write the stubs in node's tree to self.output_fn.'''
    fn = self.output_fn
    dir_ = os.path.dirname(fn)
    if os.path.exists(fn) and not self.overwrite:
        print('file exists: %s' % fn)
    elif not dir_ or os.path.exists(dir_):
        t1 = time.time()
        # Delayed output allows sorting.
        self.parent_stub = Stub(kind='root', name='<new-stubs>')
        for z in self.prefix_lines or []:
            self.parent_stub.out_list.append(z)
        self.visit(node)
            # Creates parent_stub.out_list.
        if self.update_flag:
            self.parent_stub = self.update(fn, new_root=self.parent_stub)
        if 1:
            self.output_file = open(fn, 'w')
            self.output_time_stamp()
            self.output_stubs(self.parent_stub)
            self.output_file.close()
            self.output_file = None
            self.parent_stub = None
        t2 = time.time()
        print('wrote: %s in %4.2f sec' % (fn, t2 - t1))
    else:
        print('output directory not not found: %s' % dir_)
.. @+node:ekr.20160317054700.167: *7* st.output_stubs

def output_stubs(self, stub):
    '''Output this stub and all its descendants.'''
    for s in stub.out_list or []:
        # Indentation must be present when an item is added to stub.out_list.
        if self.output_file:
            self.output_file.write(s.rstrip()+'\n')
        else:
            print(s)
    # Recursively print all children.
    for child in stub.children:
        self.output_stubs(child)
.. @+node:ekr.20160317054700.168: *7* st.output_time_stamp

def output_time_stamp(self):
    '''Put a time-stamp in the output file.'''
    if self.output_file:
        self.output_file.write('# make_stub_files: %s\n' %
            time.strftime("%a %d %b %Y at %H:%M:%S"))
.. @+node:ekr.20160317054700.169: *7* st.update & helpers

def update(self, fn, new_root):
    '''
    Merge the new_root tree with the old_root tree in fn (a .pyi file).

    new_root is the root of the stub tree from the .py file.
    old_root (read below) is the root of stub tree from the .pyi file.

    Return old_root, or new_root if there are any errors.
    '''
    trace = False ; verbose = False
    s = self.get_stub_file(fn)
    if not s or not s.strip():
        return new_root
    if '\t' in s:
        # Tabs in stub files make it impossible to parse them reliably.
        g.trace('Can not update stub files containing tabs.')
        return new_root
    # Read old_root from the .pyi file.
    old_d, old_root = self.parse_stub_file(s, root_name='<old-stubs>')
    if old_root:
        # Merge new stubs into the old tree.
        if trace and verbose:
            print(self.trace_stubs(old_root, header='old_root'))
            print(self.trace_stubs(new_root, header='new_root'))
        print('***** updating stubs from %s *****' % fn)
        self.merge_stubs(self.stubs_dict.values(), old_root, new_root)
        if trace:
            print(self.trace_stubs(old_root, header='updated_root'))
        return old_root
    else:
        return new_root
.. @+node:ekr.20160317054700.170: *8* st.get_stub_file

def get_stub_file(self, fn):
    '''Read the stub file into s.'''
    if os.path.exists(fn):
        try:
            s = open(fn, 'r').read()
        except Exception:
            print('--update: error reading %s' % fn)
            s = None
        return s
    else:
        print('--update: not found: %s' % fn)
        return None
.. @+node:ekr.20160317054700.171: *8* st.parse_stub_file

def parse_stub_file(self, s, root_name):
    '''
    Parse s, the contents of a stub file, into a tree of Stubs.

    Parse by hand, so that --update can be run with Python 2.
    '''
    trace = False
    assert '\t' not in s
    d = {}
    root = Stub(kind='root', name=root_name)
    indent_stack = [-1] # To prevent the root from being popped.
    stub_stack = [root]
    lines = []
    pat = re.compile(r'^([ ]*)(def|class)\s+([a-zA-Z_]+)(.*)')
    for line in g.splitLines(s):
        m = pat.match(line)
        if m:
            indent, kind, name, rest = (
                len(m.group(1)), m.group(2), m.group(3), m.group(4))
            old_indent = indent_stack[-1]
            # Terminate any previous lines.
            old_stub = stub_stack[-1]
            old_stub.out_list.extend(lines)
            if trace:
                for s in lines:
                    g.trace('  '+s.rstrip())
            lines = [line]
            # Adjust the stacks.
            if indent == old_indent:
                stub_stack.pop()
            elif indent > old_indent:
                indent_stack.append(indent)
            else: # indent < old_indent
                # The indent_stack can't underflow because
                # indent >= 0 and indent_stack[0] < 0
                assert indent >= 0
                while indent <= indent_stack[-1]:
                    indent_stack.pop()
                    old_stub = stub_stack.pop()
                    assert old_stub != root
                indent_stack.append(indent)
            # Create and push the new stub *after* adjusting the stacks.
            assert stub_stack
            parent = stub_stack[-1]
            stack = [z.name for z in stub_stack[1:]]
            parent = stub_stack[-1]
            stub = Stub(kind, name, parent, stack)
            self.add_stub(d, stub)
            stub_stack.append(stub)
            if trace:
                g.trace('%s%5s %s %s' % (' '*indent, kind, name, rest))
        else:
            parent = stub_stack[-1]
            lines.append(line)
    # Terminate the last stub.
    old_stub = stub_stack[-1]
    old_stub.out_list.extend(lines)
    if trace:
        for s in lines:
            g.trace('  '+s.rstrip())
    return d, root
.. @+node:ekr.20160317054700.172: *8* st.merge_stubs & helpers

def merge_stubs(self, new_stubs, old_root, new_root, trace=False):
    '''
    Merge the new_stubs *list* into the old_root *tree*.
    - new_stubs is a list of Stubs from the .py file.
    - old_root is the root of the stubs from the .pyi file.
    - new_root is the root of the stubs from the .py file.
    '''
    trace = False or trace ; verbose = False
    # Part 1: Delete old stubs do *not* exist in the *new* tree.
    aList = self.check_delete(new_stubs,
                              old_root,
                              new_root,
                              trace and verbose)
        # Checks that all ancestors of deleted nodes will be deleted.
    aList = list(reversed(self.sort_stubs_by_hierarchy(aList)))
        # Sort old stubs so that children are deleted before parents.
    if trace and verbose:
        dump_list('ordered delete list', aList)
    for stub in aList:
        if trace: g.trace('deleting  %s' % stub)
        parent = self.find_parent_stub(stub, old_root) or old_root
        parent.children.remove(stub)
        assert not self.find_stub(stub, old_root), stub
    # Part 2: Insert new stubs that *not* exist in the *old* tree.
    aList = [z for z in new_stubs if not self.find_stub(z, old_root)]
    aList = self.sort_stubs_by_hierarchy(aList)
        # Sort new stubs so that parents are created before children.
    for stub in aList:
        if trace: g.trace('inserting %s' % stub)
        parent = self.find_parent_stub(stub, old_root) or old_root
        parent.children.append(stub)
        assert self.find_stub(stub, old_root), stub
.. @+node:ekr.20160317054700.173: *9* st.check_delete

def check_delete(self, new_stubs, old_root, new_root, trace):
    '''Return a list of nodes that can be deleted.'''
    old_stubs = self.flatten_stubs(old_root)
    old_stubs.remove(old_root)
    aList = [z for z in old_stubs if z not in new_stubs]
    if trace:
        dump_list('old_stubs', old_stubs)
        dump_list('new_stubs', new_stubs)
        dump_list('to-be-deleted stubs', aList)
    delete_list = []
    # Check that all parents of to-be-delete nodes will be deleted.
    for z in aList:
        z1 = z
        for i in range(20):
            z = z.parent
            if not z:
                g.trace('can not append: new root not found', z)
                break
            elif z == old_root:
                # if trace: g.trace('can delete', z1)
                delete_list.append(z1)
                break
            elif z not in aList:
                g.trace("can not delete %s because of %s" % (z1, z))
                break
        else:
            g.trace('can not happen: parent loop')
    if trace:
        dump_list('delete_list', delete_list)
    return delete_list
.. @+node:ekr.20160317054700.174: *9* st.flatten_stubs

def flatten_stubs(self, root):
    '''Return a flattened list of all stubs in root's tree.'''
    aList = [root]
    for child in root.children:
        self.flatten_stubs_helper(child, aList)
    return aList

def flatten_stubs_helper(self, root, aList):
    '''Append all stubs in root's tree to aList.'''
    aList.append(root)
    for child in root.children:
        self.flatten_stubs_helper(child, aList)
.. @+node:ekr.20160317054700.175: *9* st.find_parent_stub

def find_parent_stub(self, stub, root):
    '''Return stub's parent **in root's tree**.'''
    return self.find_stub(stub.parent, root) if stub.parent else None
.. @+node:ekr.20160317054700.176: *9* st.find_stub

def find_stub(self, stub, root):
    '''Return the stub **in root's tree** that matches stub.'''
    if stub == root: # Must use Stub.__eq__!
        return root # not stub!
    for child in root.children:
        stub2 = self.find_stub(stub, child)
        if stub2: return stub2
    return None
.. @+node:ekr.20160317054700.177: *9* st.sort_stubs_by_hierarchy

def sort_stubs_by_hierarchy(self, stubs1):
    '''
    Sort the list of Stubs so that parents appear before all their
    descendants.
    '''
    stubs, result = stubs1[:], []
    for i in range(50):
        if stubs:
            # Add all stubs with i parents to the results.
            found = [z for z in stubs if z.level() == i]
            result.extend(found)
            for z in found:
                stubs.remove(z)
        else:
            return result
    g.trace('can not happen: unbounded stub levels.')
    return [] # Abort the merge.
.. @+node:ekr.20160317054700.178: *8* st.trace_stubs

def trace_stubs(self, stub, aList=None, header=None, level=-1):
    '''Return a trace of the given stub and all its descendants.'''
    indent = ' '*4*max(0,level)
    if level == -1:
        aList = ['===== %s...\n' % (header) if header else '']
    for s in stub.out_list:
        aList.append('%s%s' % (indent, s.rstrip()))
    for child in stub.children:
        self.trace_stubs(child, level=level+1, aList=aList)
    if level == -1:
        return '\n'.join(aList) + '\n'
.. @+node:ekr.20031218072017.3137: *6* g.Timing
def getTime():
    return time.time()

def esDiffTime(message, start):
    delta = time.time() - start
    g.es('', "%s %5.2f sec." % (message, delta))
    return time.time()

def printDiffTime(message, start):
    delta = time.time() - start
    g.pr("%s %5.2f sec." % (message, delta))
    return time.time()

def timeSince(start):
    return "%5.2f sec." % (time.time() - start)
.. @+node:ekr.20140526123310.17593: *6* test
def test(c):
    g.cls()
    t1 = time.time()
    RopeController(c).run()
    print('done: %s sec.' % g.timeSince(t1))
.. @+node:ekr.20100221142603.5644: *5* run (pylint-leo.py)
@nobeautify

def run(fn, verbose):
    '''Run pylint on fn.'''
    trace = False and not g.unitTesting
    # theDir is empty for the -f option.
    from pylint import lint
    assert lint
    rc_fn = os.path.abspath(os.path.join('leo','test','pylint-leo-rc.txt'))
    if not os.path.exists(rc_fn):
        print('pylint rc file not found: %s' % (rc_fn))
        return
    if verbose:
        path = g.os_path_dirname(fn)
        dirs = path.split(os.sep)
        theDir = dirs and dirs[-1] or ''
        print('pylint-leo.py: %s%s%s' % (theDir,os.sep,g.shortFileName(fn)))
    # Call pylint in a subprocess so Pylint doesn't abort *this* process.
    args = ','.join([
        "fn=r'%s'" % (fn),
        "rc=r'%s'" % (rc_fn),
    ])
    if 0: # Prints error number.
        args.append('--msg-template={path}:{line}: [{msg_id}({symbol}), {obj}] {msg}')
    command = '%s -c "import leo.core.leoGlobals as g; g.run_pylint(%s)"' % (
        sys.executable, args)
    t1 = time.time()
    g.execute_shell_commands(command)
    t2 = time.time()
    if trace:
        g.trace('%4.2f %s' % (t2-t1, g.shortFileName(fn)))
.. @+node:ekr.20140401054342.16844: *5* g.run_pylint
def run_pylint(fn, rc,
    dots=True, # Show level dots in Sherlock traces.
    patterns=None, # List of Sherlock trace patterns.
    sherlock=False, # Enable Sherlock tracing.
    show_return=True, # Show returns in Sherlock traces.
    stats_patterns=None, # Patterns for Sherlock statistics.
    verbose=True, # Show filenames in Sherlock traces.
):
    '''
    Run pylint with the given args, with Sherlock tracing if requested.
    Do not assume g.app exists.
    '''
    try:
        from pylint import lint
    except ImportError:
        return g.trace('can not import pylint')
    if not g.os_path_exists(fn):
        return g.trace('does not exist:', fn)
    if not g.os_path_exists(rc):
        return g.trace('does not exist', rc)
    # g.trace(rc)
    args = ['--rcfile=%s' % (rc)]
    # Prints error number.
    # args.append('--msg-template={path}:{line}: [{msg_id}({symbol}), {obj}] {msg}')
    args.append(fn)
    if sherlock:
        sherlock = g.SherlockTracer(
                dots=dots,
                show_return=show_return,
                verbose=True, # verbose: show filenames.
                patterns=patterns or [],
            )
        try:
            sherlock.run()
            lint.Run(args)
        finally:
            sherlock.stop()
            sherlock.print_stats(patterns=stats_patterns or [])
    else:
        # print('g.run_pylint: lint: %s' % lint)
        # print('g.run_pylint: %s' % g.shortFileName(fn))
        lint.Run(args)
.. @+node:ekr.20160503084702.1: *4* pylint command appends leo directory to sys.path
This allows the pylint command to work without any sitecustomize.py file.
.. @+node:ekr.20160503093403.1: *4* Removed all static abbrev commands
See unused emacs abbreviation commands.
.. @+node:ekr.20160427071821.1: *4* Wont do: #236: abbrev-write generates different continuations than used in @data
abbrev-write generates different continuations than used in @data
https://github.com/leo-editor/leo-editor/issues/236

When defining abbreviations in a @data abbreviations node,
continuation looks like:
continue;;=line 1
: line 2
: line 3

when abbreviations are dumped via abbrev-write they look like:
continue;;=line 1\n line 2\n line 3

I would consider the abbrev-write file more useful if it used the
same continuation convention as in @data nodes
.. @-all
.. @@nosearch
.. @@killbeautify
.. @@language rest
.. @@wrap
.. @@pagewidth 60
.. @-leo
