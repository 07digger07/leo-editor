.. @+leo-ver=5-thin
.. @+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
.. @@language rest

.. @+all
.. @+node:ekr.20131225061403.16376: ** 4.11.1
.. @+node:ekr.20131105020211.18059: *3* Added per-node expansions!
@language rest
https://groups.google.com/forum/#!topic/leo-editor/Wd0NtBLEZZk

What I did:

- Added v.expandedPositions ivar.
- Wrote c.shouldBeExpanded.
- p.isExpanded calls c.shouldBeExpanded if p is a clone.
  This is important: it means that most code does not have to be aware of c.shouldBeExpanded.
- p.expand & p.contract maintain p.v.expandedPositions list.
- Rewrote & simplified p.isVisible.
- Left c.positionExists and p.isAncestorOf unchanged.
.. @+node:ekr.20131222112420.16373: *4* Notes
The idea is store "ephemeral" or position-related data **in vnodes*. This
is a completely new idea in Leo's history!

Suppose every vnode contains a new ivar: v.expandedPositions, a list of
(copies of) positions at which v is to be expanded. This would work as
follows:

1. Contracting a node at position p clears p.v.expandedPositions. The happy
   side effects is that contracting any clone will contract them all.

2. Expanding a node at position appends p.copy() to p.v.expandedPositions,
   and purges any no-longer-existing positions from that list.

3. nativeTree.drawChildren will expand nodes using c.shouldBeExpanded(p) instead of
   p.isExpanded(p).

As always, changing outline structure will invalidate positions. Because
c.p and all it's ancestors are always expanded, the worst that can happen
when an outline changes is that some positions that *aren't* the present
position will contract unexpectedly. Most such contraction will occur off
screen.
.. @+node:ekr.20131223064351.16352: *3* Improved p.isAncestorOf and c.positionExists
- Added test for c.positionExists to p.isAncestorOf.
- Added v.isNthChildOf
- Rewrote c.positionsExists using v.isNthChildOf
.. @+node:ekr.20131224124822.16717: *3* Fixed problems with clone-expansion
@language rest

Alt-End when the last top-level node was a clone caused all clones to expand.

The fix was in p.isAncestorOf.

Also, changed p.all_unique_positions() to p.all_positions() in places where p.contract was called.

I started this project by doing a clone-find-all for isExpanded.

@language python
.. @+node:ekr.20131225061403.16378: *3* Fixed bug 1264350
@language rest

Up-arrow on the first node in a chapter switches to another chapter 
https://bugs.launchpad.net/leo-editor/+bug/1264350

Solution:

1. The "fix" at rev 6472 was wrong: The original code was correct.
2. Added a unit test.
.. @+node:ekr.20131225045014.16398: *3* Fixed problem with 1-character reverse searches!
The problem was an off-by-one test in regexHelper.
.. @+node:ekr.20140114145953.16692: *3* Added c.config.isLocalSetting
.. @+node:ekr.20140114145953.16693: *3* Fixed important security hole in mod_scripting plugin
The ctor of the scriptingController does not allow::

    @bool scripting-at-script-nodes = True
    
in local .leo files. 
.. @+node:ekr.20140205074001.16358: *3* Fixed a startup error involving --ipython
Fixed a bug that caused Leo to exit during startup when
--python given on the command line but IPython is not installed.
.. @+node:ekr.20140209065845.16766: *3* Fixed unicode problem in the log pane

@language rest

Fixed bug: https://bugs.launchpad.net/leo-editor/+bug/1276236

g.insertCodingLine adds coding line to start of all python scripts, except when unit testing.
.. @+node:ekr.20140212082408.16406: *3* Added spell-as-you-type commands
Thanks to Terry Brown for these commands::

spell-as-you-type-toggle
  Enable / disable spell as you type mode.  When enabled, word ending
  keystrokes will put a short list of suggestions in the log window, if
  the word is unknown to the speller.  Only shows the first 5
  suggestions, even if there are more.

spell-as-you-type-next
  Cycle the word behind (left of, for ltr languages) the cursor through
  the full list of suggestions.

spell-as-you-type-undo
  Change the word behind (left of, for ltr languages) the cursor to
.. @+node:ekr.20140218040104.16759: *3* added p.nosentinels
.. @+node:ekr.20140313100328.16828: *3* Fixed serious c.deletePositionsInList bug
@nocolor-node

https://groups.google.com/forum/#!topic/leo-editor/Uoa7ifVV_Aw

I selected ALL nodes, and deleted them. (I think I used the context menu
delete) Then the outline window was red, could not insert any nodes, could
not Undo. Todd. Had to abandon the outline and start again.

# Breaks Leo HARD:
# c.deletePositionsInList(c.all_positions())
.. @+node:ekr.20140401054342.16845: *3* Created g.run_pylint so pylint can run unmodified
@language rest

This runs pylint (with optional Sherlock tracing) in
a separate process, thereby allowing Leo to run
pylint unchanged.

What I did:

1. pylint-leo.py: run now runs the following command in a separate process::

    <python> -c "import leo.core.leoGlobals as g; g.run_pylint(<args>)"
    
2. g.run_pylint uses Sherlock tracing if requested.

    
.. @+node:ekr.20140424102007.16873: *3* Fixed clone-find-all command
Changed find.findAll and helpers as follows:
    
- findAll inits onlyPosition for the clone-find-all commands.
    
- createCloneFindAllNode does not link the node into the outline.
  To do this, leoFind.py imports leo.core.leoNodes.

- linkCloneFindAllNode does this *after* the command completes. This keeps
  all positions unchanged while they are being scanned.
   
- The code now tests for either clone_find_all or clone_find_all_flattened
  in various places.
.. @+node:ekr.20031218072017.3073: *4* find.findAll & helper
def findAll(self,clone_find_all=False,clone_find_all_flattened=False):
    trace = False and not g.unitTesting
    c = self.c ; w = self.s_ctrl ; u = c.undoer
    if clone_find_all_flattened:
        undoType = 'Clone Find All Flattened'
    elif clone_find_all:
        undoType = 'Clone Find All'
    else:
        undoType = 'Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if clone_find_all or clone_find_all_flattened:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    skip = {} # Nodes that should be skipped.
        # Keys are vnodes, values not important.
    count,found = 0,None
    if trace: g.trace(self.p and self.p.h)
    # 2014/04/24: Init suboutline-only for clone-find-all commands
    if clone_find_all or clone_find_all_flattened:
        self.p = c.p.copy()
        if self.suboutline_only:
            self.onlyPosition = self.p.copy()
    while 1:
        pos, newpos = self.findNextMatch() # sets self.p.
        if not self.p: self.p = c.p.copy()
        if pos is None: break
        if clone_find_all and self.p.v in skip:
            continue
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if clone_find_all or clone_find_all_flattened:
            if not skip:
                # Nothing has been created yet.
                undoData = u.beforeInsertNode(c.p)
                found = self.createCloneFindAllNode(flattened = clone_find_all_flattened)
            if clone_find_all_flattened:
                skip[self.p.v] = True
            else:
                # Don't look at the node or it's descendants.
                for p2 in self.p.self_and_subtree():
                    skip[p2.v] = True
            # Create a clone of self.p under the find node.
            p2 = self.p.clone()
            p2.moveToLastChildOf(found)
        else:
            self.printLine(line,allFlag=True)
    if found and (clone_find_all or clone_find_all_flattened):
        self.linkCloneFindAllNode(found)
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        c.selectPosition(found)
        c.setChanged(True)
    else:
        self.restore(data)
    c.redraw()
    g.es("found",count,"matches")
.. @+node:ekr.20051113110735: *5* createCloneFindAllNode
def createCloneFindAllNode(self,flattened):
    '''Create a node, but do *not* link it into the outline yet.'''
    c = self.c
    # Don't link the node into the outline so that positions remain valid.
    v = leoNodes.VNode(context=c)
    p = leoNodes.Position(v)
    p.h = 'Found:%s %s' % (
        ' (flattened)' if  flattened else '',
        self.find_text)
    return p
.. @+node:ekr.20140424102007.16875: *5* linkCloneFindAllNode
def linkCloneFindAllNode(self,p):
    '''Link p into the outline as the last top-level node.'''
    c = self.c
    top = c.rootPosition()
    while top.hasNext():
        top.moveToNext()
    p._linkAfter(top)
.. @+node:ekr.20140426052603.18136: *3* Removed g.choose from Leo's core & plugins
This function is deprecated: use Python's ternary operator instead.
.. @+node:ekr.20140313100328.16825: *3* Fixed leoGlobals bug (per Reinhard Engle)
@language rest

Reinhard Engel reinhard.engel.de@googlemail.com

There seems to be a subtle bug in leoGlobals.py:

In the 'globalDirectiveList', the directive 'command' is missing. This
seems not to cause problems, because of the way 'aList' in
'compute_directives_re' is constructed. Then in 'get_directives_dict' the
directive is silently skipped.

The following pattern in 'compute_directives_re' solves this problem:

@language python

aList = [x for x in globalDirectiveList if z != 'others']
aList.sort(lambda a,b: len(b)-len(a))
    # Sort by length, longest first
pat = "^@(%s)(?=( |\t|\n)+)" % "|".join(aList)
.. @-all

# Put this @language after the @all as a kind of permanent unit test.

.. @@language python # Override the default .txt coloring.

.. @@pagewidth 60
.. @-leo
