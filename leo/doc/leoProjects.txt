#@+leo-ver=5-thin
#@+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
#@+all
#@+node:ekr.20130807203905.16589: ** 4.11 b1 projects
@language rest
#@+node:ekr.20130821062332.11235: *3* Fixed bug 1208942: Leo holding directory/file handles after file close?
@language rest

https://bugs.launchpad.net/leo-editor/+bug/1208942
Leo holding directory/file handles after file close?

Open Leo
2. Create a new directory "test"
3. Create a new Leo file, save as "test/test.leo"
4. Create @file node in test.leo, save file.
5. Close test.leo, but keep Leo open (with another .leo open in a different tab)
6. Attempt to delete "test" directory <<-- FAILS, "open in another application"
7. Close Leo completely
8. Delete "test" directory <<-- Succeeds, now that Leo's closed

Actually, only just opening a .leo file without any @file nodes was enough to keep a file open.

The fix was to close theFile in fc.getLeoFile.

@language python
#@+node:ekr.20130821062332.11233: *3* Added c.recursiveImport and ic.recursiveImportController
This will reduce duplicate scripts.
#@+node:ekr.20130821062332.11236: *3* Added yes-to-all button when prompting for dangerous writes
@language rest

For example, when warning about existing files.

What I did:
    
1. Added yesToAllMessage keyword arg to all runAskYesNoCancelDialog methods.

2. **only** at.writeAll manages at.canCancelFlag, at.cancelFlag and at.yesToAll.

3. Path changed logic in at.writeAllHelper now calls at.promptForDangerousWrite.

4. at.promptForDangerousWrite sets cancelFlag and yesToAll *only* if canCancelFlag is True.
   This ensures that these flags are not changed outside the code managed by at.writeAll.
#@+node:ekr.20130510070942.10611: *3* Fixed bug 1162307: Undoing a headline change does not change focus to the headline
Undoing a headline change does not change focus to the headline
https://bugs.launchpad.net/leo-editor/+bug/1162307
#@+node:ekr.20130805134749.12435: *3* Fixed bug 1182695: the tricky string that leo can not handle
@language python

the tricky string that leo can not handle 
https://bugs.launchpad.net/leo-editor/+bug/1182695

def but_quotes_at_the_end_of_a_triple_quoted_string_are_still_tricky(self):
    string = """Hello "world\""""
    
what

"\"" b # Escape works.

The fix was to the escape-handling code in match_span.
#@+node:ekr.20130908104426.11259: *3* Investigated bug 1182694: not display unique in leo and other editor
@language rest

https://bugs.launchpad.net/leo-editor/+bug/1182694

A string-formatting bug.

https://groups.google.com/forum/?fromgroups#!topic/leo-editor/uy_7dP1uY8w

https://leo-editor.googlegroups.com/attach/4b330006a649027d/SC-2013_5_21_14_12_31.png?view=1&part=5

https://leo-editor.googlegroups.com/attach/4b330006a649027d/SC-2013_5_21_14_12_19.png?view=1&part=4

This is a consequence of an underindented comment.  Like this::

        def test(self):
            string = "abc,\n\
    xyz"

http://leoeditor.com/directives.html#index-7

An underindented line is a line of body text that is indented less then the
starting line of the class, method or function in which it appears. Leo
outlines can not represent such lines exactly: every line in an external
file will have at least the indentation of any unindented line of the
corresponding node in the outline. Leo will issue a warning (not an error)
for underindented Python comment lines. Such lines can not change the
meaning of Python programs.
#@+node:ekr.20130908104426.11267: *3* Fixed bug 1193870 Delete Menu doesn't work in Qt
@language rest

https://bugs.launchpad.net/leo-editor/+bug/1193870

The fix was to leoQtMenu.destroy.  Previously, it did nothing.

Here is a test script::

@language python

    m = c.frame.menu
    name = 'Programming'
    menu = m.getMenu(name)
    if menu:
        m.deleteMenu(name)
    else:
        m.createNewMenu(name)
    
#@+node:ekr.20130908104426.11245: *3* Fixed bug 1019794: p.copyTreeFromSelfTo, chould deepcopy p.v.u
https://bugs.launchpad.net/leo-editor/+bug/1019794

Added the following to copyTreeFromSelfTo:

    p2.v.u = copy.deepcopy(p.v.u)
#@+node:ekr.20130909063103.11556: *3* Fixed bugs 1183855 & 1212332 involving missing select hooks
1183855 (un)select hooks not fired when node selection changed by find command
https://bugs.launchpad.net/leo-editor/+bug/1183855

1212332 Insert doesn't fire unselect / select events
https://bugs.launchpad.net/leo-editor/+bug/1212332


Select and unselect hooks were not being called when a command (including
the find command) left focus in the headline.

The fix was to c.redraw(!) It now calls c.frame.tree.select before calling
c.frame.tree.redraw.
#@+node:ekr.20130806072439.20475: *3* Fixed bug 1223383: Garbled text with BOM-marked files
@language rest

This bug was fixed by the new_read (and new_write) logic
first committed at Rev. 5960.

To do when removing new_read switch:
- Remove unused theFile & fileName args from at.readLine.

@language python
#@+node:ekr.20130911061510.11285: *4*  report
@language rest

https://bugs.launchpad.net/leo-editor/+bug/1223383

https://groups.google.com/forum/#!searchin/leo-editor/garbled$20text/leo-editor/tq1HdMFuyVg/fbpK2M6K1tIJ

**Note**: Python does not support utf-16 encoding:
http://www.python.org/dev/peps/pep-0263/

converting utf-16 -> utf-8 AND remove BOM
http://stackoverflow.com/questions/8827419/converting-utf-16-utf-8-and-remove-bom

    # str.decode will get rid of the BOM for you (and deduce the endianness).
    with open(ff_name, 'rb') as source_file:
        with open(target_file_name, 'w+b') as dest_file:
            contents = source_file.read()
            dest_file.write(contents.decode('utf-16').encode('utf-8'))
        
Note:  my favorite way to see BOM bytes is to open the file in xemacs and use <alt-x>hexl-mode.
For example, the following body text::
    
    @first # -*- coding: utf-16 -*-
    @encoding utf-16

    This is a test
    
Will be rendered as::
    
    00000000: fffe 2300 2000 2d00 2a00 2d00 2000 6300  ..#. .-.*.-. .c.
    00000010: 6f00 6400 6900 6e00 6700 3a00 2000 7500  o.d.i.n.g.:. .u.
    00000020: 7400 6600 2d00 3100 3600 2000 2d00 2a00  t.f.-.1.6. .-.*.
    00000030: 2d00 0a23 fffe 4000 2b00 6c00 6500 6f00  -..#..@.+.l.e.o.
    00000040: 2d00 7600 6500 7200 3d00 3500 2d00 7400  -.v.e.r.=.5.-.t.
    00000050: 6800 6900 6e00 2d00 6500 6e00 6300 6f00  h.i.n.-.e.n.c.o.
    00000060: 6400 6900 6e00 6700 3d00 7500 7400 6600  d.i.n.g.=.u.t.f.
    00000070: 2d00 3100 3600 2c00 2e00 0a23 fffe 4000  -.1.6.,....#..@.
    00000080: 2b00 6e00 6f00 6400 6500 3a00 6500 6b00  +.n.o.d.e.:.e.k.
    00000090: 7200 2e00 3200 3000 3100 3300 3000 3900  r...2.0.1.3.0.9.
    000000a0: 3000 3900 3100 3900 3300 3700 3000 3200  0.9.1.9.3.7.0.2.
    000000b0: 2e00 3900 3100 3700 3000 3a00 2000 2a00  ..9.1.7.0.:. .*.
    000000c0: 2000 4000 6600 6900 6c00 6500 2000 6300   .@.f.i.l.e. .c.
    000000d0: 3a00 2f00 7400 6500 7300 7400 2f00 7500  :./.t.e.s.t./.u.
    000000e0: 7400 6600 2d00 3100 3600 2d00 7400 6500  t.f.-.1.6.-.t.e.
    000000f0: 7300 7400 2e00 7400 7800 7400 0a23 4040  s.t...t.x.t..#@@
    00000100: 6669 7273 740a 23ff fe40 0040 0065 006e  first.#..@.@.e.n
    00000110: 0063 006f 0064 0069 006e 0067 0020 0075  .c.o.d.i.n.g. .u
    00000120: 0074 0066 002d 0031 0036 000a 0aff fe54  .t.f.-.1.6.....T
    00000130: 0068 0069 0073 0020 0069 0073 0020 0061  .h.i.s. .i.s. .a
    00000140: 0020 0074 0065 0073 0074 000a 2340 2d6c  . .t.e.s.t..#@-l
    00000150: 656f 0a                                  eo.

From: Chema Cortes <pych3m4@gmail.com>

I have some external files encoded with utf8 and utf16-le with BOM marks.
Leo ignores these marks, and these files become garbled. I cannot fix this
problem with @enconding directives.

Reading the code, I can see the problem when leo opens files as
binary, followed by a unicode encoding. Why not use, instead, the
'codecs.open' for this job, more friendly with BOM-marks?

Testing with system:
Leo 4.11 devel, build 5418, 2012-07-09 09:10:17
Python 2.7.3, qt version 4.8.0
Windows 5, 1, 2600, 2, Service Pack 3

#@+node:ekr.20130911110233.11283: *4*  what I did
@language rest

Added new_write master switch in leoAtFile.py.
When new_write is True:
- Leo no longer writes a temporary output file.
- at.replaceTargetFileIfDifferent calls the new at.create method to write the target file.
- onl simply writes '\n'.  Conversion to the desired newline happens only in at.create.

Important: writing utf-16 files appears to work, but reading utf-16 files
does not. There are problems decoding utf-16 string in at.readline.
Possibly reading the entire file and converting to unicode might work.

Added new_read master switch in leoAtFile.py.
When new_read is True:
- at.readFileToUnicode converts the entire input file to unicode
  with a single call to g.toUnicode.
- at.getLine uses ivars to retrieve the next line.
  (the theFile and fileName arguments to at.getLine are not used).
#@-all

# Put this @language after the @all as a kind of permanent unit test.

#@@language python # Override the default .txt coloring.

#@@pagewidth 60
#@-leo
