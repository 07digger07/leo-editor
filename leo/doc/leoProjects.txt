#@+leo-ver=5-thin
#@+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
#@+all
#@+node:ekr.20111103205308.9698: ** Unit tests
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)

s1 = '''
<table id="1"> <table id="2">
<contents/>
</table>
</table>
'''

s2 = '''
<table id="1"> 
<table id="2">
<contents/>
</table>
</table>
'''

t1 = 
assert result == expected,'expected...\n%s\ngot...\n%s' % (
    repr(expected),repr(result))
#@+node:ekr.20100907115157.5905: *3* @ignore Ancient tests
#@+node:ekr.20100208095423.5940: *4* @test leoCache
import leo.core.leoCache as leoCache

cacher = leoCache.cacher(c)

if 0:
    import os
    os.system('cls')

assert cacher.test()
#@+node:ekr.20100906165118.5915: *4* @test leoInkCommands
ic = c.inkscapeCommands
screenshot = r'c:\leo.repo\inkcall\some_screen_shot.png'
template_fn = r'c:\leo.repo\inkcall\template.svg'
png_fn = r'c:\leo.repo\inkcall\output.png'
svg_fn = r'c:\leo.repo\inkcall\temp.svg'
callouts = [
        "This goes here",
        "These are those, but slightly longer",
        "Then you pull this, but this text needs to be longer for testing",]
ic.run(
    screenshot,
    callouts=callouts,
    numbers=[2,4,17],
    edit_flag = True, # True: call inkscape to edit the working file.
    png_fn=png_fn, # Optional: Name of output png file.
    svg_fn=svg_fn, # Optional: Name of working svg file.
    template_fn=template_fn, # Optional: Name of template svg file.
)
#@+node:ekr.20111102123707.9629: *4* @ignore test of marked unit-test trees
#@+node:ekr.20111102123707.9630: *5* @test assert False
assert False
#@+node:ekr.20111102123707.9631: *5* @test assert True
assert True
#@+node:ekr.20111107092526.9799: *4* @test detection of external unit tests
# This test is redundant, and another test sets import_html_tags

# print('g.app.isExternalUnitTest',g.app.isExternalUnitTest)
if g.app.isExternalUnitTest:
    fn = c.shortFileName()
    assert fn.endswith('dynamicUnitTest.leo'),fn
    data = c.config.getData('import_html_tags')
    assert len(data) == 85 # length of data in leoSettings.leo.
else:
    data = c.config.getData('import_html_tags')
    assert len(data) == 85,len(data)
#@+node:ekr.20111107092526.9800: *5* doTests...
def doTests(c,all=None,marked=None,p=None,verbosity=1):

    trace = False ; verbose = False
    if all:
        p = c.rootPosition()
    elif not p:
        p = c.p
    p1 = c.p.copy() # 2011/10/31: always restore the selected position.
    
    g.trace(g.app.isExternalUnitTest)
    
    # This seems a bit risky when run in unitTest.leo.
    # c.save() # Eliminate the need for ctrl-s.
    
    if trace: g.trace('marked',marked,'c',c)

    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)

        # New in Leo 4.4.8: ignore everything in @ignore trees.
        last = None if all else p.nodeAfterTree()
        
        aList = findAllUnitTestNodes(c,p,last,all,marked,
            lookForMark=False,lookForNodes=True)
       
        found = False
        for p in aList:
            if isTestNode(p):
                if trace: g.trace('adding',p.h)
                test = makeTestCase(c,p)
            elif isSuiteNode(p): # @suite
                if trace: g.trace('adding',p.h)
                test = makeTestSuite(c,p)
            else:
                test = None
            if test:
                suite.addTest(test)
                found = True
        
        # Verbosity: 1: print just dots.
        if not found:
            # 2011/10/30: run the body of p as a unit test.
            test = makeTestCase(c,c.p)
            if test:
                suite.addTest(test)
                found = True
        if found:
            res = unittest.TextTestRunner(verbosity=verbosity).run(suite)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
                c.cacher.db[key] = archive
        else:
            g.es_print('no %s@test or @suite nodes in %s outline' % (
                g.choose(marked,'marked ',''),
                g.choose(all,'entire','selected')),color='red')
    finally:
        c.setChanged(changed) # Restore changed state.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.contractAllHeadlines()
            c.redraw(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20111107092526.9801: *6* class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20111107092526.9802: *7* __init__ (generalTestCase)
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@+node:ekr.20111107092526.9803: *7*  fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@+node:ekr.20111107092526.9804: *7* tearDown
def tearDown (self):

    pass

    # Restore the outline.
    self.c.outerUpdate()
#@+node:ekr.20111107092526.9805: *7* setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p.copy()) # 2010/02/03
#@+node:ekr.20111107092526.9806: *7* runTest (generalTestCase)
def runTest (self,define_g = True):

    trace = False
    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)
    
    if c.shortFileName() == 'dynamicUnitTest.leo':
        c.write_script_file = True

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p and p.copy(),'self':self,}
    else:
        d = {'self':self,}

    script = script + '\n'
    if trace: g.trace('p: %s c: %s write script: %s script:\n%s' % (
        p and p.h,c.shortFileName(),c.write_script_file,script))

    # Execute the script. Let the unit test handle any errors!
    # 2011/11/02: pass the script sources to exec or execfile.
    if c.write_script_file:
        scriptFile = c.writeScriptFile(script)
        if g.isPython3:
            exec(compile(script,scriptFile,'exec'),d)
        else:
            execfile(scriptFile,d)
    else:
        exec(script,d)
#@+node:ekr.20111107092526.9807: *7* shortDescription
def shortDescription (self):

    s = self.p.h

    # g.trace(s)

    return s + '\n'
#@+node:ekr.20111107092526.9808: *6* makeTestSuite (leoTest)
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()
    # g.trace('c.write_script_file',c.write_script_file)
    script = g.getScript(c,p).strip()
    if not script:
        print("no script in %s" % h)
        return None
    try:
        if 0: #debugging
            n,lines = 0,g.splitLines(script)
            for line in lines:
                print(n,line)
                n += 1
                
        # 2011/11/02: make script sources available.
        d = {'c':c,'g':g,'p':p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            if g.isPython3:
                exec(compile(script,scriptFile,'exec'),d)
            else:
                execfile(scriptFile,d)
        else:
            exec(script + '\n',d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("makeTestSuite: %s script did not set g.app.scriptDict" % p.h)
        return suite
    except Exception:
        print('makeTestSuite: exception creating test cases for %s' % p.h)
        g.es_exception()
        return None
#@+node:ekr.20111107092526.9809: *6* makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.b.strip():
        return generalTestCase(c,p)
    else:
        return None
#@+node:ekr.20111107092526.9810: *5* main & helpers (leoDynamicTest.py)
def main ():

    trace = False
    readSettings = True 
    tag = 'leoDynamicTests.leo'
    if trace: t1 = time.time()

    # Setting verbose=True prints messages that would be sent to the log pane.
    path,gui,silent = scanOptions()
    # print('(leoDynamicTest.py:main)','silent',silent)

    # Not loading plugins and not reading settings speeds things up considerably.
    bridge = leoBridge.controller(gui=gui,
        loadPlugins=False, # Must be False: plugins will fail when run externally.
        readSettings=True, # True adds about 0.3 seconds.  Is it useful?
        silent=True,
        verbose=False)

    if trace:
         t2 = time.time()
         print('%s open bridge:  %0.2fsec' % (tag,t2-t1))

    if bridge.isOpen():
        g = bridge.globals()
        g.app.silentMode = silent
        g.app.isExternalUnitTest = True
        path = g.os_path_finalize_join(g.app.loadDir,'..','test',path)
        c = bridge.openLeoFile(path)
        if trace:
            t3 = time.time()
            print('%s open file: %0.2fsec' % (tag,t3-t2))
        runUnitTests(c,g)
#@+node:ekr.20111107092526.9811: *6* runUnitTests
def runUnitTests (c,g):

    p = c.rootPosition()
    #g.es_print('running dynamic unit tests...')
    c.selectPosition(p)
    c.debugCommands.runAllUnitTestsLocally()
#@+node:ekr.20111107092526.9812: *6* scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('--path',dest='path')
    parser.add_option('--gui',dest="gui")
    parser.add_option('--silent',action="store_true",dest="silent")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)

    # -- path
    # We can't finalize the path here, because g does not exist ye.
    path = options.path or 'dynamicUnitTest.leo'

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('qttabs','qt'):
        gui = 'nullGui'

    # --silent
    silent = options.silent

    return path,gui,silent
#@+node:ekr.20111116161118.10248: *3* Recent tests
#@+node:ekr.20111104132424.9909: *4* @test assert True
# It's useful to have this do-nothing test.

assert True
#@+node:ekr.20111107092526.9819: *4* @test cls
g.cls() # Clear the screen
#@+node:ekr.20111110085739.10265: *4* @test html string
s = '''\
<HTML>
<head>
    <title>Bodystring</title>
</head>
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
</html>
'''

html_tags = ('body','head','html','table',) # 'div',
setting = 'import_html_tags'

# Settings now work when run externally.
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.app.unitTestDict ['expectedErrors'] = 0

showTree = True

c.importCommands.htmlUnitTest(p,s=s,showTree=showTree)

if showTree:
    # g.cls()
    for p in p.subtree():
        print('\n***** %s\n' %p.h)
        print(p.b)
#@+node:ekr.20120112100822.10003: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120112100822.10004: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120112100822.10005: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120112100822.10006: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120203153754.10033: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120203153754.10034: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120203153754.10035: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120203153754.10036: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120204061120.10061: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120204061120.10062: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120204061120.10063: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120204061120.10064: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20111109151106.9746: *4* @test htmlScanner.filterTokens
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)
strip = hs.stripTokens
dump  = hs.formatTokens

s1 = '''<table id="1"><table id="2">
<contents/>
</table>
</table>'''

s2 = '<table id="1"><table id="2"><contents/></table></table>'
    
t1 = hs.tokenize(s1)
t2 = hs.tokenize(s2)
f1 = hs.filterTokens(t1)
f2 = hs.filterTokens(t2)

assert strip(f1) == strip(f2),'f1...\n%s\nf2...\n%s' % (
    dump(f1),dump(f2))
    
if 0:
    print(dump(f1))
#@+node:ekr.20111110084957.10092: *4* @test import dataN.html
fn = r'c:\recent\data.html'

# fn = r'c:\recent\data-smaller.html'
# fn = r'c:\recent\data666.html'

# These all pass on data.html:
    # html_tags = ('html','head','body',)
    # html_tags = ('html','head','body','table',)
    # html_tags = ('html','head','body','table','div',)
    # html_tags = ('html','head','body','table','div','script',)
    # html_tags = ('html','head','body','table','div','script','link',)
    # html_tags = ('html','head','body','table','div','script','link','p',)

html_tags = ('html','head','body','table','div','script','p','td','tr',)

# Settings now work when run externally.
setting = 'import_html_tags'
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.cls()

c.importCommands.importFilesCommand(files=[fn], treeType='@file')
#@+node:ekr.20111109105907.9795: *4* @test unicode stuff
@first # -*- coding: utf-8 -*-

table = (
    'test',
    'Ä 궯 奠',
    'Ä 궯 奠 after', # fails with cp6501: after is duplicated.
)

print('*'*20)
print('isPython3: %s' % g.isPython3)

for s in table:
    if g.isPython3:
        s = s.encode('ascii','replace') # create bytes.
    g.es(repr(s))
    g.es(s)
    g.pr ('g.pr(s)       : %s' % s)
    g.pr ('g.pr(repr(s)) : %s' % repr(s))
    print('print(s)      : %s' % s)
    print('print(repr(s)): %s' % s)
#@+node:ekr.20111113064104.9841: *4* @test external text operations
assert g.app.isExternalUnitTest

body = c.frame.body
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl

w = body.bodyCtrl
w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111112131605.9789: *4* @test nullBody text operations
# print('isExternalUnitTest',g.app.isExternalUnitTest)

if g.app.isExternalUnitTest:
    body = c.frame.body
else:
    import leo.core.leoCommands as leoCommands
    import leo.core.leoFrame as leoFrame
    import leo.core.leoGui as leoGui
    
    # Important: external unit tests should execute in this environment.
    nullGui   = leoGui.nullGui('null gui')
    nullFrame = leoFrame.nullFrame(title='nullFrame title',gui=nullGui)
    c2 = leoCommands.Commands(nullFrame,fileName='<empty fileName>')
    nullFrame.c = c2
    body = leoFrame.nullBody(frame=nullFrame,parentFrame=None)
    assert repr(body).startswith('<leo.core.leoFrame.nullBody')

# Now test some basic operations.
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl
w = body.bodyCtrl

w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111115155710.9835: *4* @test g.python_tokenize
# h = 'g.python_tokenize'
# p = p.firstChild()
# assert p.h == h
tokens = g.python_tokenize(p.b,line_numbers=False)

# tokens = [(kind,val) for (kind,val,line_number) in tokens]

# First, the basic check
tokens1 = [val for kind,val in tokens]
s = ''.join(tokens1)
assert p.b == s,repr(s)

if 0:
    for z in tokens:
        kind,val = z
        print('%6s %s' % (kind,repr(val)))
        
# Next, start filtering.
tokens = [(kind,g.choose(kind=='string','"S"',val)) for kind,val in tokens]

if 0: # Delete whitespace.
    tokens = [(kind,val) for (kind,val) in tokens if kind != 'ws']
    tokens = [(kind,g.choose(kind=='id',val+' ',val)) for (kind,val) in tokens]

# Last: stringize.
tokens = [val for kind,val in tokens if kind != 'comment']
# print(''.join(tokens))

if 1: # Print lines containing '='
    s = ''.join(tokens)
    for ch in '()[]{}<>.,:=+-/':
        s = s.replace(' '+ch,ch)
    aList = [z for z in g.splitLines(s)
        if z.find('=') > -1] # and not z.find('+=')>-1 and not z.find('-=')>-1]
    print(''.join(aList))
    
#@+node:ekr.20111204110514.10287: *4* @test p.moveToFirst/LastChild
def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()

child = p.firstChild()
assert child
setup(child)
p2 = child.insertAfter()
p2.h = "test"
try:
    assert c.positionExists(p2),p2
    p2.moveToFirstChildOf(child)
    assert c.positionExists(p2),p2
    p2.moveToLastChildOf(child)
    assert c.positionExists(p2),p2
finally:
    if 1:
        setup(child)
    c.redraw(p)
#@+node:ekr.20111210100047.10306: *5* child
#@+node:ekr.20111116161118.10247: *3* Old lint tests
#@+node:ekr.20111116103733.9845: *4*  Naming tests
# http://docs.python.org/reference/executionmodel.html#naming-and-binding

if 0:
    def test():
        a = b
        b = 1 # UnboundLocalError
        
print('***')
          
def test():
    global g2
    g2 = 4
    def test2():
        print(g2)
    test2()
    g2 = 3
    print(g2)
    
g2 = 'g2'
print(g2)

test()
#@+node:ekr.20111116103733.9846: *5* << define s>>
s = '''



'''

s = g.adjustTripleString(s,-4)
#@+node:ekr.20111116103733.9839: *4* @test create lots of data structures
# A simple prototype of data-centric design.
# 0.023 sec to create 100,000 dicts.
# 0.230 sec to create 1,000,000 dicts.

import time

t1 = time.clock()
n = 1000000

d = {}
for z in range(n):
    d[n] = {'n':n,}

t2 = time.clock()
print('Created %s dicts in %2.3f sec.' % (n,t2-t1))
#@+node:ekr.20111116103733.9844: *4* @test dumper (to outNodes)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outNodes.txt'

outStream = open(out,'w')
u.AstDumper().dumpFileAsNodes(fn,outStream)
#@+node:ekr.20111116103733.9840: *4* @test dumper (to outString)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outString.txt'

outStream = open(out,'w')
u.AstDumper(brief=True).dumpFileAsString(fn,outStream)
#@+node:ekr.20111128103520.10237: *3* Tests of @shadow from unitTest.leo
#@+node:ekr.20111128103520.10238: *4* @@shadow ../test/unittest/at-shadow-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10239: *5* spam
def spam():
    pass
#@+node:ekr.20111128103520.10240: *5* eggs
def eggs():
    pass
#@+node:ekr.20111128103520.10241: *4* @@shadow unittest/at-shadow-line-number-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10242: *5* child
def child():
    pass
#@+node:ekr.20111128103520.10243: *4* @test @shadow: shape of tree
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow ../test/unittest/at-shadow-test.py'
    p = g.findNodeAnywhere(c,h)
    assert p
    
    table = (
        (p.firstChild(),'spam'),
        (p.firstChild().next(),'eggs')
    )
    
    assert not p.isDirty(),p.h # Do not ignore this failure!
    
    for p2,h2 in table:
        assert len(p2.h) == len(h2)
#@+node:ekr.20111128103520.10244: *4* @test goto-global-line @shadow
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow unittest/at-shadow-line-number-test.py'
    root1 = g.findNodeAnywhere(c,h)
    assert root1
    assert root1.isAnyAtFileNode()
    
    fileName,lines,n,root2 = c.goToLineNumber(c).setup_file(n=6,p=root1)
    assert fileName == h[8:],'fileName'
    assert root2 == root1
    
    if 0:
        print('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
            root and root.h,isRaw,n,len(lines)))
#@+node:ekr.20120116073928.10114: *3* Unit tests for settings
#@+node:ekr.20120126050844.10386: *4* @ignore print dicts unit tests
#@+node:ekr.20120117095916.10124: *5* @test printMenusList
def printMenusList(aList,level=0):
    
    for z in aList:
        a,b,c = z
        print('*** kind',a)
        if type(b) in (type(()),type([])):
            for z2 in b:
                a1,b1,c1 = z2
                if a1.startswith('@menu') and type(b1) in (type(()),type([])):
                    print()
                    print('*** inner menu: %s' % (level+1))
                    print(a1)
                    for z3 in b1:
                        print(z3)
                    if c1: print(c1)
                else:
                    print(z2)
            if c: print(c)
        else:
            print(b)
        print()
        break #
        
printMenusList(c.config.getMenusList())
       
#@+node:ekr.20120117095916.10140: *5* @test printInverseBindingDict
print('\ninverseBindingDict...\n')

d = c.k.computeInverseBindingDict()

for key in sorted(list(d.keys())):

    if 1 == len(d.get(key)):
        print(key,d.get(key))
    else:
        print()
        print(key)
        print(d.get(key))
        print()
#@+node:ekr.20120123113111.10925: *5* @test printBindingsDict
import leo.core.leoConfig as leoConfig # for ShortcutInfo
    
partial = True

d = c.k.bindingsDict
    # Keys are shortcuts; values are *lists* leoConfig.ShortcutInfo objects.
    
print('\nk.bindingsDict%s...\n' % ' (partial)' if partial else '')
    
for key in list(sorted(d.keys())):
    aList = d.get(key,[])
    for b in aList:
        assert isinstance(b,leoConfig.ShortcutInfo)
        if not partial or b.kind != 'leosettings.leo':
            print(b)
#@+node:ekr.20120117095916.10141: *5* @test printMasterBindingsDict
partial = True

panes = ('all','body','button','log','tree','text',
    'command','insert','overwrite',)

d = c.k.masterBindingsDict
    # Keys are scope names (in panes) or mode names.
    # Values are dicts:
        # keys are strokes; values are leoConfig.ShortcutInfo objects.
        
print('\nk.masterBindingsDict%s...\n' % ' (partial)' if partial else '')

for pane in sorted(list(d.keys())):
    kind = 'pane' if pane in panes else 'mode'
    print('%s: %s...' % (kind,pane))
    d2 = d.get(pane)
    for stroke in sorted(list(d2.keys())):
        b = d2.get(stroke)
        if not partial or b.kind != 'leosettings.leo':
            print('%6s %25s %17s %s' % (b.pane,stroke,b.kind,b.commandName))
            assert b.pane == pane
            assert b.stroke == stroke
    print()
#@+node:ekr.20120126080450.10187: *4* @ignore passed
#@+node:ekr.20120126080450.10189: *5* @test mode-related info
@

g.app.config.modeCommandsDict
    Keys are command names: enter-x-mode.
    Values are inner dictionaries:
        Keys are command names, values are lists of ShortcutInfo nodes.
@c

d = g.app.config.modeCommandsDict
    
for key in sorted(d.keys()):
    print('*** mode ***',key)
    d2 = d.get(key)
    for key2 in sorted(d2.keys()):
        aList = d2.get(key2)
        print(key2)
        for si in aList:
            print('   ',si)
#@+node:ekr.20120120095156.10262: *5* @test types of contents of settings dicts
@
ivar                    Keys                Values
----                    ----                ------
c.commandsDict          command names (1)   functions
k.inverseCommandsDict   func.__name__       command names
k.bindingsDict          shortcuts           list of ShortcutInfo objects
k.masterBindingsDict    scope names (2)     inner masterBindingDicts (3)
k.masterGuiBindingsDict strokes             list of widgets in which stoke is bound
k.settingsNameDict (4)  settings.lower()    "Real" Tk specifiers
inverseBindingDict (5)  command names       lists of tuples (pane,key)
modeCommandsDict (6)    command name (7)    inner modeCommandsDicts (8)

Notes:
(1) Command names are minibuffer names (strings)
(2) Scope names are 'all','text',etc.
(3) inner masterBindingDicts: Keys are strokes; values are ShortcutInfo objects.
(4) k.settingsNameDict has no inverse.
(5) inverseBindingDict is **not** an ivar: it is computed by k.computeInverseBindingDict.
(6) A global dict: g.app.gui.modeCommandsDict
(7) enter-x-command
(8) Keys are command names, values are lists of ShortcutInfo objects.
@c

si_type = c.k.ShortcutInfo
disabled_func_type = None # Should be any bound method.
k = c.k

@others

test_dict_of_objects(c.commandsDict,type('s'),disabled_func_type,'commandsDict')
test_dict_of_objects(k.inverseCommandsDict,type('s'),type('s'),'inverseCommandsDict')
test_dict_of_lists(k.bindingsDict,si_type,'bindingsDict')
test_dict_of_dicts(k.masterBindingsDict,si_type,'masterBindingsDict')
test_dict_of_lists(k.masterGuiBindingsDict,None,'masterGuiBindingsDict')
test_dict_of_objects(k.settingsNameDict,type('s'),type('s'),'settingsNameDict')
test_dict_of_lists(k.computeInverseBindingDict(),type(tuple()),'inverseBindingDict')

# Test individual dicts separately.
d = g.app.config.modeCommandsDict
test_dict_of_dicts(d,None,'modeCommandsDict')
for key in sorted(d.keys()):
    d2 = d.get(key)
    test_dict_of_lists(d2,si_type,'inner modeCommandsDict')
        # This requires a hack to special-case the
        # '*entry-commands*' and '*command-prompt*' keys.
#@+node:ekr.20120126080450.10193: *6* test_dict_of_dicts
def test_dict_of_dicts(d,theType,tag):

    assert d,tag

    for key in d.keys():
        d2 = d.get(key)
        assert type(d2) == type({})
        for key in d2.keys():
            obj = d2.get(key)
            if theType:
                assert type(obj) == theType,repr(obj)
#@+node:ekr.20120126080450.10191: *6* test_dict_of_lists
def test_dict_of_lists(d,theType,tag):

    assert d,tag

    for key in d.keys():
        obj = d.get(key)
        if key in ('*entry-commands*','*command-prompt*'):
            # Special case for g.app.config.modeCommandsDict
            assert type(obj)==type([]),repr(obj)
        else:
            assert type(obj) == type([])
            # Don't check types of list elements if theType is None.
            if theType:
                for z in obj:
                    assert type(z)==theType,'key: %s obj: %s' % (key,repr(obj))
#@+node:ekr.20120126080450.10195: *6* test_dict_of_objects
def test_dict_of_objects(d,keyType,valueType,tag):

    assert d,tag

    for key in d.keys():
        assert type(key) == keyType,repr(key)
        obj = d.get(key)
        # Don't check type of obj if valueType is None.
        if valueType:
            assert type(obj) == valueType,'\nobj: %s\nvalueType: %s' % (repr(obj),valueType)
#@+node:ekr.20120126080450.10194: *6* Unused
# import types
# types.ListType does not exist in Python 3.x.
# assert isinstance(aList,list().__class__)
#@+node:ekr.20120127084215.10238: *5* @test merge_settings_dicts
@others

# import os ; os.system('cls')
    
d1 = g.app.config.immutable_leo_settings_shortcuts_dict
d2 = g.app.config.immutable_my_leo_settings_shortcuts_dict
d3 = g.app.config.merge_settings_dicts(d1,d2)

if False:
    patterns = (
        'backward-find-character-extend-selection',
    )
    for pattern in patterns:
        print(dump_dict(d1,pattern,tag='d1'))
        print(dump_dict(d2,pattern,tag='d2'))
        print(dump_dict(d3,pattern,tag='d3'))

test(d1,d2,d3)
#@+node:ekr.20120127145909.10227: *6* dump & dump_dict (@test merge_settings_dicts)
def dump(aList,pattern=None,tag=None):
    
    return '\n'.join([repr(z) for z in aList])
    

def dump_dict(d,pattern=None,tag=None):
    
    result = [] # '\ndump of %s...' % (tag)
    
    for key in d.keys():
        if pattern in (key,None):
            result.append(key)
            aList = d.get(key)
            for z in aList:
                result.append('    %s' % (z))
                
    return '\n'.join(result)
#@+node:ekr.20120127084215.10239: *6* test (@test merge_settings_dicts)
def test(old_d,new_d,result_d):
    
    '''Test that result_d is the result of upating old_d with new_d.
    
    This test is tricky: only inverted dicts have ShortcutInfo nodes as keys.'''
    
    invert,uninvert = g.app.config.invert,g.app.config.uninvert

    # Compute the inversions of all the dicts.
    inv_old,inv_new,inv_res = invert(old_d),invert(new_d),invert(result_d)
    
    # Part 1: Ensure we test all keys.
    keys = list(inv_old.keys())
    keys.extend(list(inv_new.keys()))
    keys.extend(list(inv_res.keys()))
    keys = sorted(list(set(keys)))
    assert None not in keys
    for key in inv_old.keys(): assert key in keys,key
    for key in inv_new.keys(): assert key in keys,key
    for key in inv_res.keys(): assert key in keys,key
    
    # Part 2: Carefully test the inverted result.
    def si_name_key(si): return si.commandName or ''

    for key in keys:
        # Compute the *sorted* list of 
        res_list = sorted(inv_res.get(key,[]),key=si_name_key)
        old_list = sorted(inv_old.get(key,[]),key=si_name_key)
        new_list = sorted(inv_new.get(key,[]),key=si_name_key)
        assert res_list,'no res_list.get(%s)' % (key)
        # if new_list: print(key,dump(new_list))
        if new_list:
            assert new_list == res_list,'key %s\nnew:\n%s\nres:\n%s' % (
                key,dump(new_list),dump(res_list))
        else:
            assert old_list == res_list,'key %s\nold:\n%s\nres:\n%s' % (
                key,dump(old_list),dump(res_list))
    
    # Part 3: Test that result_d == uninvert(invert(result_d)).
    # A.  They must have the same keys.
    unv_res = uninvert(inv_res)
    assert sorted(list(result_d.keys())) == sorted(list(unv_res.keys()))

    # B. The values of for each key must match after being sorted.
    def si_stroke_key(si): return si.stroke or ''
        
    for key in sorted(result_d.keys()):
        res_list = sorted(result_d.get(key,[]),key=si_stroke_key)
        unv_list = sorted( unv_res.get(key,[]),key=si_stroke_key)
        assert res_list == unv_list,'key %s\nres:\n%s\nunv:\n%s' % (
            key,dump(res_list),dump(unv_list))
   
#@+node:ekr.20120203153754.10032: *5* @test KeyStroke
ks = c.k.KeyStroke

@others

a1 = ks('a')
a2 = ks('a')
b1 = ks('b')
assert a1 == a2
d = {}
d[a1] = a1.s
d[a2] = a2.s
d[b1] = b1.s

for key in sorted(d):
    print(key,d.get(key))
#@+node:ekr.20120205022040.17748: *5* @test g.TypedDict
d = g.TypedDictOfLists('ks',type('s'),type(9))
d.add('a',1)
d.add('a',2)
d.add('b',3)

print(d)
for s in sorted(d.keys()):
    print(s,d.get(s,[]))

print('after replace...')
d.replace('a',[8,9,10])

for s in sorted(d.keys()):
    print(s,d.get(s,[]))
#@+node:ekr.20120215062153.14233: *3* @mark-for-unit-tests
#@+node:ekr.20080412053100.5: *4* @settings
#@+node:ekr.20080412053100.4: *5* @bool fixedWindow = False
#@+node:ekr.20100902154544.5872: *5* @bool enable-abbreviations = True
#@+node:ekr.20111123042248.12701: *5* @@@enabled-plugins
# Leo loads plugins in the order they appear here.

# Highly-recommended plugins:

plugins_menu.py
free_layout.py # needs to be early
viewrendered.py
mod_scripting.py
bigdash.py
#@+node:ekr.20111031081007.9985: *5* @shortcuts
run-selected-unit-tests-externally = Alt-4 # Standard binding, unchanged.
run-marked-unit-tests-externally = Alt-5
run-marked-unit-tests-locally = Alt-6
#@+node:ekr.20120329072206.9700: ** 4.10
#@+node:ekr.20120322073519.10401: *3* b1
#@+node:ekr.20120318110848.9734: *4* Added import-org-mode script
#@+node:ekr.20120318110848.9735: *5* import-org-mode (command, not used)
class ImportOrgMode:
    @others

def importOrgMode (self,event):
    c = self.c
    self.ImportOrgMode(c).go(c.p)
    c.bodyWantsFocus()

if False and g.app.inScript:
    print('='*40)
    ImportOrgMode(c).test()
    print('done')
#@+node:ekr.20120318110848.9736: *6* ctor
def __init__ (self,c):
    
    self.c = c
#@+node:ekr.20120318110848.9737: *6* go
def go (self,p):
    
    '''Prompt for a file and pass the contents to scan().'''
#@+node:ekr.20120318110848.9738: *6* scan
def scan (self,fn,p,s):

    self.c = c
    root = p.insertAsLastChild()
    root.h = fn
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        g.trace(repr(s))
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1
                level += 1
            if level > len(stack):
                g.trace('bad level',repr(s))
                last = None
            elif level == len(stack):
                last = stack[-1]
                last.b = ''.join(body)
            else:
                last = stack[-1]
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            p = parent.insertAsLastChild()
            p.h = s.strip()
            stack.append(p)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        parent = stack[-1]
        parent.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
#@+node:ekr.20120318110848.9739: *6* test
def test (self):
    
    s = '''
* A1
    a1.1
    a1.2
** B11
** B12
b12.1
*** C121
c121.1
    c121.2
c121.3
* A2
a2.1
** B21
*** C211
c211.1
*** C212
** B22
    b22.1
b22.1
* A3
* A4
a4.1
* A5
** B51
*** C511
**** D5111
***** E51111
** B52
*** C521
c521.1
'''

    tag = 'test-import-org-mode'
    p = g.findNodeAnywhere(c,tag)
    s = g.adjustTripleString(s,-4)
    if p:
        try:
            self.scan('test-file',p,s)
        except Exception:
            c.redraw(p)
    else:
        print('not found: %s' % tag)
#@+node:ekr.20120318110848.9740: *5* @@button import-org-mode
'''Import each file in the files list after the presently selected node.'''


files = (
    r'c:\Users\edreamleo\test\import-org-mode.txt',
    r'c:\Users\edreamleo\test\import-org-mode.txt',
)

@others

for fn in files:
    try:
        root = c.p.copy()
        f = open(fn)
        s = f.read()
        scan(c,fn,s)
        c.selectPosition(root)
    except IOError:
        print('can not open %s' % fn)
#@+node:ekr.20120318110848.9741: *6* scan
def scan (c,fn,s):

    last = root = c.p.insertAsLastChild()
    last.h = g.shortFileName(fn)
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1 ; level += 1
            if level > len(stack):
                g.trace('bad level',repr(s))
            elif level == len(stack):
                last.b = ''.join(body)
            else:
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            last = parent.insertAsLastChild()
            last.h = s.strip()
            stack.append(last)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        last.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
#@+node:ekr.20120318110848.9742: *5* test-import-org-mode
#@+node:ekr.20120318110848.9747: *4* Code for displaying a function call hierarchy in Leo
From Brian Theado

The other day I stumbled across Ville's code in scripts.leo which displays the
output of python's trace module in a leo outline. The output of the trace module
is not very friendly and I didn't find the result very usable. I was inspired to
write some code to translate the output so the tree of function calls is
displayed via Leo headlines. Thanks to Ville for sharing that code. I never
would have figure this out without that starting point.

Just copy (Ctrl-Shift-V) the child outline into a leo outline and hit ctrl-b on
the "call tree" node. The execution tree of the 'scroll-outline-up-line'
minibuffer command will be displayed to stdout and also as a tree of leo
headlines.
#@+node:ekr.20120318110848.9748: *5* call tree
import trace

@language python
@others

# http://docs.python.org/library/trace.html for documentation
# on the trace module
tracer = trace.Trace(countcallers=1)

# Trace a minibuffer command.

# Any function call will work. Leo's minibuffer commands are easily discoverable
# via tab completion and the 'print-commands' command.

#tracer.runfunc(c.executeMinibufferCommand, 'goto-prev-node')
tracer.runfunc(c.executeMinibufferCommand, 'scroll-outline-up-line')

top = p.insertAsLastChild().copy()
top.h = 'trace session'
displayCalltree(top, tracer.results().callers.keys())
c.redraw()
#@+node:ekr.20120318110848.9749: *6* displayCalltree
def displayCalltree(p, callinfo):
   '''
   Converts the function call hierarchy in 'callinfo' into a tree of function
   calls.  The function call tree is displayed to stdout as indented text
   and is inserted as a tree of leo nodes rooted at the given position 'p'
   '''
   callers = [k[0] for k in callinfo]
   callees = [k[1] for k in callinfo]

   # The first set of children will be those that don't have any callers
   # listed in callinfo
   toplevels = list(set(callers) - set(callees))
   positions = {}
   path = []

   # Depth-first traversal of the call hierarchy represented by 'callinfo'
   # 'levels' is a stack which grows during descend and shrinks
   # during ascend.  Each element of 'levels' is a list of unprocessed
   # siblings of each other
   levels = [toplevels]
   while len(levels) > 0:
       while len(levels[-1]) > 0:
           # Process the first element in the 'deepest' (i.e. last) list of siblings
           cur = levels[-1][0]
           levels[-1] = levels[-1][1:]
           indent = " " * 4 * (len(levels)-1)
           if cur not in path:
               if cur in positions.keys():
                   # Function already seen, so make a clone
                   clone = positions[cur].clone()
                   clone.moveToLastChildOf(p)
                   print (indent + "%s %s ..." % cur[1:])
               else:
                   # Haven't seen this function, so insert a new headline
                   p = p.insertAsLastChild().copy()
                   p.h = "%s %s" % cur[1:]
                   print (indent + p.h)

                   # Remember the position so it can be cloned if seen again
                   positions[cur] = p

                   # Find all callees of this function and descend
                   levels.append([c[1] for c in callinfo if c[0] == cur])
                   path.append(cur)
           else:
               r = p.insertAsLastChild().copy()
               r.h = "(recursive call) %s %s" % (cur[1], cur[2])
               print(indent + r.h + "...")

       # Ascend back up one level
       path = path[0:-1]
       p = p.parent()
       levels = levels[0:-1]
#@+node:ekr.20120318110848.9750: *6* trace session
#@+node:ekr.20120314064059.9737: *4* Use ctrl-click to open url's
- (Done) Added the following commands:
    
    - ctrl-click-icon
    - ctrl-click-at-cursor
    - open-url
    - open-url-under-cursor
    
- (Done) Double-click *only* edits headline.
- (Done) Only look at first line of the body in @url nodes.
- (Done) Ctrl-click in body allows spaces in url's.

#@+node:ekr.20120322073519.10402: *3* final
#@+node:ekr.20120327163022.9737: *4* Bugs
#@+node:ekr.20120322073519.9785: *5* Fixed crasher in flattenOutline
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 553, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 2120, in flattenOutline
    c.importCommands.flattenOutline(fileName)
  File "c:\leo.repo\trunk\leo\core\leoImport.py", line 479, in flattenOutline
    theFile.write(s)
TypeError: must be str, not bytes
#@+node:ekr.20031218072017.1147: *6* ic.flattenOutline
def flattenOutline (self,fileName):

    c = self.c ; nl = g.u(self.output_newline)
    p = c.currentVnode()
    if not p: return
    self.setEncoding()
    firstLevel = p.level()

    try:
        theFile = open(fileName,'wb')
            # Fix crasher: open in 'wb' mode.
    except IOError:
        g.es("can not open",fileName,color="blue")
        c.testManager.fail()
        return

    for p in p.self_and_subtree():
        head = p.moreHead(firstLevel)
        s = head + nl
        if g.isPython3:
            s = g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
        theFile.write(s)
        body = p.moreBody() # Inserts escapes.
        if len(body) > 0:
            s = g.toEncodedString(body + nl,self.encoding,reportErrors=True)
            theFile.write(s)
    theFile.close()
#@+node:ekr.20120323110755.9687: *5* Fix viewrendered crash
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoPlugins.py", line 337, in callTagHandler
    result = handler(tag,keywords)
  File "c:\leo.repo\trunk\leo\plugins\viewrendered.py", line 560, in update
    f(s,keywords)
  File "c:\leo.repo\trunk\leo\plugins\viewrendered.py", line 655, in update_graphics_script
    pc.gs = QtGui.QGraphicsScene(pc.splitter)
AttributeError: 'ViewRenderedController' object has no attribute 'splitter'
#@+node:ekr.20120323124339.9722: *5* Fixed(mostly)scrolling problem with multiple editors
@language python
@language rest
Selecting body editor with clicks doesn't save/restore visual ivars.
The solution would be to create a new onClick event handler...
#@+node:ekr.20120212060348.10374: *6*  << global switches >>
trace_startup = False
    # These traces use print instead of g.trace so that
    # the traces can add class info the method name.

new_modes = False
    # True: use ModeController and ModeInfo classes.
if new_modes: print('***** new_modes')

new_keys = False
    # This project hardly seems urgent.
    # True: Qt input methods produce a **user setting**, not a stroke.
if new_keys: print('***** new_keys')

# Debugging options...

enableDB = True
    # Don't even think about eliminating this constant:
    # it is needed for debugging.

no_scroll = False
    # True: disable all calls to w.setYScrollPosition.
no_see = False
    # True: disable all calls to w.see and w.seeInsertPoint.
    
# Tracing options...

trace_scroll = False
    # Trace calls to get/setYScrollPosition
trace_see = False
    # Trace calls to see and setInsertPoint.

# Switches to trace the garbage collector.
trace_gc = False           
trace_gc_calls = False    
trace_gc_calls = False 
trace_gc_verbose = False
trace_gc_inited = False

trace_masterCommand = False
trace_masterKeyHandler = False
trace_masterKeyHandlerGC = False
trace_minibuffer = False
trace_modes = False

# These print statements have been moved to writeWaitingLog.
# This allows for better --silent operation.
if 0:
    print('*** isPython3: %s' % isPython3)
    if not enableDB:
        print('** leoGlobals.py: caching disabled')

#@+node:ekr.20120324124808.9839: *6* Not changed
#@+node:ekr.20060528170438: *7* cycleEditorFocus (leoBody)
def cycleEditorFocus (self,event=None):

    '''Cycle keyboard focus between the body text editors.'''

    trace = False and not g.unitTesting
    c = self.c ; d = self.editorWidgets
    w = c.frame.body.bodyCtrl
    values = list(d.values())
    if len(values) > 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = list(d.values())[i]
        assert(w!=w2)
        self.selectEditor(w2)
        c.frame.body.bodyCtrl = w2
#@+node:ekr.20110605121601.18223: *7* Event handlers (qtBody)
#@+node:ekr.20110930174206.15472: *8* onFocusIn (qtBody)
def onFocusIn (self,obj):

    '''Handle a focus-in event in the body pane.'''

    trace = False and not g.unitTesting
    c = self.c
    
    if trace: g.trace(str(obj.objectName()))

    # 2010/08/01: Update the history only on focus in events.
    # 2011/04/02: Update history only in leoframe.tree.select.
    # c.nodeHistory.update(c.p)
    
    if obj.objectName() == 'richTextEdit':
        wrapper = hasattr(obj,'leo_wrapper') and obj.leo_wrapper
        if wrapper and wrapper != self.bodyCtrl:
            self.selectEditor(wrapper)
        self.onFocusColorHelper('focus-in',obj)
        obj.setReadOnly(False)
        obj.setFocus() # Weird, but apparently necessary.
#@+node:ekr.20110930174206.15473: *8* onFocusOut (qtBody)
def onFocusOut (self,obj):

    '''Handle a focus-out event in the body pane.'''
    
    trace = False and not g.unitTesting

    if trace: g.trace(str(obj.objectName()))
    
    # Apparently benign.
    if obj.objectName() == 'richTextEdit':
        self.onFocusColorHelper('focus-out',obj)
        obj.setReadOnly(True)
    
#@+node:ekr.20110605121601.18224: *8* onFocusColorHelper (qtBody)
badFocusColors = []

def onFocusColorHelper(self,kind,obj):

    trace = False and not g.unitTesting
    
    c = self.c ; w = c.frame.body.bodyCtrl
    
    if trace: g.trace(kind)
    
    if kind == 'focus-in':
        # if trace: g.trace('%9s' % (kind),'calling c.k.showStateColors()')
        c.k.showStateColors(inOutline=False,w=self.widget)
    else:
        bg = self.unselectedBackgroundColor
        fg = self.unselectedForegroundColor
        c.frame.body.setEditorColors(bg,fg)

    w.widget.ensureCursorVisible()
        # 2011/10/02: Fix cursor-movement bug.
#@+node:ekr.20111002125540.7021: *7* get/setYScrollPosition (LeoQTextBrowser)
def getYScrollPosition(self):
    
    trace = False and g.trace_scroll and not g.unitTesting

    w = self
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    if trace: g.trace(pos)
    return pos

def setYScrollPosition(self,pos):
    
    trace = g.trace_scroll and not g.unitTesting
    w = self

    if g.no_scroll:
        return
    elif pos is None:
        if trace: g.trace('None')
    else:
        if trace: g.trace(pos,g.callers())
        sb = w.verticalScrollBar()
        sb.setSliderPosition(pos)
#@+node:ekr.20031218072017.4037: *7* setSelectionAreas (leoBody)
def setSelectionAreas (self,before,sel,after):

    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    body = self ; w = body.bodyCtrl
    
    # 2012/02/05: save/restore Yscroll position.
    pos = w.getYScrollPosition()
    s = w.getAllText()
    before = before or ''
    sel = sel or ''
    after = after or ''
    w.delete(0,len(s))
    w.insert(0,before+sel+after)
    i = len(before)
    j = max(i,len(before)+len(sel)-1)
    # g.trace(i,j,repr(sel))
    w.setSelectionRange(i,j,insert=j)
    w.setYScrollPosition(pos)
    return i,j
#@+node:ekr.20110605121601.18098: *7* setYScrollPosition (leoQTextEditWidget)
def setYScrollPosition(self,pos):
    
    trace = False and g.trace_scroll and not g.unitTesting
    w = self.widget
    
    if g.no_scroll:
        return
    elif pos is None:
        if trace: g.trace('None')
    else:
        if trace: g.trace(pos,g.callers())
        sb = w.verticalScrollBar()
        sb.setSliderPosition(pos)
#@+node:ekr.20031218072017.3344: *7* v.__init
# To support ZODB, the code must set v._p_changed = 1 whenever
# v.unknownAttributes or any mutable vnode object changes.

def __init__ (self,context):

    # The primary data: headline and body text.
    self._headString = g.u('newHeadline')
    self._bodyString = g.u('')

    # Structure data...
    self.children = [] # Ordered list of all children of this node.
    self.parents = [] # Unordered list of all parents of this node.

    # Other essential data...
    self.fileIndex = g.app.nodeIndices.getNewIndex()
        # The immutable file index for this vnode.
        # New in Leo 4.6 b2: allocate gnx (fileIndex) immediately.
    self.iconVal = 0 # The present value of the node's icon.
    self.statusBits = 0 # status bits

    # v.t no longer exists.  All code must now be aware of the one-node world.
    # self.t = self # For compatibility with scripts and plugins.

    # Information that is never written to any file...
    self.context = context # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.insertSpot = None # Location of previous insert point.
    self.scrollBarSpot = None # Previous value of scrollbar position.
    self.selectionLength = 0 # The length of the selected body text.
    self.selectionStart = 0 # The start of the selected body text.
#@+node:ekr.20100303074003.5638: *7* v.saveCursorAndScroll
def saveCursorAndScroll(self,w):
    
    trace = (False or g.trace_scroll) and not g.unitTesting

    v = self
    if not w: return
    
    try:
        v.scrollBarSpot = w.getYScrollPosition()
        v.insertSpot = w.getInsertPoint()
        if trace: g.trace(v.scrollBarSpot,v.insertSpot)
    except AttributeError:
        # 2011/03/21: w may not support the high-level interface.
        pass
#@+node:ekr.20120324124808.9835: *6* Changed
@language python
@language rest

- Removed insert=None,new_p=None args from all versions of setAllText.
  These are entirely misguided, and may have contributed to scrolling problems.
  
  setAllText now *only* sets text, nothing else!

- All calls to leoMoveCursorHelper are follwed by code that updates
  v.insertSpot, v.selectionStart and v.selectionLength.
  
- v.restoreCursorAndScroll now *carefully* restores selection
  based on v.insertSpot, v.selectionStart and v.selectionLength.
  It also restores the scrollbar using v.scrollBarSpot.
  
- < < unselect the old node > > (selectHelper) now *only*
  sets v.scrollBarSpot.
  
#@+node:ekr.20050920084036.136: *7* exchangePointMark
def exchangePointMark (self,event):

    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''

    trace = False and not g.unitTesting
    c = self.c
    w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind='exchange',extend=False)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange(sort=False)
        if i == j: return

        ins = w.getInsertPoint()
        ins = g.choose(ins==i,j,i)
        w.setInsertPoint(ins)
        w.setSelectionRange(i,j,insert=None)
#@+node:ekr.20090530181848.6035: *7* movePageHelper
def movePageHelper(self,event,kind,extend): # kind in back/forward.

    '''Move the cursor up/down one page, possibly extending the selection.'''

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    linesPerPage = 15 # To do.

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(
            kind=g.choose(kind=='forward','page-down','page-up'),
            extend=extend,linesPerPage=linesPerPage)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        ins = w.getInsertPoint()
        s = w.getAllText()
        lines = g.splitLines(s)
        row,col = g.convertPythonIndexToRowCol(s,ins)
        row2 = g.choose(kind=='back',
            max(0,row-linesPerPage),
            min(row+linesPerPage,len(lines)-1))
        if row == row2: return
        spot = g.convertRowColToPythonIndex(s,row2,col,lines=lines)
        if trace: g.trace('spot',spot,'row2',row2)
        self.extendHelper(w,extend,spot,upOrDown=True)
#@+node:ekr.20100109094541.6227: *7* moveToBufferHelper
def moveToBufferHelper (self,event,spot,extend):

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        if spot == 'home':
            self.moveToHelper(event,0,extend=extend)
        elif spot == 'end':
            s = w.getAllText()
            self.moveToHelper(event,len(s),extend=extend)
        else:
            g.trace('can not happen: bad spot',spot)
#@+node:ekr.20100109094541.6228: *7* moveToCharacterHelper
def moveToCharacterHelper (self,event,spot,extend):

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        i = w.getInsertPoint()
        if spot == 'left':
            i=max(0,i-1)
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'right':
            i = min(i+1,len(w.getAllText()))
            self.moveToHelper(event,i,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@+node:ekr.20060113105246.1: *7* moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=direction,extend=extend)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        # Find the start of the next/prev line.
        row,col = g.convertPythonIndexToRowCol(s,ins)
        if trace:
            gui_ins = w.toGuiIndex(ins)
            bbox = w.bbox(gui_ins)
            if bbox:
                x,y,width,height = bbox
                # bbox: x,y,width,height;  dlineinfo: x,y,width,height,offset
                g.trace('gui_ins',gui_ins,'dlineinfo',w.dlineinfo(gui_ins),'bbox',bbox)
                g.trace('ins',ins,'row',row,'col',col,
                    'event.x',event and event.x,'event.y',event and event.y)
                g.trace('subtracting line height',w.index('@%s,%s' % (x,y-height)))
                g.trace('adding      line height',w.index('@%s,%s' % (x,y+height)))
        i,j = g.getLine(s,ins)
        if direction == 'down':
            i2,j2 = g.getLine(s,j)
        else:
            i2,j2 = g.getLine(s,i-1)

        # The spot is the start of the line plus the column index.
        n = max(0,j2-i2-1) # The length of the new line.
        col2 = min(col,n)
        spot = i2 + col2
        if trace: g.trace('spot',spot,'n',n,'col',col,'line',repr(s[i2:j2]))

        self.extendHelper(w,extend,spot,upOrDown=True)
#@+node:ekr.20100109094541.6231: *7* moveWithinLineHelper
def moveWithinLineHelper (self,event,spot,extend):

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    # g.trace(hasattr(w,'leoMoveCursorHelper'))
    
    # Bug fix: 2012/02/28: don't use the Qt end-line logic:
    # it apparently does not work for wrapped lines.
    if hasattr(w,'leoMoveCursorHelper') and spot != 'end-line':
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i,j = g.getLine(s,ins)
        if spot == 'start-line':
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'end-line':
            # Bug fix: 2011/11/13: Significant in external tests.
            if g.match(s,j-1,'\n'): j -= 1
            self.moveToHelper(event,j,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@+node:ekr.20110605121601.18077: *7* leoMoveCursorHelper & helper (leoQTextEditWidget)
def leoMoveCursorHelper (self,kind,extend=False,linesPerPage=15):

    '''Move the cursor in a QTextEdit.'''

    trace = False and not g.unitTesting
    verbose = True
    w = self.widget
    if trace:
        g.trace(kind,'extend',extend)
        if verbose:
            g.trace(len(w.toPlainText()))

    tc = QtGui.QTextCursor
    d = {
        'exchange': True, # Dummy.
        'down':tc.Down,'end':tc.End,'end-line':tc.EndOfLine,
        'home':tc.Start,'left':tc.Left,'page-down':tc.Down,
        'page-up':tc.Up,'right':tc.Right,'start-line':tc.StartOfLine,
        'up':tc.Up,
    }
    kind = kind.lower()
    op = d.get(kind)
    mode = g.choose(extend,tc.KeepAnchor,tc.MoveAnchor)

    if not op:
        return g.trace('can not happen: bad kind: %s' % kind)

    if kind in ('page-down','page-up'):
        self.pageUpDown(op, mode)
    elif kind == 'exchange': # exchange-point-and-mark
        cursor = w.textCursor()
        anchor = cursor.anchor()
        pos = cursor.position()
        cursor.setPosition(pos,tc.MoveAnchor)
        cursor.setPosition(anchor,tc.KeepAnchor)
        w.setTextCursor(cursor)
    else:
        if not extend:
            # Fix an annoyance. Make sure to clear the selection.
            cursor = w.textCursor()
            cursor.clearSelection()
            w.setTextCursor(cursor)
        w.moveCursor(op,mode)
        
    # 2012/03/25.  Add this common code.
    self.seeInsertPoint()
    self.rememberSelectionAndScroll()
    self.c.frame.updateStatusLine()
#@+node:btheado.20120129145543.8180: *8* pageUpDown
def pageUpDown (self, op, moveMode):

    '''The QTextEdit PageUp/PageDown functionality seems to be "baked-in"
       and not externally accessible.  Since Leo has its own keyhandling
       functionality, this code emulates the QTextEdit paging.  This is
       a straight port of the C++ code found in the pageUpDown method
       of gui/widgets/qtextedit.cpp'''

    control = self.widget
    cursor = control.textCursor()
    moved = False
    lastY = control.cursorRect(cursor).top()
    distance = 0
    # move using movePosition to keep the cursor's x
    while True:
        y = control.cursorRect(cursor).top()
        distance += abs(y - lastY)
        lastY = y
        moved = cursor.movePosition(op, moveMode)
        if (not moved or distance >= control.height()):
            break
    tc = QtGui.QTextCursor
    sb = control.verticalScrollBar()
    if moved:
        if (op == tc.Up):
            cursor.movePosition(tc.Down, moveMode)
            sb.triggerAction(QtGui.QAbstractSlider.SliderPageStepSub)
        else:
            cursor.movePosition(tc.Up, moveMode)
            sb.triggerAction(QtGui.QAbstractSlider.SliderPageStepAdd)
    control.setTextCursor(cursor)
#@+node:ekr.20110605121601.18209: *7* deactivateEditors (qtBody)
def deactivateEditors(self,wrapper):

    '''Deactivate all editors except wrapper's editor.'''

    trace = False and not g.unitTesting
    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        wrapper2 = d.get(key)
        w2 = wrapper2.widget
        if hasattr(w2,'leo_active'):
            active = w2.leo_active
        else:
            active = True
        if wrapper2 != wrapper and active:
            w2.leo_active = False
            self.unselectLabel(wrapper2)
            if trace: g.trace(w2)
            self.onFocusOut(w2)
#@+node:ekr.20120325032957.9730: *7* rememberSelectionAndScroll (leoQtBaseTextWidget)
def rememberSelectionAndScroll(self):

    trace = (False or g.trace_scroll) and not g.unitTesting

    w = self
    v = self.c.p.v # Always accurate.
    v.insertSpot = ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    if i > j: i,j = j,i
    assert(i<=j)
    v.selectionStart = i
    v.selectionLength = j-i
    v.scrollBarSpot = spot = w.getYScrollPosition()
    
    if trace: g.trace(id(v),id(w),i,j,ins,spot,v.h)
#@+node:ekr.20110605121601.18044: *7* selectAllText (leoQtBaseTextWidget)
def selectAllText(self,insert=None):

    w = self.widget
    w.selectAll()
    # if insert is not None:
        # self.setInsertPoint(insert)
    # Bug fix: 2012/03/25.
    self.setSelectionRange(0,'end',insert=insert)
   
#@+node:ekr.20110605121601.18203: *7* selectEditorHelper (qtBody)
def selectEditorHelper (self,wrapper):

    trace = False and not g.unitTesting
    c = self.c ; cc = c.chapterController
    d = self.editorWidgets
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    w = wrapper.widget
    assert isinstance(w,QtGui.QTextEdit),w

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    # The actual switch.
    self.deactivateEditors(wrapper)
    self.recolorWidget (w.leo_p,wrapper) # switches colorizers.
    # g.trace('c.frame.body',c.frame.body)
    # g.trace('c.frame.body.bodyCtrl',c.frame.body.bodyCtrl)
    # g.trace('wrapper',wrapper)
    
    c.frame.body.bodyCtrl = wrapper
    c.frame.body.widget = wrapper # Major bug fix: 2011/04/06
    w.leo_active = True

    self.switchToChapter(wrapper)
    self.selectLabel(wrapper)

    if not self.ensurePositionExists(w):
        return g.trace('***** no position editor!')
    if not (hasattr(w,'leo_p') and w.leo_p):
        return g.trace('***** no w.leo_p',w)
        
    p = w.leo_p
    assert p,p

    if trace: g.trace('wrapper %s old %s p %s' % (
        id(wrapper),c.p.h,p.h))

    c.expandAllAncestors(p)
    c.selectPosition(p)
        # Calls assignPositionToEditor.
        # Calls p.v.restoreCursorAndScroll.
    c.redraw()
    c.recolor_now()
    c.bodyWantsFocus()
#@+node:ekr.20070423101911: *7* selectHelper (leoTree) (changed 4.10)
# Do **not** try to "optimize" this by returning if p==c.p.
# 2011/11/06: *event handlers* are called only if p != c.p.

def selectHelper (self,p,scroll):

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.p
    
    call_event_handlers = p != old_p

    if p:
        # 2009/10/10: selecting a foreign position
        # will not be pretty.
        assert p.v.context == c
    else:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    # if trace and (verbose or call_event_handlers):
        # g.trace(p and p.h,g.callers())
            
    if call_event_handlers:
        unselect = not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    else:
        unselect = True

    if unselect:
        << unselect the old node >>
        
    if call_event_handlers:
        g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        
    if call_event_handlers:
        if call_event_handlers:
            select = not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        else:
            select = True
        if select:
            << select the new node >>
            c.nodeHistory.update(p) # Remember this position.
    else:
        if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
            << select the new node >>
            c.nodeHistory.update(p) # Remember this position.
        
    c.setCurrentPosition(p)
    << set the current node >>
    p.restoreCursorAndScroll(w)
        # Was in setBodyTextAfterSelect (in <select the new node>)
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    # if trace and (verbose or call_event_handlers):
        # g.trace('**** after old: %s new %s' % (
            # old_p and len(old_p.b),len(p.b)))

    # what UNL.py used to do
    c.frame.clearStatusLine()
    c.frame.putStatusLine(p.get_UNL())

    if call_event_handlers: # 2011/11/06
        g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
#@+node:ekr.20120325072403.7771: *8* << unselect the old node >> (selectHelper)
# Remember the position of the scrollbar *before* making any changes.
# This does not work if we are switching body editors!
    # if old_p:
        # old_p.v.scrollBarSpot = yview = body.getYScrollPosition() if body else None
        # if trace: g.trace('old scroll: %3s insert: %3s %s' % (
            # yview,old_p.v.insertSpot,old_p.h))
        
# Remember the selection range and insert point.
# This does not work if we are switching body editors!
# Instead, w.setInsertPoint and w.setSelectionRangeHelper should do the saving.

    # if old_p and body:
        # old_p.v.insertSpot = ins = body.getInsertPoint()
        # i,j = body.getSelectionRange()
        # assert(i<=j)
        # old_p.v.selectionStart = i
        # old_p.v.selectionLength = j-i
        # if trace: g.trace(i,j,ins)
    
# New in Leo 4.10: the code sets v.insertSpot as soon as it changes (not here).

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)
#@+node:ekr.20040803072955.133: *8* << set the current node >> (selectHelper)
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

# Was in ctor.
use_chapters = c.config.getBool('use_chapters')

if use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.h)

c.treeFocusHelper() # 2010/12/14
c.undoer.onSelect(old_p,p)
#@+node:ekr.20120325072403.7767: *8* << select the new node >> (selectHelper)
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.h
frame.setWrap(p)
self.setBodyTextAfterSelect(p,old_p)
#@+node:ekr.20110605121601.18092: *7* setAllText (leoQTextEditWidget) & helper (changed 4.10)
def setAllText(self,s):

    '''Set the text of the widget.

    If insert is None, the insert point, selection range and scrollbars are initied.
    Otherwise, the scrollbars are preserved.'''

    trace = False and not g.unitTesting
    verbose = False
    c,w = self.c,self.widget
    colorizer = c.frame.body.colorizer
    highlighter = colorizer.highlighter
    colorer = highlighter.colorer

    # Set a hook for the colorer.
    colorer.initFlag = True

    if trace and verbose: t1 = g.getTime()

    try:
        self.changingText = True # Disable onTextChanged
        colorizer.changingText = True
        w.setReadOnly(False)
        w.setPlainText(s)
    finally:
        self.changingText = False
        colorizer.changingText = False

    if trace and verbose: g.trace(g.timeSince(t1))
    
#@+node:ekr.20090608081524.6109: *7* setBodyTextAfterSelect (changed 4.10)
def setBodyTextAfterSelect (self,p,old_p):
    
    # trace = g.trace_scroll and not g.unitTesting

    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c ; w = c.frame.body.bodyCtrl
    s = p.v.b # Guaranteed to be unicode.
    old_s = w.getAllText()

    if p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
        pass
    else:
        # w.setAllText destroys all color tags, so do a full recolor.
        w.setAllText(s)
        colorizer = c.frame.body.colorizer
        if hasattr(colorizer,'setHighlighter'):
            colorizer.setHighlighter(p)
        self.frame.body.recolor(p)

    # This is now done after c.p has been changed.
        # p.restoreCursorAndScroll(w)
#@+node:ekr.20110605121601.18095: *7* setInsertPoint (leoQTextEditWidget)
def setInsertPoint(self,i):
    
    # Fix bug 981849: incorrect body content shown.
    # Use the more careful code in setSelectionRangeHelper & lengthHelper.
    self.setSelectionRangeHelper(i=i,j=i,insert=i)
    
    # trace = (True or g.trace_scroll) and not g.unitTesting

    # w = self.widget
    # s = w.toPlainText()
    # i = self.toPythonIndex(i)
    # i = max(0,min(i,len(s)))
    
    # cursor = w.textCursor()
    # cursor.setPosition(i)
    # w.setTextCursor(cursor)
    
    # # Remember the values for v.restoreCursorAndScroll.
    # v = self.c.p.v # Always accurate.
    # v.insertSpot = i
    # v.selectionStart = i
    # v.selectionLength = 0
    # v.scrollBarSpot = spot = w.getYScrollPosition()
    
    # if trace: g.trace(i,v.h)

#@+node:ekr.20110605121601.18096: *7* setSelectionRangeHelper & helper (leoQTextEditWidget)
def setSelectionRangeHelper(self,i,j,insert=None):

    trace = (False or g.trace_scroll) and not g.unitTesting

    w = self.widget
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)

    n = self.lengthHelper()
    i = max(0,min(i,n))
    j = max(0,min(j,n))
    if insert is None:
        ins = max(i,j)
    else:
        ins = self.toPythonIndex(insert)
        ins = max(0,min(ins,n))

    # 2010/02/02: Use only tc.setPosition here.
    # Using tc.movePosition doesn't work.
    tc = w.textCursor()
    if i == j:
        tc.setPosition(i)
    elif ins == j:
        # Put the insert point at j
        tc.setPosition(i)
        tc.setPosition(j,tc.KeepAnchor)
    else:
        # Put the insert point a i
        tc.setPosition(j)
        tc.setPosition(i,tc.KeepAnchor)
    w.setTextCursor(tc)

    # Remember the values for v.restoreCursorAndScroll.
    v = self.c.p.v # Always accurate.
    v.insertSpot = ins
    if i > j: i,j = j,i
    assert(i<=j)
    v.selectionStart = i
    v.selectionLength = j-i
    v.scrollBarSpot = spot = w.getYScrollPosition()
    if trace: g.trace('i: %s j: %s ins: %s spot: %s %s' % (i,j,ins,spot,v.h))
#@+node:ekr.20110605121601.18097: *8* lengthHelper
def lengthHelper(self):

    '''Return the length of the text.'''

    w = self.widget
    tc = w.textCursor()
    tc.movePosition(QtGui.QTextCursor.End)
    n = tc.position()
    return n

#@+node:ekr.20100303074003.5636: *7* v.restoreCursorAndScroll (changed 4.10)
# Called only by leoTree.selectHelper.

def restoreCursorAndScroll (self,w):
    
    trace = (False or g.trace_scroll) and not g.unitTesting
    v = self
    ins = v.insertSpot
    start,n = v.selectionStart,v.selectionLength
    spot = v.scrollBarSpot
    
    # Fix bug 981849: incorrect body content shown.
    if ins is None: ins = 0
    w.setInsertPoint(ins)

    if g.no_scroll:
        return

    # Override any changes to the scrollbar setting that might
    # have been done above by w.setSelectionRange or w.setInsertPoint.
    if spot is not None:
        w.setYScrollPosition(spot)
    v.scrollBarSpot = spot
        
    if trace: g.trace('start: %s n: %s ins: %s spot: %s %s' % (
        start,n,ins,spot,v.h))
        
    # Never call w.see here.
#@+node:ekr.20120327062318.9731: *5* Ensure selected @test node is run
In earlier version of Leo if one runs test externally with the selected
position under @test node, that @test was executed with (run-marked-unit-tests-externally)

The fix was to the "important special case" in TM.findAllUnitTestNodes.
#@+node:ekr.20120327062318.9732: *5* Made sure the new load code loads plugins at most once
@language python
@language rest

new load code, double init. for free layout
http://groups.google.com/group/leo-editor/browse_thread/thread/dd16ac6dc1832eb2

bookmarks.py was the culprit. The code in onCreate must test to see if c.free_layout already exists.
#@+node:ekr.20120326061010.9726: *5* fixed problem with file:/// url's on Windows
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/bb063866875a81c3#

In my installation, now on the latest revision ( r5195) I'm still
experiencing an issue with the '@url command' using 'File-URL' in a Windows
environement.

I'm able to create the Leo User documentation locally. - However, when I
try to read the documentation using the 'File-URL'

file:///D:/Branches/leo-editor/leo/doc/html/_build/html/leo_toc.html

I get the following message in the Leo-Log.

<log>

File 'D:\D:\Branches\leo-editor\leo\doc\html\_build\html\leo_toc.html' does not exist

</log>

However if I enter this URL directly into FF it is found and displayed properly.

EKR: Obviously, the 'D:\D:\' is the problem.

The fix is simply to special-case file:/// on Windows in g.computeFileUrl.
#@+node:ekr.20120327163022.9736: *5* fixed get_fn in viewrendered plugin
@language rest
groups.google.com/group/leo-editor/browse_thread/thread/bb063866875a81c3/6162e6108b09428e

The new code is much like g.computeFileUrl.
#@+node:ekr.20120327163022.9741: *5* Restored special case for run-selected-unit-tests
@language rest

Added code to findAllUnitTestNodes to look up the tree for @test & @suite nodes
if none have been found so far.  Only for the run-unit-tests-externally/locally.
#@+node:ekr.20120321174708.9744: *5* Fixed failing unit tests in distro
@nocolor-node

The @test at.readOneAtShadowNode retains @shadow links node
give fail1: test not set up properly.
The outline is then corrupted, causing other unit tests to fail.
The partial solution is not to call the undo command in the finally clause.
#@+node:ekr.20120327163022.9739: *4* Features
#@+node:ekr.20120324124808.9833: *5* Alt-Home & Alt-End collapse all possible nodes
#@+node:ekr.20120326061010.9728: *5* Added g.restore_selection_range
@nocolor-node

If off, only the insert point is restored.

It's kinda pointless to make this a user option.
#@+node:ekr.20120212060348.10374: *6*  << global switches >>
trace_startup = False
    # These traces use print instead of g.trace so that
    # the traces can add class info the method name.

new_modes = False
    # True: use ModeController and ModeInfo classes.
if new_modes: print('***** new_modes')

new_keys = False
    # This project hardly seems urgent.
    # True: Qt input methods produce a **user setting**, not a stroke.
if new_keys: print('***** new_keys')

# Debugging options...

enableDB = True
    # Don't even think about eliminating this constant:
    # it is needed for debugging.

no_scroll = False
    # True: disable all calls to w.setYScrollPosition.
no_see = False
    # True: disable all calls to w.see and w.seeInsertPoint.
    
# Tracing options...

trace_scroll = False
    # Trace calls to get/setYScrollPosition
trace_see = False
    # Trace calls to see and setInsertPoint.

# Switches to trace the garbage collector.
trace_gc = False           
trace_gc_calls = False    
trace_gc_calls = False 
trace_gc_verbose = False
trace_gc_inited = False

trace_masterCommand = False
trace_masterKeyHandler = False
trace_masterKeyHandlerGC = False
trace_minibuffer = False
trace_modes = False

# These print statements have been moved to writeWaitingLog.
# This allows for better --silent operation.
if 0:
    print('*** isPython3: %s' % isPython3)
    if not enableDB:
        print('** leoGlobals.py: caching disabled')

#@+node:ekr.20100303074003.5636: *6* v.restoreCursorAndScroll (changed 4.10)
# Called only by leoTree.selectHelper.

def restoreCursorAndScroll (self,w):
    
    trace = (False or g.trace_scroll) and not g.unitTesting
    v = self
    ins = v.insertSpot
    start,n = v.selectionStart,v.selectionLength
    spot = v.scrollBarSpot
    
    # Fix bug 981849: incorrect body content shown.
    if ins is None: ins = 0
    w.setInsertPoint(ins)

    if g.no_scroll:
        return

    # Override any changes to the scrollbar setting that might
    # have been done above by w.setSelectionRange or w.setInsertPoint.
    if spot is not None:
        w.setYScrollPosition(spot)
    v.scrollBarSpot = spot
        
    if trace: g.trace('start: %s n: %s ins: %s spot: %s %s' % (
        start,n,ins,spot,v.h))
        
    # Never call w.see here.
#@+node:ekr.20120327163022.9738: *4* Home page
#@+node:ekr.20111027103125.16545: *5* Added link to home page from the TOC
#@+node:ekr.20120229173025.20629: *5* Removed online-tutorial link
http://groups.google.com/group/leo-editor/browse_thread/thread/2157d8bfc0f381f1

es, choosing Help-->"Open Online Tutorial" tries to go to a page on
3dTree.com the site for which is no longer held.

Should the Quick Intro be brought back instead? 
#@+node:ekr.20111027103125.16539: *5* Added search box to Leo's home page
<div id="searchbox" style="">
<h3>Quick search</h3>

<form class="search" method="get" action="search.html">

<p class="searchtip" style="font-size: 90%"> Enter search terms or a module, class or function name. </p>
</div>
#@+node:ekr.20111020120612.15896: *5* Added link to glossary from Leo's home page
#@+node:ekr.20111027103125.16544: *5* Added screen shot to Leo's home page
#@+node:ekr.20110930174206.15470: *5* Brought screen shots up to date
#@+node:ekr.20120326061010.9727: *5* Scaled the screenshot on home page
http://groups.google.com/group/leo-editor/browse_thread/thread/ea3c29888d8ac92b

> - Added a full-sized screenshot at the bottom of the page.
>  I'm not sure whether this is a good idea.  What do you think?

Scaled the screen-shot using:

http://stackoverflow.com/questions/3029422/image-auto-resize-to-fit-div-container
#@+node:ekr.20120323124339.9721: *4* Investigated problem with desktop shortcut
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/a03661d8c1eec0c6

I'm experimenting with the latest version (WinXP). This is really odd. If I
launch Leo using the desktop shortcut, I'm not able to open *any* valid
.leo file except  LeoSettings.leo. This is the shortcut:
C:\Python32\pythonw.exe "C:\Program Files\Leo-4.10-b1\launchLeo.py"

However, if I launch using my Windows batch file, I'm able to open all
files as expected. The code is:
C:\Python32\python "C:\Program Files\Leo-4.10-b1\launchLeo.py" %*

Anyone else experiencing this? Any possible explanation?

EKR: Are you doing this in a console window? 

No, that's why I used the batch file so I can launch w/ a console. When I
do, it works fine. 

I just installed on another box w/ Python 2.6.2 That works fine. The other
box has Python 3.2, not sure why that matters, but it might be a clue.
#@+node:ekr.20120327163022.9742: *5* EKR response
@language rest

There are two differences between the two ways of launching.

1. pythonw.exe vs python.exe

2. The former has no "%*" argument.  It's possible that you have no
workbook.leo file in your home directory, which might cause a failure,
iirc.

I suggest first changing pythonw to python.  This will open a console,
but probably too briefly to read.  To fix this, add a -i argument,
which will drop python into interactive mode, which has the side
effect of leaving the console open.  This should tell you why exactly
nothing happens.

I suspect that adding the "%*" argument will fix the problem,
regardless of whether you use pythonw or python.

If not, please feel free to ask more questions.
#@+node:ekr.20120329072206.9701: ** 4.10.1
#@+node:ekr.20120330040023.9780: *3* Bugs
#@+node:ekr.20120330040023.9779: *4* Restore focus on window activation
#@+node:ekr.20110607182447.16456: *5* Event handlers (qtGui)
#@+node:ekr.20110605121601.18480: *6* onActivateEvent (qtGui)
# Called from eventFilter

def onActivateEvent (self,event,c,obj,tag):

    '''Put the focus in the body pane when the Leo window is
    activated, say as the result of an Alt-tab or click.'''

    # This is called several times for each window activation.
    # We only need to set the focus once.

    trace = False and not g.unitTesting

    if trace: g.trace(tag)
    
    if c.exists and tag == 'body':
        self.active = True
        # Retain the focus that existed when the deactivate event happened.
            # c.bodyWantsFocusNow()
        g.doHook('activate',c=c,p=c.p,v=c.p,event=event)
#@+node:ekr.20110605121601.18481: *6* onDeactiveEvent (qtGui)
def onDeactivateEvent (self,event,c,obj,tag):

    '''Put the focus in the body pane when the Leo window is
    activated, say as the result of an Alt-tab or click.'''

    trace = False and not g.unitTesting

    # This is called several times for each window activation.
    # Save the headline only once.

    if c.exists and tag.startswith('tree'):
        self.active = False
        if trace: g.trace()
        c.k.keyboardQuit(setFocus=False)
            # 2011/06/13.
            # 2011/09/29. Don't change the tab in the log pane.
        # c.endEditing()
        g.doHook('deactivate',c=c,p=c.p,v=c.p,event=event)
#@+node:ekr.20120409074150.9940: *4* The @auto read code now catches failed asserts in import code.
@nocolor-node

If an assert fails, the entire file is read into a single node.
#@+node:ekr.20120409182030.10028: *4* Fixed several problems with c-to-py command
@nocolor-node

An assert failed during scanning in mungeAllFunctions.

Added defensive code to mungeAllFunctions, dedentBlocks and
replaceComments. The new code simply increments a pointer if a "progress"
assert would fail. (The progress assert still exists, as a double-check.)

Fixed bug: the call to u.afterChangeGroup in the go() method is called only once.

Suppress warning messages given by CPrettyPrinter.indent.
#@+node:ekr.20120401144849.10036: *4* Fixed bug 971171: re .leoRecentFiles
@language python
@language rest

If If $(HOME)/.leo/.leoRecentFiles.txt does not exist,
the only recent file ever is the current file
https://bugs.launchpad.net/leo-editor/+bug/971171

The fix: rf.writeRecentFilesFile creates $(HOME)/.leo/.leoRecentFiles.txt if it does not exist.
#@+node:ekr.20120401144849.10035: *4* Fixed bugs 971166 & 979142 re copy/paste
@language python
@language rest

These bugs are really the same bug

Node body contents displayed is unpredictably incorrect
https://bugs.launchpad.net/leo-editor/+bug/979142

Prints to tabs in the Log Pane are UTF-8 encoded
https://bugs.launchpad.net/leo-editor/+bug/971166

The fix was:

1. Use the "slow" code in leoQTextEditWidget.get.
2. Use w.get/setAllText in leoFrame.pasteText.
#@+node:ekr.20120413152012.10048: *4* Minimize scrolling during paste-text
#@+node:ekr.20070130115927.7: *5* leoFrame.pasteText
def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    trace = False and not g.unitTesting
    f = self ; c = f.c
    w = event and event.widget
    wname = (w and c.widget_name(w)) or '<no widget>'
    if trace: g.trace(g.app.gui.isTextWidget(w),w)
    if not w or not g.app.gui.isTextWidget(w): return

    i,j = oldSel = w.getSelectionRange()  # Returns insert point if no selection.
    oldText = w.getAllText()

    if middleButton and c.k.previousSelection is not None:
        start,end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()

    # g.trace(type(s),s[:25])

    s = g.toUnicode(s)

    # g.trace('pasteText','wname',wname,'s',s,g.callers())

    singleLine = wname.startswith('head') or wname.startswith('minibuffer')

    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)
    w.see(i+len(s) + 2) # 2011/06/01

    if wname.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif singleLine:
        s = w.getAllText()
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # 2011/11/14: headline width methods do nothing at present.
        # if wname.startswith('head'):
            # The headline is not officially changed yet.
            # p.initHeadString(s)
            # width = f.tree.headWidth(p=None,s=s)
            # w.setWidth(width)
    else: pass

    return

OnPasteFromMenu = pasteText
#@+node:ekr.20110605121601.18092: *5* setAllText (leoQTextEditWidget) & helper (changed 4.10)
def setAllText(self,s):

    '''Set the text of the widget.

    If insert is None, the insert point, selection range and scrollbars are initied.
    Otherwise, the scrollbars are preserved.'''

    trace = False and not g.unitTesting
    verbose = False
    c,w = self.c,self.widget
    colorizer = c.frame.body.colorizer
    highlighter = colorizer.highlighter
    colorer = highlighter.colorer

    # Set a hook for the colorer.
    colorer.initFlag = True

    if trace and verbose: t1 = g.getTime()

    try:
        self.changingText = True # Disable onTextChanged
        colorizer.changingText = True
        w.setReadOnly(False)
        w.setPlainText(s)
    finally:
        self.changingText = False
        colorizer.changingText = False

    if trace and verbose: g.trace(g.timeSince(t1))
    
#@+node:ekr.20110605121601.18079: *5* delete (avoid call to setAllText) (leoQTextEditWidget)
def delete(self,i,j=None):

    trace = False and not g.unitTesting
    c,w = self.c,self.widget
    colorer = c.frame.body.colorizer.highlighter.colorer
    n = colorer.recolorCount

    if trace: g.trace(self.getSelectionRange())

    i = self.toGuiIndex(i)
    if j is None: j = i+1
    j = self.toGuiIndex(j)
    if i > j: i,j = j,i

    if trace: g.trace(i,j)

    # Set a hook for the colorer.
    colorer.initFlag = True

    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    cursor = w.textCursor()

    try:
        self.changingText = True # Disable onTextChanged

        old_i,old_j = self.getSelectionRange()
        if i == old_i and j == old_j:
            # Work around an apparent bug in cursor.movePosition.
            cursor.removeSelectedText()
        elif i == j:
            pass
        else:
            # g.trace('*** using dubious code')
            cursor.setPosition(i)
            moveCount = abs(j-i)
            cursor.movePosition(cursor.Right,cursor.KeepAnchor,moveCount)
            w.setTextCursor(cursor)  # Bug fix: 2010/01/27
            if trace:
                i,j = self.getSelectionRange()
                g.trace(i,j)
            cursor.removeSelectedText()
            if trace: g.trace(self.getSelectionRange())
    finally:
        self.changingText = False

    sb.setSliderPosition(pos)

    # g.trace('%s calls to recolor' % (colorer.recolorCount-n))
#@+node:ekr.20110605121601.18089: *5* insert (avoid call to setAllText) (leoQTextWidget)
def insert(self,i,s):

    c,w = self.c,self.widget
    colorer = c.frame.body.colorizer.highlighter.colorer
    n = colorer.recolorCount

    # Set a hook for the colorer.
    colorer.initFlag = True
    i = self.toGuiIndex(i)
    cursor = w.textCursor()
    try:
        self.changingText = True # Disable onTextChanged.
        cursor.setPosition(i)
        cursor.insertText(s) # This cause an incremental call to recolor.
        w.setTextCursor(cursor) # Bug fix: 2010/01/27
    finally:
        self.changingText = False
#@+node:ekr.20120418065452.10029: *4* Fixed bug 981849: incorrect body content shown
@language python
@language rest

https://bugs.launchpad.net/leo-editor/+bug/981849

Use the more careful code in setSelectionRangeHelper & lengthHelper.
#@+node:ekr.20100303074003.5636: *5* v.restoreCursorAndScroll (changed 4.10)
# Called only by leoTree.selectHelper.

def restoreCursorAndScroll (self,w):
    
    trace = (False or g.trace_scroll) and not g.unitTesting
    v = self
    ins = v.insertSpot
    start,n = v.selectionStart,v.selectionLength
    spot = v.scrollBarSpot
    
    # Fix bug 981849: incorrect body content shown.
    if ins is None: ins = 0
    w.setInsertPoint(ins)

    if g.no_scroll:
        return

    # Override any changes to the scrollbar setting that might
    # have been done above by w.setSelectionRange or w.setInsertPoint.
    if spot is not None:
        w.setYScrollPosition(spot)
    v.scrollBarSpot = spot
        
    if trace: g.trace('start: %s n: %s ins: %s spot: %s %s' % (
        start,n,ins,spot,v.h))
        
    # Never call w.see here.
#@+node:ekr.20110605121601.18096: *5* setSelectionRangeHelper & helper (leoQTextEditWidget)
def setSelectionRangeHelper(self,i,j,insert=None):

    trace = (False or g.trace_scroll) and not g.unitTesting

    w = self.widget
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)

    n = self.lengthHelper()
    i = max(0,min(i,n))
    j = max(0,min(j,n))
    if insert is None:
        ins = max(i,j)
    else:
        ins = self.toPythonIndex(insert)
        ins = max(0,min(ins,n))

    # 2010/02/02: Use only tc.setPosition here.
    # Using tc.movePosition doesn't work.
    tc = w.textCursor()
    if i == j:
        tc.setPosition(i)
    elif ins == j:
        # Put the insert point at j
        tc.setPosition(i)
        tc.setPosition(j,tc.KeepAnchor)
    else:
        # Put the insert point a i
        tc.setPosition(j)
        tc.setPosition(i,tc.KeepAnchor)
    w.setTextCursor(tc)

    # Remember the values for v.restoreCursorAndScroll.
    v = self.c.p.v # Always accurate.
    v.insertSpot = ins
    if i > j: i,j = j,i
    assert(i<=j)
    v.selectionStart = i
    v.selectionLength = j-i
    v.scrollBarSpot = spot = w.getYScrollPosition()
    if trace: g.trace('i: %s j: %s ins: %s spot: %s %s' % (i,j,ins,spot,v.h))
#@+node:ekr.20110605121601.18097: *6* lengthHelper
def lengthHelper(self):

    '''Return the length of the text.'''

    w = self.widget
    tc = w.textCursor()
    tc.movePosition(QtGui.QTextCursor.End)
    n = tc.position()
    return n

#@+node:ekr.20110605121601.18095: *5* setInsertPoint (leoQTextEditWidget)
def setInsertPoint(self,i):
    
    # Fix bug 981849: incorrect body content shown.
    # Use the more careful code in setSelectionRangeHelper & lengthHelper.
    self.setSelectionRangeHelper(i=i,j=i,insert=i)
    
    # trace = (True or g.trace_scroll) and not g.unitTesting

    # w = self.widget
    # s = w.toPlainText()
    # i = self.toPythonIndex(i)
    # i = max(0,min(i,len(s)))
    
    # cursor = w.textCursor()
    # cursor.setPosition(i)
    # w.setTextCursor(cursor)
    
    # # Remember the values for v.restoreCursorAndScroll.
    # v = self.c.p.v # Always accurate.
    # v.insertSpot = i
    # v.selectionStart = i
    # v.selectionLength = 0
    # v.scrollBarSpot = spot = w.getYScrollPosition()
    
    # if trace: g.trace(i,v.h)

#@+node:ekr.20120427064024.10062: *4* Fixed bug 711158: Warn if same .leo file open in another Leo instance
@language python
@language rest

Warn if same .leo file open in another Leo instance
https://bugs.launchpad.net/leo-editor/+bug/711158


What I did:

- The PickleShareDB object is created even if caching (of files) is disabled.
  This allows us to used g.app.db even when --no-cache is in effect.
  
- Added the three methods in app.Detecting already-open files.
#@+node:ekr.20100208082353.5920: *5* initGlobalDb
def initGlobalDB (self):

    trace = False and not g.unitTesting

    # New in Leo 4.10.1.
    # We always create the global db, even if caching is disabled.
    try:
        dbdirname = g.app.homeLeoDir + "/db/global"
        self.db = db = PickleShareDB(dbdirname)
        if trace: g.trace(db,dbdirname)
        self.inited = True
        return db
    except Exception:
        return {} # Use a plain dict as a dummy.
#@+node:ekr.20031218072017.1553: *5* fc.getLeoFile & helpers
# The caller should follow this with a call to c.redraw().

def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    # g.trace('*****',fileName)
    fc,c = self,self.c
    c.setChanged(False) # May be set when reading @file nodes.
    fc.warnOnReadOnlyFiles(fileName)
    fc.checking = False
    fc.mFileName = c.mFileName
    fc.initReadIvars()

    try:
        c.loading = True # disable c.changed
        ok = True if silent else g.app.checkForOpenFile(c,fileName)
        if ok:
            ok = fc.getLeoFileHelper(theFile,fileName,silent)
                # Read the .leo file and create the outline.
                
            # Remember the open file.
            g.app.rememberOpenFile(fileName)
        else:
            fc.mFileName = c.mFileName = None
                # Bug fix. Clear the fileName so forgetOpenFile doesn't remove it.
    
        if ok:
            fc.resolveTnodeLists()
                # Do this before reading external files.
            c.setFileTimeStamp(fileName)
            
            if readAtFileNodesFlag:
                # Redraw before reading the @file nodes so the screen isn't blank.
                # This is important for big files like LeoPy.leo.
                c.redraw()
                fc.readExternalFiles(fileName)
            
            if c.config.getBool('check_outline_after_read'):
                c.checkOutline(event=None,verbose=True,unittest=False,full=True)
    finally:
        c.loading = False # reenable c.changed

    if c.changed:
        fc.propegateDirtyNodes()
    c.setChanged(c.changed) # Refresh the changed marker.
    fc.initReadIvars()
    return ok, c.frame.ratio
#@+node:ekr.20090526081836.5841: *6* fc.getLeoFileHelper
def getLeoFileHelper(self,theFile,fileName,silent):

    '''Read the .leo file and create the outline.'''

    c,fc = self.c,self
    try:
        ok = True
        v = fc.readSaxFile(theFile,fileName,silent,inClipboard=False,reassignIndices=False)
        if v: # v is None for minimal .leo files.
            c.setRootVnode(v)
            fc.rootVnode = v
        else:
            v = leoNodes.vnode(context=c)
            v.setHeadString('created root node')
            p = leoNodes.position(v)
            p._linkAsRoot(oldRoot=None)
            fc.rootVnode = v
            # c.setRootPosition()
            c.changed = False
    except BadLeoFile:
        junk, message, junk = sys.exc_info()
        if not silent:
            g.es_exception()
            c.alert(fc.mFileName + " is not a valid Leo file: " + str(message))
        ok = False

    return ok
#@+node:ekr.20100205060712.8314: *6* fc.handleNodeConflicts & helper
def handleNodeConflicts (self):

    c = self.c
    if not c.nodeConflictList: return

    # Find the last top-level node.
    sib = c.rootPosition()
    while sib.hasNext():
        sib.moveToNext()

    # Create the 'Recovered Nodes' node.
    root = sib.insertAfter()
    root.setHeadString('Recovered Nodes')
    root.expand()

    # For each conflict, create one child and two grandchildren.
    for bunch in c.nodeConflictList:
        tag = bunch.get('tag') or ''
        gnx = bunch.get('gnx') or ''
        fn  = bunch.get('fileName') or ''
        b1,h1 = bunch.get('b_old'),bunch.get('h_old')
        b2,h2 = bunch.get('b_new'),bunch.get('h_new')
        child = root.insertAsLastChild()
        h = 'Recovered node "%s from %s' % (h1,g.shortFileName(fn))
        child.setHeadString(h)
        # child.setBodyString('%s %s' % (tag,gnx))
        line1 = '%s %s\nDiff...\n' % (tag,gnx)
        d = difflib.Differ().compare(g.splitLines(b2),g.splitLines(b1))
        # d = difflib.unified_diff(g.splitLines(b2),g.splitLines(b1))
        diffLines = [z for z in d]
        lines = [line1]
        lines.extend(diffLines)
        # There is less need to show trailing newlines because
        # we don't report changes involving only trailing newlines.
        child.setBodyString(''.join(lines)) # .replace('\n','\\n\n'))
        n1 = child.insertAsNthChild(0)
        n2 = child.insertAsNthChild(1)
        n1.setHeadString('old:'+h1)
        n1.setBodyString(b1)
        n2.setHeadString('new:'+h2)
        n2.setBodyString(b2)

    return root
#@+node:ekr.20100701112151.5959: *7* getDiff
def getDiff (self,s1,s2):

    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)
    diffLines = difflib.Differ.compare(lines1,lines2)
    return diffLines
#@+node:ekr.20100124110832.6212: *6* fc.propegateDirtyNodes
def propegateDirtyNodes (self):

    fc = self ; c = fc.c

    aList = [z.copy() for z in c.all_positions() if z.isDirty()]
    for p in aList:
        p.setAllAncestorAtFileNodesDirty()
#@+node:ekr.20120212220616.10537: *6* fc.readExternalFiles
def readExternalFiles(self,fileName):

    c,fc = self.c,self
    
    c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
    recoveryNode = fc.handleNodeConflicts()

    # Do this after reading external files.
    # The descendent nodes won't exist unless we have read the @thin nodes!
    fc.restoreDescendentAttributes()

    fc.setPositionsFromVnodes()
    c.selectVnode(recoveryNode or c.p) # load body pane
#@+node:ekr.20031218072017.1554: *6* fc.warnOnReadOnlyFiles
def warnOnReadOnlyFiles (self,fileName):

    # os.access may not exist on all platforms.

    try:
        self.read_only = not os.access(fileName,os.W_OK)
    except AttributeError:
        self.read_only = False
    except UnicodeError:
        self.read_only = False

    if self.read_only and not g.unitTesting:
        g.es("read only:",fileName,color="red")
#@+node:ekr.20120427064024.10068: *5* app.Detecting already-open files
#@+node:ekr.20120427064024.10064: *6* app.checkForOpenFile
def checkForOpenFile (self,c,fn):
    
    d,tag = g.app.db,'open-leo-files'

    if d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting:
        return True
    else:
        aList = d.get(tag) or []
        if fn in aList:
            result = g.app.gui.runAskYesNoDialog(c,
                title='Open Leo File Again?',
                message='%s is already open.  Open it again?' % (fn),
            )
            if result == 'yes':
                clear = g.app.gui.runAskYesNoDialog(c,
                    title='Reset open count?',
                    message='Reset open count for %s?' \
                        "\nSay yes if you know this outline" \
                        "\nis not really open elsewhere"% (fn),
                )
                if clear == 'yes':
                    d[tag] = [i for i in d[tag] if i != fn]
                    # IMPORTANT - rest of load process will add another
                    # entry for this Leo instance, don't do it here
            return result == 'yes'
        else:
            return True
#@+node:ekr.20120427064024.10066: *6* app.forgetOpenFile
def forgetOpenFile (self,fn):

    trace = False and not g.unitTesting
    d,tag = g.app.db,'open-leo-files'

    if d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting:
        pass
    else:
        aList = d.get(tag) or []
        if fn in aList:
            aList.remove(fn)
            if trace:
                g.trace('removed: %s' % (fn),g.callers())
                for z in aList:
                    print('  %s' % (z))
            d[tag] = aList
        else:
            if trace: g.trace('did not remove: %s' % (fn))
#@+node:ekr.20120427064024.10065: *6* app.rememberOpenFile
def rememberOpenFile(self,fn):
    
    trace = False and not g.unitTesting
    d,tag = g.app.db,'open-leo-files'

    if d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting:
        pass
    elif g.app.preReadFlag:
        pass
    else:
        aList = d.get(tag) or []
        # It's proper to add duplicates to this list.
        aList.append(fn)
        if trace:
            # Trace doesn't work well while initing.
            print('rememberOpenFile:added: %s' % (fn))
            for z in aList:
                print('  %s' % (z))
        d[tag] = aList
#@+node:ekr.20120520055508.11872: *4* Clear previous focus-border after alt-tab
@nocolor-node

This was a recent problem.  Normally setInputState should *not* set the border.

Added code to eventFilter to call remove_border on focus out.

set-xxx-state commands call setInputState with set_border = True.
#@+node:ekr.20061031131434.123: *5* set-xxx-State
def setCommandState (self,event):
    '''Enter the 'command' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('command',set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setInsertState (self,event):
    '''Enter the 'insert' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('insert',set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setOverwriteState (self,event):
    '''Enter the 'overwrite' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('overwrite',set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()
#@+node:ekr.20061031131434.133: *5* setInputState
def setInputState (self,state,set_border=False):

    c,k = self.c,self
    k.unboundKeyAction = state

    if set_border and c.frame and c.frame.body:
        w = c.frame.body.bodyCtrl
        if hasattr(w,'widget'):
            g.app.gui.add_border(c,w.widget)
#@+node:ekr.20111022215436.16685: *5* Borders (qtGui)
def add_border(self,c,w):

    state = c.k and c.k.unboundKeyAction
    
    # g.trace(state,hasattr(w,'viewport'),w,g.callers())

    if state and c.use_focus_border and hasattr(w,'viewport'):
        w = w.viewport()
        d = {
            'command':  c.focus_border_command_state_color,
            'insert':   c.focus_border_color,
            'overwrite':c.focus_border_overwrite_state_color,
        }
        color = d.get(state,c.focus_border_color)
        sheet = "border: %spx solid %s" % (c.focus_border_width,color)
        self.update_style_sheet(w,'border',sheet)

def remove_border(self,c,w):
    
    # g.trace(hasattr(w,'viewport'),w)

    if c.use_focus_border and hasattr(w,'viewport'):
        w = w.viewport()
        # g.trace(w)
        sheet = "border: %spx solid white" % c.focus_border_width
        self.update_style_sheet(w,'border',sheet)
#@+node:ekr.20110605121601.18540: *5* eventFilter
def eventFilter(self, obj, event):

    trace = (False or g.trace_masterKeyHandler) and not g.unitTesting
    verbose = True
    traceEvent = False # True: call self.traceEvent.
    traceKey = (True or g.trace_masterKeyHandler)
    c = self.c ; k = c.k
    eventType = event.type()
    ev = QtCore.QEvent
    gui = g.app.gui
    aList = []

    kinds = [ev.ShortcutOverride,ev.KeyPress,ev.KeyRelease]

    # Hack: QLineEdit generates ev.KeyRelease only on Windows,Ubuntu
    lineEditKeyKinds = [ev.KeyPress,ev.KeyRelease]

    # Important:
    # QLineEdit: ignore all key events except keyRelease events.
    # QTextEdit: ignore all key events except keyPress events.
    if eventType in lineEditKeyKinds:
        p = c.currentPosition()
        isEditWidget = obj == c.frame.tree.edit_widget(p)
        self.keyIsActive = g.choose(
            isEditWidget,
            eventType == ev.KeyRelease,
            eventType == ev.KeyPress)
    else:
        self.keyIsActive = False

    if eventType == ev.WindowActivate:
        gui.onActivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType == ev.WindowDeactivate:
        gui.onDeactivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
        if self.tag in ('body','tree','log'):
            g.app.gui.remove_border(c,obj)
    elif eventType in kinds:
        tkKey,ch,ignore = self.toTkKey(event)
        aList = c.k.masterGuiBindingsDict.get('<%s>' %tkKey,[])
        # g.trace('instate',k.inState(),'tkKey',tkKey,'ignore',ignore,'len(aList)',len(aList))
        if ignore:
            override = False
        # This is extremely bad.
        # At present, it is needed to handle tab properly.
        elif self.isSpecialOverride(tkKey,ch):
            override = True
        elif k.inState():
            override = not ignore # allow all keystrokes.
        else:
            override = len(aList) > 0
    else:
        override = False ; tkKey = '<no key>'
        if self.tag == 'body':
            if eventType == ev.FocusIn:
                g.app.gui.add_border(c,obj)
                c.frame.body.onFocusIn(obj)
            elif eventType == ev.FocusOut:
                g.app.gui.remove_border(c,obj)
                c.frame.body.onFocusOut(obj)
        if self.tag in ('tree','log'):
            if eventType == ev.FocusIn:
                g.app.gui.add_border(c,obj)
            elif eventType == ev.FocusOut:
                g.app.gui.remove_border(c,obj)

    if self.keyIsActive:
        shortcut = self.toStroke(tkKey,ch) # ch is unused.

        if override:
            # Essentially *all* keys get passed to masterKeyHandler.
            if trace and traceKey:
                g.trace('ignore',ignore,'bound',repr(shortcut),repr(aList))
            w = self.w # Pass the wrapper class, not the wrapped widget.
            event = self.create_key_event(event,c,w,ch,tkKey,shortcut)
            ret = k.masterKeyHandler(event)
            c.outerUpdate()
        else:
            if trace and traceKey and verbose:
                g.trace(self.tag,'unbound',tkKey,shortcut)
        
        if trace and traceEvent:
            # Trace key events.
            self.traceEvent(obj,event,tkKey,override)

    elif trace and traceEvent:
        # Trace non-key events.
        self.traceEvent(obj,event,tkKey,override)

    return override
#@+node:ekr.20120520055508.11874: *4* Fixed special cases of auto-completion of commands
@nocolor-node

If the user has not typed anything in the minibuffer, <alt-x><tab> returns *all* completions.

Otherwise, if there are no completions, the "Completions" tab is empty, *not* all completions.

This behavior is much more intuitive than the old behavior.

The fix was a new special case in k.computeCompletionList.
#@+node:ekr.20111025141618.16484: *4* Fixed bug 879338: Global tables in leoApp.py should describe all languages known to the colorizer
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/879338

Having the colorizer colorize a language properly gives the false illusion
that Leo "understands" the language.

Supporting the language in the global tables in leoApp.py makes the
illusion a reality.
#@+node:ekr.20120522160137.9908: *5* Notes
@language rest

Rev 5334 is a first draft of a fix of bug 879338:
Global tables in leoApp.py should describe all languages known to the colorizer
https://bugs.launchpad.net/leo-editor/+bug/879338

The essence of the bug fix is that Leo's language-description tables should
contain entries for all .py files in the leo/modes folder. These files
control the colorizer. If Leo's colorizer knows about a language, then Leo
should know as much as possible about the language.

In concept, this is a fairly straightforward process, but there were *many*
details to handle. If you aren't a Leo developer, you might want to stop
reading now...

===== Tables

Fixing this bug required non-trivial changes to the following tables::

    g.app.language_delims_dict
    # Keys are languages, values are 1,2 or 3-tuples of delims.

    g.app.language_extension_dict
    # Keys are language names, values are extensions.

    g.app.self.extension_dict
    # Keys are extensions, values are language names

I used scripts to generate new entries for these tables, but these scripts
can not possibly deal with the all the complications...

Leo uses these tables as follows:

1.  To generate the comment delimiters in sentinels for each language.

Happily, getting the comment delimiters correct was probably the easiest
part, so Leo should continue to write sentinels properly for
previously-know languages. However, I had to take care to preserve the REM,
CWEB, forth and perlpod hacks, so that comment delims would include the
necessary spaces.

2. To associate file extensions with importers.

Knowing about new file extensions doesn't actually allow Leo to import any
new languages. For all languages without an official importer Leo will
simply copy the entire text of the file into a single node, as it always
has.

3. To colorize code.

Leo's colorizer mostly doesn't use these tables: to colorize language x,
the colorizer looks for the file leo/modes/x.py. Thus, these changes
probably do not affect the colorizer at all.

===== Special cases

I did a lot of googling in order to determine the proper file extensions to
use for various language. In the process, I learned that *almost* all
languages described in the leo/modes folder are real, interesting and
useful languages.

However, there at least 5 categories of special cases that affect the
tables:

1. Languages that are really just colorizer modes:

These include embperl, pseudoplain and phpsection. We need entries in
leo/modes for these, but they aren't real languages and thus they should
not appear in the language-description tables.

2. Things that might be colorized but aren't real languages.

Afaik, the following are not real languages, and Leo would never have to
generate files in these languages: cvs_commit,dsssl,relax_ng_compatc and svn_commit.

Notes:

- relax_ng_compact is an xml schema.

- The rtf colorizer is *not* a colorizer for binary .rtf file format, is a
  colorizer for .rtf sources. It probably won't do too much harm to retain
  the colorizer data for these languages, but I wouldn't mind eliminating
  them either.

3.  Unknown languages.

A few languages seem not really to exist: freemarker, hex, jcl, progress, props.

4. Languages without real comment delimiters.

Patch annotations are *not* real comment delimiters, so Leo could not
generate patch (.fix or .patch) files from an outline. Happily, there is no
need to do so.

5. Conflicting file extensions.

There are two separate kinds of problems:

A. Leo contains colorizers for several assembly languages. Typically,
assembly languages have .asm or .a file extensions. However, a particular
extension can only be associated with a single language name. Thus, Leo has
no way of knowing what language to associate with .asm or .a files. So I
just punted and didn't make any association at all.

B. Both the rebol and r languages use the .r file extension. One of Leo's
users previously created an entry for rebol, so that's the language that
takes precedence.
#@+node:ekr.20120523114117.10885: *5* Remove unused files from leo/modes directory
@language rest

Remove all .xml files in the leo/modes directory.

Imo, this should have been done long ago, for at least the following
reasons:

- These files are part of the jEdit project.
- They are used only by the jedit2py script in scripts.leo.
- The colorizer doesn't use them.
- Bug fixes to the colorizer are made to the .py files, not to the .xml files.
- We can always get updated versions of the .xml files from the jEdit
  project in the unlikely event that we ever need them again.

2. Remove the following .py files from the leo/modes directory:
cvs_commit.py, dsssl.py, freemarker.py, hex.py, jcl.py, progress.py,
props.py and svn_commit.py.

Notes:

- embperl.py, phpsection.py and pseudoplain.py will *not* be removed;
they are internal colorizer states.

- relax_ng_compact.py will be removed if it is not used by any other
colorizer.

- patch.py and rtf.py colorizers will be retained, even though Leo can
never generate such files. 
#@+node:ekr.20120522024827.9900: *5* Scripts
#@+node:ekr.20111021035504.9469: *6* Script: get all comments from modes (slow)
@language python

'''Slow script.'''

import glob
import imp

@others

if 0: # The other script is much faster.
    
    keys = ("lineComment","commentStart","commentEnd",)
    d = {}
        # Keys are language names.
        # Values are a list of comment delims, in keys order.
    
    paths,modes_path = get_paths()
    for path in paths:
        module_name = g.shortFileName(path)[:-3]
        module = import_module(module_name,modes_path)
        aList = []
        for key in keys:
            val = module.properties.get(key)
            if val: aList.append(val)
        d[module_name] = aList
    
    print('-'* 20)
    print('language_delims_dict')
    for key in sorted(d):
        print('%16s: "%s"' % ('"%s"' % (key),' '.join(d.get(key))))
#@+node:ekr.20111021035504.9470: *7* get_paths
def get_paths():
    
    modes_path = g.os_path_finalize_join(g.app.loadDir,'..','modes')
    pattern = g.os_path_finalize_join(modes_path,'*.py')
    paths = glob.glob(pattern)
    paths = [z for z in paths if not z.endswith('__init__.py')]
    return paths,modes_path
#@+node:ekr.20111021035504.9471: *7* import_module
def import_module(module_name,modes_path):
    
    data = imp.find_module(module_name,[modes_path])
        # This can open the file.
    theFile,pathname,description = data
    module = imp.load_module(module_name,theFile,pathname,description)
    return module
#@+node:ekr.20110528103005.18319: *6* Script to create global data structures from in modes/*.py files
@language python

'''Script to create global data structures from modes/*.py files.'''

import glob
import imp

g.cls()

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
aList = glob.glob(theDir)

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes')

# print('-'*40)
known_keys = list(g.app.language_delims_dict.keys())
new_languages = {}

for z in aList:
    name = g.os_path_basename(z)
    name2 = name[:-3]
    if name2 in known_keys or name2.startswith('__'):
        if 0: print('ignore: %s' % (name2))
    else:
        try:
            theFile, pathname, description = imp.find_module(name2,[theDir])
            m = imp.load_module(name2, theFile, pathname, description)
            if hasattr(m,'properties'):
                # new_languages.append(name2)
                new_languages[name2] = m
            else:
                print('no properties: %s %s' % (name2,m))
        except Exception:
            g.es_exception()
            
print('%s new languages\n' % (len(list(new_languages.keys()))))
    
for key in sorted(new_languages.keys()):
    m = new_languages.get(key)
    aList2 = [m.properties.get(z)
        for z in ('lineComment','commentStart','commentEnd')
            if m.properties.get(z)]
    print('%-20s : "%s",' % (
        '"%s"' % (key),
        ' '.join(aList2)))
    # computed[name2] = ' '.join(aList2)
       
if 0:
    mismatches = 0
    print()
    for z in known_keys:
        val = g.app.language_delims_dict.get(z)
        val2 = computed.get(z)
        if not val:
            print('no val',z)
        elif not val2:
            print('no val2',z)
        elif val != val2:
            mismatches += 1
            print('mismatch for %s. expected %s got %s' % (z,repr(val),repr(val2)))
            print(repr(val))
            print(repr(val2))
    print('%s mismatches' % mismatches)
#@+node:ekr.20031218072017.1416: *5* app.__init__
def __init__(self):
    
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: print('leoApp.__init__')

    # These ivars are Leo's global vars.
    # leoGlobals.py contains global switches to be set by hand.
    
    # Command-line arguments...
    self.batchMode = False          # True: run in batch mode.
    self.enablePlugins = True       # True: run start1 hook to load plugins. --no-plugins
    self.gui = None                 # The gui class.
    self.guiArgName = None          # The gui name given in --gui option.
    self.qt_use_tabs = False        # True: allow tabbed main window.
    self.restore_session = False    # True: restore session on startup.
    self.save_session = False       # True: save session on close.
    self.silentMode = False         # True: no signon.
    self.start_fullscreen = False   # For qtGui plugin.
    self.start_maximized = False    # For qtGui plugin.
    self.start_minimized = False    # For qtGui plugin.
    self.translateToUpperCase = False # Never set to True.
    self.useIpython = False         # True: add support for IPython.
    self.use_psyco = False          # True: use psyco optimization.
    self.use_splash_screen = True   # True: put up a splash screen.

    # Debugging & statistics...
    self.count = 0                  # General purpose debugging count.
    self.debug = False              # Enable debugging. (Can be slow.)
    self.debugSwitch = 0            # 0: Brief; 1: Full.
    self.disableSave = False        # May be set by plugins.
    self.positions = 0              # The number of positions generated.
    self.scanErrors = 0             # The number of errors seen by g.scanError.
    self.statsDict = {}             # dict used by g.stat, g.clear_stats, g.print_stats.
    
    # Error messages...
    self.atPathInBodyWarning = None # Set by get_directives_dict.
    self.menuWarningsGiven = False  # True: supress warnings in menu code.
    self.unicodeErrorGiven = True   # True: suppres unicode tracebacks.
    
    # Global directories...
    self.extensionsDir = None   # The leo/extensions directory
    self.globalConfigDir = None # leo/config directory
    self.globalOpenDir = None   # The directory last used to open a file.
    self.homeDir = None         # The user's home directory.
    self.homeLeoDir = None      # The user's home/.leo directory.
    self.loadDir = None         # The leo/core directory.
    self.machineDir = None      # The machine-specific directory.
    
    # Global data...
    self.globalKillBuffer = []      # The global kill buffer.
    self.globalRegisters = {}       # The global register list.
    self.leoID = None               # The id part of gnx's.
    self.lossage = []               # List of last 100 keystrokes.
    self.numberOfUntitledWindows=0  # Number of opened untitled windows.
    self.windowList = []            # Global list of all frames.
    self.realMenuNameDict = {}      # Translations of menu names.
    
    # Global controller/manager objects...
    self.config = None              # The singleton leoConfig instance.
    self.db = None                  # The singleton leoCacher instance.
    self.loadManager = None         # The singleton LoadManager instance.
    # self.logManager = None        # The singleton LogManager instance.
    # self.openWithManager = None   # The singleton OpenWithManager instance.
    self.nodeIndices = None         # The singleton nodeIndices instance.
    self.pluginsController = None   # The singleton PluginsManager instance.
    self.sessionManager = None      # The singleton SessionManager instance.
    
    # Global status vars...
    
    if 1: #### To be moved to the Commands class...
        self.commandName = None         # The name of the command being executed.
        self.commandInterruptFlag=False # True: command within a command.
            
    self.dragging = False           # True: dragging.
    self.inBridge = False           # True: running from leoBridge module.
    self.inScript = False           # True: executing a script.
    self.initing  = True            # True: we are initiing the app.
    self.killed   = False           # True: we are about to destroy the root window.
    self.preReadFlag = False        # True: we are pre-reading a settings file.
    self.quitting = False           # True: quitting.  Locks out some events.
    self.reverting = False          # True: executing the revert command.
    
    #### To be moved to the LogManager.

    # The global log...
    self.log = None                 # The LeoFrame containing the present log.
    self.logInited = False          # False: all log message go to logWaiting list.
    self.logIsLocked = False        # True: no changes to log are allowed.
    self.logWaiting = []            # List of messages waiting to go to a log.
    self.printWaiting = []          # Queue of messages to be sent to the printer.
    self.signon = ''
    self.signon2 = ''
    self.signon_printed = False
    
    # Global types.
    import leo.core.leoFrame as leoFrame
    import leo.core.leoGui as leoGui
    self.nullGui = leoGui.nullGui()
    self.nullLog = leoFrame.nullLog()
    
    #### To be moved to OpenWithManager.
    
    # Open with data...
    self.hasOpenWithMenu = False    # True: open with plugin has been loaded.
    self.openWithFiles = []         # List of data used by Open With command.
    self.openWithFileNum = 0        # Number of Open-With temp file names.
    self.openWithTable = None       # Passed to createOpenWithMenuFromTable.
    
    #### To be moved to to the pluginsController.

    # Plugins and event handlers...
    self.afterHandler = None
    self.hookError = False      # True: suppress further calls to hooks.
    self.hookFunction = None    # Application wide hook function.
    self.idle_imported = False  # True: we have done an import idle
    self.idleTimeDelay = 100    # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False   # True: the global idleTimeHookHandler will reshedule itself.
    
    # Support for scripting...
    self.searchDict = {}    # For communication between find/change scripts.
    self.scriptDict = {}    # For use by scripts.

    # Unit testing...
    self.isExternalUnitTest = False # True: we are running a unit test externally.
    self.unitTestDict = {}          # For communication between unit tests and code.
    self.unitTestGui = None         # A way to override the gui in external unit tests.
    self.unitTesting = False        # True if unit testing.
    self.unitTestMenusDict = {}
        # Created in leoMenu.createMenuEntries for a unit test.
        # keys are command names. values are sets of strokes.

    # Define all global data.        
    self.define_global_constants()
    self.define_language_delims_dict()
    self.define_language_extension_dict()
    self.define_extension_dict()
    self.global_commands_dict = {}
#@+node:ekr.20031218072017.1417: *6* app.define_global_constants
def define_global_constants(self):

    # self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
    
    self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
    self.prolog_postfix_string = "?>"
    self.prolog_namespace_string = \
        'xmlns:leo="http://edreamleo.org/namespaces/leo-python-editor/1.1"'
#@+node:ekr.20120522160137.9909: *6* app.define_language_delims_dict
def define_language_delims_dict(self):

    self.language_delims_dict = {
        # Internally, lower case is used for all language names.
        # Keys are languages, values are 1,2 or 3-tuples of delims.
        "actionscript"       : "// /* */", #jason 2003-07-03
        "ada"                : "--",
        "ada95"              : "--",
        "ahk"                : ";",
        "antlr"              : "// /* */",
        "apacheconf"         : "#",
        "apdl"               : "!",
        "applescript"        : "-- (* *)",
        "asp"                : "<!-- -->",
        "aspect_j"           : "// /* */",
        "assembly_macro32"   : ";",
        "assembly_mcs51"     : ";",
        "assembly_parrot"    : "#",
        "assembly_r2000"     : "#",
        "assembly_x86"       : ";",
        "autohotkey"         : "; /* */", #TL - AutoHotkey language
        "awk"                : "#",
        "b"                  : "// /* */",
        "batch"              : "REM_", # Use the REM hack.
        "bbj"                : "/* */",
        "bcel"               : "// /* */",
        "bibtex"             : "%",
        "c"                  : "// /* */", # C, C++ or objective C.
        "chill"              : "/* */",
        "cobol"              : "*",
        "coldfusion"         : "<!-- -->",
        "config"             : "#", # Leo 4.5.1
        "cplusplus"          : "// /* */",
        "cpp"                : "// /* */",# C++.
        "csharp"             : "// /* */", # C#
        "css"                : "/* */", # 4/1/04
        "cweb"               : "@q@ @>", # Use the "cweb hack"
        "cython"             : "#",
        "d"                  : "// /* */",
        "doxygen"            : "#",
        "eiffel"             : "--",
        "elisp"              : ";",
        "erlang"             : "%",
        "factor"             : "! ( )",
        "forth"              : "\\_ _(_ _)", # Use the "REM hack"
        "fortran"            : "C",
        "fortran90"          : "!",
        "foxpro"             : "&&",
        "gettext"            : "# ",
        "groovy"             : "// /* */",
        "haskell"            : "--_ {-_ _-}",
        "haxe"               : "// /* */",
        "html"               : "<!-- -->",
        "i4gl"               : "-- { }",
        "icon"               : "#",
        "idl"                : "// /* */",
        "inform"             : "!",
        "ini"                : ";",
        "inno_setup"         : ";",
        "interlis"           : "/* */",
        "io"                 : "// */",
        "java"               : "// /* */",
        "javascript"         : "// /* */", # EKR: 2011/11/12: For javascript import test.
        "javaserverpage"     : "<%-- --%>", # EKR: 2011/11/25 (See also, jsp)
        "jhtml"              : "<!-- -->",
        "jmk"                : "#",
        "jsp"                : "<%-- --%>",
        "kshell"             : "#", # Leo 4.5.1.
        "latex"              : "%",
        "lilypond"           : "% %{ %}",
        "lisp"               : ";", # EKR: 2010/09/29
        "lotos"              : "(* *)",
        "lua"                : "--", # ddm 13/02/06
        "mail"               : ">",
        "makefile"           : "#",
        "maple"              : "//",
        "matlab"             : "%", # EKR: 2011/10/21
        "ml"                 : "(* *)",
        "modula3"            : "(* *)",
        "moin"               : "##",
        "mqsc"               : "*",
        "netrexx"            : "-- /* */",
        "noweb"              : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
        "nqc"                : "// /* */",
        "nsi"                : ";", # EKR: 2010/10/27
        "nsis2"              : ";",
        "objective_c"        : "// /* */",
        "objectrexx"         : "-- /* */",
        "occam"              : "--",
        "omnimark"           : ";",
        "pascal"             : "// { }",
        "perl"               : "#",
        "perlpod"            : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
        "php"                : "// /* */", # 6/23/07: was "//",
        "pike"               : "// /* */",
        "pl1"                : "/* */",
        "plain"              : "#", # We must pick something.
        "plsql"              : "-- /* */", # SQL scripts qt02537 2005-05-27
        "pop11"              : ";;; /* */",
        "postscript"         : "%",
        "povray"             : "// /* */",
        "powerdynamo"        : "// <!-- -->",
        "prolog"             : "% /* */",
        "psp"                : "<!-- -->",
        "ptl"                : "#",
        "pvwave"             : ";",
        "pyrex"              : "#",
        "python"             : "#",
        "r"                  : "#",
        "rapidq"             : "'", # fil 2004-march-11
        "rebol"              : ";", # jason 2003-07-03
        "redcode"            : ";",
        "rest"               : ".._",
        "rhtml"              : "<%# %>",
        "rib"                : "#",
        "rpmspec"            : "#",
        "rst"                : ".._",
        "ruby"               : "#", # thyrsus 2008-11-05
        "rview"              : "// /* */",
        "sas"                : "* /* */",
        "scala"              : "// /* */",
        "scheme"             : "; #| |#",
        "sdl_pr"             : "/* */",
        "sgml"               : "<!-- -->",
        "shell"              : "#",     # shell scripts
        "shellscript"        : "#",
        "shtml"              : "<!-- -->",
        "smalltalk"          : '" "', # Comments are enclosed in double quotes(!!)
        "smi_mib"            : "--",
        "splus"              : "#",
        "sqr"                : "!",
        "squidconf"          : "#",
        "ssharp"             : "#",
        "swig"               : "// /* */",
        "tcl"                : "#",
        "tcltk"              : "#",
        "tex"                : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
        "text"               : "#", # We must pick something.
        "texinfo"            : "@c",
        "tpl"                : "<!-- -->",
        "tsql"               : "-- /* */",
        "unknown"            : "#", # Set when @comment is seen.
        "unknown_language"   : '#--unknown-language--', # For unknown extensions in @shadow files.
        "uscript"            : "// /* */",
        "vbscript"           : "'",
        "velocity"           : "## #* *#",
        "verilog"            : "// /* */",
        "vhdl"               : "--",
        "vim"                : "\"",
        "vimoutline"         : "#", #TL 8/25/08 Vim's outline plugin
        "xml"                : "<!-- -->",
        "xsl"                : "<!-- -->",
        "xslt"               : "<!-- -->",
        "zpt"                : "<!-- -->",
        
        # These aren't real languages, or have no delims...
        # "cvs_commit"         : "",
        # "dsssl"              : "; <!-- -->",
        # "embperl"            : "<!-- -->",  # Internal colorizing state.
        # "freemarker"         : "",
        # "hex"                : "",
        # "jcl"                : "",
        # "patch"              : "",
        # "phpsection"         : "<!-- -->",  # Internal colorizing state.
        # "props"              : "#",         # Unknown language.
        # "pseudoplain"        : "",
        # "relax_ng_compact"   : "#",         # An xml schema.
        # "rtf"                : "",
        # "svn_commit"         : "",
    }
#@+node:ekr.20120522160137.9910: *6* app.define_language_extension_dict
def define_language_extension_dict (self):
    
    # Used only by c.getOpenWithExt.
    
    # Keys are languages, values are extensions.
    self.language_extension_dict = {
        "actionscript"  : "as", #jason 2003-07-03
        "ada"           : "ada",
        "ada95"         : "ada",
        "ahk"           : "ahk",
        "antlr"         : "g",
        "apacheconf"    : "conf",
        "apdl"          : "apdl",
        "applescript"   : "scpt",
        "asp"           : "asp",
        "aspect_j"      : "aj",
        "autohotkey"    : "ahk", #TL - AutoHotkey language
        "awk"           : "awk",
        "b"             : "b",
        "batch"         : "bat", # Leo 4.5.1.
        "bbj"           : "bbj",
        "bcel"          : "bcel",
        "bibtex"        : "bib",
        "c"             : "c",
        "chill"         : "ch",  # Only one extension is valid: .c186, .c286
        "cobol"         : "cbl", # Only one extension is valid: .cob
        "coldfusion"    : "cfm",
        "config"        : "cfg",
        "cplusplus"     : "c++",
        "cpp"           : "cpp",
        "css"           : "css", # 4/1/04
        "cweb"          : "w",
        "cython"        : "pyx", # Only one extension is valid at present: .pyi, .pyd.
        "d"             : "d",
        "eiffel"        : "e",
        "elisp"         : "el",
        "erlang"        : "erl",
        "factor"        : "factor",
        "forth"         : "forth",
        "fortran"       : "f",
        "fortran90"     : "f90",
        "foxpro"        : "prg",
        "gettext"       : "po",
        "groovy"        : "groovy",
        "haskell"       : "hs",
        "haxe"          : "hx",
        "html"          : "html",
        "i4gl"          : "i4gl",
        "icon"          : "icn",
        "idl"           : "idl",
        "inform"        : "inf",
        "ini"           : "ini",
        "inno_setup"    : "iss",
        "io"            : "io",
        "java"          : "java",
        "javascript"    : "js", # EKR: 2011/11/12: For javascript import test.
        "javaserverpage": "jsp", # EKR: 2011/11/25
        "jhtml"         : "jhtml",
        "jmk"           : "jmk",
        "jsp"           : "jsp",
        "kshell"        : "ksh", # Leo 4.5.1.
        "latex"         : "tex", # 1/8/04
        "lilypond"      : "ly",
        "lua"           : "lua", # ddm 13/02/06
        "mail"          : "eml",
        "makefile"      : "mak",
        "maple"         : "mpl",
        "matlab"        : "m",
        "ml"            : "ml",
        "modula3"       : "mod",
        "moin"          : "wiki",
        "mqsc"          : "mqsc",
        "noweb"         : "nw",
        "nqc"           : "nqc",
        "nsi"           : "nsi", # EKR: 2010/10/27
        "nsis2"         : "nsi",
        "objective_c"   : "mm", # Only one extension is valid: .m
        "objectrexx"    : "rex",
        "occam"         : "occ",
        "omnimark"      : "xom",
        "pascal"        : "p",
        "perl"          : "pl",
        "perlpod"       : "pod",
        "php"           : "php",
        "pike"          : "pike",
        "pl1"           : "pl1",
        "plain"         : "txt",
        "plsql"         : "sql", # qt02537 2005-05-27
        # "pop11"       : "p", # Conflicts with pascall.
        "postscript"    : "ps",
        "povray"        : "pov",
        "prolog"        : "pro",
        "psp"           : "psp",
        "ptl"           : "ptl",
        "pyrex"         : "pyx",
        "python"        : "py",
        "r"             : "r",
        "rapidq"        : "bas", # fil 2004-march-11
        "rebol"         : "r", # jason 2003-07-03
        "rhtml"         : "rhtml",
        "rib"           : "rib",
        "rst"           : "rest",
        "ruby"          : "rb", # thyrsus 2008-11-05
        "sas"           : "sas",
        "scala"         : "scala",
        "scheme"        : "scm",
        "sgml"          : "sgml",
        "shell"         : "sh", # DS 4/1/04
        "shellscript"   : "sh",
        "shtml"         : "shtml",
        "shtml"         : "ssi",
        "smalltalk"     : "sm",
        "splus"         : "splus",
        "sqr"           : "sqr",
        "ssharp"        : "ss",
        "swig"          : "i",
        "tcl"           : "tcl",
        "tcltk"         : "tcl",
        "tex"           : "tex",
        "texinfo"       : "info",
        "text"          : "txt",
        "tpl"           : "tpl",
        "tsql"          : "sql", # A guess.
        "unknown"       : "txt", # Set when @comment is seen.
        "uscript"       : "uc",
        "vbscript"      : "vbs",
        "velocity"      : "vtl",
        "verilog"       : "v",
        "vhdl"          : "vhd",
        "vhdl"          : "vhdl",
        "vim"           : "vim",
        "vimoutline"    : "otl", #TL 8/25/08 Vim's outline plugin
        "xml"           : "xml",
        "xsl"           : "xsl",
        "xslt"          : "xsl",
        "zpt"           : "zpt",
    }

    # These aren't real languages, or have no delims...
        # cvs_commit, dsssl, embperl, freemarker, hex, jcl,
        # patch, phpsection, progress, props, pseudoplain,
        # relax_ng_compact, rtf, svn_commit.

    # These have extensions which conflict with other languages.
        # assembly_macro32: .asm or .a
        # assembly_mcs51:   .asm or .a
        # assembly_parrot:  .asm or .a
        # assembly_r2000:   .asm or .a
        # assembly_x86:     .asm or .a
        # squidconf:        .conf
        # rpmspec:          .rpm
#@+node:ekr.20120522160137.9911: *6* app.define_extension_dict
def define_extension_dict(self):
    
    # Keys are extensions, values are languages
    self.extension_dict = {
        # "ada":    "ada",
        "ada":      "ada95", # modes/ada95.py exists.
        "ahk":      "ahk",
        "ahk":      "autohotkey",
        "aj":       "aspect_j",
        "apdl":     "apdl",
        "as":       "actionscript", #jason 2003-07-03
        "asp":      "asp",
        "awk":      "awk",
        "b":        "b",
        "bas":      "rapidq", # fil 2004-march-11
        "bat":      "batch",
        "bbj":      "bbj",
        "bcel":     "bcel",
        "bib":      "bibtex",
        "c":        "c",
        "c++":      "cplusplus",
        "cbl":      "cobol", # Only one extension is valid: .cob
        "cfg":      "config",
        "cfm":      "coldfusion",
        "ch":       "chill", # Other extensions, .c186,.c286
        "conf":     "apacheconf",
        "cpp":      "cpp",
        "css":      "css",
        "d":        "d",
        "e":        "eiffel",
        "el":       "elisp",
        "eml":      "mail",
        "erl":      "erlang",
        "f":        "fortran",
        "f90":      "fortran90",
        "factor":   "factor",
        "forth":    "forth",
        "g":        "antlr",
        "groovy":   "groovy",
        "h":        "c", # 2012/05/23.
        "hs":       "haskell",
        "html":     "html",
        "hx":       "haxe",
        "i":        "swig",
        "i4gl":     "i4gl",
        "icn":      "icon",
        "idl":      "idl",
        "inf":      "inform",
        "info":     "texinfo",
        "ini":      "ini",
        "io":       "io",
        "iss":      "inno_setup",
        "java":     "java",
        "jhtml":    "jhtml",
        "jmk":      "jmk",
        "js":       "javascript", # For javascript import test.
        "jsp":      "javaserverpage",
        "jsp":      "jsp",
        "ksh":      "kshell", # Leo 4.5.1.
        "lua":      "lua", # ddm 13/02/06
        "ly":       "lilypond",
        "m":        "matlab", # EKR: 2011/10/21
        "mak":      "makefile",
        "ml":       "ml",
        "mm":       "objective_c", # Only one extension is valid: .m
        "mod":      "modula3",
        "mpl":      "maple",
        "mqsc":     "mqsc",
        "nqc":      "nqc",
        "nsi":      "nsi", # EKR: 2010/10/27
        "nsi":      "nsis2",
        "nw":       "noweb",
        "occ":      "occam",
        "otl":      "vimoutline", #TL 8/25/08 Vim's outline plugin
        "p":        "pascal",
        # "p":      "pop11", # Conflicts with pascal.
        "php":      "php",
        "pike":     "pike",
        "pl":       "perl",
        "pl1":      "pl1",
        "po":       "gettext",
        "pod":      "perlpod",
        "pov":      "povray",
        "prg":      "foxpro",
        "pro":      "prolog",
        "ps":       "postscript",
        "psp":      "psp",
        "ptl":      "ptl",
        "py":       "python",
        "pyx":      "cython", # Other extensions, .pyd,.pyi
        "pyx":      "pyrex",
        # "r":      "r", # modes/r.py does not exist.
        "r":        "rebol", # jason 2003-07-03
        "rb":       "ruby", # thyrsus 2008-11-05
        "rest":     "rst",
        "rex":      "objectrexx",
        "rhtml":    "rhtml",
        "rib":      "rib",
        "sas":      "sas",
        "scala":    "scala",
        "scm":      "scheme",
        "scpt":     "applescript",
        "sgml":     "sgml",
        "sh":       "shell", # DS 4/1/04. modes/shell.py exists.
        # "sh":     "shellscript",
        "shtml":    "shtml",
        "sm":       "smalltalk",
        "splus":    "splus",
        "sql":      "plsql", # qt02537 2005-05-27
        "sql":      "tsql", # A guess.
        "sqr":      "sqr",
        "ss":       "ssharp",
        "ssi":      "shtml",
        "tcl":      "tcl", # modes/tcl.py exists.
        # "tcl":    "tcltk",
        "tex":      "latex",
        "tex":      "tex",
        "tpl":      "tpl",
        "txt":      "plain",
        "txt":      "text",
        "txt":      "unknown", # Set when @comment is seen.
        "uc":       "uscript",
        "v":        "verilog",
        "vbs":      "vbscript",
        "vhd":      "vhdl",
        "vhdl":     "vhdl",
        "vim":      "vim",
        "vtl":      "velocity",
        "w":        "cweb",
        "wiki":     "moin",
        "xml":      "xml",
        "xom":      "omnimark",
        "xsl":      "xsl",
        "xsl":      "xslt",
        "zpt":      "zpt",
    }

    # These aren't real languages, or have no delims...
        # cvs_commit, dsssl, embperl, freemarker, hex, jcl,
        # patch, phpsection, progress, props, pseudoplain,
        # relax_ng_compact, rtf, svn_commit.

    # These have extensions which conflict with other languages.
        # assembly_macro32: .asm or .a
        # assembly_mcs51:   .asm or .a
        # assembly_parrot:  .asm or .a
        # assembly_r2000:   .asm or .a
        # assembly_x86:     .asm or .a
        # squidconf:        .conf
        # rpmspec:          .rpm
        
    # Extra language extensions, used to associate extensions with mode files.
    # Used by importCommands.languageForExtension.
    # Keys are extensions, values are corresponding mode file (without .py)
    # A value of 'none' is a signal to unit tests that no extension file exists.
    self.extra_extension_dict = {
        'pod'   : 'perl',
        'unknown_language': 'none',
        'w'     : 'none', # cweb
    }
    
#@+node:ekr.20120522160137.9914: *5* @test consistency of leoApp tables
@
language_delims_dict 
    # Keys are languages, values are 1,2 or 3-tuples of delims. 
language_extension_dict
    # Keys are languages, values are extensions.
extension_dict = {
    # Keys are extensions, values are languages.
@c

delims_d    = g.app.language_delims_dict
lang_d      = g.app.language_extension_dict
ext_d       = g.app.extension_dict

for lang in lang_d:
    ext = lang_d.get(lang)
    assert lang in delims_d,'fail 1: %s' % lang
    assert ext in ext_d,'fail 2: %s' % ext
for ext in ext_d:
    lang = ext_d.get(ext)
    assert lang in lang_d,'fail 3: %s' % lang
#@+node:ekr.20120519193038.9883: *3* Code
#@+node:ekr.20110518103946.18179: *4* Added external/leosax.py to leoPyRef.leo
http://groups.google.com/group/leo-editor/browse_thread/thread/93f2cc88ebbf9893
#@+node:ekr.20120330040023.9781: *3* Features
#@+node:ekr.20120409074150.9941: *4* baseNativeTree.onHeadChanged now truncates headlines
@nocolor-node

The new code works like leoTree.onHeadChanged.

The code can be called twice, so it is a bit tricky
to only issue warnings once.
#@+node:ekr.20061008140603: *5* TM.runEditCommandTest
def runEditCommandTest (self,p):

    tm = self
    c = self.c
    atTest = p.copy()
    w = c.frame.body.bodyCtrl

    h = atTest.h
    assert h.startswith('@test '),'expected head: %s, got: %s' % ('@test',h)
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, 'no command: %s' % (commandName)

    work,before,after = tm.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node,h in ((work,'work'),(before,before_h),(after,after_h)):
        h2 = node.h
        assert h2.startswith(h),'expected head: %s, got: %s' % (h,h2)

    sels = []
    for node,h in ((before,before_h),(after,after_h)):
        sel = node.h[len(h):].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    sel1,sel2 = sels
    #g.trace(repr(sels))

    c.selectPosition(work)
    c.setBodyString(work,before.b)
    #g.trace(repr(sel1[0]),repr(sel1[1]))
    w.setSelectionRange(sel1[0],sel1[1],insert=sel1[1])
    c.k.simulateCommand(commandName)
    s1 = work.b ; s2 = after.b
    assert s1 == s2, 'mismatch in body\nexpected: %s\n     got: %s' % (repr(s2),repr(s1))
    sel3 = w.getSelectionRange()
    ins = w.toGuiIndex(w.getInsertPoint())
    #g.trace('ins',ins,'s1[j:...]',repr(s1[j:j+10]))
    # Convert both selection ranges to gui indices.
    sel2_orig = sel2
    # g.trace(w)
    assert len(sel2) == 2,'Bad headline index.  Expected index,index.  got: %s' % sel2
    i,j = sel2 ; sel2 = w.toGuiIndex(i),w.toGuiIndex(j)
    assert len(sel3) == 2,'Bad headline index.  Expected index,index.  got: %s' % sel3
    i,j = sel3 ; sel3 = w.toGuiIndex(i),w.toGuiIndex(j)
    assert sel2 == sel3, 'mismatch in sel\nexpected: %s = %s, got: %s' % (sel2_orig,sel2,sel3)
    c.selectPosition(atTest)
    atTest.contract()
    # Don't redraw.
#@+node:ekr.20110605121601.17912: *5* onHeadChanged (nativeTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None,e=None):

    '''Officially change a headline.'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; u = c.undoer
    if not p:
        if trace: g.trace('** no p')
        return

    item = self.getCurrentItem()
    if not item:
        if trace and verbose: g.trace('** no item')
        return
    if not e:
        e = self.getTreeEditorForItem(item)
    if not e:
        if trace and verbose: g.trace('** not editing')
        return

    s = g.u(e.text())

    if g.doHook("headkey1",c=c,p=c.p,v=c.p,s=s):
        return

    self.closeEditorHelper(e,item)
    oldHead = p.h
    changed = s != oldHead
    if changed:
        # New in Leo 4.10.1.
        if trace: g.trace('new',repr(s),'old',repr(p.h))
        << truncate s if it has multiple lines >>
        p.initHeadString(s)
        item.setText(0,s) # Required to avoid full redraw.
        undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)

    g.doHook("headkey2",c=c,p=c.p,v=c.p,s=s)

    # This is a crucial shortcut.
    if g.unitTesting: return

    if changed:
        self.redraw_after_head_changed()

    if 0: # Don't do this: it interferes with clicks, and is not needed.
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()

    p.v.contentModified()
    c.outerUpdate()
#@+node:ekr.20120409185504.10028: *6* << truncate s if it has multiple lines >>
# Remove trailing newlines before warning of truncation.
while s and s[-1] == '\n':
    s = s[:-1]

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    s = s[:i]
    if s != oldHead:
        g.es("truncating headline to one line",color="blue")

limit = 1000
if len(s) > limit:
    s = s[:limit]
    if s != oldHead:
        g.es("truncating headline to",limit,"characters",color="blue")
#@+node:ekr.20120411095406.10036: *4* Sorted statistics in profile_leo
#@+node:ekr.20031218072017.2607: *5* profile_leo (runLeo.py)
@ To gather statistics, do the following in a console window:
    
    python profileLeo.py <list of .leo files>
@c

def profile_leo ():

    """Gather and print statistics about Leo"""
    
    # Work around a Python distro bug: can fail on Ubuntu.
    try:
        import pstats
    except ImportError:
        g.es_print('can not import pstats: this is a Python distro bug')
        g.es_print('https://bugs.launchpad.net/ubuntu/+source/python-defaults/+bug/123755')
        g.es_print('try installing pstats yourself')
        return

    import cProfile as profile
    import leo.core.leoGlobals as g
    import os

    theDir = os.getcwd()

    # On Windows, name must be a plain string. An apparent cProfile bug.
    name = str(g.os_path_normpath(g.os_path_join(theDir,'leoProfile.txt')))
    print ('profiling to %s' % name)
    profile.run('import leo ; leo.run()',name)
    p = pstats.Stats(name)
    p.strip_dirs()
    # p.sort_stats('module','calls','time','name')
    p.sort_stats('cumulative','time')
    #reFiles='leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'
    #p.print_stats(reFiles)
    p.print_stats()

prof = profile_leo
#@+node:ekr.20120410175141.10027: *4* Added --no-plugins option
#@+node:ekr.20120219154958.10486: *5* LM.scanOptions & helper
def scanOptions(self,fileName,pymacs):

    '''Handle all options, remove them from sys.argv and set lm.options.'''

    trace = False
    lm = self
    
    # print('scanOptions',sys.argv)

    # Note: this automatically implements the --help option.
    parser = optparse.OptionParser()
    add = parser.add_option
    
    add('--fullscreen',   action="store_true",
        help = 'start fullscreen (Qt only)')
    add('--ipython',      action="store_true",dest="use_ipython",
        help = 'enable ipython support')
    add('--gui',
        help = 'gui to use (qt/qttabs)')
    add('--maximized',    action="store_true",
        help = 'start maximized (Qt only)')
    add('--minimized',    action="store_true",
        help = 'start minimized')
    add('--no-cache',     action="store_true", dest='no_cache',
        help = 'disable reading of cached files')
    add('--no-plugins',   action="store_true", dest='no_plugins',
        help = 'disable all plugins')
    add('--no-splash',    action="store_true", dest='no_splash_screen',
        help = 'disable the splash screen')
    add('--screen-shot',  dest='screenshot_fn',
        help = 'take a screen shot and then exit')
    add('--script',       dest="script",
        help = 'execute a script and then exit')
    add('--script-window',dest="script_window",
        help = 'open a window for scripts')
    add('--select',       dest='select',
        help='headline or gnx of node to select')
    add('--session-restore',action="store_true",dest='session_restore',
        help = 'restore previously saved session tabs at startup')
    add('--session-save',action="store_true",dest='session_save',
        help = 'save session tabs on exit')
    add('--silent',       action="store_true", dest="silent",
        help = 'disable all log messages')
    add('--version',      action="store_true", dest="version",
        help='print version number and exit')
    add('--window-size',  dest='window_size',
        help='initial window size in height x width format')

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    if trace:
        # print('scanOptions:',sys.argv)
        g.trace('options',options)

    # Handle the args...

    # --gui
    gui = options.gui

    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            g.app.qt_use_tabs = True
        elif gui in ('curses','qt','null'):
            g.app.qt_use_tabs = False
        else:
            print('scanOptions: unknown gui: %s.  Using qt gui' % gui)
            gui = 'qt'
            g.app.qt_use_tabs = False
    elif sys.platform == 'darwin':
        gui = 'qt'
        g.app.qt_use_tabs = False
    else:
        gui = 'qttabs'
        g.app.qt_use_tabs = True

    assert gui
    g.app.guiArgName = gui
    
    # --ipython
    g.app.useIpython = options.use_ipython
    if trace: g.trace('g.app.useIpython',g.app.useIpython)
    
    # --fullscreen
    # --minimized
    # --maximized
    g.app.start_fullscreen = options.fullscreen
    g.app.start_maximized = options.maximized
    g.app.start_minimized = options.minimized

    # --no-cache
    if options.no_cache:
        if trace: print('scanOptions: disabling caching')
        g.enableDB = False
        
    # --no-plugins
    if options.no_plugins:
        if trace: print('scanOptions: disabling plugins')
        g.app.enablePlugins = False
        
    # --no-splash
    # g.trace('--no-splash',options.no_splash_screen)
    g.app.use_splash_screen = not options.no_splash_screen
    
    # --screen-shot=fn
    screenshot_fn = options.screenshot_fn
    if screenshot_fn:
        screenshot_fn = screenshot_fn.strip('"')
        if trace: print('scanOptions: screenshot_fn',screenshot_fn)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        script,e = g.readFileIntoString(script_name,kind='script:')
        # print('script_name',repr(script_name))
    else:
        script = None
        # if trace: print('scanOptions: no script')

    # --select
    select = options.select
    if select:
        select = select.strip('"')
        if trace: print('scanOptions: select',repr(select))
        
    # --session-restore & --session-save
    g.app.restore_session = bool(options.session_restore)
    g.app.save_session = bool(options.session_save)

    # --silent
    g.app.silentMode = options.silent
    # print('scanOptions: silentMode',g.app.silentMode)

    # --version: print the version and exit.
    versionFlag = options.version
    

    # --window-size
    windowSize = options.window_size
    if windowSize:
        if trace: print('windowSize',repr(windowSize))
        try:
            h,w = windowSize.split('x')
        except ValueError:
            windowSize = None
            g.trace('bad --window-size:',windowSize)
            
    # Compute lm.files
    lm.files = lm.computeFilesList(fileName)
    
    # Post-process the options.
    if pymacs:
        script = None
        windowFlag = None

    # Compute the return values.
    windowFlag = script and script_path_w
    d = {
        'gui':gui,
        'screenshot_fn':screenshot_fn,
        'script':script,
        'select':select,
        'version':versionFlag,
        'windowFlag':windowFlag,
        'windowSize':windowSize,
    }
    
    if trace: g.trace(d)

    return d
#@+node:ekr.20120219154958.10483: *6* LM.computeFilesList
def computeFilesList(self,fileName):

    lm = self
    files = []
    if fileName:
        files.append(fileName)

    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)

    return [lm.completeFileName(z) for z in files]
#@+node:ekr.20120305084218.9915: *4* Show all commands after <alt-x><tab>
@nocolor-node

A simple change to k.computeCompletionList was all that was needed.

#@+node:ekr.20120415133744.10050: *4* Make sure tab completion only happens on explicit tab
#@+node:ekr.20061031131434.111: *5* fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    trace = False and not g.unitTesting
    verbose = True
    k = self ; c = k.c ; gui = g.app.gui
    recording = c.macroCommands.recordingMacro
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    c.check_event(event)
    ch = char = event and event.char or ''
    stroke = event and event.stroke or None

    if trace: g.trace('recording',recording,'state',state,char)
    
    # 2011/06/06: remember these events also.
    if recording:
        c.macroCommands.startRecordingMacro(event)
        
    if state > 0:
        k.setLossage(char,stroke)
    
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif char == 'Ins' or k.isFKey(char):
        pass
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n','Return'):
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif char in ('\t','Tab'):
        if trace and verbose: g.trace('***Tab')
        k.doTabCompletion(list(c.commandsDict.keys()),allow_empty_completion=True)
        c.minibufferWantsFocus()
    elif char in ('\b','BackSpace'):
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return # (for Tk) 'break'
#@+node:ekr.20061031131434.112: *6* callAltXFunction
def callAltXFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event and event.widget
        if hasattr(w,'permanent') and not w.permanent:
            g.es('Can not execute commands from headlines')
        else:
            c.widgetWantsFocusNow(event and event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(commandName)
    else:
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
#@+node:ekr.20061031131434.128: *5* k.getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    trace = False and not g.app.unitTesting
    state = k.getState('getArg')
    
    c.check_event(event)
    
    # 2011/06/06: remember these events also.
    if c.macroCommands.recordingMacro and state > 0:
        c.macroCommands.startRecordingMacro(event)

    char = event and event.char or ''
    if state > 0:
        k.setLossage(char,stroke)
    
    if trace: g.trace(
        'state',state,'char',repr(char),'stroke',repr(stroke),
        'isPlain',k.isPlainKey(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n','Return',) or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes:
            k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = char ##
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        if trace: g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif char in('\t','Tab'):
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif char in ('\b','BackSpace'):
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        pass
        # 2011/03/01: ignore F-keys. Ignoring all except plain keys would kill unicode searches.
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return # (for Tk) 'break'
#@+node:ekr.20061031131434.129: *6* << init altX vars >>
k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@+node:ekr.20061031131434.178: *5* k.doTabCompletion
# Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList,redraw=True,allow_empty_completion=False):

    '''Handle tab completion when the user hits a tab.'''

    k = self ; c = k.c ; s = k.getLabel().strip()

    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        # g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex >= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        if redraw:
            # g.trace('** recomputing default completions')
            k.computeCompletionList(defaultTabList,
                backspace=False,
                allow_empty_completion=allow_empty_completion)

    c.minibufferWantsFocus()
#@+node:ekr.20061031131434.175: *5* k.computeCompletionList
# Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace,allow_empty_completion=False):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)
    c.frame.log.clearTab(tabName)
    
    if not k.mb_tabList and allow_empty_completion:
        if command:
            # 2012/05/20: Put up an *empty* list as a visual cue.
            k.mb_tabList = []
            g.es('','\n',tabName=tabName)
        else:
            # 2012/05/20: Return *all* completions if the command is empty.
            k.mb_tabList = sorted(defaultTabList)
            common_prefix = ''

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.
        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)

        inverseBindingDict = k.computeInverseBindingDict()
        data,n = [],0
        for commandName in k.mb_tabList:
            dataList = inverseBindingDict.get(commandName,[('',''),])
            for z in dataList:
                pane,key = z
                s1a = '%s ' % (pane) if pane != 'all:' else ''
                s1b = k.prettyPrintKey(key)
                s1 = s1a + s1b
                s2 = commandName
                data.append((s1,s2),)
                n = max(n,len(s1))
        aList = ['%*s %s' % (-n,s1,s2) for s1,s2 in data]
        g.es('','\n'.join(aList),tabName=tabName)
    c.bodyWantsFocus()
#@+node:ekr.20111017132257.15891: *4* IPython now works with all versions of IPython
#@+node:ekr.20120330110655.10023: *5*  Notes
@language rest

Investigate how IPython hijacks event loops
http://groups.google.com/group/leo-editor/browse_thread/thread/e1dc6439bf8b17f9

pyos_inputhook is relevant

IPython lib.inputhook
http://ipython.org/ipython-doc/stable/api/generated/IPython.lib.inputhook.html


* IPython seems to require Python 2.x.
* I can run IPython from either C:\prog\ipython-0.12 or from python\lib\site-packages

From C:\prog\ipython-0.12\IPython\scripts

#!/usr/bin/env python
"""Terminal-based IPython entry point.
"""

from IPython.frontend.terminal.ipapp import launch_new_instance

launch_new_instance()

Here is ipapi.get::

@language python

    def get():
        """Get the global InteractiveShell instance."""
        from IPython.core.interactiveshell import InteractiveShell
        return InteractiveShell.instance()
#@+node:ekr.20120330110655.10025: *6* @url ipython api
http://ipython.org/ipython-doc/rel-0.12/api/index.html
#@+node:ekr.20120330110655.10024: *6* @url ipython-dev archive
http://mail.scipy.org/pipermail/ipython-dev/
#@+node:ekr.20120330110655.10026: *6* @url ipython.core.interactiveshell
http://ipython.org/ipython-doc/rel-0.12/api/generated/IPython.core.interactiveshell.html
#@+node:ekr.20120403093858.10043: *6* pylint

c:\leo.repo\trunk>pylint -r

E0602:182:LeoWorkbook.<lambda>: Undefined variable 'c'
E0602:205:LeoWorkbook.require: Undefined variable '_leo_push_history'
E1101:241:GlobalIPythonManager.embed_ipython: Instance of 'GlobalIPythonManager' has no 'qtApp' member
E1103:290:GlobalIPythonManager.get_history: Instance of 'list' has no 'get' member (but some types could not be inferred
)
E0602:325:GlobalIPythonManager.init_ipython: Undefined variable 'push_mark_req'
E0602:326:GlobalIPythonManager.init_ipython: Undefined variable 'push_cl_node'
E0602:329:GlobalIPythonManager.init_ipython: Undefined variable 'push_ipython_script'
E0602:330:GlobalIPythonManager.init_ipython: Undefined variable 'push_plain_python'
E0602:331:GlobalIPythonManager.init_ipython: Undefined variable 'push_ev_node'
E1101:344:GlobalIPythonManager.expose_ileo_push: Instance of 'GlobalIPythonManager' has no 'push_from_leo' member
E0602:426:GlobalIPythonManager.new_push_to_ipython: Undefined variable 'ipy_leo'
E0602:445:GlobalIPythonManager.push_cl_node: Undefined variable 'c'
E0602:462:GlobalIPythonManager.push_ev_node: Undefined variable 'ip'
E0602:523:GlobalIPythonManager.push_mark_req: Undefined variable '_leo_push_history'
E0602:536:GlobalIPythonManager.push_plain_python: Undefined variable 'ip'
E1101:549:GlobalIPythonManager.run_leo_startup_node: Instance of 'GlobalIPythonManager' has no 'push_from_leo' member
E0602:764:LeoNode.ipush: Undefined variable 'push_from_leo'
W0106:787:LeoNode.script: Expression "(" Method to get the 'tangled' contents of the node\n\n            (parse @others,
 %s references etc.)\n            ") % (g.angleBrackets(' section '))" is assigned to nothing
E1101:966:add_var: Class 'LeoNode' has no 'p' member
E1101:971:add_var: Class 'LeoNode' has no 'p' member
E1101:990:all_cells: Class 'LeoNode' has no 'p' member
E1101:1009:edit_macro: Function 'edit_object_in_leo' has no 'when_type' member
E1101:1121:rootnode: Class 'LeoNode' has no 'p' member
R0923:601:LeoInterface: Interface not implemented
('EKR: exit status', 14)

c:\leo.repo\trunk>
#@+node:ekr.20120401144849.10152: *6* What I did
@language rest

- Import logic looks for legacy IPython first (0.11 and prev),
  then looks for new-style IPython (0.12 and above).

- Created GlobalIPythonManager class, assigned to leoIPython.gipm and g.app.gipm.

- Added self.c ivar to LeoNode class.  This is the same as p.v.context.
#@+node:ekr.20120415174008.10062: *5* Startup...
#@+node:ekr.20110605121601.18134: *6* init (qtGui.py top level) (qtPdb)
def init():
    
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace and g.trace_startup: print('qtGui.__init__')

    if g.app.unitTesting: # Not Ok for unit testing!
        return False

    if not QtCore:
        return False

    if g.app.gui:
        return g.app.gui.guiName() == 'qt'
    else:
        g.app.gui = leoQtGui()

        # Override g.pdb
        def qtPdb(message=''):
            if message: print(message)
            import pdb
            if not g.app.useIpython:
                QtCore.pyqtRemoveInputHook()
            pdb.set_trace()
        g.pdb = qtPdb

        g.app.gui.finishCreate()
        g.plugin_signon(__name__)
        return True
#@+node:ekr.20110605121601.18483: *6* runMainLoop (qtGui)
def runMainLoop(self):

    '''Start the Qt main loop.'''
    
    g.app.gui.dismiss_splash_screen()
    
    if self.script:
        log = g.app.log
        if log:
            g.pr('Start of batch script...\n')
            log.c.executeScript(script=self.script)
            g.pr('End of batch script')
        else:
            g.pr('no log, no commander for executeScript in qtGui.runMainLoop')
    elif g.app.useIpython and g.app.ipm:
        # g.app.ipm exists only if IPython was imported properly.
        g.app.ipm.embed_ipython()
            # Runs main loop and calls sys.exit.
    else:
        sys.exit(self.qtApp.exec_())
#@+node:ekr.20120401144849.10116: *6* start_new_api
def start_new_api(self):

    # No c is available: we can't get @string ipython_argv setting.
    sys.argv =  ['ipython']
    
    self.started = True

    # Prints signon.
    # self.ip set in update_commander.
    ipapp.launch_new_instance()

        # Doesn't print signon.
        # shell = ishell.TerminalInteractiveShell()
        # self.ip = shell
        # shell.mainloop()
#@+node:ekr.20120415174008.10061: *5* Conversion to new api...
#@+node:ekr.20120415174008.10063: *6* get_ip
def get_ip (self):
    
    """Get the global InteractiveShell instance."""
    
    shell = InteractiveShell.instance()
    
    return shell
#@+node:ekr.20120401144849.10140: *6* pushToIPythonCommand (g.command push-to-ipython)
@g.command('push-to-ipython')
def pushToIPythonCommand(event=None):

    '''The push-to-ipython command.

    IPython must be started, but the commander need not be inited.'''
    
    trace = False and not g.unitTesting
    
    # Ensure that the correct commander is set.
    startIPython(event=event)
    
    g_ipm.push_to_ipython()
#@+node:ekr.20120401144849.10142: *6* push_to_ipython
def push_to_ipython(self):
    
    c,ip = self.c,self.ip
    if not c:
        return g.trace('can not happen: no c.')
        
    if not self.ip:
        return g.trace('can not happen: no ip.')
        
    c.inCommand = False # Disable the command lockout logic
        
    n = LeoNode(c.p)
    
    def f(self=self,n=n):
        self.push_ipython_script(n)
        return True
    d = CommandChainDispatcher()
    d.add(f)
    d()
#@+node:ekr.20120415133744.10049: *6* Found: ip.IP
#@+node:ekr.20120401144849.10084: *7* get_history
def get_history(self,hstart = 0):
    res = []
    
    ip = self.ip
    
    if g_legacy:
        ihist = ip.IP.input_hist
        ihist_raw = ip.IP.input_hist_raw
        ohist = ip.IP.output_hist
    else:
        m = ip.history_manager
        ihist = m.input_hist_parsed
        ihist_raw = m.input_hist_raw
        ohist = m.output_hist

    # for idx in range(hstart, len(ip.IP.input_hist)):
    for idx in range(hstart, len(ihist)):
        val = ohist.get(idx,None)
        has_output = True
        # inp = ip.IP.input_hist_raw[idx]
        inp = ihist_raw[idx]
        if inp.strip():
            res.append('In [%d]: %s' % (idx, inp))
        if val:
            res.append(pprint.pformat(val))
            res.append('\n')    
    return ''.join(res)
#@+node:ekr.20120401144849.10099: *7* push_ipython_script
def push_ipython_script(self,node):
    """ Execute the node body in IPython,
    as if it was entered in interactive prompt """
    
    trace = False
    c = self.c
    ip = self.ip
    try:
        if 0:
            g.trace()
            for z in sorted(dir(ip)):
                print('%30s %s' % (z,getattr(ip,z).__class__))
        
        if g_legacy:
            ihist = ip.IP.input_hist
            ohist = ip.IP.output_hist 
            hstart = len(ip.IP.input_hist)
        else:
            m = ip.history_manager
            hstart = ip.history_length
            ihist = m.input_hist_parsed
            ohist = m.output_hist

        if trace:
            g.trace('ihist',ihist)
            g.trace('ohist',ohist)
    
        script = node.script()

        # The current node _p needs to handle
        # wb.require() and recursive ipushes.
        old_p = ip.user_ns.get('_p',None)
        ip.user_ns['_p'] = node
        
        if g_legacy:
            ip.runlines(script)
        else:
            ip.runcode(script)

        ip.user_ns['_p'] = old_p
        if old_p is None:
            del ip.user_ns['_p']

        has_output = False
        # for idx in range(hstart,len(ip.IP.input_hist)):
        for idx in range(hstart,len(ihist)):
            val = ohist.get(idx,None)
            if val is not None:
                has_output = True
                # inp = ip.IP.input_hist[idx]
                inp = ihist[idx]
                if inp.strip():
                    es('In: %s' % (inp[:40], ))
                es('<%d> %s' % (idx,pprint.pformat(ohist[idx],width=40)))

        if not has_output:
            es('ipy run: %s (%d LL)' %(node.h,len(script)))
    finally:
        # if trace: g.trace('end push_ipython_script')
        c.redraw()
#@+node:ekr.20120401144849.10091: *7* mb_completer
def mb_completer(event):
    
    """ Custom completer for minibuffer """
    
    c = g_ipm.c
    ip = g_ipm.ip

    cmd_param = event.line.split()
    if event.line.endswith(' '):
        cmd_param.append('')
        
    if len(cmd_param) > 2:
        if g_legacy:
            return ip.IP.Completer.file_matches(event.symbol)
        else:
            completer = IPCompleter(shell=ip,
                namespace=ip.user_ns,
                global_namespace=None,
                alias_table=None,
                use_readline=True,
                config=None)
            return completer.file_matches(event.symbol)

    return sorted(list(c.commandsDict.keys()))
#@+node:ekr.20120415174008.10064: *5* Inited IPython properly
@nocolor-node

- Replaced push_from_leo by CommandChainDispatcher().
#@+node:ekr.20120401144849.10102: *6* push_position_from_leo
def push_position_from_leo(self,p):
    
    try:
        d = CommandChainDispatcher(LeoNode(p))
        d()

    except AttributeError as e:
        if e.args == ("Commands instance has no attribute 'frame'",):
            es("Error: ILeo not associated with .leo document")
            es("Press alt+shift+I to fix!")
        else:
            raise
#@+node:ekr.20120401144849.10098: *6* push_from_leo
# push_from_leo = CommandChainDispatcher()
#@+node:ekr.20120401063816.10144: *6* init_ipython
def init_ipython(self):
    
    """ This will be run by _ip.load('ipy_leo') 

    Leo still needs to run update_commander() after this.

    """
    
    ip = self.ip
    # g.trace(ip)
    
    if self.inited:
        return
    
    self.show_welcome()

    #### Shell.hijack_tk()
    ip.set_hook('complete_command',mb_completer,str_key = '%mb')
    
    f = ip.expose_magic if g_legacy else ip.define_magic
    
    f('mb',mb_f)
    f('lee',lee_f)
    f('leoref',leoref_f)
    f('lleo',lleo_f)    
    f('lshadow',lshadow_f)
    f('lno',lno_f)

    # Note that no other push command should EVER have lower than 0
    g_ipm.expose_ileo_push(g_ipm.push_mark_req,-1)
    g_ipm.expose_ileo_push(g_ipm.push_cl_node,100)
    # this should be the LAST one that will be executed,
    # and it will never raise TryNext.
    g_ipm.expose_ileo_push(g_ipm.push_ipython_script,1000)
    g_ipm.expose_ileo_push(g_ipm.push_plain_python,100)
    g_ipm.expose_ileo_push(g_ipm.push_ev_node,100)
    
    ip.set_hook('pre_prompt_hook',ileo_pre_prompt_hook) 
        
    # global wb
    # wb = LeoWorkbook()
    ip.user_ns['wb'] = self.wb
#@+node:ekr.20120401144849.10119: *6* show_welcome
def show_welcome(self):

    print("------------------")
    print("Welcome to Leo-enabled IPython session!")
    print("Try %leoref for quick reference.")

    if g_legacy:
        import IPython.platutils as u
        u.set_term_title('ILeo')
        u.freeze_term_title()
    else:
        import IPython.utils.terminal as u
        u.toggle_set_term_title(True)
        u.set_term_title('ILeo')
#@+node:ekr.20120419095424.9924: *4* Integrated free_layout into Leo's core
#@+node:ekr.20120217070122.10470: *5* c.initObjects
def initObjects(self,gui):
    
    trace = (False or g.trace_startup) and not g.unitTesting
    c = self
    
    if trace:
        print('g.initObjects %s %s' % (
            c.shortFileName(),g.app.gui))

    self.hiddenRootNode = leoNodes.vnode(context=c)
    self.hiddenRootNode.setHeadString('<hidden root vnode>')
    
    # Create the gui frame.
    title = c.computeWindowTitle(c.mFileName)
    
    if not g.app.initing:
        g.doHook("before-create-leo-frame",c=c)

    self.frame = gui.createLeoFrame(c,title)
    assert self.frame
    assert self.frame.c == c
    
    self.nodeHistory = nodeHistory(c)
    
    self.initConfigSettings()

    c.setWindowPosition() # Do this after initing settings.

    # Break circular import dependencies by importing here.
    # These imports take almost 3/4 sec in the leoBridge.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoCache as leoCache
    import leo.core.leoChapters as leoChapters
    import leo.core.leoEditCommands as leoEditCommands
    import leo.core.leoKeys as leoKeys
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoRst as leoRst
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoTest as leoTest
    import leo.core.leoUndo as leoUndo
    
    self.keyHandler = self.k = leoKeys.keyHandlerClass(c)
    self.chapterController  = leoChapters.chapterController(c)
    self.shadowController   = leoShadow.shadowController(c)
    self.fileCommands       = leoFileCommands.fileCommands(c)
    self.atFileCommands     = leoAtFile.atFile(c)
    self.importCommands     = leoImport.leoImportCommands(c)
    self.rstCommands        = leoRst.rstCommands(c)
    self.tangleCommands     = leoTangle.tangleCommands(c)
    self.testManager        = leoTest.TestManager(c)
    
    self.editCommandsManager = leoEditCommands.EditCommandsManager(c)
    self.editCommandsManager.createEditCommanders()

    self.cacher = leoCache.cacher(c)
    self.cacher.initFileDB(self.mFileName)
    self.undoer = leoUndo.undoer(self)
    
    import leo.plugins.free_layout as free_layout
    self.free_layout = free_layout.FreeLayoutController(c)
#@+node:tbrown.20110203111907.5521: *5* init (free_layout.py)
def init():
    
    if 1:
        return g.app.gui.guiName() == "qt"
    else:
        # g.trace('free_layout.py')
        if g.app.gui.guiName() != "qt":
            return False
    
        g.registerHandler('after-create-leo-frame',bindControllers)
        g.registerHandler('after-create-leo-frame2',loadLayouts)
        g.plugin_signon(__name__)
        
        return True
#@+node:ekr.20110318080425.14390: *5*  ctor (FreeLayoutController)
def __init__ (self,c):
    
    # g.trace('(FreeLayoutController)',c) # ,g.callers(files=True))
    
    # if hasattr(c,'free_layout'):
        # return
    
    self.c = c
    
    # c.free_layout = self
        # To be removed
    
    self.windows = []  
    # list of top level free-layout windows opened from 'Open Window'
    # splitter handle context menu
    
    # g.registerHandler('after-create-leo-frame',self.bindControllers)
    
    # attach to an outline
    g.registerHandler('after-create-leo-frame',self.init)
    
    # now that the outline's set up (plugins etc.), load layout for
    # outline, can't do that sooner as plugins must be loaded first
    # to provide their widgets in panels etc.
    g.registerHandler('after-create-leo-frame2',self.loadLayouts)
    
    ### self.init()
    
#@+node:tbrown.20110203111907.5522: *5* init (FreeLayoutController)
def init(self,tag,keys):
    """Attach to an outline and
    
    - add tags to widgets to indicate that they're essential
      (tree, body, log-window-tabs) and
      
    - tag the log-window-tabs widget as the place to put widgets
      from free-laout panes which are closed
      
    - register this FreeLayoutController as a provider of menu items
      for NestedSplitter
    """

    c = self.c

    if c != keys.get('c'):
        return
        
    # g.trace(c.frame.title)

    # Careful: we could be unit testing.

    splitter = self.get_top_splitter() # A NestedSplitter.
    if not splitter:
        # g.trace('no splitter!')
        return None
        
    # by default NestedSplitter's context menus are disabled, needed
    # once to globally enable them
    NestedSplitter.enabled = True

    # when NestedSplitter disposes of children, it will either close
    # them, or move them to another designated widget.  Here we set
    # up two designated widgets

    logTabWidget = splitter.findChild(QtGui.QWidget, "logTabWidget")
    splitter.root.holders['_is_from_tab'] = logTabWidget
    splitter.root.holders['_is_permanent'] = 'TOP'

    # allow body and tree widgets to be "removed" to tabs on the log tab panel    
    bodyWidget = splitter.findChild(QtGui.QFrame, "bodyFrame")
    bodyWidget._is_from_tab = "Body"

    treeWidget = splitter.findChild(QtGui.QFrame, "outlineFrame")
    treeWidget._is_from_tab = "Tree"
    # also the other tabs will have _is_from_tab set on them by the
    # offer_tabs menu callback above

    # if the log tab panel is removed, move it back to the top splitter
    logWidget = splitter.findChild(QtGui.QFrame, "logFrame")
    logWidget._is_permanent = True

    # tag core Leo components (see ns_provides)
    splitter.findChild(QtGui.QWidget, "outlineFrame")._ns_id = '_leo_pane:outlineFrame'
    splitter.findChild(QtGui.QWidget, "logFrame")._ns_id = '_leo_pane:logFrame'
    splitter.findChild(QtGui.QWidget, "bodyFrame")._ns_id = '_leo_pane:bodyFrame'

    splitter.register_provider(self)
#@+node:ekr.20120419095424.9927: *5* loadLayouts (FreeLayoutController)
def loadLayouts(self,tag,keys):
    
    c = self.c
    
    if c != keys.get('c'):
        return
        
    # g.trace(c.frame.title)
  
    layout = c.config.getData("free-layout-layout")
    
    if layout:
        layout = json.loads('\n'.join(layout))
        
    if '_ns_layout' in c.db:
        name = c.db['_ns_layout']
        if layout:
            g.es("NOTE: embedded layout in @settings/@data free-layout-layout " \
                "overrides saved layout "+name)
        else:
            layout = g.app.db['ns_layouts'][name]

    if layout:
        # Careful: we could be unit testing.
        splitter = c.free_layout.get_top_splitter()
        if splitter:
            splitter.load_layout(layout)
#@+node:ekr.20110605121601.18503: *5* runScrolledMessageDialog (qtGui)
def runScrolledMessageDialog (self,
    short_title= '',
    title='Message',
    label= '',
    msg='',
    c=None,**kw
):

    if g.unitTesting: return None

    def send(title=title, label=label, msg=msg, c=c, kw=kw):
        return g.doHook('scrolledMessage',
            short_title=short_title,title=title,
            label=label, msg=msg,c=c, **kw)

    if not c or not c.exists:
        << no c error>>
    else:        
        retval = send()
        if retval: return retval
        << load viewrendered plugin >>
        retval = send()
        if retval: return retval
        << no dialog error >>

    << emergency fallback >>
#@+node:ekr.20110605121601.18504: *6* << no c error>>
g.es_print_error('%s\n%s\n\t%s' % (
    "The qt plugin requires calls to g.app.gui.scrolledMessageDialog to include 'c'",
    "as a keyword argument",
    g.callers()
))
#@+node:ekr.20110605121601.18505: *6* << load viewrendered plugin >>
pc = g.app.pluginsController
# 2011/10/20: load viewrendered (and call vr.onCreate)
# *only* if not already loaded.
if not pc.isLoaded('viewrendered.py'):
    vr = pc.loadOnePlugin('viewrendered.py')
    if vr:
        g.es('viewrendered plugin loaded.', color='blue')
        vr.onCreate('tag',{'c':c})
#@+node:ekr.20110605121601.18506: *6* << no dialog error >>
g.es_print_error(
    'No handler for the "scrolledMessage" hook.\n\t%s' % (
        g.callers()))
#@+node:ekr.20110605121601.18507: *6* << emergency fallback >>
b = QtGui.QMessageBox
d = b(None) # c.frame.top)
d.setWindowFlags(QtCore.Qt.Dialog) # That is, not a fixed size dialog.

d.setWindowTitle(title)
if msg: d.setText(msg)
d.setIcon(b.Information)
yes = d.addButton('Ok',b.YesRole)
c.in_qt_dialog = True
d.exec_()
c.in_qt_dialog = False
#@+node:ekr.20120429125741.10056: *4* created parse-body command
@nocolor-node

Useful for re-parsing text that was not originally parsed properly.
#@+node:ekr.20120429125741.10057: *5* @g.command(parse-body)
@g.command('parse-body')
def parse_body_command(event):
    
    c = event.get('c')
    p = c and c.p
    if not c or not p: return
    ic = c.importCommands
    ic.tab_width = ic.getTabWidth()
    language = g.scanForAtLanguage(c,p)
    ext = g.app.language_extension_dict.get(language)
    if ext:
        if not ext.startswith('.'): ext = '.' + ext
        func = ic.importDispatchDict.get(ext)
        if func:
            bunch = c.undoer.beforeChangeTree(p)
            s = p.b
            p.b = ''
            func(s,p,atAuto=False)
            bunch = c.undoer.afterChangeTree(p,'parse-body',bunch)
            c.validateOutline()
            p.expand()
            c.redraw()
            return
    g.es_print('unknown language')
#@+node:ekr.20120517124200.9985: *4* Support vimoutliner imports and @auto-otl
#@+node:ekr.20120518080359.10006: *5* at.writeAtAutoOtlFile
def writeAtAutoOtlFile (self,root):

    """Write all the *descendants* of an @auto-otl node."""

    at = self
    
    def put(s):
        '''Take care with output newlines.'''
        at.os(s[:-1] if s.endswith('\n') else s)
        at.onl()

    for child in root.children():
        n = child.level()
        for p in child.self_and_subtree():
            indent = '\t'*(p.level()-n)
            put('%s%s' % (indent,p.h))
            for s in p.b.splitlines(False):
                put('%s: %s' % (indent,s))
            
    root.setVisited()
    return True
#@+node:ekr.20120517124200.9983: *5* class vimoutlinerScanner
class vimoutlinerScanner(baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        baseScannerClass.__init__(self,
            importCommands,atAuto=atAuto,language='plain')
                # Use @language plain.

        # Overrides of base-class ivars.
        self.fullChecks = False
        self.hasDecls = False

        # The stack of valid parents at each level.
        self.parents = []

    @others
#@+node:ekr.20120519091649.10016: *6* scanHelper & helpers
# Override baseScannerClass.scanHelper.

def scanHelper(self,s,i,end,parent,kind):
    
    '''Create Leo nodes for all vimoutliner lines.'''

    trace = False and not g.unitTesting
    assert kind == 'outer' and end == len(s)

    while i < len(s):
        # Set k to the end of the line.
        progress = i
        k = g.skip_line(s,i)
        line = s[i:k] # For traces.

        # Skip leading hard tabs, ignore blanks & compute the line's level.
        level = 1 # The root has level 0.
        while i < len(s) and s[i].isspace():
            if s[i] == '\t': level += 1
            i += 1

        if i == k:
            g.trace('ignoring blank line: %s' % (repr(line)))
        elif i < len(s) and s[i] == ':':
            # Append the line to the body.
            i += 1
            if i < len(s) and s[i] == ' ':
                i += 1
            else:
                g.trace('missing space after colon: %s' % (repr(line)))
            p = self.findParent(level)
            p.b = p.b + s[i:k]
        else:
            putRef = True

            # Cut back the stack, then allocate a new (placeholder) node.
            self.parents = self.parents[:level]
            p = self.findParent(level)

            # Set the headline of the placeholder node.
            h = s[i:k]
            p.h = h[:-1] if h.endswith('\n') else h

        # Move to the next line.
        i = k
        assert progress < i,'i: %s %s' % (i,repr(line))

    return len(s),putRef,0 # bodyIndent not used.
#@+node:ekr.20120517155536.10132: *7* findParent
def findParent(self,level):
    
    '''Return the parent at the indicated level, allocating
    place-holder nodes as necessary.'''
    
    trace = False and not g.unitTesting
    assert level >= 0
    
    if not self.parents:
        self.parents = [self.root]

    if trace: g.trace(level,[z.h for z in self.parents])
        
    while level >= len(self.parents):
        b = ''
        h = 'placeholder' if level > 1 else 'declarations'
        parent = self.parents[-1]
        p = self.createHeadline(parent,b,h)
        self.parents.append(p)
        
    return self.parents[level]
#@+node:ekr.20120517155536.10131: *7* createNode
def createNode (self,b,h,level):
    
    parent = self.findParent(level)
    p = self.createHeadline(parent,b,h)
    self.parents = self.parents[:level+1]
    self.parents.append(p)
#@+node:ekr.20120519114248.9886: *4* Change focus-border color depending on input state
@nocolor-node

Leo now supports two new setting, with the indicated default::

    @color focus_border_command_state_color = blue
    @color focus_border_overwrite_state_color = green

This works in conjunction with the existing border-color setting::

    @color focus_border_color = red

So by default, the color border is red when in insert state, and blue
if in command state.

This allows the focus border to change color depending on whether we
are in input or command mode.  This is a workaround for the (extreme)
difficulty of changing cursors depending on mode.

When used to distinguish insert from command modes, I recommend
changing the existing setting::

    @int focus_border_width = 1

to::

    @int focus_border_width = 2

This makes the focus border much more visible, and makes the color
changes obvious.

I tested this code without changing bindings using the set-command-
state command.

As before, if you don't want any such colored borders, just do::

    @bool use_focus_border = False 
#@+node:ekr.20090213065933.6: *5* c.initConfigSettings
def initConfigSettings (self):

    '''Init all cached commander config settings.'''
    
    trace = (False or g.trace_startup) and not g.unitTesting
    c = self

    if trace:
        print('c.initConfigSettings: c.configInited: %s %s' % (
            c.configInited,c.shortFileName()))
            
    getBool = c.config.getBool
    getColor = c.config.getColor
    getData  = c.config.getData
    getInt = c.config.getInt

    c.autoindent_in_nocolor     = getBool('autoindent_in_nocolor_mode')
    c.collapse_nodes_after_move = getBool('collapse_nodes_after_move')
        # Patch by nh2: 0004-Add-bool-collapse_nodes_after_move-option.patch
    c.collapse_on_lt_arrow      = getBool('collapse_on_lt_arrow',default=True)
        # 2011/11/09: An excellent, subliminal, improvement.
    c.contractVisitedNodes      = getBool('contractVisitedNodes')
    c.fixed                     = getBool('fixedWindow',default=False)
    c.fixedWindowPosition       = getData('fixedWindowPosition')
    c.focus_border_color        = getColor('focus_border_color') or 'red'
    c.focus_border_command_state_color = getColor(
        'focus_border_command_state_color') or 'blue'
    c.focus_border_overwrite_state_color = getColor(
        'focus_border_overwrite_state_color') or 'green'
    c.focus_border_width        = getInt('focus_border_width') or 1 # pixels
    c.outlineHasInitialFocus    = getBool('outline_pane_has_initial_focus')
    # c.showMinibuffer            = getBool('useMinibuffer')
        # This option is a bad idea.
    c.page_width                = getInt('page_width') or 132
        # 2012/02/27: this appears to be a fix of an *ancient* bug.
    c.putBitsFlag               = getBool('put_expansion_bits_in_leo_files',default=True)
    c.sparse_move               = getBool('sparse_move_outline_left')
    c.sparse_find               = getBool('collapse_nodes_during_finds')
    c.sparce_spell              = getBool('collapse_nodes_while_spelling')
    c.stayInTreeAfterSelect     = getBool('stayInTreeAfterSelect')
    c.stayInTreeAfterEdit       = getBool('stayInTreeAfterEditHeadline')
    c.smart_tab                 = getBool('smart_tab')
        # Note: there is also a smart_auto_indent setting.
    c.tab_width                 = getInt('tab_width') or -4
    c.use_body_focus_border     = getBool('use_body_focus_border',default=True)
    c.use_focus_border          = getBool('use_focus_border',default=True)
    c.write_script_file         = getBool('write_script_file')

    # g.trace('smart %s, tab_width %s' % (c.smart_tab, c.tab_width))
    # g.trace(c.sparse_move)
#@+node:ekr.20111022215436.16685: *5* Borders (qtGui)
def add_border(self,c,w):

    state = c.k and c.k.unboundKeyAction
    
    # g.trace(state,hasattr(w,'viewport'),w,g.callers())

    if state and c.use_focus_border and hasattr(w,'viewport'):
        w = w.viewport()
        d = {
            'command':  c.focus_border_command_state_color,
            'insert':   c.focus_border_color,
            'overwrite':c.focus_border_overwrite_state_color,
        }
        color = d.get(state,c.focus_border_color)
        sheet = "border: %spx solid %s" % (c.focus_border_width,color)
        self.update_style_sheet(w,'border',sheet)

def remove_border(self,c,w):
    
    # g.trace(hasattr(w,'viewport'),w)

    if c.use_focus_border and hasattr(w,'viewport'):
        w = w.viewport()
        # g.trace(w)
        sheet = "border: %spx solid white" % c.focus_border_width
        self.update_style_sheet(w,'border',sheet)
#@+node:ekr.20061031131434.74: *5* class keyHandlerClass
class keyHandlerClass:

    '''A class to support emacs-style commands.'''

    @others
#@+node:ekr.20061031131434.75: *6*  k.Birth
#@+node:ekr.20061031131434.76: *7* k.__init__
def __init__ (self,c):

    '''Create a key handler for c.'''
    
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: print('k.__init__')

    self.c = c
    self.dispatchEvent = None
    self.inited = False         # Set at end of finishCreate.
    self.swap_mac_keys = False  #### How to init this ????
    self.w = None
            # Note: will be None for nullGui.

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    
    # Access to data types defined in leoKeys.py
    self.KeyStroke = g.KeyStroke
    
    # Define all ivars...
    self.defineExternallyVisibleIvars()
    self.defineInternalIvars()
    self.defineSettingsIvars()
    
    if g.new_modes:
        self.modeController = ModeController(c)

    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None # Set by AutoCompleter.start.

    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction() # 2011/02/09
#@+node:ekr.20061031131434.78: *7* k.defineExternallyVisibleIvars
def defineExternallyVisibleIvars(self):

    self.abbrevOn = False
        # True: abbreviations are on.
    self.arg = ''
        # The value returned by k.getArg.
    self.argSelectedText = '' # The selected text in state 0.
    self.commandName = None # The name of the command being executed.
    self.funcReturn = None # For k.simulateCommand
    self.getArgEscape = None # A signal that the user escaped getArg in an unusual way.
    self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
    self.inputModeBindings = {}
    self.inputModeName = '' # The name of the input mode, or None.
    self.inverseCommandsDict = {}
        # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
    self.modePrompt = '' # The mode promopt.
    self.negativeArg = False
    self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
    # self.regx = g.bunch(iter=None,key=None)
    self.repeatCount = None
    self.state = g.bunch(kind=None,n=None,handler=None)
#@+node:ekr.20061031131434.79: *7* k.defineInternalIvars
def defineInternalIvars(self):

    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of ShortcutInfo's.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are ShortcutInfo's.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    self.mb_help = False
    
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.fullCommandKey = None
    self.universalArgKey = None
    
    # Keepting track of the characters in the mini-buffer...
    self.arg_completion = True
    self.mb_event = None
    self.mb_history = []
    self.mb_prefix = ''
    self.mb_tabListPrefix = ''
    self.mb_tabList = []
    self.mb_tabListIndex = -1
    self.mb_prompt = ''
    
    self.func = None
    self.previous = []
    self.stroke = None
    
    # For onIdleTime...
    self.idleCount = 0
    
    # For modes...
    self.afterGetArgState = None
    self.argTabList = []
    self.getArgEscapes = []
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
#@+node:ekr.20080509064108.7: *7* k.defineMultiLineCommands
def defineMultiLineCommands (self):

    k = self

    k.multiLineCommandList = [
        # editCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # keyHandlerCommandsClass
        'repeat-complex-command',
        # killBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # queryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # rectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # registerCommandsClass
        'jump-to-register',
        'point-to-register',
        # searchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
#@+node:ekr.20120217070122.10479: *7* k.defineSettingIvars
def defineSettingsIvars(self):
    
    # Part 1: These were in the ctor.
    c = self.c
    getBool  = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter           = getBool('enable_autocompleter_initially')
    self.enable_calltips                = getBool('enable_calltips_initially')
    self.ignore_caps_lock               = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color    = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_warning_color       = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color         = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys                  = getBool('swap_mac_keys')
    
    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings       = c.config.getBool('enable_alt_ctrl_bindings')
    
    # Part 2: These were in finishCreate.
    
    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body_text_background_color') or 'white'
    fg = c.config.getColor('body_text_foreground_color') or 'black'

    self.command_mode_bg_color    = getColor('command_mode_bg_color') or bg
    self.command_mode_fg_color    = getColor('command_mode_fg_color') or fg
    self.insert_mode_bg_color     = getColor('insert_mode_bg_color') or bg
    self.insert_mode_fg_color     = getColor('insert_mode_fg_color') or fg
    self.overwrite_mode_bg_color  = getColor('overwrite_mode_bg_color') or bg
    self.overwrite_mode_fg_color  = getColor('overwrite_mode_fg_color') or fg
    self.unselected_body_bg_color = getColor('unselected_body_bg_color') or bg
    self.unselected_body_fg_color = getColor('unselected_body_fg_color') or bg
    
    # g.trace(self.c.shortFileName())
#@+node:ekr.20080509064108.6: *7* k.defineSingleLineCommands
def defineSingleLineCommands (self):

    k = self

    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # editCommandsClass
        'back-to-indentation',
        'back-to-home', # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # keyHandlerCommandsClass
        # 'auto-complete',
        'negative-argument',
        'number-command',
        'number-command-0',
        'number-command-1',
        'number-command-2',
        'number-command-3',
        'number-command-4',
        'number-command-5',
        'number-command-6',
        'number-command-7',
        'number-command-8',
        'universal-argument',
        # killBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # macroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere',              # 2011/06/07
        'set-find-node-only',               # 2011/06/07
        'set-find-suboutline-only',         # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
        # registerCommandsClass
        'append-to-register',
        'copy-to-register',
        'insert-register',
        'prepend-to-register',
    ]
#@+node:ekr.20070123085931: *7* k.defineSpecialKeys
def defineSpecialKeys (self):

    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''

    k = self
    
    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&" : "ampersand",
        "^" : "asciicircum",
        "~" : "asciitilde",
        "*" : "asterisk",
        "@" : "at",
        "\\": "backslash",
        "|" : "bar",
        "{" : "braceleft",
        "}" : "braceright",
        "[" : "bracketleft",
        "]" : "bracketright",
        ":" : "colon",      # removed from code.
        "," : "comma",
        "$" : "dollar",
        "=" : "equal",
        "!" : "exclam",     # removed from code.
        ">" : "greater",
        "<" : "less",
        "-" : "minus",
        "#" : "numbersign",
        '"' : "quotedbl",
        "'" : "quoteright",
        "(" : "parenleft",
        ")" : "parenright", # removed from code.
        "%" : "percent",
        "." : "period",     # removed from code.
        "+" : "plus",
        "?" : "question",
        "`" : "quoteleft",
        ";" : "semicolon",
        "/" : "slash",
        " " : "space",      # removed from code.
        "_" : "underscore",
    }
    
    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s

    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict:
        k.guiBindNamesInverseDict [k.guiBindNamesDict.get(key)] = key
#@+node:ekr.20070123143428: *7* k.defineTkNames
def defineTkNames (self):

    k = self

    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left','Right','Up','Down',
        # Page up/down keys.
        'Next','Prior',
        # Home end keys.
        'Home','End'
        # Modifier keys.
        'Caps_Lock','Num_Lock',
        # F-keys.
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        # All others.
        'Begin','Break','Clear','Delete','Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace','Linefeed','Return','Tab',
    )

    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp'    : 'BackSpace', # Dubious: should be '\b'
        'dnarrow' : 'Down',
        'esc'     : 'Escape',
        'ltarrow' : 'Left',
        'pageup'  : 'Prior',
        'pagedn'  : 'Next',
        'rtarrow' : 'Right',
        'uparrow' : 'Up',
    }

    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict [s.lower()] = s

@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
#@+node:ekr.20061031131434.80: *7* k.finishCreate & helpers
def finishCreate (self):

    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: print('k.finishCreate')

    k = self ; c = k.c
    self.w = c.frame.miniBufferWidget
        # Will be None for nullGui.

    k.createInverseCommandsDict()
    k.makeAllBindings()
    self.inited = True

    k.setDefaultInputState()
    k.resetLabel()
#@+node:ekr.20061031131434.81: *8* createInverseCommandsDict
def createInverseCommandsDict (self):

    '''Add entries to k.inverseCommandsDict using c.commandDict.

    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict:
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))

        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())
#@+node:ekr.20061101071425: *7* oops
def oops (self):

    g.trace('Should be defined in subclass:',g.callers(4))
#@+node:ekr.20110209093958.15413: *7* setDefaultEditingKeyAction (New)
def setDefaultEditingAction (self):

    k = self ; c = k.c

    action = c.config.getString('default_editing_state') or 'insert'
    action.lower()

    if action not in ('command','insert','overwrite'):
        g.trace('ignoring default_editing_state: %s' % (action))
        action = 'insert'

    self.defaultEditingAction = action
#@+node:ekr.20061031131434.82: *7* setDefaultUnboundKeyAction
def setDefaultUnboundKeyAction (self,allowCommandState=True):

    k = self ; c = k.c

    # g.trace(g.callers())

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()

    if defaultAction == 'command' and not allowCommandState:
        self.unboundKeyAction = 'insert'
    elif defaultAction in ('command','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % (defaultAction))
        self.unboundKeyAction = 'insert'

    # g.trace(self.unboundKeyAction)

    self.defaultUnboundKeyAction = self.unboundKeyAction

    k.setInputState(self.defaultUnboundKeyAction)
#@+node:ekr.20061031131434.88: *6* k.Binding
#@+node:ekr.20061031131434.89: *7* k.bindKey & helpers
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False,tag=None):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.
    
    tag gives the source of the binding.
    
    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    if not k.check_bind_key(commandName,pane,shortcut):
        return False

    aList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %17s %s' % (pane,shortcut,tag,commandName))
    try:
        if not shortcut:
            stroke = None
        elif g.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s,stroke
        else:
            stroke = k.strokeFromSetting(shortcut)

        si = g.ShortcutInfo(kind=tag,pane=pane,
            func=callback,commandName=commandName,stroke=stroke)
    
        if shortcut: #####
            k.bindKeyToDict(pane,shortcut,si)
        if not modeFlag:
            if shortcut:
                alist = k.remove_conflicting_definitions(
                    aList,commandName,pane,shortcut)
        aList.append(si)
        if shortcut:
            assert stroke
            k.bindingsDict [stroke] = aList
            if trace: g.trace(shortcut,aList)
        return True
    except Exception: # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20120130074511.10228: *8* k.check_bind_key
def check_bind_key(self,commandName,pane,shortcut):
    
    if not shortcut:
        return False

    k = self
    assert g.isStroke(shortcut)

    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter','leave'):
        if shortcut.lower().find(s) > -1:
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return False

    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    else:
        return True
#@+node:ekr.20120130074511.10227: *8* k.kill_one_shortcut
def kill_one_shortcut (self,stroke):
    
    '''Update the dicts so that c.config.getShortcut(name) will return None
    for all names *presently* bound to the stroke.'''
    
    k = self ; c = k.c
    lm = g.app.loadManager
    
    # A crucial shortcut: inverting and uninverting dictionaries is slow.
    # Important: the comparison is valid regardless of the type of stroke.
    if stroke in (None,'None','none'):
        return
        
    assert g.isStroke(stroke),stroke
        
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.ShortcutInfo)

    inv_d = lm.invert(d)
    aList = inv_d.get(stroke,[])
    inv_d[stroke] = []
    
    c.config.shortcutsDict = lm.uninvert(inv_d)
#@+node:ekr.20061031131434.92: *8* k.remove_conflicting_definitions
def remove_conflicting_definitions (self,aList,commandName,pane,shortcut):
    
    trace = False and not g.unitTesting
    k = self
    result = []
    for si in aList:
        assert g.isShortcutInfo(si),si
        if pane in ('button','all',si.pane):
            if trace:
                # This is too annoying to report here. See bug 951921.
                g.es_print('c for %s in %s' % (
                    si.stroke,k.c.shortFileName()))
                g.es_print('previous: %s new: %s' % (si.commandName,commandName))
            k.kill_one_shortcut(shortcut)
        else:
            result.append(si)
    return result
#@+node:ekr.20061031131434.93: *8* k.bindKeyToDict
def bindKeyToDict (self,pane,stroke,si):
    
    '''Update k.masterBindingsDict for the stroke.'''

    trace = False and not g.unitTesting
        # and stroke.lower().find('tab') != -1 
    k = self
    
    assert g.isStroke(stroke),stroke
    
    # New in Leo 4.4.1: Allow redefintions.
    d = k.masterBindingsDict.get(pane,{})
    d[stroke] = si
    k.masterBindingsDict [pane] = d
#@+node:ekr.20061031131434.94: *8* k.bindOpenWith
def bindOpenWith (self,d):

    '''Register an open-with command.'''

    k = self ; c = k.c
    
    shortcut = d.get('shortcut')
    name = d.get('name')
    
    # g.trace(d)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,d=d):
        return c.openWith(d=d)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='all',verbose=False)
#@+node:ekr.20061031131434.95: *7* k.checkBindings
def checkBindings (self):

    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''

    k = self ; c = k.c

    if not c.config.getBool('warn_about_missing_settings'): return

    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&','')
        if not c.config.exists(key,'shortcut'):
            if abbrev:
                g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))
#@+node:ekr.20061031131434.97: *7* k.completeAllBindings
def completeAllBindings (self,w=None):

    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''

    # g.trace(w)

    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke),repr(stroke)
        k.makeMasterGuiBinding(stroke,w=w)
#@+node:ekr.20061031131434.96: *7* k.completeAllBindingsForWidget
def completeAllBindingsForWidget (self,w):

    k = self

    # g.trace('w',w,'Alt+Key-4' in d)

    for stroke in k.bindingsDict:
        assert g.isStroke(stroke),repr(stroke)
        k.makeMasterGuiBinding(stroke,w=w)
#@+node:ekr.20070218130238: *7* k.dumpMasterBindingsDict
def dumpMasterBindingsDict (self):

    k = self ; d = k.masterBindingsDict

    g.pr('\nk.masterBindingsDict...\n')

    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            si = d2.get(key2)
            assert g.isShortcutInfo(si),si
            g.pr('%20s %s' % (key2,si.commandName))
#@+node:ekr.20061031131434.99: *7* k.initAbbrev
def initAbbrev (self):

    k = self ; c = k.c ; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName,key)

def initOneAbbrev (self,commandName,key):
    k = self ; c = k.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s',key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            # g.trace(key,commandName,func.__name__)
            c.commandsDict [key] = func
            # k.inverseCommandsDict[func.__name__] = key
        else:
            g.es_print('bad abbrev:',key,'unknown command name:',commandName,color='blue')
#@+node:ekr.20061031131434.101: *7* k.initSpecialIvars
def initSpecialIvars (self):

    '''Set ivars for special keystrokes from previously-existing bindings.'''

    k = self ; c = k.c
    trace = False or c.config.getBool('trace_bindings_verbose')
    warn  = c.config.getBool('warn_about_missing_settings')

    for ivar,commandName in (
        ('fullCommandKey',  'full-command'),
        ('abortAllModesKey','keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
        ('autoCompleteForceKey','auto-complete-force'),
    ):
        junk, aList = c.config.getShortcut(commandName)
        aList,found = aList or [], False
        for pane in ('text','all'):
            for si in aList:
                assert g.isShortcutInfo(si),si
                if si.pane == pane:
                    if trace: g.trace(commandName,si.stroke)
                    setattr(k,ivar,si.stroke)
                    found = True; break
        if not found and warn:
            g.trace('no setting for %s' % commandName)
#@+node:ekr.20061031131434.98: *7* k.makeAllBindings
def makeAllBindings (self):

    k = self ; c = k.c

    # g.trace(c.shortFileName())

    k.bindingsDict = {}
    if g.new_modes:
        k.modeController.addModeCommands()
    else:
        k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    c.frame.body.createBindings()
    c.frame.log.setTabBindings('Log')
    if c.frame.statusLine: c.frame.statusLine.setBindings()
    c.frame.tree.setBindings()
    c.frame.setMinibufferBindings()
    k.completeAllBindings()
    k.checkBindings()
#@+node:ekr.20061031131434.102: *7* k.makeBindingsFromCommandsDict & helper
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    
    if trace:
        g.trace('makeBindingsFromCommandsDict entry')
        t1 = time.time()

    # Step 1: Create d2.
    # Keys are strokes. Values are lists of si with si.stroke == stroke.
    d = c.commandsDict
    d2 = g.TypedDictOfLists(
        name='makeBindingsFromCommandsDict helper dict',
        keyType=g.KeyStroke,valType=g.ShortcutInfo)
   
    for commandName in sorted(d.keys()):
        command = d.get(commandName)
        key, aList = c.config.getShortcut(commandName)
        for si in aList:
            assert isinstance(si,g.ShortcutInfo)
            # Important: si.stroke is already canonicalized.
            stroke = si.stroke
            si.commandName = commandName
            if stroke:
                assert g.isStroke(stroke)
                d2.add(stroke,si)

    # Step 2: make the bindings.
    if trace: t2 = time.time()
        
    for stroke in sorted(d2.keys()):
        aList2 = d2.get(stroke)
        for si in aList2:
            assert isinstance(si,g.ShortcutInfo)
            commandName = si.commandName
            command = c.commandsDict.get(commandName)
            tag = si.kind
            pane = si.pane
            if stroke and not pane.endswith('-mode'):
                k.bindKey(pane,stroke,command,commandName,tag=tag)
                
    if trace:
        t3 = time.time()
        g.trace('%0.2fsec' % (t2-t1))
        g.trace('%0.2fsec' % (t3-t2))
#@+node:ekr.20061031131434.103: *7* k.makeMasterGuiBinding
def makeMasterGuiBinding (self,stroke,w=None):

    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''

    k = self ; c = k.c ; f = c.frame

    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas = f.tree and hasattr(f.tree,'canvas') and f.tree.canvas   or None
        if 0: # Canvas and bindingWidget bindings are now set in tree.setBindings.
            widgets = (c.miniBufferWidget,bodyCtrl)
        else:
            widgets = (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)

    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke,event.w)
        return k.masterKeyHandler(event) # ,stroke=stroke)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(stroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [stroke] = aList
#@+node:ekr.20061031131434.104: *6* k.Dispatching
#@+node:ekr.20061031131434.111: *7* fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    trace = False and not g.unitTesting
    verbose = True
    k = self ; c = k.c ; gui = g.app.gui
    recording = c.macroCommands.recordingMacro
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    c.check_event(event)
    ch = char = event and event.char or ''
    stroke = event and event.stroke or None

    if trace: g.trace('recording',recording,'state',state,char)
    
    # 2011/06/06: remember these events also.
    if recording:
        c.macroCommands.startRecordingMacro(event)
        
    if state > 0:
        k.setLossage(char,stroke)
    
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif char == 'Ins' or k.isFKey(char):
        pass
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n','Return'):
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif char in ('\t','Tab'):
        if trace and verbose: g.trace('***Tab')
        k.doTabCompletion(list(c.commandsDict.keys()),allow_empty_completion=True)
        c.minibufferWantsFocus()
    elif char in ('\b','BackSpace'):
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return # (for Tk) 'break'
#@+node:ekr.20061031131434.112: *8* callAltXFunction
def callAltXFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event and event.widget
        if hasattr(w,'permanent') and not w.permanent:
            g.es('Can not execute commands from headlines')
        else:
            c.widgetWantsFocusNow(event and event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(commandName)
    else:
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
#@+node:ekr.20061031131434.113: *7* k.endCommand
def endCommand (self,commandName):

    '''Make sure Leo updates the widget following a command.

    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            k.commandName = None
            c.editCommandsManager.initAllEditCommanders()
            
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # g.pr('endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers())
            k.newMinibufferWidget = None
#@+node:ekr.20061031131434.114: *6* k.Externally visible commands
#@+node:ekr.20061031131434.115: *7* digitArgument & universalArgument
def universalArgument (self,event):

    '''Prompt for a universal argument.'''
    k = self
    k.setLabelBlue('Universal Argument: ',protect=True)
    k.universalDispatcher(event)

def digitArgument (self,event):

    '''Prompt for a digit argument.'''
    k = self
    k.setLabelBlue('Digit Argument: ',protect=True)
    k.universalDispatcher(event)
#@+node:ekr.20070613133500: *7* k.menuCommandKey
def menuCommandKey (self,event=None):

    # This method must exist, but it never gets called.
    pass 
#@+node:ekr.20070613190936: *7* k.propagateKeyEvent
def propagateKeyEvent (self,event):
    
    '''Open a menu.'''

    # self.oops() # Should be overridden.
#@+node:ekr.20061031131434.117: *7* negativeArgument (redo?)
def negativeArgument (self,event):

    '''Prompt for a negative digit argument.'''
    
    g.trace('not ready yet')
    
    # k = self ; state = k.getState('neg-arg')

    # if state == 0:
        # k.setLabelBlue('Negative Argument: ',protect=True)
        # k.setState('neg-arg',1,k.negativeArgument)
    # else:
        # k.clearState()
        # k.resetLabel()
        # func = k.negArgFunctions.get(k.stroke)
        # if func:
            # func(event)
#@+node:ekr.20061031131434.118: *7* numberCommand
def numberCommand (self,event,stroke,number):
    
    '''Enter a number prefix for commands.'''

    k = self ; c = self.c
    k.stroke = stroke
    w = event and event.widget
    
    k.universalDispatcher(event)
    g.app.gui.event_generate(c,chr(number),chr(number),w)
    return # (for Tk) 'break'

def numberCommand0 (self,event):
    '''Execute command number 0.'''
    return self.numberCommand (event,None,0)

def numberCommand1 (self,event):
    '''Execute command number 1.'''
    return self.numberCommand (event,None,1)

def numberCommand2 (self,event):
    '''Execute command number 2.'''
    return self.numberCommand (event,None,2)

def numberCommand3 (self,event):
    '''Execute command number 3.'''
    return self.numberCommand (event,None,3)

def numberCommand4 (self,event):
    '''Execute command number 4.'''
    return self.numberCommand (event,None,4)

def numberCommand5 (self,event):
    '''Execute command number 5.'''
    return self.numberCommand (event,None,5)

def numberCommand6 (self,event):
    '''Execute command number 6.'''
    return self.numberCommand (event,None,6)

def numberCommand7 (self,event):
    '''Execute command number 7.'''
    return self.numberCommand (event,None,7)

def numberCommand8 (self,event):
    '''Execute command number 8.'''
    return self.numberCommand (event,None,8)

def numberCommand9 (self,event):
    '''Execute command number 9.'''
    return self.numberCommand (event,None,9)
#@+node:ekr.20061031131434.119: *7* k.printBindings & helper
def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[ ] leoSettings.leo
[D] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] mode

'''

    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend,c.tab_width)
    data = []
    for stroke in sorted(d):
        assert g.isStroke(stroke),stroke
        aList = d.get(stroke,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            s1 = '' if si.pane=='all' else si.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = si.commandName
            s4 = si.kind or '<no hash>'
            data.append((s1,s2,s3,s4),)

    # Print keys by type:
    result = []
    result.append('\n'+legend)
    for prefix in (
        'Alt+Ctrl+Shift','Alt+Ctrl','Alt+Shift','Alt', # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift','Ctrl+Meta','Ctrl+Shift','Ctrl', # Ctrl+Key: done by Ctrl.
        'Meta+Key','Meta+Shift','Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1,s2,s3,s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append('***** %s...\n' % prefix)
        self.printBindingsHelper(result,data2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result,data,prefix=None)
    if not g.unitTesting:
        g.es('',''.join(result),tabName=tabName)
    state = k.unboundKeyAction 
    k.showStateAndMode()
    return result # for unit test.
#@+node:ekr.20061031131434.120: *8* printBindingsHelper
def printBindingsHelper (self,result,data,prefix):
    
    lm = g.app.loadManager
 
    data.sort(key=lambda x: x[1])

    data2,n = [],0
    for pane,key,commandName,kind in data:
        key = key.replace('+Key','')
        # g.trace(key,kind)
        letter = lm.computeBindingLetter(kind)
        pane = '%s: ' % (pane) if pane else ''
        left = pane+key # pane and shortcut fields
        n = max(n,len(left))
        data2.append((letter,left,commandName),)
        
    for z in data2:
        letter,left,commandName = z
        result.append('%s %*s %s\n' % (letter,-n,left,commandName))

    if data:
        result.append('\n')
#@+node:ekr.20120520174745.9867: *7* k.printButtons
def printButtons (self,event=None):

    '''Print all @button and @command commands, their bindings and their source.'''

    k = self ; c = k.c
    tabName = '@buttons && @commands'
    c.frame.log.clearTab(tabName)
    
    def put(s):
        g.es('',s,tabName=tabName)
        
    data = []
    for aList in [c.config.getButtons(),c.config.getCommands()]:
        for z in aList:
            p,script = z
            c = p.v.context
            tag = 'M' if c.shortFileName().endswith('myLeoSettings.leo') else 'G'
            data.append((p.h,tag),)

    for aList in [g.app.config.atLocalButtonsList,g.app.config.atLocalCommandsList]:
        for p in aList:
            data.append((p.h,'L'),)

    result = ['%s %s' % (z[1],z[0]) for z in sorted(data)]
    put('\n'.join(result))
    
    legend = '''\

legend:
G leoSettings.leo
L local .leo File
M myLeoSettings.leo
'''
    legend = g.adjustTripleString(legend,c.tab_width)
    put(''.join(legend))
#@+node:ekr.20061031131434.121: *7* k.printCommands
def printCommands (self,event=None):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c ; tabName = 'Commands'

    c.frame.log.clearTab(tabName)

    inverseBindingDict = k.computeInverseBindingDict()
    data,n = [],0
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName,[('',''),])
        for z in dataList:
            pane, key = z
            pane = '%s ' % (pane) if pane != 'all:' else ''
            key = k.prettyPrintKey(key).replace('+Key','')
            s1 = pane + key
            s2 = commandName
            n = max(n,len(s1))
            data.append((s1,s2),)

    # This isn't perfect in variable-width fonts.
    lines = ['%*s %s\n' % (-n,s1,s2) for s1,s2 in data]
    g.es('',''.join(lines),tabName=tabName)
#@+node:ekr.20061031131434.122: *7* repeatComplexCommand & helper
def repeatComplexCommand (self,event):

    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command',1,handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.es('no previous command',color='blue')
    return # (for Tk) 'break'

def repeatComplexCommandHelper (self,event):

    k = self ; c = k.c ; gui = g.app.gui
    
    char = event and event.char or ''
   
    if char in ('\n','Return') and k.mb_history:
        last = k.mb_history [0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict [last](event)
        return # (for Tk) 'break'
    else:
        # g.trace('oops')
        return k.keyboardQuit()
#@+node:ekr.20061031131434.123: *7* set-xxx-State
def setCommandState (self,event):
    '''Enter the 'command' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('command',set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setInsertState (self,event):
    '''Enter the 'insert' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('insert',set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setOverwriteState (self,event):
    '''Enter the 'overwrite' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('overwrite',set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()
#@+node:ekr.20061031131434.124: *7* toggle-input-state
def toggleInputState (self,event=None):

    '''The toggle-input-state command.'''

    k = self ; c = k.c
    default = c.config.getString('top_level_unbound_key_action') or 'insert'
    state = k.unboundKeyAction

    if default == 'insert':
        state = g.choose(state=='insert','command','insert')
    elif default == 'overwrite':
        state = g.choose(state=='overwrite','command','overwrite')
    else:
        state = g.choose(state=='command','insert','command') # prefer insert to overwrite.

    k.setInputState(state)
    k.showStateAndMode()
#@+node:ekr.20061031131434.125: *6* k.Externally visible helpers
#@+node:ekr.20061031131434.128: *7* k.getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    trace = False and not g.app.unitTesting
    state = k.getState('getArg')
    
    c.check_event(event)
    
    # 2011/06/06: remember these events also.
    if c.macroCommands.recordingMacro and state > 0:
        c.macroCommands.startRecordingMacro(event)

    char = event and event.char or ''
    if state > 0:
        k.setLossage(char,stroke)
    
    if trace: g.trace(
        'state',state,'char',repr(char),'stroke',repr(stroke),
        'isPlain',k.isPlainKey(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n','Return',) or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes:
            k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = char ##
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        if trace: g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif char in('\t','Tab'):
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif char in ('\b','BackSpace'):
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        pass
        # 2011/03/01: ignore F-keys. Ignoring all except plain keys would kill unicode searches.
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return # (for Tk) 'break'
#@+node:ekr.20061031131434.129: *8* << init altX vars >>
k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@+node:ekr.20061031131434.130: *7* k.keyboardQuit
def keyboardQuit (self,event=None,setFocus=True,mouseClick=False):

    '''This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    
    if trace: g.trace(g.callers())

    if g.app.quitting:
        return
        
    # 2011/05/30: We may be called from Qt event handlers.
    # Make sure to end editing!
    c.endEditing() 
    
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')

    if k.inputModeName:
        k.endMode()

    # Complete clear the state.
    k.state.kind = None
    k.state.n = None

    k.clearState()
    k.resetLabel()

    if setFocus:
        c.bodyWantsFocus()

    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    k.showStateAndMode(setFocus=setFocus)
#@+node:ekr.20061031131434.126: *7* k.manufactureKeyPressForCommandName (changed)
def manufactureKeyPressForCommandName (self,w,commandName):

    '''Implement a command by passing a keypress to the gui.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    stroke = k.getShortcutForCommandName(commandName)
    if not stroke:
        shortcut = None
    elif g.isStroke(stroke):
        shortcut = stroke.s
    else:
        stroke = k.strokeFromSetting(stroke)
        shortcut = stroke.s
   
    assert g.isString(shortcut)

    if trace and shortcut: g.trace(
        'shortcut',repr(shortcut),'commandName',commandName)

    if shortcut and w:
        # g.trace(stroke)
        g.app.gui.set_focus(c,w)
        g.app.gui.event_generate(c,None,shortcut,w)
    else:
        message = 'no shortcut for %s' % (commandName)
        if g.app.unitTesting:
            raise AttributeError(message)
        else:
            g.trace(message,color='red')
#@+node:ekr.20071212104050: *7* k.overrideCommand
def overrideCommand (self,commandName,func):

    # Override entries in c.k.masterBindingsDict
    k = self
    d = k.masterBindingsDict
    for key in d:
        d2 = d.get(key)
        for key2 in d2:
            si = d2.get(key2)
            assert g.isShortcutInfo(si),si
            if si.commandName == commandName:
                si.func=func
                d2[key2] = si
#@+node:ekr.20061031131434.131: *7* k.registerCommand
def registerCommand (self,commandName,shortcut,func,
    pane='all',verbose=False, wrap=True):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.

    '''

    trace = False and not g.unitTesting ; verbose = False
    k = self ; c = k.c
    
    if trace: g.trace(commandName,shortcut)

    if wrap:
        func = c.universalCallback(func)
    f = c.commandsDict.get(commandName)

    if f and f.__name__ != 'dummyCallback' and trace and verbose:
        g.es_print('redefining',commandName, color='red')
        
    assert not g.isStroke(shortcut)

    c.commandsDict [commandName] = func
    fname = func.__name__
    k.inverseCommandsDict [fname] = commandName
    if trace and fname != 'minibufferCallback':
        g.trace('leoCommands %24s = %s' % (fname,commandName))

    if shortcut:
        if trace: g.trace('shortcut',shortcut)
        stroke = k.strokeFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a stroke from leoSettings.leo.
        stroke = None
        junk,aList = c.config.getShortcut(commandName)
        for si in aList:
            assert g.isShortcutInfo(si),si
            assert g.isStrokeOrNone(si.stroke)
            if si.stroke and not si.pane.endswith('-mode'):
                # if trace: g.trace('*** found',si)
                stroke = si.stroke
                break

    if stroke:
        if trace: g.trace('stroke',stroke,'pane',pane,commandName)
        ok = k.bindKey (pane,stroke,func,commandName,tag='register-command') # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if trace and verbose and ok and not g.app.silentMode:
            g.es_print('','@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
        c.frame.tree.setBindings()
    elif trace and verbose and not g.app.silentMode:
        g.es_print('','@command: %s' % (commandName),color='blue')

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
#@+node:ekr.20061031131434.127: *7* k.simulateCommand
def simulateCommand (self,commandName):

    k = self ; c = k.c

    commandName = commandName.strip()
    if not commandName: return

    aList = commandName.split(None)
    if len(aList) == 1:
        k.givenArgs = []
    else:
        commandName = aList[0]
        k.givenArgs = aList[1:]

    # g.trace(commandName,k.givenArgs)
    func = c.commandsDict.get(commandName)

    if func:
        # g.trace(commandName,func.__name__)
        if commandName.startswith('specialCallback'):
            event = None # A legacy function.
        else: # Create a dummy event as a signal.
            event = g.app.gui.create_key_event(c,None,None,None)
            
        k.masterCommand(event=event,func=func)
        if c.exists:
            return k.funcReturn
        else:
            return None
    else:
        if g.app.unitTesting:
            raise AttributeError
        else:
            g.trace('no command for %s' % (commandName),color='red')
            return None
#@+node:ekr.20061031131434.145: *6* k.Master event handlers
#@+node:ekr.20061031131434.105: *7* k.masterCommand & helpers
def masterCommand (self,commandName=None,event=None,func=None,stroke=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = (False or g.trace_masterCommand) and not g.unitTesting
    verbose = True
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    if event: c.check_event(event)

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.

    char = ch = event and event.char or ''
    w = event and event.w
    
    # 2011/10/28: compute func if not given.
    if commandName and not func:
        func = c.commandsDict.get(commandName)
        
    # Important: it is *not* an error for func to be None.
    k.func = func
    commandName = commandName or func and func.__name__ or '<no function>'
    k.funcReturn = None # For unit testing.
    << define specialKeysyms >>
    special = char in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: # Useful.
        g.trace('stroke: %s ch: %s func: %s' % (
            stroke,repr(ch),func and func.__name__))

    if inserted:
        k.setLossage(ch,stroke)

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startRecordingMacro(event)
        # 2011/06/06: Show the key, if possible.
        # return

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return

    if special: # Don't pass these on.
        return

    # if k.regx.iter:
        # try:
            # k.regXKey = char
            # k.regx.iter.next() # EKR: next() may throw StopIteration.
        # except StopIteration:
            # pass
        # return

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event,stroke)
        if expanded: return

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return # (for Tk) 'break'
    elif k.inState():
        return # (for Tk) 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
#@+node:ekr.20061031131434.106: *8* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
#@+node:ekr.20061031131434.110: *8* k.handleDefaultChar
def handleDefaultChar(self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting
    verbose = False

    if trace and verbose:
        g.trace('widget_name',name,'stroke',stroke,'enable alt-ctrl',self.enable_alt_ctrl_bindings)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        # not k.enable_alt_ctrl_bindings and # Old code: this isn't an alt-ctrl key!
        k.ignore_unbound_non_ascii_keys and # Bug fix: 2011/11/23
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
        return # (for Tk) 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return # (for Tk) 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return # (for Tk) 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return # (for Tk) 'break'
    elif name.startswith('log'):
        # Bug fix: 2011/11/21: Because of universal bindings
        # we may not be able to insert anything into w.
        import leo.core.leoFrame as leoFrame
        if issubclass(w.__class__,leoFrame.HighLevelInterface):
            i = w.logCtrl.getInsertPoint()
            if not stroke:
                stroke = event and event.stroke
            if stroke:
                s = stroke.toGuiChar()
                w.logCtrl.insert(i,s)
        else:
            if trace: g.trace('Not a HighLevelInterface object',w)
        return # None
    else:
        # Let the widget handle the event.
        return # None
#@+node:ekr.20061031131434.146: *7* k.masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event):

    '''This is the handler for almost all key bindings.'''
    
    trace = (False or g.trace_masterKeyHandler) and not g.app.unitTesting
    traceGC = g.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True
    
    k,c = self,self.c ; gui = g.app.gui
    c.check_event(event)
    << define vars >>
    
    assert g.isStrokeOrNone(stroke)

    if char in special_keys:
        if trace and verbose: g.trace('char',char)
        return None
    
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:',repr(stroke),'char:',
        repr(event and event.char),
        'ch:',repr(event and event.char),
        'state',state,'state2',k.unboundKeyAction)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if c.macroCommands.recordingMacro:
            c.macroCommands.endMacro()
            return # (for Tk) 'break'
        else:
            return k.masterCommand(commandName='keyboard-quit',
                event=event,func=k.keyboardQuit,stroke=stroke)

    if k.inState():
        if trace: g.trace('   state %-10s %s' % (stroke,state))
        done,val = k.doMode(event,state,stroke)
        if done: return val

    if traceGC: g.printNewObjects('masterKey 2')
            
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key',stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            return k.handleUnboundKeys(event,char,stroke)

    # 2011/02/08: Use getPandBindings for *all* keys.
    si = k.getPaneBinding(stroke,w)
    if si:
        assert g.isShortcutInfo(si),si
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound',stroke,si.func.__name__)
        return k.masterCommand(event=event,
            commandName=si.commandName,func=si.func,stroke=si.stroke)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace: g.trace(' unbound',stroke)
        return k.handleUnboundKeys(event,char,stroke)
#@+node:ekr.20061031131434.147: *8* << define vars >>
w = event and event.widget
char = event and event.char or ''
stroke = event and event.stroke or None
w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@+node:ekr.20061031131434.108: *8* callStateFunction
def callStateFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; val = None 
    ch = event and event.char or ''
    stroke = event and event.stroke or ''

    if trace: g.trace(k.state.kind,'ch',ch,'stroke',stroke,
        'ignore_unbound_non_ascii_keys',k.ignore_unbound_non_ascii_keys)
        
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns',repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@+node:ekr.20091230094319.6244: *8* doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns',repr(val))
        if val == 'do-standard-keys':
            return False,None # 2011/06/17.
        else:
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert g.isShortcutInfo(si),si
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=si.commandName,func=si.func,
                modeName=state,nextMode=si.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            if 0: # 2012/05/20: I dislike this warning.
                g.warning('unbound key ends mode',stroke) # 2011/02/02
            k.endMode()
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler',handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True,'break'
#@+node:ekr.20091230094319.6240: *8* getPaneBinding
def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    verbose = False
    k = self ; w_name = k.c.widget_name(w)
    # keyStatesTuple = ('command','insert','overwrite')
    state = k.unboundKeyAction
    
    assert g.isStroke(stroke)

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command','insert','overwrite') and state == key or # 2010/02/09
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key,name,stroke,stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si),si
                    table = ('previous-line','next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case',si.commandName)
                    else:
                        if trace: g.trace('key: %7s name: %6s  found %s = %s' % (
                            key,name,repr(si.stroke),si.commandName))
                        return si

    return None
#@+node:ekr.20061031131434.152: *8* handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = (False or g.trace_masterKeyHandler) and not g.app.unitTesting

    # Special case for bindings handled in k.getArg:
        
    assert g.isStroke(stroke)

    if state in ('getArg','full-command'):
        if stroke in ('\b','BackSpace','\r','Linefeed','\n','Return','\t','Tab','Escape',):
            return False
        if k.isFKey(stroke):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si),si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane),si.commandName,stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName,event=event,func=si.func,stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@+node:ekr.20110209083917.16004: *8* isAutoCompleteChar
def isAutoCompleteChar (self,stroke):
    
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''

    k = self ; state = k.unboundKeyAction
    
    assert g.isStrokeOrNone(stroke)
    
    if stroke and state in ('insert','overwrite'):
        for key in (state,'body','log','text','all'):
            d = k.masterBindingsDict.get(key,{})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                    assert g.isShortcutInfo(si),si
                    if si.commandName == 'auto-complete':
                        return True
    return False
#@+node:ekr.20080510095819.1: *8* k.handleUnboundKeys
def handleUnboundKeys (self,event,char,stroke):

    trace = False and not g.unitTesting
    verbose = True
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')
    
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    
    assert g.isStroke(stroke)

    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char),repr(stroke)))

    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode',stroke)
        return None
        
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key',stroke)
        return None

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event=event,stroke=stroke)

    elif (not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char),repr(stroke))
        return None

    elif k.ignore_unbound_non_ascii_keys and (
        len(char) > 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char),repr(stroke))
        return None

    elif (
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore',stroke)
        return None

    else:
        if trace: g.trace('no func',repr(char),repr(stroke))
        return k.masterCommand(event=event,stroke=stroke)
#@+node:ekr.20061031170011.3: *6* k.Minibuffer
# These may be overridden, but this code is now gui-independent.
#@+node:ekr.20061031131434.135: *7* k.minibufferWantsFocus
# def minibufferWantsFocus(self):

    # c = self.c
    # c.widgetWantsFocus(c.miniBufferWidget)
#@+node:ekr.20061031170011.5: *7* k.getLabel
def getLabel (self,ignorePrompt=False):

    k = self ; w = self.w
    if not w: return ''

    s = w.getAllText()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''
#@+node:ekr.20080408060320.791: *7* k.killLine
def killLine (self,protect=True):

    k = self ; c = self.c
    w = self.w
    s = w.getAllText()
    s = s[:len(k.mb_prefix)]

    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n,n,insert=n)

    if protect:
        k.mb_prefix = s
#@+node:ekr.20061031170011.6: *7* k.protectLabel
def protectLabel (self):

    k = self ; w = self.w
    if not w: return

    k.mb_prefix = w.getAllText()

#@+node:ekr.20061031170011.7: *7* k.resetLabel
def resetLabel (self):

    k = self ; w = self.w
    k.setLabelGrey('')
    k.mb_prefix = ''

    if w:    
        w.setSelectionRange(0,0,insert=0)
        state = k.unboundKeyAction
        k.setLabelBlue(label='%s State' % (state.capitalize()),protect=True)
#@+node:ekr.20061031170011.8: *7* k.setLabel
def setLabel (self,s,protect=False):

    trace = (False or g.trace_minibuffer) and not g.app.unitTesting
    k = self ; c = k.c ; w = self.w
    if not w: return

    if trace: g.trace(repr(s),w)

    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n,n,insert=n)
    
    w2 = c.frame.body.bodyCtrl.widget
    if w2: w2.ensureCursorVisible()
        # 2011/10/02: Fix cursor-movement bug.

    if protect:
        k.mb_prefix = s
#@+node:ekr.20061031170011.9: *7* k.extendLabel
def extendLabel(self,s,select=False,protect=False):
    
    trace = False and not g.unitTesting

    k = self ; c = k.c ; w = self.w
    if not (w and s): return
    
    if trace: g.trace(s)

    c.widgetWantsFocusNow(w)

    w.insert('end',s)

    if select:
        i,j = k.getEditableTextRange()
        w.setSelectionRange(i,j,insert=j)

    if protect:
        k.protectLabel()
#@+node:ekr.20080408060320.790: *7* k.selectAll
def selectAll (self):

    '''Select all the user-editable text of the minibuffer.'''

    w = self.w
    i,j = self.getEditableTextRange()
    w.setSelectionRange(i,j,insert=j)


#@+node:ekr.20061031170011.10: *7* k.setLabelBlue
def setLabelBlue (self,label=None,protect=False):

    k = self ; w = k.w
    if not w: return

    w.setBackgroundColor(self.minibuffer_background_color) # 'lightblue')

    if label is not None:
        k.setLabel(label,protect)
#@+node:ekr.20061031170011.11: *7* k.setLabelGrey
def setLabelGrey (self,label=None):

    k = self ; w = self.w
    if not w: return

    w.setBackgroundColor(self.minibuffer_warning_color) # 'lightgrey')

    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
#@+node:ekr.20080510153327.2: *7* k.setLabelRed
def setLabelRed (self,label=None,protect=False):

    k = self ; w = self.w
    if not w: return
    
    w.setBothColors(
        self.minibuffer_warning_color,
        self.minibuffer_error_color)
    
    if label is not None:
        k.setLabel(label,protect)
#@+node:ekr.20061031170011.12: *7* k.updateLabel
def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''

    trace = False or g.trace_minibuffer and not g.app.unitTesting
    k = self ; c = k.c ; w = self.w
    
    ch = char = (event and event.char) or ''

    if trace: g.trace('ch',ch,'k.stroke',k.stroke)

    if ch and ch not in ('\n','\r'):
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange()
        ins = w.getInsertPoint()
        # g.trace(i,j,ins)
        if i != j:
            w.delete(i,j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) > len(k.mb_prefix):
                w.delete(i-1)
                i-=1
        else:
            w.insert(ins,ch)
            i = ins+1
#@+node:ekr.20061031170011.13: *7* k.getEditableTextRange
def getEditableTextRange (self):

    k = self ; w = self.w
    trace = g.trace_minibuffer and not g.app.unitTesting

    s = w.getAllText()
    # g.trace(len(s),repr(s))

    i = len(k.mb_prefix)
    j = len(s)

    # g.trace(i,j)
    return i,j
#@+node:ekr.20120208064440.10190: *6* k.Modes (no change)
#@+node:ekr.20061031131434.100: *7* k.addModeCommands (enterModeCallback)
def addModeCommands (self):

    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''
    
    trace = False and not g.unitTesting
    
    if trace: g.trace('(k)')

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.

    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        if trace: g.trace(f.__name__,key,'len(c.commandsDict.keys())',len(list(c.commandsDict.keys())))
#@+node:ekr.20061031131434.157: *7* k.badMode
def badMode(self,modeName):

    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)
#@+node:ekr.20061031131434.158: *7* k.createModeBindings
def createModeBindings (self,modeName,d,w):

    '''Create mode bindings for the named mode using dictionary d for w, a text widget.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    assert d.name().endswith('-mode')
    for commandName in d.keys():
        if commandName in ('*entry-commands*','*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:',commandName,'Referenced from',modeName)
            continue
        aList = d.get(commandName,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            stroke = si.stroke
            # Important: si.val is canonicalized.
            if stroke and stroke not in ('None','none',None):
                if trace:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        si.nextMode)
                        
                assert g.isStroke(stroke)

                k.makeMasterGuiBinding(stroke)

                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.ShortcutInfo(
                    kind = 'mode<%s>' % (modeName), # 2012/01/23
                    commandName=commandName,
                    func=func,
                    nextMode=si.nextMode,
                    stroke=stroke)
                k.masterBindingsDict [ modeName ] = d2
#@+node:ekr.20120208064440.10179: *7* k.endMode
def endMode(self):

    k = self ; c = k.c

    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode') # Changes focus to the body pane

    k.endCommand(k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode() # Restores focus.

    if w:
        c.widgetWantsFocusNow(w)
#@+node:ekr.20061031131434.160: *7* k.enterNamedMode
def enterNamedMode (self,event,commandName):

    k = self ; c = k.c
    modeName = commandName[6:]
    c.inCommand = False # Allow inner commands in the mode.
    k.generalModeHandler(event,modeName=modeName)
#@+node:ekr.20061031131434.161: *7* k.exitNamedMode
def exitNamedMode (self,event=None):
    
    '''Exit an input mode.'''

    k = self

    if k.inState():
        k.endMode()

    k.showStateAndMode()
#@+node:ekr.20061031131434.165: *7* k.modeHelp & helper (revise helper)
def modeHelp (self,event):

    '''The mode-help command.

    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.'''

    k = self ; c = k.c

    c.endEditing()

    # g.trace(k.inputModeName)

    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-'+k.inputModeName)
        k.modeHelpHelper(d)

    if not k.silentMode:
        c.minibufferWantsFocus()

    return
#@+node:ekr.20061031131434.166: *8* modeHelpHelper
def modeHelpHelper (self,d):

    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data,n = [],0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*','*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for si in aList:
                assert g.isShortcutInfo(si),si
                stroke = si.stroke
                if stroke not in (None,'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n,len(s1))
                    data.append((s1,s2),)

    data.sort()
    modeName = k.inputModeName.replace('-',' ')
    if modeName.endswith('mode'):
        modeName = modeName[:-4].strip()
        
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('','%s\n\n' % (prompt.kind.strip()),tabName=tabName)
    else:
        g.es('','%s mode\n\n' % modeName,tabName=tabName)

    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('','%*s %s' % (n,s1,s2),tabName=tabName)
#@+node:ekr.20061031131434.164: *7* k.reinitMode (call k.createModeBindings???)
def reinitMode (self,modeName):

    k = self ; c = k.c

    d = k.modeBindingsDict

    k.inputModeName = modeName
    w = g.choose(k.silentMode,k.modeWidget,k.w)
    k.createModeBindings(modeName,d,w)

    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName+': ',protect=True)

#@+node:ekr.20120208064440.10199: *7* k.generalModeHandler (OLD)
def generalModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None,prompt=None):

    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting

    if trace: g.trace(modeName,'state',state)

    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        self.initMode(event,modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return # (for Tk) 'break'
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            savedModeName = k.inputModeName # Remember this: it may be cleared.
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c,None,None,k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                return # (for Tk) 'break'
            if nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName,1,handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event,nextMode) # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                if g.app.quitting or not c.exists: return # (for Tk) 'break'
#@+node:ekr.20061031131434.156: *6* k.Modes (changed)
#@+node:ekr.20061031131434.163: *7* k.initMode (changed)
def initMode (self,event,modeName):

    k = self ; c = k.c
    trace = (False or g.trace_modes) and not g.unitTesting

    if not modeName:
        g.trace('oops: no modeName')
        return
        
    if g.new_modes:
        mode = k.modeController.getMode(modeName)
        if mode:
            mode.initMode()
        else:
            g.trace('***** oops: no mode',modeName)
    else:
        d = g.app.config.modeCommandsDict.get('enter-'+modeName)
        if not d:
            self.badMode(modeName)
            return
        else:
            k.modeBindingsDict = d
            si = d.get('*command-prompt*')
            if si:
                prompt = si.kind # A kludge.
            else:
                prompt = modeName
            if trace: g.trace('modeName: %s prompt: %s d.keys(): %s' % (
                modeName,prompt,sorted(list(d.keys()))))
    
        k.inputModeName = modeName
        k.silentMode = False
    
        aList = d.get('*entry-commands*',[])
        if aList:
            for si in aList:
                assert g.isShortcutInfo(si),si
                commandName = si.commandName
                if trace: g.trace('entry command:',commandName)
                k.simulateCommand(commandName)
                # Careful, the command can kill the commander.
                if g.app.quitting or not c.exists: return
                # New in Leo 4.5: a startup command can immediately transfer to another mode.
                if commandName.startswith('enter-'):
                    if trace: g.trace('redirect to mode',commandName)
                    return
    
        # Create bindings after we know whether we are in silent mode.
        w = g.choose(k.silentMode,k.modeWidget,k.w)
        k.createModeBindings(modeName,d,w)
        k.showStateAndMode(prompt=prompt)
#@+node:ekr.20120208064440.10201: *7* k.NEWgeneralModeHandler (NEW MODES)
def NEWgeneralModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None,prompt=None):

    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting

    if trace: g.trace(modeName,'state',state)

    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        self.initMode(event,modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return # (for Tk) 'break'
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
        return # (for Tk) 'break'
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            savedModeName = k.inputModeName # Remember this: it may be cleared.
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c,None,None,k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                return # (for Tk) 'break'
            if nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName,1,handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event,nextMode) # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                if g.app.quitting or not c.exists: return # (for Tk) 'break'

    return # (for Tk) 'break'
#@+node:ekr.20061031131434.167: *6* k.Shared helpers
#@+node:ekr.20061031131434.175: *7* k.computeCompletionList
# Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace,allow_empty_completion=False):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)
    c.frame.log.clearTab(tabName)
    
    if not k.mb_tabList and allow_empty_completion:
        if command:
            # 2012/05/20: Put up an *empty* list as a visual cue.
            k.mb_tabList = []
            g.es('','\n',tabName=tabName)
        else:
            # 2012/05/20: Return *all* completions if the command is empty.
            k.mb_tabList = sorted(defaultTabList)
            common_prefix = ''

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.
        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)

        inverseBindingDict = k.computeInverseBindingDict()
        data,n = [],0
        for commandName in k.mb_tabList:
            dataList = inverseBindingDict.get(commandName,[('',''),])
            for z in dataList:
                pane,key = z
                s1a = '%s ' % (pane) if pane != 'all:' else ''
                s1b = k.prettyPrintKey(key)
                s1 = s1a + s1b
                s2 = commandName
                data.append((s1,s2),)
                n = max(n,len(s1))
        aList = ['%*s %s' % (-n,s1,s2) for s1,s2 in data]
        g.es('','\n'.join(aList),tabName=tabName)
    c.bodyWantsFocus()
#@+node:ekr.20061031131434.177: *7* k.doBackSpace
# Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList,completion=True):

    '''Cut back to previous prefix and update prefix.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c ; w = self.w

    # Step 1: actually delete the character.
    ins = w.getInsertPoint()
    s = w.getAllText()

    if trace: g.trace('ins',ins,'k.mb_prefix',repr(k.mb_prefix),
        'w',w)

    if ins <= len(k.mb_prefix):
        # g.trace('at start')
        return
    i,j = w.getSelectionRange()
    if i == j:
        ins -= 1
        w.delete(ins)
        w.setSelectionRange(ins,ins,insert=ins)
    else:
        ins = i
        w.delete(i,j)
        w.setSelectionRange(i,i,insert=ins)

    # Step 2: compute completions.
    if not completion: return
    k.mb_tabListPrefix = w.getAllText()
    k.computeCompletionList(defaultCompletionList,backspace=True)
#@+node:ekr.20061031131434.178: *7* k.doTabCompletion
# Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList,redraw=True,allow_empty_completion=False):

    '''Handle tab completion when the user hits a tab.'''

    k = self ; c = k.c ; s = k.getLabel().strip()

    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        # g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex >= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        if redraw:
            # g.trace('** recomputing default completions')
            k.computeCompletionList(defaultTabList,
                backspace=False,
                allow_empty_completion=allow_empty_completion)

    c.minibufferWantsFocus()
#@+node:ekr.20061031131434.168: *7* k.getFileName & helpers
def getFileName (self,event=None,handler=None,prefix='',filterExt='.leo'):

    '''Similar to k.getArg, but uses completion to indicate files on the file system.'''

    k = self ; c = k.c ; gui = g.app.gui
    tag = 'getFileName' ; state = k.getState(tag)
    tabName = 'Completion'
    
    char = event and event.char or ''
    # g.trace('state',state,'char',char)

    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        k.getFileNameHandler = handler
        k.setState(tag,1,k.getFileName)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        c.frame.log.clearTab(tabName)
        c.minibufferWantsFocus()
    elif char in ('\n','Return'):
        k.arg = k.getLabel(ignorePrompt=True)
        handler = k.getFileNameHandler
        c.frame.log.deleteTab(tabName)
        if handler: handler(event)
    elif char in ('\t','Tab'):
        k.doFileNameTab()
        c.minibufferWantsFocus()
    elif char in ('\b','BackSpace'):
        k.doFileNameBackSpace() 
        c.minibufferWantsFocus()
    else:
        k.doFileNameChar(event)
    return # (for Tk) 'break'
#@+node:ekr.20061031131434.169: *8* << init altX vars >>
k.filterExt = filterExt
k.mb_prefix = (prefix or k.getLabel())
k.mb_prompt = prefix or k.getLabel()
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
theDir = g.os_path_finalize(os.curdir)
k.extendLabel(theDir,select=False,protect=False)

k.mb_tabListPrefix = k.getLabel()
#@+node:ekr.20061031131434.170: *8* k.doFileNameBackSpace
def doFileNameBackSpace (self):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c

    if 0:
        g.trace(
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    if len(k.mb_tabListPrefix) > len(k.mb_prefix):
        k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
        k.setLabel(k.mb_tabListPrefix)
#@+node:ekr.20061031131434.171: *8* k.doFileNameChar
def doFileNameChar (self,event):

    k = self

    # Clear the list, any other character besides tab indicates that a new prefix is in effect.
    k.mb_tabList = []
    k.updateLabel(event)
    k.mb_tabListPrefix = k.getLabel()

    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
    else:
        # Restore everything.
        old = k.getLabel(ignorePrompt=True)[:-1]
        k.setLabel(k.mb_prompt + old)
#@+node:ekr.20061031131434.172: *8* k.doFileNameTab
def doFileNameTab (self):

    k = self
    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
#@+node:ekr.20061031131434.173: *8* k.computeFileNameCompletionList
# This code must not change mb_tabListPrefix.
def computeFileNameCompletionList (self):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    path = k.getLabel(ignorePrompt=True)
    sep = os.path.sep
    tabList = []
    for f in glob.glob(path+'*'):
        if g.os_path_isdir(f):
            tabList.append(f + sep)
        else:
            junk,ext = g.os_path_splitext(f)
            if not ext or ext == k.filterExt:
                tabList.append(f)
    k.mb_tabList = tabList
    junk,common_prefix = g.itemsMatchingPrefixInList(path,tabList)
    if tabList:
        c.frame.log.clearTab(tabName)
        k.showFileNameTabList()
    return common_prefix
#@+node:ekr.20061031131434.174: *8* k.showFileNameTabList
def showFileNameTabList (self):

    k = self ; tabName = 'Completion'

    for path in k.mb_tabList:
        theDir,fileName = g.os_path_split(path)
        s = g.choose(path.endswith('\\'),theDir,fileName)
        s = fileName or g.os_path_basename(theDir) + '\\'
        g.es('',s,tabName=tabName)
#@+node:ekr.20110609161752.16459: *7* k.setLossage
def setLossage (self,ch,stroke):
    
    trace = False and not g.unitTesting
    k = self
    
    if trace: g.trace(repr(stroke),g.callers())
    
    if ch or stroke:
        if len(g.app.lossage) > 99:
            g.app.lossage.pop()

    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0,(ch,stroke),)
#@+node:ekr.20061031131434.180: *7* k.traceBinding (not used)
def traceBinding (self,si,shortcut,w):

    k = self ; c = k.c ; gui = g.app.gui

    if not c.config.getBool('trace_bindings'): return

    theFilter = c.config.getString('trace_bindings_filter') or ''
    if theFilter and shortcut.lower().find(theFilter.lower()) == -1: return

    pane_filter = c.config.getString('trace_bindings_pane_filter')

    if not pane_filter or pane_filter.lower() == si.pane:
        g.trace(si.pane,shortcut,si.commandName,gui.widget_name(w))
#@+node:ekr.20061031131434.181: *6* k.Shortcuts & bindings
#@+node:ekr.20061031131434.176: *7* k.computeInverseBindingDict
def computeInverseBindingDict (self):

    k = self ; d = {}

    # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict.keys():
        assert g.isStroke(stroke),repr(stroke)
        aList = k.bindingsDict.get(stroke,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            shortcutList = d.get(si.commandName,[])
            
            # The shortcutList consists of tuples (pane,stroke).
            # k.inverseBindingDict has values consisting of these tuples.
            aList = k.bindingsDict.get(stroke,g.ShortcutInfo(kind='dummy',pane='all'))
                    # Important: only si.pane is required below.
            for si in aList:
                assert g.isShortcutInfo(si),si
                pane = '%s:' % (si.pane)
                data = (pane,stroke)
                if data not in shortcutList:
                    shortcutList.append(data)

            d [si.commandName] = shortcutList

    return d
#@+node:ekr.20061031131434.179: *7* k.getShortcutForCommand/Name
def getShortcutForCommandName (self,commandName):

    k = self ; c = k.c
    command = c.commandsDict.get(commandName)
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke),repr(stroke)
            aList = k.bindingsDict.get(stroke,[])
            for si in aList:
                assert g.isShortcutInfo(si),si
                if si.commandName == commandName:
                    return stroke
    return None

def getShortcutForCommand (self,command):

    k = self ; c = k.c
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke),repr(stroke)
            aList = k.bindingsDict.get(stroke,[])
            for si in aList:
                assert g.isShortcutInfo(si),si
                if si.commandName == command.__name__:
                    return stroke
    return None
#@+node:ekr.20090518072506.8494: *7* k.isFKey
def isFKey (self,stroke):

    k = self
    if not stroke: return False
    assert g.isString(stroke) or g.isStroke(stroke)
    s = stroke.s if g.isStroke(stroke) else stroke
    s = s.lower()
    return s.startswith('f') and len(s) <= 3 and s[1:].isdigit()
#@+node:ekr.20061031131434.182: *7* k.isPlainKey
def isPlainKey (self,stroke):

    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''

    k = self
    if not stroke: return False

    assert g.isString(stroke) or g.isStroke(stroke)
    shortcut = stroke.s if g.isStroke(stroke) else stroke

    # altgr combos (Alt+Ctrl) are always plain keys
    if shortcut.startswith('Alt+Ctrl+') and not self.enable_alt_ctrl_bindings:
        return True

    for z in ('Alt','Ctrl','Command','Meta'):
        if shortcut.find(z) != -1:            
            return False
    else:
        # Careful, allow bare angle brackets for unit tests.
        if shortcut.startswith('<') and shortcut.endswith('>'):
            shortcut = shortcut[1:-1]

        isPlain = (
            len(shortcut) == 1 or
            len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
            # A hack: allow Return to be bound to command.
            shortcut in ('Tab','\t')
        )

        # g.trace(isPlain,repr(shortcut))
        return isPlain and not self.isFKey(shortcut)
#@+node:ekr.20061031131434.191: *7* k.prettyPrintKey
def prettyPrintKey (self,stroke,brief=False):

    trace = False and not g.unitTesting
    k = self
    if not stroke:
        s = ''
    elif g.isStroke(stroke):
        s = stroke.s
    else:
        s = stroke

    if not s: return ''

    shift = s.find("shift") >= 0 or s.find("shft") >= 0

    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if trace: g.trace('fields',fields)
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    if s.endswith(' '):
        s = s[:-1]+'Space' # 2010/11/06
        
    return s
#@+node:ekr.20061031131434.184: *7* k.strokeFromSetting
def strokeFromSetting (self,setting,addKey=True):

    k = self

    trace = False and not g.unitTesting # and setting.lower().find('ctrl-x') > -1
    verbose = False
    if not setting:
        return None
    
    assert g.isString(setting)

    s = g.stripBrackets(setting.strip())
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>

    if trace and verbose:
        g.trace('%20s %s' % (setting,shortcut),g.callers())
    
    return g.KeyStroke(shortcut) if shortcut else None

canonicalizeShortcut = strokeFromSetting # For compatibility.
### strokeFromSetting = shortcutFromSetting
#@+node:ekr.20061031131434.185: *8* << define cmd, ctrl, alt, shift >>
s2 = s.lower()

cmd   = s2.find("cmd") >= 0     or s2.find("command") >= 0
ctrl  = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt   = s2.find("alt") >= 0
shift = s2.find("shift") >= 0   or s2.find("shft") >= 0
meta  = s2.find("meta") >= 0
#@+node:ekr.20061031131434.186: *8* << swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
#@+node:ekr.20061031131434.187: *8* << convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
#@+node:ekr.20061031131434.188: *8* << compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", repr(s),repr(setting))
            g.trace(g.callers())
        return None

if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if addKey and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(),last)
#@+node:ekr.20061031131434.189: *8* << compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (meta,'Meta+'),
    (shift,'Shift+'),
    (True, last),
)

# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val) for flag,val in table if flag])
#@+node:ekr.20110606004638.16929: *7* k.stroke2char
def stroke2char (self,stroke):
    
    '''Convert a stroke to an (insertable) char.
    
    This method allows Leo to use strokes everywhere.'''
    
    trace = False and not g.unitTesting
    k = self
    
    if not stroke: return ''
    s = stroke.s
    
    # Allow bare angle brackets for unit tests.
    if s.startswith('<') and s.endswith('>'):
        s = s[1:-1]
        
    if len(s) == 0: return ''
    if len(s) == 1: return s
        
    for z in ('Alt','Ctrl','Command','Meta'):
        if s.find(z) != -1:            
            return ''
            # This is not accurate: leoQtEventFilter retains
            # the spelling of Alt-Ctrl keys because of the
            # @bool enable_alt_ctrl_bindings setting.
            
    # Special case the gang of four, plus 'Escape',
    d = {
        'BackSpace':'\b',
        'Escape':'Escape',
        'Linefeed':'\r',
        'Return':'\n',
        'Tab':'\t',
    }
    ch = d.get(s)
    if ch: return ch
            
    # First, do the common translations.
    ch = k.guiBindNamesInverseDict.get(s)
    if ch:
        if trace: g.trace(repr(stroke),repr(ch))
        return ch
    
    # A much-simplified form of code in k.strokeFromSetting.
    shift = s.find('Shift+') > -1 or s.find('Shift-') > -1
    s = s.replace('Shift+','').replace('Shift-','')
    
    last = s #  Everything should have been stripped.
    
    if len(s) == 1 and s.isalpha():
        if shift:
            s = last.upper()
        else:
            s = last.lower()
    
    val = g.choose(len(s)==1,s,'')

    if trace: g.trace(repr(stroke),repr(val)) # 'shift',shift,
    return val
#@+node:ekr.20061031131434.193: *6* k.States
#@+node:ekr.20061031131434.194: *7* clearState
def clearState (self):

    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
#@+node:ekr.20061031131434.196: *7* getState
def getState (self,kind):

    k = self
    val = g.choose(k.state.kind == kind,k.state.n,0)
    # g.trace(state,'returns',val)
    return val
#@+node:ekr.20061031131434.195: *7* getStateHandler
def getStateHandler (self):

    return self.state.handler
#@+node:ekr.20061031131434.197: *7* getStateKind
def getStateKind (self):

    return self.state.kind
#@+node:ekr.20061031131434.198: *7* inState
def inState (self,kind=None):

    k = self

    if kind:
        return k.state.kind == kind and k.state.n != None
    else:
        return k.state.kind and k.state.n != None
#@+node:ekr.20080511122507.4: *7* setDefaultInputState
def setDefaultInputState (self):

    k = self ; state = k.defaultUnboundKeyAction
    
    # g.trace(state)
    
    k.setInputState(state)
#@+node:ekr.20110209093958.15411: *7* setEditingState
def setEditingState (self):

    k = self ; state = k.defaultEditingAction
    
    # g.trace(state)
    
    k.setInputState(state)
#@+node:ekr.20061031131434.133: *7* setInputState
def setInputState (self,state,set_border=False):

    c,k = self.c,self
    k.unboundKeyAction = state

    if set_border and c.frame and c.frame.body:
        w = c.frame.body.bodyCtrl
        if hasattr(w,'widget'):
            g.app.gui.add_border(c,w.widget)
#@+node:ekr.20061031131434.199: *7* setState
def setState (self,kind,n,handler=None):

    k = self
    if kind and n != None:
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        k.clearState()

    # k.showStateAndMode()
#@+node:ekr.20061031131434.192: *7* k.showStateAndMode
def showStateAndMode(self,w=None,prompt=None,setFocus=True):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return
    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return
        
    isText = g.app.gui.isTextWidget(w)

    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return

    wname = g.app.gui.widget_name(w).lower()
    
    # 2011/02/12: get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree,'getWrapper'):
            if hasattr(w,'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2,item=None)
            isText = bool(w) # A benign hack.

    if trace: g.trace('state: %s, text?: %s, w: %s' % (
        state,isText,w))

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    else:
        s = '%s State' % state.capitalize()
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'
            
    if s:
        k.setLabelBlue(label=s,protect=True)
    if w and isText:
        k.showStateColors(inOutline,w)
        k.showStateCursor(state,w)
#@+node:ekr.20080512115455.1: *7* showStateColors
def showStateColors (self,inOutline,w):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; state = k.unboundKeyAction

    # body = c.frame.body ; bodyCtrl = body.bodyCtrl
    w_name = g.app.gui.widget_name(w)

    if state not in ('insert','command','overwrite'):
        g.trace('bad input state',state)

    # if trace: g.trace('%9s' % (state),w_name)
    
    if w_name.startswith('body'):
        w = c.frame.body
    elif w_name.startswith('head'):
        pass
    else:
        # Don't recolor the minibuffer, log panes, etc.
        if trace: g.trace('not body or head')
        return

    if state == 'insert':
        bg = k.insert_mode_bg_color
        fg = k.insert_mode_fg_color
    elif state == 'command':
        bg = k.command_mode_bg_color
        fg = k.command_mode_fg_color
    elif state == 'overwrite':
        bg = k.overwrite_mode_bg_color
        fg = k.overwrite_mode_fg_color
    else:
        bg = fg = 'red'

    if hasattr(w,'setEditorColors'):
        # Note: fg color has no effect on Qt at present.
        w.setEditorColors(bg=bg,fg=fg)
    else:
        try:
            w.configure(bg=bg,fg=fg)
        except Exception:
            pass # g.es_exception()
#@+node:ekr.20110202111105.15439: *7* showStateCursor
def showStateCursor (self,state,w):
    
    # g.trace(state,w)
    
    pass
    
    
#@+node:ekr.20061031131434.200: *6* k.universalDispatcher & helpers
def universalDispatcher (self,event):

    '''Handle accumulation of universal argument.'''

    << about repeat counts >>

    c,k = self.c,self ; gui = g.app.gui
    state = k.getState('u-arg')
    stroke = event and event.stroke or None
    
    if state == 0:
        k.dispatchEvent = event
        # The call should set the label.
        k.setState('u-arg',1,k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        # stroke = k.stroke # Warning: k.stroke is always Alt-u
        char = event and event.char or ''
        # g.trace(state,char)
        if char == 'Escape':
            k.keyboardQuit()
        elif char == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif char.isdigit() or char == '-':
            k.updateLabel(event)
        elif char in (
            'Alt_L','Alt_R',
            'Control_L','Control_R',
            'Meta_L','Meta_R',
            'Shift_L','Shift_R',
        ):
            k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            val = k.getLabel(ignorePrompt=True)
            try:                n = int(val) * k.repeatCount
            except ValueError:  n = 1
            k.clearState()
            event = k.dispatchEvent
            k.executeNTimes(event,n)
            k.keyboardQuit()
    elif state == 2:
        k.doControlU(event,stroke)

    return # (for Tk) 'break'
#@+node:ekr.20061031131434.201: *7* << about repeat counts >>
@nocolor

@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
#@+node:ekr.20061031131434.202: *7* k.executeNTimes
def executeNTimes (self,event,n):

    trace = False and not g.unitTesting
    c,k = self.c,self
    
    w = event and event.widget
    
    stroke = event and event.stroke or None
    if not stroke: return
  
    if stroke == k.fullCommandKey:
        for z in range(n):
            k.fullCommand(event)
    else:
        si = k.getPaneBinding(stroke,event and event.widget)
        if si:
            assert g.isShortcutInfo(si),si
            if trace: g.trace('repeat',n,'method',si.func.__name__,
                'stroke',stroke,'widget',w)
            for z in range(n):
                event = g.app.gui.create_key_event(c,None,stroke,w)
                k.masterCommand(commandName=None,event=event,func=si.func,stroke=stroke)
        else:
            for z in range(n):
                k.masterKeyHandler(event)
#@+node:ekr.20061031131434.203: *7* doControlU
def doControlU (self,event,stroke):

    k = self ; c = k.c

    ch = event and event.char or ''

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if ch == '(':
        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
#@+node:ekr.20061031131434.123: *5* set-xxx-State
def setCommandState (self,event):
    '''Enter the 'command' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('command',set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setInsertState (self,event):
    '''Enter the 'insert' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('insert',set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setOverwriteState (self,event):
    '''Enter the 'overwrite' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('overwrite',set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()
#@+node:ekr.20061031131434.133: *5* setInputState
def setInputState (self,state,set_border=False):

    c,k = self.c,self
    k.unboundKeyAction = state

    if set_border and c.frame and c.frame.body:
        w = c.frame.body.bodyCtrl
        if hasattr(w,'widget'):
            g.app.gui.add_border(c,w.widget)
#@+node:ekr.20120519114248.9887: *4* Fully support :: convention in @mode nodes
@nocolor-node

If the @mode headline contains ::, everything following
the :: is the mode prompt. For example::
    
    @mode abc :: xyz
    
Creates the enter-abc-mode command, but the prompt for the command is xyz.

ParserBaseClass.createModeCommand creates this convention.
Changed k.modeHelpHelper.
#@+node:ekr.20120420095827.9947: *4* Completed the new support for sessions
@nocolor-node

(Done) Changed es so it always queues messages when g.app.log is None.
(Done) complete the command-line args: --session-save and --session-restore.
(Done) Write session info in leoTabbedTopLevel.closeEvent and g.app.onQuit.

Rev 5324 finishes some session-related work. The existing
session commands are unchanged, but Leo now fully supports
two new command-line arguments::

    --session-restore     restore previously saved session tabs at startup
    --session-save        save session tabs on exit

If you use both arguments, everything is automatic: Leo
saves the tabs when you quit Leo, and restores tabs when you
start Leo. Note that you can still specify file names on the
command line in addition to whatever files --session-restore
will open for you.

If you use only --session-restore, it is up to you to save
sessions "by hand" with one of the session commands, for
instance, session-snapshot-save.
#@+node:ekr.20111017102409.15875: *4* Created print-buttons command
@nocolor-node

Created print-buttons command, showing source of all @command and @button nodes.

Changed ParserBaseClass.doButtons/doCommands so they return
lists of (p.copy(),script) rather than (p.h,script)

Added g.app.config.atLocalButtonsList & g.app.config.atLocalCommandsList
for use by print-buttons command.
#@+node:ekr.20041117062717.2: *5* gcm.ctor
def __init__ (self):
    
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: print('g.app.config.__init__')
    
    # Set later.  To keep pylint happy.
    if 0: # No longer needed, now that setIvarsFromSettings always sets gcm ivars.
        self.at_root_bodies_start_in_doc_mode = True
        self.default_derived_file_encoding = 'utf-8'
        self.output_newline = 'nl'
        self.redirect_execute_script_output_to_log_pane = True
        self.relative_path_base_directory = '!'

    self.atCommonButtonsList = [] # List of info for common @buttons nodes.
    self.atCommonCommandsList = [] # List of info for common @commands nodes.
    self.atLocalButtonsList = [] # List of positions of @button nodes.
    self.atLocalCommandsList = [] # List of positions of @command nodes.

    self.buttonsFileName = ''
    self.configsExist = False # True when we successfully open a setting file.
    self.unitTestDict = {} # For unit testing: *not* the same as g.app.unitTestDict.
    self.defaultFont = None # Set in gui.getDefaultConfigFont.
    self.defaultFontFamily = None # Set in gui.getDefaultConfigFont.
    self.enabledPluginsFileName = None
    self.enabledPluginsString = '' 
    self.inited = False
    self.menusList = []
    self.menusFileName = ''
    if g.new_modes:
        pass # Use k.ModeController instead.
    else:
        self.modeCommandsDict = g.TypedDict(
            name = 'modeCommandsDict',
            keyType = type('commandName'),valType = g.TypedDictOfLists)

    # Inited later...
    self.panes = None
    self.sc = None
    self.tree = None

    self.initDicts()
    self.initIvarsFromSettings()
    self.initRecentFiles()
#@+node:ekr.20070925144337: *5* doButtons
def doButtons (self,p,kind,name,val):

    '''Handle an @buttons tree.'''

    trace = False and not g.unitTesting
    aList = [] ; c = self.c ; tag = '@button'
    seen = []
    after = p.nodeAfterTree()
    while p and p != after:
        if p.v in seen:
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            seen.append(p.v)
            p.moveToNodeAfterTree()
        else:
            seen.append(p.v)
            if g.match_word(p.h,0,tag):
                # We can not assume that p will be valid when it is used.
                script = g.getScript(c,p,
                    useSelectedText=False,
                    forcePythonSentinels=True,
                    useSentinels=True)
                aList.append((p.copy(),script),)
            p.moveToThreadNext()

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    if aList:
        g.app.config.atCommonButtonsList.extend(aList)
            # Bug fix: 2011/11/24: Extend the list, don't replace it.
        g.app.config.buttonsFileName = c and c.shortFileName() or '<no settings file>'

    if trace: g.trace(len(aList),c.shortFileName())

    d,key = g.app.config.unitTestDict,'config.doButtons-file-names'
    aList = d.get(key,[])
    aList.append(c.shortFileName())
    d[key] = aList
#@+node:ekr.20080312071248.6: *5* doCommands
def doCommands (self,p,kind,name,val):

    '''Handle an @commands tree.'''

    trace = False and not g.unitTesting
    aList = [] ; c = self.c ; tag = '@command'
    seen = []
    after = p.nodeAfterTree()
    while p and p != after:
        if p.v in seen:
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            seen.append(p.v)
            p.moveToNodeAfterTree()
        else:
            seen.append(p.v)
            if g.match_word(p.h,0,tag):
                # We can not assume that p will be valid when it is used.
                script = g.getScript(c,p,
                    useSelectedText=False,
                    forcePythonSentinels=True,
                    useSentinels=True)
                aList.append((p.copy(),script),)
            p.moveToThreadNext()

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    if aList:
        g.app.config.atCommonCommandsList.extend(aList)
            # Bug fix: 2011/11/24: Extend the list, don't replace it.
    if trace: g.trace(len(aList),c.shortFileName())
    
    d,key = g.app.config.unitTestDict,'config.doCommands-file-names'
    aList = d.get(key,[])
    aList.append(c.shortFileName())
    d[key] = aList
#@+node:ekr.20120520174745.9867: *5* k.printButtons
def printButtons (self,event=None):

    '''Print all @button and @command commands, their bindings and their source.'''

    k = self ; c = k.c
    tabName = '@buttons && @commands'
    c.frame.log.clearTab(tabName)
    
    def put(s):
        g.es('',s,tabName=tabName)
        
    data = []
    for aList in [c.config.getButtons(),c.config.getCommands()]:
        for z in aList:
            p,script = z
            c = p.v.context
            tag = 'M' if c.shortFileName().endswith('myLeoSettings.leo') else 'G'
            data.append((p.h,tag),)

    for aList in [g.app.config.atLocalButtonsList,g.app.config.atLocalCommandsList]:
        for p in aList:
            data.append((p.h,'L'),)

    result = ['%s %s' % (z[1],z[0]) for z in sorted(data)]
    put('\n'.join(result))
    
    legend = '''\

legend:
G leoSettings.leo
L local .leo File
M myLeoSettings.leo
'''
    legend = g.adjustTripleString(legend,c.tab_width)
    put(''.join(legend))
#@-all

# Put this @language after the @all as a kind of permanent unit test.

#@@language python # Override the default .txt coloring.

#@@pagewidth 60
#@-leo
