.. @+leo-ver=5-thin
.. @+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
.. @@language rest

.. @+all
.. @+node:ekr.20131225061403.16376: ** 4.11.1
.. @+node:ekr.20140702131031.16726: *3* Bugs
.. @+node:ekr.20131124060912.16475: *4* Cleared bug 1228457: Beginning find at the current node's body cursor when that cursor is not displayed
https://bugs.launchpad.net/leo-editor/+bug/1228457

This appears to have been fixed.
.. @+node:ekr.20131124060912.16477: *4* Cleared bug 1228713: Find-backward skips headlines under some conditions
https://bugs.launchpad.net/leo-editor/+bug/1228713

This appears to have been fixed at some time in the past, possibly as the result of fixing another bug.
.. @+node:ekr.20140702131031.16723: *4* Cleared bug 1254864: Can't search from current cursor position downward in body text
https://bugs.launchpad.net/leo-editor/+bug/1254864
.. @+node:ekr.20140531073052.16701: *4* find-all now uses exising find pattern
.. @+node:ekr.20140205074001.16358: *4* Fixed a startup error involving --ipython
Fixed a bug that caused Leo to exit during startup when
--python given on the command line but IPython is not installed.
.. @+node:ekr.20140727055826.18129: *4* Fixed annoyance: shift-ctrl-w leaves .leo file as dirty
@language rest
  
- pd.update_before_write_foreign_file tells when an @data node has been
  changed. This explains why the .leo file is now dirty.
- at.saveOutlineIfPossible automatically saves the .leo file if only
  unchanged persistence nodes remain.
  
at.saveOutlineIfPossible makes the following hacks unnecessary:
    
- at.writeAllHelper writes an unchanged @auto file only if it is
  selected explicitly.
- Changed at.writeAll so that the no @<file> node written message now says
  that you must selected an unchanged @auto node directly in order to write
  it with the write-at-files-nodes command.

@language python
.. @+node:ekr.20140809063010.18177: *4* Fixed autocompleter bug
@language rest

The problem was in ic.createImporterData, not at.createWritesData.
A trace in get_leo_namespace pinpointed the problem.

 
.. @+node:ekr.20130908104426.11234: *4* Fixed bug 1041906: underlying C/C++ object has been deleted
@language rest

https://bugs.launchpad.net/leo-editor/+bug/1041906

Changed LeoQtTree.closeEditorHelper as follows:
    
- Call w.setItemWidget(item,0,None) to make sure e is never referenced again.
    
- Catch RuntimeError exceptions.
.. @+node:ekr.20140714090832.17762: *4* Fixed bug 1090950: refresh from disk - cut node resurrection
Fixed bug 1090950: refresh from disk - cut node resurrection.
https://bugs.launchpad.net/leo-editor/+bug/1090950

refresh_rclick_cb in contextmenu.py now just calls c.refreshFromDisk,
which calls c.recreateGnxDict() before reading any file.

Also created the new refresh-from-disk command and the corresponding item in the File menu.
.. @+node:ekr.20140718092511.17736: *5* print gnxs & gnxDict
@language python
'''A script used while investigating this bug.'''
# g.cls()
d = {}
x = g.app.nodeIndices
result = []
for v in c.all_unique_nodes():
    gnx = v.fileIndex
    assert g.isUnicode(gnx),gnx
    d [gnx] = v
    result.append('%s %s' % (gnx,v))
print('%s v.fileIndex\'s...' % len(result))
print('\n'.join(sorted(result)))
if 1:
    d = c.fileCommands.gnxDict
    print('old: %s fc.gnxDict keys...' % len(list(d.keys())))
    for key in sorted(d.keys()): 
        print('%s %s' % (key,d.get(key)))
if 1:
    c.recreateGnxDict()
    d = c.fileCommands.gnxDict
    print('new: %s fc.gnxDict keys...' % len(list(d.keys())))
    for key in sorted(d.keys()): 
        print('%s %s' % (key,d.get(key)))
.. @+node:ekr.20131124060912.16474: *4* Fixed bug 1228312: Find tab selected in log pane disables Minibuffer
https://bugs.launchpad.net/leo-editor/+bug/1228312

When the find tab is selected in the log pane, Alt-X complements the Regexp
flag--instead of enabling use of the Minibuffer. It doesn't matter where
focus is. Focus can be in the outline pane or body pane, Alt-X still just
complements the Regexp flag.

Fixed at rev 6351.

This was the so-called "greedy checkbox bug".
.. @+node:ekr.20131124060334.16469: *4* Fixed bug 1228458: Inconsistency between Find-forward and Find-backward
https://bugs.launchpad.net/leo-editor/+bug/1228458

The fix was made to firstSearchPane:

In a Leo-Editor file containing exactly one node, there is no way to search
the headline.

Suggested fix: Backward search should search the body and then the headline.
.. @+node:ekr.20140702131031.16725: *4* Fixed bug 1254861: Ctrl-f doesn't ensure find input field visible
https://bugs.launchpad.net/leo-editor/+bug/1254861

The fix was to LeoQtLog.selectHelper.
.. @+node:ekr.20140824163757.20586: *4* Fixed bug 1260415: exception writing external files" is insufficient
@language rest

https://bugs.launchpad.net/leo-editor/+bug/1260415

Added more informative error messages in at.writeAllAtFileNodesHelper.
This is the direct response to the bug report.  A typical message::

    Internal error writing one or more external files.
    Please report this error to:
    https://groups.google.com/forum/#!forum/leo-editor
    All changes will be lost unless you
    can save each changed file.
    
A much better fix: catch all exceptions in at.writeAll.
A typical message::

    Internal error writing: @<file> node
    Please report this error to:
    https://groups.google.com/forum/#!forum/leo-editor
    Warning: changes to this file will be lost
    unless you can save the file successfully.
.. @+node:ekr.20131225061403.16378: *4* Fixed bug 1264350
@language rest

Up-arrow on the first node in a chapter switches to another chapter 
https://bugs.launchpad.net/leo-editor/+bug/1264350

Solution:

1. The "fix" at rev 6472 was wrong: The original code was correct.
2. Added a unit test.
.. @+node:ekr.20140827092102.18572: *4* Fixed bug: activate events now properly restore focus
Previously, Ctrl-F Alt-tab Alt-tab would put focus in an inactive minibuffer.

The fix involved rewriting onActivate/DeactivateEvent.
.. @+node:ekr.20140424102007.16873: *4* Fixed clone-find-all command
Changed find.findAll and helpers as follows:
    
- findAll inits onlyPosition for the clone-find-all commands.
    
- createCloneFindAllNode does not link the node into the outline.
  To do this, leoFind.py imports leo.core.leoNodes.

- linkCloneFindAllNode does this *after* the command completes. This keeps
  all positions unchanged while they are being scanned.
   
- The code now tests for either clone_find_all or clone_find_all_flattened
  in various places.
.. @+node:ekr.20130502102046.10578: *4* Fixed Crash deleting body editor
# Trying to delete a second body editor.

Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 560, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\plugins\qtGui.py", line 2980, in deleteEditor
    name = w.leo_name
AttributeError: 'LeoQTextBrowser' object has no attribute 'leo_name'
.. @+node:ekr.20131124060912.16476: *4* Fixed doc bug 1228452: related to the radio buttons in the Find pane
https://bugs.launchpad.net/leo-editor/+bug/1228452

.. @+node:ekr.20140114145953.16693: *4* Fixed important security hole in mod_scripting plugin
The ctor of the scriptingController does not allow::

    @bool scripting-at-script-nodes = True
    
in local .leo files. 
.. @+node:ekr.20140313100328.16825: *4* Fixed leoGlobals bug (per Reinhard Engle)
@language rest

Reinhard Engel reinhard.engel.de@googlemail.com

There seems to be a subtle bug in leoGlobals.py:

In the 'globalDirectiveList', the directive 'command' is missing. This
seems not to cause problems, because of the way 'aList' in
'compute_directives_re' is constructed. Then in 'get_directives_dict' the
directive is silently skipped.

The following pattern in 'compute_directives_re' solves this problem:

@language python

aList = [x for x in globalDirectiveList if z != 'others']
aList.sort(lambda a,b: len(b)-len(a))
    # Sort by length, longest first
pat = "^@(%s)(?=( |\t|\n)+)" % "|".join(aList)
.. @+node:ekr.20140729055228.17976: *4* Fixed modes/md.py
import glob
pattern = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
for fn in glob.glob(pattern):
    sfn = g.shortFileName(fn)
    f = open(fn)
    s = f.read()
    f.close()
    if s.find(r'regexp="\\') > -1:
        g.es(sfn)

@

Possible automatic computation of First sets:
http://stackoverflow.com/questions/787134/can-i-determine-the-set-of-first-chars-matched-by-regex-pattern
http://www.cs.uky.edu/~lewis/texts/theory/automata/reg-sets.pdf

found: Rules indicated are dubious or broken

md.py:
    disabled: 6,7,
    changed: 8,12,20,21,23,24,25,47
    [ \t]   leadins: 8,20,24,25,50,51
    space   leadins: 23,46,49
    [=-]    leadins: 21,47
    [\\_]   leadins: 54,55
    other   leadins: 12,19,53

moin.py:
    [ \t]           rule 3.
    single-quote    rule 6.

erlang.py:  no obvious problem.
lilypond.py:no obvious problem.
perl.py:    no obvious problem.
pl1.py:     no obvious problm.
rest.py:    no obvious problem.
rtf.py:     no obvious problem.
scala.py:   no obvious problem.
yaml.py:    fixed
.. @+node:ekr.20131225045014.16398: *4* Fixed problem with 1-character reverse searches!
The problem was an off-by-one test in regexHelper.
.. @+node:ekr.20131224124822.16717: *4* Fixed problems with clone-expansion
@language rest

Alt-End when the last top-level node was a clone caused all clones to expand.

The fix was in p.isAncestorOf.

Also, changed p.all_unique_positions() to p.all_positions() in places where p.contract was called.

I started this project by doing a clone-find-all for isExpanded.

@language python
.. @+node:ekr.20140825212426.18671: *4* Fixed recent bug in change command
@language rest

The change pattern doesn't always get set properly.

The fix was in find.addChangeStringToLabel. It must never protect the
change string!
.. @+node:ekr.20140313100328.16828: *4* Fixed serious c.deletePositionsInList bug
@nocolor-node

https://groups.google.com/forum/#!topic/leo-editor/Uoa7ifVV_Aw

I selected ALL nodes, and deleted them. (I think I used the context menu
delete) Then the outline window was red, could not insert any nodes, could
not Undo. Todd. Had to abandon the outline and start again.

# Breaks Leo HARD:
# c.deletePositionsInList(c.all_positions())
.. @+node:ekr.20140209065845.16766: *4* Fixed unicode problem in the log pane

@language rest

Fixed bug: https://bugs.launchpad.net/leo-editor/+bug/1276236

g.insertCodingLine adds coding line to start of all python scripts, except when unit testing.
.. @+node:ekr.20140824161117.18385: *4* Gave the Find Tab the intended amount of border
dw.createGrid now honors the margin argument.
.. @+node:ekr.20140905085028.18560: *4* Reported QTextEdit bug
https://bugreports.qt-project.org/browse/QTBUG-41153
.. @+node:ekr.20140825124443.18548: *4* Fixed tab cycling
@nocolor-node

As of rev 6bc05ce Leo build: 20140826115101:

Tab cycling now works as expected in all my tests.

- Reset tab cycling if the user types backspace or any plain character.
- Start cycling *only* if len(label) == len(common_prefix)

These restriction appear to be essential.
.. @+node:ekr.20140910140737.17821: *4* Fixed autocompleter bug
@language rest

https://groups.google.com/d/msg/leo-editor/NGbogCgVmx4/nsJGngrS8BgJ

When I hit <enter> after selecting "selectPosition," I get the following
error message in the log pane:

Unexpected exception...
Traceback (most recent call last):
  File "/home/ldi/git/leo-editor/leo/core/leoUndo.py", line 1323, in
setUndoTypingParams
    old_start,old_end = oldSel
TypeError: 'NoneType' object is not iterable

@language python
.. @+node:ekr.20140910173844.17822: *4* Fixed find bug
@language rest

https://groups.google.com/forum/#!topic/leo-editor/yR8eL5cZpi4

Another example of the wretched newline problem. @edit nodes preserve '\r'
characters, and that messes up the counts in the find command.

The fix was a hack to find.search: it removes '\r' characters.

.. @+node:ekr.20140917101732.27900: *4* Fixed unwanted scrolling in abbreviations
Saved and restored the y-scroll position in find_place_holder.
.. @+node:ekr.20140827092102.18576: *4* Set the default syntax color for operators to black
This is required so that, for example, python coloring is correct after
selecting a node that sets another color for operators.
.. @+node:ekr.20140906152857.18699: *4* Fixed recursive import bug
@language rest

https://github.com/leo-editor/leo-editor/issues/49

The file import code as found in scripts fails on reaching
Word backup files (file names prefixed with a ~)

The problem was that g.os_path_join automatically called
os.path.expanduser, which converts ~ to the users home directory.

The fix was to disable the call to os.pathexpanduser in g.os_path_join &
g.os_path_finalize if the new expanduser keyword argument is False.
.. @+node:ekr.20140918072425.17930: *4* Suppressed duplicate console messages
g.es does nothing when g.app.gui.consoleOnly is True
.. @+node:ekr.20140919050334.17884: *4* Fixed QCompleter bug
@language rest

http://i.imgur.com/1ZV45oB.png

There was a problem with hitting tab, and possibly with using the mouse in the QListWidget.

The fix was to define w as follows in lqlw.select_callback and lqlw.tab_callback:
    
    w = c.k.autoCompleter.w or c.frame.body.wrapper

In addition, I changed assert in lqlw.set_position to calls to g.trace.
.. @+node:ekr.20140917180536.17913: *4* Improved ctrl-o code
@language rest

- Non-plain keys are now ignored.
- Backspace and other characters now do something fairly reasonable when text is selected.
  This is an edge case, unless everything to the end of the text is selected.
.. @+node:ekr.20140919093158.17872: *4* Fixed bug: it's now possible to change big-text nodes
The fix was to set w.leo_big_text = None in remove_big_text_buttons and add_load_button.
.. @+node:ekr.20140919160020.17927: *4* All unit tests now pass when run externally
@language rest

Fixed an important bug in addNode, a helper of createOutline: There was a
confusion about commanders: p is in the old commander. p2 must be in the
new commander.

Disabled a few unit tests when run externally:
This was due to missing nodes or copies of clones not being cloned.
.. @+node:ekr.20141007082033.18003: *4* Fixed bug 61: errors inhibited read @auto foo.md.
@language rest

Fixed bug 61, https://github.com/leo-editor/leo-editor/issues/61
errors inhibited read @auto foo.md.

Modified dropEvent and its helpers.

Added createLeoFileTree and isLeoFile.

Regular drag of .leo files from a file folder works like the open-outline
command.

Ctrl-drag of .leo files from a file folder copies all nodes of the .leo
file to the receiving outline.

Added help-for-drag-and-drop command.
.. @+node:ekr.20141008071500.17790: *4* Made beautify commands compatible with pep8
http://legacy.python.org/dev/peps/pep-0008/

https://github.com/leo-editor/leo-editor/issues/68

    (fixed) puts whitespace between function name and opening '('
    (fixed) puts whitespace between dictionary name and '['
    (fixed) removes whitespace between function arguments after ','
    (partially fixed) removes whitespace around operator inside parentheses
        (this is not so clear, depends on situation, can be correct or can be wrong)
    (fixed) puts whitespace between print and opening '('

print(obj) is correct and PEP8 style in Python 3, in Python 2.7 runs
correctly but print(obj) is not correct traditionally
.. @+node:ekr.20141008185752.17804: *4* eliminated "can not exedute commands from headlines"
Removed the odious "'Can not execute commands from headlines" message.

Instead of this message, Leo ends editing, replaces the event.widget and
event.w fields with c.frame.body.wrapper.widget and carries on. All tests
pass.
.. @+node:ekr.20141012064706.18240: *4* Fixed bug 35: leoBridge sometimes assigns the same GNX to two distinct vnodes
https://github.com/leo-editor/leo-editor/issues/35
leoBridge sometimes assigns the same GNX to two distinct vnodes

c.initObjects sets c.hiddenRootNode.fileIndex to 'hidden-root-vnode-gnx'

fc.getLeoFile calls the new fc.setMaxNodeIndex after reading all nodes.
.. @+node:ekr.20141017150357.18267: *4* Fixed bug 31: 'undo' on a freshly-loaded outline
https://github.com/leo-editor/leo-editor/issues/31
'undo' on a freshly-loaded outline containing chapters removes chapters

Chapter.afterCreateChapter does not push undo data when cc.initing is True.
.. @+node:ekr.20141017150357.18270: *4* Investigated bug 869098: Context menu settings lost if save as used
@language rest

https://bugs.launchpad.net/leo-editor/+bug/869098
Context menu settings lost if save as used

This report appears invalid.

The renamed file uses the @data contextmenu_commands node in that files.

Note that @data contextmenu_commands node in the file *replaces* any other
@data contextmenu_commands node in leoSettings.leo or myLeoSettings.leo.

.. @+node:ekr.20141017110114.18272: *4* Fixed bug 50: Important body text lost switching @file to @auto-rst
@language rest

https://github.com/leo-editor/leo-editor/issues/50
Important: body text lost switching @file to @auto-rst

This case is so dangerous that Leo refuses to create the file and instead
reverts to the previous @file node.

Changes:
    
- v.at_read is now a dict: keys are full file names; values are lists of headlines.
- at.shouldPromptForDangerousWrite returns True if p.h is not in v.at_read.
- at.promptForDangerousWrite issues a warning and reverts the headline

@language python
.. @+node:ekr.20141017110114.18274: *4* Fixed big-text bugs: #28, #63, #64
@language rest

Summary post:
https://groups.google.com/d/msg/leo-editor/b6TszFS_6NQ/gJrlRkqH9_oJ

https://github.com/leo-editor/leo-editor/issues/28
Fixed: Leo hangs when a node with too large body is selected

https://github.com/leo-editor/leo-editor/issues/64
Fixed: big text status re-evaluated on find in current body

https://github.com/leo-editor/leo-editor/issues/63
Fixed: refresh-from-disk does not clear big text load delay UI

What I did:

- The big text is now shown along with warning text and warning buttons.
  Imo, this is essential: it keeps c.frame.body.wrapper.widget unchanged.
- Converted LeoBigTextDialog class to BigTextController class.
- c.bigTextController (btc) replaces injected ivars.
- Simplified all the interface code in LeoTree.select and helpers.
- Added QTextEdit#bigtextwarning to the Qt stylesheet to make the warning background pink.
.. @+node:ekr.20141020061642.21502: *4* Investigated bug 1193820: Focus change on tree pane after saving current Leo file
@language rest

From https://github.com/leo-editor/leo-editor/issues/73

https://bugs.launchpad.net/leo-editor/+bug/1193820
Focus change on tree pane after saving current Leo file
    
Using Qt. First reported here:
https://groups.google.com/forum/#!topic/leo-editor/hPwPG9OTC3U

This no longer seems to be a problem.
.. @+node:ekr.20141020061642.21503: *4* Fixed bug 1258373: failed find focus fails
@language rest

From https://github.com/leo-editor/leo-editor/issues/73

https://bugs.launchpad.net/leo-editor/+bug/1258373
failed find focus fails

Changed code in the save/restore methods in leoFind.py.
.. @+node:ekr.20141020061642.21512: *4* Delegated git #57 to Terry
https://github.com/leo-editor/leo-editor/issues/57
.. @+node:ekr.20141020061642.21514: *4* Fixed bug 1245535: API allows headlines to contain newlines
@language python

From https://github.com/leo-editor/leo-editor/issues/73

https://bugs.launchpad.net/leo-editor/+bug/1245535
API allows headlines to contain newlines.

The fix was to v.setHeadString.
.. @+node:ekr.20141020061642.21518: *4* Fixed bug 75: write-opml-file always produces an empty file
@language rest

https://github.com/leo-editor/leo-editor/issues/75
write-opml-file always produces an empty file

leoOPML.py's docstring needs updating.

Improved the packaging as follows:

- The leoOPML plugin no longer monkey patches any part of the FileCommands
  class. Instead the plugin sets the c.opmlController ivar.

- fc.writeToFileHelper calls c.opmlController.putToOPML(owner=self).
    
- OpmlController.putToOPML is just PutToOPML(owner) where PutToOPML is a
  class that creates the opml using the owner's put method.
.. @+node:ekr.20141020112451.18306: *4* Fixed bug 76: erroneous clone markers in @auto trees
@language rest

https://github.com/leo-editor/leo-editor/issues/76
erroneous clone markers in @auto trees

The fixes were to several methods of the PersistenceDataController class.

@language python
.. @+node:ekr.20141017150357.18268: *4* Investigated bug 24: Windows installer setting wrong file association for .leo files
@language rest

https://github.com/leo-editor/leo-editor/issues/24
Windows installer setting wrong file association for .leo files

At present, everything appears to be working.

Original report
---------------

If you do ftype LeoFile after using installing LeoSetup-4.11-final.exe,
you'll see:

    LeoFile="<path to python>\pythonw.exe" "C:\Program Files (x86)\Leo-4.11-final\launchLeo.py %*"

This is wrong. As Creating Windows file associations in the Leo documentation
correctly states, this should instead be:

    LeoFile="<path to python>\pythonw.exe" "<path to launchLeo.py>\launchLeo.py" "%1" %*
.. @+node:ekr.20141020061642.21515: *4* Fixed bug 1245616: Autocomplete ? function...does not work
@language rest

From https://github.com/leo-editor/leo-editor/issues/73

https://bugs.launchpad.net/leo-editor/+bug/1245616
Autocomplete ? function to show doc string does not work

- Added lqlw.get_selection.
- get_object appends get_selection before calling get_object.
- Cleaned code in info.
.. @+node:ekr.20141024170936.6: *4* Fixed tab-completion problems
@language rest

It sometimes picked a shorter completion that is not a prefix of the present label!

Examples:
    print-se **sometimes** shows print-uas or print-bindings or...
    print-stat<tab>-h<tab> shows print-statusbar-hide
    print-st<tab> shows print-style-sheet.
    print-pr<tab> show print-plugin-handlers.
    
The fix was a single extra check in ga.do_tab.
.. @+node:ekr.20141024184556.12: *4* Fixed bug 12: when hoisted, the (alt-)arrow keys can't navigate to the top node
https://github.com/leo-editor/leo-editor/issues/12

The fix was to p.isVisible.
.. @+node:ekr.20141024184556.11: *4* Fixed bug 36: @auto file not found produces a script error
@language rest

https://github.com/leo-editor/leo-editor/issues/36

The report seems misleading: it says this happens when Leo tries to load an
@auto file that is in the outline but which's file was erased outside Leo,
but it worked for me.

I did add a guard in g.recureiveUNLFind to ensure that the IndexError shown
in the bug report can never happen.
.. @+node:ekr.20140923144655.17926: *4* Fixed bug: Find-previous fails at last node
@language rest

Find-previous fails at last node
https://groups.google.com/d/msg/leo-editor/RAzVPihqmkI/-tgTQw0-LtwJ

This only affected searches that were initiated using the buttons in the Find tab.

What I did:
    
- Init buttonFlag ivar in setup_button & setup_command.
- showSuccess sets was_in_headline ivar.
- focusInTree returns was_in_headline when buttonFlag is True.
- editLabelHelper now properly sets selection range for backward searches.
- Removed a selection hack in initNextText.

@language python
.. @+node:ekr.20031218072017.3065: *5* find.setup_button
def setup_button(self):
    '''Init a search started by a button in the Find panel.'''
    c = self.c
    self.buttonFlag = True
    self.p = c.p.copy()
    c.bringToFront()
    if 0: # We _must_ retain the editing status for incremental searches!
        c.endEditing()
    self.update_ivars()
.. @+node:ekr.20031218072017.3066: *5* find.setup_command
# Initializes a search when a command is invoked from the menu.

def setup_command(self):

    if 0: # We _must_ retain the editing status for incremental searches!
        self.c.endEditing()
    # Fix bug
    self.buttonFlag = False
    self.update_ivars()
.. @+node:ekr.20031218072017.3086: *5* find.initInHeadline & helper
def initInHeadline (self):
    '''
    Select the first pane to search for incremental searches and changes.
    This is called only at the start of each search.
    This must not alter the current insertion point or selection range.
    '''
    c = self.c
    p = self.p or c.p.copy()
    # Fix bug 1228458: Inconsistency between Find-forward and Find-backward.
    if self.search_headline and self.search_body:
        # We have no choice: we *must* search the present widget!
        self.in_headline = self.focusInTree()
    else:
        self.in_headline = self.search_headline
    # g.trace(self.in_headline,p and p.h)
.. @+node:ekr.20131126085250.16651: *6* find.focusInTree
def focusInTree(self):
    '''Return True is the focus widget w is anywhere in the tree pane.
    
    Note: the focus may be in the find pane.
    '''
    c = self.c
    ftm = self.ftm
    w = ftm.entry_focus or g.app.gui.get_focus(raw=True)
    ftm.entry_focus = None # Only use this focus widget once!
    w_name = w and g.app.gui.widget_name(w) or ''
    if self.buttonFlag and self.was_in_headline in (True,False):
        # Fix bug: https://groups.google.com/d/msg/leo-editor/RAzVPihqmkI/-tgTQw0-LtwJ
        self.in_headline = self.was_in_headline
        val = self.was_in_headline
    # Easy case: focus in body.
    elif w == c.frame.body.wrapper:
        val = False
    elif w == c.frame.tree.treeWidget:
        val = True
    else:
        val = w_name.startswith('head')
    # g.trace(self.was_in_headline,val,c.p.h)
    return val
.. @+node:ekr.20031218072017.3053: *5* find.__init__ & helpers
def __init__ (self,c):
    # g.trace('(LeoFind)',c.shortFileName(),id(self),g.callers())
    self.c = c
    self.errors = 0
    self.expert_mode = False # set in finishCreate.
    self.ftm = None
        # Created by dw.createFindTab.
    self.frame = None
    self.k = k = c.k
    self.re_obj = None
    # Options ivars: set by FindTabManager.init.
    self.batch = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.wrap = None
    self.whole_word = None
    # For isearch commands.
    self.stack = [] # Entries are (p,sel)
    self.isearch_ignore_case = None
    self.isearch_forward = None
    self.isearch_regexp = None
    self.findTextList = []
    self.changeTextList = []
    # Widget ivars.
    self.change_ctrl = None
    self.s_ctrl = SearchWidget() # For searches.
    self.find_text = ""
    self.change_text = ""
    self.radioButtonsChanged = False # Set by ftm.radio_button_callback
    # Ivars containing internal state...
    self.buttonFlag = False
    self.changeAllFlag = False
    self.findAllFlag = False
    self.in_headline = False # True: searching headline text.
    self.p = None # The position being searched.  Never saved between searches!
    self.was_in_headline = None
        # Fix bug: https://groups.google.com/d/msg/leo-editor/RAzVPihqmkI/-tgTQw0-LtwJ
    # For suboutline-only
    self.onlyPosition = None # The starting node for suboutline-only searches.
    # For wrapped searches.
    self.wrapping = False # True: wrapping is enabled.
        # This must be different from self.wrap, which is set by the checkbox.
    self.wrapPosition = None # The start of wrapped searches: persists between calls.
    self.wrapPos = None # The starting position of the wrapped search: persists between calls.
.. @+node:ekr.20131126085250.16651: *5* find.focusInTree
def focusInTree(self):
    '''Return True is the focus widget w is anywhere in the tree pane.
    
    Note: the focus may be in the find pane.
    '''
    c = self.c
    ftm = self.ftm
    w = ftm.entry_focus or g.app.gui.get_focus(raw=True)
    ftm.entry_focus = None # Only use this focus widget once!
    w_name = w and g.app.gui.widget_name(w) or ''
    if self.buttonFlag and self.was_in_headline in (True,False):
        # Fix bug: https://groups.google.com/d/msg/leo-editor/RAzVPihqmkI/-tgTQw0-LtwJ
        self.in_headline = self.was_in_headline
        val = self.was_in_headline
    # Easy case: focus in body.
    elif w == c.frame.body.wrapper:
        val = False
    elif w == c.frame.tree.treeWidget:
        val = True
    else:
        val = w_name.startswith('head')
    # g.trace(self.was_in_headline,val,c.p.h)
    return val
.. @+node:ekr.20031218072017.3089: *5* find.restore
def restore (self,data):
    '''Restore the screen and clear state after a search fails.'''
    c = self.c
    in_headline,editing,p,w,insert,start,end = data
    self.was_in_headline = not self.was_in_headline
    if 0: # Don't do this here.
        # Reset ivars related to suboutline-only and wrapped searches.
        self.reset_state_ivars()
    c.frame.bringToFront() # Needed on the Mac
    # Don't try to reedit headline.
    if p and c.positionExists(p): # 2013/11/22.
        c.selectPosition(p)
    else:
        c.selectPosition(c.rootPosition()) # New in Leo 4.5.
    # Fix bug 1258373: https://bugs.launchpad.net/leo-editor/+bug/1258373
    if in_headline:
        c.selectPosition(p)
        if False and editing:
            c.editHeadline()
        else:
            c.treeWantsFocus()
    else:
        # Looks good and provides clear indication of failure or termination.
        w.setSelectionRange(insert,insert)
        w.setInsertPoint(insert)
        w.seeInsertPoint()
        c.widgetWantsFocus(w)
.. @+node:ekr.20031218072017.3074: *5* find.findNext
def findNext(self,initFlag=True):
    '''Find the next instance of the pattern.'''
    if not self.checkArgs():
        return False # for vim-mode find commands.
    # initFlag is False for change-then-find.
    if initFlag:
        self.initInHeadline()
        data = self.save()
        self.initInteractiveCommands()
    else:
        data = self.save()
    pos, newpos = self.findNextMatch()
    if pos is None:
        if self.wrapping:
            g.es("end of wrapped search")
        else:
            g.es("not found","'%s'" % (self.find_text))
        self.restore(data)
        return False # for vim-mode find commands.
    else:
        self.showSuccess(pos,newpos)
        return True # for vim-mode find commands.
.. @+node:ekr.20031218072017.3075: *5* find.findNextMatch & helpers
def findNextMatch(self):
    '''
    Resume the search where it left off.
    The caller must call set_first_incremental_search or
    set_first_batch_search.
    '''
    trace = False and not g.unitTesting
    verbose = True
    c = self.c ; p = self.p
    if trace:
        g.trace('*** entry','p',p,'\n',
            'search_headline',self.search_headline,
            'search_body',self.search_body)
        for parent in p.parents():
            print(parent)
    if not self.search_headline and not self.search_body:
        if trace: g.trace('nothing to search')
        return None, None
    if len(self.find_text) == 0:
        if trace: g.trace('no find text')
        return None, None
    self.errors = 0
    attempts = 0
    if self.pattern_match:
        ok = self.precompilePattern()
        if not ok: return None,None
    while p:
        pos, newpos = self.search()
        if self.errors:
            g.trace('find errors')
            break # Abort the search.
        if trace and verbose:
            g.trace('pos: %s p: %s head: %s' % (pos,p.h,self.in_headline))
        if pos is not None:
            # Success.
            if self.mark_finds:
                p.setMarked()
                c.frame.tree.drawIcon(p) # redraw only the icon.
            if trace: g.trace('success',pos,newpos,p.h)
            return pos, newpos
        # Searching the pane failed: switch to another pane or node.
        if self.shouldStayInNode(p):
            # Switching panes is possible.  Do so.
            self.in_headline = not self.in_headline
            self.initNextText()
        else:
            # Switch to the next/prev node, if possible.
            attempts += 1
            p = self.p = self.nextNodeAfterFail(p)
            if p: # Found another node: select the proper pane.
                self.in_headline = self.firstSearchPane()
                self.initNextText()
    if trace: g.trace('failed after %s attempts' % attempts)
    return None, None
.. @+node:ekr.20131123071505.16468: *6* find.doWrap
def doWrap(self):
    '''Return the position resulting from a wrap.'''
    c = self.c
    if self.reverse:
        p = c.rootPosition()
        while p and p.hasNext():
            p = p.next()
        p = p.lastNode()
        return p
    else:
        return c.rootPosition()
.. @+node:ekr.20131124060912.16473: *6* find.firstSearchPane
def firstSearchPane(self):
    '''
    Set return the value of self.in_headline
    indicating which pane to search first.
    '''
    if self.search_headline and self.search_body:
        # Fix bug 1228458: Inconsistency between Find-forward and Find-backward.
        if self.reverse:
            return False # Search the body pane first.
        else:
            return True # Search the headline pane first.
    elif self.search_headline or self.search_body:
        # Search the only enabled pane.
        return self.search_headline
    else:
        g.trace('can not happen: no search enabled')
        return False # search the body.
.. @+node:ekr.20131123132043.16477: *6* find.initNextText
def initNextText(self,ins=None):
    '''
    Init s_ctrl when a search fails. On entry:
    - self.in_headline indicates what text to use.
    - self.reverse indicates how to set the insertion point.
    '''
    trace = False and not g.unitTesting
    c = self.c
    p = self.p or c.p.copy()
    s = p.h if self.in_headline else p.b
    w = self.s_ctrl
    tree = c.frame and c.frame.tree
    if tree and hasattr(tree,'killEditing'):
        # g.trace('kill editing before find')
        tree.killEditing()
    if self.reverse:
        i,j = w.sel
        if ins is None:
            if i is not None and j is not None and i != j:
                ins = min(i,j)
        # Fix bug https://groups.google.com/d/msg/leo-editor/RAzVPihqmkI/-tgTQw0-LtwJ
        # editLabelHelper now properly sets the insertion range.
            # elif ins in (i,j): ins = min(i,j)
    elif ins is None:
        ins = 0
    if trace and self.in_headline and ins is not None: g.trace(ins,p.h)
    self.init_s_ctrl(s,ins)
.. @+node:ekr.20131123132043.16476: *6* find.nextNodeAfterFail & helper (use p.moveTo...?)
def nextNodeAfterFail(self,p):
    '''Return the next node after a failed search or None.'''
    trace = False and not g.unitTesting
    c = self.c
    # Wrapping is disabled by any limitation of screen or search.
    wrap = (self.wrapping and not self.node_only and 
        not self.suboutline_only and not c.hoistStack)
    if wrap and not self.wrapPosition:
        self.wrapPosition = p.copy()
        self.wrapPos = 0 if self.reverse else len(p.b)
    # Move to the next position.
    p = p.threadBack() if self.reverse else p.threadNext()
    # Check it.
    if p and self.outsideSearchRange(p):
        if trace: g.trace('outside search range',p and p.h)
        return None
    if not p and wrap:
        p = self.doWrap()
    if not p:
        if trace: g.trace('end of search')
        return None
    if wrap and p == self.wrapPosition:
        if trace: g.trace('end of wrapped search',p and p.h)
        return None
    else:
        if trace: g.trace('found',p and p.h)
        return p
.. @+node:ekr.20131123071505.16465: *7* find.outsideSearchRange
def outsideSearchRange(self,p):
    '''
    Return True if the search is about to go outside its range, assuming
    both the headline and body text of the present node have been searched.
    '''
    trace = False and not g.unitTesting
    c = self.c
    if not p:
        if trace: g.trace('no p')
        return True
    if self.node_only:
        if trace: g.trace('Node only',p.h)
        return True
    if self.suboutline_only:
        if self.onlyPosition:
            if p != self.onlyPosition and not self.onlyPosition.isAncestorOf(p):
                if trace: g.trace('outside suboutline-only',p.h,self.onlyPosition.h)
                return True
        else:
            g.trace('Can not happen: onlyPosition!',p.h)
            return True
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.trace('outside hoist',p.h)
            g.warning('found match outside of hoisted outline')
            return True
    return False # Within range.
.. @+node:ekr.20131123071505.16467: *6* find.precompilePattern
def precompilePattern(self):
    '''Precompile the regexp pattern if necessary.'''
    trace = False and not g.unitTesting
    try: # Precompile the regexp.
        flags = re.MULTILINE
        if self.ignore_case: flags |= re.IGNORECASE
        # Escape the search text.
        b,s = '\\b',self.find_text
        if self.whole_word:
            if not s.startswith(b): s = b + s
            if not s.endswith(b): s = s + b
        if trace: g.trace(self.whole_word,repr(s))
        self.re_obj = re.compile(s,flags)
        return True
    except Exception:
        g.warning('invalid regular expression:',self.find_text)
        self.errors += 1 # Abort the search.
        return False
.. @+node:ekr.20131124060912.16472: *6* find.shouldStayInNode
def shouldStayInNode (self,p):
    '''Return True if the find should simply switch panes.'''
    # Errors here cause the find command to fail badly.
    # Switch only if:
    #   a) searching both panes and,
    #   b) this is the first pane of the pair.
    # There is *no way* this can ever change.
    # So simple in retrospect, so difficult to see.
    return (
        self.search_headline and self.search_body and (
        (self.reverse and not self.in_headline) or
        (not self.reverse and self.in_headline)))
.. @+node:ekr.20031218072017.3091: *5* find.showSuccess
def showSuccess(self,pos,newpos,showState=True):
    '''Display the result of a successful find operation.'''
    trace = False and not g.unitTesting
    c = self.c
    self.p = p = self.p or c.p.copy()
    # Set state vars.
    # Ensure progress in backwards searches.
    insert = min(pos,newpos) if self.reverse else max(pos,newpos)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
    if trace: g.trace('in_headline',self.in_headline,p)
    if c.sparse_find:
        c.expandOnlyAncestorsOfNode(p=p)
    if self.in_headline:
        c.endEditing()
        selection = pos,newpos,insert
        c.redrawAndEdit(p,
            selection=selection,
            keepMinibuffer=True)
        w = c.edit_widget(p)
    else:
        w = c.frame.body.wrapper
        # Bug fix: 2012/11/26: *Always* do the full selection logic.
        # This ensures that the body text is inited  and recolored.
        c.selectPosition(p)
        c.bodyWantsFocus()
        if showState:
            c.k.showStateAndMode(w)
        c.bodyWantsFocusNow()
        # assert w.getAllText() == p.b.replace('\r','')
        w.setSelectionRange(pos,newpos,insert=insert)
        w.seeInsertPoint() # 2014/09/17
        if trace: g.trace('p.b',len(p.b),'w.text',len(w.getAllText()),'sel',w.getSelectionRange())
        c.outerUpdate()
        if c.vim_mode and c.vimCommands:
            c.vimCommands.update_selection_after_search()
    return w # Support for isearch.
.. @+node:ekr.20031218072017.2991: *5* c.redrawAndEdit
def redrawAndEdit(self,p,selectAll=False,selection=None,keepMinibuffer=False):
    '''Redraw the screen and edit p's headline.'''
    c = self ; k = c.k
    c.redraw(p) # This *must* be done now.
    if p:
        # This should request focus.
        c.frame.tree.editLabel(p,selectAll=selectAll,selection=selection)
        if k and not keepMinibuffer:
            # Setting the input state has no effect on focus.
            if selectAll:
                k.setInputState('insert')
            else:
                k.setDefaultInputState()
            # This *does* affect focus.
            k.showStateAndMode()
    else:
        g.trace('** no p')
    # Update the focus immediately.
    if not keepMinibuffer:
        c.outerUpdate()
.. @+node:ekr.20110605121601.17909: *5* qtree.editLabel
def editLabel (self,p,selectAll=False,selection=None):
    """Start editing p's headline."""
    trace = False and not g.unitTesting
    if self.busy():
        if trace: g.trace('busy')
        return
    c = self.c
    c.outerUpdate()
        # Do any scheduled redraw.
        # This won't do anything in the new redraw scheme.
    item = self.position2item(p)
    if item:
        e,wrapper = self.editLabelHelper(item,selectAll,selection)
    else:
        e,wrapper = None,None
        self.error('no item for %s' % p)
    if trace: g.trace('p: %s e: %s' % (p and p.h,e))
    if e:
        # A nice hack: just set the focus request.
        c.requestedFocusWidget = e       
    return e,wrapper
.. @+node:ekr.20110605121601.18422: *5* qtree.editLabelHelper
def editLabelHelper (self,item,selectAll=False,selection=None):
    '''
    Help nativeTree.editLabel do gui-specific stuff.
    '''
    c,vc = self.c,self.c.vimCommands
    w = self.treeWidget
    w.setCurrentItem(item)
        # Must do this first.
        # This generates a call to onTreeSelect.
    w.editItem(item)
        # Generates focus-in event that tree doesn't report.
    e = w.itemWidget(item,0) # A QLineEdit.
    if e:
        s = e.text() ; len_s = len(s)
        if s == 'newHeadline': selectAll=True
        if selection:
            # pylint: disable=unpacking-non-sequence
            # Fix bug https://groups.google.com/d/msg/leo-editor/RAzVPihqmkI/-tgTQw0-LtwJ
            # Note: negative lengths are allowed.
            i,j,ins = selection
            if ins is None:
                start,n = i,abs(i-j)
                # This case doesn't happen for searches.
            elif ins == j:
                start,n = i,j-i
            else:
                start = start,n = j,i-j
            # g.trace('i',i,'j',j,'ins',ins,'-->start',start,'n',n)
        elif selectAll: start,n,ins = 0,len_s,len_s
        else:           start,n,ins = len_s,0,len_s
        e.setObjectName('headline')
        e.setSelection(start,n)
        # e.setCursorPosition(ins) # Does not work.
        e.setFocus()
        wrapper = self.connectEditorWidget(e,item) # Hook up the widget.
        if vc and c.vim_mode: #  and selectAll
            # For now, *always* enter insert mode.
            if vc.is_text_wrapper(wrapper):
                vc.begin_insert_mode(w=wrapper)
            else:
                g.trace('not a text widget!',wrapper)
    return e,wrapper
.. @+node:ekr.20140919052413.17945: *4* Fixed suboutline only find bug
@language rest

https://groups.google.com/d/msg/leo-editor/ujDqUI68Sx4/EwTYCw7O38cJ

qtree.onItemClicked now calls c.findCommands.reset_state_ivars()
.. @+node:ekr.20141024184556.10: *4* Investigated bug 56: Focus change on tree pane after saving current Leo file
@language rest

https://github.com/leo-editor/leo-editor/issues/56

I do not see this behavior.

===== Report

When I save the leo file, instead of staying where I am on the leo tree, it
will go and center the view on the selected node. 

.. @+node:ekr.20141026191037.6: *4* Can't fix bug 83: Bracket completion doesn't work
@language rest

https://github.com/leo-editor/leo-editor/issues/83
.. @+node:ekr.20140819050118.18319: *3* Code
.. @+node:ekr.20140114145953.16692: *4* Added c.config.isLocalSetting
.. @+node:ekr.20140218040104.16759: *4* Added p.nosentinels
.. @+node:ekr.20140702124615.16727: *4* Added support for html handlebar syntax coloring
These are colored with the previously unused literal3 tag,
so you specify the color with:

    @color html_literal3_color = pink
.. @+node:ekr.20140427131738.16870: *4* Added support for qt5
@language rest

It is not possible to use both the PyQt4 and PyQt5 installers at the same
time. But this is no big deal on Windows: just install PyQt5 for Python 3.4
only.
.. @+node:ekr.20140426105101.16868: *4* Converted all class names to pep8 style
Capitalized, no underscores.
.. @+node:ekr.20131223064351.16352: *4* Improved p.isAncestorOf and c.positionExists
- Added test for c.positionExists to p.isAncestorOf.
- Added v.isNthChildOf
- Rewrote c.positionsExists using v.isNthChildOf
.. @+node:ekr.20140426052603.18136: *4* Removed g.choose from Leo's core & plugins
This function is deprecated: use Python's ternary operator instead.
.. @+node:ekr.20140816165728.18938: *4* Rewrote & simplified k.getArg
What I did:
- Removed prefix arg to all calls to k.getArg.
  Not needed now that there is better convention for k.setLabelBlue.
- Removed protect argument from k.setLabelBlue.
  Some code now uses k.extendLabel to mix protect and unprotected parts of the label.
  
- k.fnc and k.getArgInstance now created by finishCreate.
  This guarantees that the c,k and log ivars are inited properly.
- Allow <tab> to escape to :r and :tabname code.
  This required several kludges.

.. @+node:ekr.20140821112622.18367: *4* Changed most calls to k.setLabel to k.setStatusLabel
@nocolor-node

Leo's core now calls k.setStatusLabel, not k.setLael, to report the status
of a Leo command. This allows an option (does not exist yet) to use g.es
instead of the minibuffer to report status.
.. @+node:ekr.20140825071827.18528: *4* Created g.IdleTime and qtGui.IdleTime
@language rest

Rev 060c33a...Leo build: 20140825070951 contains a spectacular collapse in
complexity in idle-time handling. Instantly, registering idle-time event
handlers can be considered deprecated, though I have no plans to remove the
horrendous older code.

The new pattern allows multiple, independent (or cooperating) idle-time
handlers, created at will as needed.

The new code is based on the IdleTime class in qtGui.py. Rather than access
this directly, code should use the g.IdleTime proxy:: g.IdleTime ensures
that all is well when using gui's that don't have an IdleTime class.

Here is how to use the new code::

    def handler(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace(it.count,it.c.shortFileName(),'%2.4f' % (delta_t))
        if it.count >= 5:
            g.trace('done')
            it.stop()
    it = g.IdleTime(c,handler,delay=500)
    if it: it.start()

The code creates an instance of the IdleTime class that calls the given handler at idle time, and no more than once every 500 msec.  Here is the output::

    handler 1 ekr.leo 0.5100
    handler 2 ekr.leo 1.0300
    handler 3 ekr.leo 1.5400
    handler 4 ekr.leo 2.0500
    handler 5 ekr.leo 2.5610
    handler done

Timer instances are completely independent.  For example:

    def handler1(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t))
        if it.count >= 5:
            g.trace('done')
            it.stop()

    def handler2(it):
        '''The IdleTime handler: called at idle time.'''
        delta_t = it.time-it.starting_time
        g.trace('%2s %s %2.4f' % (it.count,it.c.shortFileName(),delta_t))
        if it.count >= 10:
            g.trace('done')
            it.stop()

    it1 = g.IdleTime(c,handler1,delay=500)
    it2 = g.IdleTime(c,handler2,delay=1000)
    if it1 and it2:
        it1.start()
        it2.start()

Here is the output::

    handler1  1 ekr.leo 0.5200
    handler2  1 ekr.leo 1.0100
    handler1  2 ekr.leo 1.0300
    handler1  3 ekr.leo 1.5400
    handler2  2 ekr.leo 2.0300
    handler1  4 ekr.leo 2.0600
    handler1  5 ekr.leo 2.5600
    handler1 done
    handler2  3 ekr.leo 3.0400
    handler2  4 ekr.leo 4.0600
    handler2  5 ekr.leo 5.0700
    handler2  6 ekr.leo 6.0800
    handler2  7 ekr.leo 7.1000
    handler2  8 ekr.leo 8.1100
    handler2  9 ekr.leo 9.1300
    handler2 10 ekr.leo 10.1400
    handler2 done
.. @+node:ekr.20140827123957.18478: *4* Improved speed of selection logic
@nocolor-node

0. Added details timing traces throughout the selectHelper logic.
   These traces showed precisely where the performance bugs were.

1. updateSyntaxColorer now does nothing if the body text starts with @killcolor.

2. w.setSelectionRangeHelper and v.restoreCursorAndScroll had performance bugs
because they called code that computed the length of text slowly.

3. The solution: w.setSelectionRangeHelper and all setInsertPoint methods
now take an 's' keyword arg. In the selection logic, s is set to p.b.
If s is not None, the desired length is simply len(s)

As a result, w.setSelectionRangeHelper no longer calls lengthHelper.
lengthHelper used QTextCursor, which is *much* slower than getAllText.

4. Even though all w.setInsertPoint methods have an s keyword arg,
   v.restoreCursorAndScroll uses the following defensive code::
       
    try:
        w.widget.setInsertPoint(ins,s=v._bodyString)
    except TypeError:
        w.setInsertPoint(ins)
.. @+node:ekr.20140905070127.18559: *4* A major reorg of Leo's code
@language rest

One change is required to all plugins and scripts:

    body.bodyCtrl.x -> body.wrapper.x
    
There is a script that does this automatically.


What I did
- Created "@test interfaces using API classes" based on the checking script.
- The various isTextWidget methods now check for the existence of a supportsHighLevelInterface ivar.
- StringTextWrapper is now a stand-alone class.
- Removed BaseTextWrapper.
- LeoLog is no longer a subclass of the HighLevelInterface class.
  This required a hack to handle keystrokes in the log pane:
  k.masterKeyHandler sends strokes to c.frame.log.logWidget (a QTextEditWrapper)
  by changing event.widget.
  QTextMixin sets supportsHighLevelInterface = True as a signal to k.handleDefaultChar.
- Eliminated redirection code from LeoQtBody class.
- LeoBody is no longer a subclass of the HighLevelInterface class.
    - The only changes, one or two new guards.
- Create WrapperAPI class whose text indicates expected type of the result.
- Removed wrapper.getFocus method.
- Removed all references to HighLevelInterface class in the core.
- Removed the evil set_focus synonym in the HighLevelInterface class.
.. @+node:ekr.20140909072923.18136: *4* Converted 7 plugins so they work with PyQt5
active_path.py, attrib_edit.py, contextmenu.py, graphcanvas.py,
notebook.py, projectwizard.py, stickynotes.py
.. @+node:ekr.20141015035853.18305: *4* Simplified gnx scan logic
@language rest

1. createSaxVnode now does::
    
    v.fileIndex = ni.tupleToString(x.scanGnx(sax_node.tnx))
    
ni.tupleToString is substantially simpler than ni.toString.

This is the only call to tupleToString in Leo.

2. Removed ni.toString.

3. ni.scanGnx no longer converts n to an int.  It's going to become a string again anyway.

4. The new fc.setMaxNodeIndex *does* convert the n field to an int, but
   this very rarely happens.

@language python
.. @+node:ekr.20141021133422.12578: *4* Delayed allocation of gnx's...
@nocolor-node

- fc.getLeoFile now calls ni.begin/end_holding
- Added gnx keyword arg to VNode ctor.
- Added traces to pd.restore_gnx

What I did:
    
- checked all calls to VNode ctor.
- checked all calls to getNewIndex.
- checked all calls to fileIndex =
.. @+node:ekr.20141023110422.3: *4* Created ni.updateLastIndex
@language rest

pd.restore_gnx and fc.getLeoOutlineFromClipboard now call v.setFileIndex()

v.fileIndex calls ni.updateLastIndex.

@language python
.. @+node:ekr.20141023154408.4: *4* Delayed allocation of vnodes
https://groups.google.com/d/msg/leo-editor/JWhlmJBiesk/RsC64VZ1gxQJ
.. @+node:ekr.20140702131031.16727: *3* Features
.. @+node:ekr.20131105020211.18059: *4* Added per-node expansions!
@language rest
https://groups.google.com/forum/#!topic/leo-editor/Wd0NtBLEZZk

What I did:

- Added v.expandedPositions ivar.
- Wrote c.shouldBeExpanded.
- p.isExpanded calls c.shouldBeExpanded if p is a clone.
  This is important: it means that most code does not have to be aware of c.shouldBeExpanded.
- p.expand & p.contract maintain p.v.expandedPositions list.
- Rewrote & simplified p.isVisible.
- Left c.positionExists and p.isAncestorOf unchanged.
.. @+node:ekr.20131222112420.16373: *5* Notes
The idea is store "ephemeral" or position-related data **in vnodes*. This
is a completely new idea in Leo's history!

Suppose every vnode contains a new ivar: v.expandedPositions, a list of
(copies of) positions at which v is to be expanded. This would work as
follows:

1. Contracting a node at position p clears p.v.expandedPositions. The happy
   side effects is that contracting any clone will contract them all.

2. Expanding a node at position appends p.copy() to p.v.expandedPositions,
   and purges any no-longer-existing positions from that list.

3. nativeTree.drawChildren will expand nodes using c.shouldBeExpanded(p) instead of
   p.isExpanded(p).

As always, changing outline structure will invalidate positions. Because
c.p and all it's ancestors are always expanded, the worst that can happen
when an outline changes is that some positions that *aren't* the present
position will contract unexpectedly. Most such contraction will occur off
screen.
.. @+node:ekr.20140212082408.16406: *4* Added spell-as-you-type commands
Thanks to Terry Brown for these commands::

spell-as-you-type-toggle
  Enable / disable spell as you type mode.  When enabled, word ending
  keystrokes will put a short list of suggestions in the log window, if
  the word is unknown to the speller.  Only shows the first 5
  suggestions, even if there are more.

spell-as-you-type-next
  Cycle the word behind (left of, for ltr languages) the cursor through
  the full list of suggestions.

spell-as-you-type-undo
  Change the word behind (left of, for ltr languages) the cursor to
.. @+node:ekr.20140401054342.16845: *4* Created g.run_pylint so pylint can run unmodified
@language rest

This runs pylint (with optional Sherlock tracing) in
a separate process, thereby allowing Leo to run
pylint unchanged.

What I did:

1. pylint-leo.py: run now runs the following command in a separate process::

    <python> -c "import leo.core.leoGlobals as g; g.run_pylint(<args>)"
    
2. g.run_pylint uses Sherlock tracing if requested.

    
.. @+node:ekr.20140601151054.17620: *4* Improved find/replace-all commands
@nocolor-node

These commands now get their arguments from the Find Panel.

Changed the following methods:

generalChangeHelper,
minibufferFind/ReplaceAll,
searchWithPresentOptions,
setReplaceString,

Also fixed the bindings in create_find_buttons so buttons
are bound to the proper button-related methods. As a result,
the find-all and change-all buttons now work as expected.
.. @+node:ekr.20140702091137.16754: *4* Improved idle-time handling and added new commands
@language rest

Added the following commands:
    
disable-idle-time-tracing
enable-idle-time-tracing
toggle-idle-time-tracing
disable-idle-time-events
enable-idle-time-events
toggle-idle-time-events

Simplified and generalized idle-time handling as follows:
    
- Removed g.app.afterHandler: g.app.idleTimeHook does the same thing now.
- The timer callback now calls g.app.idleTimeHook() if it exists.
- g.enableIdleTimeHook now has the following signature::
    
    def enableIdleTimeHook(idleTimeDelay=500,idleTimeHandler=None):
        
  The two args set g.app.idleTimeDelay and g.app.idleTimeHandler respectively.
  g.idleTimeHookHandler is used if idleTimeHandler is None.

The new code has these properties:
    
1. g.app.idleTimeHook() actually gets called only at idle-time,
2. There is no busy waiting, and
3. There is at least g.app.idleTimeDelay msec. between calls to g.app.idleTimeHook()

Here is an script illustrating the possibilities::

@language python

'''
A script illustrating interacting idle-time handlers.
Do Alt-x enable-idle-time-tracing before executing this script
'''
class Handlers:
    def h1(self):
        g.trace()
        g.enableIdleTimeHook(1000,self.h2)
    def h2(self):
        g.trace()
        g.enableIdleTimeHook(500,self.h1)
h = Handlers()
if g.app.idleTimeHook:
    g.disableIdleTimeHook()
else:
    g.enableIdleTimeHook(1000,h.h1)
.. @+node:ekr.20140402091953.16865: *4* Added pylint command
@language rest

When pylint is available on your machine, Leo's pylint
command will execute run pylint on all @<file> nodes in the
selected tree. This command is now available from the popup
menus created by the contextmenu plugin.

This command is a dynamic way of selecting files to check
with pylint. It is *much* easier to use than the old pylint
-r option in pylint-leo.py. There is no longer any need to
update a list of "recent" files. Hooray.

The command has significantly changed my work flow. I use
pylint much more often.

The details of the search process are as follows:

1. The command looks down the tree of the selected node,
   looking for @<file> nodes.
2. If now @<file> nodes are found, it looks up the tree,
   looking for @<file> nodes.
3. If the selected node is a clone, and no @<file> nodes
   have yet been found, it expands the search to all
   ancestors of all positions cloned to the selected node.

This means that you can check a file by selecting any
(possibly clone) node of the file.

**Important**: running pylint-leo.py is still often very
useful. In particular, I often run python pylint-leo.py -a
to check all files. Here is the recently improved docstring
for pylint-leo.py::

    '''
    This file runs pylint on predefined lists of files.
    
    The -r option no longer exists. Instead, use Leo's pylint command to run
    pylint on all Python @<file> nodes in a given tree.
    
    On windows, the following .bat file runs this file::
        python27 pylint-leo.py %*
    
    On Ubuntu, the following alias runs this file::
        pylint="python27 pylint-leo.py"
    '''
.. @+node:ekr.20140720065949.17739: *4* Created @auto-org-mode
@language rest

Note: persistence applies to @auto-vimoutline-mode and @auto-org-mode

Done:
- Added @auto-org-mode to list of valid @auto nodes.
- Created org-mode importer.
- Create at.writeOneOrgModeNode, called from at.writeOneAtAutoNode

@language python
.. @+node:ekr.20140727180847.17989: *4* Completed generalization of importers
@language rest

- ic.createOutline and its helper, ic.dispatch, now use tables
  created by ic.createImporterData and its helper.

- Eliminated odious special cases involving self.treeType in
  ic.create_top_node and ic.init_import.
  
- self.treeType is used only in a limited way in the scanner classes:
  The only tests are against '@root' and '@file'.
  
- For now, the unit-tests wrappers are hard-coded.
.. @+node:ekr.20140723120730.17921: *4* The @auto write code now uses writer plugins
@language rest

What I did:
- at.createWritersData inits tables using the writers_dict in each plugin.
- at.writeOnAtAutoNode calls at.dispatch to find writers.
  An important escape hatch: at.writeOnAtAutoNode calls the *existing* rst.writer
  if the user deletes plugins/writers/rst.py.

Won't do:
- at.writeAllHelper has lots of special-case code, but that probably can't be helped.
- It would be way too dangerous to refactor the write code for @file, @shadow, etc.
    
@language python
.. @+node:ekr.20140729162415.18088: *4* Leo now supports dynamic @auto names
@language rest

The leo/plugins/importers folders now contains importer plugins.

The leo/plugins/writers folders now contain writer plugins.

Both importer and writer plugins can defined new kinds of @auto nodes.

Importers and writers can register either @auto-names or
file extensions. I have just verified that @auto x.xyzzy
will use both the importer and the writer for the .xyzzy
extension, that is, importers/test.py and writers/test.py.
So, for *unique* extensions, there is no need to use a
separate @auto name, you can just use @auto.

What I did:

- atFile.ctor sets two sets of spellings of @auto names: g.app.atAutoNames
  & g.app.atFileNames

- Loading importer & writer plugins updates g.app.atAutoNames:
    - at.parse_writer_dict sets at.atAutoWritersDict & at.writersDispatchDict
    - ic.parse_importer_dict sets ic.atAutoDict and ic.classDispatchDict

@language python
.. @+node:ekr.20140730072544.17981: *4* Leo imports importers & writers from home/.leo
@language rest

Leo now imports from ~/.leo/plugins before importing from leo/plugins.

The new code is in at.createWritersData & helper and ic.at.createImportersData & their helpers.
.. @+node:ekr.20140730081842.17990: *5*  demo script
'''Load each plugins ~/.leo/plugins if possible, then from leo/plugins.'''
import glob
def report(message,kind,folder,name):
    g.trace('%7s: %5s %9s %s' % (message,kind,folder,name))
g.cls()
plugins1 = g.os_path_finalize_join(g.app.homeDir,'.leo','plugins')
plugins2 = g.os_path_finalize_join(g.app.loadDir,'..','plugins')
seen = set() # set of (folder,sfn)
for kind,plugins in (('home',plugins1),('leo',plugins2)):
    if g.os_path_exists(plugins):
        for folder in ('importers','writers'):
            path = g.os_path_finalize_join(plugins,folder)
            pattern = g.os_path_finalize_join(plugins,folder,'*.py')
            for fn in glob.glob(pattern):
                sfn = g.shortFileName(fn)
                if g.os_path_exists(fn) and sfn != '__init__.py':
                    moduleName = sfn[:-3]
                    if moduleName:
                        data = (folder,sfn)
                        if data in seen:
                            report('seen',kind,folder,sfn)
                        else:
                            m = g.importFromPath(moduleName,path) # Uses imp.
                            if m:
                                seen.add(data)
                                report('loaded',kind,folder,m.__name__)
                            else:
                                report('error',kind,folder,sfn)
                # else: report('skipped',kind,folder,sfn)
.. @+node:ekr.20140815081211.18471: *4* Cleaned up command-name handling a bit
Changed k.inverseCommandsDict to c.inverseCommandsDict.
Called vc.define commands from c.finishCreate.
Changed ecm.finishCreateEditCommanders to ecm.defineCommandNames.
The new c.createCommandNames copies entries in g.app.global_commands_dict to commander c.
    Note: @g.command makes entries in g.app.global_commands_dict.
.. @+node:ekr.20140813144229.19018: *4* Added insert-file-name command
# The code is in leoEditCommands.py::insertFileName.
.. @+node:ekr.20140821164256.18294: *4* Added vim mode
See: http://leoeditor.com/vimBindings.html#using-leo-s-native-vim-mode
.. @+node:ekr.20140821115448.18291: *5* Support visual line mode
@nocolor-node


do_visual_mode will extend the selection if visual_line_mode is True.

Affected methods: vc.vim_V and vc>do_visual_mode.

It would be good if LeoQTextEditWidget.setSelectionRangeHelper could handle
insert points in the middle of a text selection, but at present it can't.
.. @+node:ekr.20140828033858.18516: *4* Added clone-find-parents command
Added c.cloneFindParents.
.. @+node:ekr.20140910065834.18127: *4* Changed Leo's namespace in .leo files
The xml namespace line at the start of .leo files has been:

    <leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >

The new line line is:

    <leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
.. @+node:ekr.20140917063815.18007: *4* Leo's main style sheet is fully parameterized
All aspects of the style sheet can now be altered using normal user settings.
.. @+node:ekr.20140828033858.18521: *4* Enabled big-text buttons
@language rest

The user can lose tail text if they start typing before the body text completely loads!

- Added c.max_pre_loaded_body_chars = c.config.getInt('max-pre-loaded-body-chars')

- The "dummy" body text now contains a warning to wait until the text fully loads.

@language python
.. @+node:ekr.20140917180536.17912: *4* Added --trace-plugins option & corresponding leoBridge option
- Added --trace-plugins option
- The leoBridge now supports the tracePlugins keyword option.
.. @+node:ekr.20140918060252.19480: *4* Leo stylesheets now support all color names in leoColor.py
For example, this setting works without any explicit definition of mistyrose2.
    
    @color head-bg = @mistyrose2
    
.. @+node:ekr.20141010095448.20599: *4* ** beautify command now uses PythonTidy
@language rest

This is a major upgrade to the beautify command.

PythonTidy (tidy for short) does a full parse of the Python sources: https://pypi.python.org/pypi/PythonTidy/

What I did today.  See the << version info >> section for all the details::

1. Leonized tidy's sources: @file ../external/PythonTidy.py in in LeoPyRef.leo.

- Removed all pylint complaints and made other minor mods.
 
2. Suppressed features not appropriate for Leo:

- Adds shebang and encoding lines only for @<file> nodes.
- Suppress extra spacing between classes & functions.

3. Added settings to leoSettings.leo that control tidy operation:

    @bool tidy_add_blank_lines_around_comments =True
    @bool tidy_double_quoted_strings = False
    @bool tidy_keep_blank_lines = True
    @bool tidy_left_adjust_docstrings = False
    @int  tidy_lines_before_split_lit = 2
    @int  tidy_seps_before_split_line = 8

3. Fixed several important bugs:

- The original code deleted all comments because of a botch in Comments__init__.
- Tidy now properly handles the tidy_add_blank_lines_around_comments and tidy_double_quoted_strings settings.
.. @+node:ekr.20141022211918.6: *4* added --no-persist command-line option
@language rest

removed new_auto switch in leoAtFile.py

added g.app.at_auto_persist

c.persistenceController exists only if g.app.auto_persist is True
.. @+node:ekr.20131025044901.17146: *4* Added new clone-to-last-node
@language rest

This does *not* change the selected node so it's easy to
clone several nodes.

Added c.cloneToLastNode.  
.. @+node:ekr.20141024211256.21: *4* Improved check outline
It now tests that all gnx's exist and are unique.
.. @+node:ekr.20141026133611.7: *4* Added @bool auto-scroll-find-tab
The default is True, so as to enable the "fix" to bug
1254861: find - ctrl-f doesn't ensure find input field
visible https://bugs.launchpad.net/leo-editor/+bug/1254861

I found the new behavior extremely unpleasant. For me, it
was the worst fit-and-finish issues with Leo.
.. @+node:ekr.20141026133611.9: *4* Rewrote at_produce plugin
This plugin used ancient coding technology, created menu
items instead of minibuffer commands, did not report
progress and was probably not thread safe.

All these defects have now been remedied.  It could be quite useful in some situations.

For example, suppose node P has this body text::

    @produce echo pylint commands
    @produce pylint -v
    @produce pylint -f core\leoAtFile.py
    @produce pylint -g

Selected node P and running the at-produce-selected command produces these messages in the log pane::

    @produce pylint -g
    @produce pylint -g
    @produce pylint -g
    @produce pylint -g
    at-produce done

And produces a node whose headline is::

    produce.log from Sun Sep 21 06:35:37 2014

And whose body text is::

    produce: echo pylint commands
    pylint commands
    ===============
    produce: pylint -v
   
    c:\leo.repo\leo-editor>python27 pylint-leo.py -v
   
    c:\leo.repo\leo-editor>c:\python27\python.exe pylint-leo.py -v
    pylint-leo.py 1.1.0,
    astroid 1.0.1, common 0.61.0
    Python 2.7.2 (default, Jun 12 2011, 15:08:59) [MSC v.1500 32 bit (Intel)]
    ===============
    produce: pylint -f core\leoAtFile.py
   
    c:\leo.repo\leo-editor>python27 pylint-leo.py -f core\leoAtFile.py
   
    c:\leo.repo\leo-editor>c:\python27\python.exe pylint-leo.py -f core\leoAtFile.py
    pylint-leo.py: core\leoAtFile.py
    time:  5.000 sec.
    ===============
    produce: pylint -g
   
    c:\leo.repo\leo-editor>python27 pylint-leo.py -g
   
    c:\leo.repo\leo-editor>c:\python27\python.exe pylint-leo.py -g
    pylint-leo.py: plugins\free_layout.py
    pylint-leo.py: plugins\nested_splitter.py
    pylint-leo.py: plugins\qt_commands.py
    pylint-leo.py: plugins\qt_events.py
    pylint-leo.py: plugins\qt_frame.py
    pylint-leo.py: plugins\qt_idle_time.py
    pylint-leo.py: plugins\qt_gui.py
    pylint-leo.py: plugins\qt_text.py
    pylint-leo.py: plugins\qt_tree.py
    time: 40.073 sec.
    ===============
.. @-all

# Put this @language after the @all as a kind of permanent unit test.

.. @@language python # Override the default .txt coloring.

.. @@pagewidth 60
.. @-leo
