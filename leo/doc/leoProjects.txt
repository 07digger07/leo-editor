#@+leo-ver=5-thin
#@+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
#@+all
#@+node:ekr.20111103205308.9698: ** Unit tests
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)

s1 = '''
<table id="1"> <table id="2">
<contents/>
</table>
</table>
'''

s2 = '''
<table id="1"> 
<table id="2">
<contents/>
</table>
</table>
'''

t1 = 
assert result == expected,'expected...\n%s\ngot...\n%s' % (
    repr(expected),repr(result))
#@+node:ekr.20100907115157.5905: *3* @ignore Ancient tests
#@+node:ekr.20100208095423.5940: *4* @test leoCache
import leo.core.leoCache as leoCache

cacher = leoCache.cacher(c)

if 0:
    import os
    os.system('cls')

assert cacher.test()
#@+node:ekr.20100906165118.5915: *4* @test leoInkCommands
ic = c.inkscapeCommands
screenshot = r'c:\leo.repo\inkcall\some_screen_shot.png'
template_fn = r'c:\leo.repo\inkcall\template.svg'
png_fn = r'c:\leo.repo\inkcall\output.png'
svg_fn = r'c:\leo.repo\inkcall\temp.svg'
callouts = [
        "This goes here",
        "These are those, but slightly longer",
        "Then you pull this, but this text needs to be longer for testing",]
ic.run(
    screenshot,
    callouts=callouts,
    numbers=[2,4,17],
    edit_flag = True, # True: call inkscape to edit the working file.
    png_fn=png_fn, # Optional: Name of output png file.
    svg_fn=svg_fn, # Optional: Name of working svg file.
    template_fn=template_fn, # Optional: Name of template svg file.
)
#@+node:ekr.20111102123707.9629: *4* @ignore test of marked unit-test trees
#@+node:ekr.20111102123707.9630: *5* @test assert False
assert False
#@+node:ekr.20111102123707.9631: *5* @test assert True
assert True
#@+node:ekr.20111107092526.9799: *4* @test detection of external unit tests
# This test is redundant, and another test sets import_html_tags

# print('g.app.isExternalUnitTest',g.app.isExternalUnitTest)
if g.app.isExternalUnitTest:
    fn = c.shortFileName()
    assert fn.endswith('dynamicUnitTest.leo'),fn
    data = c.config.getData('import_html_tags')
    assert len(data) == 85 # length of data in leoSettings.leo.
else:
    data = c.config.getData('import_html_tags')
    assert len(data) == 85,len(data)
#@+node:ekr.20111107092526.9800: *5* doTests...
def doTests(c,all=None,marked=None,p=None,verbosity=1):

    trace = False ; verbose = False
    if all:
        p = c.rootPosition()
    elif not p:
        p = c.p
    p1 = c.p.copy() # 2011/10/31: always restore the selected position.
    
    g.trace(g.app.isExternalUnitTest)
    
    # This seems a bit risky when run in unitTest.leo.
    # c.save() # Eliminate the need for ctrl-s.
    
    if trace: g.trace('marked',marked,'c',c)

    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)

        # New in Leo 4.4.8: ignore everything in @ignore trees.
        last = None if all else p.nodeAfterTree()
        
        aList = findAllUnitTestNodes(c,p,last,all,marked,
            lookForMark=False,lookForNodes=True)
       
        found = False
        for p in aList:
            if isTestNode(p):
                if trace: g.trace('adding',p.h)
                test = makeTestCase(c,p)
            elif isSuiteNode(p): # @suite
                if trace: g.trace('adding',p.h)
                test = makeTestSuite(c,p)
            else:
                test = None
            if test:
                suite.addTest(test)
                found = True
        
        # Verbosity: 1: print just dots.
        if not found:
            # 2011/10/30: run the body of p as a unit test.
            test = makeTestCase(c,c.p)
            if test:
                suite.addTest(test)
                found = True
        if found:
            res = unittest.TextTestRunner(verbosity=verbosity).run(suite)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
                c.cacher.db[key] = archive
        else:
            g.es_print('no %s@test or @suite nodes in %s outline' % (
                g.choose(marked,'marked ',''),
                g.choose(all,'entire','selected')),color='red')
    finally:
        c.setChanged(changed) # Restore changed state.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.contractAllHeadlines()
            c.redraw(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20111107092526.9801: *6* class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20111107092526.9802: *7* __init__ (generalTestCase)
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@+node:ekr.20111107092526.9803: *7*  fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@+node:ekr.20111107092526.9804: *7* tearDown
def tearDown (self):

    pass

    # Restore the outline.
    self.c.outerUpdate()
#@+node:ekr.20111107092526.9805: *7* setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p.copy()) # 2010/02/03
#@+node:ekr.20111107092526.9806: *7* runTest (generalTestCase)
def runTest (self,define_g = True):

    trace = False
    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)
    
    if c.shortFileName() == 'dynamicUnitTest.leo':
        c.write_script_file = True

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p and p.copy(),'self':self,}
    else:
        d = {'self':self,}

    script = script + '\n'
    if trace: g.trace('p: %s c: %s write script: %s script:\n%s' % (
        p and p.h,c.shortFileName(),c.write_script_file,script))

    # Execute the script. Let the unit test handle any errors!
    # 2011/11/02: pass the script sources to exec or execfile.
    if c.write_script_file:
        scriptFile = c.writeScriptFile(script)
        if g.isPython3:
            exec(compile(script,scriptFile,'exec'),d)
        else:
            execfile(scriptFile,d)
    else:
        exec(script,d)
#@+node:ekr.20111107092526.9807: *7* shortDescription
def shortDescription (self):

    s = self.p.h

    # g.trace(s)

    return s + '\n'
#@+node:ekr.20111107092526.9808: *6* makeTestSuite (leoTest)
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()
    # g.trace('c.write_script_file',c.write_script_file)
    script = g.getScript(c,p).strip()
    if not script:
        print("no script in %s" % h)
        return None
    try:
        if 0: #debugging
            n,lines = 0,g.splitLines(script)
            for line in lines:
                print(n,line)
                n += 1
                
        # 2011/11/02: make script sources available.
        d = {'c':c,'g':g,'p':p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            if g.isPython3:
                exec(compile(script,scriptFile,'exec'),d)
            else:
                execfile(scriptFile,d)
        else:
            exec(script + '\n',d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("makeTestSuite: %s script did not set g.app.scriptDict" % p.h)
        return suite
    except Exception:
        print('makeTestSuite: exception creating test cases for %s' % p.h)
        g.es_exception()
        return None
#@+node:ekr.20111107092526.9809: *6* makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.b.strip():
        return generalTestCase(c,p)
    else:
        return None
#@+node:ekr.20111107092526.9810: *5* main & helpers (leoDynamicTest.py)
def main ():

    trace = False
    readSettings = True 
    tag = 'leoDynamicTests.leo'
    if trace: t1 = time.time()

    # Setting verbose=True prints messages that would be sent to the log pane.
    path,gui,silent = scanOptions()
    # print('(leoDynamicTest.py:main)','silent',silent)

    # Not loading plugins and not reading settings speeds things up considerably.
    bridge = leoBridge.controller(gui=gui,
        loadPlugins=False, # Must be False: plugins will fail when run externally.
        readSettings=True, # True adds about 0.3 seconds.  Is it useful?
        silent=True,
        verbose=False)

    if trace:
         t2 = time.time()
         print('%s open bridge:  %0.2fsec' % (tag,t2-t1))

    if bridge.isOpen():
        g = bridge.globals()
        g.app.silentMode = silent
        g.app.isExternalUnitTest = True
        path = g.os_path_finalize_join(g.app.loadDir,'..','test',path)
        c = bridge.openLeoFile(path)
        if trace:
            t3 = time.time()
            print('%s open file: %0.2fsec' % (tag,t3-t2))
        runUnitTests(c,g)
#@+node:ekr.20111107092526.9811: *6* runUnitTests
def runUnitTests (c,g):

    p = c.rootPosition()
    #g.es_print('running dynamic unit tests...')
    c.selectPosition(p)
    c.debugCommands.runAllUnitTestsLocally()
#@+node:ekr.20111107092526.9812: *6* scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('--path',dest='path')
    parser.add_option('--gui',dest="gui")
    parser.add_option('--silent',action="store_true",dest="silent")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)

    # -- path
    # We can't finalize the path here, because g does not exist ye.
    path = options.path or 'dynamicUnitTest.leo'

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('qttabs','qt'):
        gui = 'nullGui'

    # --silent
    silent = options.silent

    return path,gui,silent
#@+node:ekr.20111116161118.10248: *3* Recent tests
#@+node:ekr.20111104132424.9909: *4* @test assert True
# It's useful to have this do-nothing test.

assert True
#@+node:ekr.20111107092526.9819: *4* @test cls
g.cls() # Clear the screen
#@+node:ekr.20111110085739.10265: *4* @test html string
s = '''\
<HTML>
<head>
    <title>Bodystring</title>
</head>
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
</html>
'''

html_tags = ('body','head','html','table',) # 'div',
setting = 'import_html_tags'

# Settings now work when run externally.
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.app.unitTestDict ['expectedErrors'] = 0

showTree = True

c.importCommands.htmlUnitTest(p,s=s,showTree=showTree)

if showTree:
    # g.cls()
    for p in p.subtree():
        print('\n***** %s\n' %p.h)
        print(p.b)
#@+node:ekr.20120112100822.10003: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120112100822.10004: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120112100822.10005: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120112100822.10006: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120203153754.10033: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120203153754.10034: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120203153754.10035: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120203153754.10036: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120204061120.10061: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120204061120.10062: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120204061120.10063: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120204061120.10064: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20111109151106.9746: *4* @test htmlScanner.filterTokens
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)
strip = hs.stripTokens
dump  = hs.formatTokens

s1 = '''<table id="1"><table id="2">
<contents/>
</table>
</table>'''

s2 = '<table id="1"><table id="2"><contents/></table></table>'
    
t1 = hs.tokenize(s1)
t2 = hs.tokenize(s2)
f1 = hs.filterTokens(t1)
f2 = hs.filterTokens(t2)

assert strip(f1) == strip(f2),'f1...\n%s\nf2...\n%s' % (
    dump(f1),dump(f2))
    
if 0:
    print(dump(f1))
#@+node:ekr.20111110084957.10092: *4* @test import dataN.html
fn = r'c:\recent\data.html'

# fn = r'c:\recent\data-smaller.html'
# fn = r'c:\recent\data666.html'

# These all pass on data.html:
    # html_tags = ('html','head','body',)
    # html_tags = ('html','head','body','table',)
    # html_tags = ('html','head','body','table','div',)
    # html_tags = ('html','head','body','table','div','script',)
    # html_tags = ('html','head','body','table','div','script','link',)
    # html_tags = ('html','head','body','table','div','script','link','p',)

html_tags = ('html','head','body','table','div','script','p','td','tr',)

# Settings now work when run externally.
setting = 'import_html_tags'
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.cls()

c.importCommands.importFilesCommand(files=[fn], treeType='@file')
#@+node:ekr.20111109105907.9795: *4* @test unicode stuff
@first # -*- coding: utf-8 -*-

table = (
    'test',
    'Ä 궯 奠',
    'Ä 궯 奠 after', # fails with cp6501: after is duplicated.
)

print('*'*20)
print('isPython3: %s' % g.isPython3)

for s in table:
    if g.isPython3:
        s = s.encode('ascii','replace') # create bytes.
    g.es(repr(s))
    g.es(s)
    g.pr ('g.pr(s)       : %s' % s)
    g.pr ('g.pr(repr(s)) : %s' % repr(s))
    print('print(s)      : %s' % s)
    print('print(repr(s)): %s' % s)
#@+node:ekr.20111113064104.9841: *4* @test external text operations
assert g.app.isExternalUnitTest

body = c.frame.body
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl

w = body.bodyCtrl
w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111112131605.9789: *4* @test nullBody text operations
# print('isExternalUnitTest',g.app.isExternalUnitTest)

if g.app.isExternalUnitTest:
    body = c.frame.body
else:
    import leo.core.leoCommands as leoCommands
    import leo.core.leoFrame as leoFrame
    import leo.core.leoGui as leoGui
    
    # Important: external unit tests should execute in this environment.
    nullGui   = leoGui.nullGui('null gui')
    nullFrame = leoFrame.nullFrame(title='nullFrame title',gui=nullGui)
    c2 = leoCommands.Commands(nullFrame,fileName='<empty fileName>')
    nullFrame.c = c2
    body = leoFrame.nullBody(frame=nullFrame,parentFrame=None)
    assert repr(body).startswith('<leo.core.leoFrame.nullBody')

# Now test some basic operations.
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl
w = body.bodyCtrl

w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111115155710.9835: *4* @test g.python_tokenize
# h = 'g.python_tokenize'
# p = p.firstChild()
# assert p.h == h
tokens = g.python_tokenize(p.b,line_numbers=False)

# tokens = [(kind,val) for (kind,val,line_number) in tokens]

# First, the basic check
tokens1 = [val for kind,val in tokens]
s = ''.join(tokens1)
assert p.b == s,repr(s)

if 0:
    for z in tokens:
        kind,val = z
        print('%6s %s' % (kind,repr(val)))
        
# Next, start filtering.
tokens = [(kind,g.choose(kind=='string','"S"',val)) for kind,val in tokens]

if 0: # Delete whitespace.
    tokens = [(kind,val) for (kind,val) in tokens if kind != 'ws']
    tokens = [(kind,g.choose(kind=='id',val+' ',val)) for (kind,val) in tokens]

# Last: stringize.
tokens = [val for kind,val in tokens if kind != 'comment']
# print(''.join(tokens))

if 1: # Print lines containing '='
    s = ''.join(tokens)
    for ch in '()[]{}<>.,:=+-/':
        s = s.replace(' '+ch,ch)
    aList = [z for z in g.splitLines(s)
        if z.find('=') > -1] # and not z.find('+=')>-1 and not z.find('-=')>-1]
    print(''.join(aList))
    
#@+node:ekr.20111204110514.10287: *4* @test p.moveToFirst/LastChild
def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()

child = p.firstChild()
assert child
setup(child)
p2 = child.insertAfter()
p2.h = "test"
try:
    assert c.positionExists(p2),p2
    p2.moveToFirstChildOf(child)
    assert c.positionExists(p2),p2
    p2.moveToLastChildOf(child)
    assert c.positionExists(p2),p2
finally:
    if 1:
        setup(child)
    c.redraw(p)
#@+node:ekr.20111210100047.10306: *5* child
#@+node:ekr.20111116161118.10247: *3* Old lint tests
#@+node:ekr.20111116103733.9845: *4*  Naming tests
# http://docs.python.org/reference/executionmodel.html#naming-and-binding

if 0:
    def test():
        a = b
        b = 1 # UnboundLocalError
        
print('***')
          
def test():
    global g2
    g2 = 4
    def test2():
        print(g2)
    test2()
    g2 = 3
    print(g2)
    
g2 = 'g2'
print(g2)

test()
#@+node:ekr.20111116103733.9846: *5* << define s>>
s = '''



'''

s = g.adjustTripleString(s,-4)
#@+node:ekr.20111116103733.9839: *4* @test create lots of data structures
# A simple prototype of data-centric design.
# 0.023 sec to create 100,000 dicts.
# 0.230 sec to create 1,000,000 dicts.

import time

t1 = time.clock()
n = 1000000

d = {}
for z in range(n):
    d[n] = {'n':n,}

t2 = time.clock()
print('Created %s dicts in %2.3f sec.' % (n,t2-t1))
#@+node:ekr.20111116103733.9844: *4* @test dumper (to outNodes)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outNodes.txt'

outStream = open(out,'w')
u.AstDumper().dumpFileAsNodes(fn,outStream)
#@+node:ekr.20111116103733.9840: *4* @test dumper (to outString)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outString.txt'

outStream = open(out,'w')
u.AstDumper(brief=True).dumpFileAsString(fn,outStream)
#@+node:ekr.20111116103733.9838: *4* @test speed of AstTraverser (one file)
import leo.core.leoGlobals as g
import leo.core.leoInspect as leoInspect
import ast
import time

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
    
t1 = time.clock()
s = open(fn,'r').read()
t2 = time.clock()
tree = ast.parse(s,filename=fn,mode='exec')
t3 = time.clock()
leoInspect.AstTraverser(fn).visit(tree)
t4 = time.clock()

if 1:
    print('read:     %2.3f sec.' % (t2-t1))
    print('parse:    %2.3f sec.' % (t3-t2))
    print('traverse: %2.3f sec.' % (t4-t3))
    print('total:    %2.3f sec.' % (t4-t1))
#@+node:ekr.20111128103520.10237: *3* Tests of @shadow from unitTest.leo
#@+node:ekr.20111128103520.10238: *4* @@shadow ../test/unittest/at-shadow-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10239: *5* spam
def spam():
    pass
#@+node:ekr.20111128103520.10240: *5* eggs
def eggs():
    pass
#@+node:ekr.20111128103520.10241: *4* @@shadow unittest/at-shadow-line-number-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10242: *5* child
def child():
    pass
#@+node:ekr.20111128103520.10243: *4* @test @shadow: shape of tree
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow ../test/unittest/at-shadow-test.py'
    p = g.findNodeAnywhere(c,h)
    assert p
    
    table = (
        (p.firstChild(),'spam'),
        (p.firstChild().next(),'eggs')
    )
    
    assert not p.isDirty(),p.h # Do not ignore this failure!
    
    for p2,h2 in table:
        assert len(p2.h) == len(h2)
#@+node:ekr.20111128103520.10244: *4* @test goto-global-line @shadow
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow unittest/at-shadow-line-number-test.py'
    root1 = g.findNodeAnywhere(c,h)
    assert root1
    assert root1.isAnyAtFileNode()
    
    fileName,lines,n,root2 = c.goToLineNumber(c).setup_file(n=6,p=root1)
    assert fileName == h[8:],'fileName'
    assert root2 == root1
    
    if 0:
        print('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
            root and root.h,isRaw,n,len(lines)))
#@+node:ekr.20111116103733.9818: *3* LeoInspect tests
#@+node:ekr.20111116103733.10672: *4* @test leoInspect with multiple files
import leo.core.leoInspect as inspect

import os

<< define old_s >>
<< define s >>

g.cls()

aList = (
    'leoAtFile.py',
    'leoEditCommands.py',
)
inspect.test(c,aList,print_stats=False,s=None,print_times=True)
#@+node:ekr.20111116103733.10451: *5* << define old_s >>
# import leo.core.leoGlobals
# import leo.core.leoGlobals as g
# from leo.core.leoGlobals import pr as pr2
# from leo.core.leoGlobals import trace

s_old = '''\
import sys

aGlobal = 5
# aGlobal2 is not explicitly defined.

c = [z for z in 'abc']

def myFunc():
    n1,n2,n3,junk,junk=sys.version_info
    a = self.b
    for z in a:
        print(z)
    with A() as a:
        print(a,b)
        
def test():
    a = b # UnboundLocalError.
    b = 1
    c = 2 # Any def will do at present.
    print(g)
    print(c.frame.body)
    print(c.frame.body.xxx.yyy)
    print(b.yyy) # no check will be made.
    print(xxx.yyy)
    for c in 'abc':
        print(c,b)
        print(g)


class myClass:
    
    def __init__(self,c):
        self.a = True
        self.b = None
        c.frame.xxxx
        
    def spam(self,a,b,c=5,*args,**keys):
        global aGlobal2
        aGlobal2 = 'abc'
        self.a = b
        self.a = x
        
    def no_self(a):
        pass
        
    def test_lambda(self):
        f = lambda a,b: a

    def test_comprehension(self):
        z2 = [z for z in 'abc']
        
aGlobal3 = 4 # This should be defined everywhere.

def test():
    # a = ','.join(['a','b'])
    p = 5
    # print(p.parent().h)
    # print(g.app.windowList[0])
    print(p)
    print(g)

'''

# import leo.core.leoCommands as leoCommands
#@+node:ekr.20111116103733.10452: *5* << define s >>
s = '''\

import leo.core.leoGlobals as g

def test(c):
    a = 5
    f = c.frame
    c.frame.body.bodyCtrl = w

'''

s = g.adjustTripleString(s,-4)
# print(s)
#@+node:ekr.20111116103733.10450: *5* test
def test(c,files,print_stats=True,s=None,print_times=True):
   
    t1 = time.clock()
    sd = SemanticData(controller=None)

    if s: # Use test string.
        fn = '<test file>'
        InspectTraverser(c,fn,sd,s).traverse(s)
    else:
        for fn in files:
            print(g.shortFileName(fn))
            s = LeoCoreFiles().get_source(fn)
            if s:
                InspectTraverser(c,fn,sd,s).traverse(s)
            else:
                print('file not found: %s' % (fn))
           
    sd.total_time = time.clock()-t1
    
    if print_times: sd.print_times()
    if print_stats: sd.print_stats()
#@+node:ekr.20111116103733.10449: *4* @test leoInspect.module.classes
import leo.core.leoInspect as inspect

dump_modules = False
print_modules = True
print_functions = False
print_stats = False
print_times = True

if dump_modules or print_stats:
    g.cls()

m = inspect.module(c,'leoEditCommands.py',sd=None,
    print_stats=print_stats,print_times=print_times)
    
for o in m.classes():
    if dump_modules:
        o.dump(verbose=False)
    if print_modules:
        print(o)
    if print_functions:
        for f in o.functions:
            print('  %s' % f)
#@+node:ekr.20111116161118.10212: *4* @test leoInspect.module.classes 2
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(c,'leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.classes():
    print(z)
#@+node:ekr.20111116161118.10218: *4* @test leoInspect.module.defs
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(c,'leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.defs():
    print(z)
#@+node:ekr.20111116161118.10181: *4* @test leoInspect.module.statements
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(c,'leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.statements():
    print(z)
#@+node:ekr.20111116161118.10230: *4* @test leoInspect (leoEditCommands.py)
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(fn='leoEditCommands.py')

def show(o):
    print('%-5s %s' % (o.line_number(),o.format()))

var = '.widget'
func = 'w.insert'

if 0:
    
    print('\nAssignments to %s...\n' % (var))
    for o in m.assignments_to(var):
        show(o)
        
    print('\nAssignments using %s...\n' % (var))
    for o in m.assignments_using(var):
        show(o)
        
    print('\nCalls to %s...\n' % (func))
    for o in m.calls_to(func):
        show(o)
        
    if 1:
        classes = m.classes()
        for d in classes[0].defs():
            print('')
            print(d)
            for z in d.statements():
                # print(z.tree())
                # print(z.sd.dump_ast(z.tree()))
                lines = g.splitLines(z.format())
                for line in lines:
                    print('  %s' % (line))
#@+node:ekr.20111127153202.10231: *4* @test speed of AstTraverser (all Leo core files)
import leo.core.leoGlobals as g
import leo.core.leoInspect as inspect
import ast
import time

read_time,parse_time,traverse_time = 0.0,0.0,0.0
t_start = time.clock()
count = 0
for fn in inspect.LeoCoreFiles().files:
    count += 1
    t2 = time.clock()
    s = open(fn,'r').read()
    t3 = time.clock()
    tree = ast.parse(s,filename=fn,mode='exec')
    t4 = time.clock()
    inspect.AstTraverser(fn).visit(tree)
    t5 = time.clock()
    read_time += t3-t2
    parse_time += t4-t3
    traverse_time += t5-t4
t_end = time.clock()
total_time = t_end-t_start
if 1:
    print('files:    %s' % (count))
    print('read:     %2.3f sec.' % (read_time))
    print('parse:    %2.3f sec.' % (parse_time))
    print('traverse: %2.3f sec.' % (traverse_time))
    print('total:    %2.3f sec.' % (total_time))
#@+node:ekr.20111127090852.10227: *4* @test leoInspect (all core files)
import leo.core.leoInspect as inspect
import time

sd = inspect.SemanticData()
start_time = time.clock()

count = 0
for fn in inspect.LeoCoreFiles().files:
    # print(fn)
    m = inspect.module(fn,sd=sd)
    count += 1

end_time = time.clock()
total_time = end_time-start_time

if 1:
    print('files: %s' % (count))
    print('total: %2.3f sec.' % (total_time))
if 1:
    sd.print_stats()
#@+node:ekr.20111117031039.10762: *4* @test leoInspect.module (s)
import leo.core.leoInspect as inspect

g.cls()

def show(o,indent):
    # print('\n%s\n' % o.sd.dump_ast(o.tree()))
    print('%s%s' % (' '*4*indent,o.format()))

<< define s >>
print('Input...\n%s\n' % (s.rstrip()))

m = inspect.module(s=s)

if 1:
    print(show(m,0))

print('\nAssignments to a...\n')
for o in m.assignments_to('a'):
    print(o.format())
    
print('\nAssignments using d...\n')
for o in m.assignments_using('d'):
    print(o.format())
    
print('\nCalls to f...\n')
for o in m.calls_to('f'):
    print(o.format())

if 1:
    for s in m.statements():
        show(s,0)
    
    for f in m.functions():
        show(f,0)
        for z in f.statements():
            show(z,1)
    
    for cls in m.classes():
        show(cls,0)
        for d in cls.defs():
            show(d,1)
            for z in d.statements():
                show(z,1)
#@+node:ekr.20111117031039.10763: *5* << define s >>
s = '''
x.y = b(arg1,arg2=5,*args,**args).c[1:2:3].d
a=b+c
f(a=1,b=2,*args,**keys)
'''


# def outer_function(a,b=99,c=88,*args,**keys):
    # print('hello')
    
# class myClass:
    # def method():
        # pass
    
#@+node:ekr.20111116103733.9838: *4* @test speed of AstTraverser (one file)
import leo.core.leoGlobals as g
import leo.core.leoInspect as leoInspect
import ast
import time

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
    
t1 = time.clock()
s = open(fn,'r').read()
t2 = time.clock()
tree = ast.parse(s,filename=fn,mode='exec')
t3 = time.clock()
leoInspect.AstTraverser(fn).visit(tree)
t4 = time.clock()

if 1:
    print('read:     %2.3f sec.' % (t2-t1))
    print('parse:    %2.3f sec.' % (t3-t2))
    print('traverse: %2.3f sec.' % (t4-t3))
    print('total:    %2.3f sec.' % (t4-t1))
#@+node:ekr.20120116073928.10114: *3* Unit tests for settings
#@+node:ekr.20120126050844.10386: *4* @ignore print dicts unit tests
#@+node:ekr.20120117095916.10124: *5* @test printMenusList
def printMenusList(aList,level=0):
    
    for z in aList:
        a,b,c = z
        print('*** kind',a)
        if type(b) in (type(()),type([])):
            for z2 in b:
                a1,b1,c1 = z2
                if a1.startswith('@menu') and type(b1) in (type(()),type([])):
                    print()
                    print('*** inner menu: %s' % (level+1))
                    print(a1)
                    for z3 in b1:
                        print(z3)
                    if c1: print(c1)
                else:
                    print(z2)
            if c: print(c)
        else:
            print(b)
        print()
        break #
        
printMenusList(c.config.getMenusList())
       
#@+node:ekr.20120117095916.10140: *5* @test printInverseBindingDict
print('\ninverseBindingDict...\n')

d = c.k.computeInverseBindingDict()

for key in sorted(list(d.keys())):

    if 1 == len(d.get(key)):
        print(key,d.get(key))
    else:
        print()
        print(key)
        print(d.get(key))
        print()
#@+node:ekr.20120123113111.10925: *5* @test printBindingsDict
import leo.core.leoConfig as leoConfig # for ShortcutInfo
    
partial = True

d = c.k.bindingsDict
    # Keys are shortcuts; values are *lists* leoConfig.ShortcutInfo objects.
    
print('\nk.bindingsDict%s...\n' % ' (partial)' if partial else '')
    
for key in list(sorted(d.keys())):
    aList = d.get(key,[])
    for b in aList:
        assert isinstance(b,leoConfig.ShortcutInfo)
        if not partial or b.kind != 'leosettings.leo':
            print(b)
#@+node:ekr.20120117095916.10141: *5* @test printMasterBindingsDict
partial = True

panes = ('all','body','button','log','tree','text',
    'command','insert','overwrite',)

d = c.k.masterBindingsDict
    # Keys are scope names (in panes) or mode names.
    # Values are dicts:
        # keys are strokes; values are leoConfig.ShortcutInfo objects.
        
print('\nk.masterBindingsDict%s...\n' % ' (partial)' if partial else '')

for pane in sorted(list(d.keys())):
    kind = 'pane' if pane in panes else 'mode'
    print('%s: %s...' % (kind,pane))
    d2 = d.get(pane)
    for stroke in sorted(list(d2.keys())):
        b = d2.get(stroke)
        if not partial or b.kind != 'leosettings.leo':
            print('%6s %25s %17s %s' % (b.pane,stroke,b.kind,b.commandName))
            assert b.pane == pane
            assert b.stroke == stroke
    print()
#@+node:ekr.20120126080450.10187: *4* @ignore passed
#@+node:ekr.20120126080450.10189: *5* @test mode-related info
@

g.app.config.modeCommandsDict
    Keys are command names: enter-x-mode.
    Values are inner dictionaries:
        Keys are command names, values are lists of ShortcutInfo nodes.
@c

d = g.app.config.modeCommandsDict
    
for key in sorted(d.keys()):
    print('*** mode ***',key)
    d2 = d.get(key)
    for key2 in sorted(d2.keys()):
        aList = d2.get(key2)
        print(key2)
        for si in aList:
            print('   ',si)
#@+node:ekr.20120120095156.10262: *5* @test types of contents of settings dicts
@
ivar                    Keys                Values
----                    ----                ------
c.commandsDict          command names (1)   functions
k.inverseCommandsDict   func.__name__       command names
k.bindingsDict          shortcuts           list of ShortcutInfo objects
k.masterBindingsDict    scope names (2)     inner masterBindingDicts (3)
k.masterGuiBindingsDict strokes             list of widgets in which stoke is bound
k.settingsNameDict (4)  settings.lower()    "Real" Tk specifiers
inverseBindingDict (5)  command names       lists of tuples (pane,key)
modeCommandsDict (6)    command name (7)    inner modeCommandsDicts (8)

Notes:
(1) Command names are minibuffer names (strings)
(2) Scope names are 'all','text',etc.
(3) inner masterBindingDicts: Keys are strokes; values are ShortcutInfo objects.
(4) k.settingsNameDict has no inverse.
(5) inverseBindingDict is **not** an ivar: it is computed by k.computeInverseBindingDict.
(6) A global dict: g.app.gui.modeCommandsDict
(7) enter-x-command
(8) Keys are command names, values are lists of ShortcutInfo objects.
@c

si_type = c.k.ShortcutInfo
disabled_func_type = None # Should be any bound method.
k = c.k

@others

test_dict_of_objects(c.commandsDict,type('s'),disabled_func_type,'commandsDict')
test_dict_of_objects(k.inverseCommandsDict,type('s'),type('s'),'inverseCommandsDict')
test_dict_of_lists(k.bindingsDict,si_type,'bindingsDict')
test_dict_of_dicts(k.masterBindingsDict,si_type,'masterBindingsDict')
test_dict_of_lists(k.masterGuiBindingsDict,None,'masterGuiBindingsDict')
test_dict_of_objects(k.settingsNameDict,type('s'),type('s'),'settingsNameDict')
test_dict_of_lists(k.computeInverseBindingDict(),type(tuple()),'inverseBindingDict')

# Test individual dicts separately.
d = g.app.config.modeCommandsDict
test_dict_of_dicts(d,None,'modeCommandsDict')
for key in sorted(d.keys()):
    d2 = d.get(key)
    test_dict_of_lists(d2,si_type,'inner modeCommandsDict')
        # This requires a hack to special-case the
        # '*entry-commands*' and '*command-prompt*' keys.
#@+node:ekr.20120126080450.10193: *6* test_dict_of_dicts
def test_dict_of_dicts(d,theType,tag):

    assert d,tag

    for key in d.keys():
        d2 = d.get(key)
        assert type(d2) == type({})
        for key in d2.keys():
            obj = d2.get(key)
            if theType:
                assert type(obj) == theType,repr(obj)
#@+node:ekr.20120126080450.10191: *6* test_dict_of_lists
def test_dict_of_lists(d,theType,tag):

    assert d,tag

    for key in d.keys():
        obj = d.get(key)
        if key in ('*entry-commands*','*command-prompt*'):
            # Special case for g.app.config.modeCommandsDict
            assert type(obj)==type([]),repr(obj)
        else:
            assert type(obj) == type([])
            # Don't check types of list elements if theType is None.
            if theType:
                for z in obj:
                    assert type(z)==theType,'key: %s obj: %s' % (key,repr(obj))
#@+node:ekr.20120126080450.10195: *6* test_dict_of_objects
def test_dict_of_objects(d,keyType,valueType,tag):

    assert d,tag

    for key in d.keys():
        assert type(key) == keyType,repr(key)
        obj = d.get(key)
        # Don't check type of obj if valueType is None.
        if valueType:
            assert type(obj) == valueType,'\nobj: %s\nvalueType: %s' % (repr(obj),valueType)
#@+node:ekr.20120126080450.10194: *6* Unused
# import types
# types.ListType does not exist in Python 3.x.
# assert isinstance(aList,list().__class__)
#@+node:ekr.20120127084215.10238: *5* @test merge_settings_dicts
@others

# import os ; os.system('cls')
    
d1 = g.app.config.immutable_leo_settings_shortcuts_dict
d2 = g.app.config.immutable_my_leo_settings_shortcuts_dict
d3 = g.app.config.merge_settings_dicts(d1,d2)

if False:
    patterns = (
        'backward-find-character-extend-selection',
    )
    for pattern in patterns:
        print(dump_dict(d1,pattern,tag='d1'))
        print(dump_dict(d2,pattern,tag='d2'))
        print(dump_dict(d3,pattern,tag='d3'))

test(d1,d2,d3)
#@+node:ekr.20120127145909.10227: *6* dump & dump_dict (@test merge_settings_dicts)
def dump(aList,pattern=None,tag=None):
    
    return '\n'.join([repr(z) for z in aList])
    

def dump_dict(d,pattern=None,tag=None):
    
    result = [] # '\ndump of %s...' % (tag)
    
    for key in d.keys():
        if pattern in (key,None):
            result.append(key)
            aList = d.get(key)
            for z in aList:
                result.append('    %s' % (z))
                
    return '\n'.join(result)
#@+node:ekr.20120127084215.10239: *6* test (@test merge_settings_dicts)
def test(old_d,new_d,result_d):
    
    '''Test that result_d is the result of upating old_d with new_d.
    
    This test is tricky: only inverted dicts have ShortcutInfo nodes as keys.'''
    
    invert,uninvert = g.app.config.invert,g.app.config.uninvert

    # Compute the inversions of all the dicts.
    inv_old,inv_new,inv_res = invert(old_d),invert(new_d),invert(result_d)
    
    # Part 1: Ensure we test all keys.
    keys = list(inv_old.keys())
    keys.extend(list(inv_new.keys()))
    keys.extend(list(inv_res.keys()))
    keys = sorted(list(set(keys)))
    assert None not in keys
    for key in inv_old.keys(): assert key in keys,key
    for key in inv_new.keys(): assert key in keys,key
    for key in inv_res.keys(): assert key in keys,key
    
    # Part 2: Carefully test the inverted result.
    def si_name_key(si): return si.commandName or ''

    for key in keys:
        # Compute the *sorted* list of 
        res_list = sorted(inv_res.get(key,[]),key=si_name_key)
        old_list = sorted(inv_old.get(key,[]),key=si_name_key)
        new_list = sorted(inv_new.get(key,[]),key=si_name_key)
        assert res_list,'no res_list.get(%s)' % (key)
        # if new_list: print(key,dump(new_list))
        if new_list:
            assert new_list == res_list,'key %s\nnew:\n%s\nres:\n%s' % (
                key,dump(new_list),dump(res_list))
        else:
            assert old_list == res_list,'key %s\nold:\n%s\nres:\n%s' % (
                key,dump(old_list),dump(res_list))
    
    # Part 3: Test that result_d == uninvert(invert(result_d)).
    # A.  They must have the same keys.
    unv_res = uninvert(inv_res)
    assert sorted(list(result_d.keys())) == sorted(list(unv_res.keys()))

    # B. The values of for each key must match after being sorted.
    def si_stroke_key(si): return si.stroke or ''
        
    for key in sorted(result_d.keys()):
        res_list = sorted(result_d.get(key,[]),key=si_stroke_key)
        unv_list = sorted( unv_res.get(key,[]),key=si_stroke_key)
        assert res_list == unv_list,'key %s\nres:\n%s\nunv:\n%s' % (
            key,dump(res_list),dump(unv_list))
   
#@+node:ekr.20120203153754.10032: *5* @test KeyStroke
ks = c.k.KeyStroke

@others

a1 = ks('a')
a2 = ks('a')
b1 = ks('b')
assert a1 == a2
d = {}
d[a1] = a1.s
d[a2] = a2.s
d[b1] = b1.s

for key in sorted(d):
    print(key,d.get(key))
#@+node:ekr.20120205022040.17748: *5* @test g.TypedDict
d = g.TypedDictOfLists('ks',type('s'),type(9))
d.add('a',1)
d.add('a',2)
d.add('b',3)

print(d)
for s in sorted(d.keys()):
    print(s,d.get(s,[]))

print('after replace...')
d.replace('a',[8,9,10])

for s in sorted(d.keys()):
    print(s,d.get(s,[]))
#@+node:ekr.20120215062153.14233: *3* @mark-for-unit-tests
#@+node:ekr.20080412053100.5: *4* @settings
#@+node:ekr.20080412053100.4: *5* @bool fixedWindow = False
#@+node:ekr.20100902154544.5872: *5* @bool enable-abbreviations = True
#@+node:ekr.20111123042248.12701: *5* @enabled-plugins
# Leo loads plugins in the order they appear here.

# Highly-recommended plugins:

plugins_menu.py
free_layout.py # needs to be early
viewrendered.py
mod_scripting.py
#@+node:ekr.20111031081007.9985: *5* @shortcuts
run-selected-unit-tests-externally = Alt-4 # Standard binding, unchanged.
run-marked-unit-tests-externally = Alt-5
run-marked-unit-tests-locally = Alt-6
#@+node:ekr.20110621074459.14908: ** 4.10
#@+node:ekr.20120304065838.15590: *3* Features
#@+node:ekr.20120301053039.15579: *4* Instant abbreviations (~a)
@nocolor-node

Rev 5051 contains a *major* improvement in Leo's abbreviation code.
It is simpler, and more general than before.

The downside is that you will likely have to revise your
abbreviations.  I believe the extra work will be well worthwhile.

Here are the changes:

1. Abbreviations may consist of *any* sequence of characters,
including whitespace or "special" characters. You may include
whitespace characters in definitions using the '\t' and '\n' escapes.
However, whitespace may only appear at the *end* of definitions.

2. You must take care to disambiguate abbreviations if one is a prefix
of another.

Here is an example of both points.  As always, you define
abbreviations in the body of an @global-abbreviation node or
@abbreviation node::

    nc =@nocolor\n
    nc\n=@nocolor\n
    nc\t=@nocolor\n

    ncn=@nocolor-node\n

As you can see, the definitions uses whitespace at the end
of the definition of "nc" to prevent it from being expanded
when typing "ncn".

3. The reason I call these abbreviations "instant" is that they can be
triggered on *any* keystroke, not just the end of a "word".  This
allows you to define::

    teh=the

Hurray!

4. Two rules limit scans.  They are useful and shouldn't cause
hardships.

A.  The backspace and delete characters *never* trigger substitutions.

B. The scan for definitions ends at the first newline
character. Therefore, whitespace will have effect only at
the *end* of a definition.

**Important**: these rules can cause problems when *defining*
abbreviations:  it's easy to trigger an unwanted definition.  The
solution is to use rule 4B:

I want to type::

    ncn=@nocolor-node\n

But I **cant** type this directly if nc is already defined!  The trick
is to type::

   nxcn=@nocolor-node\n

and then delete the leading x with a backspace character.

Of course, you could also turn abbrevions off while defining abbreviations...

Instant abbreviations solve the problems with Brazilian
keyboards. Just define::

    ~a=ã
    ~A=Ã
    etc.

This works regardless of keyboard, regardless of OS, etc.
You might want to define::

    ~\a=~a
    ~\A=~A

in the somewhat unlikely event that you want to type ~a rather than,
say, ~+a.  Of course, you don't need these, provided you remember to
type ~xa <Right><Delete> :-)
#@+node:ekr.20050920084036.27: *5* expandAbbrev
def expandAbbrev (self,event,stroke):

    '''Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.

    Words start with '@'.
    '''

    trace = False and not g.unitTesting
    k = self.k ; c = self.c
    ch = event and event.char or ''
    w = self.editWidget(event,forceFocus=False)
    if not w: return False
    if w.hasSelection(): return False
    
    assert g.isStrokeOrNone(stroke)

    if stroke in ('BackSpace','Delete'):
        if trace: g.trace(stroke)
        return False

    d = {'Return':'\n','Tab':'\t','space':' ','underscore':'_'}
    if stroke:
        ch = d.get(stroke.s,stroke.s)
        if len(ch) > 1:
            if (stroke.find('Ctrl+') > -1 or
                stroke.find('Alt+') > -1 or
                stroke.find('Meta+') > -1
            ):
                ch = ''
            else:
                ch = event and event.char or ''
    else:
        ch = event.char
        
    if trace: g.trace('ch',repr(ch),'stroke',repr(stroke))
    
    # New code allows *any* sequence longer than 1 to be an abbreviation.
    # Any whitespace stops the search.
    s = w.getAllText()
    j = w.getInsertPoint()
    i = j-1
    while len(s) > i >= 0 and s[i] not in ' \t\n':
        prefix = s[i:j]
        word = prefix+ch
        val,tag = self.abbrevs.get(word,(None,None))
        if trace: g.trace(repr(word),val,tag)
        if val:
            # Require a word match if the abbreviation is itself a word.
            if ch in ' \t\n': word = word.rstrip()
            if word.isalnum() and word[0].isalpha():
                if i == 0 or s[i-1] in ' \t\n':
                    break
                else:
                    i -= 1
            else:
                break
        else: i -= 1
    else:
        return False

    if trace: g.trace('**inserting',repr(val))
    oldSel = j,j
    c.frame.body.onBodyChanged(undoType='Typing',oldSel=oldSel)
    if i != j: w.delete(i,j)
    w.insert(i,val)
    c.frame.body.forceFullRecolor() # 2011/10/21
    c.frame.body.onBodyChanged(undoType='Abbreviation',oldSel=oldSel)

    return True
#@+node:ekr.20100901080826.6001: *5* addAbbrevHelper
def addAbbrevHelper (self,s,tag=''):
    
    '''Enter the abbreviation 's' into the self.abbrevs dict.'''

    if not s.strip(): return

    try:
        d = self.abbrevs
        data = s.split('=')
        # name = data[0].strip()
        # 2012/02/29: Do *not* strip ws, and allow the user to specify ws.
        name = data[0].replace('\\t','\t').replace('\\n','\n')
        val = '='.join(data[1:])
        if val.endswith('\n'): val = val[:-1]
        val = val.replace('\\n','\n')
        old,tag = d.get(name,(None,None),)
        if old and old != val and not g.unitTesting:
            g.es_print('redefining abbreviation',name,
                '\nfrom',repr(old),'to',repr(val))
        d [name] = val,tag
    except ValueError:
        g.es_print('bad abbreviation: %s' % s)
#@+node:ekr.20120307052613.11954: *4* Reinstated warnings for conflicting definitions
@nocolor-node

k.remove_conflicting_definitions always gives the warning, not just when tracing.

The warning isn't the best, and it is usually duplicated, but it is much better than nothing.
#@+node:ekr.20120304065838.15591: *3* Bugs
#@+node:ekr.20120229094652.15179: *4* Made sure global @command & @button nodes work
#@+node:ekr.20070925144337: *5* doButtons
def doButtons (self,p,kind,name,val):

    '''Handle an @buttons tree.'''

    trace = False and not g.unitTesting
    aList = [] ; c = self.c ; tag = '@button'
    seen = []
    after = p.nodeAfterTree()
    while p and p != after:
        if p.v in seen:
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            seen.append(p.v)
            p.moveToNodeAfterTree()
        else:
            seen.append(p.v)
            if g.match_word(p.h,0,tag):
                # We can not assume that p will be valid when it is used.
                script = g.getScript(c,p,
                    useSelectedText=False,
                    forcePythonSentinels=True,
                    useSentinels=True)
                aList.append((p.h,script),)
            p.moveToThreadNext()

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    if aList:
        g.app.config.atCommonButtonsList.extend(aList)
            # Bug fix: 2011/11/24: Extend the list, don't replace it.
        g.app.config.buttonsFileName = c and c.shortFileName() or '<no settings file>'

    if trace: g.trace(len(aList),c.shortFileName())

    d,key = g.app.config.unitTestDict,'config.doButtons-file-names'
    aList = d.get(key,[])
    aList.append(c.shortFileName())
    d[key] = aList
#@+node:ekr.20080312071248.6: *5* doCommands
def doCommands (self,p,kind,name,val):

    '''Handle an @commands tree.'''

    trace = False and not g.unitTesting
    aList = [] ; c = self.c ; tag = '@command'
    seen = []
    after = p.nodeAfterTree()
    while p and p != after:
        if p.v in seen:
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            seen.append(p.v)
            p.moveToNodeAfterTree()
        else:
            seen.append(p.v)
            if g.match_word(p.h,0,tag):
                # We can not assume that p will be valid when it is used.
                script = g.getScript(c,p,
                    useSelectedText=False,
                    forcePythonSentinels=True,
                    useSentinels=True)
                aList.append((p.h,script),)
            p.moveToThreadNext()

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    if aList:
        g.app.config.atCommonCommandsList.extend(aList)
            # Bug fix: 2011/11/24: Extend the list, don't replace it.
    if trace: g.trace(len(aList),c.shortFileName())
    
    d,key = g.app.config.unitTestDict,'config.doCommands-file-names'
    aList = d.get(key,[])
    aList.append(c.shortFileName())
    d[key] = aList
#@+node:ekr.20120229094652.19497: *4* Fixed Bug 930726:expandNodeAndGoToFirstChild only expands or only goes to first child
https://bugs.launchpad.net/leo-editor/+bug/930726

Bug: If the node is not expanded already, then the position
is left on the parent, not the first child.

Function expandNodeAndGoToFirstChild() is referenced only
once in LeoPyRef.leo. This reference is in table of public
Leo commands.

The node in which expandNodeAndGoToFirstChild() is defined
also contains the definition of function
expandNodeOrGoToFirstChild(). At present these two functions
are equivalent. The comments including the header for the
node imply that they should not be equivalent and that
expandNodeAndGoToFirstChild() is not correctly implemented.
#@+node:ekr.20040930064232.1: *5* expandNodeAnd/OrGoToFirstChild
def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.p

    if p.hasChildren():
        if p.isExpanded():
            c.selectPosition(p.firstChild())
        else:
            c.expandNode()
            # Fix bug 930726
            # expandNodeAndGoToFirstChild only expands or only goes to first child .
            c.selectPosition(p.firstChild())

    c.treeFocusHelper()

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.p
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode() # Calls redraw_after_expand.
        else:
            c.redraw_after_expand(p.firstChild(),setFocus=True)
#@+node:ekr.20111026091322.16494: *4* Fixed Bug 869429 (undo & redo when deleting nodes from contextmenu)
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/869429
Undo and Redo delete from context menu does not redo properly

The fix was to deletenodes_rclick in contextmenu.py.
The fallback position should be c.rootPosition()

===== Original report.

Delete (node) in context_menu (right click on headline) has unexpected undo /
redo effects.

Redo after Undo often fails, but you can Undo again, without the
ReDo taking effect, which mans an extra node is created.

In essence: -1 delete,
+1 Undo (restore node),
0 ReDo (should redelete but does nothing),
+1 Undo

(again) = 1 Should = 0 (delete, undelete, redelete, undo redelete) Deleting a
node through Outline menu works differently and properly. The undo code in the
two delete methods must be different

===== Terry

The undo code in the two delete methods must be different

It's different because the context menu delete can delete multiple
nodes at once.

I wrote the context menu delete, but I don't understand the undo system
that well - it's possible it just doesn't support a redo of something
like this.
#@+node:ekr.20031218072017.1193: *5* c.deleteOutline
def deleteOutline (self,event=None,op_name="Delete Node"):

    """Deletes the selected outline."""

    c = self ; cc = c.chapterController ; u = c.undoer
    p = c.p
    if not p: return

    c.endEditing() # Make sure we capture the headline for Undo.

    if p.hasVisBack(c): newNode = p.visBack(c)
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    if cc: # Special cases for @chapter and @chapters nodes.
        chapter = '@chapter ' ; chapters = '@chapters ' 
        h = p.h
        if h.startswith(chapters):
            if p.hasChildren():
                return cc.note('Can not delete @chapters node with children.')
        elif h.startswith(chapter):
            name = h[len(chapter):].strip()
            if name:
                # Bug fix: 2009/3/23: Make sure the chapter exists!
                # This might be an @chapter node outside of @chapters tree.
                theChapter = cc.chaptersDict.get(name)
                if theChapter:
                    return cc.removeChapterByName(name)

    undoData = u.beforeDeleteNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.doDelete(newNode)
    c.setChanged(True)
    u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    c.redraw(newNode)

    c.validateOutline()
#@+node:ekr.20031218072017.3069: *5* changeAll (leoFind)
def changeAll(self):

    # g.trace('leoFind',g.callers())

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.p
    w = self.s_ctrl
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    u.beforeChangeGroup(current,undoType)
    while 1:
        pos1, pos2 = self.findNextMatch()
        if pos1 is None: break
        count += 1
        self.batchChange(pos1,pos2)
        s = w.getAllText()
        i,j = g.getLine(s,pos1)
        line = s[i:j]
        # self.printLine(line,allFlag=True)
    p = c.p
    u.afterChangeGroup(p,undoType,reportFlag=True)
    g.es("changed:",count,"instances")
    c.redraw(p)
    self.restore(saveData)
#@+node:ekr.20050318085432.6: *5* redoGroup
def redoGroup (self):

    '''Process beads until the matching 'afterGroup' bead is seen.'''

    trace = False and not g.unitTesting
    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
        g.trace(bunch)
    else:
        for z in bunch.items:
            self.setIvarsFromBunch(z)
            if z.redoHelper:
                if trace: g.trace(z.redoHelper.__name__,p.h)
                z.redoHelper() ; count += 1
            else:
                g.trace('oops: no redo helper for %s %s' % (u.undoType,p.h))

    u.groupCount -= 1

    u.updateMarks('new') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty()

    if not g.unitTesting:
        g.es("redo",count,"instances")

    c.selectPosition(p)
    if newSel:
        i,j = newSel
        c.frame.body.setSelectionRange(i,j)
#@+node:ekr.20050318085713: *5* undoGroup
def undoGroup (self):

    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    trace = False and not g.unitTesting
    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0

    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
        g.trace(bunch)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        for z in reversedItems:
            self.setIvarsFromBunch(z)
            if z.undoHelper:
                if trace: g.trace(z.undoHelper.__name__,p.h)
                z.undoHelper() ; count += 1
            else:
                g.trace('oops: no undo helper for %s %s' % (u.undoType,p.h))

    u.groupCount -= 1

    u.updateMarks('old') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.

    if not g.unitTesting:
        g.es("undo",count,"instances")

    c.selectPosition(p)
    if oldSel:
        i,j = oldSel
        c.frame.body.setSelectionRange(i,j)
#@+node:ekr.20120303051059.9928: *4* vim and xemacs plugins now work smoothly with contextmenu plugin.
@language rest

- Open contextmenu plugin at first use (not at startup).

- Disable contextmenu dialog for temp files.

Here is the checkin log for rev 5066:

Several changes so that the vim and xemacs plugins work well with contextmenu plugin.

- vim.py and xemacs.py load contextmenu.py if necessary the first time they open a temp file.

- contextmenu.py (edit_node_on_idle) suppresses the "conflicts dialog" if the file's path is in
  [z.get('path') for z in g.app.openWithFiles]

All expected unit tests pass, as do hand tests of the vim and xemacs plugins.

#@+node:ekr.20120304065838.14231: *4* Investigated bug 805288:ctr - tab locks up in log pane
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/805288

If the log tab is active in the log pane ctrl-tab will
toggle through the body, tree and log panes. If any other
tab is active the key combination will freeze in the log
pane.

Note: ctrl-tab could be bound to several things:
    
1. tab-cycle-focus cycles between the tabs representing .leo files.
   It (correctly) always puts focus in the body pane:
       
2. Presumably, this bug refers to either cycle-focus or cycle-all-focus.
   Both work at present.
#@+node:ekr.20120304065838.15587: *4* Fixed bug 823267:when a tab is closed focus may go to a tab other than the visible one
@language rest

https://bugs.launchpad.net/leo-editor/+bug/823267

When tabs are closed with the close tab 'X' on the tab, focus
should go to whichever tab becomes visible, but it doesn't,
it goes to an arbitrary tab which may not be visible. If you
then hit Alt-X expecting to cut the highlighted node in the
visible tab, you cut a node you can't see in a different
commander.

What I did:
    
- Refactored part of g.app.closeLeoWindow into g.app.selectLeoWindow.
- Added the new_c argument to g.app.closeLeoWindow and c.close.
- Changed several event handlers in TabbedFrameFactor so that they
  call g.app.selectLeoWindow as appropriate.

@language python
#@+node:ekr.20031218072017.2833: *5* c.close
def close (self,event=None,new_c=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame,new_c=new_c)
#@+node:ekr.20031218072017.2609: *5* app.closeLeoWindow
def closeLeoWindow (self,frame,new_c=None):

    """Attempt to close a Leo window.

    Return False if the user veto's the close."""

    trace = False and not g.unitTesting
    c = frame.c

    if trace: g.trace(frame.c,g.callers(4))

    c.endEditing() # Commit any open edits.

    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    g.app.recentFilesManager.writeRecentFilesFile(c)
        # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.

    g.doHook("close-frame",c=c)
        # This may remove frame from the window list.

    if frame in g.app.windowList:
        g.app.destroyWindow(frame)

    if g.app.windowList:
        c2 = new_c or g.app.windowList[0].c
        g.app.selectLeoWindow(c2)
       
    elif not g.app.unitTesting:
        g.app.finishQuit()

    return True # The window has been closed.
#@+node:ekr.20120304065838.15588: *5* app.selectLeoWindow
def selectLeoWindow (self,c):
    
    trace = False and not g.unitTesting
    assert c
    if trace: g.trace(c.frame.title)
    
    frame = c.frame
    frame.deiconify()
    frame.lift()
    c.setLog()
    
    master = hasattr(frame.top,'leo_master') and frame.top.leo_master

    if master: # 2011/11/21: selecting the new tab ensures focus is set.
        # frame.top.leo_master is a TabbedTopLevel.
        master.select(c)

    c.bodyWantsFocus()
    c.outerUpdate()
#@+node:ekr.20110605121601.18467: *5* deleteFrame (TabbedFrameFactory)
def deleteFrame(self, wdg):
    
    trace = False and not g.unitTesting
    if not wdg: return

    if wdg not in self.leoFrames:
        # probably detached tab
        self.masterFrame.delete(wdg)
        return
        
    if trace: g.trace('old',wdg.leo_c.frame.title)
        # wdg is a DynamicWindow.
    
    tabw = self.masterFrame
    idx = tabw.indexOf(wdg)
    tabw.removeTab(idx)
    del self.leoFrames[wdg]

    wdg2 = tabw.currentWidget()
    if wdg2:
        if trace: g.trace('new',wdg2 and wdg2.leo_c.frame.title)
        g.app.selectLeoWindow(wdg2.leo_c)
    
    tabw.tabBar().setVisible(
        self.alwaysShowTabs or tabw.count() > 1)
#@+node:ekr.20110605121601.18470: *5* signal handlers (TabbedFrameFactory)
def slotCloseRequest(self,idx):
    
    trace = False and not g.unitTesting
    tabw = self.masterFrame
    w = tabw.widget(idx)
    f = self.leoFrames[w]
    c = f.c
    if trace: g.trace(f.title)
    c.close(new_c=None)
        # 2012/03/04: Don't set the frame here.
        # Wait until the next slotCurrentChanged event.
        # This keeps the log and the QTabbedWidget in sync.

def slotCurrentChanged(self, idx):

    # Two events are generated, one for the tab losing focus,
    # and another event for the tab gaining focus.
    trace = False and not g.unitTesting
    tabw = self.masterFrame
    w = tabw.widget(idx)
    f = self.leoFrames.get(w)
    if f:
        if trace: g.trace(f.title)
        tabw.setWindowTitle(f.title)
        g.app.selectLeoWindow(f.c)
            # 2012/03/04: Set the frame now.
#@+node:ekr.20120304214900.9938: *4* Fixed bug 917814: Switching Log Pane tabs is done incompletely
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/917814

Switching Log Pane tabs is not done cleanly and completely. To see this do the following:

1) Start Leo-Editor
2) Shift-Ctrl-F. This brings the Nav tab to the foreground and
   leaves the focus in the search string field of the Nav pane.
3) Click on the Log tab of the Log pane.
4) Ctrl-A. This causes the following messags to be displayed in the Log tab of the Log pane:

exception executing command
Traceback (most recent call last):
  File "/home/bob/bzrWork/trunk/leo/core/leoCommands.py", line 419, in doCommand
    val = command(event)
  File "/home/bob/bzrWork/trunk/leo/core/leoEditCommands.py", line 5755, in selectAllText
    return w.selectAllText()
  File "/home/bob/bzrWork/trunk/leo/core/leoFrame.py", line 168, in selectAllText
    def selectAllText (self,insert=None): self.widget and self.widget.selectAllText(insert)
AttributeError: 'LeoQuickSearchWidget' object has no attribute 'selectAllText'


That is, it appears that the focus is on the Log tab and the
intention is to select-all in the log tab, but Leo-Editor
tries to select-all in the Nav pane.

Strangely, doing a Ctrl-A in the Nav tab of the Log pane
seems to do nothing---no errors, no select.

-------
Ubuntu 11.10 with Fluxbox window manager
Leo Log Window
Leo 4.9.1 devel, build 4928, 2012-01-14 11:27:18
Python 2.7.2, qt version 4.7.3
linux2
setting leoID from os.getenv('USER'): 'bob'
load dir: /home/bob/bzrWork/trunk/leo/core
global config dir: /home/bob/bzrWork/trunk/leo/config
home dir: /home/bob
reading settings in /home/bob/bzrWork/trunk/leo/config/leoSettings.leo
reading settings in /home/bob/.leo/myLeoSettings.leo
reading settings in /home/bob/.leo/workbook.leo
reading: /home/bob/.leo/workbook.leo
#@+node:ekr.20110605121601.18331: *5* selectTab & helper (leoQtLog)
def selectTab (self,tabName,createText=True,widget=None,wrap='none'):
    # createText is used by leoLog.selectTab.

    '''Create the tab if necessary and make it active.'''

    trace = False and not g.unitTesting
    c = self.c ; w = self.tabWidget
    
    if trace: g.trace(tabName,g.callers())

    # Step 1: See if the tab exits.
    ok = self.selectHelper(tabName)
    if ok: return

    # Step 2: create tab if necessary.
    self.createTab(tabName,widget=widget,wrap=wrap)
    self.selectHelper(tabName)
#@+node:ekr.20110605121601.18332: *6* selectHelper (leoQtLog)
def selectHelper (self,tabName):

    trace = False and not g.unitTesting
    c,w = self.c,self.tabWidget

    for i in range(w.count()):
        if tabName == w.tabText(i):
            w.setCurrentIndex(i)
            
            widget = w.widget(i)
            
            # 2011/11/21: Set the .widget ivar only if there is a wrapper.
            wrapper = hasattr(widget,'leo_log_wrapper') and widget.leo_log_wrapper
            if wrapper:
                self.widget = wrapper
            if trace: g.trace(tabName,'widget',widget,'wrapper',wrapper)
            
            # Do *not* set focus here!
                # c.widgetWantsFocus(tab_widget)

            if tabName == 'Spell':
                # the base class uses this as a flag to see if
                # the spell system needs initing
                self.frameDict['Spell'] = widget
                
            self.tabName = tabName # 2011/11/20
            return True
    else:
        self.tabName = None # 2011/11/20
        if trace: g.trace('** not found',tabName)
        return False
#@+node:ekr.20120304214900.9940: *5* Event handler (leoQtLog)
def onCurrentChanged(self,idx):
    
    trace = False and not g.unitTesting

    tabw = self.tabWidget
    w = tabw.widget(idx)
    
    # Fixes bug 917814: Switching Log Pane tabs is done incompletely
    wrapper = hasattr(w,'leo_log_wrapper') and w.leo_log_wrapper
    if wrapper:
        self.widget = wrapper

    if trace: g.trace(idx,tabw.tabText(idx),self.c.frame.title) # wrapper and wrapper.widget)
#@+node:ekr.20110605121601.18312: *5* class leoQtLog (leoLog)
class leoQtLog (leoFrame.leoLog):

    """A class that represents the log pane of a Qt window."""

    @others
#@+node:ekr.20110605121601.18313: *6* leoQtLog Birth
#@+node:ekr.20110605121601.18314: *7* leoQtLog.__init__
def __init__ (self,frame,parentFrame):

    # g.trace('(leoQtLog)',frame,parentFrame)

    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)

    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    # self.logCtrl = None # The text area for log messages.
        # logCtrl is now a property of the base leoLog class.

    self.contentsDict = {} # Keys are tab names.  Values are widgets.
    self.eventFilters = [] # Apparently needed to make filters work!
    self.logDict = {} # Keys are tab names text widgets.  Values are the widgets.
    self.menu = None # A menu that pops up on right clicks in the hull or in tabs.

    self.tabWidget = tw = c.frame.top.leo_ui.tabWidget
        # The Qt.QTabWidget that holds all the tabs.
    
    # Fixes bug 917814: Switching Log Pane tabs is done incompletely.
    tw.connect(tw,QtCore.SIGNAL('currentChanged(int)'),self.onCurrentChanged)

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),True,False)

    if 0: # Not needed to make onActivateEvent work.
        # Works only for .tabWidget, *not* the individual tabs!
        theFilter = leoQtEventFilter(c,w=tw,tag='tabWidget')
        tw.installEventFilter(theFilter)

    self.setFontFromConfig()
    self.setColorFromConfig()
#@+node:ekr.20110605121601.18315: *7* leoQtLog.finishCreate
def finishCreate (self):

    c = self.c ; log = self ; w = self.tabWidget

    # Remove unneeded tabs.
    for name in ('Tab 1','Page'):
        for i in range(w.count()):
            if name == w.tabText(i):
                w.removeTab(i)
                break

    # Rename the 'Tab 2' tab to 'Find'.
    for i in range(w.count()):
        if w.tabText(i) in ('Find','Tab 2'):
            w.setTabText(i,'Find')
            self.contentsDict['Find'] = w.currentWidget()
            break

    # Create the log tab as the leftmost tab.
    # log.selectTab('Log')
    log.createTab('Log')
    logWidget = self.contentsDict.get('Log')
    logWidget.setWordWrapMode(
        g.choose(self.wrap,
            QtGui.QTextOption.WordWrap,
            QtGui.QTextOption.NoWrap))

    for i in range(w.count()):
        if w.tabText(i) == 'Log':
            w.removeTab(i)
    w.insertTab(0,logWidget,'Log')

    c.searchCommands.openFindTab(show=False)
    c.spellCommands.openSpellTab()
#@+node:ekr.20110605121601.18316: *7* leoQtLog.getName
def getName (self):
    return 'log' # Required for proper pane bindings.
#@+node:ekr.20110605121601.18317: *6* Do nothings (leoQtLog)
#@+node:ekr.20110605121601.18318: *7* Config (leoQtLog)
# These will probably be replaced by style sheets.

def configureBorder(self,border):               pass
def configureFont(self,font):                   pass
def getFontConfig (self):                       pass
def setColorFromConfig (self):                  pass
def SetWidgetFontFromConfig (self,logCtrl=None): pass
def saveAllState (self):                        pass
def restoreAllState (self,d):                   pass
#@+node:ekr.20110605121601.18319: *7* Focus & update (leoQtLog)
def onActivateLog (self,event=None):    pass
def hasFocus (self):                    return None
def forceLogUpdate (self,s):            pass
#@+node:ekr.20120304214900.9940: *6* Event handler (leoQtLog)
def onCurrentChanged(self,idx):
    
    trace = False and not g.unitTesting

    tabw = self.tabWidget
    w = tabw.widget(idx)
    
    # Fixes bug 917814: Switching Log Pane tabs is done incompletely
    wrapper = hasattr(w,'leo_log_wrapper') and w.leo_log_wrapper
    if wrapper:
        self.widget = wrapper

    if trace: g.trace(idx,tabw.tabText(idx),self.c.frame.title) # wrapper and wrapper.widget)
#@+node:ekr.20111120124732.10184: *6* isLogWidget (leoQtLog)
def isLogWidget(self,w):
    
    val = w == self or w in list(self.contentsDict.values())
    # g.trace(val,w)
    return val
#@+node:ekr.20110605121601.18321: *6* put & putnl (leoQtLog)
#@+node:ekr.20110605121601.18322: *7* put (leoQtLog)
# All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):

    c = self.c
    if g.app.quitting or not c or not c.exists:
        print('qtGui.log.put fails',repr(s))
        return

    if color:
        color = leoColor.getColor(color,'black')
    else:
        color = leoColor.getColor('black')

    self.selectTab(tabName or 'Log')

    # Note: this must be done after the call to selectTab.
    w = self.logCtrl.widget
        # w is a QTextBrowser

    if w:
        sb = w.horizontalScrollBar()
        pos = sb.sliderPosition()
        # g.trace(pos,sb,g.callers())
        s=s.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
        if not self.wrap: # 2010/02/21: Use &nbsp; only when not wrapping!
            s = s.replace(' ','&nbsp;')
        s = s.rstrip().replace('\n','<br>')
        s = '<font color="%s">%s</font>' % (color,s)
        w.append(s)
        w.moveCursor(QtGui.QTextCursor.End)
        sb.setSliderPosition(0) # Force the slider to the initial position.
    else:
        # put s to logWaiting and print s
        g.app.logWaiting.append((s,color),)
        if g.isUnicode(s):
            s = g.toEncodedString(s,"ascii")
        print(s)
#@+node:ekr.20110605121601.18323: *7* putnl (leoQtLog)
def putnl (self,tabName='Log'):

    if g.app.quitting:
        return

    if tabName:
        self.selectTab(tabName)

    w = self.logCtrl.widget
    
    if w:
        sb = w.horizontalScrollBar()
        pos = sb.sliderPosition()
        # Not needed!
            # contents = w.toHtml()
            # w.setHtml(contents + '\n')
        w.moveCursor(QtGui.QTextCursor.End)
        sb.setSliderPosition(pos)
        w.repaint() # Slow, but essential.
    else:
        # put s to logWaiting and print  a newline
        g.app.logWaiting.append(('\n','black'),)
#@+node:ekr.20110605121601.18324: *6* Tab (leoQtLog)
#@+node:ekr.20110605121601.18325: *7* clearTab
def clearTab (self,tabName,wrap='none'):

    w = self.logDict.get(tabName)
    if w:
        w.clear() # w is a QTextBrowser.
#@+node:ekr.20110605121601.18326: *7* createTab (leoQtLog)
def createTab (self,tabName,widget=None,wrap='none'):
    """ Create a new tab in tab widget

    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """

    trace = False and not g.unitTesting
    c = self.c
    
    if trace: g.trace(tabName,widget and g.app.gui.widget_name(widget) or '<no widget>')

    if widget is None:

        widget = LeoQTextBrowser(parent=None,c=c,wrapper=self)
            # widget is subclass of QTextBrowser.
        contents = leoQTextEditWidget(widget=widget,name='log',c=c)
            # contents a wrapper.
        widget.leo_log_wrapper = contents
            # Inject an ivar into the QTextBrowser that points to the wrapper.
            
        if trace: g.trace('** creating',tabName,'self.widget',contents,'wrapper',widget)
        
        widget.setWordWrapMode(
            g.choose(self.wrap,
                QtGui.QTextOption.WordWrap,
                QtGui.QTextOption.NoWrap))

        widget.setReadOnly(False) # Allow edits.
        self.logDict[tabName] = widget
        if tabName == 'Log':
            self.widget = contents # widget is an alias for logCtrl.
            widget.setObjectName('log-widget')

        if True: # 2011/05/28.
            # Set binding on all text widgets.
            theFilter = leoQtEventFilter(c,w=self,tag='log')
            self.eventFilters.append(theFilter) # Needed!
            widget.installEventFilter(theFilter)
            
        if True and tabName == 'Log':
    
            assert c.frame.top.__class__.__name__ == 'DynamicWindow'
            find_widget = c.frame.top.leo_find_widget
            
            # 2011/11/21: A hack: add an event filter.
            find_widget.leo_event_filter = leoQtEventFilter(c,w=widget,tag='find-widget')
            find_widget.installEventFilter(find_widget.leo_event_filter)
            if trace: g.trace('** Adding event filter for Find',find_widget)
            
            # 2011/11/21: A hack: make the find_widget an official log widget.
            self.contentsDict['Find']=find_widget
    
        self.contentsDict[tabName] = widget
        self.tabWidget.addTab(widget,tabName)
    else:
        contents = widget
            # Unlike text widgets, contents is the actual widget.
        widget.leo_log_wrapper = contents
            # The leo_log_wrapper is the widget itself.
        if trace: g.trace('** using',tabName,widget)
        
        if 1: # Now seems to work.
            theFilter = leoQtEventFilter(c,w=contents,tag='tabWidget')
            self.eventFilters.append(theFilter) # Needed!
            widget.installEventFilter(theFilter)
    
        self.contentsDict[tabName] = contents
        self.tabWidget.addTab(contents,tabName)

    return contents
#@+node:ekr.20110605121601.18327: *7* cycleTabFocus (leoQtLog)
def cycleTabFocus (self,event=None):

    '''Cycle keyboard focus between the tabs in the log pane.'''
    
    trace = False and not g.unitTesting
    c = self.c
    w = self.tabWidget

    i = w.currentIndex()
    i += 1
    if i >= w.count():
        i = 0

    tabName = w.tabText(i)
    
    self.selectTab(tabName,createText=False)
    if trace: g.trace(i,tabName)

#@+node:ekr.20110605121601.18328: *7* deleteTab
def deleteTab (self,tabName,force=False):

    c = self.c ; w = self.tabWidget

    if force or tabName not in ('Log','Find','Spell'):
        for i in range(w.count()):
            if tabName == w.tabText(i):
                w.removeTab(i)
                break

    self.selectTab('Log')
    c.invalidateFocus()
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18329: *7* hideTab
def hideTab (self,tabName):

    self.selectTab('Log')
#@+node:ekr.20111122080923.10185: *7* orderedTabNames (leoQtLog)
def orderedTabNames (self):
    
    '''Return a list of tab names in the order in which they appear in the QTabbedWidget.'''
    
    w = self.tabWidget

    return [w.tabText(i) for i in range(w.count())]

#@+node:ekr.20110605121601.18330: *7* numberOfVisibleTabs (leoQtLog)
def numberOfVisibleTabs (self):

    return len([val for val in self.contentsDict.values() if val != None])
        # **Note**: the base-class version of this uses frameDict.
#@+node:ekr.20110605121601.18331: *7* selectTab & helper (leoQtLog)
def selectTab (self,tabName,createText=True,widget=None,wrap='none'):
    # createText is used by leoLog.selectTab.

    '''Create the tab if necessary and make it active.'''

    trace = False and not g.unitTesting
    c = self.c ; w = self.tabWidget
    
    if trace: g.trace(tabName,g.callers())

    # Step 1: See if the tab exits.
    ok = self.selectHelper(tabName)
    if ok: return

    # Step 2: create tab if necessary.
    self.createTab(tabName,widget=widget,wrap=wrap)
    self.selectHelper(tabName)
#@+node:ekr.20110605121601.18332: *8* selectHelper (leoQtLog)
def selectHelper (self,tabName):

    trace = False and not g.unitTesting
    c,w = self.c,self.tabWidget

    for i in range(w.count()):
        if tabName == w.tabText(i):
            w.setCurrentIndex(i)
            
            widget = w.widget(i)
            
            # 2011/11/21: Set the .widget ivar only if there is a wrapper.
            wrapper = hasattr(widget,'leo_log_wrapper') and widget.leo_log_wrapper
            if wrapper:
                self.widget = wrapper
            if trace: g.trace(tabName,'widget',widget,'wrapper',wrapper)
            
            # Do *not* set focus here!
                # c.widgetWantsFocus(tab_widget)

            if tabName == 'Spell':
                # the base class uses this as a flag to see if
                # the spell system needs initing
                self.frameDict['Spell'] = widget
                
            self.tabName = tabName # 2011/11/20
            return True
    else:
        self.tabName = None # 2011/11/20
        if trace: g.trace('** not found',tabName)
        return False
#@+node:ekr.20110605121601.18333: *6* leoQtLog color tab stuff
def createColorPicker (self,tabName):

    g.es('color picker not ready for qt',color='blue')
#@+node:ekr.20110605121601.18334: *6* leoQtLog font tab stuff
#@+node:ekr.20110605121601.18335: *7* createFontPicker
def createFontPicker (self,tabName):

    log = self
    QFont = QtGui.QFont
    font,ok = QtGui.QFontDialog.getFont()
    if not (font and ok): return

    style = font.style()
    table = (
        (QFont.StyleNormal,'normal'),
        (QFont.StyleItalic,'italic'),
        (QFont.StyleOblique,'oblique'))
    for val,name in table:
        if style == val:
            style = name ; break
    else: style = ''

    weight = font.weight()
    table = (
        (QFont.Light,'light'),
        (QFont.Normal,'normal'),
        (QFont.DemiBold,'demibold'),
        (QFont.Bold	,'bold'),
        (QFont.Black,'black'))
    for val,name in table:
        if weight == val:
            weight = name ; break
    else: weight = ''

    table = (
        ('family',str(font.family())),
        ('size  ',font.pointSize()),
        ('style ',style),
        ('weight',weight),
    )

    for key,val in table:
        if val:
            g.es(key,val,tabName='Fonts')
#@+node:ekr.20110605121601.18336: *7* createBindings (fontPicker)
def createBindings (self):
    
    pass
#@+node:ekr.20110605121601.18337: *7* getFont
def getFont(self,family=None,size=12,slant='roman',weight='normal'):

    return g.app.config.defaultFont
#@+node:ekr.20110605121601.18338: *7* setFont
def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):

    pass
#@+node:ekr.20110605121601.18339: *7* hideFontTab
def hideFontTab (self,event=None):

    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@+node:ekr.20120306090228.10818: *4* Fixed bug 924123: Some SyntaxError's thrown when compiling the whole source with Python 3
@nocolor-node

Rev 5076 fixes bug 924123:
Some SyntaxError's thrown when compiling the whole source with Python 3
https://bugs.launchpad.net/leo-editor/+bug/924123

These syntax errors were minor in the sense that they had no
effect on Leo's users, but they were a significant
distribution issue because Linux packages are not to have
such errors.

Notes:

I removed the following files. Apparently, they are used nowhere in Leo. 
    
    leo/core/leo_Debugger.py
    leo/core/leo_FileList.py"
    leo/core/leo_RemoteDebugger.py
    leo/core/leo_Shell.py
    leo/core/leo_run.py

This files no longer exists:

    leosax.py
    
Fixed all reported syntax errors.

The unit test "@test syntax of all files" now checks the following files:
    
- old gui files:
    cursesGui.py, ironPythonGui.py, swing_gui.py, tkGui.py, and wxGui.py
    
- script files:
    convert_to_shadow.py, leoFindScript.py, LinixInstall.py,
    tangle_done.py, untangle_done.py
#@+node:ekr.20111026091322.16496: *4* Tried, and failed, to fix bug 844953: copy-clone-pasted node appears in other tab
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/844953

1. Open two empty files with the LEO revision 4451/trunk using the qttabs GUI and save them both.
2. Create a new node and write "Abc" in its head.
3. Select "Copy Node" from the outline menu.
4. Select "Paste Node As Clone" from the outline menu:
   Node is not inserted as clone, but inserted as a copy in the second file/tab.

Sometimes even a standard Copy-Paste action results in the node being inserted in the other file.

EKR: This a unity menu problem, not a problem with the paste commands per se.

The problem is that only a single unity menu exists, and we must ensure that
it is the menu for the presently-selected tab.


The new code consists of calls to c.enableMenuBar, but the code has no effect, so it will be eliminated.
#@+node:ekr.20110605121601.18456: *5* select (leoTabbedTopLevel)
def select (self,c):

    '''Select the tab for c.'''
    
    dw = c.frame.top # A DynamicWindow
    i = self.indexOf(dw)
    self.setCurrentIndex(i)
    
    # Fix bug 844953: tell Unity which menu to use.
    c.enableMenuBar()

    # g.trace(i,c.frame.title,c.frame.menu.menuBar)
#@+node:ekr.20120223062418.10405: *5* LM.createMenu
def createMenu(self,c,fn=None):

    # Create the menu as late as possible so it can use user commands.
    lm = self

    if not g.doHook("menu1",c=c,p=c.p,v=c.p):

        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2",c=c,p=c.p,v=c.p)
        g.doHook("after-create-leo-frame",c=c)
        g.doHook("after-create-leo-frame2",c=c)

        # Fix bug 844953: tell Unity which menu to use.
        c.enableMenuBar()
#@+node:ekr.20120306130648.9849: *5* c.enableMenuBar
def enableMenuBar(self):
    
    '''A failed attempt to work around Ubuntu Unity memory bugs.'''
    
    c = self
    
    # g.trace(c.frame.title,g.callers())
    
    if 0:
        if c.frame.menu.isNull:
            return
    
        for frame in g.app.windowList:
            if frame != c.frame:
                frame.menu.menuBar.setDisabled(True)
    
        c.frame.menu.menuBar.setEnabled(True)
#@+node:ekr.20120306130648.9850: *4* Fixed bug 501636: Leo's import code should support non-ascii xml tags
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/501636

Leo's present @auto import code for xml files supports only ascii tags.

In particular, xmlScanner.isWordChar should allow non-ascii characters as specified in
www.w3.org/TR/2008/REC-xml-20081126/#NT-Name

NameStartChar ::= ":" | [A-Z] | "_" | [a-z] |
    [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |
    [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] |
    [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] |
    [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]

NameChar ::= NameStartChar | "-" | "." | [0-9] | #xB7 |
    [#x0300-#x036F] | [#x203F-#x2040]

The following script, presently in test.leo, may be useful:

import unicodedata as u
table = ('a','9','_',':','.',)
table2 = (
    (0xc0,0xd6),(0xd8,0xf6),(0xf8,0x2ff),(0x370,0x37d),(0x37f,0x1fff),
    (0x200c,0x200d),(0x2070,0x218f),(0x2c00,0x2fef),(0x3001,0xd7ff),
    (0xf900,0xfdcf),(0xfdf0,0xfffd),(0x10000,0xeffff),
    # Valid only after the start of a word.
    (0xb7,0xb7+1),(0x0300,0x036f),(0x203f,0x2040),
)
for ch in table:
    ch = g.u(ch)
    g.es(ch,u.category(ch))
for i,j in table2:
    g.es('*** range %xd %xd' % (i,j))
    for n in range(i,min(i+5,j)):
        if g.isPython3: ch = chr(n)
        else: ch = unichr(n)
        g.es(ch,u.category(ch))

Clearly, however, the unicode category of these characters
is not helpful. Instead, a dictionary lookup would be
appropriate.
#@+node:ekr.20071214072924.4: *5* startsHelper & helpers (xmlScanner)
def startsHelper(self,s,i,kind,tags,tag=None):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = (False and kind == 'class') # and not g.unitTesting
    verbose = True
    self.codeEnd = self.sigEnd = self.sigId = None

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Get the tag that starts the class or function.
    if not g.match(s,i,'<'): return False
    self.sigStart = i
    i += 1
    sigIdStart = j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    
    # Fix bug 501636: Leo's import code should support non-ascii xml tags.
    # The call to g.toUnicode only needed on Python 2.x.
    self.sigId = theId = g.toUnicode(s[j:i].lower())
        # Set sigId ivar 'early' for error messages.
        # Bug fix: html case does not matter.
    if not theId: return False

    if theId not in tags:
        if trace and verbose:
            g.trace('**** %s theId: %s not in tags: %s' % (
                kind,theId,tags))
        return False

    if trace and verbose: g.trace(theId)
    classId = '' 
    sigId = theId

    # Complete the opening tag.
    i, ok, complete = self.skipToEndOfTag(s,i,start=sigIdStart)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # Bug fix: 2011/11/05.
    # For xml/html, make sure the signature includes any trailing whitespace.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        # sigEnd = g.skip_line(s,sigEnd)
        sigEnd = g.skip_ws(s,sigEnd)

    if not complete:
        i,ok = self.skipToMatchingTag(s,i,theId,tags,start=sigIdStart)
        if not ok:
            if trace and verbose: g.trace('no matching tag:',theId)
            return False

    # Success: set the ivars.
    # Not used in xml/html.
    # self.sigStart = self.adjustDefStart(s,self.sigStart)
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId
            
    # Scan to the start of the next tag.
    done = False
    while not done and i < len(s):
        progress = i
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif s[i] == '<':
            start = i
            i += 1
            if i < len(s) and s[i] == '/':
                i += 1
            j = g.skip_ws_and_nl(s,i)
            if self.startsId(s,j):
                i = self.skipId(s,j)
                word = s[j:i].lower()
                if word in tags:
                    self.codeEnd = start
                    done = True
                    break
            else:
                i = j
        else:
            i += 1
        
        assert done or progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    if trace: g.trace(repr(s[self.sigStart:self.codeEnd]))
    return True
#@+node:ekr.20071214072924.3: *6* skipToEndOfTag (xmlScanner)
def skipToEndOfTag(self,s,i,start):

    '''Skip to the end of an open tag.
    
    return i,ok,complete
    
    where complete is True if the tag of the form <name/>
    '''

    trace = False
    complete,ok = False,False
    while i < len(s): 
        progress = i
        if i == '"':
            i = self.skipString(s,i)
        elif g.match(s,i,'<!--'):
            i = self.skipComment(s,i)
        elif g.match(s,i,'<'):
            complete,ok = False,False ; break
        elif g.match(s,i,'/>'):
            i = g.skip_ws(s,i+2)
            complete,ok = True,True ; break
        elif g.match(s,i,'>'):
            i += 1
            complete,ok = False,True ; break
        else:
            i += 1
        assert progress < i

    if trace: g.trace('ok',ok,repr(s[start:i]))
    return i,ok,complete
#@+node:ekr.20071214075117: *6* skipToMatchingTag (xmlScanner)
def skipToMatchingTag (self,s,i,tag,tags,start):
    
    '''Skip the entire class definition. Return i,ok.
    '''

    trace = False
    found,level,target_tag = False,1,tag.lower()
    while i < len(s): 
        progress = i
        if s[i] == '"':
            i = self.skipString(s,i)
        elif g.match(s,i,'<!--'):
            i = self.skipComment(s,i)
        elif g.match(s,i,'</'):
            j = i+2
            i = self.skipId(s,j)
            tag2 = s[j:i].lower()
            i,ok,complete = self.skipToEndOfTag(s,i,start=j)
                # Sets complete if /> terminates the tag.
            if ok and tag2 == target_tag:
                level -= 1
                if level == 0:
                    found = True ; break
        elif g.match(s,i,'<'):
            # An open tag.
            j = g.skip_ws_and_nl(s,i+1)
            i = self.skipId(s,j)
            word = s[j:i].lower()
            i,ok,complete = self.skipToEndOfTag(s,i,start=j)
            # **Important**: only bump level for nested *target* tags.
            # This avoids problems when interior tags are not properly nested.
            if ok and word == target_tag and not complete:
                level += 1
        elif g.match(s,i,'/>'):
            # This is a syntax error.
            # This should have been eaten by skipToEndOfTag.
            i += 2
            g.trace('syntax error: unmatched "/>"')
        else:
            i += 1

        assert progress < i
        
    if trace: g.trace('%sfound:%s\n%s\n\n*****end %s\n' % (
        g.choose(found,'','not '),target_tag,s[start:i],target_tag))

    return i,found
#@+node:ekr.20091230062012.6238: *5* skipId (override base class) & helper
@  For characters valid in names see:
   www.w3.org/TR/2008/REC-xml-20081126/#NT-Name
@c

def skipId (self,s,i):

    if 1:
        # Fix bug 501636: Leo's import code should support non-ascii xml tags.
        if i < len(s) and self.isWordChar1(s[i]):
            i += 1
        else:
            return i
        while i < len(s) and self.isWordChar2(s[i]):
            i += 1
        return i
    else:
        # Fix bug 497332: @data import_xml_tags does not allow dashes in tag.
        chars = '.-:' # Allow : anywhere.
        while i < len(s) and (self.isWordChar(s[i]) or s[i] in chars):
            i += 1
        return i
#@+node:ekr.20120306130648.9852: *6* isWordChar (xmlScanner) To be replaced
def isWordChar (self,ch):
    
    '''This allows only ascii tags.'''
    
    # Same as g.isWordChar. This is not correct.
    return ch and (ch.isalnum() or ch == '_')
#@+node:ekr.20091230062012.6239: *6* isWordChar1 (xmlScanner)
@ From www.w3.org/TR/2008/REC-xml-20081126/#NT-Name

NameStartChar    ::= ":" | [A-Z] | "_" | [a-z] |
    [#xC0-#xD6]     | [#xD8-#xF6]     | [#xF8-#x2FF]    |
    [#x370-#x37D]   | [#x37F-#x1FFF]  | [#x200C-#x200D] |
    [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] |
    [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
@c

word_char_table1 = (
    (0xC0,  0xD6),    (0xD8,  0xF6),    (0xF8,  0x2FF),
    (0x370, 0x37D),   (0x37F, 0x1FFF),  (0x200C,0x200D),
    (0x2070,0x218F),  (0x2C00,0x2FEF),  (0x3001,0xD7FF),
    (0xF900,0xFDCF),  (0xFDF0,0xFFFD),  (0x10000,0xEFFFF),
)

def isWordChar1(self,ch):
    
    if not ch: return False
    
    if ch.isalnum() or ch in '_:': return True
    
    n = ord(ch)
    for n1,n2 in self.word_char_table1:
        if n1 <= n <= n2:
            return True

    return False
#@+node:ekr.20120306130648.9851: *6* isWordChar2 (xmlScanner)
@ From www.w3.org/TR/2008/REC-xml-20081126/#NT-Name

NameChar    ::= NameStartChar | "-" | "." | [0-9] | #xB7 |
    [#x0300-#x036F] | [#x203F-#x2040]
@c
    
word_char_table2 = (
    (0xB7,      0xB7),  # Middle dot.
    (0x0300,    0x036F),
    (0x203F,    0x2040),
)

def isWordChar2(self,ch):
    
    if not ch: return False
    
    if self.isWordChar1(ch) or ch in "-.0123456789":
        return True
    
    n = ord(ch)
    for n1,n2 in self.word_char_table2:
        if n1 <= n <= n2:
            return True

    return False
#@+node:ekr.20071018084830: *5* scanHelper (baseScannerClass)
def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    # g.trace(g.callers())
    # g.trace('i',i,g.get_line(s,i))
    assert kind in ('class','outer')
    start = i ; putRef = False ; bodyIndent = None
    # Major change: 2011/11/11: prevent scanners from going beyond end.
    if self.hasNestedClasses and end < len(s):
        s = s[:end] # Potentially expensive, but unavoidable.
    # if g.unitTesting: g.pdb()
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i)
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
            # Bug fix: 2007/11/8: do *not* set start: we are just skipping the block.
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,bodyIndent
#@+node:ekr.20111103073536.16595: *5* startsId (xmlScanner)
def startsId(self,s,i):
    
    # Fix bug 501636: Leo's import code should support non-ascii xml tags.
    return i < len(s) and self.isWordChar1(s[i])
#@+node:ekr.20120306130648.9853: *5* test
table1 = (
    (0xC0,  0xD6),    (0xD8,  0xF6),    (0xF8,  0x2FF),
    # (0x370, 0x37D),   (0x37F, 0x1FFF),  (0x200C,0x200D),
    # (0x2070,0x218F),  (0x2C00,0x2FEF),  (0x3001,0xD7FF),
    # (0xF900,0xFDCF),  (0xFDF0,0xFFFD),  (0x10000,0xEFFFF),
)

table2 = (
    (0xB7,  0xB7),
    (0x0300,0x036F),
    (0x203F,0x2040),
)

result = []
result.append('*****')
for table in table1,table2:
    for n1,n2 in table:
        for n in range(n1,n2+1):
            result.append(chr(n))
    result.append('=====')
        
# g.es(len(''.join(result)))
g.es('\n'.join(result))
#@+node:ekr.20120306201510.9853: *4* Fixed bug 799695: colorizer bug after move-lines-up into a docstring
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/799695

# The fix was simply to call c.recolor_now(incremental=False)
#@+node:ekr.20120306201510.9855: *4* Fixed bug 824087: Alt+F4 is not the same as Alt+F, c
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/824087

The fix was to bind Ctrl-F4 to close-window, instead of Alt-F4.

I instantly like this new binding.
#@+node:ekr.20120306201510.9854: *4* Fixed(?) bug 923301: Unicode error when executing 'rst3' command
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/923301

I am opening a bug for this, since I think that a Leo-Newbie might not be
able to find a work around for this issue.

The 'rst3' command just fails silently - and - does not create any output
file at all. - It took me a while to find the offending section in the body
of a large outline node, so that the 'rst3' command was able to create
an output file again.

<log>

D:\Users\Viktor Ransmayr\Documents>leo ./BR-2012-01-28.leo

** isPython3: True
Leo 4.9.1 devel, build 4950, 2012-01-28 10:16:45
Python 3.2.2, qt version 4.8.0
Windows 6, 1, 7601, 2, Service Pack 1
reading settings in D:\Branches\leo-editor\leo\config\leoSettings.leo
reading settings in D:\Users\Viktor Ransmayr\.leo\myLeoSettings.leo
reading settings in D:\Users\Viktor Ransmayr\Documents\BR-2012-01-28.leo
wrote recent file: D:\Users\Viktor Ransmayr\.leo\.leoRecentFiles.txt
<string>:179: (WARNING/2) Literal block expected; none found.
Traceback (most recent call last):
  File "D:\Branches\leo-editor\leo\plugins\qtGui.py", line 8689, in eventFilter
    ret = k.masterKeyHandler(event)
  File "D:\Branches\leo-editor\leo\core\leoKeys.py", line 2897, in masterKeyHandler
    done,val = k.doMode(event,state,stroke)
  File "D:\Branches\leo-editor\leo\core\leoKeys.py", line 2973, in doMode
    val = k.callStateFunction(event) # Calls end-command.
  File "D:\Branches\leo-editor\leo\core\leoKeys.py", line 2947, in callStateFunction
    val = k.state.handler(event)
  File "D:\Branches\leo-editor\leo\core\leoKeys.py", line 2010, in fullCommand
    k.callAltXFunction(k.mb_event)
  File "D:\Branches\leo-editor\leo\core\leoKeys.py", line 2056, in callAltXFunction
    func(event)
  File "D:\Branches\leo-editor\leo\core\leoRst.py", line 472, in rst3
    self.processTopTree(self.c.p)
  File "D:\Branches\leo-editor\leo\core\leoRst.py", line 482, in processTopTree

self.processTree(p,ext=None,toString=False,justOneFile=justOneFile)
  File "D:\Branches\leo-editor\leo\core\leoRst.py", line 510, in processTree

self.write_rst_tree(p,ext,fn,toString=toString,justOneFile=justOneFile)
  File "D:\Branches\leo-editor\leo\core\leoRst.py", line 560, in write_rst_tree

self.write_files(ext,fn,callDocutils,toString,writeIntermediateFile)
  File "D:\Branches\leo-editor\leo\core\leoRst.py", line 1749, in write_files
    f.write(s)
  File "C:\Python32\lib\encodings\cp1252.py", line 19, in encode
    return codecs.charmap_encode(input,self.errors,encoding_table)[0]
UnicodeEncodeError: 'charmap' codec can't encode character '\u0142' in position
19816: character maps to <undefined>

</log>

This has been re-produced with the latest revision of leo-trunk. - If wanted,
I can send a minimal outline that consistently produces this tracedback.
#@+node:ekr.20100813041139.5919: *5* write_files & helpers
def write_files (self,ext,fn,callDocutils,toString,writeIntermediateFile):

    isHtml = ext in ('.html','.htm')
    fn = self.computeOutputFileName(fn)
    if not toString:
        if not self.createDirectoryForFile(fn):
            return

    if writeIntermediateFile:
        if not toString:
            self.createIntermediateFile(fn,self.source)

    if callDocutils and ext in ('.htm','.html','.tex','.pdf','.s5','.odt'):
        self.stringOutput = s = self.writeToDocutils(self.source,ext)
        if s and isHtml:
            self.stringOutput = s = self.addTitleToHtml(s)
        if not s: return
        
        if toString:
            if not g.isUnicode(s):
                s = g.toUnicode(s,'utf-8')
        else:
            s = g.toEncodedString(s,'utf-8')
                # Fixes bug 923301: Unicode error when executing 'rst3' command
            f = open(fn,'w')
            f.write(s)
            f.close()
            self.report(fn)
            # self.http_endTree(fn,p,justOneFile=justOneFile)
#@+node:ekr.20100813041139.5913: *6* addTitleToHtml
def addTitleToHtml(self,s):

    '''Replace an empty <title> element by the contents of
    the first <h1> element.'''

    i = s.find('<title></title>')
    if i == -1: return s

    m = re.search('<h1>([^<]*)</h1>', s)
    if not m:
        m = re.search('<h1><[^>]+>([^<]*)</a></h1>', s)
    if m:
        s = s.replace('<title></title>',
            '<title>%s</title>' % m.group(1))

    return s
#@+node:ekr.20100813041139.5914: *6* createDirectoryForFile
def createDirectoryForFile(self, fn):

    '''Create the directory for fn if
    a) it doesn't exist and
    b) the user options allow it.

    Return True if the directory existed or was made.'''

    c = self.c

    # Create the directory if it doesn't exist.
    theDir, junk = g.os_path_split(fn)
    theDir = c.os_path_finalize(theDir)

    if g.os_path_exists(theDir):
        return True
    else:
        ok = g.makeAllNonExistentDirectories(theDir,c=c,force=False)
        if not ok:
            g.es_print('did not create:',theDir,color='red')
        return ok
#@+node:ekr.20100813041139.5912: *6* createIntermediateFile (changed)
def createIntermediateFile(self,fn,s):

    '''Write s to to the file whose name is fn.'''

    ext = self.getOption('write_intermediate_extension')
    ext = ext or '.txt' # .txt by default.
    if not ext.startswith('.'): ext = '.' + ext

    fn = fn + ext

    # g.trace('intermediate file',fn)
    if g.isPython3:
        f = open(fn,'w',encoding=self.encoding)
    else:
        f = open(fn,'w')
    if not g.isPython3: # 2010/08/27
        s = g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
    f.write(s)
    f.close()
    self.report(fn)
#@+node:ekr.20090502071837.65: *6* writeToDocutils (sets argv) & helper
def writeToDocutils (self,s,ext):

    '''Send s to docutils using the writer implied by ext and return the result.'''

    trace = False and not g.unitTesting

    if not docutils:
        g.trace('docutils not present',color='red')
        return None

    openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding }

    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs()
    
    if ext == '.pdf':
        module = g.importFromPath(
            name = 'leo_pdf.py',
            path = g.os_path_finalize_join(g.app.loadDir,'..','plugins'),
            pluginName = 'leo_pdf',
            verbose = False)
        if not module:
            return None
        writer = module.Writer() # Get an instance.
        writer_name = None
    else:
        writer = None
        for ext2,writer_name in (
            ('.html','html'),
            ('.htm','html'),
            ('.tex','latex'),
            ('.pdf','leo.plugins.leo_pdf'), # 2011/11/03
            ('.s5','s5'), # 2011/03/27
            ('.odt','odt'), # 2011/03/27
        ):
            if ext2 == ext:
                break
        else:
            g.es_print('unknown docutils extension: %s' % (ext),color='red')
            return None
    
    if ext in ('.html','.htm') and not SilverCity:
        if not self.silverCityWarningGiven:
            self.silverCityWarningGiven = True
            if not g.unitTesting:
                g.es('SilverCity not present so no syntax highlighting')

    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption('stylesheet_path') or ''

    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        self.c.frame.openDirectory,rel_stylesheet_path)

    path = g.os_path_finalize_join(
        stylesheet_path,self.getOption('stylesheet_name'))

    res = ""
    if self.getOption('stylesheet_embed') == False:
        rel_path = g.os_path_join(
            rel_stylesheet_path,self.getOption('stylesheet_name'))
        rel_path = rel_path.replace('\\','/') # 2010/01/28
        overrides['stylesheet'] = rel_path
        overrides['stylesheet_path'] = None
        overrides['embed_stylesheet'] = None
    elif g.os_path_exists(path):
        if ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.es_print('stylesheet not found: %s' % (path),color='red')
    else:
        g.es_print('stylesheet not found\n',path,color='red')
        if self.path:g.es_print('@path:', self.path)
        g.es_print('open path:',self.c.frame.openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        if trace: g.trace('overrides',overrides)
        result = None # Ensure that result is defined.
        result = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer=writer,
                writer_name=writer_name,
                settings_overrides=overrides)
        if g.isBytes(result):
            result = g.toUnicode(result)
    except docutils.ApplicationError as error:
        # g.es_print('Docutils error (%s):' % (
            # error.__class__.__name__),color='red')
        g.es_print('Docutils error:',color='red')
        g.es_print(error,color='blue')
    except Exception:
        g.es_print('Unexpected docutils exception')
        g.es_exception()
    return result
#@+node:ekr.20090502071837.66: *7* handleMissingStyleSheetArgs
def handleMissingStyleSheetArgs (self,s=None):

    '''Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.'''

    force = False
    if force:
        # See http://docutils.sourceforge.net/docs/user/config.html#documentclass
        return {'documentclass':'report', 'documentoptions':'english,12pt,lettersize'}

    if not s:
        s = self.getOption('publish_argv_for_missing_stylesheets')
    if not s: return {}

    # Handle argument lists such as this:
    # --language=en,--documentclass=report,--documentoptions=[english,12pt,lettersize]
    d = {}
    while s:
        s = s.strip()
        if not s.startswith('--'): break
        s = s[2:].strip()
        eq = s.find('=')
        cm = s.find(',')
        if eq == -1 or (-1 < cm < eq): # key[nl] or key,
            val = ''
            cm = s.find(',')
            if cm == -1:
                key = s.strip()
                s = ''
            else:
                key = s[:cm].strip()
                s = s[cm+1:].strip()
        else: # key = val
            key = s[:eq].strip()
            s = s[eq+1:].strip()
            if s.startswith('['): # [...]
                rb = s.find(']')
                if rb == -1: break # Bad argument.
                val = s[:rb+1]
                s = s[rb+1:].strip()
                if s.startswith(','):
                    s = s[1:].strip()
            else: # val[nl] or val,
                cm = s.find(',')
                if cm == -1:
                    val = s
                    s = ''
                else:
                    val = s[:cm].strip()
                    s = s[cm+1:].strip()

        # g.trace('key',repr(key),'val',repr(val),'s',repr(s))
        if not key: break
        if not val.strip(): val = '1'
        d[str(key)] = str(val)

    return d
#@+node:ekr.20120307065748.14157: *4* Fixed bug 893230: URL coloring does not work for many Internet protocols
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/893230

Added support for colorizing the following schemes:
gopher,mailto,news,nntp,prospero,telnet,wais

No new unit tests, but the new code does pass a hand test (which found a bug).

Changed match_ural_any, etc, and addLeoRules.
#@+node:ekr.20110605121601.18608: *5* match_url_any/f/h  (new)
# Fix bug 893230: URL coloring does not work for many Internet protocols.
# Added support for: gopher, mailto, news, nntp, prospero, telnet, wais
url_regex_f = re.compile(  r"""(file|ftp)://[^\s'"]+[\w=/]""")
url_regex_g = re.compile(      r"""gopher://[^\s'"]+[\w=/]""")
url_regex_h = re.compile(r"""(http|https)://[^\s'"]+[\w=/]""")
url_regex_m = re.compile(      r"""mailto://[^\s'"]+[\w=/]""")
url_regex_n = re.compile( r"""(news|nntp)://[^\s'"]+[\w=/]""")
url_regex_p = re.compile(    r"""prospero://[^\s'"]+[\w=/]""")
url_regex_t = re.compile(      r"""telnet://[^\s'"]+[\w=/]""")
url_regex_w = re.compile(        r"""wais://[^\s'"]+[\w=/]""")

kinds = '(file|ftp|gopher|http|https|mailto|news|nntp|prospero|telnet|wais)'
# url_regex   = re.compile(r"""(file|ftp|http|https)://[^\s'"]+[\w=/]""")
url_regex   = re.compile(r"""%s://[^\s'"]+[\w=/]""" % (kinds))

def match_any_url(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex)

def match_url_f(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_f)
    
def match_url_g(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_g)

def match_url_h(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_h)
    
def match_url_m(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_m)
    
def match_url_n(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_n)
    
def match_url_p(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_p)
    
def match_url_t(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_t)

def match_url_w(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_w)
#@+node:ekr.20110605121601.18577: *5* addLeoRules
def addLeoRules (self,theDict):

    '''Put Leo-specific rules to theList.'''

    table = (
        # Rules added at front are added in **reverse** order.
        ('@',  self.match_leo_keywords,True), # Called after all other Leo matchers.
            # Debatable: Leo keywords override langauge keywords.
        ('@',  self.match_at_color,    True),
        ('@',  self.match_at_killcolor,True),
        ('@',  self.match_at_language, True), # 2011/01/17
        ('@',  self.match_at_nocolor,  True),
        ('@',  self.match_at_nocolor_node,True),
        ('@',  self.match_doc_part,    True),
        ('f',  self.match_url_f,       True),
        ('g',  self.match_url_g,       True),
        ('h',  self.match_url_h,       True),
        ('m',  self.match_url_m,       True),
        ('n',  self.match_url_n,       True),
        ('p',  self.match_url_p,       True),
        ('t',  self.match_url_t,       True),
        ('w',  self.match_url_w,       True),
        ('<',  self.match_section_ref, True), # Called **first**.
        # Rules added at back are added in normal order.
        (' ',  self.match_blanks,      False),
        ('\t', self.match_tabs,        False),
    )

    for ch, rule, atFront, in table:

        # Replace the bound method by an unbound method.

        if g.isPython3:
            rule = rule.__func__
        else:
            rule = rule.im_func
        # g.trace(rule)

        theList = theDict.get(ch,[])
        if rule not in theList:
            if atFront:
                theList.insert(0,rule)
            else:
                theList.append(rule)
            theDict [ch] = theList

    # g.trace(g.listToString(theDict.get('@')))
#@+node:ekr.20120307065748.14160: *4* Fixed bug 944551: @url URL Open Hangs Leo... 
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/944551
@url URL Open Hangs Leo-Editor for duration (and lesser URL problems)

- Removed "significant" calls to os.system. (It's alright to call os.system('cls'))
- Added support for unit testing to g.os_startfile, g.recursiveUNLSearch & g.handleUrl

Both unit tests and hand tests pass.
#@+node:ekr.20120307101527.9887: *5* @url file://C:/prog/test.sh
#@+node:ekr.20120307101527.9893: *5* @url file://C:/prog
#@+node:ekr.20120307101527.9898: *5* @url http://writemonkey.com/index.php
#@+node:ekr.20120307101527.14201: *5* @url file://C:\leo.repo\trunk\leo\doc\LeoDocs.leo#Leo 4.10 Release notes
#@+node:ekr.20120307130611.11249: *5* @url #-->Before 4.10 b1
#@+node:ekr.20090829140232.6036: *5* os_startfile
def os_startfile(fname):
    
    if g.unitTesting:
        g.app.unitTestDict['os_startfile']=fname
        return
    
    if sys.platform.startswith('win'):
        os.startfile(fname)
    elif sys.platform == 'darwin':
        # From Marc-Antoine Parent.
        try:
            subprocess.call(['open', fname])
        except OSError:
            pass # There may be a spurious "Interrupted system call"
        except ImportError:
            os.system("open '%s'" % (fname,))
    else:
        os.system('xdg-open "%s"'%fname)
#@+node:tbrown.20110219154422.37469: *5* g.recursiveUNLSearch
def recursiveUNLSearch(unlList, c, depth=0, p=None, maxdepth=0, maxp=None):
    """try and move to unl in the commander c
    
    NOTE: maxdepth is max depth seen in recursion so far, not a limit on
          how fast we will recurse.  So it should default to 0 (zero).
    """
    
    if g.unitTesting:
        g.app.unitTestDict['g.recursiveUNLSearch']=True
        return True, maxdepth, maxp

    def moveToP(c, p):
        c.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()
        c.frame.bringToFront()

    if depth == 0:
        nds = c.rootPosition().self_and_siblings()
        unlList = [i.replace('--%3E', '-->') for i in unlList if i.strip()]
        # drop empty parts so "-->node name" works
    else:
        nds = p.children()

    for i in nds:

        if unlList[depth] == i.h:

            if depth+1 == len(unlList):  # found it
                moveToP(c, i)
                return True, maxdepth, maxp
            else:
                if maxdepth < depth+1:
                    maxdepth = depth+1
                    maxp = i.copy()
                found, maxdepth, maxp = g.recursiveUNLSearch(unlList, c, depth+1, i, maxdepth, maxp)
                if found:
                    return found, maxdepth, maxp
                # else keep looking through nds

    if depth == 0 and maxp:  # inexact match
        moveToP(c, maxp)
        g.es('Partial UNL match')

    return False, maxdepth, maxp
#@+node:tbrown.20090219095555.61: *5* g.handleUrlInUrlNode
def handleUrlInUrlNode(url,c=None,p=None):
    
    # Note 1: the UNL plugin has its own notion of what a good url is.

    # Note 2: tree.OnIconDoubleClick now uses the body text of an @url
    #         node if it exists.

    if url:
        if c and not p:
            p = c.p
        g.handleUrl(c,p,url)
    else:
        g.es("no url following @url")
#@+node:tbrown.20090219095555.63: *6* g.handleUrl
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

def handleUrl(c,p,url):
    
    trace = False and not g.unitTesting

    try:
        parsed = urlparse(url)

        if parsed.netloc:
            leo_path = os.path.join(parsed.netloc, parsed.path)
            # "readme.txt" gets parsed into .netloc...
        else:
            leo_path = parsed.path
            
        if leo_path.endswith('\\'): leo_path = leo_path[:-1]
        if leo_path.endswith('/'):  leo_path = leo_path[:-1]
            
        if trace:
            print()
            g.trace('c.frame.title',c.frame.title)
            g.trace('leo_path     ',leo_path)
            g.trace('parsed.netloc',parsed.netloc)
            g.trace('parsed.path  ',parsed.path)
            g.trace('parsed.scheme',parsed.scheme)

        if c and parsed.scheme in ('', 'file'):
            
            if not leo_path:
            
                # local UNLs like "node-->subnode", "-->node", and "#node"
                if '-->' in parsed.path:
                    g.recursiveUNLSearch(parsed.path.split("-->"), c)
                    return
                if not parsed.path and parsed.fragment:
                    g.recursiveUNLSearch(parsed.fragment.split("-->"), c)
                    return
    
            # leo aware path
            leo_path = os.path.expanduser(leo_path)
            leo_path = g.os_path_expandExpression(leo_path, c=c)
            if p and not os.path.isabs(leo_path):
                leo_path = os.path.normpath(
                    os.path.join(c.getNodePath(p), leo_path))
    
            # .leo file
            if leo_path.lower().endswith('.leo') and os.path.exists(leo_path):
                # Immediately end editing, so that typing in the new window works properly.
                c.endEditing()
                c.redraw_now()
                if g.unitTesting:
                    g.app.unitTestDict['g.openWithFileName']=leo_path
                else:
                    c2 = g.openWithFileName(leo_path,old_c=c)
                    # with UNL after path
                    if c2 and parsed.fragment:
                        g.recursiveUNLSearch(parsed.fragment.split("-->"),c2)
                    if c2:
                        c2.bringToFront()
                        return
                    
        if parsed.scheme in ('', 'file'):
            if os.path.exists(leo_path):
                g.os_startfile(leo_path)
                return
            if parsed.scheme == 'file':
                g.es("File '%s' does not exist"%leo_path)
                return
            
        import webbrowser

        if g.unitTesting:
            g.app.unitTestDict['browser']=url
            return
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
        
    except:
        g.es("exception opening",url)
        g.es_exception()
#@-all

# Put this @language after the @all as a kind of permanent unit test.

#@@language python # Override the default .txt coloring.

#@@pagewidth 60
#@-leo
