.. @+leo-ver=5-thin
.. @+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
.. @+all
.. @+node:ekr.20170619165453.1: ** Branch: string-gui
Attempt to run all unit tests without using Qt gui code.
All gui-related code will be simulated with the StringTextWrapper class.
.. @+node:ekr.20170710063210.1: ** @command git-diff
g.cls()
import difflib
import os
@others
# GitDiffController(c, 'HEAD', 'HEAD~1').run()
GitDiffController(c, 'HEAD').run()
    # Same as git diff
.. @+node:ekr.20170806094320.13: *3* class GitDiffController
class GitDiffController:
    '''A class to do git diffs.'''
    @others
.. @+node:ekr.20170806094320.4: *4* gdc.__init__
def __init__ (self, c, rev1=None, rev2=None):
    '''Ctor for the GitDiffController class.'''
    self.c = c
    self.file_node = None
    self.old_dir = g.os_path_abspath('.')
    self.repo_dir = self.find_git_working_directory()
    self.rev1 = rev1
    self.rev2 = rev2
    self.root = None
.. @+node:ekr.20170806094321.1: *4* gdc.create_file_node
def create_file_node(self, diff_list, fn):

    p = self.root.insertAsLastChild()
    p.h = fn.strip()
    p.b = ''.join(diff_list)
    return p
.. @+node:ekr.20170806094320.18: *4* gdc.create_root
def create_root(self):
    
    c = self.c
    p = c.lastTopLevel().insertAfter()
    if self.rev1 and self.rev2:
        p.h = 'git diff %s %s' % (self.rev1, self.rev2)
    else:
        p.h = 'git diff'
    # p.b = '@language diff\n'
        # No such colorizer at present.
    return p
.. @+node:ekr.20170806094320.6: *4* gdc.diff_file
def diff_file(self, fn):
    
    trace = False and not g.unitTesting
    c = self.c
    lines = self.get_rev(self.rev1, fn)
    lines2 = self.get_rev(self.rev2, fn)
    diff_list = list(difflib.unified_diff(
        lines,
        lines2,
        self.rev1 or 'uncommitted',
        self.rev2 or 'uncommitted',
    ))
    if trace:
        g.trace(len(lines), len(lines2), fn)
        g.printList(diff_list)
    self.file_node = self.create_file_node(diff_list, fn)
    if c.looksLikeDerivedFile(fn):
        p1 = self.make_outline(fn, lines, self.rev1)
        if not p1: return
        p2 = self.make_outline(fn, lines2, self.rev2)
        if not p2: return
        ### To do: compare the outlines.
    
.. @+node:ekr.20170806094320.7: *4* gdc.find_file
def find_file(self, fn):
    '''Return the @<file> node matching fn.'''
    c = self.c
    fn = g.os_path_basename(fn)
    for p in c.all_unique_positions():
        if p.isAnyAtFileNode():
            fn2 = p.anyAtFileNodeName()
            if fn2.endswith(fn):
                return p
    return None
.. @+node:ekr.20170806094321.3: *4* gdc.find_git_working_directory
def find_git_working_directory(self):
    '''Return the git working directory.'''
    path = g.os_path_abspath('.')
    while path:
        if g.os_path_exists(g.os_path_finalize_join(path, '.git')):
            return path
        path = g.os_path_finalize_join(path, '..')
    return None
.. @+node:ekr.20170806094321.5: *4* gdc.finish
def finish(self):
    '''Finish execution of this command.'''
    c = self.c
    os.chdir(self.old_dir)
    c.contractAllHeadlines()
    self.root.expand()
    c.selectPosition(self.root)
    c.redraw()
.. @+node:ekr.20170806094320.9: *4* gdc.get_files
def get_files(self):
    '''Return a list of changed files.'''
    if self.rev1 and self.rev2:
        command = 'git diff --name-only %s %s' % (self.rev1, self.rev2)
        
    else:
        command = 'git diff --name-only'
    files = [
        z.strip() for z in g.execGitCommand(command, self.repo_dir)
            if z.strip().endswith('.py')
    ]
    # g.printList(files)
    return files
.. @+node:ekr.20170806094320.15: *4* gdc.get_rev
def get_rev(self, rev, fn):
    '''Get the file from the given rev, or the working directory if None.'''
    if rev:
        command = 'git show %s:%s' % (rev, fn)
        lines = g.execGitCommand(command, self.repo_dir)
    else:
        # Get the file from the working directory.
        path = g.os_path_finalize_join(self.repo_dir, fn)
        if g.os_path_exists(path):
            with open(path, 'r') as f:
                s = f.read().replace('\r','')
                s = g.toUnicode(s)
                lines = g.splitLines(s)
        else:
            g.trace('not found:', path)
            lines = []
    return lines
.. @+node:ekr.20170806094321.7: *4* gdc.make_outline
def make_outline(self, fileName, lines, rev):
    '''Create a temp outline from lines.'''
    # A specialized version of atFileCommands.read.
    c = self.c
    at = c.atFileCommands
    fromString = ''.join(lines)
    root = self.file_node.insertAsLastChild()
    root.h = fileName + ':' + rev if rev else fileName
    at.initReadIvars(root, fileName, importFileName=None, atShadow=None)
    at.fromString = fromString
    if at.errors:
        g.trace('init error')
        return None
    # From at.openFileForReading
    at.inputFile = g.FileLikeObject(fromString=fromString)
    at.initReadLine(fromString)
    ###
        # root.clearVisitedInTree()
        # at.scanAllDirectives(root, importing=at.importing, reading=True)
            # # Sets the following ivars:
                # # at.default_directory
                # # at.encoding: **changed later** by readOpenFile/at.scanHeader.
                # # at.explicitLineEnding
                # # at.language
                # # at.output_newline
                # # at.page_width
                # # at.tab_width
    at.readOpenFile(root, fileName, deleteNodes=True)
        # Calls at.scanHeader, which sets at.encoding.
    at.inputFile.close()
    root.clearDirty()
    if at.errors == 0:
        at.deleteUnvisitedNodes(root)
        at.deleteTnodeList(root)
    ###
        # if at.errors == 0 and not at.importing:
            # # Used by mod_labels plugin.
            # at.readPostPass(root, thinFile)
    at.deleteAllTempBodyStrings()
    return root
.. @+node:ekr.20170806094320.12: *4* gdc.run
def run(self):
    '''The main line of the git diff command.'''
    c = self.c
    if self.repo_dir:
        files = self.get_files()
        if files:
            self.root = self.create_root()
            c.selectPosition(self.root)
            for fn in files:
                self.diff_file(fn)
            self.finish()
        else:
            g.es_print('empty git diff')
    else:
        g.es_print('no git repo found in', g.os_path_abspath('.'))
.. @-all
.. @@nosearch
.. @@killbeautify
.. @@language rest
.. @@wrap
.. @@pagewidth 60
.. @-leo
