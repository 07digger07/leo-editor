.. @+leo-ver=5-thin
.. @+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
.. @+all
.. @+node:ekr.20170325085902.1: ** 5.6
.. @+node:ekr.20170326052206.1: *3* bugs
.. @+node:ekr.20170403181726.1: *4* #385: Leo doesn't remember new headlines after saves
https://github.com/leo-editor/leo-editor/issues/385
.. @+node:ekr.20170324115046.1: *4* #386: colorize markdown properly
https://github.com/leo-editor/leo-editor/issues/386
All changes made to leo/modes/md.py
.. @+node:ekr.20170315103331.1: *4* #438: Tree abbreviation placeholders in headlines...
https://github.com/leo-editor/leo-editor/issues/438
.. @+node:ekr.20170411191726.1: *4* #449 & #470: Spontaneous node generation
https://github.com/leo-editor/leo-editor/issues/470

See also:
https://github.com/leo-editor/leo-editor/issues/449
The original fix was in i.run in linescanner.py.
.. @+node:ekr.20170330024242.1: *4* #451: refresh-from-disk selects wrong node
https://github.com/leo-editor/leo-editor/issues/451
refresh-from-disk doesn't always restore focus to the correct node

- at.readOneAtAutoNode returns the *new* position.
- c.refreshFromDisk selects that position.
.. @+node:ekr.20170401202930.1: *4* #453: Focus jumps to body when expanding abbrev in a headline
https://github.com/leo-editor/leo-editor/issues/453
Focus jumps to de body pane when expanding an abbreviation in a headline.

The fix was in find_place_holder. It should not set focus if no placeholder found.
.. @+node:ekr.20170402034115.1: *4* #456: replace-all is very slow
Made several changes to find.batchChange.
.. @+node:ekr.20170402035751.1: *4* #458: Chapters drop-down list is not automatically resized
https://github.com/leo-editor/leo-editor/issues/458
Set a Qt flag in tt.createControl.
.. @+node:ekr.20170428063311.1: *4* #466: Moving a node can cause temporary coloring issues
https://github.com/leo-editor/leo-editor/issues/466

- Added LeoHighlighter.force_rehighlight.
- Rewrote 'recolor' command (c.force_recolor).
- Rewrote c.recolor_now.
- Added calls to c.recolor_now to c.moveOutline*.
.. @+node:ekr.20170411072038.1: *4* #471: UnicodeDecodeError in writeRecentFilesFileHelper
UnicodeDecodeError in writeRecentFilesFileHelper
https://github.com/leo-editor/leo-editor/issues/471

The fix was in rf.writeRecentFilesFileHelper.
.. @+node:ekr.20170411072045.1: *4* #472: @clean nodes stopped updating
https://github.com/leo-editor/leo-editor/issues/472

Solved: the checks are made only if @bool check_for_changed_external_files = True

Changed code in efc.on_idle and efc.idle_check_commander.
.. @+node:ekr.20170425070312.1: *4* #476: (error in cacher.fileKey)
https://github.com/leo-editor/leo-editor/issues/476
.. @+node:ekr.20170428144545.1: *4* #487: g.IdleTime docstring
https://github.com/leo-editor/leo-editor/issues/487
.. @+node:ekr.20170528061812.1: *4* Ensure that .leo/.leoRecentFiles.txt is closed
https://github.com/leo-editor/leo-editor/pull/497

Rewrote rf.createRecentFiles, rf.readRecentFilesFile and rf.writeRecentFilesFileHelper.
.. @+node:ekr.20170608072053.84: *4* Ensure that .leo/.leoRecentFiles.txt is closed.
https://github.com/leo-editor/leo-editor/pull/497

Rewrote rf.createRecentFiles, rf.readRecentFilesFile and rf.writeRecentFilesFileHelper.
.. @+node:ekr.20170326054533.1: *4* Fixed bug in k.computeInverseBindingDict
The bug gave way too many bindings for the move-lines commands.
.. @+node:ekr.20170326113032.1: *4* Fixed bug in tab completion
ga.show_tab_list wasn't showing commands without any shortcuts!
.. @+node:ekr.20170406091617.1: *4* Fixed bugs re plugins registration
Fixed plugins.registerOneHandler and plugins.registerOneExclusiveHandler
.. @+node:ekr.20170427164915.1: *4* Fixed html import problem
The unit test "@test xml non-ascii tags" failed on Python 2, but not Python 3.

The fix was in xml_i.scan_tag & helper
.. @+node:ekr.20170406095247.1: *4* Fixed serious bug in c.checkFileTimeStamp
It must return True if g.app.externalFilesController is None.
.. @+node:ekr.20170401132710.1: *4* Fixed several problems with goto-global-line
.. @+node:ekr.20170608072053.88: *4* #498: --session-restore option fails if no leo.session exists
https://github.com/leo-editor/leo-editor/issues/498

With a new installation of Leo there is no leo.session file. It is apparently created only after using the --session-save command line option.

If the --session-restore option is also used before that file is created, then Leo fails to open (splash screen displays, then nothing else happens).
.. @+node:ekr.20170416063625.1: *4* Revised xml/html importers
The new code is simpler and handles dubious html syntax.
.. @+node:ekr.20170329145930.1: *4* The pylint command now warns if pylint has not been installed
The change was to pylint.run_pylint.

This removes a major source of confusion.
.. @+node:ekr.20170617113038.1: *4* #479: Preserve brython indentation...
https://github.com/leo-editor/leo-editor/issues/479
Preserve brython indentation when importing .html files
.. @+node:ekr.20170618015241.1: *4* #481: The python importer optionally puts method decorators in headlines
https://github.com/leo-editor/leo-editor/issues/481
.. @+node:ekr.20170325085907.1: *3* code
.. @+node:ekr.20170325085939.1: *4* Added better checks in v.setBodyString & v.setHeadString
.. @+node:ekr.20170331043509.1: *4* Improved @auto write code
- Removed the allow_at_auto_section switch in leoAtFile.py.

- When writing @auto files << handle line at s[i] >> in at.putBody now expands section references in @auto files *if* they are defined. Otherwise, lines containing undefined section references are written as plain code lines.
.. @+node:ekr.20170331043931.1: *4* Added gen_refs keyword arg to Importer ctor
This makes explicit which importers actually generate section reference. At present, only the javascript importer sets this arg.
.. @+node:ekr.20170403182514.1: *4* Updated docs re #464
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/464

**Warning**: The p.b and p.h setters and p.setDirty() are *very* expensive:

- p.b = s calls c.setBodyString(p, s) which will recolor body text and update the node's icon.
- p.h = s calls c.setHeadString(p, s) which calls p.setDirty().
- p.setDirty() changes the icons of all ancestor @file nodes.

In contrast, the corresponding p.v.b and p.v.b setters and p.v.setDirty() are extremely fast.

Usually, code *should* use the p.b and p.h setters and p.setDirty(), despite their cost, because they update Leo's outline pane properly. Calling c.redraw() is *not* enough.

These performance gotchas become important for repetitive commands, like cff, replace-all and recursive import. In such situations, code should use p.v.b and p.v.h setters instead of p.b and p.h setters.
.. @+node:ekr.20170404032504.1: *4* Added 'recursive' keyword arg to recursive import API
Added 'recursive' keyword arg to c.recursiveImport and RecursiveImportController ctor.
Recursive is *not* the same as not one_file.
.. @+node:ekr.20170406092043.1: *4* Removed atAuto from atFile class
Ding dong, the switch is dead, the wicked old switch is dead.
.. @+node:ekr.20170412055006.1: *4* Added g.Git functions
leoGlobals.py the following functions and their helpers in the .Git subtree:

- branch, commit = g.gitInfo(path = None)
- date, build = g.jsonCommitInfo()
- branch = g.gitBranchName(path = None)
- commit = g.getCommitNumber(path = None)

The path should be a folder containing a .git subfolder. If the path is None, the leo-editor folder is used.

Leo's cacher code will soon use the branch name returned by g.gitInfo() to ensure that switching git branches works properly.

As a happy side effect, these methods completely collapse the complexity of leoVersion.py. 
.. @+node:ekr.20170427171721.1: *4* Added traces to c.doCommand to detect multiple redraws
These traces detected nothing unusual and have been disabled.
.. @+node:ekr.20170608072053.74: *4* Use 'with' statement to simplify code
Improved g.SherlockTracer.do_line, g.gitInfo, g.is_binary_external_file, g.log, g.readFileToUnicodeString.
.. @+node:ekr.20170403190659.1: *3* docs
.. @+node:ekr.20170325090029.1: *3* features
.. @+node:ekr.20170325045838.1: *4* #448: Add abbreviations for commands
https://github.com/leo-editor/leo-editor/issues/448

If the expansion of an abbrevitiation is a command name, that command will be executed. Alas, this isn't very useful: typing destroys selection ranges.

This took only a few lines of code in abbrev.expandAbbrev.
.. @+node:ekr.20170509091900.1: *4* #484: improve menus
https://github.com/leo-editor/leo-editor/issues/484

Added submenus to Windows menu. This significantly simplifies and clarifies the Windows menu.
.. @+node:ekr.20170608071935.1: *4* #488: Created a curses/npyscreen front end for Leo
https://github.com/leo-editor/leo-editor/issues/488
.. @+node:ekr.20170614051052.1: *4* Added "yes/no to all" buttons for externally changed file dialog
Rev 9c94fec36d adds Yes / no to all on external file changes.

If you answer yes to all or no to all Leo remembers that
answer for 3 seconds. As a result, another set of external
changes will show the pop up again.
.. @+node:ekr.20170411191401.1: *4* Added  git branch name to backed-up files
.. @+node:ekr.20170328143013.1: *4* Added --trace-focus command-line argument
.. @+node:ekr.20170411092513.1: *4* Added goto-any-clone command
Searches from c.p for *any* clone, not just a clone of c.p.  Useful for eliminating all clones from a .leo file.

This command is different from goto-next-clone as follows:

- goto-any-clone goes to the next clone, regardless of whether c.p is a clone.
- goto-any-clone does not wrap. It prints a message when no clones remain.
.. @+node:ekr.20170430033223.1: *4* Added log listener commands
@language rest
@wrap

The log-listen (aka listen-to-log) and kill-log-listen (aka, listen-log-kill) commands implement this logging cookbook recipe:
https://docs.python.org/2/howto/logging-cookbook.html#sending-and-receiving-logging-events-across-a-network

The log-listen command creates a logging listener whose output goes to Leo's console. The listener runs in a separate process so that Leo doesn't hang.

Start the listener first, then start another process in another console. All logging output from the second process will be captured and displayed by the listener, provided that the second process includes a call to `rootLogger.addHandler(socketHandler)`.

leo/external/log_broadcast.py contains example code. leo/plugins/cursesGui2.py uses this pattern to broadcast g.trace.



.. @+node:ekr.20170325090032.1: *4* Added show-color-names command
.. @+node:ekr.20170427173032.1: *4* clone-find commands report number of matches in root node
Changed find.createCloneFindAllNodes and c.cloneFindMarkedHelper.
.. @+node:ekr.20170327052423.1: *4* Improved "Write Existing File?" dialog
at.promptForDangerousWrite puts up a dialog with a clearer cancel button.
All tests pass.

- It says "Cancel (No To All)".
- Added cancelMessage keyword arg to x.promptForDangerousWrite.
- Use keyword args in LeoFrame.promptForSave and ns_do_context.
.. @+node:ekr.20170414103904.1: *4* Improved caching
Rev b32259 transitions to a new caching scheme:

1. All hashes now use the full path to the external file.  Previously, the headline of @file nodes was typically used instead. Surely this might have caused silent problems.

2. Leo's hasher now includes the name of the present git branch in the hash. When switching git branches, this in essence disables hashing for all files changed in the previous branch.
.. @+node:ekr.20170326091637.1: *4* Improved indent-region and unindent-region commands
https://groups.google.com/d/msg/leo-editor/SUnqs1_YbeI/DIv0EbtFCgAJ

The indent-region and unindent-region just move the insert point if there is no text selected.
.. @+node:ekr.20170326052408.1: *4* Improved move-lines-up/down commands
These commands (bound to ctrl-up/down by default) now work at the top or bottom of the body pane. The move-lines-up command inserts a new line below the moved line/lines when the lines are at the top of the body text.  Similarly, the move-lines-down command inserts a line before the moved lines when at the bottom of the body text. Imo, this is a natural and useful.
.. @+node:ekr.20170530023214.1: *4* Restored importer;; abbreviation
55b2037ac3a: 2016-11-22 06:33:17 Removed importer;; abbreviation(!!)


Restored the abbreviation from f10fa02b8cb681, the previous commit.
.. @+node:ekr.20170616100339.1: *4* Added tcl importer
.. @+node:ekr.20170618083013.1: *4* Added toggle-auto-edit command
https://github.com/leo-editor/leo-editor/issues/482

This command is surprisingly useful.  It toggles between a flattened view (@edit) and an outline view (@auto) of an external file containing no sentinels.

This command preserves the presently selected line when flattening/un-flattening the outline. You can run this command from any descendant of an @auto node.
.. @+node:ekr.20170618083013.2: *5* efc.toggleAtAutoAtEdit & helpers
@cmd('toggle-at-auto-at-edit')
def toggleAtAutoAtEdit(self, event):
    '''Toggle between @auto and @edit, preserving insert point, etc.'''
    p = self.c.p
    if p.isAtEditNode():
        self.toAtAuto(p)
        return
    for p in p.self_and_parents():
        if p.isAtAutoNode():
            self.toAtEdit(p)
            return
    g.es_print('Not in an @auto or @edit tree.', color='blue')
.. @+node:ekr.20170618083013.3: *6* efc.toAtAuto
def toAtAuto(self, p):
    '''Convert p from @edit to @auto.'''
    c = self.c
    # Change the headline.
    p.h = '@auto' + p.h[5:]
    # Compute the position of the present line within the file.
    w = c.frame.body.wrapper
    ins = w.getInsertPoint()
    row, col = g.convertPythonIndexToRowCol(p.b, ins)
    # Ignore *preceding* directive lines.
    directives = [z for z in g.splitLines(c.p.b)[:row] if g.isDirective(z)]
    row -= len(directives)
    row = max(0, row)
    # Reload the file, creating new nodes.
    c.selectPosition(p, enableRedrawFlag=False)
    c.refreshFromDisk()
    # Restore the line in the proper node.
    c.gotoCommands.find_file_line(row+1)
    p.setDirty()
    c.setChanged()
    c.redraw()
    c.bodyWantsFocus()
.. @+node:ekr.20170618083013.4: *6* efc.toAtEdit
def toAtEdit(self, p):
    '''Convert p from @auto to @edit.'''
    c = self.c
    w = c.frame.body.wrapper
    p.h = '@edit' + p.h[5:]
    # Compute the position of the present line within the *selected* node c.p
    ins = w.getInsertPoint()
    row, col = g.convertPythonIndexToRowCol(c.p.b, ins)
    # Ignore directive lines.
    directives = [z for z in g.splitLines(c.p.b)[:row] if g.isDirective(z)]
    row -= len(directives)
    row = max(0, row)
    # Count preceding lines from p to c.p, again ignoring directives.
    for p2 in p.self_and_subtree():
        if p2 == c.p:
            break
        lines = [z for z in g.splitLines(p2.b) if not g.isDirective(z)]
        row += len(lines)
    # Reload the file into a single node.
    c.selectPosition(p, enableRedrawFlag=False)
    c.refreshFromDisk()
    # Restore the line in the proper node.
    ins = g.convertRowColToPythonIndex(p.b, row+1, 0)
    w.setInsertPoint(ins)
    p.setDirty()
    c.setChanged()
    c.redraw()
    c.bodyWantsFocus()
.. @+node:ekr.20170619155533.1: *4* Improved operation of command history
The first UP-arrow to gives the presvious command, the next up-arrow gives the next command, etc.
.. @+node:ekr.20170403192311.1: *3* plugins
.. @+node:ekr.20170403192317.1: *4* screen_capture.py now enabled by default
.. @+node:ekr.20170331043621.1: *3* settings
.. @+node:ekr.20170328043328.1: *4* Added ctrl-shift < and > bindings
@language rest
@wrap

These are bound to indent/unindent-region and can be used when no text is selected.
.. @+node:ekr.20170427110630.1: *4* Restored default: @bool check_for_changed_external_files = True
.. @+node:ekr.20170330083957.1: *4* Retired @bool allow_section_references_in_at_auto
The disabled setting now contains this comment:

    **Note**: This setting has been retired for the following reasons:
    
    1. The new javascript importer *always* generate section references
    for non-trivial programs. As a result, the legacy value for this
    setting would cause the javascript importer to fail.
    
    2. The new @auto write code writes expands section references if
    they exist. Otherwise, the write code writes the line as is,
    without any complaint. As a result, there should be no problem if
    an imported code contains something that looks like a section
    reference but isn't.
.. @+node:ekr.20170619154105.1: *3* Branch: tree-gen
@language rest
@wrap

Adds c.frame.tree.generation count.
- Update count in v._addLink and v._cutlink.
- Use the count in LeoValues to avoid unnecessary recalcularion.
.. @+node:ekr.20031218072017.3341: *4* class VNode
@nobeautify

class VNodeBase(object):
    << VNode constants >>
    @others

if use_zodb and ZODB:

    class VNode(ZODB.Persistence.Persistent, VNodeBase):
        pass

else:
    VNode = VNodeBase

vnode = VNode # compatibility.

@beautify
.. @+node:ekr.20031218072017.951: *5* << VNode constants >>
# Define the meaning of status bits in new vnodes.
# Archived...
clonedBit = 0x01 # True: VNode has clone mark.
# unused      0x02
expandedBit = 0x04 # True: VNode is expanded.
markedBit = 0x08 # True: VNode is marked
# unused    = 0x10 # (was orphanBit)
selectedBit = 0x20 # True: VNode is current VNode.
topBit = 0x40 # True: VNode was top VNode when saved.
# Not archived...
richTextBit = 0x080 # Determines whether we use <bt> or <btr> tags.
visitedBit = 0x100
dirtyBit = 0x200
writeBit = 0x400
orphanBit = 0x800 # True: error in @<file> tree prevented it from being written.
.. @+node:ekr.20031218072017.3342: *5* v.Birth & death
.. @+node:ekr.20031218072017.3344: *6* v.__init
def __init__(self, context, gnx=None):
    '''
    Ctor for the VNode class.
    To support ZODB, the code must set v._p_changed = 1 whenever
    v.unknownAttributes or any mutable VNode object changes.
    '''
    # The primary data: headline and body text.
    self._headString = g.u('newHeadline')
    self._bodyString = g.u('')
    # Structure data...
    self.children = []
        # Ordered list of all children of this node.
    self.parents = []
        # Unordered list of all parents of this node.
    # Other essential data...
    self.fileIndex = None
        # The immutable fileIndex (gnx) for this node. Set below.
    self.iconVal = 0
        # The present value of the node's icon.
    self.statusBits = 0
        # status bits
    # Information that is never written to any file...
    self.context = context # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.expandedPositions = []
        # Positions that should be expanded.
    self.insertSpot = None
        # Location of previous insert point.
    self.scrollBarSpot = None
        # Previous value of scrollbar position.
    self.selectionLength = 0
        # The length of the selected body text.
    self.selectionStart = 0
        # The start of the selected body text.
    # To make VNode's independent of Leo's core,
    # wrap all calls to the VNode ctor::
    #
    #   def allocate_vnode(c,gnx):
    #       v = VNode(c)
    #       g.app.nodeIndices.new_vnode_helper(c,gnx,v)
    g.app.nodeIndices.new_vnode_helper(context, gnx, self)
    assert self.fileIndex, g.callers()
.. @+node:ekr.20031218072017.3345: *6* v.__repr__ & v.__str__
def __repr__(self):
    return "<VNode %7x %s>" % (id(self), self.cleanHeadString())

__str__ = __repr__
.. @+node:ekr.20040312145256: *6* v.dump
def dumpLink(self, link):
    return link if link else "<none>"

def dump(self, label=""):
    v = self
    print('%s %s %s' % ('-' * 10, label, v))
    print('len(parents) %s' % len(v.parents))
    print('len(children) %s' % len(v.children))
    print('parents %s' % g.listToString(v.parents))
    print('children%s' % g.listToString(v.children))
.. @+node:ekr.20060910100316: *6* v.__hash__ (only for zodb)
if use_zodb and ZODB:

    def __hash__(self):
        return self.__hash__()
.. @+node:ekr.20031218072017.3346: *5* v.Comparisons
.. @+node:ekr.20040705201018: *6* v.findAtFileName
def findAtFileName(self, names, h=''):
    '''Return the name following one of the names in nameList or ""'''
    # Allow h argument for unit testing.
    if not h: h = self.headString()
    # if h.startswith('@auto-test'): g.trace(h,'@auto-test' in names)
    if not g.match(h, 0, '@'):
        return ""
    i = g.skip_id(h, 1, '-')
    word = h[: i]
    if word in names and g.match_word(h, 0, word):
        name = h[i:].strip()
        # g.trace(repr(word),repr(name))
        return name
    else:
        return ""
.. @+node:ekr.20031218072017.3350: *6* v.anyAtFileNodeName
def anyAtFileNodeName(self):
    """Return the file name following an @file node or an empty string."""
    return (
        self.findAtFileName(g.app.atAutoNames) or
        self.findAtFileName(g.app.atFileNames))
.. @+node:ekr.20031218072017.3348: *6* v.at...FileNodeName
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atAutoNodeName(self, h=None):
    return self.findAtFileName(g.app.atAutoNames, h=h)
# Retain this special case as part of the "escape hatch".
# That is, we fall back on code in leoRst.py if no
# importer or writer for reStructuredText exists.

def atAutoRstNodeName(self, h=None):
    names = ("@auto-rst",)
    return self.findAtFileName(names, h=h)

def atCleanNodeName(self):
    names = ("@clean",)
    return self.findAtFileName(names)

def atEditNodeName(self):
    names = ("@edit",)
    return self.findAtFileName(names)

def atFileNodeName(self):
    names = ("@file", "@thin")
        # Fix #403.
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName(self):
    names = ("@nosent", "@file-nosent",)
    return self.findAtFileName(names)

def atRstFileNodeName(self):
    names = ("@rst",)
    return self.findAtFileName(names)

def atShadowFileNodeName(self):
    names = ("@shadow",)
    return self.findAtFileName(names)

def atSilentFileNodeName(self):
    names = ("@asis", "@file-asis",)
    return self.findAtFileName(names)

def atThinFileNodeName(self):
    names = ("@thin", "@file-thin",)
    return self.findAtFileName(names)
# New names, less confusing

atNoSentFileNodeName = atNoSentinelsFileNodeName
atAsisFileNodeName = atSilentFileNodeName
.. @+node:EKR.20040430152000: *6* v.isAtAllNode
def isAtAllNode(self):
    """Returns True if the receiver contains @others in its body at the start of a line."""
    flag, i = g.is_special(self._bodyString, 0, "@all")
    return flag
.. @+node:ekr.20040326031436: *6* v.isAnyAtFileNode
def isAnyAtFileNode(self):
    """Return True if v is any kind of @file or related node."""
    # This routine should be as fast as possible.
    # It is called once for every VNode when writing a file.
    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()
.. @+node:ekr.20040325073709: *6* v.isAt...FileNode
def isAtAutoNode(self):
    return bool(self.atAutoNodeName())

def isAtAutoRstNode(self):
    return bool(self.atAutoRstNodeName())

def isAtCleanNode(self):
    return bool(self.atCleanNodeName())

def isAtEditNode(self):
    return bool(self.atEditNodeName())

def isAtFileNode(self):
    return bool(self.atFileNodeName())

def isAtRstFileNode(self):
    return bool(self.atRstFileNodeName())

def isAtNoSentinelsFileNode(self):
    return bool(self.atNoSentinelsFileNodeName())

def isAtSilentFileNode(self): # @file-asis
    return bool(self.atSilentFileNodeName())

def isAtShadowFileNode(self):
    return bool(self.atShadowFileNodeName())

def isAtThinFileNode(self):
    return bool(self.atThinFileNodeName())
# New names, less confusing:

isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtAsisFileNode = isAtSilentFileNode
.. @+node:ekr.20031218072017.3351: *6* v.isAtIgnoreNode
def isAtIgnoreNode(self):
    """Returns True if the receiver contains @ignore in its body at the start of a line.

    or if the headline starts with @ignore."""
    # v = self
    # 2011/10/08: honor @ignore in headlines.  Sheesh.
    if g.match_word(self._headString, 0, '@ignore'):
        return True
    else:
        flag, i = g.is_special(self._bodyString, 0, "@ignore")
        return flag
.. @+node:ekr.20031218072017.3352: *6* v.isAtOthersNode
def isAtOthersNode(self):
    """Returns True if the receiver contains @others in its body at the start of a line."""
    flag, i = g.is_special(self._bodyString, 0, "@others")
    return flag
.. @+node:ekr.20031218072017.3353: *6* v.matchHeadline
def matchHeadline(self, pattern):
    """Returns True if the headline matches the pattern ignoring whitespace and case.

    The headline may contain characters following the successfully matched pattern."""
    v = self
    h = g.toUnicode(v.headString())
    h = h.lower().replace(' ', '').replace('\t', '')
    h = h.lstrip('.') # 2013/04/05. Allow leading period before section names.
    pattern = g.toUnicode(pattern)
    pattern = pattern.lower().replace(' ', '').replace('\t', '')
    return h.startswith(pattern)
.. @+node:ekr.20160502100151.1: *5* v.copyTree
def copyTree(self, copyMarked=False):
    '''
    Return an all-new tree of vnodes that are copies of self and all its
    descendants.

    **Important**: the v.parents ivar must be [] for all nodes.
    v._addParentLinks will set all parents.
    '''
    v = self
    # Allocate a new vnode and gnx with empty children & parents.
    v2 = VNode(context=v.context, gnx=None)
    assert v2.parents == [], v2.parents
    assert v2.gnx
    assert v.gnx != v2.gnx
    # Copy vnode fields. Do **not** set v2.parents.
    v2._headString = g.toUnicode(v._headString, reportErrors=True) # 2017/01/24
    v2._bodyString = g.toUnicode(v._bodyString, reportErrors=True) # 2017/01/24
    v2.u = copy.deepcopy(v.u)
    if copyMarked and v.isMarked():
        v2.setMarked()
    # Recursively copy all descendant vnodes.
    for child in v.children:
        v2.children.append(child.copyTree(copyMarked))
    return v2
.. @+node:ekr.20031218072017.3359: *5* v.Getters
.. @+node:ekr.20031218072017.3378: *6* v.bodyString
body_unicode_warning = False

def bodyString(self):
    # This message should never be printed and we want to avoid crashing here!
    if g.isUnicode(self._bodyString):
        return self._bodyString
    else:
        if not self.body_unicode_warning:
            self.body_unicode_warning = True
            g.internalError('not unicode:', repr(self._bodyString))
        return g.toUnicode(self._bodyString)

getBody = bodyString
    # Deprecated, but here for compatibility.
.. @+node:ekr.20031218072017.3360: *6* v.Children
.. @+node:ekr.20031218072017.3362: *7* v.firstChild
def firstChild(self):
    v = self
    return v.children and v.children[0]
.. @+node:ekr.20040307085922: *7* v.hasChildren & hasFirstChild
def hasChildren(self):
    v = self
    return len(v.children) > 0

hasFirstChild = hasChildren
.. @+node:ekr.20031218072017.3364: *7* v.lastChild
def lastChild(self):
    v = self
    return v.children[-1] if v.children else None
.. @+node:ekr.20031218072017.3365: *7* v.nthChild
# childIndex and nthChild are zero-based.

def nthChild(self, n):
    v = self
    if 0 <= n < len(v.children):
        return v.children[n]
    else:
        return None
.. @+node:ekr.20031218072017.3366: *7* v.numberOfChildren
def numberOfChildren(self):
    v = self
    return len(v.children)
.. @+node:ekr.20040323100443: *6* v.directParents
def directParents(self):
    """(New in 4.2) Return a list of all direct parent vnodes of a VNode.

    This is NOT the same as the list of ancestors of the VNode."""
    v = self
    return v.parents
.. @+node:ekr.20080429053831.6: *6* v.hasBody
def hasBody(self):
    '''Return True if this VNode contains body text.'''
    s = self._bodyString
    return s and len(s) > 0
.. @+node:ekr.20031218072017.1581: *6* v.headString & v.cleanHeadString
head_unicode_warning = False

def headString(self):
    """Return the headline string."""
    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self._headString):
        if not self.head_unicode_warning:
            self.head_unicode_warning = True
            g.internalError('not unicode', repr(self._headString))
    # Make _sure_ we return a unicode string.
    return g.toUnicode(self._headString)

def cleanHeadString(self):
    s = self._headString
    if g.isPython3:
        return s
    else:
        return g.toEncodedString(s, "ascii") # Replaces non-ascii characters by '?'
.. @+node:ekr.20131223064351.16351: *6* v.isNthChildOf
def isNthChildOf(self, n, parent_v):
    '''Return True if v is the n'th child of parent_v.'''
    v = self
    children = parent_v and parent_v.children
    return children and 0 <= n < len(children) and children[n] == v
.. @+node:ekr.20031218072017.3367: *6* v.Status Bits
.. @+node:ekr.20031218072017.3368: *7* v.isCloned
def isCloned(self):
    return len(self.parents) > 1
.. @+node:ekr.20031218072017.3369: *7* v.isDirty
def isDirty(self):
    return (self.statusBits & self.dirtyBit) != 0
.. @+node:ekr.20031218072017.3371: *7* v.isMarked
def isMarked(self):
    return (self.statusBits & VNode.markedBit) != 0
.. @+node:ekr.20031218072017.3372: *7* v.isOrphan
def isOrphan(self):
    return (self.statusBits & VNode.orphanBit) != 0
.. @+node:ekr.20031218072017.3373: *7* v.isSelected
def isSelected(self):
    return (self.statusBits & VNode.selectedBit) != 0
.. @+node:ekr.20031218072017.3374: *7* v.isTopBitSet
def isTopBitSet(self):
    return (self.statusBits & self.topBit) != 0
.. @+node:ekr.20031218072017.3376: *7* v.isVisited
def isVisited(self):
    return (self.statusBits & VNode.visitedBit) != 0
.. @+node:ekr.20080429053831.10: *7* v.isWriteBit
def isWriteBit(self):
    v = self
    return (v.statusBits & v.writeBit) != 0
.. @+node:ekr.20031218072017.3377: *7* v.status
def status(self):
    return self.statusBits
.. @+node:ekr.20031218072017.3384: *5* v.Setters
.. @+node:ekr.20090830051712.6151: *6*  v.Dirty bits
.. @+node:ekr.20031218072017.3390: *7* v.clearDirty
def clearDirty(self):
    '''Clear the vnode dirty bit.'''
    v = self
    # g.trace(v.h,g.callers())
    v.statusBits &= ~v.dirtyBit
.. @+node:ekr.20090830051712.6153: *7* v.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):
    trace = False and not g.unitTesting
    v = self; c = v.context
    # Set the starting nodes.
    nodes = []
    newNodes = [v]
    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.parents:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
        newNodes = addedNodes[:]
    # Remove the hidden VNode.
    if c.hiddenRootNode in nodes:
        if trace: g.trace('removing hidden root', c.hiddenRootNode)
        nodes.remove(c.hiddenRootNode)
    if trace: g.trace(nodes)
    return nodes
.. @+node:ekr.20090830051712.6157: *7* v.setAllAncestorAtFileNodesDirty
# Unlike p.setAllAncestorAtFileNodesDirty,
# there is no setDescendentsDirty arg.

def setAllAncestorAtFileNodesDirty(self):
    trace = False and not g.unitTesting
    verbose = False
    v = self
    dirtyVnodeList = []
    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = v.findAllPotentiallyDirtyNodes()
    if trace and verbose:
        for v in nodes:
            print(v.isDirty(), v.isAnyAtFileNode(), v)
    dirtyVnodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]
    for v in dirtyVnodeList:
        v.setDirty() # Do not call p.setDirty here!
    if trace: g.trace(dirtyVnodeList)
    return dirtyVnodeList
.. @+node:ekr.20080429053831.12: *7* v.setDirty
def setDirty(self):
    '''Set the vnode dirty bit.'''
    # if self.h.startswith('@auto'):
    # g.trace('(v) %5s %30s' % (self.isDirty(),self.h),g.callers())
    self.statusBits |= self.dirtyBit
.. @+node:ekr.20031218072017.3386: *6*  v.Status bits
.. @+node:ekr.20031218072017.3389: *7* v.clearClonedBit
def clearClonedBit(self):
    self.statusBits &= ~self.clonedBit
.. @+node:ekr.20031218072017.3391: *7* v.clearMarked
def clearMarked(self):
    self.statusBits &= ~self.markedBit
.. @+node:ekr.20080429053831.8: *7* v.clearWriteBit
def clearWriteBit(self):
    self.statusBits &= ~self.writeBit
.. @+node:ekr.20031218072017.3392: *7* v.clearOrphan
def clearOrphan(self):
    # if self.h.startswith('@file'): g.trace(self.h,g.callers())
    self.statusBits &= ~self.orphanBit
.. @+node:ekr.20031218072017.3393: *7* v.clearVisited
def clearVisited(self):
    self.statusBits &= ~self.visitedBit
.. @+node:ekr.20031218072017.3395: *7* v.contract/expand/initExpandedBit/isExpanded
def contract(self):
    '''Contract the node.'''
    self.statusBits &= ~self.expandedBit

def expand(self):
    '''Expand the node.'''
    self.statusBits |= self.expandedBit

def initExpandedBit(self):
    '''Init self.statusBits.'''
    self.statusBits |= self.expandedBit

def isExpanded(self):
    '''Return True if the VNode expansion bit is set.'''
    return (self.statusBits & self.expandedBit) != 0
.. @+node:ekr.20031218072017.3396: *7* v.initStatus
def initStatus(self, status):
    self.statusBits = status
.. @+node:ekr.20031218072017.3397: *7* v.setClonedBit & initClonedBit
def setClonedBit(self):
    self.statusBits |= self.clonedBit

def initClonedBit(self, val):
    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &= ~self.clonedBit
.. @+node:ekr.20031218072017.3398: *7* v.setMarked & initMarkedBit
def setMarked(self):
    self.statusBits |= self.markedBit

def initMarkedBit(self):
    self.statusBits |= self.markedBit
.. @+node:ekr.20031218072017.3399: *7* v.setOrphan
def setOrphan(self):
    '''Set the vnode's orphan bit.'''
    trace = (False or g.app.debug) and not g.unitTesting
    if trace and self.h.startswith('@file'):
        g.trace(self.h, g.callers())
    self.statusBits |= self.orphanBit
.. @+node:ekr.20031218072017.3400: *7* v.setSelected
# This only sets the selected bit.

def setSelected(self):
    self.statusBits |= self.selectedBit
.. @+node:ekr.20031218072017.3401: *7* v.setVisited
# Compatibility routine for scripts

def setVisited(self):
    self.statusBits |= self.visitedBit
.. @+node:ekr.20080429053831.9: *7* v.setWriteBit
def setWriteBit(self):
    self.statusBits |= self.writeBit
.. @+node:ekr.20031218072017.3385: *6* v.computeIcon & setIcon
def computeIcon(self):
    val = 0; v = self
    if v.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val

def setIcon(self):
    pass # Compatibility routine for old scripts
.. @+node:ekr.20100303074003.5636: *6* v.restoreCursorAndScroll
# Called only by LeoTree.selectHelper.

def restoreCursorAndScroll(self):
    '''Restore the cursor position and scroll so it is visible.'''
    trace = (False or g.trace_scroll) and not g.unitTesting
    traceTime = False and not g.unitTesting
    v = self
    ins = v.insertSpot
    # start, n = v.selectionStart, v.selectionLength
    spot = v.scrollBarSpot
    body = self.context.frame.body
    w = body.wrapper
    # Fix bug 981849: incorrect body content shown.
    if ins is None: ins = 0
    # This is very expensive for large text.
    if traceTime: t1 = time.time()
    if hasattr(body.wrapper, 'setInsertPoint'):
        if trace and ins: g.trace('ins', ins, 'spot', spot)
        w.setInsertPoint(ins)
    if traceTime:
        delta_t = time.time() - t1
        if delta_t > 0.1: g.trace('%2.3f sec' % (delta_t))
    # Override any changes to the scrollbar setting that might
    # have been done above by w.setSelectionRange or w.setInsertPoint.
    if spot is not None:
        w.setYScrollPosition(spot)
        v.scrollBarSpot = spot
    # Never call w.see here.
.. @+node:ekr.20100303074003.5638: *6* v.saveCursorAndScroll
def saveCursorAndScroll(self):
    trace = (False or g.trace_scroll) and not g.unitTesting
    v = self; c = v.context
    w = c.frame.body
    if not w: return
    try:
        v.scrollBarSpot = w.getYScrollPosition()
        v.insertSpot = w.getInsertPoint()
        if trace: g.trace(v.scrollBarSpot, v.insertSpot)
    except AttributeError:
        # 2011/03/21: w may not support the high-level interface.
        pass
.. @+node:ekr.20040315032144: *6* v.setBodyString & v.setHeadString
unicode_warning_given = False

def setBodyString(self, s):
    v = self
    if g.isUnicode(s):
        v._bodyString = s
    else:
        try:
            v._bodyString = g.toUnicode(s, reportErrors=True)
        except Exception:
            if not self.unicode_warning_given:
                self.unicode_warning_given = True
                g.internalError(s)
                g.es_exception()

def setHeadString(self, s):
    # Fix bug: https://bugs.launchpad.net/leo-editor/+bug/1245535
    # API allows headlines to contain newlines.
    v = self
    if g.isUnicode(s):
        v._headString = s.replace('\n','')
    else:
        try:
            s = g.toUnicode(s, reportErrors=True)
            v._headString = s.replace('\n','')
        except Exception:
            if not self.unicode_warning_given:
                self.unicode_warning_given = True
                g.internalError(s)
                g.es_exception()

initBodyString = setBodyString
initHeadString = setHeadString
setHeadText = setHeadString
setTnodeText = setBodyString
.. @+node:ekr.20031218072017.3402: *6* v.setSelection
def setSelection(self, start, length):
    v = self
    v.selectionStart = start
    v.selectionLength = length
.. @+node:ville.20120502221057.7498: *6* v.contentModified
def contentModified(self):
    g.contentModifiedSet.add(self)
.. @+node:ville.20120502221057.7499: *6* v.childrenModified
def childrenModified(self):
    g.childrenModifiedSet.add(self)
.. @+node:ekr.20130524063409.10700: *5* v.Inserting & cloning
def cloneAsNthChild(self, parent_v, n):
    # Does not check for illegal clones!
    v = self
    v._linkAsNthChild(parent_v, n)
    return v

def insertAsFirstChild(self):
    v = self
    return v.insertAsNthChild(0)

def insertAsLastChild(self):
    v = self
    return v.insertAsNthChild(len(v.children))

def insertAsNthChild(self, n):
    v = self
    assert 0 <= n <= len(v.children)
    v2 = VNode(v.context)
    v2._linkAsNthChild(v, n)
    assert v.children[n] == v2
    return v2
.. @+node:ekr.20080427062528.9: *5* v.Low level methods
.. @+node:ekr.20090706110836.6135: *6* v._addLink & helper
def _addLink(self, childIndex, parent_v, adjust=True):
    '''Adjust links after adding a link to v.'''
    trace = False and not g.unitTesting
    v = self
    # g.trace(v.context.frame.tree)
    v.context.frame.tree.generation += 1
    parent_v.childrenModified()
    # Update parent_v.children & v.parents.
    parent_v.children.insert(childIndex, v)
    v.parents.append(parent_v)
    if trace:
        g.trace('*** added parent', parent_v, 'to', v,
                'len(parents)', len(v.parents))
    # Set zodb changed flags.
    v._p_changed = 1
    parent_v._p_changed = 1
    # If v has only one parent, we adjust all
    # the parents links in the descendant tree.
    # This handles clones properly when undoing a delete.
    if adjust:
        if len(v.parents) == 1:
            for child in v.children:
                child._addParentLinks(parent=v)
.. @+node:ekr.20090804184658.6129: *7* v._addParentLinks
def _addParentLinks(self, parent):
    trace = False and not g.unitTesting
    v = self
    v.parents.append(parent)
    if trace:
        g.trace('v', v.h, 'parent', parent.h, g.callers())
        # '*** added parent', parent, 'to', v, 'len(parents)', len(v.parents))
    if len(v.parents) == 1:
        for child in v.children:
            child._addParentLinks(parent=v)
.. @+node:ekr.20090804184658.6128: *6* v._cutLink
def _cutLink(self, childIndex, parent_v):
    '''Adjust links after cutting a link to v.'''
    v = self
    v.context.frame.tree.generation += 1
    parent_v.childrenModified()
    assert parent_v.children[childIndex] == v
    del parent_v.children[childIndex]
    if parent_v in v.parents:
        v.parents.remove(parent_v)
    v._p_changed = 1
    parent_v._p_changed = 1
    # If v has no more parents, we adjust all
    # the parent links in the descendant tree.
    # This handles clones properly when deleting a tree.
    if not v.parents:
        for child in v.children:
            child._cutParentLinks(parent=v)
.. @+node:ekr.20090804190529.6133: *7* v._cutParentLinks
def _cutParentLinks(self, parent):
    trace = False and not g.unitTesting
    v = self
    if trace: g.trace('parent', parent, 'v', v)
    v.parents.remove(parent)
    if not v.parents:
        for child in v.children:
            child._cutParentLinks(parent=v)
.. @+node:ekr.20031218072017.3425: *6* v._linkAsNthChild (used by 4.x read logic)
def _linkAsNthChild(self, parent_v, n):
    """Links self as the n'th child of VNode pv"""
    v = self # The child node.
    v._addLink(n, parent_v)
.. @+node:ekr.20090130065000.1: *5* v.Properties
.. @+node:ekr.20090130114732.5: *6* v.b Property
def __get_b(self):
    v = self
    return v.bodyString()

def __set_b(self, val):
    v = self
    v.setBodyString(val)

b = property(
    __get_b, __set_b,
    doc="VNode body string property")
.. @+node:ekr.20090130125002.1: *6* v.h property
def __get_h(self):
    v = self
    return v.headString()

def __set_h(self, val):
    v = self
    v.setHeadString(val)

h = property(
    __get_h, __set_h,
    doc="VNode headline string property")
.. @+node:ekr.20090130114732.6: *6* v.u Property
def __get_u(self):
    v = self
    # Wrong: return getattr(v, 'unknownAttributes', {})
    # It is does not set v.unknownAttributes, which can cause problems.
    if not hasattr(v, 'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self, val):
    v = self
    if val is None:
        if hasattr(v, 'unknownAttributes'):
            delattr(v, 'unknownAttributes')
    elif isinstance(val, dict):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc="VNode u property")
.. @+node:ekr.20090215165030.1: *6* v.gnx Property
def __get_gnx(self):
    v = self
    return v.fileIndex

gnx = property(
    __get_gnx, # __set_gnx,
    doc="VNode gnx property")
.. @+node:ekr.20170619165453.1: *3* Branch: string-gui
Attempt to run all unit tests without using Qt gui code.
All gui-related code will be simulated with the StringTextWrapper class.
.. @+node:ekr.20041005105605.71: ** at.Reading (4.x)
.. @+node:ekr.20041005105605.73: *3* at.findChild4 (legacy only)
def findChild4(self, headline):
    """
    Return the next VNode in at.root.tnodeList.
    Called only for **legacy** @file nodes.

    tnodeLists are used *only* when reading @file (not @thin) nodes.
    tnodeLists compensate for not having gnx's in derived files!
    """
    trace = True and not g.unitTesting
    at = self; v = at.root.v
    if trace: g.trace('legacy file', headline)
    # if not g.unitTesting:
        # if headline.startswith('@file'):
            # g.es_print('Warning: @file logic',headline)
    if trace: g.trace('%s %s %s' % (
        at.tnodeListIndex,
        v.tnodeList[at.tnodeListIndex], headline))
    if not hasattr(v, "tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ", v, g.callers())
        return None
    if at.tnodeListIndex >= len(v.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (
            at.tnodeListIndex, repr(v)))
        g.trace("bad tnodeList index",
            at.tnodeListIndex, len(v.tnodeList), v)
        return None
    v = v.tnodeList[at.tnodeListIndex]
    assert(v)
    at.tnodeListIndex += 1
    # Don't check the headline.  It simply causes problems.
    v.setVisited() # Supress warning/deletion of unvisited nodes.
    return v
.. @+node:ekr.20130911110233.11284: *3* at.readFileToUnicode & helpers
def readFileToUnicode(self, fn):
    '''
    Carefully sets at.encoding, then uses at.encoding to convert the file
    to a unicode string. Calls at.initReadLine if all went well.

    Sets at.encoding as follows:
    1. Use the BOM, if present. This unambiguously determines the encoding.
    2. Use the -encoding= field in the @+leo header, if present and valid.
    3. Otherwise, uses existing value of at.encoding, which comes from:
        A. An @encoding directive, found by at.scanAllDirectives.
        B. The value of c.config.default_derived_file_encoding.

    Returns the string, or None on failure.

    This method is now part of the main @file read code.
    at.openFileForReading calls this method to read all @file nodes.
    Previously only at.scanHeaderForThin (import code) called this method.
    '''
    at = self
    # g.trace('=====', at.errors)
    s = at.openFileHelper(fn)
    if s is not None:
        e, s = g.stripBOM(s)
        if e:
            # The BOM determines the encoding unambiguously.
            s = g.toUnicode(s, encoding=e)
        else:
            # Get the encoding from the header, or the default encoding.
            s_temp = g.toUnicode(s, 'ascii', reportErrors=False)
            e = at.getEncodingFromHeader(fn, s_temp)
            # g.trace(e,g.shortFileName(fn))
            s = g.toUnicode(s, encoding=e)
        s = s.replace('\r\n', '\n')
        at.encoding = e
        at.initReadLine(s)
    return s
.. @+node:ekr.20130911110233.11285: *4* at.openFileHelper
def openFileHelper(self, fn):
    '''Open a file, reporting all exceptions.'''
    at = self
    s = None
    try:
        f = open(fn, 'rb')
        s = f.read()
        f.close()
    except IOError:
        at.error('can not open %s' % (fn))
    except Exception:
        at.error('Exception reading %s' % (fn))
        g.es_exception()
    return s
.. @+node:ekr.20130911110233.11287: *4* at.getEncodingFromHeader
def getEncodingFromHeader(self, fn, s):
    '''
    Return the encoding given in the @+leo sentinel, if the sentinel is
    present, or the previous value of at.encoding otherwise.
    '''
    at = self
    if at.errors:
        g.trace('can not happen: at.errors > 0')
        e = at.encoding
        if g.unitTesting: assert False, g.callers()
            # This can happen when the showTree command in a unit test is left on.
            # A @file/@clean node is created which refers to a non-existent file.
            # It's surprisingly difficult to set at.error=0 safely elsewhere.
            # Otoh, I'm not sure why this test here is ever really useful.
    else:
        at.initReadLine(s)
        old_encoding = at.encoding
        assert old_encoding
        at.encoding = None
        # Execute scanHeader merely to set at.encoding.
        at.scanHeader(fn, giveErrors=False)
        e = at.encoding or old_encoding
    assert e
    return e
.. @+node:ekr.20050301105854: *3* at.readPostPass & helpers
def readPostPass(self, root, thinFile):
    '''Post-process all vnodes.'''
    at = self
    seen = {}
    for p in root.self_and_subtree():
        v = p.v
        if v.gnx not in seen:
            old_body = p.bodyString()
            seen[v.gnx] = v
            at.terminateNode(postPass=True, v=v)
            if new_read:
                # at.terminateNode has done all the work.
                if hasattr(v, 'tempBodyList'):
                    delattr(v, 'tempBodyList')
                if hasattr(v, 'tempRoots'):
                    delattr(v, 'tempRoots')
            else:
                new_body = p.bodyString()
                if hasattr(v, 'tempBodyList'):
                    delattr(v, 'tempBodyList')
                if new_body != old_body:
                    at.handleChangedNode(new_body, old_body, p, thinFile)
                
.. @+node:ekr.20150309154506.27: *4* at.handleChangedNode
def handleChangedNode(self, new_body, old_body, p, thinFile):
    '''Set ancestor files dirty and support mod_labels plugin.'''
    trace = False and not g.unitTesting
    c = self.c
    if thinFile: # Expected.
        if trace: g.trace('****', p.h)
        p.v.setBodyString(new_body)
        if p.v.isDirty():
            p.setAllAncestorAtFileNodesDirty()
    else:
        c.setBodyString(p, new_body) # Sets c and p dirty.
    if p.v.isDirty():
        # New in Leo 4.3: support for mod_labels plugin:
        try:
            c.mod_label_controller.add_label(p, "before change:", old_body)
        except Exception:
            pass
        # This warning is given elsewhere.
        # g.warning("changed:",p.h)
.. @+node:ekr.20100628072537.5814: *4* at.terminateNode & helpers
def terminateNode(self, middle=False, postPass=True, v=None):
    '''
    Set the body text of at.v, and issue warning if it has changed.

    This is called as follows:

    old sentinels: when handling a @-node sentinel.
    new sentinels: from the post-pass when v.tempBodyList exists.
    '''
    at = self
    trace = False and at.readVersion5 and not g.unitTesting
    if not v: v = at.v
    # Compute the new text.
    if at.readVersion5:
        s = ''.join(v.tempBodyList) if hasattr(v, 'tempBodyList') else ''
    else:
        s = ''.join(at.out)
    s = g.toUnicode(s)
    if trace: g.trace('%28s %s' % (v.h, repr(s)))
    if at.importing:
        v._bodyString = s # Allowed use of _bodyString.
    elif middle:
        pass # Middle sentinels never alter text.
    else:
        at.terminateBody(v, postPass)
    # Delete tempBodyList. Do not leave this lying around!
    if hasattr(v, 'tempBodyList'): delattr(v, 'tempBodyList')
.. @+node:ekr.20100628124907.5816: *5* at.indicateNodeChanged
def indicateNodeChanged(self, old, new, postPass, v):
    '''
    Add an entry to c.nodeConflictList.
    Called only from at.terminateBody.
    '''
    at, c = self, self.c
    debug = False # Debug perfect import.
    if at.perfectImportRoot:
        if not postPass:
            at.correctedLines += 1
            if debug:
                at.reportCorrection(old, new, v)
            v.setDirty()
                # Just mark the vnode dirty.
                # Ancestors will be marked dirty later.
            c.setChanged(True)
    else:
        # Do nothing if only trailing whitespace is involved.
        if new.endswith('\n') and old == new[: -1]: return
        if old.endswith('\n') and new == old[: -1]: return
        g.trace('root', at.root.h)
        c.nodeConflictList.append(g.bunch(
            tag='(uncached)',
            gnx=v.gnx,
            fileName=at.root.h,
            b_old=old,
            b_new=new,
            h_old=v._headString,
            h_new=v._headString,
            root_v = at.root and at.root.v,
        ))
        v.setDirty()
            # Just set the dirty bit. Ancestors will be marked dirty later.
        c.changed = True
            # Important: the dirty bits won't stick unless we set c.changed here.
            # Do *not* call c.setChanged(True) here: that would be too slow.
.. @+node:ekr.20100628124907.5818: *5* at.reportCorrection
def reportCorrection(self, old, new, v):
    '''Debugging only. Report changed perfect import lines.'''
    at = self
    found = any([p.v == v for p in at.perfectImportRoot.self_and_subtree()])
    if found:
        g.pr('\n', '-' * 40)
        g.pr("old", len(old))
        for line in g.splitLines(old):
            line = line.replace(' ', '< >').replace('\t', '<TAB>').replace('\n', '<NL>')
            g.pr(repr(str(line)))
        g.pr('\n', '-' * 40)
        g.pr("new", len(new))
        for line in g.splitLines(new):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            g.pr(repr(str(line)))
        g.pr('\n', '-' * 40)
    else:
        # This should never happen.
        g.error("correcting hidden node: v=", repr(v))
.. @+node:ekr.20100702062857.5824: *5* at.terminateBody (detects changes)
def terminateBody(self, v, postPass=False):
    '''Terminate scanning of body text for node v. Set v.b.'''
    trace = False and not g.unitTesting
    at = self
    if at.readVersion5:
        new = ''.join(v.tempBodyList) if hasattr(v, 'tempBodyList') else ''
    else:
        new = ''.join(at.out)
    new = g.toUnicode(new)
    if new_read:
        # *Do* allow changes to the root node.
        if hasattr(v, 'tempRoots'):
            g.trace('=====', list(v.tempRoots))
            old = v.bodyString()
            at.indicateNodeChanged(old, new, postPass, v)
        else:
            # No other @file node has set this node.
            # Just replace the body string
            v.tempRoots = set()
            v.setBodyString(new)
        v.tempRoots.add(self.root)
    else:
        old = v.bodyString()
        # Warn if the body text has changed. Don't warn about the root node.
        if v != at.root.v and at.bodyIsInited(v) and new != old:
            at.indicateNodeChanged(old, new, postPass, v)
        v.setBodyString(new)
    at.bodySetInited(v)
        # Note: the sax code also sets this, so we can't use
        # this "bit" in place of v.tempRoots.
    if trace:
        g.trace('%25s old %3s new %3s' % (v.gnx, len(old), len(new)), v.h)
.. @+node:ekr.20041005105605.74: *3* at.scanText4 & allies
def scanText4(self, fileName, p, verbose=False):
    """Scan a 4.x derived file non-recursively."""
    at = self
    trace = False and not g.unitTesting
    verbose = True
    at.initScanText4(p)
    if trace:
        print('')
        g.trace('filename:', fileName)
    try:
        while at.errors == 0 and not at.done:
            s = at.readLine()
            if trace and verbose: g.trace(repr(s))
            at.lineNumber += 1
            if not s:
                # An error.  We expect readEndLeo to set at.done.
                break
            kind = at.sentinelKind4(s)
            if kind == at.noSentinel:
                i = 0
            else:
                i = at.skipSentinelStart4(s, 0)
            func = at.dispatch_dict[kind]
            if trace: g.trace('%15s %16s %s' % (
                at.sentinelName(kind), func.__name__, repr(s)))
            func(s, i)
    except AssertionError:
        junk, message, junk = sys.exc_info()
        at.error('scanText4: unexpected assertion failure in',
            'fromString' if at.fromString else fileName,
            '\n', message)
        g.trace(g.callers(5))
        raise
    except Exception:
        # Work around bug https://bugs.launchpad.net/leo-editor/+bug/1074812
        # Crashes in the scanning logic may arise from corrupted external files.
        at.error('The input file appears to be corrupted.')
        g.es_exception()
    if at.errors == 0 and not at.done:
        assert at.endSentinelStack, 'empty sentinel stack'
        at.readError(
            "Unexpected end of file. Expecting %s sentinel" %
            at.sentinelName(at.endSentinelStack[-1]))
    return at.lastLines
.. @+node:ekr.20041005105605.75: *4* at.initScanText4
def initScanText4(self, p):
    '''Init all ivars for at.scanText4().'''
    at = self
    # Unstacked ivars...
    at.cloneSibCount = 0
    at.done = False
    at.inCode = True
    at.indent = 0 # Changed only for sentinels.
    at.lastLines = [] # The lines after @-leo
    at.leadingWs = ""
    at.lineNumber = 0
    at.root = p.copy() # Bug fix: 12/10/05
    at.rootSeen = False
    at.updateWarningGiven = False
    # Stacked ivars...
    at.endSentinelNodeStack = [None]
    at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
    at.lastThinNode = None
    at.out = []
    at.outStack = []
    at.thinChildIndexStack = []
    at.thinNodeStack = []
    at.v1 = p.v
    at.v = p.v
    at.vStack = []
.. @+node:ekr.20041005105605.77: *4* at.readNormalLine & appendToDocPart
def readNormalLine(self, s, i=0): # i not used.
    at = self
    # g.trace('inCode',at.inCode,repr(s))
    if at.inCode:
        if not at.raw:
            # 2012/06/05: Major bug fix: insert \\-n. for underindented lines.
            n = g.computeLeadingWhitespaceWidth(s, at.tab_width)
            if n < at.indent:
                # g.trace('n: %s at.indent: %s\n%s' % (n,at.indent,repr(s)))
                if s.strip():
                    s = r'\\-%s.%s' % (at.indent - n, s.lstrip())
                else:
                    s = '\n' if s.endswith('\n') else ''
            else: # Legacy
                s = g.removeLeadingWhitespace(s, at.indent, at.tab_width)
        at.appendToOut(s)
    else:
        at.appendToDocPart(s)
.. @+node:ekr.20100624082003.5942: *5* at.appendToDocPart
def appendToDocPart(self, s):
    '''Append the next line of the @doc part to docOut.'''
    at = self
    trace = False and at.readVersion5 and not g.unitTesting
    # Skip the leading stuff
    if at.endSentinelComment:
        i = at.skipIndent(s, 0, at.indent)
    else:
        # Skip the single comment delim and a blank.
        i = g.skip_ws(s, 0)
        if g.match(s, i, at.startSentinelComment):
            i += len(at.startSentinelComment)
            if g.match(s, i, " "): i += 1
    if at.readVersion5:
        # Append the line to docOut.
        line = s[i:]
        at.docOut.append(line)
    else:
        # Append line to docOut, possibly stripping the newline.
        line = s[i: -1] # remove newline for rstrip.
        if line == line.rstrip():
            # no trailing whitespace: the newline is real.
            at.docOut.append(line + '\n')
        else:
            # trailing whitespace: the newline is fake.
            at.docOut.append(line)
    if trace: g.trace(repr(line))
.. @+node:ekr.20041005105605.80: *4* start sentinels
.. @+node:ekr.20041005105605.81: *5* at.readStartAll
def readStartAll(self, s, i):
    """Read an @+all sentinel."""
    at = self
    j = g.skip_ws(s, i)
    leadingWs = s[i: j]
    if leadingWs:
        assert g.match(s, j, "@+all"), 'missing @+all'
    else:
        assert g.match(s, j, "+all"), 'missing +all'
    # Make sure that the generated at-all is properly indented.
    # New code (for both old and new sentinels).
    # Regularize the whitespace preceding the @all directive.
    junk_i, w = g.skip_leading_ws_with_indent(s, 0, at.tab_width)
    lws2 = g.computeLeadingWhitespace(max(0, w - at.indent), at.tab_width)
    at.appendToOut(lws2 + "@all\n")
    at.endSentinelStack.append(at.endAll)
    if at.readVersion5:
        at.endSentinelNodeStack.append(at.v)
        at.endSentinelLevelStack.append(len(at.thinNodeStack))
.. @+node:ekr.20041005105605.85: *5* at.readStartNode & helpers
def readStartNode(self, s, i, middle=False):
    """
    Read an @+node or @+middle sentinel.
    This will terminate the previous node.
    """
    trace = False and not g.unitTesting
    at = self
    gnx, headline, i, level, ok = at.parseNodeSentinel(s, i, middle)
    # trace = trace and headline.startswith('ic.appendStringToBody')
    if trace: g.trace(gnx, headline)
    if at.v1:
        # Fix bug 169: https://github.com/leo-editor/leo-editor/issues/169
        # import-file does not preserve gnx of root @file node
        # g.trace(at.v1.fileIndex,'-->',gnx,at.v1.h)
        at.v1.fileIndex = gnx
        at.v1 = None
    if not ok: return
    # Switch context.
    if at.readVersion5:
        # Terminate the *previous* doc part if it exists.
        if at.docOut:
            at.appendToOut(''.join(at.docOut))
            at.docOut = []
        # Important: with new sentinels we *never*
        # terminate nodes until the post-pass.
    else:
        assert not at.docOut, 'not at.docOut' # Cleared by @-node sentinel.
        at.outStack.append(at.out)
        at.out = []
    at.inCode = True
    at.raw = False # End raw mode.
    at.vStack.append(at.v)
    at.indentStack.append(at.indent)
    i, at.indent = g.skip_leading_ws_with_indent(s, 0, at.tab_width)
    if at.importing:
        p = at.createImportedNode(at.root, headline)
        at.v = p.v
    elif at.thinFile:
        at.v = at.createNewThinNode(gnx, headline, level)
    else:
        at.v = at.findChild4(headline)
    if not at.v:
        return # This can happen when reading strange files.
    assert at.v == at.root.v or at.v.isVisited(), at.v.h
    at.v.setVisited()
        # Indicate that the VNode has been set in the external file.
    if not at.readVersion5:
        at.endSentinelStack.append(at.endNode)
.. @+node:ekr.20100625085138.5957: *6* at.createNewThinNode & helpers
def createNewThinNode(self, gnx, headline, level):
    '''Create a new (new-style) vnode.'''
    at = self
    testFile = at.targetFileName.endswith('clone-revert-test.txt')
    trace = (False and testFile) and not g.unitTesting
    if trace:
        g.trace('v5: %s level: %2s %-24s %s' % (at.readVersion5, level, gnx, headline))
        g.trace(at.thinNodeStack)
    if at.thinNodeStack:
        if at.readVersion5: # Expected.
            v = self.createV5ThinNode(gnx, headline, level)
        else: # Legacy files.
            at.thinNodeStack.append(at.lastThinNode)
            v = at.old_createThinChild4(gnx, headline)
    else:
        v = at.root.v
        if at.readVersion5:
            at.thinChildIndexStack.append(0)
        at.thinNodeStack.append(v)
    at.lastThinNode = v
    return v
.. @+node:ekr.20130121102015.10272: *7* at.createV5ThinNode
def createV5ThinNode(self, gnx, headline, level):
    '''Create a version 5 vnode.'''
    at = self
    trace = False and not g.unitTesting
    oldLevel = len(at.thinNodeStack)
    newLevel = level
    assert oldLevel >= 1
    assert newLevel >= 1
    # The invariant: top of at.thinNodeStack after changeLevel is the parent.
    at.changeLevel(oldLevel, newLevel - 1)
    parent = at.thinNodeStack[-1]
    n = at.thinChildIndexStack[-1]
    if trace: g.trace(oldLevel, newLevel - 1, n, parent.h, headline)
    v = at.new_createThinChild4(gnx, headline, n, parent)
    at.thinChildIndexStack[-1] = n + 1
    at.thinNodeStack.append(v)
    at.thinChildIndexStack.append(0)
    at.lastThinNode = v
    # Ensure that the body text is set only once.
    # Huh?
    if v.isVisited():
        if hasattr(v, 'tempBodyList'):
            delattr(v, 'tempBodyList')
    else:
        # This is the only place we call v.setVisited in the read logic.
        v.setVisited()
    return v
.. @+node:ekr.20130121075058.10246: *7* at.new_createThinChild4
def new_createThinChild4(self, gnxString, headline, n, parent):
    """
    Find or create a new *vnode* whose parent (also a vnode)
    is at.lastThinNode. This is called only for @thin trees.
    """
    trace = False and not g.unitTesting
    trace_tree = False
    c = self.c
    if trace and trace_tree:
        g.trace(n, len(parent.children), parent.h, ' -> ', headline)
        # at.thinChildIndexStack,[z.h for z in at.thinNodeStack],
    gnx = gnxString = g.toUnicode(gnxString)
    gnxDict = c.fileCommands.gnxDict
    v = gnxDict.get(gnxString)
    if v:
        if gnx == v.fileIndex:
            # Always use v.h, regardless of headline.
            if trace and v.h != headline:
                g.trace('read error v.h: %s headline: %s' % (v.h, headline))
            child = v # The return value.
            if n >= len(parent.children):
                child._linkAsNthChild(parent, n)
                if trace and trace_tree:
                    g.trace('OLD n: %s parent: %s -> %s' % (n, parent.h, child.h))
            elif trace:
                if trace_tree: g.trace('DUP n: %s parent: %s -> %s' % (
                    n, parent.h, child.h))
                else:
                    g.trace('CLONE', id(v), v.gnx, v.h)
        else:
            g.internalError('v.fileIndex: %s gnx: %s' % (v.fileIndex, gnx))
            return None
    else:
        v = leoNodes.VNode(context=c, gnx=gnx)
        v._headString = headline # Allowed use of v._headString.
        gnxDict[gnxString] = v
        if g.trace_gnxDict: g.trace(c.shortFileName(), gnxString, v)
        child = v
        child._linkAsNthChild(parent, n)
        if trace and v.h == 'clone-test':
            g.trace('NEW n: %s parent: %s -> %s' % (n, parent.h, child.h))
    return child
.. @+node:ekr.20130121075058.10245: *7* at.old_createThinChild4
def old_createThinChild4(self, gnxString, headline):
    """
    Find or create a new *vnode* whose parent (also a vnode)
    is at.lastThinNode. This is called only for @thin trees.
    """
    trace = False and not g.unitTesting
    verbose = True
    at = self; c = at.c
    gnx = gnxString = g.toUnicode(gnxString)
    gnxDict = c.fileCommands.gnxDict
    last = at.lastThinNode # A VNode.
    lastIndex = last.fileIndex
    if trace and verbose: g.trace("last %s, gnx %s %s" % (
        last and last.h, gnxString, headline))
    parent = last
    children = parent.children
    for child in children:
        if gnx == child.fileIndex:
            break
    else:
        child = None
    if at.cloneSibCount > 1:
        n = at.cloneSibCount; at.cloneSibCount = 0
        if child: clonedSibs, junk = at.scanForClonedSibs(parent, child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        if trace: g.trace(copies, headline)
    else:
        if gnx == lastIndex:
            last.setVisited()
                # Supress warning/deletion of unvisited nodes.
            if trace: g.trace('found last', last)
            return last
        if child:
            child.setVisited()
                # Supress warning/deletion of unvisited nodes.
            if trace: g.trace('found child', child)
            return child
        copies = 1 # Create exactly one copy.
    while copies > 0:
        copies -= 1
        # Create the VNode only if it does not already exist.
        v = gnxDict.get(gnxString)
        if v:
            if gnx != v.fileIndex:
                g.internalError('v.fileIndex: %s gnx: %s' % (
                    v.fileIndex, gnx))
        else:
            v = leoNodes.VNode(context=c, gnx=gnx)
            v._headString = headline # Allowed use of v._headString.
            gnxDict[gnxString] = v
            if g.trace_gnxDict: g.trace(c.shortFileName(), gnxString, v)
        child = v
        child._linkAsNthChild(parent, parent.numberOfChildren())
    if trace: g.trace('new node: %s' % child.h)
    child.setVisited() # Supress warning/deletion of unvisited nodes.
    return child
.. @+node:ekr.20100625184546.5979: *6* at.parseNodeSentinel & helpers
def parseNodeSentinel(self, s, i, middle):
    at = self
    if middle:
        assert g.match(s, i, "+middle:"), 'missing +middle'
        i += 8
    else:
        if not g.match(s, i, '+node:'): g.trace(repr(s[i: i + 40]), g.callers(5))
        assert g.match(s, i, "+node:"), 'missing +node:'
        i += 6
    # Get the gnx and the headline.
    if at.thinFile:
        gnx, i, level, ok = at.parseThinNodeSentinel(s, i)
        if not ok:
            # Bug fix: 2014/03/26: return 5-tuple
            return None, None, None, None, False
    else:
        gnx, level = None, None
    headline = at.getNodeHeadline(s, i)
    return gnx, headline, i, level, True
.. @+node:ekr.20100625085138.5955: *7* at.getNodeHeadline
def getNodeHeadline(self, s, i):
    '''Set headline to the rest of the line.
    Don't strip leading whitespace.'''
    at = self
    if at.endSentinelComment:
        k = s.rfind(at.endSentinelComment, i)
        h = s[i: k].rstrip() # works if k == -1
    else:
        h = s[i: -1].rstrip()
    # Undo the CWEB hack: undouble @ signs if\
    # the opening comment delim ends in '@'.
    if at.startSentinelComment[-1:] == '@':
        h = h.replace('@@', '@')
    return h
.. @+node:ekr.20100625085138.5953: *7* at.parseThinNodeSentinel
def parseThinNodeSentinel(self, s, i):
    at = self

    def oops(message):
        if g.unitTesting: g.trace(message, repr(s))
        else: at.readError(message)
        return None, None, None, False

    j = s.find(':', i)
    if j == -1:
        return oops('Expecting gnx in @+node sentinel')
    else:
        gnx = s[i: j]
    if at.readVersion5:
        if not g.match(s, j, ': '):
            return oops('Expecting space after gnx')
        i = j + 2
        if not g.match(s, i, '*'):
            return oops('No level stars')
        i += 1
        if g.match(s, i, ' '):
            level = 1; i += 1
        elif g.match(s, i, '* '):
            level = 2; i += 2
        else:
            # The level stars have the form *N*.
            level = 0; j = i
            while i < len(s) and s[i].isdigit():
                i += 1
            if i > j:
                level = int(s[j: i])
            else:
                return oops('No level number')
            if g.match(s, i, '* '):
                i += 2
            else:
                return oops('No space after level stars')
    else: # not readVersion5.
        i = j + 1 # Skip the gnx.
        level = 0
    return gnx, i, level, True
.. @+node:ekr.20041005105605.111: *5* at.readRef (paired using new sentinels)
@ The sentinel contains an @ followed by a section name in angle brackets.
This code is different from the code for the @@ sentinel: the expansion
of the reference does not include a trailing newline.
@c

def readRef(self, s, i):
    """Handle an @<< sentinel."""
    at = self
    if at.readVersion5:
        assert g.match(s, i, "+"), 'g.match(s,i,"+")'
        i += 1 # Skip the new plus sign.
        # New in Leo 4.8: Ignore the spellling in leadingWs.
        # Instead, compute lws2, the regularized leading whitespace.
        junk_i, w = g.skip_leading_ws_with_indent(s, 0, at.tab_width)
        lws2 = g.computeLeadingWhitespace(max(0, w - at.indent), at.tab_width)
    else:
        lws2 = ''
    j = g.skip_ws(s, i)
    assert g.match(s, j, "<<"), 'missing @<< sentinel'
    if at.endSentinelComment:
        k = s.find(at.endSentinelComment, i)
        if at.readVersion5:
            line = lws2 + s[i: k] + '\n' # Restore the newline.
        else:
            line = s[i: k] # No trailing newline, whatever k is.
    else:
        if at.readVersion5:
            line = lws2 + s[i:]
        else:
            line = s[i: -1] # No trailing newline
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and start[-1] == '@':
        line = line.replace('@@', '@')
    at.appendToOut(line)
    if at.readVersion5:
        # g.trace(at.indent,repr(line))
        at.endSentinelLevelStack.append(len(at.thinNodeStack))
        at.endSentinelIndentStack.append(at.indent)
        at.endSentinelStack.append(at.endRef)
        at.endSentinelNodeStack.append(at.v)
    else:
        pass # There is no paired @-ref sentinel.
.. @+node:ekr.20041005105605.82: *5* at.readStartAt/Doc & helpers
.. @+node:ekr.20100624082003.5938: *6* readStartAt
def readStartAt(self, s, i):
    """Read an @+at sentinel."""
    at = self
    assert g.match(s, i, "+at"), 'missing +at'
    i += 3
    if at.readVersion5: # Append whatever follows the sentinel.
        j = at.skipToEndSentinel(s, i)
        follow = s[i: j]
        at.appendToOut('@' + follow + '\n')
        at.docOut = []
        at.inCode = False
    else:
        j = g.skip_ws(s, i)
        ws = s[i: j]
        at.docOut = ['@' + ws + '\n']
            # This newline may be removed by a following @nonl
        at.inCode = False
        at.endSentinelStack.append(at.endAt)
.. @+node:ekr.20100624082003.5939: *6* readStartDoc
def readStartDoc(self, s, i):
    """Read an @+doc sentinel."""
    at = self
    assert g.match(s, i, "+doc"), 'missing +doc'
    i += 4
    if at.readVersion5: # Append whatever follows the sentinel.
        j = at.skipToEndSentinel(s, i)
        follow = s[i: j] + '\n'
        at.appendToOut('@' + follow + '\n')
        at.docOut = []
        at.inCode = False
    else:
        j = g.skip_ws(s, i)
        ws = s[i: j]
        at.docOut = ["@doc" + ws + '\n']
            # This newline may be removed by a following @nonl
        at.inCode = False
        at.endSentinelStack.append(at.endDoc)
.. @+node:ekr.20100624082003.5940: *6* skipToEndSentinel
def skipToEndSentinel(self, s, i):
    '''Skip to the end of the sentinel line.'''
    at = self
    end = at.endSentinelComment
    if end:
        j = s.find(end, i)
        if j == -1:
            return g.skip_to_end_of_line(s, i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s, i)
.. @+node:ekr.20041005105605.83: *5* at.readStartLeo
def readStartLeo(self, s, i):
    """Read an unexpected @+leo sentinel."""
    at = self
    assert g.match(s, i, "+leo"), 'missing +leo sentinel'
    at.readError("Ignoring unexpected @+leo sentinel")
.. @+node:ekr.20041005105605.84: *5* at.readStartMiddle
def readStartMiddle(self, s, i):
    """Read an @+middle sentinel."""
    at = self
    at.readStartNode(s, i, middle=True)
    g.warning('Warning: file contains @+middle sentinel')
.. @+node:ekr.20041005105605.89: *5* at.readStartOthers
def readStartOthers(self, s, i):
    """Read an @+others sentinel."""
    at = self
    j = g.skip_ws(s, i)
    leadingWs = s[i: j]
    if leadingWs:
        assert g.match(s, j, "@+others"), 'missing @+others'
    else:
        assert g.match(s, j, "+others"), 'missing +others'
    # Make sure that the generated at-others is properly indented.
    # New code (for both old and new sentinels).
    # Regularize the whitespace preceding the @others directive.
    junk_i, w = g.skip_leading_ws_with_indent(s, 0, at.tab_width)
    lws2 = g.computeLeadingWhitespace(max(0, w - at.indent), at.tab_width)
    at.appendToOut(lws2 + "@others\n")
    if at.readVersion5:
        at.endSentinelIndentStack.append(at.indent)
        at.endSentinelStack.append(at.endOthers)
        at.endSentinelNodeStack.append(at.v)
        at.endSentinelLevelStack.append(len(at.thinNodeStack))
    else:
        at.endSentinelStack.append(at.endOthers)
.. @+node:ekr.20041005105605.90: *4* end sentinels
.. @+node:ekr.20041005105605.91: *5* at.readEndAll
def readEndAll(self, unused_s, unused_i):
    """Read an @-all sentinel."""
    at = self
    at.popSentinelStack(at.endAll)
    if at.readVersion5:
        # Restore the node containing the @all directive.
        # *Never* terminate new-sentinel nodes until the post-pass.
        at.raw = False # End raw mode: 2011/06/13.
        oldLevel = len(at.thinNodeStack)
        newLevel = at.endSentinelLevelStack.pop()
        at.v = at.endSentinelNodeStack.pop() # Bug fix: 2011/06/13.
        at.changeLevel(oldLevel, newLevel)
        # g.trace('oldLevel',oldLevel,'newLevel',newLevel,'at.v',at.v)
.. @+node:ekr.20041005105605.92: *5* at.readEndAt & readEndDoc
def readEndAt(self, unused_s, unused_i):
    """Read an @-at sentinel."""
    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True

def readEndDoc(self, unused_s, unused_i):
    """Read an @-doc sentinel."""
    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True
.. @+node:ekr.20041005105605.93: *5* at.readEndLeo
def readEndLeo(self, unused_s, unused_i):
    """Read an @-leo sentinel."""
    at = self
    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine()
        if not s: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.
    at.done = True
.. @+node:ekr.20041005105605.94: *5* at.readEndMiddle
def readEndMiddle(self, s, i):
    """Read an @-middle sentinel."""
    at = self
    at.readEndNode(s, i, middle=True)
.. @+node:ekr.20041005105605.95: *5* at.readEndNode (old sentinels only)
def readEndNode(self, unused_s, unused_i, middle=False):
    """
    Handle old-style @-node sentinels.
    In the new scheme, only the post-pass terminates nodes.
    """
    at = self
    assert not at.readVersion5, 'not at.readVersion5'
        # Must not be called for new sentinels.
    at.raw = False # End raw mode.
    at.terminateNode(middle=middle, postPass=False)
        # Set the body text and warn about changed text.
        # This must not be called when handling new sentinels!
    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.docOut = []
    at.v = at.vStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()
    at.popSentinelStack(at.endNode)
.. @+node:ekr.20041005105605.98: *5* at.readEndOthers
def readEndOthers(self, unused_s, unused_i):
    """Read an @-others sentinel."""
    at = self
    at.popSentinelStack(at.endOthers)
    if at.readVersion5:
        # g.trace(at.readVersion5,repr(at.docOut))
        # Terminate the *previous* doc part if it exists.
        if at.docOut:
            s = ''.join(at.docOut)
            s = at.massageAtDocPart(s) # 2011/05/24
            at.appendToOut(s)
            at.docOut = []
        # 2010/10/21: Important bug fix: always enter code mode.
        at.inCode = True
        # Restore the node continain the @others directive.
        # *Never* terminate new-sentinel nodes until the post-pass.
        at.raw = False # End raw mode.
        at.v = at.endSentinelNodeStack.pop()
        at.indent = at.endSentinelIndentStack.pop()
        oldLevel = len(at.thinNodeStack)
        newLevel = at.endSentinelLevelStack.pop()
        at.changeLevel(oldLevel, newLevel)
.. @+node:ekr.20100625140824.5968: *5* at.readEndRef
def readEndRef(self, unused_s, unused_i):
    """Read an @-<< sentinel."""
    at = self
    at.popSentinelStack(at.endRef)
    if at.readVersion5:
        # Terminate the *previous* doc part if it exists.
        if at.docOut:
            at.appendToOut(''.join(at.docOut))
            at.docOut = []
        # 2010/10/21: Important bug fix: always enter code mode.
        at.inCode = True
        # Restore the node containing the section reference.
        # *Never* terminate new-sentinel nodes until the post-pass.
        at.raw = False # End raw mode.
        at.lastRefNode = at.v # A kludge for at.readAfterRef
        at.v = at.endSentinelNodeStack.pop()
        at.indent = at.endSentinelIndentStack.pop()
        oldLevel = len(at.thinNodeStack)
        newLevel = at.endSentinelLevelStack.pop()
        at.changeLevel(oldLevel, newLevel)
.. @+node:ekr.20041005105605.99: *5* at.readLastDocLine (old sentinels only)
def readLastDocLine(self, tag):
    """Read the @c line that terminates the doc part.
    tag is @doc or @.

    Not used when reading new sentinels.
    """
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s, 0, tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return
    # Bug fix: Append any whitespace following the tag to tag.
    while s and s[0] in (' ', '\t'):
        tag = tag + s[0]; s = s[1:]
    if end:
        # Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s, 0, start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace('tag', repr(tag), 'start', repr(start), 's', repr(s))
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[: -1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[: -len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return
    at.appendToOut(tag + s)
    at.docOut = []
.. @+node:ekr.20041005105605.100: *4* Unpaired sentinels
# Ooops: shadow files are cleared if there is a read error!!
.. @+node:ekr.20041005105605.101: *5* at.ignoreOldSentinel
def ignoreOldSentinel(self, s, unused_i):
    """Ignore an 3.x sentinel."""
    g.warning("ignoring 3.x sentinel:", s.strip())
.. @+node:ekr.20041005105605.102: *5* at.readAfterRef
def readAfterRef(self, s, i):
    """Read an @afterref sentinel."""
    at = self
    trace = False and not g.unitTesting
    assert g.match(s, i, "afterref"), 'missing afterref'
    # Append the next line to the text.
    s = at.readLine()
    v = at.lastRefNode
    hasList = hasattr(v, 'tempBodyList')
    # g.trace('hasList',hasList,'v',v and v.h)
    if at.readVersion5:
        if hasList and at.v.tempBodyList:
            # Remove the trailing newline.
            s2 = at.v.tempBodyList[-1]
            if s2.endswith('\n'): s2 = s2[: -1]
            at.v.tempBodyList[-1] = s2
            if trace: g.trace('v: %30s %s' % (at.v.h, repr(s2 + s)))
    at.appendToOut(s)
.. @+node:ekr.20041005105605.103: *5* at.readClone
def readClone(self, s, i):
    at = self; tag = "clone"
    assert g.match(s, i, tag), 'missing clone sentinel'
    # Skip the tag and whitespace.
    i = g.skip_ws(s, i + len(tag))
    # Get the clone count.
    junk, val = g.skip_long(s, i)
    if val is None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount = val
.. @+node:ekr.20041005105605.104: *5* at.readComment
def readComment(self, s, i):
    """Read an @comment sentinel."""
    assert g.match(s, i, "comment"), 'missing comment sentinel'
    # Just ignore the comment line!
.. @+node:ekr.20041005105605.105: *5* at.readDelims
def readDelims(self, s, i):
    """Read an @delims sentinel."""
    at = self
    assert g.match(s, i - 1, "@delims"), 'missing @delims'
    # Skip the keyword and whitespace.
    i0 = i - 1
    i = g.skip_ws(s, i - 1 + 7)
    # Get the first delim.
    j = i
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s, i):
        i += 1
    if j < i:
        at.startSentinelComment = s[j: i]
        # Get the optional second delim.
        j = i = g.skip_ws(s, i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s, i):
            i += 1
        end = s[j: i] if j < i else ""
        i2 = g.skip_ws(s, i)
        if end == at.endSentinelComment and (i2 >= len(s) or g.is_nl(s, i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0: j]
            line = line.rstrip()
            at.appendToOut(line + '\n')
        else:
            at.endSentinelComment = end
            line = s[i0: i]
            line = line.rstrip()
            at.appendToOut(line + '\n')
    else:
        at.readError("Bad @delims")
        at.appendToOut("@delims")
.. @+node:ekr.20041005105605.106: *5* at.readDirective (@@)
def readDirective(self, s, i):
    """Read an @@sentinel."""
    at = self
    assert g.match(s, i, "@"), 'missing @@ sentinel'
        # The first '@' has already been eaten.
    if g.match_word(s, i, "@raw"):
        at.raw = True
    elif g.match_word(s, i, "@end_raw"):
        at.raw = False
    e = at.endSentinelComment
    s2 = s[i:]
    if e:
        k = s.rfind(e, i)
        if k != -1:
            s2 = s[i: k] + '\n'
    start = at.startSentinelComment
    if start and start[-1] == '@':
        s2 = s2.replace('@@', '@')
    # An @c or @code ends the doc part when using new sentinels.
    if (
        at.readVersion5 and s2.startswith('@c') and
        (g.match_word(s2, 0, '@c') or g.match_word(s2, 0, '@code'))
    ):
        if at.docOut:
            s = ''.join(at.docOut)
            s = at.massageAtDocPart(s)
            at.appendToOut(s)
            at.docOut = []
        at.inCode = True # End the doc part.
    at.appendToOut(s2)
.. @+node:ekr.20041005105605.109: *5* at.readNl
def readNl(self, s, i):
    """Handle an @nonl sentinel."""
    at = self
    assert g.match(s, i, "nl"), 'missing nl sentinel'
    if at.inCode:
        at.appendToOut('\n')
    else:
        at.docOut.append('\n')
.. @+node:ekr.20041005105605.110: *5* at.readNonl
def readNonl(self, s, i):
    """Handle an @nonl sentinel."""
    at = self
    assert g.match(s, i, "nonl"), 'missing nonl sentinel'
    if at.inCode:
        s = ''.join(at.out)
        # 2010/01/07: protect against a mostly-harmless read error.
        if s:
            if s[-1] == '\n':
                at.out = [s[: -1]] # Do not use at.appendToOut here!
            else:
                g.trace("out:", s)
                at.readError("unexpected @nonl directive in code part")
    else:
        s = ''.join(at.pending)
        if s:
            if s[-1] == '\n':
                at.pending = [s[: -1]]
            else:
                g.trace("docOut:", s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[: -1]]
            else:
                g.trace("docOut:", s)
                at.readError("unexpected @nonl directive in doc part")
.. @+node:ekr.20041005105605.112: *5* at.readVerbatim
def readVerbatim(self, s, i):
    """Read an @verbatim sentinel."""
    at = self
    assert g.match(s, i, "verbatim"), 'missing verbatim sentinel'
    # Append the next line to the text.
    s = at.readLine()
    i = at.skipIndent(s, 0, at.indent)
    # Do **not** insert the verbatim line itself!
        # at.appendToOut("@verbatim\n")
    at.appendToOut(s[i:])
.. @+node:ekr.20041005105605.113: *4* at.badEndSentinel, popSentinelStack
def badEndSentinel(self, expectedKind):
    """Handle a mismatched ending sentinel."""
    at = self
    assert at.endSentinelStack, 'empty sentinel stack'
    s = "(badEndSentinel) Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)

def popSentinelStack(self, expectedKind):
    """Pop an entry from endSentinelStack and check it."""
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        if 1: g.trace('%s\n%s' % (
            [at.sentinelName(z) for z in at.endSentinelStack],
            g.callers(4)))
        at.badEndSentinel(expectedKind)
.. @+node:ekr.20130121102851.10249: *4* at.changeLevel
def changeLevel(self, oldLevel, newLevel):
    '''
    Update data structures when changing node level.

    The key invariant: on exit, the top of at.thinNodeStack is the new parent node.
    '''
    at = self
    # Crucial: we must be using new-style sentinels.
    assert at.readVersion5, 'at.readVersion5'
    assert at.thinFile, 'at.thinFile'
    assert not at.importing, 'not at.importing'
        # We can be importing when using the import-file command.
    if newLevel > oldLevel:
        # A possible fix for bug #289.
        if newLevel != oldLevel + 1:
            # g.trace('expected level %s got level %s' % (
            #    oldLevel + 1, newLevel), g.callers())
            newLevel = oldLevel + 1
        # assert newLevel == oldLevel + 1, 'newLevel == oldLevel + 1'
    else:
        while oldLevel > newLevel:
            oldLevel -= 1
            at.thinChildIndexStack.pop()
            at.indentStack.pop()
            at.thinNodeStack.pop()
            at.vStack.pop()
        assert oldLevel == newLevel, 'oldLevel: %s newLevel: %s' % (oldLevel, newLevel)
        assert len(at.thinNodeStack) == newLevel, 'len(at.thinNodeStack) == newLevel'
    # The last node is the node at the top of the stack.
    # This node will be the parent of any newly created node.
    at.lastThinNode = at.thinNodeStack[-1]
.. @+node:ekr.20110523201030.18288: *4* at.massageAtDocPart (new)
def massageAtDocPart(self, s):
    '''Compute the final @doc part when block comments are used.'''
    at = self
    if at.endSentinelComment:
        ok1 = s.startswith(at.startSentinelComment + '\n')
        ok2 = s.endswith(at.endSentinelComment + '\n')
        if ok1 and ok2:
            n1 = len(at.startSentinelComment)
            n2 = len(at.endSentinelComment)
            s = s[n1 + 1: -(n2 + 1)]
        else:
            at.error('invalid @doc part...\n%s' % repr(s))
    # g.trace(repr(s))
    return s
.. @+node:ekr.20041005105605.114: *3* at.sentinelKind4 & helper (read logic)
def sentinelKind4(self, s):
    """Return the kind of sentinel at s."""
    trace = False and not g.unitTesting
    verbose = False
    at = self
    val = at.sentinelKind4_helper(s)
    if trace and (verbose or val != at.noSentinel):
        g.trace('%-20s %s' % (
            at.sentinelName(val), s.rstrip()))
    return val
.. @+node:ekr.20100518083515.5896: *4* sentinelKind4_helper
def sentinelKind4_helper(self, s):
    at = self
    i = g.skip_ws(s, 0)
    if g.match(s, i, at.startSentinelComment):
        i += len(at.startSentinelComment)
    else:
        return at.noSentinel
    # Locally undo cweb hack here
    start = at.startSentinelComment
    if start and start[-1] == '@':
        s = s[: i] + s[i:].replace('@@', '@')
    # New sentinels.
    if g.match(s, i, "@+"):
        if g.match(s, i + 2, "others"):
            return at.startOthers
        elif g.match(s, i + 2, "<<"):
            return at.startRef
        else:
            j = g.skip_ws(s, i + 2)
            if g.match(s, j, "<<"):
                return at.startRef
    elif g.match(s, i, "@-"):
        if g.match(s, i + 2, "others"):
            return at.endOthers
        elif g.match(s, i + 2, "<<"):
            return at.endRef
        else:
            j = g.skip_ws(s, i + 2)
            if g.match(s, j, "<<"):
                return at.endRef
    # Old sentinels.
    elif g.match(s, i, "@"):
        j = g.skip_ws(s, i + 1)
        if j > i + 1:
            if g.match(s, j, "@+others"):
                return at.startOthers
            elif g.match(s, j, "@-others"):
                return at.endOthers
            elif g.match(s, j, "<<"):
                return at.startRef
            else:
                # No other sentinels allow whitespace following the '@'
                return at.noSentinel
    # Do not skip whitespace here!
    if g.match(s, i, "@<<"): return at.startRef
    if g.match(s, i, "@@"): return at.startDirective
    if not g.match(s, i, '@'): return at.noSentinel
    j = i # start of lookup
    i += 1 # skip the at sign.
    if g.match(s, i, '+') or g.match(s, i, '-'):
        i += 1
    i = g.skip_c_id(s, i)
    key = s[j: i]
    if key and key in at.sentinelDict:
        return at.sentinelDict[key]
    else:
        return at.noSentinel
.. @+node:ekr.20041005105605.115: *3* at.skipSentinelStart4
def skipSentinelStart4(self, s, i):
    """Skip the start of a sentinel."""
    start = self.startSentinelComment
    assert start, 'skipSentinelStart4 1'
    i = g.skip_ws(s, i)
    assert g.match(s, i, start), 'skipSentinelStart4 2'
    i += len(start)
    # 7/8/02: Support for REM hack
    i = g.skip_ws(s, i)
    assert i < len(s) and s[i] == '@', 'skipSentinelStart4 3'
    return i + 1
.. @-all
.. @@nosearch
.. @@killbeautify
.. @@language rest
.. @@wrap
.. @@pagewidth 60
.. @-leo
