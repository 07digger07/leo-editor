#@+leo-ver=5-thin
#@+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
#@+all
#@+node:ekr.20111103205308.9698: ** Unit tests
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)

s1 = '''
<table id="1"> <table id="2">
<contents/>
</table>
</table>
'''

s2 = '''
<table id="1"> 
<table id="2">
<contents/>
</table>
</table>
'''

t1 = 
assert result == expected,'expected...\n%s\ngot...\n%s' % (
    repr(expected),repr(result))
#@+node:ekr.20100907115157.5905: *3* @ignore Ancient tests
#@+node:ekr.20100208095423.5940: *4* @test leoCache
import leo.core.leoCache as leoCache

cacher = leoCache.cacher(c)

if 0:
    import os
    os.system('cls')

assert cacher.test()
#@+node:ekr.20100906165118.5915: *4* @test leoInkCommands
ic = c.inkscapeCommands
screenshot = r'c:\leo.repo\inkcall\some_screen_shot.png'
template_fn = r'c:\leo.repo\inkcall\template.svg'
png_fn = r'c:\leo.repo\inkcall\output.png'
svg_fn = r'c:\leo.repo\inkcall\temp.svg'
callouts = [
        "This goes here",
        "These are those, but slightly longer",
        "Then you pull this, but this text needs to be longer for testing",]
ic.run(
    screenshot,
    callouts=callouts,
    numbers=[2,4,17],
    edit_flag = True, # True: call inkscape to edit the working file.
    png_fn=png_fn, # Optional: Name of output png file.
    svg_fn=svg_fn, # Optional: Name of working svg file.
    template_fn=template_fn, # Optional: Name of template svg file.
)
#@+node:ekr.20111102123707.9629: *4* @ignore test of marked unit-test trees
#@+node:ekr.20111102123707.9630: *5* @test assert False
assert False
#@+node:ekr.20111102123707.9631: *5* @test assert True
assert True
#@+node:ekr.20111107092526.9799: *4* @test detection of external unit tests
# This test is redundant, and another test sets import_html_tags

# print('g.app.isExternalUnitTest',g.app.isExternalUnitTest)
if g.app.isExternalUnitTest:
    fn = c.shortFileName()
    assert fn.endswith('dynamicUnitTest.leo'),fn
    data = c.config.getData('import_html_tags')
    assert len(data) == 85 # length of data in leoSettings.leo.
else:
    data = c.config.getData('import_html_tags')
    assert len(data) == 85,len(data)
#@+node:ekr.20111107092526.9800: *5* doTests...
def doTests(c,all=None,marked=None,p=None,verbosity=1):

    trace = False ; verbose = False
    if all:
        p = c.rootPosition()
    elif not p:
        p = c.p
    p1 = c.p.copy() # 2011/10/31: always restore the selected position.
    
    g.trace(g.app.isExternalUnitTest)
    
    # This seems a bit risky when run in unitTest.leo.
    # c.save() # Eliminate the need for ctrl-s.
    
    if trace: g.trace('marked',marked,'c',c)

    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)

        # New in Leo 4.4.8: ignore everything in @ignore trees.
        last = None if all else p.nodeAfterTree()
        
        aList = findAllUnitTestNodes(c,p,last,all,marked,
            lookForMark=False,lookForNodes=True)
       
        found = False
        for p in aList:
            if isTestNode(p):
                if trace: g.trace('adding',p.h)
                test = makeTestCase(c,p)
            elif isSuiteNode(p): # @suite
                if trace: g.trace('adding',p.h)
                test = makeTestSuite(c,p)
            else:
                test = None
            if test:
                suite.addTest(test)
                found = True
        
        # Verbosity: 1: print just dots.
        if not found:
            # 2011/10/30: run the body of p as a unit test.
            test = makeTestCase(c,c.p)
            if test:
                suite.addTest(test)
                found = True
        if found:
            res = unittest.TextTestRunner(verbosity=verbosity).run(suite)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
                c.cacher.db[key] = archive
        else:
            g.es_print('no %s@test or @suite nodes in %s outline' % (
                g.choose(marked,'marked ',''),
                g.choose(all,'entire','selected')),color='red')
    finally:
        c.setChanged(changed) # Restore changed state.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.contractAllHeadlines()
            c.redraw(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20111107092526.9801: *6* class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20111107092526.9802: *7* __init__ (generalTestCase)
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@+node:ekr.20111107092526.9803: *7*  fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@+node:ekr.20111107092526.9804: *7* tearDown
def tearDown (self):

    pass

    # Restore the outline.
    self.c.outerUpdate()
#@+node:ekr.20111107092526.9805: *7* setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p.copy()) # 2010/02/03
#@+node:ekr.20111107092526.9806: *7* runTest (generalTestCase)
def runTest (self,define_g = True):

    trace = False
    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)
    
    if c.shortFileName() == 'dynamicUnitTest.leo':
        c.write_script_file = True

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p and p.copy(),'self':self,}
    else:
        d = {'self':self,}

    script = script + '\n'
    if trace: g.trace('p: %s c: %s write script: %s script:\n%s' % (
        p and p.h,c.shortFileName(),c.write_script_file,script))

    # Execute the script. Let the unit test handle any errors!
    # 2011/11/02: pass the script sources to exec or execfile.
    if c.write_script_file:
        scriptFile = c.writeScriptFile(script)
        if g.isPython3:
            exec(compile(script,scriptFile,'exec'),d)
        else:
            execfile(scriptFile,d)
    else:
        exec(script,d)
#@+node:ekr.20111107092526.9807: *7* shortDescription
def shortDescription (self):

    s = self.p.h

    # g.trace(s)

    return s + '\n'
#@+node:ekr.20111107092526.9808: *6* makeTestSuite (leoTest)
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()
    # g.trace('c.write_script_file',c.write_script_file)
    script = g.getScript(c,p).strip()
    if not script:
        print("no script in %s" % h)
        return None
    try:
        if 0: #debugging
            n,lines = 0,g.splitLines(script)
            for line in lines:
                print(n,line)
                n += 1
                
        # 2011/11/02: make script sources available.
        d = {'c':c,'g':g,'p':p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            if g.isPython3:
                exec(compile(script,scriptFile,'exec'),d)
            else:
                execfile(scriptFile,d)
        else:
            exec(script + '\n',d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("makeTestSuite: %s script did not set g.app.scriptDict" % p.h)
        return suite
    except Exception:
        print('makeTestSuite: exception creating test cases for %s' % p.h)
        g.es_exception()
        return None
#@+node:ekr.20111107092526.9809: *6* makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.b.strip():
        return generalTestCase(c,p)
    else:
        return None
#@+node:ekr.20111107092526.9810: *5* main & helpers (leoDynamicTest.py)
def main ():

    trace = False
    readSettings = True 
    tag = 'leoDynamicTests.leo'
    if trace: t1 = time.time()

    # Setting verbose=True prints messages that would be sent to the log pane.
    path,gui,silent = scanOptions()
    # print('(leoDynamicTest.py:main)','silent',silent)

    # Not loading plugins and not reading settings speeds things up considerably.
    bridge = leoBridge.controller(gui=gui,
        loadPlugins=False, # Must be False: plugins will fail when run externally.
        readSettings=True, # True adds about 0.3 seconds.  Is it useful?
        silent=True,
        verbose=False)

    if trace:
         t2 = time.time()
         print('%s open bridge:  %0.2fsec' % (tag,t2-t1))

    if bridge.isOpen():
        g = bridge.globals()
        g.app.silentMode = silent
        g.app.isExternalUnitTest = True
        path = g.os_path_finalize_join(g.app.loadDir,'..','test',path)
        c = bridge.openLeoFile(path)
        if trace:
            t3 = time.time()
            print('%s open file: %0.2fsec' % (tag,t3-t2))
        runUnitTests(c,g)
#@+node:ekr.20111107092526.9811: *6* runUnitTests
def runUnitTests (c,g):

    p = c.rootPosition()
    #g.es_print('running dynamic unit tests...')
    c.selectPosition(p)
    c.debugCommands.runAllUnitTestsLocally()
#@+node:ekr.20111107092526.9812: *6* scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('--path',dest='path')
    parser.add_option('--gui',dest="gui")
    parser.add_option('--silent',action="store_true",dest="silent")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)

    # -- path
    # We can't finalize the path here, because g does not exist ye.
    path = options.path or 'dynamicUnitTest.leo'

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('qttabs','qt'):
        gui = 'nullGui'

    # --silent
    silent = options.silent

    return path,gui,silent
#@+node:ekr.20111116161118.10248: *3* Recent tests
#@+node:ekr.20111104132424.9909: *4* @test assert True
# It's useful to have this do-nothing test.

assert True
#@+node:ekr.20111110085739.10265: *4* @test html string
s = '''\
<HTML>
<head>
    <title>Bodystring</title>
</head>
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
</html>
'''

html_tags = ('body','head','html','table',) # 'div',
setting = 'import_html_tags'

# Settings now work when run externally.
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.app.unitTestDict ['expectedErrors'] = 0

showTree = True

c.importCommands.htmlUnitTest(p,s=s,showTree=showTree)

if showTree:
    # g.cls()
    for p in p.subtree():
        print('\n***** %s\n' %p.h)
        print(p.b)
#@+node:ekr.20120112100822.10003: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120112100822.10004: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120112100822.10005: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120112100822.10006: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120203153754.10033: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120203153754.10034: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120203153754.10035: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120203153754.10036: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120204061120.10061: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120204061120.10062: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120204061120.10063: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120204061120.10064: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20111109151106.9746: *4* @test htmlScanner.filterTokens
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)
strip = hs.stripTokens
dump  = hs.formatTokens

s1 = '''<table id="1"><table id="2">
<contents/>
</table>
</table>'''

s2 = '<table id="1"><table id="2"><contents/></table></table>'
    
t1 = hs.tokenize(s1)
t2 = hs.tokenize(s2)
f1 = hs.filterTokens(t1)
f2 = hs.filterTokens(t2)

assert strip(f1) == strip(f2),'f1...\n%s\nf2...\n%s' % (
    dump(f1),dump(f2))
    
if 0:
    print(dump(f1))
#@+node:ekr.20111110084957.10092: *4* @test import dataN.html
fn = r'c:\recent\data.html'

# fn = r'c:\recent\data-smaller.html'
# fn = r'c:\recent\data666.html'

# These all pass on data.html:
    # html_tags = ('html','head','body',)
    # html_tags = ('html','head','body','table',)
    # html_tags = ('html','head','body','table','div',)
    # html_tags = ('html','head','body','table','div','script',)
    # html_tags = ('html','head','body','table','div','script','link',)
    # html_tags = ('html','head','body','table','div','script','link','p',)

html_tags = ('html','head','body','table','div','script','p','td','tr',)

# Settings now work when run externally.
setting = 'import_html_tags'
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.cls()

c.importCommands.importFilesCommand(files=[fn], treeType='@file')
#@+node:ekr.20111109105907.9795: *4* @test unicode stuff
@first # -*- coding: utf-8 -*-

table = (
    'test',
    'Ä 궯 奠',
    'Ä 궯 奠 after', # fails with cp6501: after is duplicated.
)

print('*'*20)
print('isPython3: %s' % g.isPython3)

for s in table:
    if g.isPython3:
        s = s.encode('ascii','replace') # create bytes.
    g.es(repr(s))
    g.es(s)
    g.pr ('g.pr(s)       : %s' % s)
    g.pr ('g.pr(repr(s)) : %s' % repr(s))
    print('print(s)      : %s' % s)
    print('print(repr(s)): %s' % s)
#@+node:ekr.20111113064104.9841: *4* @test external text operations
assert g.app.isExternalUnitTest

body = c.frame.body
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl

w = body.bodyCtrl
w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111112131605.9789: *4* @test nullBody text operations
# print('isExternalUnitTest',g.app.isExternalUnitTest)

if g.app.isExternalUnitTest:
    body = c.frame.body
else:
    import leo.core.leoCommands as leoCommands
    import leo.core.leoFrame as leoFrame
    import leo.core.leoGui as leoGui
    
    # Important: external unit tests should execute in this environment.
    nullGui   = leoGui.nullGui('null gui')
    nullFrame = leoFrame.nullFrame(title='nullFrame title',gui=nullGui)
    c2 = leoCommands.Commands(nullFrame,fileName='<empty fileName>')
    nullFrame.c = c2
    body = leoFrame.nullBody(frame=nullFrame,parentFrame=None)
    assert repr(body).startswith('<leo.core.leoFrame.nullBody')

# Now test some basic operations.
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl
w = body.bodyCtrl

w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111115155710.9835: *4* @test g.python_tokenize
# h = 'g.python_tokenize'
# p = p.firstChild()
# assert p.h == h
tokens = g.python_tokenize(p.b,line_numbers=False)

# tokens = [(kind,val) for (kind,val,line_number) in tokens]

# First, the basic check
tokens1 = [val for kind,val in tokens]
s = ''.join(tokens1)
assert p.b == s,repr(s)

if 0:
    for z in tokens:
        kind,val = z
        print('%6s %s' % (kind,repr(val)))
        
# Next, start filtering.
tokens = [(kind,g.choose(kind=='string','"S"',val)) for kind,val in tokens]

if 0: # Delete whitespace.
    tokens = [(kind,val) for (kind,val) in tokens if kind != 'ws']
    tokens = [(kind,g.choose(kind=='id',val+' ',val)) for (kind,val) in tokens]

# Last: stringize.
tokens = [val for kind,val in tokens if kind != 'comment']
# print(''.join(tokens))

if 1: # Print lines containing '='
    s = ''.join(tokens)
    for ch in '()[]{}<>.,:=+-/':
        s = s.replace(' '+ch,ch)
    aList = [z for z in g.splitLines(s)
        if z.find('=') > -1] # and not z.find('+=')>-1 and not z.find('-=')>-1]
    print(''.join(aList))
    
#@+node:ekr.20111204110514.10287: *4* @test p.moveToFirst/LastChild
def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()

child = p.firstChild()
assert child
setup(child)
p2 = child.insertAfter()
p2.h = "test"
try:
    assert c.positionExists(p2),p2
    p2.moveToFirstChildOf(child)
    assert c.positionExists(p2),p2
    p2.moveToLastChildOf(child)
    assert c.positionExists(p2),p2
finally:
    if 1:
        setup(child)
    c.redraw(p)
#@+node:ekr.20111210100047.10306: *5* child
#@+node:ekr.20111116161118.10247: *3* Old lint tests
#@+node:ekr.20111116103733.9845: *4*  Naming tests
# http://docs.python.org/reference/executionmodel.html#naming-and-binding

if 0:
    def test():
        a = b
        b = 1 # UnboundLocalError
        
print('***')
          
def test():
    global g2
    g2 = 4
    def test2():
        print(g2)
    test2()
    g2 = 3
    print(g2)
    
g2 = 'g2'
print(g2)

test()
#@+node:ekr.20111116103733.9846: *5* << define s>>
s = '''



'''

s = g.adjustTripleString(s,-4)
#@+node:ekr.20111116103733.9839: *4* @test create lots of data structures
# A simple prototype of data-centric design.
# 0.023 sec to create 100,000 dicts.
# 0.230 sec to create 1,000,000 dicts.

import time

t1 = time.clock()
n = 1000000

d = {}
for z in range(n):
    d[n] = {'n':n,}

t2 = time.clock()
print('Created %s dicts in %2.3f sec.' % (n,t2-t1))
#@+node:ekr.20111116103733.9844: *4* @test dumper (to outNodes)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outNodes.txt'

outStream = open(out,'w')
u.AstDumper().dumpFileAsNodes(fn,outStream)
#@+node:ekr.20111116103733.9840: *4* @test dumper (to outString)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outString.txt'

outStream = open(out,'w')
u.AstDumper(brief=True).dumpFileAsString(fn,outStream)
#@+node:ekr.20111128103520.10237: *3* Tests of @shadow from unitTest.leo
#@+node:ekr.20111128103520.10238: *4* @@shadow ../test/unittest/at-shadow-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10239: *5* spam
def spam():
    pass
#@+node:ekr.20111128103520.10240: *5* eggs
def eggs():
    pass
#@+node:ekr.20111128103520.10241: *4* @@shadow unittest/at-shadow-line-number-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10242: *5* child
def child():
    pass
#@+node:ekr.20111128103520.10243: *4* @test @shadow: shape of tree
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow ../test/unittest/at-shadow-test.py'
    p = g.findNodeAnywhere(c,h)
    assert p
    
    table = (
        (p.firstChild(),'spam'),
        (p.firstChild().next(),'eggs')
    )
    
    assert not p.isDirty(),p.h # Do not ignore this failure!
    
    for p2,h2 in table:
        assert len(p2.h) == len(h2)
#@+node:ekr.20111128103520.10244: *4* @test goto-global-line @shadow
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow unittest/at-shadow-line-number-test.py'
    root1 = g.findNodeAnywhere(c,h)
    assert root1
    assert root1.isAnyAtFileNode()
    
    fileName,lines,n,root2 = c.goToLineNumber(c).setup_file(n=6,p=root1)
    assert fileName == h[8:],'fileName'
    assert root2 == root1
    
    if 0:
        print('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
            root and root.h,isRaw,n,len(lines)))
#@+node:ekr.20120116073928.10114: *3* Unit tests for settings
#@+node:ekr.20120126050844.10386: *4* @ignore print dicts unit tests
#@+node:ekr.20120117095916.10124: *5* @test printMenusList
def printMenusList(aList,level=0):
    
    for z in aList:
        a,b,c = z
        print('*** kind',a)
        if type(b) in (type(()),type([])):
            for z2 in b:
                a1,b1,c1 = z2
                if a1.startswith('@menu') and type(b1) in (type(()),type([])):
                    print()
                    print('*** inner menu: %s' % (level+1))
                    print(a1)
                    for z3 in b1:
                        print(z3)
                    if c1: print(c1)
                else:
                    print(z2)
            if c: print(c)
        else:
            print(b)
        print()
        break #
        
printMenusList(c.config.getMenusList())
       
#@+node:ekr.20120117095916.10140: *5* @test printInverseBindingDict
print('\ninverseBindingDict...\n')

d = c.k.computeInverseBindingDict()

for key in sorted(list(d.keys())):

    if 1 == len(d.get(key)):
        print(key,d.get(key))
    else:
        print()
        print(key)
        print(d.get(key))
        print()
#@+node:ekr.20120123113111.10925: *5* @test printBindingsDict
import leo.core.leoConfig as leoConfig # for ShortcutInfo
    
partial = True

d = c.k.bindingsDict
    # Keys are shortcuts; values are *lists* leoConfig.ShortcutInfo objects.
    
print('\nk.bindingsDict%s...\n' % ' (partial)' if partial else '')
    
for key in list(sorted(d.keys())):
    aList = d.get(key,[])
    for b in aList:
        assert isinstance(b,leoConfig.ShortcutInfo)
        if not partial or b.kind != 'leosettings.leo':
            print(b)
#@+node:ekr.20120117095916.10141: *5* @test printMasterBindingsDict
partial = True

panes = ('all','body','button','log','tree','text',
    'command','insert','overwrite',)

d = c.k.masterBindingsDict
    # Keys are scope names (in panes) or mode names.
    # Values are dicts:
        # keys are strokes; values are leoConfig.ShortcutInfo objects.
        
print('\nk.masterBindingsDict%s...\n' % ' (partial)' if partial else '')

for pane in sorted(list(d.keys())):
    kind = 'pane' if pane in panes else 'mode'
    print('%s: %s...' % (kind,pane))
    d2 = d.get(pane)
    for stroke in sorted(list(d2.keys())):
        b = d2.get(stroke)
        if not partial or b.kind != 'leosettings.leo':
            print('%6s %25s %17s %s' % (b.pane,stroke,b.kind,b.commandName))
            assert b.pane == pane
            assert b.stroke == stroke
    print()
#@+node:ekr.20120126080450.10187: *4* @ignore passed
#@+node:ekr.20120126080450.10189: *5* @test mode-related info
@

g.app.config.modeCommandsDict
    Keys are command names: enter-x-mode.
    Values are inner dictionaries:
        Keys are command names, values are lists of ShortcutInfo nodes.
@c

d = g.app.config.modeCommandsDict
    
for key in sorted(d.keys()):
    print('*** mode ***',key)
    d2 = d.get(key)
    for key2 in sorted(d2.keys()):
        aList = d2.get(key2)
        print(key2)
        for si in aList:
            print('   ',si)
#@+node:ekr.20120120095156.10262: *5* @test types of contents of settings dicts
@
ivar                    Keys                Values
----                    ----                ------
c.commandsDict          command names (1)   functions
k.inverseCommandsDict   func.__name__       command names
k.bindingsDict          shortcuts           list of ShortcutInfo objects
k.masterBindingsDict    scope names (2)     inner masterBindingDicts (3)
k.masterGuiBindingsDict strokes             list of widgets in which stoke is bound
k.settingsNameDict (4)  settings.lower()    "Real" Tk specifiers
inverseBindingDict (5)  command names       lists of tuples (pane,key)
modeCommandsDict (6)    command name (7)    inner modeCommandsDicts (8)

Notes:
(1) Command names are minibuffer names (strings)
(2) Scope names are 'all','text',etc.
(3) inner masterBindingDicts: Keys are strokes; values are ShortcutInfo objects.
(4) k.settingsNameDict has no inverse.
(5) inverseBindingDict is **not** an ivar: it is computed by k.computeInverseBindingDict.
(6) A global dict: g.app.gui.modeCommandsDict
(7) enter-x-command
(8) Keys are command names, values are lists of ShortcutInfo objects.
@c

si_type = c.k.ShortcutInfo
disabled_func_type = None # Should be any bound method.
k = c.k

@others

test_dict_of_objects(c.commandsDict,type('s'),disabled_func_type,'commandsDict')
test_dict_of_objects(k.inverseCommandsDict,type('s'),type('s'),'inverseCommandsDict')
test_dict_of_lists(k.bindingsDict,si_type,'bindingsDict')
test_dict_of_dicts(k.masterBindingsDict,si_type,'masterBindingsDict')
test_dict_of_lists(k.masterGuiBindingsDict,None,'masterGuiBindingsDict')
test_dict_of_objects(k.settingsNameDict,type('s'),type('s'),'settingsNameDict')
test_dict_of_lists(k.computeInverseBindingDict(),type(tuple()),'inverseBindingDict')

# Test individual dicts separately.
d = g.app.config.modeCommandsDict
test_dict_of_dicts(d,None,'modeCommandsDict')
for key in sorted(d.keys()):
    d2 = d.get(key)
    test_dict_of_lists(d2,si_type,'inner modeCommandsDict')
        # This requires a hack to special-case the
        # '*entry-commands*' and '*command-prompt*' keys.
#@+node:ekr.20120126080450.10193: *6* test_dict_of_dicts
def test_dict_of_dicts(d,theType,tag):

    assert d,tag

    for key in d.keys():
        d2 = d.get(key)
        assert type(d2) == type({})
        for key in d2.keys():
            obj = d2.get(key)
            if theType:
                assert type(obj) == theType,repr(obj)
#@+node:ekr.20120126080450.10191: *6* test_dict_of_lists
def test_dict_of_lists(d,theType,tag):

    assert d,tag

    for key in d.keys():
        obj = d.get(key)
        if key in ('*entry-commands*','*command-prompt*'):
            # Special case for g.app.config.modeCommandsDict
            assert type(obj)==type([]),repr(obj)
        else:
            assert type(obj) == type([])
            # Don't check types of list elements if theType is None.
            if theType:
                for z in obj:
                    assert type(z)==theType,'key: %s obj: %s' % (key,repr(obj))
#@+node:ekr.20120126080450.10195: *6* test_dict_of_objects
def test_dict_of_objects(d,keyType,valueType,tag):

    assert d,tag

    for key in d.keys():
        assert type(key) == keyType,repr(key)
        obj = d.get(key)
        # Don't check type of obj if valueType is None.
        if valueType:
            assert type(obj) == valueType,'\nobj: %s\nvalueType: %s' % (repr(obj),valueType)
#@+node:ekr.20120126080450.10194: *6* Unused
# import types
# types.ListType does not exist in Python 3.x.
# assert isinstance(aList,list().__class__)
#@+node:ekr.20120127084215.10238: *5* @test merge_settings_dicts
@others

# import os ; os.system('cls')
    
d1 = g.app.config.immutable_leo_settings_shortcuts_dict
d2 = g.app.config.immutable_my_leo_settings_shortcuts_dict
d3 = g.app.config.merge_settings_dicts(d1,d2)

if False:
    patterns = (
        'backward-find-character-extend-selection',
    )
    for pattern in patterns:
        print(dump_dict(d1,pattern,tag='d1'))
        print(dump_dict(d2,pattern,tag='d2'))
        print(dump_dict(d3,pattern,tag='d3'))

test(d1,d2,d3)
#@+node:ekr.20120127145909.10227: *6* dump & dump_dict (@test merge_settings_dicts)
def dump(aList,pattern=None,tag=None):
    
    return '\n'.join([repr(z) for z in aList])
    

def dump_dict(d,pattern=None,tag=None):
    
    result = [] # '\ndump of %s...' % (tag)
    
    for key in d.keys():
        if pattern in (key,None):
            result.append(key)
            aList = d.get(key)
            for z in aList:
                result.append('    %s' % (z))
                
    return '\n'.join(result)
#@+node:ekr.20120127084215.10239: *6* test (@test merge_settings_dicts)
def test(old_d,new_d,result_d):
    
    '''Test that result_d is the result of upating old_d with new_d.
    
    This test is tricky: only inverted dicts have ShortcutInfo nodes as keys.'''
    
    invert,uninvert = g.app.config.invert,g.app.config.uninvert

    # Compute the inversions of all the dicts.
    inv_old,inv_new,inv_res = invert(old_d),invert(new_d),invert(result_d)
    
    # Part 1: Ensure we test all keys.
    keys = list(inv_old.keys())
    keys.extend(list(inv_new.keys()))
    keys.extend(list(inv_res.keys()))
    keys = sorted(list(set(keys)))
    assert None not in keys
    for key in inv_old.keys(): assert key in keys,key
    for key in inv_new.keys(): assert key in keys,key
    for key in inv_res.keys(): assert key in keys,key
    
    # Part 2: Carefully test the inverted result.
    def si_name_key(si): return si.commandName or ''

    for key in keys:
        # Compute the *sorted* list of 
        res_list = sorted(inv_res.get(key,[]),key=si_name_key)
        old_list = sorted(inv_old.get(key,[]),key=si_name_key)
        new_list = sorted(inv_new.get(key,[]),key=si_name_key)
        assert res_list,'no res_list.get(%s)' % (key)
        # if new_list: print(key,dump(new_list))
        if new_list:
            assert new_list == res_list,'key %s\nnew:\n%s\nres:\n%s' % (
                key,dump(new_list),dump(res_list))
        else:
            assert old_list == res_list,'key %s\nold:\n%s\nres:\n%s' % (
                key,dump(old_list),dump(res_list))
    
    # Part 3: Test that result_d == uninvert(invert(result_d)).
    # A.  They must have the same keys.
    unv_res = uninvert(inv_res)
    assert sorted(list(result_d.keys())) == sorted(list(unv_res.keys()))

    # B. The values of for each key must match after being sorted.
    def si_stroke_key(si): return si.stroke or ''
        
    for key in sorted(result_d.keys()):
        res_list = sorted(result_d.get(key,[]),key=si_stroke_key)
        unv_list = sorted( unv_res.get(key,[]),key=si_stroke_key)
        assert res_list == unv_list,'key %s\nres:\n%s\nunv:\n%s' % (
            key,dump(res_list),dump(unv_list))
   
#@+node:ekr.20120203153754.10032: *5* @test KeyStroke
ks = c.k.KeyStroke

@others

a1 = ks('a')
a2 = ks('a')
b1 = ks('b')
assert a1 == a2
d = {}
d[a1] = a1.s
d[a2] = a2.s
d[b1] = b1.s

for key in sorted(d):
    print(key,d.get(key))
#@+node:ekr.20120205022040.17748: *5* @test g.TypedDict
d = g.TypedDictOfLists('ks',type('s'),type(9))
d.add('a',1)
d.add('a',2)
d.add('b',3)

print(d)
for s in sorted(d.keys()):
    print(s,d.get(s,[]))

print('after replace...')
d.replace('a',[8,9,10])

for s in sorted(d.keys()):
    print(s,d.get(s,[]))
#@+node:ekr.20120215062153.14233: *3* @mark-for-unit-tests
#@+node:ekr.20120529105626.10139: *4* @settings
#@+node:ekr.20120529105626.10140: *5* @bool fixedWindow = False
#@+node:ekr.20120529105626.10141: *5* @bool enable-abbreviations = True
#@+node:ekr.20120529105626.10142: *5* @@@enabled-plugins
# Leo loads plugins in the order they appear here.

# Highly-recommended plugins:

plugins_menu.py
free_layout.py # needs to be early
viewrendered.py
mod_scripting.py
bigdash.py
#@+node:ekr.20120529105626.10143: *5* @shortcuts
run-selected-unit-tests-externally = Alt-4 # Standard binding, unchanged.
run-marked-unit-tests-externally = Alt-5
run-marked-unit-tests-locally = Alt-6
#@+node:ekr.20120329072206.9700: ** 4.10
#@+node:ekr.20120322073519.10401: *3* b1
#@+node:ekr.20120318110848.9734: *4* Added import-org-mode script
#@+node:ekr.20120318110848.9735: *5* import-org-mode (command, not used)
class ImportOrgMode:
    @others

def importOrgMode (self,event):
    c = self.c
    self.ImportOrgMode(c).go(c.p)
    c.bodyWantsFocus()

if False and g.app.inScript:
    print('='*40)
    ImportOrgMode(c).test()
    print('done')
#@+node:ekr.20120318110848.9736: *6* ctor
def __init__ (self,c):
    
    self.c = c
#@+node:ekr.20120318110848.9737: *6* go
def go (self,p):
    
    '''Prompt for a file and pass the contents to scan().'''
#@+node:ekr.20120318110848.9738: *6* scan
def scan (self,fn,p,s):

    self.c = c
    root = p.insertAsLastChild()
    root.h = fn
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        g.trace(repr(s))
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1
                level += 1
            if level > len(stack):
                g.trace('bad level',repr(s))
                last = None
            elif level == len(stack):
                last = stack[-1]
                last.b = ''.join(body)
            else:
                last = stack[-1]
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            p = parent.insertAsLastChild()
            p.h = s.strip()
            stack.append(p)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        parent = stack[-1]
        parent.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
#@+node:ekr.20120318110848.9739: *6* test
def test (self):
    
    s = '''
* A1
    a1.1
    a1.2
** B11
** B12
b12.1
*** C121
c121.1
    c121.2
c121.3
* A2
a2.1
** B21
*** C211
c211.1
*** C212
** B22
    b22.1
b22.1
* A3
* A4
a4.1
* A5
** B51
*** C511
**** D5111
***** E51111
** B52
*** C521
c521.1
'''

    tag = 'test-import-org-mode'
    p = g.findNodeAnywhere(c,tag)
    s = g.adjustTripleString(s,-4)
    if p:
        try:
            self.scan('test-file',p,s)
        except Exception:
            c.redraw(p)
    else:
        print('not found: %s' % tag)
#@+node:ekr.20120318110848.9740: *5* @@button import-org-mode
'''Import each file in the files list after the presently selected node.'''


files = (
    r'c:\Users\edreamleo\test\import-org-mode.txt',
    r'c:\Users\edreamleo\test\import-org-mode.txt',
)

@others

for fn in files:
    try:
        root = c.p.copy()
        f = open(fn)
        s = f.read()
        scan(c,fn,s)
        c.selectPosition(root)
    except IOError:
        print('can not open %s' % fn)
#@+node:ekr.20120318110848.9741: *6* scan
def scan (c,fn,s):

    last = root = c.p.insertAsLastChild()
    last.h = g.shortFileName(fn)
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1 ; level += 1
            if level > len(stack):
                g.trace('bad level',repr(s))
            elif level == len(stack):
                last.b = ''.join(body)
            else:
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            last = parent.insertAsLastChild()
            last.h = s.strip()
            stack.append(last)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        last.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
#@+node:ekr.20120318110848.9742: *5* test-import-org-mode
#@+node:ekr.20120318110848.9747: *4* Code for displaying a function call hierarchy in Leo
From Brian Theado

The other day I stumbled across Ville's code in scripts.leo which displays the
output of python's trace module in a leo outline. The output of the trace module
is not very friendly and I didn't find the result very usable. I was inspired to
write some code to translate the output so the tree of function calls is
displayed via Leo headlines. Thanks to Ville for sharing that code. I never
would have figure this out without that starting point.

Just copy (Ctrl-Shift-V) the child outline into a leo outline and hit ctrl-b on
the "call tree" node. The execution tree of the 'scroll-outline-up-line'
minibuffer command will be displayed to stdout and also as a tree of leo
headlines.
#@+node:ekr.20120318110848.9748: *5* call tree
import trace

@language python
@others

# http://docs.python.org/library/trace.html for documentation
# on the trace module
tracer = trace.Trace(countcallers=1)

# Trace a minibuffer command.

# Any function call will work. Leo's minibuffer commands are easily discoverable
# via tab completion and the 'print-commands' command.

#tracer.runfunc(c.executeMinibufferCommand, 'goto-prev-node')
tracer.runfunc(c.executeMinibufferCommand, 'scroll-outline-up-line')

top = p.insertAsLastChild().copy()
top.h = 'trace session'
displayCalltree(top, tracer.results().callers.keys())
c.redraw()
#@+node:ekr.20120318110848.9749: *6* displayCalltree
def displayCalltree(p, callinfo):
   '''
   Converts the function call hierarchy in 'callinfo' into a tree of function
   calls.  The function call tree is displayed to stdout as indented text
   and is inserted as a tree of leo nodes rooted at the given position 'p'
   '''
   callers = [k[0] for k in callinfo]
   callees = [k[1] for k in callinfo]

   # The first set of children will be those that don't have any callers
   # listed in callinfo
   toplevels = list(set(callers) - set(callees))
   positions = {}
   path = []

   # Depth-first traversal of the call hierarchy represented by 'callinfo'
   # 'levels' is a stack which grows during descend and shrinks
   # during ascend.  Each element of 'levels' is a list of unprocessed
   # siblings of each other
   levels = [toplevels]
   while len(levels) > 0:
       while len(levels[-1]) > 0:
           # Process the first element in the 'deepest' (i.e. last) list of siblings
           cur = levels[-1][0]
           levels[-1] = levels[-1][1:]
           indent = " " * 4 * (len(levels)-1)
           if cur not in path:
               if cur in positions.keys():
                   # Function already seen, so make a clone
                   clone = positions[cur].clone()
                   clone.moveToLastChildOf(p)
                   print (indent + "%s %s ..." % cur[1:])
               else:
                   # Haven't seen this function, so insert a new headline
                   p = p.insertAsLastChild().copy()
                   p.h = "%s %s" % cur[1:]
                   print (indent + p.h)

                   # Remember the position so it can be cloned if seen again
                   positions[cur] = p

                   # Find all callees of this function and descend
                   levels.append([c[1] for c in callinfo if c[0] == cur])
                   path.append(cur)
           else:
               r = p.insertAsLastChild().copy()
               r.h = "(recursive call) %s %s" % (cur[1], cur[2])
               print(indent + r.h + "...")

       # Ascend back up one level
       path = path[0:-1]
       p = p.parent()
       levels = levels[0:-1]
#@+node:ekr.20120318110848.9750: *6* trace session
#@+node:ekr.20120314064059.9737: *4* Use ctrl-click to open url's
- (Done) Added the following commands:
    
    - ctrl-click-icon
    - ctrl-click-at-cursor
    - open-url
    - open-url-under-cursor
    
- (Done) Double-click *only* edits headline.
- (Done) Only look at first line of the body in @url nodes.
- (Done) Ctrl-click in body allows spaces in url's.

#@+node:ekr.20120322073519.10402: *3* final
#@+node:ekr.20120327163022.9737: *4* Bugs
#@+node:ekr.20120322073519.9785: *5* Fixed crasher in flattenOutline
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 553, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 2120, in flattenOutline
    c.importCommands.flattenOutline(fileName)
  File "c:\leo.repo\trunk\leo\core\leoImport.py", line 479, in flattenOutline
    theFile.write(s)
TypeError: must be str, not bytes
#@+node:ekr.20120323110755.9687: *5* Fix viewrendered crash
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoPlugins.py", line 337, in callTagHandler
    result = handler(tag,keywords)
  File "c:\leo.repo\trunk\leo\plugins\viewrendered.py", line 560, in update
    f(s,keywords)
  File "c:\leo.repo\trunk\leo\plugins\viewrendered.py", line 655, in update_graphics_script
    pc.gs = QtGui.QGraphicsScene(pc.splitter)
AttributeError: 'ViewRenderedController' object has no attribute 'splitter'
#@+node:ekr.20120323124339.9722: *5* Fixed(mostly)scrolling problem with multiple editors
@language python
@language rest

Selecting body editor with clicks doesn't save/restore visual ivars.
The solution would be to create a new onClick event handler...

- Removed insert=None,new_p=None args from all versions of setAllText.
  These are entirely misguided, and may have contributed to scrolling problems.
  
  setAllText now *only* sets text, nothing else!

- All calls to leoMoveCursorHelper are follwed by code that updates
  v.insertSpot, v.selectionStart and v.selectionLength.
  
- v.restoreCursorAndScroll now *carefully* restores selection
  based on v.insertSpot, v.selectionStart and v.selectionLength.
  It also restores the scrollbar using v.scrollBarSpot.
  
- < < unselect the old node > > (selectHelper) now *only*
  sets v.scrollBarSpot.
  
#@+node:ekr.20120327062318.9731: *5* Ensure selected @test node is run
In earlier version of Leo if one runs test externally with the selected
position under @test node, that @test was executed with (run-marked-unit-tests-externally)

The fix was to the "important special case" in TM.findAllUnitTestNodes.
#@+node:ekr.20120327062318.9732: *5* Made sure the new load code loads plugins at most once
@language python
@language rest

new load code, double init. for free layout
http://groups.google.com/group/leo-editor/browse_thread/thread/dd16ac6dc1832eb2

bookmarks.py was the culprit. The code in onCreate must test to see if c.free_layout already exists.
#@+node:ekr.20120326061010.9726: *5* fixed problem with file:/// url's on Windows
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/bb063866875a81c3#

In my installation, now on the latest revision ( r5195) I'm still
experiencing an issue with the '@url command' using 'File-URL' in a Windows
environement.

I'm able to create the Leo User documentation locally. - However, when I
try to read the documentation using the 'File-URL'

file:///D:/Branches/leo-editor/leo/doc/html/_build/html/leo_toc.html

I get the following message in the Leo-Log.

<log>

File 'D:\D:\Branches\leo-editor\leo\doc\html\_build\html\leo_toc.html' does not exist

</log>

However if I enter this URL directly into FF it is found and displayed properly.

EKR: Obviously, the 'D:\D:\' is the problem.

The fix is simply to special-case file:/// on Windows in g.computeFileUrl.
#@+node:ekr.20120327163022.9736: *5* fixed get_fn in viewrendered plugin
@language rest
groups.google.com/group/leo-editor/browse_thread/thread/bb063866875a81c3/6162e6108b09428e

The new code is much like g.computeFileUrl.
#@+node:ekr.20120327163022.9741: *5* Restored special case for run-selected-unit-tests
@language rest

Added code to findAllUnitTestNodes to look up the tree for @test & @suite nodes
if none have been found so far.  Only for the run-unit-tests-externally/locally.
#@+node:ekr.20120321174708.9744: *5* Fixed failing unit tests in distro
@nocolor-node

The @test at.readOneAtShadowNode retains @shadow links node
give fail1: test not set up properly.
The outline is then corrupted, causing other unit tests to fail.
The partial solution is not to call the undo command in the finally clause.
#@+node:ekr.20120327163022.9739: *4* Features
#@+node:ekr.20120324124808.9833: *5* Alt-Home & Alt-End collapse all possible nodes
#@+node:ekr.20120326061010.9728: *5* Added g.restore_selection_range
@nocolor-node

If off, only the insert point is restored.

It's kinda pointless to make this a user option.
#@+node:ekr.20120327163022.9738: *4* Home page
#@+node:ekr.20111027103125.16545: *5* Added link to home page from the TOC
#@+node:ekr.20120229173025.20629: *5* Removed online-tutorial link
http://groups.google.com/group/leo-editor/browse_thread/thread/2157d8bfc0f381f1

es, choosing Help-->"Open Online Tutorial" tries to go to a page on
3dTree.com the site for which is no longer held.

Should the Quick Intro be brought back instead? 
#@+node:ekr.20111027103125.16539: *5* Added search box to Leo's home page
<div id="searchbox" style="">
<h3>Quick search</h3>

<form class="search" method="get" action="search.html">

<p class="searchtip" style="font-size: 90%"> Enter search terms or a module, class or function name. </p>
</div>
#@+node:ekr.20111020120612.15896: *5* Added link to glossary from Leo's home page
#@+node:ekr.20111027103125.16544: *5* Added screen shot to Leo's home page
#@+node:ekr.20110930174206.15470: *5* Brought screen shots up to date
#@+node:ekr.20120326061010.9727: *5* Scaled the screenshot on home page
http://groups.google.com/group/leo-editor/browse_thread/thread/ea3c29888d8ac92b

> - Added a full-sized screenshot at the bottom of the page.
>  I'm not sure whether this is a good idea.  What do you think?

Scaled the screen-shot using:

http://stackoverflow.com/questions/3029422/image-auto-resize-to-fit-div-container
#@+node:ekr.20120323124339.9721: *4* Investigated problem with desktop shortcut
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/a03661d8c1eec0c6

I'm experimenting with the latest version (WinXP). This is really odd. If I
launch Leo using the desktop shortcut, I'm not able to open *any* valid
.leo file except  LeoSettings.leo. This is the shortcut:
C:\Python32\pythonw.exe "C:\Program Files\Leo-4.10-b1\launchLeo.py"

However, if I launch using my Windows batch file, I'm able to open all
files as expected. The code is:
C:\Python32\python "C:\Program Files\Leo-4.10-b1\launchLeo.py" %*

Anyone else experiencing this? Any possible explanation?

EKR: Are you doing this in a console window? 

No, that's why I used the batch file so I can launch w/ a console. When I
do, it works fine. 

I just installed on another box w/ Python 2.6.2 That works fine. The other
box has Python 3.2, not sure why that matters, but it might be a clue.
#@+node:ekr.20120327163022.9742: *5* EKR response
@language rest

There are two differences between the two ways of launching.

1. pythonw.exe vs python.exe

2. The former has no "%*" argument.  It's possible that you have no
workbook.leo file in your home directory, which might cause a failure,
iirc.

I suggest first changing pythonw to python.  This will open a console,
but probably too briefly to read.  To fix this, add a -i argument,
which will drop python into interactive mode, which has the side
effect of leaving the console open.  This should tell you why exactly
nothing happens.

I suspect that adding the "%*" argument will fix the problem,
regardless of whether you use pythonw or python.

If not, please feel free to ask more questions.
#@+node:ekr.20120329072206.9701: ** 4.10.1
#@+node:ekr.20120330040023.9780: *3* Bugs
#@+node:ekr.20120330040023.9779: *4* Restore focus on window activation
# Changed: onActivateEvent (qtGui), onDeactivateEvent (qtGui)
#@+node:ekr.20120409074150.9940: *4* The @auto read code now catches failed asserts in import code.
@nocolor-node

If an assert fails, the entire file is read into a single node.
#@+node:ekr.20120409182030.10028: *4* Fixed several problems with c-to-py command
@nocolor-node

An assert failed during scanning in mungeAllFunctions.

Added defensive code to mungeAllFunctions, dedentBlocks and
replaceComments. The new code simply increments a pointer if a "progress"
assert would fail. (The progress assert still exists, as a double-check.)

Fixed bug: the call to u.afterChangeGroup in the go() method is called only once.

Suppress warning messages given by CPrettyPrinter.indent.
#@+node:ekr.20120401144849.10036: *4* Fixed bug 971171: re .leoRecentFiles
@language python
@language rest

If If $(HOME)/.leo/.leoRecentFiles.txt does not exist,
the only recent file ever is the current file
https://bugs.launchpad.net/leo-editor/+bug/971171

The fix: rf.writeRecentFilesFile creates $(HOME)/.leo/.leoRecentFiles.txt if it does not exist.
#@+node:ekr.20120401144849.10035: *4* Fixed bugs 971166 & 979142 re copy/paste
@language python
@language rest

These bugs are really the same bug

Node body contents displayed is unpredictably incorrect
https://bugs.launchpad.net/leo-editor/+bug/979142

Prints to tabs in the Log Pane are UTF-8 encoded
https://bugs.launchpad.net/leo-editor/+bug/971166

The fix was:

1. Use the "slow" code in leoQTextEditWidget.get.
2. Use w.get/setAllText in leoFrame.pasteText.
#@+node:ekr.20120413152012.10048: *4* Minimize scrolling during paste-text
#@+node:ekr.20120427064024.10062: *4* Fixed bug 711158: Warn if same .leo file open in another Leo instance
@language python
@language rest

Warn if same .leo file open in another Leo instance
https://bugs.launchpad.net/leo-editor/+bug/711158


What I did:

- The PickleShareDB object is created even if caching (of files) is disabled.
  This allows us to used g.app.db even when --no-cache is in effect.
  
- Added the three methods in app.Detecting already-open files.
#@+node:ekr.20120520055508.11872: *4* Clear previous focus-border after alt-tab
@nocolor-node

This was a recent problem.  Normally setInputState should *not* set the border.

Added code to eventFilter to call remove_border on focus out.

set-xxx-state commands call setInputState with set_border = True.
#@+node:ekr.20120520055508.11874: *4* Fixed special cases of auto-completion of commands
@nocolor-node

If the user has not typed anything in the minibuffer, <alt-x><tab> returns *all* completions.

Otherwise, if there are no completions, the "Completions" tab is empty, *not* all completions.

This behavior is much more intuitive than the old behavior.

The fix was a new special case in k.computeCompletionList.
#@+node:ekr.20111025141618.16484: *4* Fixed bug 879338: Global tables in leoApp.py should describe all languages known to the colorizer
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/879338

Having the colorizer colorize a language properly gives the false illusion
that Leo "understands" the language.

Supporting the language in the global tables in leoApp.py makes the
illusion a reality.
#@+node:ekr.20120522160137.9908: *5* Notes
@language rest

Rev 5334 is a first draft of a fix of bug 879338:
Global tables in leoApp.py should describe all languages known to the colorizer
https://bugs.launchpad.net/leo-editor/+bug/879338

The essence of the bug fix is that Leo's language-description tables should
contain entries for all .py files in the leo/modes folder. These files
control the colorizer. If Leo's colorizer knows about a language, then Leo
should know as much as possible about the language.

In concept, this is a fairly straightforward process, but there were *many*
details to handle. If you aren't a Leo developer, you might want to stop
reading now...

===== Tables

Fixing this bug required non-trivial changes to the following tables::

    g.app.language_delims_dict
    # Keys are languages, values are 1,2 or 3-tuples of delims.

    g.app.language_extension_dict
    # Keys are language names, values are extensions.

    g.app.self.extension_dict
    # Keys are extensions, values are language names

I used scripts to generate new entries for these tables, but these scripts
can not possibly deal with the all the complications...

Leo uses these tables as follows:

1.  To generate the comment delimiters in sentinels for each language.

Happily, getting the comment delimiters correct was probably the easiest
part, so Leo should continue to write sentinels properly for
previously-know languages. However, I had to take care to preserve the REM,
CWEB, forth and perlpod hacks, so that comment delims would include the
necessary spaces.

2. To associate file extensions with importers.

Knowing about new file extensions doesn't actually allow Leo to import any
new languages. For all languages without an official importer Leo will
simply copy the entire text of the file into a single node, as it always
has.

3. To colorize code.

Leo's colorizer mostly doesn't use these tables: to colorize language x,
the colorizer looks for the file leo/modes/x.py. Thus, these changes
probably do not affect the colorizer at all.

===== Special cases

I did a lot of googling in order to determine the proper file extensions to
use for various language. In the process, I learned that *almost* all
languages described in the leo/modes folder are real, interesting and
useful languages.

However, there at least 5 categories of special cases that affect the
tables:

1. Languages that are really just colorizer modes:

These include embperl, pseudoplain and phpsection. We need entries in
leo/modes for these, but they aren't real languages and thus they should
not appear in the language-description tables.

2. Things that might be colorized but aren't real languages.

Afaik, the following are not real languages, and Leo would never have to
generate files in these languages: cvs_commit,dsssl,relax_ng_compatc and svn_commit.

Notes:

- relax_ng_compact is an xml schema.

- The rtf colorizer is *not* a colorizer for binary .rtf file format, is a
  colorizer for .rtf sources. It probably won't do too much harm to retain
  the colorizer data for these languages, but I wouldn't mind eliminating
  them either.

3.  Unknown languages.

A few languages seem not really to exist: freemarker, hex, jcl, progress, props.

4. Languages without real comment delimiters.

Patch annotations are *not* real comment delimiters, so Leo could not
generate patch (.fix or .patch) files from an outline. Happily, there is no
need to do so.

5. Conflicting file extensions.

There are two separate kinds of problems:

A. Leo contains colorizers for several assembly languages. Typically,
assembly languages have .asm or .a file extensions. However, a particular
extension can only be associated with a single language name. Thus, Leo has
no way of knowing what language to associate with .asm or .a files. So I
just punted and didn't make any association at all.

B. Both the rebol and r languages use the .r file extension. One of Leo's
users previously created an entry for rebol, so that's the language that
takes precedence.
#@+node:ekr.20120523114117.10885: *5* Removed unused files from leo/modes directory
@language rest

Remove all .xml files in the leo/modes directory.

Imo, this should have been done long ago, for at least the following
reasons:

- These files are part of the jEdit project.
- They are used only by the jedit2py script in scripts.leo.
- The colorizer doesn't use them.
- Bug fixes to the colorizer are made to the .py files, not to the .xml files.
- We can always get updated versions of the .xml files from the jEdit
  project in the unlikely event that we ever need them again.

2. Remove the following .py files from the leo/modes directory:
cvs_commit.py, dsssl.py, freemarker.py, hex.py, jcl.py, progress.py,
props.py and svn_commit.py.

Notes:

- embperl.py, phpsection.py and pseudoplain.py will *not* be removed;
they are internal colorizer states.

- relax_ng_compact.py will be removed if it is not used by any other
colorizer.

- patch.py and rtf.py colorizers will be retained, even though Leo can
never generate such files. 
#@+node:ekr.20120522024827.9900: *5* Scripts
#@+node:ekr.20111021035504.9469: *6* Script: get all comments from modes (slow)
@language python

'''Slow script.'''

import glob
import imp

@others

if 0: # The other script is much faster.
    
    keys = ("lineComment","commentStart","commentEnd",)
    d = {}
        # Keys are language names.
        # Values are a list of comment delims, in keys order.
    
    paths,modes_path = get_paths()
    for path in paths:
        module_name = g.shortFileName(path)[:-3]
        module = import_module(module_name,modes_path)
        aList = []
        for key in keys:
            val = module.properties.get(key)
            if val: aList.append(val)
        d[module_name] = aList
    
    print('-'* 20)
    print('language_delims_dict')
    for key in sorted(d):
        print('%16s: "%s"' % ('"%s"' % (key),' '.join(d.get(key))))
#@+node:ekr.20111021035504.9470: *7* get_paths
def get_paths():
    
    modes_path = g.os_path_finalize_join(g.app.loadDir,'..','modes')
    pattern = g.os_path_finalize_join(modes_path,'*.py')
    paths = glob.glob(pattern)
    paths = [z for z in paths if not z.endswith('__init__.py')]
    return paths,modes_path
#@+node:ekr.20111021035504.9471: *7* import_module
def import_module(module_name,modes_path):
    
    data = imp.find_module(module_name,[modes_path])
        # This can open the file.
    theFile,pathname,description = data
    module = imp.load_module(module_name,theFile,pathname,description)
    return module
#@+node:ekr.20110528103005.18319: *6* Script to create global data structures from in modes/*.py files
@language python

'''Script to create global data structures from modes/*.py files.'''

import glob
import imp

g.cls()

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
aList = glob.glob(theDir)

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes')

# print('-'*40)
known_keys = list(g.app.language_delims_dict.keys())
new_languages = {}

for z in aList:
    name = g.os_path_basename(z)
    name2 = name[:-3]
    if name2 in known_keys or name2.startswith('__'):
        if 0: print('ignore: %s' % (name2))
    else:
        try:
            theFile, pathname, description = imp.find_module(name2,[theDir])
            m = imp.load_module(name2, theFile, pathname, description)
            if hasattr(m,'properties'):
                # new_languages.append(name2)
                new_languages[name2] = m
            else:
                print('no properties: %s %s' % (name2,m))
        except Exception:
            g.es_exception()
            
print('%s new languages\n' % (len(list(new_languages.keys()))))
    
for key in sorted(new_languages.keys()):
    m = new_languages.get(key)
    aList2 = [m.properties.get(z)
        for z in ('lineComment','commentStart','commentEnd')
            if m.properties.get(z)]
    print('%-20s : "%s",' % (
        '"%s"' % (key),
        ' '.join(aList2)))
    # computed[name2] = ' '.join(aList2)
       
if 0:
    mismatches = 0
    print()
    for z in known_keys:
        val = g.app.language_delims_dict.get(z)
        val2 = computed.get(z)
        if not val:
            print('no val',z)
        elif not val2:
            print('no val2',z)
        elif val != val2:
            mismatches += 1
            print('mismatch for %s. expected %s got %s' % (z,repr(val),repr(val2)))
            print(repr(val))
            print(repr(val2))
    print('%s mismatches' % mismatches)
#@+node:ekr.20120522160137.9914: *5* @test consistency of leoApp tables
@
language_delims_dict 
    # Keys are languages, values are 1,2 or 3-tuples of delims. 
language_extension_dict
    # Keys are languages, values are extensions.
extension_dict = {
    # Keys are extensions, values are languages.
@c

delims_d    = g.app.language_delims_dict
lang_d      = g.app.language_extension_dict
ext_d       = g.app.extension_dict

for lang in lang_d:
    ext = lang_d.get(lang)
    assert lang in delims_d,'fail 1: %s' % lang
    assert ext in ext_d,'fail 2: %s' % ext
for ext in ext_d:
    lang = ext_d.get(ext)
    assert lang in lang_d,'fail 3: %s' % lang
#@+node:ekr.20120524082434.9920: *4* Fixed crash after viewrendered-hide
#@+node:ekr.20120523095917.9905: *4* Fixed bug: elected node was not always restored properly
@nocolor-node

The bug was in chapter.findPositionInChapter.
#@+node:ekr.20120525051746.9982: *4* Fixed bug 998090: save file as doesn't remove entry from open file list
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/998090
save file as doesn't remove entry from open file list

Save file as leaves the file's previous path in g.app.db.openFiles, so
that next time the original file's opened you get a "already open"
message.
#@+node:ekr.20120308120323.9864: *4* Wont Fix bug 903640: Import of Python files containing the strings "<<" and ">>" does not work
@nocolor-node

See: https://bugs.launchpad.net/leo-editor/+bug/903640
Import of Python files containing the strings "<<" and ">>" does not work

At present @auto can import .py files containing self.cprint("<<" + ret +
">>\n")

Furthermore, it's possible to write such files properly after changing
them.

Thus, this bug seems to have been completely fixed, as far as @auto goes.

However, *importing* the file with Leo's import-file command does fail (an
@ignore is inserted). This is expected: unlike @auto, the import command
creates an @file node, so the "perfect import" check will complain that the
section called << ret >> is undefined.

I am going to close this item. I see no real need to support other section
delimiters in external files. If there ever becomes a real need to do so, a
separate wishlist item will be appropriate.
#@+node:ekr.20120418065452.10029: *4* Fixed bug 981849: incorrect body content shown
@language python
@language rest

https://bugs.launchpad.net/leo-editor/+bug/981849

The original fix was misguided. It attempted to use more careful code in
setSelectionRangeHelper & lengthHelper.
    
The new fix avoids messing with the viewport in both setEditorColors methods:

leo-editor thread: opening new top level windows
http://groups.google.com/group/leo-editor/browse_thread/thread/8f5f6c72d8716b33

The key is to use a descriptor in LeoQTextBrowser stylesheets.  Example::

'LeoQTextBrowser { << the actual stylesheet >> }

See http://stackoverflow.com/questions/9554435/qtextedit-background-color-change-also-the-color-of-scrollbar


    
#@+node:ekr.20111022215436.16685: *5* Borders (qtGui)
def add_border(self,c,w):

    trace = True and not g.unitTesting
    state = c.k and c.k.unboundKeyAction
    
    if state and c.use_focus_border:
        d = {
            'command':  c.focus_border_command_state_color,
            'insert':   c.focus_border_color,
            'overwrite':c.focus_border_overwrite_state_color,
        }
        color = d.get(state,c.focus_border_color)
        sheet = "border: %spx solid %s" % (c.focus_border_width,color)
        self.update_style_sheet(w,'border',sheet,selector=w.__class__.__name__)

def remove_border(self,c,w):

    if c.use_focus_border:
        sheet = "border: %spx solid white" % c.focus_border_width
        self.update_style_sheet(w,'border',sheet,selector=w.__class__.__name__)
#@+node:ekr.20110605121601.18126: *5* setEditorColors (leoQtHeadlineWidget)
def setEditorColors(self,bg,fg):
    
    obj = self.widget # A QLineEdit
    
    # g.trace('(leoQtHeadlineWidget)',bg,fg)

    def check(color,kind,default):
        if not QtGui.QColor(color).isValid():
            if color not in self.badFocusColors:
                self.badFocusColors.append(color)
                g.es_print('invalid head %s color: %s' % (
                    kind,color),color='blue')
            color = default
        return color

    bg = check(bg,'background','white')
    fg = check(fg,'foreground','black')

    # if hasattr(obj,'viewport'):
        # obj = obj.viewport()
    
    obj.setStyleSheet('background-color:%s; color: %s' % (bg,fg))
#@+node:ekr.20110605121601.18187: *5* setEditorColors (qtBody)
def setEditorColors (self,bg,fg):
    
    trace = False and not g.unitTesting
    
    obj = self.bodyCtrl.widget # A QTextEditor or QTextBrowser.
    
    class_name = obj.__class__.__name__
    if  class_name != 'LeoQTextBrowser':
        if trace: g.trace('unexpected object',obj)
        return
    
    def check(color,kind,default):
        if color in ('none','None',None):
            return default
        if QtGui.QColor(color).isValid():
            return color
        if color not in self.badFocusColors:
            self.badFocusColors.append(color)
            g.es_print('invalid body %s color: %s' % (
                kind,color),color='blue')
        return default

    bg = check(bg,'background','white')
    fg = check(fg,'foreground','black')
    
    if trace: g.trace(bg,fg)

    # Set the stylesheet only for the QTextBrowser itself,
    # *not* the other child widgets:
    # See: http://stackoverflow.com/questions/9554435/qtextedit-background-color-change-also-the-color-of-scrollbar
        
    sheet = 'background-color: %s; color: %s' % (bg,fg)
    g.app.gui.update_style_sheet(obj,'colors',sheet,selector='LeoQTextBrowser')
#@+node:ekr.20111026115337.16528: *5* update_style_sheet (qtGui)
def update_style_sheet (self,w,key,value,selector=None):
    
    trace = False and not g.unitTesting
    
    # Step one: update the dict.
    d = hasattr(w,'leo_styles_dict') and w.leo_styles_dict or {}

    d[key] = value
    aList = [d.get(key) for key in list(d.keys())]
    w.leo_styles_dict = d
    
    # Step two: update the stylesheet.
    s = '; '.join(aList)
    
    if selector:
        s = '%s { %s }' % (selector,s)

    if trace:
        g.trace('\nold: %s\nnew: %s' % (str(w.styleSheet()),s))

    w.setStyleSheet(s)
#@+node:ekr.20120602154454.10193: *4* Fixed import problems discovered by importing 2to3
@language rest

** Not all import problems can be fixed automatically! **

- Added perfectImportFlag. (There was already an importing flag).

- Fixed bug in Fixed underindent convention:

    undentBy adds a period; parseUnderindentTag removes the period.
    
- @file read code must *regenerate* the \\- convention.

    This is done by readNormalLine.
    
    - Fixed an unrelated bug in g.computeWidth.  All unit tests pass.

    - Created g.computeLeadingWhitespaceWidth.
    
- some docstrings are not imported properly in py2_test_grammar.py

    The must be fixed by hand, using @raw and @end_raw.

- escapeFalseSectionReferences now is a do-nothing:
    
    It never generates @verbatim sentinels during import.
#@+node:ekr.20120605185352.10283: *5*  Notes: do not delete
@language rest

Rev 5378: cleanup-imported-nodes script in scripts.leo & an Aha
http://groups.google.com/group/leo-editor/browse_thread/thread/77b9df4f4ed6dba0

> The third (and I think last) import fail involves not generating
> @verbatim sentinels when importing files.

Fixed in the trunk at rev 5386.

This is (to me) a really interesting dark corner of Leo's import code.

By searching for @verbatim, I discovered a method called
escapeFalseSectionReferences.  This method inserts an @verbatim
"directive" before lines that look like section references.

This is wrong for multiple reasons.  It confuses the importer, there
is no such thing as an @verbatim directive, and worst, it fails to
solve the essential problem, which is that before the imported file is
saved, the **user** must fix the problem!

For example, when importing a line like::

  a = x << y >> z

The user, and *only* the user, should change this to something like::

   a = x << y \
   >> z # EKR

I suppose each importer could figure out a language-specific
workaround, but imo this isn't particularly important, for reasons
which will become clearer below.

So now escapeFalseSectionReferences is a do-nothing.

With this explanation, perhaps the checkin log will make sense::

QQQQQ
Fixed another import fail in an "interesting" way: the import code no
longer inserts @verbatim. This means a later write of the imported
will fail. This is correct!

Indeed, the failed write is the only way to alert the user that the
code must be revised by hand.

Note that another import fail, involving a leading '@' on a line in a
docstring, must also be fixed by hand. In lib2to3/pgen/grammar.py the
*only* possible fix is to enclose the entire docstring at the end of
the file by @raw and @end_raw.

All unit tests pass, but no new tests have been added so far.
QQQQQ

The other import fail mentioned in the checkin log is a truly
fascinating case, one that no amount of AI could possibly discover the
correct fix.

At the very end of lib2to3/pgen/grammar.py the following code
(shortened a bit) appears at the top level::

   opmap_raw = """
   ( LPAR
   ) RPAR
   [snip]
   @ AT
   [snip]
   == EQEQUAL
   != NOTEQUAL
   """
   opmap = {}
   for line in opmap_raw.splitlines():
       if line:
           op, name = line.split()
           opmap[op] = getattr(token, name)

There are several things to notice about this code:

1. It contains a line starting with '@'.  Sooner or later, this is
going to cause problems for either Leo's import code or Leo's write
code.

2. It's overly clever, but it's overly clever for a reason: it's
testing tokenizing logic.

3. The code at the end of the file assumes that all lines of the
docstring are 2-tuples.

For these reasons, the one and *only* possible way to make Leo write
this code correctly is to enclose the *entire* docstring in @raw and
@end_raw directives.  Like this::

   @raw
   opmap_raw = """
   ( LPAR
   ) RPAR
   [snip]
   @ AT
   [snip]
   == EQEQUAL
   != NOTEQUAL
   """
  @end_raw

In particular, surrounding the line "@ AT" with @raw/@end_raw
directives will cause 2to3 to fail on startup:  the Leo sentinel lines
will not be 2-tuples!

===== Important Conclusions

All this picky detail illustrates a crucial fact.  No matter how good
Leo's importers are, (and they are now quite good), there will
*always* be cases where thoughtful human intervention will be
required.

Furthermore, the simplest thing that could possibly work is for the
importers to allow some constructions that are guaranteed to cause
problems later, when the user attempts to write the file.  We hope
that Leo will complain about certain constructions, but Leo may not be
able to complain about all constructions.

Thus, some import mistakes can *only* be found by running tests.  For
complex programs like 2to3, the only truly safe way to check imports
is by running the 2to3 test suite.
#@+node:ekr.20120921145435.10607: *4* Fixed activateMenu
@nocolor-node
The trick is to find the wrapper first: it is *also* a QMenu.
We can then call menuBar.setActiveAction on its action!!
#@+node:ekr.20110605121601.18361: *5* leoQtMenu.activateMenu
def activateMenu (self,menuName):

    '''Activate the menu with the given name'''
    
    c = self.c
    menu = self.getMenu(menuName)
    if menu:
        menubar = c.frame.top.leo_menubar
        # Important: self is a leoQtMenu, **not** an instance of QMenu.
        # Find the qtMenuWrapper (a subclass of both QMenu and leoQtMenu).
        for child in menubar.children():
            if (
                hasattr(child,'leo_menu_label') and
                child.leo_menu_label.lower() == menuName.lower()
            ):
                action = child.menuAction()
                if action:
                    menubar.setActiveAction(action)
                else:
                    g.trace('can not happen: no action for menu %s = %s' % (
                        menuName,child))
                return
       
    g.trace('No such top-level menu: %s' % (menuName))
#@+node:ekr.20120519193038.9883: *3* Code
#@+node:ekr.20110518103946.18179: *4* Added external/leosax.py to leoPyRef.leo
http://groups.google.com/group/leo-editor/browse_thread/thread/93f2cc88ebbf9893
#@+node:ekr.20120529040553.10140: *4* Added local pylint suppressions
The format of such local suppressions is::

    # pylint: disable=<message-number>
#@+node:ekr.20120529083658.11110: *3* Docs
#@+node:ekr.20120529083658.11109: *4* For the FAQ: create a bzr repository before importing it into Leo
@language rest

When I study a program, I like to import it into Leo.  I have several
scripts that do this:  some create @auto nodes; others create @file
nodes.

Either way, the import process has the potential to change many
files.  Usually, I just change @auto and @file to @@auto or @@file, so
that any changes I make while studying the code won't affect the
originals.

But this "safety first" approach means that I can't actually use Leo
to insert tracing statements (or for any other changes.)  A few days
ago, I found a way to import "live" code into Leo safely:

   Create a bzr repository for the code before importing it

The Aha is to create the repository *wherever the code is*, including,
say, python/Lib/site-packages.

- bzr qdiff ensures that import hasn't significantly altered the code,
- bzr revert undoes any unwise or unwanted changes.

This is exactly what I need:  I can make changes to important tools
*safely* within Leo.
#@+node:ekr.20120330040023.9781: *3* Features
#@+node:ekr.20120409074150.9941: *4* baseNativeTree.onHeadChanged now truncates headlines
@nocolor-node

The new code works like leoTree.onHeadChanged.

The code can be called twice, so it is a bit tricky
to only issue warnings once.
#@+node:ekr.20120411095406.10036: *4* Sorted statistics in profile_leo
#@+node:ekr.20120410175141.10027: *4* Added --no-plugins option
#@+node:ekr.20120305084218.9915: *4* Show all commands after <alt-x><tab>
@nocolor-node

A simple change to k.computeCompletionList was all that was needed.

#@+node:ekr.20111017132257.15891: *4* IPython now works with all versions of IPython
@nocolor-node

Changed:

- init (qtGui.py top level) (qtPdb)
- runMainLoop (qtGui)
- start_new_api
#@+node:ekr.20120330110655.10023: *5*  Notes
@language rest

Investigate how IPython hijacks event loops
http://groups.google.com/group/leo-editor/browse_thread/thread/e1dc6439bf8b17f9

pyos_inputhook is relevant

IPython lib.inputhook
http://ipython.org/ipython-doc/stable/api/generated/IPython.lib.inputhook.html


* IPython seems to require Python 2.x.
* I can run IPython from either C:\prog\ipython-0.12 or from python\lib\site-packages

From C:\prog\ipython-0.12\IPython\scripts

#!/usr/bin/env python
"""Terminal-based IPython entry point.
"""

from IPython.frontend.terminal.ipapp import launch_new_instance

launch_new_instance()

Here is ipapi.get::

@language python

    def get():
        """Get the global InteractiveShell instance."""
        from IPython.core.interactiveshell import InteractiveShell
        return InteractiveShell.instance()
#@+node:ekr.20120401144849.10152: *5*  What I did
@language rest

- Import logic looks for legacy IPython first (0.11 and prev),
  then looks for new-style IPython (0.12 and above).

- Created GlobalIPythonManager class, assigned to leoIPython.gipm and g.app.gipm.

- Added self.c ivar to LeoNode class.  This is the same as p.v.context.
#@+node:ekr.20120330110655.10025: *5* @url ipython api
http://ipython.org/ipython-doc/rel-0.12/api/index.html
#@+node:ekr.20120330110655.10024: *5* @url ipython-dev archive
http://mail.scipy.org/pipermail/ipython-dev/
#@+node:ekr.20120330110655.10026: *5* @url ipython.core.interactiveshell
http://ipython.org/ipython-doc/rel-0.12/api/generated/IPython.core.interactiveshell.html
#@+node:ekr.20120419095424.9924: *4* Integrated free_layout into Leo's core
#@+node:ekr.20120429125741.10056: *4* created parse-body command
@nocolor-node

Useful for re-parsing text that was not originally parsed properly.
#@+node:ekr.20120517124200.9985: *4* Supported vimoutliner imports and @auto-otl
@nocolor-node

Created vimoutlinerScanner.

Created at.writeAtAutoOtlFile.
#@+node:ekr.20120519114248.9886: *4* Change focus-border color depending on input state
@nocolor-node

Leo now supports two new setting, with the indicated default::

    @color focus_border_command_state_color = blue
    @color focus_border_overwrite_state_color = green

This works in conjunction with the existing border-color setting::

    @color focus_border_color = red

So by default, the color border is red when in insert state, and blue
if in command state.

This allows the focus border to change color depending on whether we
are in input or command mode.  This is a workaround for the (extreme)
difficulty of changing cursors depending on mode.

When used to distinguish insert from command modes, I recommend
changing the existing setting::

    @int focus_border_width = 1

to::

    @int focus_border_width = 2

This makes the focus border much more visible, and makes the color
changes obvious.

I tested this code without changing bindings using the set-command-
state command.

As before, if you don't want any such colored borders, just do::

    @bool use_focus_border = False 
#@+node:ekr.20120529105626.10145: *5* What I did
Changed set-xxx-state & setInputState.

Changed qtGui.add_border and remove_border.
#@+node:ekr.20120519114248.9887: *4* Fully support :: convention in @mode nodes
@nocolor-node

If the @mode headline contains ::, everything following
the :: is the mode prompt. For example::
    
    @mode abc :: xyz
    
Creates the enter-abc-mode command, but the prompt for the command is xyz.

ParserBaseClass.createModeCommand creates this convention.
Changed k.modeHelpHelper.
#@+node:ekr.20120420095827.9947: *4* Completed the new support for sessions
@nocolor-node

(Done) Changed es so it always queues messages when g.app.log is None.
(Done) complete the command-line args: --session-save and --session-restore.
(Done) Write session info in leoTabbedTopLevel.closeEvent and g.app.onQuit.

Rev 5324 finishes some session-related work. The existing
session commands are unchanged, but Leo now fully supports
two new command-line arguments::

    --session-restore     restore previously saved session tabs at startup
    --session-save        save session tabs on exit

If you use both arguments, everything is automatic: Leo
saves the tabs when you quit Leo, and restores tabs when you
start Leo. Note that you can still specify file names on the
command line in addition to whatever files --session-restore
will open for you.

If you use only --session-restore, it is up to you to save
sessions "by hand" with one of the session commands, for
instance, session-snapshot-save.
#@+node:ekr.20111017102409.15875: *4* Created print-buttons command
@nocolor-node

Created print-buttons command, showing source of all @command and @button nodes.

Changed ParserBaseClass.doButtons/doCommands so they return
lists of (p.copy(),script) rather than (p.h,script)

Added g.app.config.atLocalButtonsList & g.app.config.atLocalCommandsList
for use by print-buttons command.
#@+node:ekr.20120522160137.9907: *4* Completed apropos-regular-expressions command
#@+node:ekr.20120523133829.14118: *4* Supported ctrl-clicks in vr panes
#@+node:ekr.20120524082434.9923: *4* All viewrended commands now start with vr
#@+node:ekr.20120524082434.12620: *4* help-for-command executes apropos commands
Instead of just printing their docstrings.
#@+node:ekr.20120525051746.9983: *4* Fixed bug 994985: Wishlist: normalize-whitespace
@nocolor-node

https://bugs.launchpad.net/bugs/994985
Wishlist: normalize-whitespace

When using @auto, the logic often complains about "abnormal" whitespace and
refuses to write/read node normally.

What I did:
    
1. The clean-lines command (and thus the clean-all-lines command)
   now remove trailing whitespace while preserving newlines.
   
2. reportMismatch suggests using the clean-all-lines command.
   Note: a good unit test for reportMismatch already exists.
   
3. Added a unit test for clean-lines.
#@+node:ekr.20120519114248.9885: *4* Improved incremental search commands
@nocolor-node

- Documented that return ends the search.
- Documented that deleting the entire search pattern aborts the search.
- Removed annoying status messages printed to log.

- (Can't do) If text is already highlighted, Alt-S or Alt-R should use that text.

#@+node:ekr.20120321174708.9743: *4* Added docstrings for all commands
@nocolor-node

Help-for command translate !<command-name>! in the docstring to the binding for command-name.
#@+node:ekr.20070521105645: *4* investigated epydoc
@language rest

http://sourceforge.net/forum/message.php?msg_id=4319363

http://epydoc.sourceforge.net/epydoc.html
By: ktenney

epydoc doesn't seem active.  It produces interesting web sites,
but a find-def function in Leo itself would be more useful.

#@+node:ekr.20120527053550.10118: *5* Fixed epydoc crash
The easy solution, as revealed on StackOverflow is to edit the offending
line to catch the error:

# markup/restructuredtext.py, line 307
<   m = self._SUMMARY_RE.match(child.data)
---
>   try:
>      m = self._SUMMARY_RE.match(child.data)
>   except AttributeError:
>      m = None

#@+node:ekr.20120415133744.10050: *4* Made sure tab completion only happens on explicit tab
@language python

# Don't show full completion list when the minibuffer becomes empty.
#@+node:ekr.20061031131434.111: *5* fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    trace = False and not g.unitTesting
    verbose = True
    k = self ; c = k.c ; gui = g.app.gui
    recording = c.macroCommands.recordingMacro
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    c.check_event(event)
    ch = char = event and event.char or ''
    stroke = event and event.stroke or None

    if trace: g.trace('recording',recording,'state',state,char)
    
    # 2011/06/06: remember these events also.
    if recording:
        c.macroCommands.startRecordingMacro(event)
        
    if state > 0:
        k.setLossage(char,stroke)
    
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif char == 'Ins' or k.isFKey(char):
        pass
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n','Return'):
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif char in ('\t','Tab'):
        if trace and verbose: g.trace('***Tab')
        k.doTabCompletion(list(c.commandsDict.keys()),allow_empty_completion=True)
        c.minibufferWantsFocus()
    elif char in ('\b','BackSpace'):
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return # (for Tk) 'break'
#@+node:ekr.20061031131434.112: *6* callAltXFunction
def callAltXFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event and event.widget
        if hasattr(w,'permanent') and not w.permanent:
            g.es('Can not execute commands from headlines')
        else:
            c.widgetWantsFocusNow(event and event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(commandName)
    else:
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
#@+node:ekr.20061031131434.128: *5* k.getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    trace = False and not g.app.unitTesting
    state = k.getState('getArg')
    
    c.check_event(event)
    
    # 2011/06/06: remember these events also.
    if c.macroCommands.recordingMacro and state > 0:
        c.macroCommands.startRecordingMacro(event)

    char = event and event.char or ''
    if state > 0:
        k.setLossage(char,stroke)
    
    if trace: g.trace(
        'state',state,'char',repr(char),'stroke',repr(stroke),
        'isPlain',k.isPlainKey(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)

    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n','Return',) or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes:
            k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = char ##
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        if trace: g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif char in('\t','Tab'):
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif char in ('\b','BackSpace'):
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        pass
        # 2011/03/01: ignore F-keys. Ignoring all except plain keys would kill unicode searches.
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return # (for Tk) 'break'
#@+node:ekr.20061031131434.129: *6* << init altX vars >>
k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@+node:ekr.20061031131434.178: *5* k.doTabCompletion
# Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList,redraw=True,allow_empty_completion=False):

    '''Handle tab completion when the user hits a tab.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel().strip()

    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        if trace: g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex >= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        if redraw:
            if trace: g.trace('** recomputing default completions')
            k.computeCompletionList(defaultTabList,
                backspace=False,
                allow_empty_completion=allow_empty_completion)

    c.minibufferWantsFocus()
#@+node:ekr.20061031131434.175: *5* k.computeCompletionList
# Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace,allow_empty_completion=False):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)
    c.frame.log.clearTab(tabName)
    
    if trace:
        g.trace('command',command)
        g.trace('common_prefix',common_prefix)
        g.trace('k.mb_tabList',k.mb_tabList)
    
    if not k.mb_tabList and allow_empty_completion:
        if command:
            # 2012/05/20: Put up an *empty* list as a visual cue.
            k.mb_tabList = []
            g.es('','\n',tabName=tabName)
        else:
            # 2012/05/20: Return *all* completions if the command is empty.
            k.mb_tabList = sorted(defaultTabList)
            common_prefix = ''

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.
        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)

        inverseBindingDict = k.computeInverseBindingDict()
        data,n = [],0
        for commandName in k.mb_tabList:
            dataList = inverseBindingDict.get(commandName,[('',''),])
            for z in dataList:
                pane,key = z
                s1a = '%s ' % (pane) if pane != 'all:' else ''
                s1b = k.prettyPrintKey(key)
                s1 = s1a + s1b
                s2 = commandName
                data.append((s1,s2),)
                n = max(n,len(s1))
        aList = ['%*s %s' % (-n,s1,s2) for s1,s2 in data]
        g.es('','\n'.join(aList),tabName=tabName)
    c.bodyWantsFocus()
#@+node:ekr.20061031131434.177: *5* k.doBackSpace
# Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList,completion=True):

    '''Cut back to previous prefix and update prefix.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c ; w = self.w

    # Step 1: actually delete the character.
    ins = w.getInsertPoint()
    s = w.getAllText()

    if trace: g.trace('ins',ins,'k.mb_prefix',repr(k.mb_prefix),
        'w',w)

    if ins <= len(k.mb_prefix):
        # g.trace('at start')
        return
    i,j = w.getSelectionRange()
    if i == j:
        ins -= 1
        w.delete(ins)
        w.setSelectionRange(ins,ins,insert=ins)
    else:
        ins = i
        w.delete(i,j)
        w.setSelectionRange(i,i,insert=ins)

    # Step 2: compute completions.
    if not completion: return
    k.mb_tabListPrefix = w.getAllText()
    k.computeCompletionList(defaultCompletionList,backspace=True)
#@+node:ekr.20120622075651.10000: *4* Added c2 keyword arg to c.bringToFront
#@+node:ekr.20080514131122.20: *5* c.outerUpdate
def outerUpdate (self):

    trace = False and not g.unitTesting
    verbose = True ; traceFocus = True
    c = self ; aList = []
    if not c.exists or not c.k:
        return

    # Suppress any requested redraw until we have iconified or diconified.
    redrawFlag = c.requestRedrawFlag
    c.requestRedrawFlag = False
    
    if trace and (verbose or aList):
        g.trace('**start',c.shortFileName() or '<unnamed>',g.callers(5))
    
    if c.requestBringToFront:
        if hasattr(c.frame,'bringToFront'):
            ### c.frame.bringToFront()
            c.requestBringToFront.frame.bringToFront()
                # c.requestBringToFront is a commander.
        c.requestBringToFront = None

    # The iconify requests are made only by c.bringToFront.
    if c.requestedIconify == 'iconify':
        if verbose: aList.append('iconify')
        c.frame.iconify()

    if c.requestedIconify == 'deiconify':
        if verbose: aList.append('deiconify')
        c.frame.deiconify()

    if redrawFlag:
        if trace: g.trace('****','tree.drag_p',c.frame.tree.drag_p)
        # A hack: force the redraw, even if we are dragging.
        aList.append('*** redraw')
        c.frame.tree.redraw_now(forceDraw=True)

    if c.requestRecolorFlag:
        aList.append('%srecolor' % (
            g.choose(c.incrementalRecolorFlag,'','full ')))
        # This should be the only call to c.recolor_now.
        c.recolor_now(incremental=c.incrementalRecolorFlag)

    if c.requestedFocusWidget:
        w = c.requestedFocusWidget
        if traceFocus: aList.append('focus: %s' % (
            g.app.gui.widget_name(w)))
        c.set_focus(w)
    else:
        # We must not set the focus to the body pane here!
        # That would make nested calls to c.outerUpdate significant.
        pass

    if trace and (verbose or aList):
        g.trace('** end',aList)

    c.incrementalRecolorFlag = False
    c.requestRecolorFlag = None
    c.requestRedrawFlag = False
    c.requestedFocusWidget = None
    c.requestedIconify = ''
    mods = g.childrenModifiedSet
    if mods:
        #print(mods)
        g.doHook("childrenModified",c=c, nodes = mods)
        mods.clear()
    mods = g.contentModifiedSet
    if mods:
        #print(mods)
        g.doHook("contentModified",c=c, nodes = mods)
        mods.clear()

    # g.trace('after')
#@+node:ekr.20080514131122.8: *5* c.bringToFront
def bringToFront(self,c2=None,set_focus=True):

    c = self
    c2 = c2 or c
    c.requestBringToFront = c2
    c.requestedIconify = 'deiconify'
    c.requestedFocusWidget = c2.frame.body.bodyCtrl
    g.app.gui.ensure_commander_visible(c2)

BringToFront = bringToFront # Compatibility with old scripts
#@+node:ekr.20120622075651.10001: *4* Added default button to dialog methods
#@+node:ekr.20031218072017.3730: *5* app.gui dialogs
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    """Create and run Leo's About Leo dialog."""
    self.oops()

def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    self.oops()

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self,c,title,message,cancelButtonText=None,okButtonText=None):
    """Create and run askOkCancelNumber dialog ."""
    self.oops()

def runAskOkCancelStringDialog(self,c,title,message,cancelButtonText=None,
                               okButtonText=None,default=""):
    """Create and run askOkCancelString dialog ."""
    self.oops()

def runAskYesNoDialog(self,c,title,message=None):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    self.oops()

def runPropertiesDialog(self,title='Properties', data={}, callback=None, buttons=None):
    """Dispay a modal TkPropertiesDialog"""
    self.oops()
#@+node:ekr.20031218072017.3744: *5* dialogs (nullGui)
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    return self.simulateDialog("aboutLeoDialog")

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog")

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    return self.simulateDialog("okDialog","Ok")

def runAskOkCancelNumberDialog(self,c,title,message,cancelButtonText=None,okButtonText=None):
    return self.simulateDialog("numberDialog",-1)

def runAskOkCancelStringDialog(self,c,title,message,cancelButtonText=None,
                               okButtonText=None,default=""):
    return self.simulateDialog("stringDialog",'')

def runCompareDialog(self,c):
    return self.simulateDialog("compareDialog",'')

def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False,startpath=None):
    return self.simulateDialog("openFileDialog")

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):
    return self.simulateDialog("saveFileDialog")

def runAskYesNoDialog(self,c,title,message=None):
    return self.simulateDialog("yesNoDialog","no")

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    return self.simulateDialog("yesNoCancelDialog","cancel")
#@+node:ekr.20110605121601.18487: *5* Dialogs & panels (qtGui)
#@+node:ekr.20110605121601.18488: *6* alert (qtGui)
def alert (self,c,message):

    if g.unitTesting: return

    b = QtGui.QMessageBox
    d = b(None)
    d.setWindowTitle('Alert')
    d.setText(message)
    d.setIcon(b.Warning)
    yes = d.addButton('Ok',b.YesRole)
    c.in_qt_dialog = True
    d.exec_()
    c.in_qt_dialog = False
#@+node:ekr.20110605121601.18489: *6* makeFilter
def makeFilter (self,filetypes):

    '''Return the Qt-style dialog filter from filetypes list.'''

    filters = ['%s (%s)' % (z) for z in filetypes]

    return ';;'.join(filters)
#@+node:ekr.20110605121601.18492: *6* qtGui panels
def createComparePanel(self,c):

    """Create a qt color picker panel."""
    return None # This window is optional.
    # return leoQtComparePanel(c)

def createFindTab (self,c,parentFrame):
    """Create a qt find tab in the indicated frame."""
    return leoQtFindTab(c,parentFrame)

def createLeoFrame(self,c,title):
    """Create a new Leo frame."""
    gui = self
    return leoQtFrame(c,title,gui)

def createSpellTab(self,c,spellHandler,tabName):
    return leoQtSpellTab(c,spellHandler,tabName)

#@+node:ekr.20110605121601.18493: *6* runAboutLeoDialog
def runAboutLeoDialog(self,c,version,theCopyright,url,email):

    """Create and run a qt About Leo dialog."""

    if g.unitTesting: return None

    b = QtGui.QMessageBox
    d = b(c.frame.top)

    d.setText('%s\n%s\n%s\n%s' % (
        version,theCopyright,url,email))
    d.setIcon(b.Information)
    yes = d.addButton('Ok',b.YesRole)
    d.setDefaultButton(yes)
    c.in_qt_dialog = True
    d.exec_()
    c.in_qt_dialog = False
#@+node:ekr.20110605121601.18496: *6* runAskDateTimeDialog
def runAskDateTimeDialog(self, c, title, 
    message='Select Date/Time', init=None, step_min={}):
    """Create and run a qt date/time selection dialog.

    init - a datetime, default now
    step_min - a dict, keys are QtGui.QDateTimeEdit Sections, like
      QtGui.QDateTimeEdit.MinuteSection, and values are integers,
      the minimum amount that section of the date/time changes
      when you roll the mouse wheel.

    E.g. (5 minute increments in minute field):

        print g.app.gui.runAskDateTimeDialog(c, 'When?',
          message="When is it?",
          step_min={QtGui.QDateTimeEdit.MinuteSection: 5})

    """

    class DateTimeEditStepped(QtGui.QDateTimeEdit):
        """QDateTimeEdit which allows you to set minimum steps on fields, e.g.
          DateTimeEditStepped(parent, {QtGui.QDateTimeEdit.MinuteSection: 5})
        for a minimum 5 minute increment on the minute field.
        """
        def __init__(self, parent=None, init=None, step_min={}):

            self.step_min = step_min
            if init:
                QtGui.QDateTimeEdit.__init__(self, init, parent)
            else:
                QtGui.QDateTimeEdit.__init__(self, parent)

        def stepBy(self, step):
            cs = self.currentSection()
            if cs in self.step_min and abs(step) < self.step_min[cs]:
                step = self.step_min[cs] if step > 0 else -self.step_min[cs]
            QtGui.QDateTimeEdit.stepBy(self, step)

    class Calendar(QtGui.QDialog):
        def __init__(self, parent=None, message='Select Date/Time',
            init=None, step_min={}):
            QtGui.QDialog.__init__(self, parent)

            layout = QtGui.QVBoxLayout()
            self.setLayout(layout)

            layout.addWidget(QtGui.QLabel(message))

            self.dt = DateTimeEditStepped(init=init, step_min=step_min)
            self.dt.setCalendarPopup(True)
            layout.addWidget(self.dt)

            buttonBox = QtGui.QDialogButtonBox(
            QtGui.QDialogButtonBox.Ok
                | QtGui.QDialogButtonBox.Cancel)
            layout.addWidget(buttonBox)

            self.connect(buttonBox, QtCore.SIGNAL("accepted()"),
                self, QtCore.SLOT("accept()"))
            self.connect(buttonBox, QtCore.SIGNAL("rejected()"),
                self, QtCore.SLOT("reject()"))

    if g.unitTesting: return None

    b = Calendar
    if not init:
        init = datetime.datetime.now()
    d = b(c.frame.top, message=message, init=init, step_min=step_min)

    d.setWindowTitle(title)
    
    c.in_qt_dialog = True
    val = d.exec_()
    c.in_qt_dialog = False

    if val != d.Accepted:
        return None
    else:
        return d.dt.dateTime().toPyDateTime()
#@+node:ekr.20110605121601.18494: *6* runAskLeoIDDialog
def runAskLeoIDDialog(self):

    """Create and run a dialog to get g.app.LeoID."""

    if g.unitTesting: return None

    message = (
        "leoID.txt not found\n\n" +
        "Please enter an id that identifies you uniquely.\n" +
        "Your cvs/bzr login name is a good choice.\n\n" +
        "Leo uses this id to uniquely identify nodes.\n\n" +
        "Your id must contain only letters and numbers\n" +
        "and must be at least 3 characters in length.")
    parent = None
    title = 'Enter Leo id'
    s,ok = QtGui.QInputDialog.getText(parent,title,message)
    return g.u(s)
#@+node:ekr.20110605121601.18491: *6* runAskOkCancelNumberDialog (changed)
def runAskOkCancelNumberDialog(self,c,title,message,cancelButtonText=None,okButtonText=None):

    """Create and run askOkCancelNumber dialog ."""

    if g.unitTesting: return None
    
    # n,ok = QtGui.QInputDialog.getDouble(None,title,message)
    d = QtGui.QInputDialog()
    d.setWindowTitle(title)
    d.setLabelText(message)
    if cancelButtonText:
        d.setCancelButtonText(cancelButtonText)
    if okButtonText:
        d.setOkButtonText(okButtonText)
    ok = d.exec_()
    n = d.textValue()
    try:
        n = float(n)
    except ValueError:
        n = None
    return n if ok else None
#@+node:ekr.20110605121601.18490: *6* runAskOkCancelStringDialog (changed)
def runAskOkCancelStringDialog(self,c,title,message,cancelButtonText=None,
                               okButtonText=None,default=""):

    """Create and run askOkCancelString dialog ."""

    if g.unitTesting: return None

    d = QtGui.QInputDialog()
    d.setWindowTitle(title)
    d.setLabelText(message)
    d.setTextValue(default)
    if cancelButtonText:
        d.setCancelButtonText(cancelButtonText)
    if okButtonText:
        d.setOkButtonText(okButtonText)
    ok = d.exec_()
    return str(d.textValue()) if ok else None
#@+node:ekr.20110605121601.18495: *6* runAskOkDialog
def runAskOkDialog(self,c,title,message=None,text="Ok"):

    """Create and run a qt askOK dialog ."""

    if g.unitTesting: return None

    b = QtGui.QMessageBox
    d = b(c.frame.top)

    d.setWindowTitle(title)
    if message: d.setText(message)
    d.setIcon(b.Information)
    yes = d.addButton(text,b.YesRole)
    c.in_qt_dialog = True
    d.exec_()
    c.in_qt_dialog = False

#@+node:ekr.20110605121601.18497: *6* runAskYesNoCancelDialog
def runAskYesNoCancelDialog(self,c,title,
    message=None,
    yesMessage="&Yes",noMessage="&No",defaultButton="Yes"
):

    """Create and run an askYesNo dialog."""

    if g.unitTesting: return None

    b = QtGui.QMessageBox

    d = b(c.frame.top)
    if message: d.setText(message)
    d.setIcon(b.Warning)
    d.setWindowTitle(title)
    yes    = d.addButton(yesMessage,b.YesRole)
    no     = d.addButton(noMessage,b.NoRole)
    cancel = d.addButton(b.Cancel)
    if   defaultButton == "Yes": d.setDefaultButton(yes)
    elif defaultButton == "No": d.setDefaultButton(no)
    else: d.setDefaultButton(cancel)
    c.in_qt_dialog = True
    val = d.exec_()
    c.in_qt_dialog = False

    if   val == 0: val = 'yes'
    elif val == 1: val = 'no'
    else:          val = 'cancel'
    return val
#@+node:ekr.20110605121601.18498: *6* runAskYesNoDialog
def runAskYesNoDialog(self,c,title,message=None):

    """Create and run an askYesNo dialog."""

    if g.unitTesting: return None

    b = QtGui.QMessageBox
    d = b(c.frame.top)

    d.setWindowTitle(title)
    if message: d.setText(message)
    d.setIcon(b.Information)
    yes = d.addButton('&Yes',b.YesRole)
    no  = d.addButton('&No',b.NoRole)
    d.setDefaultButton(yes)
    c.in_qt_dialog = True
    val = d.exec_()
    c.in_qt_dialog = False
    return g.choose(val == 0,'yes','no')

#@+node:ekr.20110605121601.18499: *6* runOpenDirectoryDialog (qtGui)
def runOpenDirectoryDialog(self,title,startdir):

    """Create and run an Qt open directory dialog ."""

    parent = None
    s = QtGui.QFileDialog.getExistingDirectory (parent,title,startdir)
    return g.u(s)
#@+node:ekr.20110605121601.18500: *6* runOpenFileDialog (qtGui)
def runOpenFileDialog(self,title,filetypes,defaultextension='',multiple=False,startpath=None):

    """Create and run an Qt open file dialog ."""
    
    if g.unitTesting:
        return ''
    else:
        if startpath is None:
            startpath = os.curdir
            
        parent = None
        filter = self.makeFilter(filetypes)
    
        if multiple:
            lst = QtGui.QFileDialog.getOpenFileNames(parent,title,startpath,filter)
            return [g.u(s) for s in lst]
        else:
            s = QtGui.QFileDialog.getOpenFileName(parent,title,startpath,filter)
            return g.u(s)
#@+node:ekr.20110605121601.18501: *6* runPropertiesDialog (qtGui)
def runPropertiesDialog(self,
    title='Properties',data={}, callback=None, buttons=None):

    """Dispay a modal TkPropertiesDialog"""

    # g.trace(data)
    g.es_print('Properties menu not supported for Qt gui',color='blue')
    result = 'Cancel'
    return result,data
#@+node:ekr.20110605121601.18502: *6* runSaveFileDialog (qtGui)
def runSaveFileDialog(self,initialfile='',title='Save',filetypes=[],defaultextension=''):

    """Create and run an Qt save file dialog ."""
    
    if g.unitTesting:
        return ''
    else:
        parent = None
        filter_ = self.makeFilter(filetypes)
        s = QtGui.QFileDialog.getSaveFileName(parent,title,os.curdir,filter_)
        return g.u(s)
#@+node:ekr.20110605121601.18503: *6* runScrolledMessageDialog (qtGui)
def runScrolledMessageDialog (self,
    short_title= '',
    title='Message',
    label= '',
    msg='',
    c=None,**kw
):

    if g.unitTesting: return None

    def send(title=title, label=label, msg=msg, c=c, kw=kw):
        return g.doHook('scrolledMessage',
            short_title=short_title,title=title,
            label=label, msg=msg,c=c, **kw)

    if not c or not c.exists:
        << no c error>>
    else:        
        retval = send()
        if retval: return retval
        << load viewrendered plugin >>
        retval = send()
        if retval: return retval
        << no dialog error >>

    << emergency fallback >>
#@+node:ekr.20110605121601.18504: *7* << no c error>>
g.es_print_error('%s\n%s\n\t%s' % (
    "The qt plugin requires calls to g.app.gui.scrolledMessageDialog to include 'c'",
    "as a keyword argument",
    g.callers()
))
#@+node:ekr.20110605121601.18505: *7* << load viewrendered plugin >>
pc = g.app.pluginsController
# 2011/10/20: load viewrendered (and call vr.onCreate)
# *only* if not already loaded.
if not pc.isLoaded('viewrendered.py'):
    vr = pc.loadOnePlugin('viewrendered.py')
    if vr:
        g.es('viewrendered plugin loaded.', color='blue')
        vr.onCreate('tag',{'c':c})
#@+node:ekr.20110605121601.18506: *7* << no dialog error >>
g.es_print_error(
    'No handler for the "scrolledMessage" hook.\n\t%s' % (
        g.callers()))
#@+node:ekr.20110605121601.18507: *7* << emergency fallback >>
b = QtGui.QMessageBox
d = b(None) # c.frame.top)
d.setWindowFlags(QtCore.Qt.Dialog) # That is, not a fixed size dialog.

d.setWindowTitle(title)
if msg: d.setText(msg)
d.setIcon(b.Information)
yes = d.addButton('Ok',b.YesRole)
c.in_qt_dialog = True
d.exec_()
c.in_qt_dialog = False
#@+node:ekr.20120912094259.10550: *4* Added support for @testclass
@nocolor-node
@

@testclass nodes should set either the suite or testclass vars.

@suite nodes should set the suite var.
#@+node:ekr.20120912094259.10546: *5* makeTestClass
def makeTestClass (self,p):

    """Create a subclass of unittest.TestCase"""

    c,tm = self.c,self
    fname = 'makeTestClass'
    p = p.copy()
    script = g.getScript(c,p).strip()
    if not script:
        print("nothing in %s" % p.h)
        return None
    try:
        script = script + tm.get_test_class_script()
        script = script + tm.get_suite_script()
        d = {'c':c,'g':g,'p':p,'unittest':unittest}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            if g.isPython3:
                exec(compile(script,scriptFile,'exec'),d)
            else:
                execfile(scriptFile,d)
        else:
            exec(script + '\n',d)
        testclass = g.app.scriptDict.get('testclass')
        suite = g.app.scriptDict.get('suite')
        if suite and testclass:
            print("\n%s: both 'suite' and 'testclass defined in %s" % (
                fname,p.h)) 
        elif testclass:
            suite = unittest.TestLoader().loadTestsFromTestCase(testclass)
            return suite
        elif suite:
            return suite
        else:
            print("\n%s: neither 'suite' nor 'testclass' defined in %s" % (
                fname,p.h))
            return None
    except Exception:
        print('\n%s: exception creating test class in %s' % (fname,p.h))
        g.es_print_exception()
        return None
#@+node:ekr.20051104075904.4: *5* TM.doTests & helpers (local tests)
def doTests(self,all=None,marked=None,verbosity=1):
    
    '''Run any kind of local unit test.
    
    Important: this is also called from dynamicUnitTest.leo
    to run external tests "locally" from dynamicUnitTest.leo
    '''

    trace = False ; verbose = True
    c,tm = self.c,self

    p1 = c.p.copy() # 2011/10/31: always restore the selected position.
    
    # This seems a bit risky when run in unitTest.leo.
    if not c.fileName().endswith('unitTest.leo'):
        if c.isChanged():
            c.save() # Eliminate the need for ctrl-s.
    
    if trace: g.trace('marked',marked,'c',c)

    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = c.p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)
        aList = tm.findAllUnitTestNodes(all,marked)
       
        found = False
        for p in aList:
            if tm.isTestNode(p):
                if trace: g.trace('adding',p.h)
                test = tm.makeTestCase(p)
            elif tm.isSuiteNode(p): # @suite
                if trace: g.trace('adding',p.h)
                test = tm.makeTestSuite(p)
            elif tm.isTestClassNode(p):
                if trace: g.trace('adding',p.h)
                test = tm.makeTestClass(p) # A suite of tests.
            else:
                test = None
            if test:
                suite.addTest(test)
                found = True
        
        # Verbosity: 1: print just dots.
        if not found:
            # 2011/10/30: run the body of p as a unit test.
            if trace: g.trace('no found: running raw body')
            test = tm.makeTestCase(c.p)
            if test:
                suite.addTest(test)
                found = True
        if found:
            res = unittest.TextTestRunner(verbosity=verbosity).run(suite)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
                c.cacher.db[key] = archive
        else:
            g.es_print('no %s@test or @suite nodes in %s outline' % (
                g.choose(marked,'marked ',''),
                g.choose(all,'entire','selected')),color='red')
    finally:
        c.setChanged(changed) # Restore changed state.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.contractAllHeadlines()
            c.redraw(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20120912094259.10549: *6* get_suite_script
def get_suite_script(self):
    
    s = '''
    
try:
    g.app.scriptDict['suite'] = suite
except NameError:
    pass
    
'''
    return g.adjustTripleString(s, self.c.tab_width)
#@+node:ekr.20120912094259.10547: *6* get_test_class_script
def get_test_class_script(self):
    
    s = '''
    
try:
    g.app.scriptDict['testclass'] = testclass
except NameError:
    pass
    
'''
    return g.adjustTripleString(s,self.c.tab_width)
#@+node:ekr.20051104075904.13: *6* makeTestCase
def makeTestCase (self,p):

    c = self.c
    p = p.copy()

    if p.b.strip():
        return generalTestCase(c,p)
    else:
        return None
#@+node:ekr.20120912094259.10546: *6* makeTestClass
def makeTestClass (self,p):

    """Create a subclass of unittest.TestCase"""

    c,tm = self.c,self
    fname = 'makeTestClass'
    p = p.copy()
    script = g.getScript(c,p).strip()
    if not script:
        print("nothing in %s" % p.h)
        return None
    try:
        script = script + tm.get_test_class_script()
        script = script + tm.get_suite_script()
        d = {'c':c,'g':g,'p':p,'unittest':unittest}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            if g.isPython3:
                exec(compile(script,scriptFile,'exec'),d)
            else:
                execfile(scriptFile,d)
        else:
            exec(script + '\n',d)
        testclass = g.app.scriptDict.get('testclass')
        suite = g.app.scriptDict.get('suite')
        if suite and testclass:
            print("\n%s: both 'suite' and 'testclass defined in %s" % (
                fname,p.h)) 
        elif testclass:
            suite = unittest.TestLoader().loadTestsFromTestCase(testclass)
            return suite
        elif suite:
            return suite
        else:
            print("\n%s: neither 'suite' nor 'testclass' defined in %s" % (
                fname,p.h))
            return None
    except Exception:
        print('\n%s: exception creating test class in %s' % (fname,p.h))
        g.es_print_exception()
        return None
#@+node:ekr.20051104075904.12: *6* makeTestSuite
# This code executes the script in an @suite node.
# This code assumes that the script sets the 'suite' var to the test suite.

def makeTestSuite (self,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    c,tm = self.c,self
    fname = 'makeTestSuite'
    p = p.copy()
    script = g.getScript(c,p).strip()
    if not script:
        print("no script in %s" % p.h)
        return None
    try:
        script = script + tm.get_suite_script()
        d = {'c':c,'g':g,'p':p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            if g.isPython3:
                exec(compile(script,scriptFile,'exec'),d)
            else:
                execfile(scriptFile,d)
        else:
            exec(script + '\n',d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("\n%s: %s script did not set suite var" % (fname,p.h))
        return suite
    except Exception:
        print('\n%s: exception creating test cases for %s' % (fname,p.h))
        g.es_print_exception()
        return None
#@+node:ekr.20120602062004.13335: *3* Scripts
#@+node:ekr.20111019104425.15893: *4* Added jinja2 templating script to scripts.leo
Should Leo support a standard template tool?
http://groups.google.com/group/leo-editor/browse_thread/thread/dd629473f4b3c4fc

Added a jinja2 templating example.  See:
    
file://../scripts/scripts.leo#Scripts-->@thin%20leoScripts.txt-->Important-->Prototype%20of%20jinja%20@command%20nodes
#@+node:ekr.20120531092617.10141: *4* Added cleanup-imported-nodes script to scripts.leo
@nocolor-node

The script itself is in scripts.leo: cleanup-imported-nodes

- Put docstring in root node.
- Use section reference for declarations.
- Remove leading and trailing blank lines from all nodes, leaving only a trailing newline.
- If a new contains nothing but comments, merge it with the next node.
- If a node contains nothing but a property, merge it with the previous node.

The holy grail would be to do all this in the Python importer, but a post-processing script suffices.

Workflow:
    
1. bzr checkin of all *unchanged* file.
2. Import all files and save.
3. bzr commit all changed files.
4. Run cleanup script.
5. bzr qdiff then shows all cleanups.
6. bzr commit if all goes well.
#@-all

# Put this @language after the @all as a kind of permanent unit test.

#@@language python # Override the default .txt coloring.

#@@pagewidth 60
#@-leo
