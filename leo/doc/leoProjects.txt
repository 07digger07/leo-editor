#@+leo-ver=5-thin
#@+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
#@+all
#@+node:ekr.20130926125247.11505: ** b2/final projects
@language rest

#@+node:ekr.20130928060535.11401: *3* Fixed problems with c.save commands in the leoBridge
@language rest

To emphasize what is said below in the checkin log, there is a systemic
problem with the leoBridge module: it uses a nullGui in which all dialogs
are do-nothings. This will affect all commands, such as c.save, etc., that
may (or may not) ask the user for input.

The workaround I used for c.save, c.saveAs and c.saveTo was to add a
"fileName" keyword arg, so that code using a commander returned by
leoBridge can just demand that a certain fileName be used. This is as far
as I am willing to go for the 4.11 release.

The following test, call it leo-bridge-test.py, passes::

@language python

# Do *not* execute this from inside Leo!
if __name__ == '__main__':
    import os
    import sys
    sys.path.insert(0,'c:/leo.repo/trunk/leo')
    import leo.core.leoBridge as leoBridge
    print(leoBridge)
    cc = leoBridge.controller(gui='nullGui',verbose=False)
    g = cc.globals()
    print(g)
    path = 'c:/Users/edreamleo/does-not-exist.leo'
    assert not os.path.exists(path),path
    assert not g.os_path_exists(path),path
    c = cc.openLeoFile(path)
    root = c.rootPosition()
    assert root
    root.h = 'root'
    p = root.insertAsLastChild()
    p.h = 'A'
    assert p and p.h
    if 0:
        for p in c.all_positions():
            print(p.h)
    path = 'c:/Test/leo-bridge-test.leo'
    c.save(fileName=path)
    assert os.path.exists(path),path
    assert g.os_path_exists(path),path
    os.remove(path)
    assert not os.path.exists(path),path
    assert not g.os_path_exists(path),path
    c.saveAs(fileName=path)
    assert os.path.exists(path),path
    assert g.os_path_exists(path),path
    c.saveTo(fileName=path)
    assert os.path.exists(path),path
    assert g.os_path_exists(path),path
#@+node:ekr.20130930062914.15958: *3* Added c.user_dict and g.user_dict
There are non-persistent Python dicts, for free use by plugins and scripts.
#@+node:ekr.20130908104426.11255: *3* Fixed bug 1168689 re ipython
@language rest

1168689 outdated documentation about ipython
https://bugs.launchpad.net/leo-editor/+bug/1168689

Changed runWithIpythonKernel, LM.initApp, app.finishQuit.
Added commanders property.

Injects only _leo into the IPython namespace
_leo.c is a property
The getter returns the single element of _leo.commanders_list
or a commander set previously by the setter.
    
_leo.commanders is a read-only property returning _leo.commanders_list
after first doing an update.

-----

The highlights of the changes:

1. leo.core.leoIPython.py now contains *all* of Leo's IPython-related code.
   The setup code comes mainly from leo.plugins.internal_ipkernel.py.

2. internal_ipkernel.py still exists (it will go away soon), but it has has
   been completely disabled as follows::

    if 0:
        @others

3. When the --ipython command-line argument is in effect, g.app.ipk is a
   *singleton* IPython shell, shared by any and all IPython consoles.

4. The startup code injects only a single object, _leo, into the IPython
   namespace. This is an instance of the bulked-up LeoNameSpace class. This
   interface class now contains features that make it easier to deal with
   multiple open Leo commanders.

- _leo.g is set to leoGlobals only once. Not exactly correct, perhaps, but
  nobody will notice.

- _leo.commanders is a (read-only) property returning the list of open
  commanders. This list is always kept up-to-date: it scans
  g.app.windowList before returning its result.

- _leo.c is a (read/write) property returning g.app.windowList[0].c if the
  windowList has only one element, or the "designated commander" if it
  exists. Otherwise, it returns None. In that case, the expectation is that
  the user will "designate" a commander with: _leo.c = aCommander.

- _leo.find_c(path) returns the commander c such that c.fileName() or
  g.shortFileName(c) matches path.

5. Perhaps most importantly, that's *all* there is. In particular, Ville's
   magic functions and LeoWorkbook class are gone.

Imo, the deleted code might better exist as IPython startup code, but I
could be wrong. Furthermore, Leo's p.h and p.b properties are new since
Ville first created the code, and so this kind of support code is less
urgently needed.

If there is a great demand to restore these features, it can always be done
later. For now, though, I wanted to do the simplest thing that could
possibly work.
#@+node:ekr.20131004191204.16076: *3* Fixed crasher in k.auto_completer_state_hander
Happened when user typed tab.
#@-all

# Put this @language after the @all as a kind of permanent unit test.

#@@language python # Override the default .txt coloring.

#@@pagewidth 60
#@-leo
