.. @+leo-ver=5-thin
.. @+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
.. @+all
.. @+node:ekr.20150417044242.1: ** 5.2-b1
.. @+node:ekr.20150512102759.1: *3* Code
.. @+node:ekr.20150512102801.1: *4* Decorators simplify Leo's command dispatching
Please read carefully if you write plugins or are one of Leo's core developers.  Everyone else can safely ignore this post.

The present (g.new_dispatch) project simplifies Leo's code as follows:

1. Decorators will define all Leo commands.  All getPublicCommands methods will disappear, along with their association lists of command names and bound methods.

2. Leo will never call c.universalCallback.

I understand neither it's docstring, nor its code, nor why it is needed. Leo will be better off without it and the corresponding 'wrap' argument to k.registerCommand. This wrapper gives rise to wretched code::

    @g.command('cke-text-open')
    def cmd_OpenEditor(kwargs, at_rich=False):
        '''Open the rich text editor, hide the regular editor.'''
        c = kwargs['c'] if isinstance(kwargs, dict) else kwargs

Apparently, kwargs might be two different kinds of objects depending on who calls the function.  This kind of code must go.  In an emergency, code could add ivars/attributes to exiting events, but even that would be too complex by half.

3. The Plugin class in plugins_menu.py creates Leo commands for functions whose names start with ``cmd_``.  It took me hours yesterday to figure out that this was happening.

<< Look for additional commands >> creates yet another wrapper, with yet another signature. The wrapper now has a more conforming signature and a better name::

    def plugins_menu_wrapper(kwargs, cmd=cmd):
        return cmd(kwargs['c'])

This signature allows a unit test to pass even when plugins_menu_wrapper is not wrapped again.

Happily, all of this is going to go away. ``@g.command`` will define all commands in plugins. No more invisible ``cmd_`` naming convention.

4. class AtButtonCallback now supports the __name__ attribute using a new __getattr__ method. This allows k.registerCommand not to know about the AtButtonCallback wrapper.

5. The LeoKeyEvent class now has a get method.  Code can now call event.get('c') in all cases.  Probably ditto for kwargs.get('c').

**Summary**

The new_dispatch project simplifies some of the most complex code in Leo.  It is worth a week's work.

I followed three principles while simplifying the code:

1. Eliminate malignant if statements::

    c = kwargs['c'] if isinstance(kwargs, dict) else kwargs

proliferates implementation details from one part of Leo to another.  As a result, it becomes much harder to change code without side effects.  I have been dealing with such side effects all week.

2. Regularize interfaces.

- ``@cmd`` or ``@g.command`` decorators will define all Leo commands.
- The ``cmd_`` convention will disappear, along with the complex code that creates it.
- event.get('c') will work in any code decorated by ``@cmd`` or ``@g.command``.
- AtButtonCallback instances now have a __name__.

3. Regularize objects.

Changing the interface of an object by wrapping it is unacceptable. c.universalCallback must go.

.. @+node:ekr.20150513163611.1: *5* What I did
@language rest
@wrap

- Defined all commands in leoPlugins.leo with @g.command.
- Eliminate the "cmd_" convention.
  The g.command decorator now sets func.is_command and func.command_name.
  Plugin.create_menu is now much simpler.
- All decorated commands now use the "event" arg:

    @g.command('command-name')
    def my_command(event=None):
        ...
    
    @cmd('command-name')
    def my_command(self,event=None):
        ...
.. @+node:ekr.20150501041440.1: *4* Reorganized Leo's commands files
The leo/commands directory contains the new code.
.. @+node:ekr.20150503050557.1: *4* re: replace all has_key by "in"
.. @+node:ekr.20150427042446.1: *3* Features
.. @+node:ekr.20150412053053.1: *4* Finished leoOPML plugin
.. @+node:ekr.20150420130845.1: *4* Added File:Print menus
jasonic

Leo deserves good friendly printing features which anyone can use. At the moment we have a confusing patchwork of choices. Printing Leo seems to be both harder and easier than  first meets the eye.

print-to-web (htmlize) should definitely be on Leo's missing PRINT MENU.

Having a little library of export scripts--well named, documented and intended to aid printing woudl go a long way. Thesse scripts anyone coiuld be called by onayone given a Leo Outline, accessing a navabr button. PRINT MENU or list. Or they can just insert the appropriate script  into an outline giving finer grained print control on the fly.
.. @+node:ekr.20150416060248.1: *4* Allow Leo directives in @data abbreviations-subst-env
The fix was to create a dummy root position in abbrev.init_env.
.. @+node:ekr.20150422124650.1: *4* Added c.backup
Useful for per-file backups.
.. @+node:ekr.20150425135844.1: *4* Added support for @data history-list
If you aren't using the @data history-list setting chances are that you missing a big chance to simplify your workflow. At one time I thought the history list was a minor feature.  I could not have been more wrong.

The body of the @data history-list node should contain a list of command names, one per line.  This list can include commands created by @command/@button nodes.

You execute items in the history list by doing Alt-X followed by an up arrow to get the first item in the list, or one or more down arrows to get later items in the list.  The last item you execute from this list goes to the head of the list.  Once you have executed an item, Ctrl-P (repeat complex command) will re-execute it.

The history list works well for commands that aren't quite worth a separate key binding, but that nevertheless you find you using quite often.

Even better, the history list is a perfect complement to @button and @command nodes that are tailored for a particular outline. For example, there is a button called cfa-code in leoPy.leo that executes the clone-find-all-flattened command starting at the top-level "Code" node.
.. @+node:ekr.20150426052139.1: *4* Added @ifenv, improved @ifplatform & @ifhostname
@language rest
@wrap

Here are the details:

@ifenv name, one-or-more-comma-separated values
 
Includes descendant settings if os.getenv(name) matches any of the values.

- Case is significant in the *name* of the environment variable.
- Case is ignored in the *values*.

Examples:

@ifenv HOSTNAME,bob
    Enables descendant settings if os.environ('HOSTNAME') is 'Bob' or 'bob'
   
@ifenv EDITOR,leo,lion
    Enables descendant settings if os.environ('Editor') is 'Leo' or 'Lion', etc.

@ifplatform name,  one-or-more-comma-separated values.
  
Includes descendant settings if sys.platform matches any of the values, ignoring case.

Examples:

@ifplatform darwin,linux2
    Enables descendant settings for MacOS and Linux.

@ifplatform win32
    Enables descendant settings for Windows
  
@ifhostname name

Includes descendant settings if os.environ('HOSTNAME') == name

@ifhostname !name

Includes descendant settings if os.environ('HOSTNAME') != name
.. @+node:ekr.20150211131925.4: *4* abbreviations now support auto-close quotes
https://groups.google.com/d/msg/leo-editor/yJLz-p3I4mY/Pqa1phYN_10J
.. @+node:ekr.20150325052301.1: *4* Added enhancement 165: vim-open-file command
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/165

Later: preserve cursor positions.

All the changes were to the ExternalFilesController class.
.. @+node:ekr.20150530084545.1: *4* Added support for @beautify and @nobeautify
These directives are inherited as usual.
.. @+node:ekr.20150529182422.1: *4* Rewrote Leo's Python beautifier
@language rest
@wrap




.. @+node:ekr.20150609110852.1: *4* Alt-N (goto-next-clone) falls backs to find-next-clone
.. @+node:ekr.20150427042510.1: *3* Bugs Fixed
.. @+node:ekr.20150417045902.1: *4* Recover from orphan bit in leoPyBad.leo
Rev dc1bf6f

The orphan bit was set in @file leoGlobals.py.
This prevented the file from being updated.

Changed:
- at.read.
- at.readAll
- fc.putVnode no longer writes orphan bits.
. VNode constants section: # unused    = 0x10 # (was orphanBit)
.. @+node:ekr.20150417053733.1: *4* Fixed @tabwidth bug
Using c.tab_width is wrong: it is the *default* tab width.

Created c.getTabWidth()
.. @+node:ekr.20150403035558.1: *4* Fixed bug 169: import-file does not preserve gnx of root @file node
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/169
import-file does not preserve gnx of root @file node

The fix was a special case in at.readStartNode.
.. @+node:ekr.20150428112500.1: *4* Fixed abbreviation bugs and improved abbreviations
@language rest
@wrap

The fixes were in abbrev.expandAbbrev and helpers.

Rev 585d2f4 improves abbreviations as follows:

- Match longest prefix first: e;; no longer interferes with date;;
- Predefine 'x' as the empty string before executing abbreviation scripts.
- Split @data abbreviations-subst-env into separate nodes.
- Defined do() and insert() functions in @data abbreviations-subst-env as follows::

@language python

    def do(commandName):
        '''Execute a command by name.'''
        c.k.simulateCommand(commandName,event=None)
    
    def insert(s):
        '''Insert the string s in the current widget.'''
        try:
            w = c.abbrevCommands.w
            if w:
                i = w.getInsertPoint()
                w.insert(i,s)
        except AttributeError:
            pass
            
@language rest
@wrap

Note:  Because of a glitch in how abbreviations scripts are created, you can't do::

    do(['command1','command2'])

even though c.k.simulateCommand allows list arguments.  Instead, do this::

    do('command1');do('command2');

The following abbreviations insert matching characters (no need to do x='' in them)::

    (={|{insert('()');do('back-char')}|}
    [={|{insert('[]');do('back-char')}|}
    {={|{insert('{}');do('back-char')}|}

This is an implementation of auto-close-quotes, done entirely with abbreviations! For example, typing '(' inserts '()' and puts the cursor between the parens.

I personally dislike these abbreviations.  I find it harder to skip past the ')' than to type it later.  ymmv.
.. @+node:ekr.20150428153124.1: *4* Removed warning in at.read about orphan bits
.. @+node:ekr.20150430175300.1: *4* Improved Ctrl-LtArrow
Ctrl-LtArrow and Ctrl-RtArrow leave the cursor at the start of a word.
This is the way most editors work.

The fix was in moveWordHelper.
.. @+node:ekr.20150509180744.1: *4* Fixed remove-blank-lines command
It now works when there is no text selection.
.. @+node:ekr.20150514115247.1: *4* Fixed cut/paste from menus
.. @+node:ekr.20150520071422.1: *4* Fixed bug 150: Importing file to @clean produces section references...
Importing file to @clean produces section references following class constructor
https://github.com/leo-editor/leo-editor/issues/150

The bug was a typo in plugins/importers/basescanner.py.

Also improved reporting in the RecursiveImportController class.
.. @+node:ekr.20150608184148.1: *4* Fixed bug 193: goto-global-line doesn't work properly in @clean files
https://github.com/leo-editor/leo-editor/issues/193
goto-global-line doesn't work properly in @clean files

The fix was in GoToLineNumber.go: it must test for p.isAtCleanNode()
.. @+node:ekr.20150502050809.1: *4* Fixed bug 131: Insert time in headline now inserts time in body
Insert time in headline now inserts time in body
https://github.com/leo-editor/leo-editor/issues/131

The fix was to replace:
    
    w = self.editWidget()
    
by::
    
    w = c.frame.tree.edit_widget(p)
    
    
in editCommands.insertHeadlineTime.
.. @+node:ekr.20150609082814.1: *4* Fixed Bug 162: Valid language list in Docs not up to date
@language rest
@wrap

Valid language list in Docs not up to date
https://github.com/leo-editor/leo-editor/issues/162

cm.isValidLanguage accepts any language x for which leo/modes/X.py exists.

Added a script in LeoDocs.leo that will generate all valid languages.
.. @+node:ekr.20150609111916.1: *4* Fixed bug 195: fcol when using @first directive is inaccurate
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/195
fcol when using @first directive is inaccurate

1. p.textOffset returns None if no @<file> node is an ancestor.
2. p.textOffset never caches its result.
    In any case, it was quite wrong to cache results in positions.
3. Rewrote p.textOffset to simplify it.
4. QtStatusLineClass.update prints '' for fcol if p.textOffset returns None.
5. Changed unit tests accordingly.
.. @+node:ekr.20150609103947.1: *4* Investigated bug 188: Find/Replace All Suboutline only same as Node only
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/188
Find/Replace All Suboutline only same as Node only

This bug appears to be invalid.

.. @-all
.. @@killbeautify
.. @@language rest
.. @@wrap
.. @@pagewidth 60
.. @-leo
