#@+leo-ver=5-thin
#@+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
#@+all
#@+node:ekr.20111103205308.9698: ** Unit tests
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)

s1 = '''
<table id="1"> <table id="2">
<contents/>
</table>
</table>
'''

s2 = '''
<table id="1"> 
<table id="2">
<contents/>
</table>
</table>
'''

t1 = 
assert result == expected,'expected...\n%s\ngot...\n%s' % (
    repr(expected),repr(result))
#@+node:ekr.20100907115157.5905: *3* @ignore Ancient tests
#@+node:ekr.20100208095423.5940: *4* @test leoCache
import leo.core.leoCache as leoCache

cacher = leoCache.cacher(c)

if 0:
    import os
    os.system('cls')

assert cacher.test()
#@+node:ekr.20100906165118.5915: *4* @test leoInkCommands
ic = c.inkscapeCommands
screenshot = r'c:\leo.repo\inkcall\some_screen_shot.png'
template_fn = r'c:\leo.repo\inkcall\template.svg'
png_fn = r'c:\leo.repo\inkcall\output.png'
svg_fn = r'c:\leo.repo\inkcall\temp.svg'
callouts = [
        "This goes here",
        "These are those, but slightly longer",
        "Then you pull this, but this text needs to be longer for testing",]
ic.run(
    screenshot,
    callouts=callouts,
    numbers=[2,4,17],
    edit_flag = True, # True: call inkscape to edit the working file.
    png_fn=png_fn, # Optional: Name of output png file.
    svg_fn=svg_fn, # Optional: Name of working svg file.
    template_fn=template_fn, # Optional: Name of template svg file.
)
#@+node:ekr.20111102123707.9629: *4* @ignore test of marked unit-test trees
#@+node:ekr.20111102123707.9630: *5* @test assert False
assert False
#@+node:ekr.20111102123707.9631: *5* @test assert True
assert True
#@+node:ekr.20111107092526.9799: *4* @test detection of external unit tests
# This test is redundant, and another test sets import_html_tags

# print('g.app.isExternalUnitTest',g.app.isExternalUnitTest)
if g.app.isExternalUnitTest:
    fn = c.shortFileName()
    assert fn.endswith('dynamicUnitTest.leo'),fn
    data = c.config.getData('import_html_tags')
    assert len(data) == 85 # length of data in leoSettings.leo.
else:
    data = c.config.getData('import_html_tags')
    assert len(data) == 85,len(data)
#@+node:ekr.20111107092526.9800: *5* doTests...
def doTests(c,all=None,marked=None,p=None,verbosity=1):

    trace = False ; verbose = False
    if all:
        p = c.rootPosition()
    elif not p:
        p = c.p
    p1 = c.p.copy() # 2011/10/31: always restore the selected position.
    
    g.trace(g.app.isExternalUnitTest)
    
    # This seems a bit risky when run in unitTest.leo.
    # c.save() # Eliminate the need for ctrl-s.
    
    if trace: g.trace('marked',marked,'c',c)

    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)

        # New in Leo 4.4.8: ignore everything in @ignore trees.
        last = None if all else p.nodeAfterTree()
        
        aList = findAllUnitTestNodes(c,p,last,all,marked,
            lookForMark=False,lookForNodes=True)
       
        found = False
        for p in aList:
            if isTestNode(p):
                if trace: g.trace('adding',p.h)
                test = makeTestCase(c,p)
            elif isSuiteNode(p): # @suite
                if trace: g.trace('adding',p.h)
                test = makeTestSuite(c,p)
            else:
                test = None
            if test:
                suite.addTest(test)
                found = True
        
        # Verbosity: 1: print just dots.
        if not found:
            # 2011/10/30: run the body of p as a unit test.
            test = makeTestCase(c,c.p)
            if test:
                suite.addTest(test)
                found = True
        if found:
            res = unittest.TextTestRunner(verbosity=verbosity).run(suite)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
                c.cacher.db[key] = archive
        else:
            g.es_print('no %s@test or @suite nodes in %s outline' % (
                g.choose(marked,'marked ',''),
                g.choose(all,'entire','selected')),color='red')
    finally:
        c.setChanged(changed) # Restore changed state.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.contractAllHeadlines()
            c.redraw(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20111107092526.9801: *6* class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20111107092526.9802: *7* __init__ (generalTestCase)
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@+node:ekr.20111107092526.9803: *7*  fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@+node:ekr.20111107092526.9804: *7* tearDown
def tearDown (self):

    pass

    # Restore the outline.
    self.c.outerUpdate()
#@+node:ekr.20111107092526.9805: *7* setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p.copy()) # 2010/02/03
#@+node:ekr.20111107092526.9806: *7* runTest (generalTestCase)
def runTest (self,define_g = True):

    trace = False
    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)
    
    if c.shortFileName() == 'dynamicUnitTest.leo':
        c.write_script_file = True

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p and p.copy(),'self':self,}
    else:
        d = {'self':self,}

    script = script + '\n'
    if trace: g.trace('p: %s c: %s write script: %s script:\n%s' % (
        p and p.h,c.shortFileName(),c.write_script_file,script))

    # Execute the script. Let the unit test handle any errors!
    # 2011/11/02: pass the script sources to exec or execfile.
    if c.write_script_file:
        scriptFile = c.writeScriptFile(script)
        if g.isPython3:
            exec(compile(script,scriptFile,'exec'),d)
        else:
            execfile(scriptFile,d)
    else:
        exec(script,d)
#@+node:ekr.20111107092526.9807: *7* shortDescription
def shortDescription (self):

    s = self.p.h

    # g.trace(s)

    return s + '\n'
#@+node:ekr.20111107092526.9808: *6* makeTestSuite (leoTest)
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()
    # g.trace('c.write_script_file',c.write_script_file)
    script = g.getScript(c,p).strip()
    if not script:
        print("no script in %s" % h)
        return None
    try:
        if 0: #debugging
            n,lines = 0,g.splitLines(script)
            for line in lines:
                print(n,line)
                n += 1
                
        # 2011/11/02: make script sources available.
        d = {'c':c,'g':g,'p':p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            if g.isPython3:
                exec(compile(script,scriptFile,'exec'),d)
            else:
                execfile(scriptFile,d)
        else:
            exec(script + '\n',d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("makeTestSuite: %s script did not set g.app.scriptDict" % p.h)
        return suite
    except Exception:
        print('makeTestSuite: exception creating test cases for %s' % p.h)
        g.es_exception()
        return None
#@+node:ekr.20111107092526.9809: *6* makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.b.strip():
        return generalTestCase(c,p)
    else:
        return None
#@+node:ekr.20111107092526.9810: *5* main & helpers (leoDynamicTest.py)
def main ():

    trace = False
    readSettings = True 
    tag = 'leoDynamicTests.leo'
    if trace: t1 = time.time()

    # Setting verbose=True prints messages that would be sent to the log pane.
    path,gui,silent = scanOptions()
    # print('(leoDynamicTest.py:main)','silent',silent)

    # Not loading plugins and not reading settings speeds things up considerably.
    bridge = leoBridge.controller(gui=gui,
        loadPlugins=False, # Must be False: plugins will fail when run externally.
        readSettings=True, # True adds about 0.3 seconds.  Is it useful?
        silent=True,
        verbose=False)

    if trace:
         t2 = time.time()
         print('%s open bridge:  %0.2fsec' % (tag,t2-t1))

    if bridge.isOpen():
        g = bridge.globals()
        g.app.silentMode = silent
        g.app.isExternalUnitTest = True
        path = g.os_path_finalize_join(g.app.loadDir,'..','test',path)
        c = bridge.openLeoFile(path)
        if trace:
            t3 = time.time()
            print('%s open file: %0.2fsec' % (tag,t3-t2))
        runUnitTests(c,g)
#@+node:ekr.20111107092526.9811: *6* runUnitTests
def runUnitTests (c,g):

    p = c.rootPosition()
    #g.es_print('running dynamic unit tests...')
    c.selectPosition(p)
    c.debugCommands.runAllUnitTestsLocally()
#@+node:ekr.20111107092526.9812: *6* scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('--path',dest='path')
    parser.add_option('--gui',dest="gui")
    parser.add_option('--silent',action="store_true",dest="silent")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)

    # -- path
    # We can't finalize the path here, because g does not exist ye.
    path = options.path or 'dynamicUnitTest.leo'

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('qttabs','qt'):
        gui = 'nullGui'

    # --silent
    silent = options.silent

    return path,gui,silent
#@+node:ekr.20111116161118.10248: *3* Recent tests
#@+node:ekr.20111104132424.9909: *4* @test assert True
# It's useful to have this do-nothing test.

assert True
#@+node:ekr.20111107092526.9819: *4* @test cls
g.cls() # Clear the screen
#@+node:ekr.20111110085739.10265: *4* @test html string
s = '''\
<HTML>
<head>
    <title>Bodystring</title>
</head>
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
</html>
'''

html_tags = ('body','head','html','table',) # 'div',
setting = 'import_html_tags'

# Settings now work when run externally.
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.app.unitTestDict ['expectedErrors'] = 0

showTree = True

c.importCommands.htmlUnitTest(p,s=s,showTree=showTree)

if showTree:
    # g.cls()
    for p in p.subtree():
        print('\n***** %s\n' %p.h)
        print(p.b)
#@+node:ekr.20120112100822.10003: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120112100822.10004: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120112100822.10005: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120112100822.10006: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120203153754.10033: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120203153754.10034: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120203153754.10035: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120203153754.10036: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120204061120.10061: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120204061120.10062: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120204061120.10063: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120204061120.10064: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20111109151106.9746: *4* @test htmlScanner.filterTokens
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)
strip = hs.stripTokens
dump  = hs.formatTokens

s1 = '''<table id="1"><table id="2">
<contents/>
</table>
</table>'''

s2 = '<table id="1"><table id="2"><contents/></table></table>'
    
t1 = hs.tokenize(s1)
t2 = hs.tokenize(s2)
f1 = hs.filterTokens(t1)
f2 = hs.filterTokens(t2)

assert strip(f1) == strip(f2),'f1...\n%s\nf2...\n%s' % (
    dump(f1),dump(f2))
    
if 0:
    print(dump(f1))
#@+node:ekr.20111110084957.10092: *4* @test import dataN.html
fn = r'c:\recent\data.html'

# fn = r'c:\recent\data-smaller.html'
# fn = r'c:\recent\data666.html'

# These all pass on data.html:
    # html_tags = ('html','head','body',)
    # html_tags = ('html','head','body','table',)
    # html_tags = ('html','head','body','table','div',)
    # html_tags = ('html','head','body','table','div','script',)
    # html_tags = ('html','head','body','table','div','script','link',)
    # html_tags = ('html','head','body','table','div','script','link','p',)

html_tags = ('html','head','body','table','div','script','p','td','tr',)

# Settings now work when run externally.
setting = 'import_html_tags'
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.cls()

c.importCommands.importFilesCommand(files=[fn], treeType='@file')
#@+node:ekr.20111109105907.9795: *4* @test unicode stuff
@first # -*- coding: utf-8 -*-

table = (
    'test',
    'Ä 궯 奠',
    'Ä 궯 奠 after', # fails with cp6501: after is duplicated.
)

print('*'*20)
print('isPython3: %s' % g.isPython3)

for s in table:
    if g.isPython3:
        s = s.encode('ascii','replace') # create bytes.
    g.es(repr(s))
    g.es(s)
    g.pr ('g.pr(s)       : %s' % s)
    g.pr ('g.pr(repr(s)) : %s' % repr(s))
    print('print(s)      : %s' % s)
    print('print(repr(s)): %s' % s)
#@+node:ekr.20111113064104.9841: *4* @test external text operations
assert g.app.isExternalUnitTest

body = c.frame.body
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl

w = body.bodyCtrl
w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111112131605.9789: *4* @test nullBody text operations
# print('isExternalUnitTest',g.app.isExternalUnitTest)

if g.app.isExternalUnitTest:
    body = c.frame.body
else:
    import leo.core.leoCommands as leoCommands
    import leo.core.leoFrame as leoFrame
    import leo.core.leoGui as leoGui
    
    # Important: external unit tests should execute in this environment.
    nullGui   = leoGui.nullGui('null gui')
    nullFrame = leoFrame.nullFrame(title='nullFrame title',gui=nullGui)
    c2 = leoCommands.Commands(nullFrame,fileName='<empty fileName>')
    nullFrame.c = c2
    body = leoFrame.nullBody(frame=nullFrame,parentFrame=None)
    assert repr(body).startswith('<leo.core.leoFrame.nullBody')

# Now test some basic operations.
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl
w = body.bodyCtrl

w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111115155710.9835: *4* @test g.python_tokenize
# h = 'g.python_tokenize'
# p = p.firstChild()
# assert p.h == h
tokens = g.python_tokenize(p.b,line_numbers=False)

# tokens = [(kind,val) for (kind,val,line_number) in tokens]

# First, the basic check
tokens1 = [val for kind,val in tokens]
s = ''.join(tokens1)
assert p.b == s,repr(s)

if 0:
    for z in tokens:
        kind,val = z
        print('%6s %s' % (kind,repr(val)))
        
# Next, start filtering.
tokens = [(kind,g.choose(kind=='string','"S"',val)) for kind,val in tokens]

if 0: # Delete whitespace.
    tokens = [(kind,val) for (kind,val) in tokens if kind != 'ws']
    tokens = [(kind,g.choose(kind=='id',val+' ',val)) for (kind,val) in tokens]

# Last: stringize.
tokens = [val for kind,val in tokens if kind != 'comment']
# print(''.join(tokens))

if 1: # Print lines containing '='
    s = ''.join(tokens)
    for ch in '()[]{}<>.,:=+-/':
        s = s.replace(' '+ch,ch)
    aList = [z for z in g.splitLines(s)
        if z.find('=') > -1] # and not z.find('+=')>-1 and not z.find('-=')>-1]
    print(''.join(aList))
    
#@+node:ekr.20111204110514.10287: *4* @test p.moveToFirst/LastChild
def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()

child = p.firstChild()
assert child
setup(child)
p2 = child.insertAfter()
p2.h = "test"
try:
    assert c.positionExists(p2),p2
    p2.moveToFirstChildOf(child)
    assert c.positionExists(p2),p2
    p2.moveToLastChildOf(child)
    assert c.positionExists(p2),p2
finally:
    if 1:
        setup(child)
    c.redraw(p)
#@+node:ekr.20111210100047.10306: *5* child
#@+node:ekr.20111116161118.10247: *3* Old lint tests
#@+node:ekr.20111116103733.9845: *4*  Naming tests
# http://docs.python.org/reference/executionmodel.html#naming-and-binding

if 0:
    def test():
        a = b
        b = 1 # UnboundLocalError
        
print('***')
          
def test():
    global g2
    g2 = 4
    def test2():
        print(g2)
    test2()
    g2 = 3
    print(g2)
    
g2 = 'g2'
print(g2)

test()
#@+node:ekr.20111116103733.9846: *5* << define s>>
s = '''



'''

s = g.adjustTripleString(s,-4)
#@+node:ekr.20111116103733.9839: *4* @test create lots of data structures
# A simple prototype of data-centric design.
# 0.023 sec to create 100,000 dicts.
# 0.230 sec to create 1,000,000 dicts.

import time

t1 = time.clock()
n = 1000000

d = {}
for z in range(n):
    d[n] = {'n':n,}

t2 = time.clock()
print('Created %s dicts in %2.3f sec.' % (n,t2-t1))
#@+node:ekr.20111116103733.9844: *4* @test dumper (to outNodes)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outNodes.txt'

outStream = open(out,'w')
u.AstDumper().dumpFileAsNodes(fn,outStream)
#@+node:ekr.20111116103733.9840: *4* @test dumper (to outString)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outString.txt'

outStream = open(out,'w')
u.AstDumper(brief=True).dumpFileAsString(fn,outStream)
#@+node:ekr.20111116103733.9838: *4* @test speed of AstTraverser (one file)
import leo.core.leoGlobals as g
import leo.core.leoInspect as leoInspect
import ast
import time

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
    
t1 = time.clock()
s = open(fn,'r').read()
t2 = time.clock()
tree = ast.parse(s,filename=fn,mode='exec')
t3 = time.clock()
leoInspect.AstTraverser(fn).visit(tree)
t4 = time.clock()

if 1:
    print('read:     %2.3f sec.' % (t2-t1))
    print('parse:    %2.3f sec.' % (t3-t2))
    print('traverse: %2.3f sec.' % (t4-t3))
    print('total:    %2.3f sec.' % (t4-t1))
#@+node:ekr.20111128103520.10237: *3* Tests of @shadow from unitTest.leo
#@+node:ekr.20111128103520.10238: *4* @@shadow ../test/unittest/at-shadow-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10239: *5* spam
def spam():
    pass
#@+node:ekr.20111128103520.10240: *5* eggs
def eggs():
    pass
#@+node:ekr.20111128103520.10241: *4* @@shadow unittest/at-shadow-line-number-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10242: *5* child
def child():
    pass
#@+node:ekr.20111128103520.10243: *4* @test @shadow: shape of tree
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow ../test/unittest/at-shadow-test.py'
    p = g.findNodeAnywhere(c,h)
    assert p
    
    table = (
        (p.firstChild(),'spam'),
        (p.firstChild().next(),'eggs')
    )
    
    assert not p.isDirty(),p.h # Do not ignore this failure!
    
    for p2,h2 in table:
        assert len(p2.h) == len(h2)
#@+node:ekr.20111128103520.10244: *4* @test goto-global-line @shadow
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow unittest/at-shadow-line-number-test.py'
    root1 = g.findNodeAnywhere(c,h)
    assert root1
    assert root1.isAnyAtFileNode()
    
    fileName,lines,n,root2 = c.goToLineNumber(c).setup_file(n=6,p=root1)
    assert fileName == h[8:],'fileName'
    assert root2 == root1
    
    if 0:
        print('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
            root and root.h,isRaw,n,len(lines)))
#@+node:ekr.20111116103733.9818: *3* LeoInspect tests
#@+node:ekr.20111116103733.10672: *4* @test leoInspect with multiple files
import leo.core.leoInspect as inspect

import os

<< define old_s >>
<< define s >>

g.cls()

aList = (
    'leoAtFile.py',
    'leoEditCommands.py',
)
inspect.test(c,aList,print_stats=False,s=None,print_times=True)
#@+node:ekr.20111116103733.10451: *5* << define old_s >>
# import leo.core.leoGlobals
# import leo.core.leoGlobals as g
# from leo.core.leoGlobals import pr as pr2
# from leo.core.leoGlobals import trace

s_old = '''\
import sys

aGlobal = 5
# aGlobal2 is not explicitly defined.

c = [z for z in 'abc']

def myFunc():
    n1,n2,n3,junk,junk=sys.version_info
    a = self.b
    for z in a:
        print(z)
    with A() as a:
        print(a,b)
        
def test():
    a = b # UnboundLocalError.
    b = 1
    c = 2 # Any def will do at present.
    print(g)
    print(c.frame.body)
    print(c.frame.body.xxx.yyy)
    print(b.yyy) # no check will be made.
    print(xxx.yyy)
    for c in 'abc':
        print(c,b)
        print(g)


class myClass:
    
    def __init__(self,c):
        self.a = True
        self.b = None
        c.frame.xxxx
        
    def spam(self,a,b,c=5,*args,**keys):
        global aGlobal2
        aGlobal2 = 'abc'
        self.a = b
        self.a = x
        
    def no_self(a):
        pass
        
    def test_lambda(self):
        f = lambda a,b: a

    def test_comprehension(self):
        z2 = [z for z in 'abc']
        
aGlobal3 = 4 # This should be defined everywhere.

def test():
    # a = ','.join(['a','b'])
    p = 5
    # print(p.parent().h)
    # print(g.app.windowList[0])
    print(p)
    print(g)

'''

# import leo.core.leoCommands as leoCommands
#@+node:ekr.20111116103733.10452: *5* << define s >>
s = '''\

import leo.core.leoGlobals as g

def test(c):
    a = 5
    f = c.frame
    c.frame.body.bodyCtrl = w

'''

s = g.adjustTripleString(s,-4)
# print(s)
#@+node:ekr.20111116103733.10450: *5* test
def test(c,files,print_stats=True,s=None,print_times=True):
   
    t1 = time.clock()
    sd = SemanticData(controller=None)

    if s: # Use test string.
        fn = '<test file>'
        InspectTraverser(c,fn,sd,s).traverse(s)
    else:
        for fn in files:
            print(g.shortFileName(fn))
            s = LeoCoreFiles().get_source(fn)
            if s:
                InspectTraverser(c,fn,sd,s).traverse(s)
            else:
                print('file not found: %s' % (fn))
           
    sd.total_time = time.clock()-t1
    
    if print_times: sd.print_times()
    if print_stats: sd.print_stats()
#@+node:ekr.20111116103733.10449: *4* @test leoInspect.module.classes
import leo.core.leoInspect as inspect

dump_modules = False
print_modules = True
print_functions = False
print_stats = False
print_times = True

if dump_modules or print_stats:
    g.cls()

m = inspect.module(c,'leoEditCommands.py',sd=None,
    print_stats=print_stats,print_times=print_times)
    
for o in m.classes():
    if dump_modules:
        o.dump(verbose=False)
    if print_modules:
        print(o)
    if print_functions:
        for f in o.functions:
            print('  %s' % f)
#@+node:ekr.20111116161118.10212: *4* @test leoInspect.module.classes 2
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(c,'leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.classes():
    print(z)
#@+node:ekr.20111116161118.10218: *4* @test leoInspect.module.defs
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(c,'leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.defs():
    print(z)
#@+node:ekr.20111116161118.10181: *4* @test leoInspect.module.statements
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(c,'leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.statements():
    print(z)
#@+node:ekr.20111116161118.10230: *4* @test leoInspect (leoEditCommands.py)
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(fn='leoEditCommands.py')

def show(o):
    print('%-5s %s' % (o.line_number(),o.format()))

var = '.widget'
func = 'w.insert'

if 0:
    
    print('\nAssignments to %s...\n' % (var))
    for o in m.assignments_to(var):
        show(o)
        
    print('\nAssignments using %s...\n' % (var))
    for o in m.assignments_using(var):
        show(o)
        
    print('\nCalls to %s...\n' % (func))
    for o in m.calls_to(func):
        show(o)
        
    if 1:
        classes = m.classes()
        for d in classes[0].defs():
            print('')
            print(d)
            for z in d.statements():
                # print(z.tree())
                # print(z.sd.dump_ast(z.tree()))
                lines = g.splitLines(z.format())
                for line in lines:
                    print('  %s' % (line))
#@+node:ekr.20111127153202.10231: *4* @test speed of AstTraverser (all Leo core files)
import leo.core.leoGlobals as g
import leo.core.leoInspect as inspect
import ast
import time

read_time,parse_time,traverse_time = 0.0,0.0,0.0
t_start = time.clock()
count = 0
for fn in inspect.LeoCoreFiles().files:
    count += 1
    t2 = time.clock()
    s = open(fn,'r').read()
    t3 = time.clock()
    tree = ast.parse(s,filename=fn,mode='exec')
    t4 = time.clock()
    inspect.AstTraverser(fn).visit(tree)
    t5 = time.clock()
    read_time += t3-t2
    parse_time += t4-t3
    traverse_time += t5-t4
t_end = time.clock()
total_time = t_end-t_start
if 1:
    print('files:    %s' % (count))
    print('read:     %2.3f sec.' % (read_time))
    print('parse:    %2.3f sec.' % (parse_time))
    print('traverse: %2.3f sec.' % (traverse_time))
    print('total:    %2.3f sec.' % (total_time))
#@+node:ekr.20111127090852.10227: *4* @test leoInspect (all core files)
import leo.core.leoInspect as inspect
import time

sd = inspect.SemanticData()
start_time = time.clock()

count = 0
for fn in inspect.LeoCoreFiles().files:
    # print(fn)
    m = inspect.module(fn,sd=sd)
    count += 1

end_time = time.clock()
total_time = end_time-start_time

if 1:
    print('files: %s' % (count))
    print('total: %2.3f sec.' % (total_time))
if 1:
    sd.print_stats()
#@+node:ekr.20111117031039.10762: *4* @test leoInspect.module (s)
import leo.core.leoInspect as inspect

g.cls()

def show(o,indent):
    # print('\n%s\n' % o.sd.dump_ast(o.tree()))
    print('%s%s' % (' '*4*indent,o.format()))

<< define s >>
print('Input...\n%s\n' % (s.rstrip()))

m = inspect.module(s=s)

if 1:
    print(show(m,0))

print('\nAssignments to a...\n')
for o in m.assignments_to('a'):
    print(o.format())
    
print('\nAssignments using d...\n')
for o in m.assignments_using('d'):
    print(o.format())
    
print('\nCalls to f...\n')
for o in m.calls_to('f'):
    print(o.format())

if 1:
    for s in m.statements():
        show(s,0)
    
    for f in m.functions():
        show(f,0)
        for z in f.statements():
            show(z,1)
    
    for cls in m.classes():
        show(cls,0)
        for d in cls.defs():
            show(d,1)
            for z in d.statements():
                show(z,1)
#@+node:ekr.20111117031039.10763: *5* << define s >>
s = '''
x.y = b(arg1,arg2=5,*args,**args).c[1:2:3].d
a=b+c
f(a=1,b=2,*args,**keys)
'''


# def outer_function(a,b=99,c=88,*args,**keys):
    # print('hello')
    
# class myClass:
    # def method():
        # pass
    
#@+node:ekr.20111116103733.9838: *4* @test speed of AstTraverser (one file)
import leo.core.leoGlobals as g
import leo.core.leoInspect as leoInspect
import ast
import time

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
    
t1 = time.clock()
s = open(fn,'r').read()
t2 = time.clock()
tree = ast.parse(s,filename=fn,mode='exec')
t3 = time.clock()
leoInspect.AstTraverser(fn).visit(tree)
t4 = time.clock()

if 1:
    print('read:     %2.3f sec.' % (t2-t1))
    print('parse:    %2.3f sec.' % (t3-t2))
    print('traverse: %2.3f sec.' % (t4-t3))
    print('total:    %2.3f sec.' % (t4-t1))
#@+node:ekr.20120116073928.10114: *3* Unit tests for settings
#@+node:ekr.20120126050844.10386: *4* @ignore print dicts unit tests
#@+node:ekr.20120117095916.10124: *5* @test printMenusList
def printMenusList(aList,level=0):
    
    for z in aList:
        a,b,c = z
        print('*** kind',a)
        if type(b) in (type(()),type([])):
            for z2 in b:
                a1,b1,c1 = z2
                if a1.startswith('@menu') and type(b1) in (type(()),type([])):
                    print()
                    print('*** inner menu: %s' % (level+1))
                    print(a1)
                    for z3 in b1:
                        print(z3)
                    if c1: print(c1)
                else:
                    print(z2)
            if c: print(c)
        else:
            print(b)
        print()
        break #
        
printMenusList(c.config.getMenusList())
       
#@+node:ekr.20120117095916.10140: *5* @test printInverseBindingDict
print('\ninverseBindingDict...\n')

d = c.k.computeInverseBindingDict()

for key in sorted(list(d.keys())):

    if 1 == len(d.get(key)):
        print(key,d.get(key))
    else:
        print()
        print(key)
        print(d.get(key))
        print()
#@+node:ekr.20120123113111.10925: *5* @test printBindingsDict
import leo.core.leoConfig as leoConfig # for ShortcutInfo
    
partial = True

d = c.k.bindingsDict
    # Keys are shortcuts; values are *lists* leoConfig.ShortcutInfo objects.
    
print('\nk.bindingsDict%s...\n' % ' (partial)' if partial else '')
    
for key in list(sorted(d.keys())):
    aList = d.get(key,[])
    for b in aList:
        assert isinstance(b,leoConfig.ShortcutInfo)
        if not partial or b.kind != 'leosettings.leo':
            print(b)
#@+node:ekr.20120117095916.10141: *5* @test printMasterBindingsDict
partial = True

panes = ('all','body','button','log','tree','text',
    'command','insert','overwrite',)

d = c.k.masterBindingsDict
    # Keys are scope names (in panes) or mode names.
    # Values are dicts:
        # keys are strokes; values are leoConfig.ShortcutInfo objects.
        
print('\nk.masterBindingsDict%s...\n' % ' (partial)' if partial else '')

for pane in sorted(list(d.keys())):
    kind = 'pane' if pane in panes else 'mode'
    print('%s: %s...' % (kind,pane))
    d2 = d.get(pane)
    for stroke in sorted(list(d2.keys())):
        b = d2.get(stroke)
        if not partial or b.kind != 'leosettings.leo':
            print('%6s %25s %17s %s' % (b.pane,stroke,b.kind,b.commandName))
            assert b.pane == pane
            assert b.stroke == stroke
    print()
#@+node:ekr.20120126080450.10187: *4* @ignore passed
#@+node:ekr.20120126080450.10189: *5* @test mode-related info
@

g.app.config.modeCommandsDict
    Keys are command names: enter-x-mode.
    Values are inner dictionaries:
        Keys are command names, values are lists of ShortcutInfo nodes.
@c

d = g.app.config.modeCommandsDict
    
for key in sorted(d.keys()):
    print('*** mode ***',key)
    d2 = d.get(key)
    for key2 in sorted(d2.keys()):
        aList = d2.get(key2)
        print(key2)
        for si in aList:
            print('   ',si)
#@+node:ekr.20120120095156.10262: *5* @test types of contents of settings dicts
@
ivar                    Keys                Values
----                    ----                ------
c.commandsDict          command names (1)   functions
k.inverseCommandsDict   func.__name__       command names
k.bindingsDict          shortcuts           list of ShortcutInfo objects
k.masterBindingsDict    scope names (2)     inner masterBindingDicts (3)
k.masterGuiBindingsDict strokes             list of widgets in which stoke is bound
k.settingsNameDict (4)  settings.lower()    "Real" Tk specifiers
inverseBindingDict (5)  command names       lists of tuples (pane,key)
modeCommandsDict (6)    command name (7)    inner modeCommandsDicts (8)

Notes:
(1) Command names are minibuffer names (strings)
(2) Scope names are 'all','text',etc.
(3) inner masterBindingDicts: Keys are strokes; values are ShortcutInfo objects.
(4) k.settingsNameDict has no inverse.
(5) inverseBindingDict is **not** an ivar: it is computed by k.computeInverseBindingDict.
(6) A global dict: g.app.gui.modeCommandsDict
(7) enter-x-command
(8) Keys are command names, values are lists of ShortcutInfo objects.
@c

si_type = c.k.ShortcutInfo
disabled_func_type = None # Should be any bound method.
k = c.k

@others

test_dict_of_objects(c.commandsDict,type('s'),disabled_func_type,'commandsDict')
test_dict_of_objects(k.inverseCommandsDict,type('s'),type('s'),'inverseCommandsDict')
test_dict_of_lists(k.bindingsDict,si_type,'bindingsDict')
test_dict_of_dicts(k.masterBindingsDict,si_type,'masterBindingsDict')
test_dict_of_lists(k.masterGuiBindingsDict,None,'masterGuiBindingsDict')
test_dict_of_objects(k.settingsNameDict,type('s'),type('s'),'settingsNameDict')
test_dict_of_lists(k.computeInverseBindingDict(),type(tuple()),'inverseBindingDict')

# Test individual dicts separately.
d = g.app.config.modeCommandsDict
test_dict_of_dicts(d,None,'modeCommandsDict')
for key in sorted(d.keys()):
    d2 = d.get(key)
    test_dict_of_lists(d2,si_type,'inner modeCommandsDict')
        # This requires a hack to special-case the
        # '*entry-commands*' and '*command-prompt*' keys.
#@+node:ekr.20120126080450.10193: *6* test_dict_of_dicts
def test_dict_of_dicts(d,theType,tag):

    assert d,tag

    for key in d.keys():
        d2 = d.get(key)
        assert type(d2) == type({})
        for key in d2.keys():
            obj = d2.get(key)
            if theType:
                assert type(obj) == theType,repr(obj)
#@+node:ekr.20120126080450.10191: *6* test_dict_of_lists
def test_dict_of_lists(d,theType,tag):

    assert d,tag

    for key in d.keys():
        obj = d.get(key)
        if key in ('*entry-commands*','*command-prompt*'):
            # Special case for g.app.config.modeCommandsDict
            assert type(obj)==type([]),repr(obj)
        else:
            assert type(obj) == type([])
            # Don't check types of list elements if theType is None.
            if theType:
                for z in obj:
                    assert type(z)==theType,'key: %s obj: %s' % (key,repr(obj))
#@+node:ekr.20120126080450.10195: *6* test_dict_of_objects
def test_dict_of_objects(d,keyType,valueType,tag):

    assert d,tag

    for key in d.keys():
        assert type(key) == keyType,repr(key)
        obj = d.get(key)
        # Don't check type of obj if valueType is None.
        if valueType:
            assert type(obj) == valueType,'\nobj: %s\nvalueType: %s' % (repr(obj),valueType)
#@+node:ekr.20120126080450.10194: *6* Unused
# import types
# types.ListType does not exist in Python 3.x.
# assert isinstance(aList,list().__class__)
#@+node:ekr.20120127084215.10238: *5* @test merge_settings_dicts
@others

# import os ; os.system('cls')
    
d1 = g.app.config.immutable_leo_settings_shortcuts_dict
d2 = g.app.config.immutable_my_leo_settings_shortcuts_dict
d3 = g.app.config.merge_settings_dicts(d1,d2)

if False:
    patterns = (
        'backward-find-character-extend-selection',
    )
    for pattern in patterns:
        print(dump_dict(d1,pattern,tag='d1'))
        print(dump_dict(d2,pattern,tag='d2'))
        print(dump_dict(d3,pattern,tag='d3'))

test(d1,d2,d3)
#@+node:ekr.20120127145909.10227: *6* dump & dump_dict (@test merge_settings_dicts)
def dump(aList,pattern=None,tag=None):
    
    return '\n'.join([repr(z) for z in aList])
    

def dump_dict(d,pattern=None,tag=None):
    
    result = [] # '\ndump of %s...' % (tag)
    
    for key in d.keys():
        if pattern in (key,None):
            result.append(key)
            aList = d.get(key)
            for z in aList:
                result.append('    %s' % (z))
                
    return '\n'.join(result)
#@+node:ekr.20120127084215.10239: *6* test (@test merge_settings_dicts)
def test(old_d,new_d,result_d):
    
    '''Test that result_d is the result of upating old_d with new_d.
    
    This test is tricky: only inverted dicts have ShortcutInfo nodes as keys.'''
    
    invert,uninvert = g.app.config.invert,g.app.config.uninvert

    # Compute the inversions of all the dicts.
    inv_old,inv_new,inv_res = invert(old_d),invert(new_d),invert(result_d)
    
    # Part 1: Ensure we test all keys.
    keys = list(inv_old.keys())
    keys.extend(list(inv_new.keys()))
    keys.extend(list(inv_res.keys()))
    keys = sorted(list(set(keys)))
    assert None not in keys
    for key in inv_old.keys(): assert key in keys,key
    for key in inv_new.keys(): assert key in keys,key
    for key in inv_res.keys(): assert key in keys,key
    
    # Part 2: Carefully test the inverted result.
    def si_name_key(si): return si.commandName or ''

    for key in keys:
        # Compute the *sorted* list of 
        res_list = sorted(inv_res.get(key,[]),key=si_name_key)
        old_list = sorted(inv_old.get(key,[]),key=si_name_key)
        new_list = sorted(inv_new.get(key,[]),key=si_name_key)
        assert res_list,'no res_list.get(%s)' % (key)
        # if new_list: print(key,dump(new_list))
        if new_list:
            assert new_list == res_list,'key %s\nnew:\n%s\nres:\n%s' % (
                key,dump(new_list),dump(res_list))
        else:
            assert old_list == res_list,'key %s\nold:\n%s\nres:\n%s' % (
                key,dump(old_list),dump(res_list))
    
    # Part 3: Test that result_d == uninvert(invert(result_d)).
    # A.  They must have the same keys.
    unv_res = uninvert(inv_res)
    assert sorted(list(result_d.keys())) == sorted(list(unv_res.keys()))

    # B. The values of for each key must match after being sorted.
    def si_stroke_key(si): return si.stroke or ''
        
    for key in sorted(result_d.keys()):
        res_list = sorted(result_d.get(key,[]),key=si_stroke_key)
        unv_list = sorted( unv_res.get(key,[]),key=si_stroke_key)
        assert res_list == unv_list,'key %s\nres:\n%s\nunv:\n%s' % (
            key,dump(res_list),dump(unv_list))
   
#@+node:ekr.20120203153754.10032: *5* @test KeyStroke
ks = c.k.KeyStroke

@others

a1 = ks('a')
a2 = ks('a')
b1 = ks('b')
assert a1 == a2
d = {}
d[a1] = a1.s
d[a2] = a2.s
d[b1] = b1.s

for key in sorted(d):
    print(key,d.get(key))
#@+node:ekr.20120205022040.17748: *5* @test g.TypedDict
d = g.TypedDictOfLists('ks',type('s'),type(9))
d.add('a',1)
d.add('a',2)
d.add('b',3)

print(d)
for s in sorted(d.keys()):
    print(s,d.get(s,[]))

print('after replace...')
d.replace('a',[8,9,10])

for s in sorted(d.keys()):
    print(s,d.get(s,[]))
#@+node:ekr.20120215062153.14233: *3* @mark-for-unit-tests
#@+node:ekr.20080412053100.5: *4* @settings
#@+node:ekr.20080412053100.4: *5* @bool fixedWindow = False
#@+node:ekr.20100902154544.5872: *5* @bool enable-abbreviations = True
#@+node:ekr.20111123042248.12701: *5* @enabled-plugins
# Leo loads plugins in the order they appear here.

# Highly-recommended plugins:

plugins_menu.py
free_layout.py # needs to be early
viewrendered.py
mod_scripting.py
#@+node:ekr.20111031081007.9985: *5* @shortcuts
run-selected-unit-tests-externally = Alt-4 # Standard binding, unchanged.
run-marked-unit-tests-externally = Alt-5
run-marked-unit-tests-locally = Alt-6
#@+node:ekr.20110621074459.14908: ** 4.10
#@+node:ekr.20111113141805.10062: *3* Code
#@+node:ekr.20111109105907.9796: *4* Simplified g.pr
#@+node:ekr.20111023164430.16771: *4* Removed unused color tags
@nocolor-node

# 8 Leo-specific, not jEdit specific.
blank
docpart
leokeyword
link
name
nameBrackets
tab
url
#@+node:ekr.20111104132424.9670: *4* Used common code to discover unit tests
@nocolor-node

Created findAllUnitTestNodes, used by createOutline & doTests.
#@+node:ekr.20111113141805.10061: *4* Eliminated the low-level interface
@nocolor-node

Only the high-level interface (baseTextWidget) used the low-level interface.
#@+node:ekr.20111114013726.9967: *4* Removed unused cruft from high-level interface
@nocolor-node

Removed the following unused methods::
    
    bind                c.bind also removed.
    configure
    cget
    event_generate      g.app.gui.event_generate does exist.
    getWidth
    indexIsVisible      Also removed for leoEditCommands: scrollHelper and measure.
    mark_set
    onChar              Fortunately, never used anywhere
    pack                Used only in Tk code
    scrollLines
    set_width           Removed do-nothing calls in Leo's core.
    tag_add             Removed do-nothing calls in qt colorizer.
    tag_bind            Removed do-nothing calls in qt colorizer.
    tag_delete          Removed do-nothing calls in qt colorizer.
    tag_names
    tag_ranges
    tag_remove
    update
    update_idletasks
    xyToPythonIndex
    yview
#@+node:ekr.20111112131605.9787: *4* All unit tests may now be run externally
@nocolor-node

- The nullGui now uses a fully capable string-based body widget.
- The nullGui now uses the regular undoer.
#@+node:ekr.20111114102224.9934: *4* Unified the high-level interface
@nocolor-node

leoQTextEditWidget overrides base toPythonIndex toPythonIndexRowCol.

The versions that call g.toPythonIndex are much slower than
leoQTextEditWidget.toPythonIndex.

The following classes have a toPythonIndex method:

leoQTextEditWidget (fast)

HighLevelInterface: calls g.toPythonIndex.
baseTextWidget: calls g.toPythonIndex.
leoFind: calls g.toPytonIndex.
leoQtBaseTextWidget: calls g.toPythonIndex.
#@+node:ekr.20111115090357.9805: *4* Create properties for logCtrl & bodyCtrl
@nocolor-node

This is an important addition to reliability.
It ensures that body/log.widget and body.bodyCtrl/log.logCtrl are always in synch.
#@+node:ekr.20111118190243.10193: *4* Added eventFilters to top-level frames
@nocolor-node

Added eventFilter in createFrame in SDI/TabbedFrameFactory classes
#@+node:ekr.20111122080923.10183: *4* added log.orderedTabNames
#@+node:ekr.20120130135119.10212: *4* Always use brief=True in k.prettyPrintKey
#@+node:ekr.20120216051410.10852: *4* g.trace and g.pr now print immediately
@nocolor-node

Queuing the output of g.pr makes no sense, and limited the usefulness of g.trace.
#@+node:ekr.20120226180525.10192: *4* Removed many module-level imports
@nocolor-node

This is something that I've wanted to do for a long time.  

Now, most modules import only leo.core.leoGlobals. However,
Leo's core still imports leo.core.leoNodes in order to create
positions, vnodes, etc. It would be straightforward to
eliminate these by creating g.app factory methods, but there
is no urgent reason to do so.
#@+node:ekr.20120226180525.10193: *4* Created the TestManager class
@nocolor-node

All top-level code in leoTest.py now resides in the
TestManager class.

The c.testManager object eliminates the need for imports of
leo.core.leoTest within unitTest.leo, an excellent
simplification.

Furthermore, there is no need to access the testUtils class:
everything is in c.testManager.

The TestManager class substantially clarifies *all* the code
in leoTest.leo. This is surprisingly important because the
testing code is hardly straightforward.
#@+node:ekr.20120224193527.15209: *4* Created the LoadManager class (docs)
@language rest

This is a major restructuring of Leo's code:
    
Initing settings files and local files is now as simple as possible.

g.openWithFileName now simply calls lm.loadLocalFile.

Commands.__init__ now calls c.finshCreate.

g.app.newCommander now simply calls Commands.__init__,
a *huge* collapse in complexity.

===== Details

The g.app.config class is now substantially simpler:
complex methods have moved to the LoadManager.

The new LoadManager class handles all aspects of Leo's
complex startup process, including most importantly the very
complex process by which Leo reads user settings.

As a side effect, c.config.get is now *much* simpler than
before: it search one, and *only* one dictionary to discover
settings.

Reading local files must be done *twice*. The first read
discovers settings, the second read uses those settings to
open the file. The first read always uses a null gui; the
second read uses g.app.gui, whatever that happens to be.

LM.openLocalFile embodies all aspects of the complex
strategy necessary for opening a local file twice. The first
read creates a PreviousSetting object, which is then passed
to LM.openFileByName, which in turn passes the
PreviousSetting object to the ctor for the Commander.
Finally, the PreviousSetting object inits c.config.

Because of the previousSettings object, the call to
LM.openFileByName does *not* need to "synthesize" a link to
c1 using c.hash. This stamps out bug 568452 at its source.

The crucial point is the previous settings get passed along
to the Commander ctor, *before* LM.openFileByName calls
c.fileCommands.openLeoFile to create the outline.

#@+node:ekr.20120225032124.16123: *4* Removed c argument from g.app.config getters
@nocolor-node

- Moved findSettingsPosition to LocalConfigManager.
- Moved printSettings to LocalConfigManager.
#@+node:ekr.20120227053645.10186: *4* Delay "reading settings" message until after signon
#@+node:ekr.20110310093050.14263: *5* pr (codewise)
# see: http://www.diveintopython.org/xml_processing/unicode.html

pr_warning_given = False

def pr(*args,**keys): # (codewise!)

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    if hasattr(sys.stdout,'encoding') and sys.stdout.encoding:
        # sys.stdout is a TextIOWrapper with a particular encoding.
        encoding = sys.stdout.encoding
    else:
        encoding = 'utf-8'

    # Important:  Python's print statement *can* handle unicode.
    # However, the following must appear in Python\Lib\sitecustomize.py:
    #    sys.setdefaultencoding('utf-8')
    s = g.translateArgs(args,d) # Translates everything to unicode.
    if newline:
        s = s + '\n'

    if g.isPython3:
        if encoding.lower() in ('utf-8','utf-16'):
            s2 = s # There can be no problem.
        else:
            # 2010/10/21: Carefully convert s to the encoding.
            s3 = g.toEncodedString(s,encoding=encoding,reportErrors=False)
            s2 = g.toUnicode(s3,encoding=encoding,reportErrors=False)
    else:
        s2 = g.toEncodedString(s,encoding,reportErrors=False)

    if 1: # Good for production: queues 'reading settings' until after signon.
        if app.logInited:
            sys.stdout.write(s2)
        else:
            app.printWaiting.append(s2)
    else:
        # Good for debugging: prints messages immediately.
        print(s2)
#@+node:ekr.20080710101653.1: *5* g.pr
# see: http://www.diveintopython.org/xml_processing/unicode.html

pr_warning_given = False

def pr(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''
    
    print_immediately = False # True: good for debugging.

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')

    if sys.platform.lower().startswith('win'):
        encoding = 'ascii' # 2011/11/9.
    elif hasattr(sys.stdout,'encoding') and sys.stdout.encoding:
        # sys.stdout is a TextIOWrapper with a particular encoding.
        encoding = sys.stdout.encoding
    else:
        encoding = 'utf-8'

    s = g.translateArgs(args,d) # Translates everything to unicode.
    
    # Add a newline unless we are going to queue the message.
    if app.logInited and not print_immediately:
        if newline:
            s = s + '\n'

    if g.isPython3:
        if encoding.lower() in ('utf-8','utf-16'):
            s2 = s # There can be no problem.
        else:
            # Carefully convert s to the encoding.
            s3 = g.toEncodedString(s,encoding=encoding,reportErrors=False)
            s2 = g.toUnicode(s3,encoding=encoding,reportErrors=False)
    else:
        s2 = g.toEncodedString(s,encoding,reportErrors=False)
      
    if print_immediately:
        # Good for debugging: prints messages immediately.
        sys.stdout.write(s2)
    else:
        # Good for production: queues 'reading settings' until after signon.
        if app.logInited:
            sys.stdout.write(s2)
        else:
            app.printWaiting.append(s2)
#@+node:ekr.20120118085926.10251: *4* Use at.readOneAtAutoNode instead of ic.readOneAtAutoNode
# It's important to use only one version of the code.
#@+node:ekr.20110918184425.6915: *3* Features
#@+node:ekr.20110929165422.15464: *4* Supported auto-hide in viewrendered plugin
#@+node:ekr.20110918180029.15527: *4* set g.app.execute_script during script execution
@nocolor-node

This allows the following pattern to appear in Leo source files::

    class myClass:
        @others
        
    if g.app.testing:
        myClass(c).test()
        
This is better than enabling the test with "if 1:" because
c is not defined while importing the module, so the import
will fail if I forget to change "if 1:" to "if 0" when saving
the .leo file.
#@+node:ekr.20110916215321.6710: *4* Added select-to-matching-bracket command
#@+node:ekr.20090724081340.5987: *4* Improved recursive import script
@nocolor-node

- Generates only @auto, does not do an actual import.
- Creates @path nodes so actual @auto nodes are short.
#@+node:ekr.20110917174948.6875: *4* Added beautify-c command
@nocolor-node

Added class CPrettyPrinter & beatifyCCode
#@+node:ekr.20110916215321.7767: *4* Added c-to-python command
#@+node:ekr.20110919184022.6900: *5* To do
@nocolor-node

* Simplify declaration code by using lookahead.

- change skip_to_matching bracket to skip_past_matching_braket.

- (Maybe) Put type decls as comments at end of line.
    Only decls in function bodies need to be munged, but that's not easy.

- (Maybe) Use @ and @c to delimit block comments.
#@+node:ekr.20110919184022.6901: *5* What I did
@nocolor-node

What I did:

- Wrapped the code in a class.

- Replaced all globals with ivars.

- Replaced listToString with ''.join(aList)
    
- Eliminated stringToList.
    The code never passes None where a sequence is expected.
    
- Get tab_width from @tabwidth directives.

- Get user data from::
    
    @data c-to-python-class-list
    @data c-to-python-type-list
    @data c-to-python-ivars-dict
        keys end in a colon
        all other lines contain comma-delimited values for the current key.
        
- Add extra parens for 'if' that span several lines.
- Fixed extra indentation.
- Changed ! to not except before =.
- Dedented C blocks, such as::
    
    {
        statement;
        statement;
    }
    
- Improved formatting of block comments.
#@+node:ekr.20110916215321.8003: *5* mungeAllFunctions
def mungeAllFunctions(self,aList):
    
    '''Scan for a '{' at the top level that is preceeded by ')' '''

    prevSemi = 0 # Previous semicolon: header contains all previous text
    i = 0
    firstOpen = None
    while i < len(aList):
        progress = i
        if self.is_string_or_comment(aList,i):
            j = self.skip_string_or_comment(aList,i)
            prevSemi = j
        elif self.match(aList,i,'('):
            if not firstOpen:
                firstOpen = i
            j = i + 1
        elif self.match(aList,i,'#'):
            # At this point, it is a preprocessor directive.
            j = self.skip_past_line(aList, i)
            prevSemi = j
        elif self.match(aList,i,';'):
            j = i + 1
            prevSemi = j
        elif self.match(aList,i,"{"):
            j = self.handlePossibleFunctionHeader(aList,i,prevSemi,firstOpen)
            prevSemi = j
            firstOpen = None # restart the scan
            # g.trace(repr(''.join(aList[prevSemi:prevSemi+20])))
        else:
            j = i + 1
        
        assert j > progress
        i = j
        
# elif self.match_word(aList, i, "@code"):
    # j = i + 5
    # prevSemi = j # restart the scan
# elif self.match_word(aList, i, "@c"):
    # j = i + 2 ; prevSemi = j # restart the scan
#@+node:ekr.20110916215321.8004: *6* handlePossibleFunctionHeader
# converts function header lines from c++ format to python format.
# That is, converts
# x1..nn w::y ( t1 z1,..tn zn) {
# to
# def y (z1,..zn): {

def handlePossibleFunctionHeader (self,aList,i,prevSemi,firstOpen):

    trace = False
    assert(self.match(aList,i,"{"))

    prevSemi = self.skip_ws_and_nl(aList, prevSemi)
    close = self.prevNonWsOrNlChar(aList,i)

    if close < 0 or aList[close] != ')':
        # Should not increase *Python* indent.
        return 1 + self.skip_to_matching_bracket(aList,i)
        
    if not firstOpen:
        return 1 + self.skip_to_matching_bracket(aList,i)

    close2 = self.skip_to_matching_bracket(aList, firstOpen)
    if close2 != close:
        return 1 + self.skip_to_matching_bracket(aList,i)

    open_paren = firstOpen
    assert(aList[open_paren]=='(')
    head = aList[prevSemi:open_paren]

    # do nothing if the head starts with "if", "for" or "while"
    k = self.skip_ws(head,0)
    if k >= len(head) or not head[k].isalpha():
        return 1 + self.skip_to_matching_bracket(aList,i)

    kk = self.skip_past_word(head,k)
    if kk > k:
        headString = ''.join(head[k:kk])
        # C keywords that might be followed by '{'
        # print "headString:", headString
        if headString in [ "class", "do", "for", "if", "struct", "switch", "while"]:
            return 1 + self.skip_to_matching_bracket(aList, i)

    args = aList[open_paren:close+1]
    k = 1 + self.skip_to_matching_bracket(aList,i)
    body = aList[close+1:k]
    
    if True and trace:
        g.trace('\nhead: %s\nargs: %s\nbody: %s' % (
            ''.join(head),''.join(args),''.join(body)))
    
    head = self.massageFunctionHead(head)
    args = self.massageFunctionArgs(args)
    body = self.massageFunctionBody(body)

    if False and trace:
        g.trace('\nhead2: %s\nargs2: %s\nbody2: %s' % (
            ''.join(head),''.join(args),''.join(body)))

    result = []
    if head: result.extend(head)
    if args: result.extend(args)
    if body: result.extend(body)

    aList[prevSemi:k] = result
    return prevSemi + len(result)
#@+node:ekr.20110916215321.8005: *6* massageFunctionArgs
def massageFunctionArgs (self,args):

    assert(args[0]=='(')
    assert(args[-1]==')')

    result = ['('] ; lastWord = []
    if self.class_name:
        for item in list("self,"): result.append(item) #can put extra comma

    i = 1
    while i < len(args):
        i = self.skip_ws_and_nl(args, i)
        c = args[i]
        if c.isalpha():
            j = self.skip_past_word(args,i)
            lastWord = args[i:j]
            i = j
        elif c == ',' or c == ')':
            for item in lastWord:
                result.append(item)
            if lastWord != [] and c == ',':
                result.append(',')
            lastWord = []
            i += 1
        else: i += 1
    if result[-1] == ',':
        del result[-1]
    result.append(')')
    result.append(':')
    # print "new args:", ''.join(result)
    return result
#@+node:ekr.20110916215321.8006: *6* massageFunctionHead (sets .class_name)
def massageFunctionHead (self,head):
    
    result = []
    prevWord = []
    self.class_name = ''
    i = 0
    # g.trace(repr(''.join(head)))
    while i < len(head):
        i = self.skip_ws_and_nl(head,i)
        if i < len(head) and head[i].isalpha():
            result = []
            j = self.skip_past_word(head,i)
            prevWord = head[i:j]
            i = j
            # look for ::word2
            i = self.skip_ws(head,i)
            if self.match(head,i,"::"):
                # Set the global to the class name.
                self.class_name = ''.join(prevWord)
                # print(class name:", self.class_name)
                i = self.skip_ws(head,i+2)
                if i < len(head) and (head[i]=='~' or head[i].isalpha()):
                    j = self.skip_past_word(head,i)
                    if head[i:j] == prevWord:
                        result.extend('__init__')
                    elif head[i]=='~' and head[i+1:j] == prevWord:
                        result.extend('__del__')
                    else:
                        # result.extend(list('::'))
                        result.extend(head[i:j])
                    i = j
            else:
                result.extend(prevWord)
        else: i += 1

    finalResult = list("def ")
    finalResult.extend(result)
    return finalResult
#@+node:ekr.20110916215321.8007: *6* massageFunctionBody & helpers
def massageFunctionBody (self,body):

    body = self.massageIvars(body)
    body = self.removeCasts(body)
    body = self.removeTypeNames(body)
    body = self.dedentBlocks(body)
    return body
#@+node:ekr.20110919224143.6928: *7* dedentBlocks
def dedentBlocks (self,body):
    
    '''Look for '{' preceded by '{' or '}' or ';'
    (with intervening whitespace and comments).
    '''
    
    i = 0
    while i < len(body):
        j = i
        ch = body[i]
        if self.is_string_or_comment(body,i):
            j = self.skip_string_or_comment(body,i)
        elif ch in '{};':
            # Look ahead ofr '{'
            j += 1
            while True:
                k = j
                j = self.skip_ws_and_nl(body,j)
                if self.is_string_or_comment(body,j):
                    j = self.skip_string_or_comment(body,j)
                if k == j: break
                assert k < j
            if self.match(body,j,'{'):
                k = j
                j = self.skip_to_matching_bracket(body,j)
                # g.trace('found block\n',''.join(body[k:j+1]))
                m = '# <Start dedented block>...'
                body[k:k+1] = list(m)
                j += len(m)
                while k < j:
                    progress = k
                    if body[k] == '\n':
                        k += 1
                        spaces = 0
                        while spaces < 4 and k < j:
                            if body[k] == ' ':
                                spaces += 1
                                k += 1
                            else:
                                break
                        if spaces > 0:
                            del body[k-spaces:k]
                            k -= spaces
                            j -= spaces
                    else:
                        k += 1
                    assert progress < k
                m = '    # <End dedented block>'
                body[j:j+1] = list(m)
                j += len(m)
        else:
            j = i + 1
        assert i < j
        i = j
                
    return body
#@+node:ekr.20110916215321.8008: *7* massageIvars
def massageIvars (self,body):

    if self.class_name and self.ivars_dict.has_key(self.class_name):
        ivars = self.ivars_dict.get(self.class_name)
    else:
        ivars = []

    i = 0
    while i < len(body):
        if self.is_string_or_comment(body,i):
            i = self.skip_string_or_comment(body,i)
        elif body[i].isalpha():
            j = self.skip_past_word(body,i)
            word = ''.join(body[i:j])
            # print "looking up:", word
            if word in ivars:
                # replace word by self.word
                # print "replacing", word, " by self.", word
                word = "self." + word
                word = list(word)
                body[i:j] = word
                delta = len(word)-(j-i)
                i = j + delta
            else: i = j
        else: i += 1
    return body
#@+node:ekr.20110916215321.8009: *7* removeCasts
def removeCasts (self,body):

    i = 0
    while i < len(body):
        if self.is_string_or_comment(body,i):
            i = self.skip_string_or_comment(body,i)
        elif self.match(body, i, '('):
            start = i
            i = self.skip_ws(body, i+1)
            if body[i].isalpha():
                j = self.skip_past_word(body,i)
                word = ''.join(body[i:j])
                i = j
                if word in self.class_list or word in self.type_list:
                    i = self.skip_ws(body, i)
                    while self.match(body,i,'*'):
                        i += 1
                    i = self.skip_ws(body, i)
                    if self.match(body,i,')'):
                        i += 1
                        # print "removing cast:", ''.join(body[start:i])
                        del body[start:i]
                        i = start
        else: i += 1
    return body
#@+node:ekr.20110916215321.8010: *7* removeTypeNames
# Do _not_ remove type names when preceeded by new.

def removeTypeNames (self,body):

    i = 0
    while i < len(body):
        if self.is_string_or_comment(body,i):
            i = self.skip_string_or_comment(body,i)
        elif self.match_word(body, i, "new"):
            i = self.skip_past_word(body,i)
            i = self.skip_ws(body,i)
            # don't remove what follows new.
            if body[i].isalpha():
                i = self.skip_past_word(body,i)
        elif body[i].isalpha():
            j = self.skip_past_word(body,i)
            word = ''.join(body[i:j])
            if word in self.class_list or word in self.type_list:
                j = self.skip_ws(body,j)
                while self.match(body,j,'*'):
                    j += 1
                # print "Deleting type name:", ''.join(body[i:j])
                j = self.skip_ws(body,j)
                del body[i:j]
            else:
                i = j
        else: i += 1
    return body
#@+node:ekr.20110920174648.6945: *5* mungeAllFunctions NEW
def mungeAllFunctions(self,aList):
    
    '''Scan for a '{' at the top level that is preceeded by ')' '''
    
    i,start_of_decl,paren_parts = 0,0,[]
    while i < len(aList):
        j = i
        ch = aList[i]
        if ch in '*[], \t\n':
            j += 1
        elif ch == '(':
            j = self.skip_parens(aList,i)
            paren_parts.append((i,j),)
        elif ch == ';':
            # A function declaration.
            j = self.munge_declaration(aList,start_of_decl,i,paren_parts)
            start_of_decl,paren_parts = j,[]
        elif ch == "{":
            # A function definition or enum/struct/union
            # depending on the word at aList[start_of_decl]...
            j1 = self.skip_parens(aList,i)
            j2 = self.munge_declaration(aList,start_of_decl,j1,paren_parts)
            j = self.munge_function_body(aList,i,j2)
            start_of_decl,paren_parts = j,[]
        elif ch == '=':
            # An initializer.
            j = self.skip_statement(aList,i)
            j = self.munge_declaration(aList,start_of_decl,j,paren_parts)
            start_of_decl,paren_parts = j,[]
        elif self.match(aList,i,'#'):
            # A preprocessor directive.
            j = self.skip_past_line(aList,i)
        elif ch in ('"',"'"):
            j = self.skip_string(aList,i)
        elif self.match(aList,i,'//'):
            j = self.skip_to_end_of_line(aList,i)
        elif self.match(aList,i,'/*'):
            j = self.skip_omment(aList,i)
        elif ch == '_' or ch.isalpha():
            j = g.skip_c_id(aList,i)
        elif ch.isdigit():
            j = g.skip_number(aList,i)
        else:
            g.trace('unexpected character in declaration:',repr(ch))
            j = i + 1
        
        assert j > i
        i = j
#@+node:ekr.20110920174648.6946: *6* handlePossibleFunctionHeader
# converts function header lines from c++ format to python format.
# That is, converts
# x1..nn w::y ( t1 z1,..tn zn) {
# to
# def y (z1,..zn): {

def handlePossibleFunctionHeader (self,aList,i,prevSemi,firstOpen):

    trace = False
    assert(self.match(aList,i,"{"))

    prevSemi = self.skip_ws_and_nl(aList, prevSemi)
    close = self.prevNonWsOrNlChar(aList,i)

    if close < 0 or aList[close] != ')':
        # Should not increase *Python* indent.
        return 1 + self.skip_to_matching_bracket(aList,i)
        
    if not firstOpen:
        return 1 + self.skip_to_matching_bracket(aList,i)

    close2 = self.skip_to_matching_bracket(aList, firstOpen)
    if close2 != close:
        return 1 + self.skip_to_matching_bracket(aList,i)

    open_paren = firstOpen
    assert(aList[open_paren]=='(')
    head = aList[prevSemi:open_paren]

    # do nothing if the head starts with "if", "for" or "while"
    k = self.skip_ws(head,0)
    if k >= len(head) or not head[k].isalpha():
        return 1 + self.skip_to_matching_bracket(aList,i)

    kk = self.skip_past_word(head,k)
    if kk > k:
        headString = ''.join(head[k:kk])
        # C keywords that might be followed by '{'
        # print "headString:", headString
        if headString in [ "class", "do", "for", "if", "struct", "switch", "while"]:
            return 1 + self.skip_to_matching_bracket(aList, i)

    args = aList[open_paren:close+1]
    k = 1 + self.skip_to_matching_bracket(aList,i)
    body = aList[close+1:k]
    
    if True and trace:
        g.trace('\nhead: %s\nargs: %s\nbody: %s' % (
            ''.join(head),''.join(args),''.join(body)))
    
    head = self.massageFunctionHead(head)
    args = self.massageFunctionArgs(args)
    body = self.massageFunctionBody(body)

    if False and trace:
        g.trace('\nhead2: %s\nargs2: %s\nbody2: %s' % (
            ''.join(head),''.join(args),''.join(body)))

    result = []
    if head: result.extend(head)
    if args: result.extend(args)
    if body: result.extend(body)

    aList[prevSemi:k] = result
    return prevSemi + len(result)
#@+node:ekr.20110920174648.6947: *6* massageFunctionArgs
def massageFunctionArgs (self,args):

    assert(args[0]=='(')
    assert(args[-1]==')')

    result = ['('] ; lastWord = []
    if self.class_name:
        for item in list("self,"): result.append(item) #can put extra comma

    i = 1
    while i < len(args):
        i = self.skip_ws_and_nl(args, i)
        c = args[i]
        if c.isalpha():
            j = self.skip_past_word(args,i)
            lastWord = args[i:j]
            i = j
        elif c == ',' or c == ')':
            for item in lastWord:
                result.append(item)
            if lastWord != [] and c == ',':
                result.append(',')
            lastWord = []
            i += 1
        else: i += 1
    if result[-1] == ',':
        del result[-1]
    result.append(')')
    result.append(':')
    # print "new args:", ''.join(result)
    return result
#@+node:ekr.20110920174648.6948: *6* massageFunctionHead (sets .class_name)
def massageFunctionHead (self,head):
    
    result = []
    prevWord = []
    self.class_name = ''
    i = 0
    # g.trace(repr(''.join(head)))
    while i < len(head):
        i = self.skip_ws_and_nl(head,i)
        if i < len(head) and head[i].isalpha():
            result = []
            j = self.skip_past_word(head,i)
            prevWord = head[i:j]
            i = j
            # look for ::word2
            i = self.skip_ws(head,i)
            if self.match(head,i,"::"):
                # Set the global to the class name.
                self.class_name = ''.join(prevWord)
                # print(class name:", self.class_name)
                i = self.skip_ws(head,i+2)
                if i < len(head) and (head[i]=='~' or head[i].isalpha()):
                    j = self.skip_past_word(head,i)
                    if head[i:j] == prevWord:
                        result.extend('__init__')
                    elif head[i]=='~' and head[i+1:j] == prevWord:
                        result.extend('__del__')
                    else:
                        # result.extend(list('::'))
                        result.extend(head[i:j])
                    i = j
            else:
                result.extend(prevWord)
        else: i += 1

    finalResult = list("def ")
    finalResult.extend(result)
    return finalResult
#@+node:ekr.20110920174648.6949: *6* massageFunctionBody & helpers
def massageFunctionBody (self,body):

    body = self.massageIvars(body)
    body = self.removeCasts(body)
    body = self.removeTypeNames(body)
    body = self.dedentBlocks(body)
    return body
#@+node:ekr.20110920174648.6950: *7* dedentBlocks
def dedentBlocks (self,body):
    
    '''Look for '{' preceded by '{' or '}' or ';'
    (with intervening whitespace and comments).
    '''
    
    i = 0
    while i < len(body):
        j = i
        ch = body[i]
        if self.is_string_or_comment(body,i):
            j = self.skip_string_or_comment(body,i)
        elif ch in '{};':
            # Look ahead ofr '{'
            j += 1
            while True:
                k = j
                j = self.skip_ws_and_nl(body,j)
                if self.is_string_or_comment(body,j):
                    j = self.skip_string_or_comment(body,j)
                if k == j: break
                assert k < j
            if self.match(body,j,'{'):
                k = j
                j = self.skip_to_matching_bracket(body,j)
                # g.trace('found block\n',''.join(body[k:j+1]))
                m = '# <Start dedented block>...'
                body[k:k+1] = list(m)
                j += len(m)
                while k < j:
                    progress = k
                    if body[k] == '\n':
                        k += 1
                        spaces = 0
                        while spaces < 4 and k < j:
                            if body[k] == ' ':
                                spaces += 1
                                k += 1
                            else:
                                break
                        if spaces > 0:
                            del body[k-spaces:k]
                            k -= spaces
                            j -= spaces
                    else:
                        k += 1
                    assert progress < k
                m = '    # <End dedented block>'
                body[j:j+1] = list(m)
                j += len(m)
        else:
            j = i + 1
        assert i < j
        i = j
                
    return body
#@+node:ekr.20110920174648.6951: *7* massageIvars
def massageIvars (self,body):

    if self.class_name and self.ivars_dict.has_key(self.class_name):
        ivars = self.ivars_dict.get(self.class_name)
    else:
        ivars = []

    i = 0
    while i < len(body):
        if self.is_string_or_comment(body,i):
            i = self.skip_string_or_comment(body,i)
        elif body[i].isalpha():
            j = self.skip_past_word(body,i)
            word = ''.join(body[i:j])
            # print "looking up:", word
            if word in ivars:
                # replace word by self.word
                # print "replacing", word, " by self.", word
                word = "self." + word
                word = list(word)
                body[i:j] = word
                delta = len(word)-(j-i)
                i = j + delta
            else: i = j
        else: i += 1
    return body
#@+node:ekr.20110920174648.6952: *7* removeCasts
def removeCasts (self,body):

    i = 0
    while i < len(body):
        if self.is_string_or_comment(body,i):
            i = self.skip_string_or_comment(body,i)
        elif self.match(body, i, '('):
            start = i
            i = self.skip_ws(body, i+1)
            if body[i].isalpha():
                j = self.skip_past_word(body,i)
                word = ''.join(body[i:j])
                i = j
                if word in self.class_list or word in self.type_list:
                    i = self.skip_ws(body, i)
                    while self.match(body,i,'*'):
                        i += 1
                    i = self.skip_ws(body, i)
                    if self.match(body,i,')'):
                        i += 1
                        # print "removing cast:", ''.join(body[start:i])
                        del body[start:i]
                        i = start
        else: i += 1
    return body
#@+node:ekr.20110920174648.6953: *7* removeTypeNames
# Do _not_ remove type names when preceeded by new.

def removeTypeNames (self,body):

    i = 0
    while i < len(body):
        if self.is_string_or_comment(body,i):
            i = self.skip_string_or_comment(body,i)
        elif self.match_word(body, i, "new"):
            i = self.skip_past_word(body,i)
            i = self.skip_ws(body,i)
            # don't remove what follows new.
            if body[i].isalpha():
                i = self.skip_past_word(body,i)
        elif body[i].isalpha():
            j = self.skip_past_word(body,i)
            word = ''.join(body[i:j])
            if word in self.class_list or word in self.type_list:
                j = self.skip_ws(body,j)
                while self.match(body,j,'*'):
                    j += 1
                # print "Deleting type name:", ''.join(body[i:j])
                j = self.skip_ws(body,j)
                del body[i:j]
            else:
                i = j
        else: i += 1
    return body
#@+node:ekr.20110929074744.15447: *4* removed scrolledmessage plugin
The viewrendered plugin does more.
#@+node:ekr.20110930075237.15469: *4* Added import-org-mode script
#@+node:ekr.20110929165422.15432: *5* import-org-mode (command, not used)
class ImportOrgMode:
    @others

def importOrgMode (self,event):
    c = self.c
    self.ImportOrgMode(c).go(c.p)
    c.bodyWantsFocus()

if False and g.app.inScript:
    print('='*40)
    ImportOrgMode(c).test()
    print('done')
#@+node:ekr.20110929185034.15461: *6* ctor
def __init__ (self,c):
    
    self.c = c
#@+node:ekr.20110929185034.15457: *6* go
def go (self,p):
    
    '''Prompt for a file and pass the contents to scan().'''
#@+node:ekr.20110929185034.15460: *6* scan
def scan (self,fn,p,s):

    self.c = c
    root = p.insertAsLastChild()
    root.h = fn
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        g.trace(repr(s))
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1
                level += 1
            if level > len(stack):
                g.trace('bad level',repr(s))
                last = None
            elif level == len(stack):
                last = stack[-1]
                last.b = ''.join(body)
            else:
                last = stack[-1]
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            p = parent.insertAsLastChild()
            p.h = s.strip()
            stack.append(p)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        parent = stack[-1]
        parent.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
#@+node:ekr.20110929185034.15459: *6* test
def test (self):
    
    s = '''
* A1
    a1.1
    a1.2
** B11
** B12
b12.1
*** C121
c121.1
    c121.2
c121.3
* A2
a2.1
** B21
*** C211
c211.1
*** C212
** B22
    b22.1
b22.1
* A3
* A4
a4.1
* A5
** B51
*** C511
**** D5111
***** E51111
** B52
*** C521
c521.1
'''

    tag = 'test-import-org-mode'
    p = g.findNodeAnywhere(c,tag)
    s = g.adjustTripleString(s,-4)
    if p:
        try:
            self.scan('test-file',p,s)
        except Exception:
            c.redraw(p)
    else:
        print('not found: %s' % tag)
#@+node:ekr.20110929185034.15578: *5* @@button import-org-mode
'''Import each file in the files list after the presently selected node.'''


files = (
    r'c:\Users\edreamleo\test\import-org-mode.txt',
    r'c:\Users\edreamleo\test\import-org-mode.txt',
)

@others

for fn in files:
    try:
        root = c.p.copy()
        f = open(fn)
        s = f.read()
        scan(c,fn,s)
        c.selectPosition(root)
    except IOError:
        print('can not open %s' % fn)
#@+node:ekr.20110929185034.15580: *6* scan
def scan (c,fn,s):

    last = root = c.p.insertAsLastChild()
    last.h = g.shortFileName(fn)
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1 ; level += 1
            if level > len(stack):
                g.trace('bad level',repr(s))
            elif level == len(stack):
                last.b = ''.join(body)
            else:
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            last = parent.insertAsLastChild()
            last.h = s.strip()
            stack.append(last)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        last.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
#@+node:ekr.20110929185034.15463: *5* test-import-org-mode
#@+node:ekr.20110930213637.15474: *4* The Find tab now scrolls
@nocolor-node

The change was to DynamicWindow.createLogPane.
#@+node:ekr.20111003130143.15562: *4* Removed Leo's old syntax coloring code
@nocolor-node

This was Tk code, and so can not possibly be useful now.

Also removed the settings specific to the Tk colorizer.
#@+node:ekr.20111006060936.15637: *4* Added p.positionAfterDeletedTree
@nocolor-node

This important new method allows scripts to traverse an outline, deleting nodes
during the traversal. The pattern is::

    p = c.rootPosition()
    while p:
    if <delete p?>:
        next = p.positionAfterDeletedTree()
        p.doDelete()
        p = next
    else:
        p.moveToThreadNext()
        
This method also allows scripts to *move* nodes during a traversal, **provided**
that nodes are moved to a "safe" spot so that moving a node does not change the
position of any other nodes.

For example, the move-marked-nodes command first creates a **move node**, called
'Clones of marked nodes'. All moved nodes become children of this node.
**Inserting** these nodes as children of the "move node" does not change the
positions of other nodes. **Deleting** these nodes *may* change the position of
nodes, but the pattern above handles this complication cleanly.
#@+node:ekr.20111005081134.15541: *4* Added delete-marked-nodes and move-marked-nodes commands
# And rewrote clone-marked-nodes.
#@+node:ekr.20111009101205.7134: *4* Open now shows all files
@nocolor-node

Surprisingly important: it is a not-so-subtle clue that *any* file may be
opened: non-Leo files are opened in @edit nodes. Soon: external files containing
Leo sentinels will be opened as @file nodes.
#@+node:ekr.20111009104133.7160: *4* Made open smarter
@nocolor-node

Create @file nodes (not @thin nodes) when opening an external file.

Changed g.openWrapperLeoFile to create @file instead of @edit when possible.

Changed c.open; minor changes to importDerivedFiles.
#@+node:ekr.20111010154337.15586: *4* Improved create @auto nodes script
#@+node:ekr.20111010122531.15571: *4* Rewrote shell-command commands
@nocolor-node

Rewrote the shellCommand, shellCommandOnRegion and executeSubprocess methods.
#@+node:ekr.20111010122531.15572: *4* Added shell commands to Cmds menu
#@+node:ekr.20111011052729.15681: *4* Added quick edit/save mode
@nocolor-node

The idea is to allow Leo to be a drop-in replacement for SciTe.

Suppose you do::
    
    leo x.y
    
where y is not "leo".

1. If x.y exists, Leo should:
    
- Open an unnamed .leo file consisting of @edit x.y.

- If you execute the save command, or close the Leo window,
  Leo should save x.y if it has been changed, but *not* prompt
  you to save the "temporary" .leo file.
  
2. If x.y does *not* exist, leo should do exactly the same
   thing, except that @edit x.y will be empty.
   
However, there are two problems with using Leo as a replacement for SciTe:

1. Load time.  SciTe loads instantly, Leo does not.

2. Screen real estate: Leo is not at its best when presenting only a single
   @edit node: everything but the body pane is wasted space.
#@+node:ekr.20111011062533.15685: *5* Request
@language rest

https://bugs.launchpad.net/leo-editor/+bug/381527

Opens a new nameless leo file and adds somefile.foo as an @edit node.

This is good but...

Saving is a pain, because you have to give a name / location for the .leo file,
and in the quick edit use case you want to be able to just hit ctrl-S to save
somefile.foo.

=====

Ah, at last I see the problem. Saving the **.leo** file is too "heavy". This is
an interesting design problem. You could say that Leo could "throw away" the
temporary .leo file, provided it contains only the @edit node.

True, "quick" editing of a non-Leo file could be done in the workbook, but such
an approach would litter the workbook, and would make opening the workbook
slower and slower. That is, the workbook would get heavier and heavier.
#@+node:ekr.20111011062533.15684: *5* Checkin log
@nocolor-node

Rev 4577 adds an important new feature: "quick edit/save mode"

This fixes bug 381527 quick edit and save use of leo, and makes Leo considerably lighter.

**Important**: As you will see below, quite a few hacks were needed to make this work.  That doesn't bother me at all, because they are all hidden.  The *effect* of those hacks is easily understandable.

**However**, I may have missed something: I almost missed that I had to change the code that prompts for a save when closing an unsaved headline.  So please be on the lookout for any use cases that I missed.

From the checkin log:

QQQQQ

"leo somefile.foo" opens a nameless .leo file containing a single @edit node.

In quick edit/save mode, the user can change somefile.foo without saving the .leo file at all.

Leo *does* properly prompt for saves so that changes to somefile.foo will not be lost.

Quick edit/save mode changes Leo as follows:

1. The save command, and *only* the save command (not save-as or save-to), looks for an unsaved .leo file containing a single @edit node. This is the "quick save" case.

In this case, Leo does *not* prompt for a filename and does *not*, therefore, save the .leo file. However, Leo does save the @edit node if it is dirty.

2. In the quick edit/save case, atFile.writeOneAtEdit node does *not* prompt for so-called dangerous writes, because, in fact, the write is not dangerous :-)

3. In the quick edit/save case, leoFrame.promptForSave prompts for saving the @edit file, *not* the .leo file.

QQQQQ

I forgot to mention one detail.  There is no way to save the .leo file itself in quick edit/save mode.  If you want to do that, simply add any other node at the top level of the outline.  This ends quick edit/save mode.  When you save or close the outline, Leo will prompt you for the name of the .leo file as usual.

Edward
#@+node:ekr.20111012172344.9383: *5* Changed
@nocolor-node

The following were changed:

c.save,
at.writeOneAtEditNode,
at.openFileForWriting
leoFrame.promptForSave
#@+node:ekr.20111011165246.15707: *4* Searches from Leo's web pages now work
Updating Sphinx and using new .js files did the trick.
#@+node:ekr.20110919113533.6818: *4* Added @button split-defs
#@+node:ekr.20111013104917.15659: *4* MacOS is no longer fully supported
@nocolor-node

Leo's home page no longer mentions MacOS and LeoDocs.leo and install.txt now
warn people that MacOS is difficult to install.
#@+node:ekr.20111015194452.15694: *4* Added support for tags in @button nodes
@nocolor-node

The mod_scripting plugin so that the name of the command created by an @button
nodes does not include any [<tag>] that immediately follows @button. Examples::

    @button [ekr] x
    @button [edit] y
    @button [important] z

These buttons create commands named x, y and z, and the name of the buttons are
x, y and z.

Note that the '[' must be the first non-blank after @button to be recognized and
removed.

The code is a straightforward addition to cleanButtonText in mod_scripting.py:
it is unlikely to have any impact whatsoever to existing @button nodes.

The intended use is for searches of the form @button [some tag].
#@+node:ekr.20111018104244.15929: *4* Reorganized @button & @command nodes.
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/bd6ed96c88fabb4e

The prefix "DingDing" signifies that this post is an answer to the
lament:

    "Wouldn't it be great if we all could remember what we,
    and others, have already done :-)"

Last night I had a forehead-slapping moment: the place to put @button
nodes is in myLeoSettings.leo.

This morning, I realized that using @command rather than @button
completes the Aha.

This organization has all benefits, and no drawbacks:

- I always know here scripts are.

- No need for duplicates.

- I can organize the scripts within myLeoSettings.leo as usual using
organizer nodes.  This organization can change as needed.

- Using @command rather than @button means that I never have to
disable scripts.  No more @@button.

- Using @command saves screen real estate.  In my experience, having
buttons be visible doesn't prevent them from being hidden in full
view.

- If I use common prefixes, like c_ (for command) or edit_ (for edit-
related scripts) or ekr_ (for personal scripts), the *typing
completion* will let me zero in on the script I want to use:

    <alt-x> c_<tab>
    <alt-x> c_import<tab>

etc.  Furthermore, Ctrl-P (repeat-complex-command) will allow me to
rerun the last script run.  This is a quite common case.

Summary
=======

This Aha substitutes an *already-existing* usage (typing completion)
for a whole set of memory-intensive retrieval problems.  I'm not
likely ever to forget typing completion, although I might forget the
specif prefixes used in @command nodes.  If that happens, I'll know
where to look.

This Aha takes full advantage of Leo's organization strengths and
*concentrates* those strengths by putting all the to-be-organized
material in one place.  This allows for easy reorganization:  changing
command-name prefixes, for instance, would be straightforward. 
#@+node:ekr.20111018104244.15930: *4* DingDing: big Aha's
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/9ebd0dd748f3011f

1. Today's work promises to *end* my confusion about scripts:

Scripts will typically be found in myLeoSettings.leo, or, for
"official" scripts, in other places, particularly leoSettings.leo.

The print-buttons command (maybe better called print-scripts) will
show the location of @button or @command nodes.

2. This is a huge breakthrough, because it makes hundreds of scripts
easily available.  This in turn makes *all* scripts more valuable.

3. As I was thinking about these happy developments, I realized that a
big new horizon is about to open up.

I shall not describe here my thought processes, but they were related
to what I have been thinking of as @link nodes. The idea behind @link
nodes was that they would be a link to a given node, specified by a
commander and a gnx.

However, scripts moot the need for @link nodes!  The phrase that
popped into my head was::

    Don't *link* to nodes, *search* for nodes!

That is, links, no matter how "good" they are, are breakable and
fragile; searches are more robust and more dynamic.  Bye bye link
nodes!

4.  Do you see what has just happened?  A search, in other words **a
script**, has eliminated the need for a major new core feature, that
is, link nodes.

This is a *huge* change in point of view!

5.  Here are some implications:

A.  Leo must have a check-doc-strings script that will verify that all
commands have non-trivial doc strings.

B. Leo must have a create-command-docs script that will create large
parts of Leo's documentation for individual commands by searching for
commands in all the proper places, including functions specified by
@g.command(name) and Leo's various commands dictionaries.

C. Leo must have a create-plugins-doc script that does the same for
plugins.  A prototype of this script exists somewhere.  Making it an
@command node will make it much more visible.

Conclusions
==========

1. "Smallish" changes (making scripts more visible via typing
completion) has greatly increased the convenience, and thus
application, of scripts.

Part of the Leo Aha is that Leo outlines are *much* easier to script
than flat files.  We are about to see an explosion in applicability of
scripts in Leo.

2. Searches, that is, scripts, are a *much* more powerful mechanism
than breakable links.  My throwaway response to many feature requests
has always been, "well, you can always write a script to do what you
want."

Now we can see the sense in which this is a proper, universal,
response.  In Leo's case, it has recently become clear that docstrings
are the natural *primary* location for data.  This makes the data
available for online help, such as the help-for-command command.

Now we can see that the *proper* way of creating large parts of Leo's
documentation tree (nodes for the rst3 command) will be via one or
more scripts that dynamically search Leo's source files looking for
data!

A great day for Leo.
#@+node:ekr.20111018163319.9412: *4* help-for-command now uses g.getDocStringFromFunction
#@+node:ekr.20111020120612.15897: *4* @ignore now prevents local @button/@command node definitions
@nocolor-node

A big improvement.  There is no longer any need for @@buton, etc.: just put under an @ignore node.

test.leo illustrates the new organization.
#@+node:ekr.20111003161039.15481: *4* Added support for solarized colors
@nocolor-node

http://ethanschoonover.com/solarized


- 

#@+node:ekr.20111022215436.16684: *4* Added border around selected pane
@nocolor-node

Made this optional, and configurable.

c.focus_border_color    = c.config.getColor('focus_border_color') or 'red'
c.focus_border_width    = c.config.getInt('focus_border_width') or 1 # pixels
c.use_body_focus_border = c.config.getBool('use_body_focus_border',default=True)
c.use_focus_border      = c.config.getBool('use_focus_border',default=True)
#@+node:ekr.20111024175001.16476: *4* Applied patch for bug 800399: Leo should have smart word jumps/deletes
@nocolor-node

Some editors, such as Eclipse, vim, this Webkit form I type in, and even Word,
allow to jump over, select and delete words, especially those containing or
surrounded by special characters, in a smarter way than just "going to the
beginning of the word before" (back-word) or "going to the end of the next word"
(forward-word).

E.g. in a line containing "i = ass" (note: multiple spaces) with the cursor at
the end, Ctrl-BackSpace would delete everything up to the "=", leaving "i =",
and if the cursor was right behind the "i", Ctrl-Right would position the cursor
right before the "=", instead of before the "ass", as Leo does now.

They also make deleting easy. Given a python method:

def fun():
    line1
    line2

Eclipse's and Webkit's Ctrl-BackSpace, beginning with the cursor behind "line2",
used multiple times, yield (turn by turn):

def fun():
    line1
    [4 spaces left of here]

def fun():
    line1
[emtpy line]

def fun():
    line1

def fun():
    [4 spaces left of here]

def fun():
[empty line]

def fun():

def fun

def [1 space left of here]

[empty line]

while Leo's backward-delete-word yields:

def fun():
    line1
   [3 spaces left of here ?!]

def fun():
   [3 spaces left of here ?!]

def

[empty line]

So to say, Leo's word-based commands jump, select and delete more than is useful
for possibly many users coming from other editors, leaving them only with
character-based commands.

I have attached two patches that add "-smart" equivalents of the jump, select
and delete commands.

Users wanting to use these commands can set in their myLeoSettings.leo:

  back-word-smart = Ctrl-LtArrow
  back-word-smart-extend-selection = Ctrl-Shift-LtArrow

  forward-word-smart = Ctrl-RtArrow
  forward-word-smart-extend-selection = Ctrl-Shift-RtArrow

  delete-word-smart = Ctrl-Delete
  backward-delete-word-smart = Ctrl-BackSpace

which overrides the default bindings.
#@+node:ekr.20111026101713.16510: *4* Support single-line nodes like <node/> xml import code
@nocolor-node

The single-line nodes should end in a newline. Otherwise the created node will
add a newline, and the checkers will complain.

The new class is xmlScanner and htmlScanner in leoImport.py.
#@+node:ekr.20111019104425.15862: *4* Leo's home page now shows the latest postings from leo-editor.
@nocolor-node

Leo's home page now shows the latest postings on the leo-editor group.
#@+node:ekr.20111031083623.13746: *4* Support run-marked-unit-tests-locally/externally
@nocolor-node

The new command names and default bindings are::
    
    run-all-unit-tests-externally       = None
    run-all-unit-tests-locally          = None
    run-marked-unit-tests-externally    = None
    run-marked-unit-tests-locally       = None
    run-selected-unit-tests-externally  = None
    run-selected-unit-tests-locally     = Alt-4
#@+node:ekr.20111102065242.10014: *4* Disabled messages on external unit tests
@nocolor-node

1. Removing the signon message:

    This was nasty to find. They were created by the call to
    c.new (the non-testc!) in runTests.

    The trace in g.es was the key to discovering what was happening.
    
2. Moved the print statements from leoGlobals.py to writeWaitingLog.

    This allows g.app.silentMode to have effect.
    
3. fc.save now takes a 'silent' argument, set only by createFileFromOutline.

#@+node:ekr.20111102093435.10018: *4* Unit tests now always have the sources available
The following code were changed:

g.executeScript,
c.executeScript,
c.writeScriptFile,
TM.doTests
runTest (generalTestCase)
TM.makeTestSuite.
#@+node:ekr.20111102093435.10017: *4* Support marking an entire tree
@nocolor-node

If a marked node is neither an @test node nor an @suite node,
all nodes in the tree are considered to be marked.
#@+node:ekr.20111103073536.16582: *4* Added support for @bool use_body_focus_border
#@+node:ekr.20111106070228.12432: *4* Call unselect1 hook only once
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/e2980a2b86af913e

Isee the following
- when a file is opened
  - one message listing the root node
  - 7 repeats of the message for the current node

- when the file is saved in a session with several tabs
  - a message is generated for each current node in each tab

- shifting focus from body to headline doesn't generate the message,
  shifting focus with <ctl-h> does

- switching from one tab to another doesn't generate the message 
#@+node:ekr.20111107055809.9733: *4* Added g.app.isExternalUnitTest
Unit tests can test this ivar.
#@+node:ekr.20111107082312.9850: *4* External unit tests now *do* read settings
@nocolor-node

This adds about 0.35 seconds. This is not important with the new meaning of Alt-4.
#@+node:ekr.20111107082312.9851: *4* bridgeController.initLeo now kills events if plugins not loaded
@nocolor-node

The new code monkey-patches g.doHook to a do-nothing::
    
    if not self.loadPlugins:
        def dummyDoHook(tag,*args,**keys):
            pass
        g.doHook = dummyDoHook
#@+node:ekr.20111107092526.9784: *4* Added c.config.set
@nocolor-node

An useful convenience method now that external unit tests can use config settings.
#@+node:ekr.20111109083738.9799: *4* Alt-left-arrow collapses all children when selecting the parent
Under control of @bool collapse_on_lt_arrow option, default *True*.
#@+node:ekr.20111112064924.9779: *4* Improved scannerUnitTest
@nocolor-node

The error message is now part of the failed assert.  Very helpful.
#@+node:ekr.20111115070256.9802: *4* External unit tests now always read config settings
@nocolor-node

The change was simply to set readSettings = True in
leoDynamicTest.py.main.

Experience show the extra time (0.3 sec) is very important
for some unit tests.
#@+node:ekr.20111114151846.9848: *4* Added @bool indent_added_comments setting
@nocolor-node

The default, True, is the legacy operation, which I recommend.

#@+node:ekr.20111115122621.9785: *4* Improved add/delete-comments
@nocolor-node

add-comments preserves trailing whitespace.
delete-comments now works whether or not blanks surround comments delims.
#@+node:ekr.20111118090912.12875: *4* Selected @test node always run
@nocolor-node

This is true regardless of command, marked status of the node, or @ignore nodes.  Doh!

Added special-case code to findAllUnitTestNodes.
#@+node:ekr.20111118093803.10159: *4* Improve print-bindings & print-commands.
@nocolor-node

print-bindings: Alt/Ctrl+Key+N now printed with plain Alt/Ctrl keys and shown as Alt/Ctrl+N.
print-commands: Alt/Ctrl+Key+N now printed as Alt/Ctrl+N.
#@+node:ekr.20111121084517.10187: *4* Added show-decoration-selected: 1 to
Added show-decoration-selected: 1 to QTreeWidget stylesheet.

This causes the entire headline row to be shown when select, a big improvement, imo.
#@+node:ekr.20111123095018.12910: *4* Added stylesheets for Log & Find tabs
#@+node:ekr.20111215193352.10219: *4* Warn when importing/reading/writing @ignored nodes
@nocolor-node

What I did:
    
Created c.init_error_dialogs & c.raise_error_dialogs.

These are called from the following methods:
    
c.importAnyFile
c.open
c.readAtAutoNodes
c.readAtFileNodes
at.readAll
c.save
c.saveAs
c.saveTo
fc.writeAtFileNodes
fc.writeAtShadowNodes
fc.writeDirtyAtFileNodes

2. Disabled log messages in several of the above methods during unit testing.

3. Disabled runOpenFileDialog and runSaveFileDialog during unit testing.
#@+node:ekr.20120130101219.10180: *4* Improved presentation of bindings
@nocolor-node
 
- Improved autocompletion list:
    don't print 'all' in bindings.
    print bindings first
    pad bindings properly, as is done in print-commands/bindings.
    
- Improved print-commands & print-bindings: don't print 'all'

- Simplfied the code in various ways.
#@+node:ekr.20120201092039.10044: *4* Brian's new page up/down code
#@+node:btheado.20120129145543.8180: *5* pageUpDown
def pageUpDown (self, op, moveMode):

    '''The QTextEdit PageUp/PageDown functionality seems to be "baked-in"
       and not externally accessible.  Since Leo has its own keyhandling
       functionality, this code emulates the QTextEdit paging.  This is
       a straight port of the C++ code found in the pageUpDown method
       of gui/widgets/qtextedit.cpp'''

    control = self.widget
    cursor = control.textCursor()
    moved = False
    lastY = control.cursorRect(cursor).top()
    distance = 0
    # move using movePosition to keep the cursor's x
    while True:
        y = control.cursorRect(cursor).top()
        distance += abs(y - lastY)
        lastY = y
        moved = cursor.movePosition(op, moveMode)
        if (not moved or distance >= control.height()):
            break
    tc = QtGui.QTextCursor
    sb = control.verticalScrollBar()
    if moved:
        if (op == tc.Up):
            cursor.movePosition(tc.Down, moveMode)
            sb.triggerAction(QtGui.QAbstractSlider.SliderPageStepSub)
        else:
            cursor.movePosition(tc.Up, moveMode)
            sb.triggerAction(QtGui.QAbstractSlider.SliderPageStepAdd)
    control.setTextCursor(cursor)
#@+node:ekr.20120225032124.18054: *4* Added clone-find-all-flattened command
@nocolor-node

The clone-find-all command includes nodes only once: if a
node's ancestor appears in the list, the node is not include
again in the top-level list.

The new clone-find-all-flattened command includes every found node
in the top-level list of nodes. I find this less confusing.
#@+node:ekr.20060128080201: *5* cloneFindAll (minibufferFind)
def cloneFindAll (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=None,regexp=None,word=None)
        # Init the pattern from the search pattern.
        self.stateZeroHelper(
            event,tag,'Clone Find All: ',self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
        c.treeWantsFocus()
        
#@+node:ekr.20060128075225: *5* cloneFindAllCommand & cloneFindAllFlattenedCommand
def cloneFindAllCommand (self,event=None):

    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
    
def cloneFindAllFlattenedCommand (self,event=None):

    self.setup_command()
    self.clone_find_all = True
    self.clone_find_all_flattened = True
    self.findAll()
    self.clone_find_all = False
    self.clone_find_all_flattened = False
#@+node:ekr.20120226131923.10220: *5* cloneFindAllFlattened (minibufferFind)
def cloneFindAllFlattened (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all-flattened'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=None,regexp=None,word=None)
        # Init the pattern from the search pattern.
        self.stateZeroHelper(
            event,tag,'Clone Find All Flattened: ',self.cloneFindAllFlattened)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAllFlattened=True)
        c.treeWantsFocus()
#@+node:ekr.20060124093828: *5* Find wrappers
def changeAll(self,event=None):
    '''Execute the 'Change All' command with the settings shown in the Find tab.'''
    self.getHandler().changeAll(event)

def cloneFindAll (self,event):
    '''Do search-with-present-options and print all matches in the log pane. It
    also creates a node at the beginning of the outline containing clones of all
    nodes containing the 'find' string. Only one clone is made of each node,
    regardless of how many clones the node has, or of how many matches are found
    in each node.'''
    self.getHandler().cloneFindAll(event)
    
def cloneFindAllFlattened (self,event):
    self.getHandler().cloneFindAllFlattened(event)

def findAll            (self,event):
    '''Do search-with-present-options and print all matches in the log pane.'''
    self.getHandler().findAll(event)

def replaceString      (self,event):
    '''Prompts for a search string. Type <Return> to end the search string. The
    command will then prompt for the replacement string. Typing a second
    <Return> key will place both strings in the Find tab and executes a **find**
    command, that is, the search-with-present-options command.'''
    self.getHandler().replaceString(event)

def reSearchBackward   (self,event):
    '''Do a reverse regex search.'''
    self.getHandler().reSearchBackward(event)

def reSearchForward    (self,event):
    '''Do a forward regex search.'''
    self.getHandler().reSearchForward(event)

def searchBackward     (self,event):
    '''Do a backward plain search.'''
    self.getHandler().searchBackward(event)

def searchForward      (self,event):
    '''Do a forward plain search.'''
    self.getHandler().searchForward(event)

def wordSearchBackward (self,event):
    '''Do a backward word-only search.'''
    self.getHandler().wordSearchBackward(event)

def wordSearchForward  (self,event):
    '''Do a forward word-only search.'''
    self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    '''Prompts for a search string. Typing the <Return> key puts the search
    string in the Find tab and executes a search based on all the settings in
    the Find tab. Recommended as the default search command.'''
    self.getHandler().searchWithPresentOptions(event)
#@+node:ekr.20060124181213.4: *5* generalSearchHelper (minibufferFind)
def generalSearchHelper (self,pattern,cloneFindAll=False,cloneFindAllFlattened=False,findAll=False):

    c = self.c

    self.setupSearchPattern(pattern)

    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.p
    self.finder.v = self.finder.p.v

    if findAll:
        self.finder.findAllCommand()
    elif cloneFindAll:
        self.finder.cloneFindAllCommand()
    elif cloneFindAllFlattened:
        self.finder.cloneFindAllFlattenedCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
#@+node:ekr.20050920084036.259: *5* getPublicCommands (searchCommandsClass)
def getPublicCommands (self):

    return {
        'clone-find-all':                       self.cloneFindAll,
        'clone-find-all-flattened':             self.cloneFindAllFlattened,
        
        'change':                               self.findTabChange,
        'change-all':                           self.changeAll,
        'change-then-find':                     self.findTabChangeThenFind,
        
        'find-all':                             self.findAll,
        'find-clone-all':                       self.cloneFindAll, # Synonym.
        'find-clone-all-flattened':             self.cloneFindAllFlattened, # Synonym.
        'find-next':                            self.findTabFindNext,
        'find-prev':                            self.findTabFindPrev,

        'find-tab-hide':                        self.hideFindTab, # new name
        'find-tab-open':                        self.openFindTab, # new name

        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
        'isearch-with-present-options':         self.isearchWithPresentOptions,

        'replace-string':                       self.replaceString,

        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,

        'show-find-options':                    self.showFindOptions,

        'toggle-find-collapses-nodes':          self.toggleFindCollapesNodes,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        # 'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,

        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }
#@+node:ekr.20031218072017.3073: *5* findAll & helper (leoFind)
def findAll(self):

    trace = False and not g.unitTesting
    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All Flattened' if self.clone_find_all_flattened else 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if self.clone_find_all:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    skip = {} # Nodes that should be skipped.
        # Keys are vnodes, values not important.
    count,found = 0,None
    if trace: g.trace(self.clone_find_all_flattened,self.p)
    while 1:
        pos, newpos = self.findNextMatch() # sets self.p.
        if pos is None: break
        if self.clone_find_all and self.p.v in skip:
            continue
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if self.clone_find_all:
            if not skip:
                undoData = u.beforeInsertNode(c.p)
                found = self.createCloneFindAllNode()
            if self.clone_find_all_flattened:
                skip[self.p.v] = True
            else:
                # Don't look at the node or it's descendants.
                for p2 in self.p.self_and_subtree():
                    skip[p2.v] = True
            # Create a clone of self.p under the find node.
            p2 = self.p.clone()
            p2.moveToLastChildOf(found)
        else:
            self.printLine(line,allFlag=True)

    if self.clone_find_all and skip:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        c.selectPosition(found)
        c.setChanged(True)

    self.restore(data)
    c.redraw()
    g.es("found",count,"matches")
#@+node:ekr.20051113110735: *6* createCloneFindAllNode
def createCloneFindAllNode(self):
    
    c = self.c
    oldRoot = c.rootPosition()
    found = oldRoot.insertAfter()
    found.moveToRoot(oldRoot)
    c.setHeadString(found,'Found: ' + self.find_text)
    return found
#@+node:ekr.20110730093802.15135: *3* Investigations
#@+node:ekr.20110904102049.15417: *4* Relative path problems
#@+node:ekr.20101022172109.6108: *5* g.scanAtPathDirectives scanAllAtPathDirectives
def scanAtPathDirectives(c,aList):

    path = c.scanAtPathDirectives(aList)
    return path

def scanAllAtPathDirectives(c,p):

    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path
#@+node:ekr.20080828103146.15: *5* c.scanAtPathDirectives
def scanAtPathDirectives(self,aList):

    '''Scan aList for @path directives.
    Return a reasonable default if no @path directive is found.'''

    trace = False and not g.unitTesting
    verbose = True

    c = self
    c.scanAtPathDirectivesCount += 1 # An important statistic.
    if trace and verbose: g.trace('**entry',g.callers(4))

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose:
        g.trace('base   ',base)
        g.trace('loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        warning = d.get('@path_in_body')
        if trace and path:
            g.trace('**** d',d)
            g.trace('**** @path path',path)
        if path is not None: # retain empty paths for warnings.
            # Convert "path" or <path> to path.
            path = g.stripPathCruft(path)
            if path and not warning:
                paths.append(path)
            # We will silently ignore empty @path directives.

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose:
        g.printList(paths,tag='c.scanAtPathDirectives: raw paths')

    path = c.os_path_finalize_join(*paths)

    if trace and verbose: g.trace('joined path:',path)
    if trace: g.trace('returns',path)

    return path or g.getBaseDirectory(c)
        # 2010/10/22: A useful default.
#@+node:ekr.20080922124033.6: *5* os_path_expandExpression
def os_path_expandExpression (s,**keys):

    '''Expand {{anExpression}} in c's context.'''

    trace = False
    
    s1 = s
    c = keys.get('c')
    if not c:
        g.trace('can not happen: no c',g.callers())
        return s

    if not s:
        if trace: g.trace('no s')
        return ''

    i = s.find('{{')
    j = s.find('}}')
    if -1 < i < j:
        exp = s[i+2:j].strip()
        if exp:
            try:
                import os
                import sys
                p = c.p
                d = {'c':c,'g':g,'p':p,'os':os,'sys':sys,}
                val = eval(exp,d)
                s = s[:i] + str(val) + s[j+2:]
                if trace: g.trace(s1,s)
            except Exception:
                g.trace(g.callers())
                g.es_exception(full=True, c=c, color='red')

    return s
#@+node:ekr.20080921060401.14: *5* g.os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c = keys.get('c')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path)
    path = os.path.abspath(path)
    path = os.path.normpath(path)
    return path

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c = keys.get('c')

    if c:
        args = [g.os_path_expandExpression(z,**keys)
            for z in args if z]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
#@+node:ekr.20111020092529.15886: *4* Investigate bug: 877332: @file TEX files not reading correctly
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/877332

Not valid: this is a 4.9-final bug that was fixed long ago.

reading: @thin C:\Documents and Settings\Rob\Desktop\Dropbox\Templates\LaTex Templates\Exam2.tex
exception executing command
Traceback (most recent call last):
 File "C:\Program Files\Leo-4.9-final\leo\core\leoCommands.py", line 408, in doCommand
   val = command(event)
 File "C:\Program Files\Leo-4.9-final\leo\core\leoCommands.py", line 981, in importAnyFile
   ic.importDerivedFiles(parent=c.p,paths=derived)
 File "C:\Program Files\Leo-4.9-final\leo\core\leoImport.py", line 978, in importDerivedFiles
   at.read(p)
 File "C:\Program Files\Leo-4.9-final\leo\core\leoAtFile.py", line 586, in read
   c.cacher.writeFile(root,fileKey)
 File "C:\Program Files\Leo-4.9-final\leo\core\leoCache.py", line 412, in writeFile
   elif fileKey in self.db:
TypeError: argument of type 'NoneType' is not iterable
#@+node:ekr.20100208071151.5903: *5* writeFile (cacher)
# Was atFile.writeCachedTree

def writeFile(self,p,fileKey):

    trace = False and not g.unitTesting
    c = self.c

    # Bug fix: 2010/05/26: check g.enableDB before giving internal error.
    if not g.enableDB:
        if trace: g.trace('cache disabled')
    elif not fileKey:
        g.trace(g.callers(5))
        g.internalError('empty fileKey')
    elif self.db.get(fileKey):
        if trace: g.trace('already cached',fileKey)
    else:
        if trace: g.trace('caching ',p.h,fileKey)
        self.db[fileKey] = self.makeCacheList(p)
        
    # if trace: g.trace('* callers',g.callers(4))
#@+node:ekr.20111028111441.16583: *4* Investigated viewrendered problem: file not found
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/928b7222cebf1b7c

Short summary:  Not a Leo problem::
    
    os.path.abspath(r'N:\whatever') yields valid file name.
    os.path.abspath(r'\N:\watever') yields invalid file name.
#@+node:ekr.20111108174504.9791: *4* Investigated unicode problems with print
@nocolor-node

After so many years of confusion the problem is now apparent:
the Windows console uses code page 437: which is just extended ascii.

chcp 65001 is equivalent to utf-8, and it would be good to use,
but at present bzr goes nuts and changes to another code page!

So for the moment I'll have to live with what is, in effect, plain ascii.
#@+node:ekr.20110930075237.15471: *4* Investigated autocomplete popup bug
@nocolor-node

On Ubuntu only, the auto complete popup is system-wide modal, it should only be modal over Leo windows.

However, there does not seem to be any fix:
http://groups.google.com/group/leo-editor/browse_thread/thread/171aaf79e0bea256

All works well on Windows 7.  I do see the "system-wide" model
behavior on Ubuntu.

This appears to be a Ubuntu-specific bug.  Indeed, the popup is a
QListWidget.  Such widgets have a setWindowModality method::

    setWindowModality ( Qt::WindowModality windowModality )

The valid modalities are at: http://doc.qt.nokia.com/4.7-snapshot/qt.html#WindowModality-enum

NonModal: The window is not modal and does not block input to other
windows.

WindowModal: The window is modal to a single window hierarchy and
blocks input to its parent window, all grandparent windows, and all
siblings of its parent and grandparent windows.

ApplicationModal: The window is modal to the application and blocks
input to all windows.

None of these would appear to be a system-wide modality, and
furthermore, the default is supposed to be NonModal.

Anyway, calling setWindowModality(QtCore.Qt.NonModal) does not seem to
have much effect on Ubuntu, so I think I can safely say there is
nothing more I can do. 
#@+node:ekr.20111010082822.15543: *4* Investigated language detection for .tex files
# It works for me, but I simplified the code.
#@+node:ekr.20031218072017.368: *5* << define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "cython"        : "#",
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "javascript"    : "// /* */", # EKR: 2011/11/12: For javascript import test.
    "javaserverpage": "<%-- --%>", # EKR: 2011/11/25
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lisp"          : ";", # EKR: 2010/09/29
    "lua"           : "--",  # ddm 13/02/06
    "matlab"        : "%", # EKR: 2011/10/21
    "nsi"           : ";", # EKR: 2010/10/27
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "scala"         : "// /* */",
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--',
        # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

# Used only by c.getOpenWithExt.
self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    #"cython"        : "pyd",
    #"cython"        : "pyi",
    "cython"        : "pyx", # Only one extension is valid at present.
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "javascript"    : "js", # EKR: 2011/11/12: For javascript import test.
    "javaserverpage": "jsp", # EKR: 2011/11/25
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "matlab"        : "m", # EKR: 2011/10/21
    "nsi"           : "nsi", # EKR: 2010/10/27
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    # "rst"           : "rst", # caught by pylint.
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "scala"         : "scala",
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "js"    : "javascript", # EKR: 2011/11/12: For javascript import test.
    "jsp"   : "javaserverpage", # EKR: 2011/11/25: For @shadow.
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "m"     : "matlab", # EKR 2011/10/21
    "nsi"   : "nsi", # EKR: 2010/10/27
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "pyd"   : "cython",
    "pyi"   : "cython",
    "pyx"   : "cython",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "scala" : "scala",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nsi'   : 'none', # Leo 4.8.
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
#@+node:ekr.20110605121601.18550: *5* Syntax coloring
#@+node:ekr.20110605121601.18551: *6* leoQtColorizer
# This is c.frame.body.colorizer

class leoQtColorizer:

    '''An adaptor class that interfaces Leo's core to two class:

    1. a subclass of QSyntaxHighlighter,

    2. the jEditColorizer class that contains the
       pattern-matchin code from the threading colorizer plugin.'''

    @others

#@+node:ekr.20110605121601.18552: *7*  ctor (leoQtColorizer)
def __init__ (self,c,w):

    # g.trace('(leoQtColorizer)',w)

    self.c = c
    self.w = w

    # Step 1: create the ivars.
    self.changingText = False
    self.count = 0 # For unit testing.
    self.enabled = c.config.getBool('use_syntax_coloring')
    self.error = False # Set if there is an error in jeditColorizer.recolor
    self.flag = True # Per-node enable/disable flag.
    self.killColorFlag = False
    self.language = 'python' # set by scanColorDirectives.
    self.languageList = [] # List of color directives in the node the determines it.
    self.max_chars_to_colorize = c.config.getInt('qt_max_colorized_chars') or 0
    self.oldLanguageList = []
    self.oldV = None
    self.showInvisibles = False # 2010/1/2

    # Step 2: create the highlighter.
    self.highlighter = leoQtSyntaxHighlighter(c,w,colorizer=self)
    self.colorer = self.highlighter.colorer
    w.leo_colorizer = self

    # Step 3: finish enabling.
    if self.enabled:
        self.enabled = hasattr(self.highlighter,'currentBlock')
#@+node:ekr.20110605121601.18553: *7* colorize (leoQtColorizer)
def colorize(self,p,incremental=False,interruptable=True):

    '''The main colorizer entry point.'''

    trace = False and not g.unitTesting ; verbose = False

    self.count += 1 # For unit testing.

    if len(p.b) > self.max_chars_to_colorize > 0:
        self.flag = False
    elif self.enabled:
        oldFlag = self.flag
        self.updateSyntaxColorer(p)
            # sets self.flag and self.language and self.languageList.
        if trace and verbose:
            g.trace('old: %s, new: %s, %s' % (
                self.oldLanguageList,self.languageList,repr(p.h)))
        if (oldFlag != self.flag or
            self.oldV != p.v or
            self.oldLanguageList != self.languageList or
            not incremental
        ):
            if trace: g.trace('** calling rehighlight **')
            self.oldLanguageList = self.languageList[:]
            self.oldV = p.v
            self.highlighter.rehighlight(p)

    return "ok" # For unit testing.
#@+node:ekr.20110605121601.18554: *7* enable/disable
def disable (self,p):

    g.trace(g.callers(4))

    if self.enabled:
        self.flag = False
        self.enabled = False
        self.highlighter.rehighlight(p) # Do a full recolor (to black)

def enable (self,p):

    g.trace(g.callers(4))

    if not self.enabled:
        self.enabled = True
        self.flag = True
        # Do a full recolor, but only if we aren't changing nodes.
        if self.c.currentPosition() == p:
            self.highlighter.rehighlight(p)
#@+node:ekr.20110605121601.18555: *7* minor entry points
def interrupt(self):
    pass

def isSameColorState (self):
    return True # Disable some logic in leoTree.select.

def kill (self):
    pass
#@+node:ekr.20110605121601.18556: *7* scanColorDirectives (leoQtColorizer) & helper
def scanColorDirectives(self,p):
    
    '''Set self.language based on the directives in p's tree.'''

    trace = False and not g.unitTesting
    c = self.c
    if c == None: return None # self.c may be None for testing.
    
    root = p.copy()
    self.language = None
    self.rootMode = None # None, "code" or "doc"

    for p in root.self_and_parents():
        theDict = g.get_directives_dict(p)
        # if trace: g.trace(p.h,theDict)
        << Test for @language >>
        << Test for @root, @root-doc or @root-code >>
        
    # 2011/05/28: If no language, get the language from any @<file> node.
    if self.language:
        if trace: g.trace('found @language %s' % (self.language))
        return self.language
        
    #  Attempt to get the language from the nearest enclosing @<file> node.
    self.language = g.getLanguageFromAncestorAtFileNode(root)

    if not self.language:
        if trace: g.trace('using default',c.target_language)
        self.language = c.target_language

    return self.language # For use by external routines.
#@+node:ekr.20110605121601.18557: *8* << Test for @language >>
if 'language' in theDict:
    s = theDict["language"]
    i = g.skip_ws(s,0)
    j = g.skip_c_id(s,i)
    aList = self.findLanguageDirectives(p)
    # In the root node, we use the first (valid) @language directive,
    # no matter how many @language directives the root node contains.
    # In ancestor nodes, only unambiguous @language directives
    # set self.language.
    if p == root or len(aList) == 1:
        self.languageList = aList
        self.language = aList and aList[0] or []
        break
#@+node:ekr.20110605121601.18558: *8* << Test for @root, @root-doc or @root-code >>
if 'root' in theDict and not self.rootMode:

    s = theDict["root"]
    if g.match_word(s,0,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,0,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@+node:ekr.20110605121601.18559: *8* findLanguageDirectives
def findLanguageDirectives (self,p):

    '''Scan p's body text for *valid* @language directives.

    Return a list of languages.'''
    
    # Speed not very important: called only for nodes containing @language directives.
    trace = False and not g.unitTesting
    aList = []
    for s in g.splitLines(p.b):
        if g.match_word(s,0,'@language'):
            i = len('@language')
            i = g.skip_ws(s,i)
            j = g.skip_id(s,i)
            if j > i:
                word = s[i:j]
                if self.isValidLanguage(word):
                    aList.append(word)
                else:
                    if trace:g.trace('invalid',word)

    if trace: g.trace(aList)
    return aList
#@+node:ekr.20110605121601.18560: *8* isValidLanguage
def isValidLanguage (self,language):
    
    fn = g.os_path_join(g.app.loadDir,'..','modes','%s.py' % (language))
    return g.os_path_exists(fn)
#@+node:ekr.20110605121601.18561: *7* setHighlighter
# Called *only* from leoTree.setBodyTextAfterSelect

def setHighlighter (self,p):

    trace = False and not g.unitTesting
    c = self.c

    if self.enabled:
        self.flag = self.updateSyntaxColorer(p)
        if self.flag:
            # Do a full recolor, but only if we aren't changing nodes.
            if self.c.currentPosition() == p:
                self.highlighter.rehighlight(p)
        else:
            self.highlighter.rehighlight(p) # Do a full recolor (to black)
    else:
        self.highlighter.rehighlight(p) # Do a full recolor (to black)

    if trace: g.trace('enabled: %s flag: %s %s' % (
        self.enabled,self.flag,p.h),g.callers())
#@+node:ekr.20110605121601.18562: *7* updateSyntaxColorer
def updateSyntaxColorer (self,p):

    trace = False and not g.unitTesting
    p = p.copy()

    if len(p.b) > self.max_chars_to_colorize > 0:
        self.flag = False
    else:
        # self.flag is True unless an unambiguous @nocolor is seen.
        self.flag = self.useSyntaxColoring(p)
        self.scanColorDirectives(p) # Sets self.language

    if trace: g.trace(self.flag,len(p.b),self.language,p.h,g.callers(5))
    return self.flag
#@+node:ekr.20110605121601.18563: *7* useSyntaxColoring & helper
def useSyntaxColoring (self,p):

    """Return True unless p is unambiguously under the control of @nocolor."""

    trace = False and not g.unitTesting
    if not p:
        if trace: g.trace('no p',repr(p))
        return False

    p = p.copy()
    first = True ; kind = None ; val = True
    self.killColorFlag = False
    for p in p.self_and_parents():
        d = self.findColorDirectives(p)
        color,no_color = 'color' in d,'nocolor' in d
        # An @nocolor-node in the first node disabled coloring.
        if first and 'nocolor-node' in d:
            kind = '@nocolor-node'
            self.killColorFlag = True
            val = False ; break
        # A killcolor anywhere disables coloring.
        elif 'killcolor' in d:
            kind = '@killcolor %s' % p.h
            self.killColorFlag = True
            val = False ; break
        # A color anywhere in the target enables coloring.
        elif color and first:
            kind = 'color %s' % p.h
            val = True ; break
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            kind = '@nocolor %s' % p.h
            val = False ; break
        elif color and not no_color:
            kind = '@color %s' % p.h
            val = True ; break
        first = False

    if trace: g.trace(val,kind)
    return val
#@+node:ekr.20110605121601.18564: *8* findColorDirectives
color_directives_pat = re.compile(
    # Order is important: put longest matches first.
    r'(^@color|^@killcolor|^@nocolor-node|^@nocolor)'
    ,re.MULTILINE)

def findColorDirectives (self,p):

    '''Scan p for @color, @killcolor, @nocolor and @nocolor-node directives.

    Return a dict containing pointers to the start of each directive.'''

    trace = False and not g.unitTesting

    d = {}
    anIter = self.color_directives_pat.finditer(p.b)
    for m in anIter:
        # Remove leading '@' for compatibility with
        # functions in leoGlobals.py.
        word = m.group(0)[1:]
        d[word] = word

    if trace: g.trace(d)
    return d
#@+node:ekr.20110605121601.18565: *6* leoQtSyntaxHighlighter
# This is c.frame.body.colorizer.highlighter

class leoQtSyntaxHighlighter(QtGui.QSyntaxHighlighter):

    '''A subclass of QSyntaxHighlighter that overrides
    the highlightBlock and rehighlight methods.

    All actual syntax coloring is done in the jeditColorer class.'''

    @others
#@+node:ekr.20110605121601.18566: *7* ctor (leoQtSyntaxHighlighter)
def __init__ (self,c,w,colorizer):

    self.c = c
    self.w = w

    # print('leoQtSyntaxHighlighter.__init__',w)

    # Not all versions of Qt have the crucial currentBlock method.
    self.hasCurrentBlock = hasattr(self,'currentBlock')

    # Init the base class.
    QtGui.QSyntaxHighlighter.__init__(self,w)

    self.colorizer = colorizer

    self.colorer = jEditColorizer(c,
        colorizer=colorizer,
        highlighter=self,
        w=c.frame.body.bodyCtrl)
#@+node:ekr.20110605121601.18567: *7* highlightBlock
def highlightBlock (self,s):
    """ Called by QSyntaxHiglighter """

    if self.hasCurrentBlock and not self.colorizer.killColorFlag:
        if g.isPython3:
            s = str(s)
        else:
            s = unicode(s)
        self.colorer.recolor(s)

#@+node:ekr.20110605121601.18568: *7* rehighlight
def rehighlight (self,p):

    '''Override base rehighlight method'''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; tree = c.frame.tree
    self.w = c.frame.body.bodyCtrl.widget
    s = p.b
    self.colorer.init(p,s)
    n = self.colorer.recolorCount
    
    if trace: g.trace(p.h)

    # Call the base class method, but *only*
    # if the crucial 'currentBlock' method exists.
    if self.colorizer.enabled and self.hasCurrentBlock:
        # Lock out onTextChanged.
        old_selecting = c.frame.tree.selecting
        try:
            c.frame.tree.selecting = True
            QtGui.QSyntaxHighlighter.rehighlight(self)
        finally:
            c.frame.tree.selecting = old_selecting

    if trace and verbose:
        g.trace('%s %s calls to recolor' % (
            p.h,self.colorer.recolorCount-n))
#@+node:ekr.20110605121601.18569: *6* class jeditColorizer
# This is c.frame.body.colorizer.highlighter.colorer

class jEditColorizer:

    '''This class contains jEdit pattern matchers adapted
    for use with QSyntaxHighlighter.'''

    << about the line-oriented jEdit colorizer >>

    @others
#@+node:ekr.20110605121601.18570: *7* << about the line-oriented jEdit colorizer >>
@nocolor-node
@

The aha behind the line-oriented jEdit colorizer is that we can define one or
more *restarter* methods for each pattern matcher that could possibly match
across line boundaries. I say "one or more" because we need a separate restarter
method for all combinations of arguments that can be passed to the jEdit pattern
matchers. In effect, these restarters are lambda bindings for the generic
restarter methods.

In actuality, very few restarters are needed. For example, for Python, we need
restarters for continued strings, and both flavors of continued triple-quoted
strings. For python, these turn out to be three separate lambda bindings for
restart_match_span.

When a jEdit pattern matcher partially succeeds, it creates the lambda binding
for its restarter and calls setRestart to set the ending state of the present
line to an integer representing the bound restarter. setRestart calls
computeState to create a *string* representing the lambda binding of the
restarter. setRestart then calls stateNameToStateNumber to convert that string
to an integer state number that then gets passed to Qt's setCurrentBlockState.
The string is useful for debugging; Qt only uses the corresponding number.
#@+node:ekr.20110605121601.18571: *7*  Birth & init
#@+node:ekr.20110605121601.18572: *8* __init__ (jeditColorizer)
def __init__(self,c,colorizer,highlighter,w):

    # Basic data...
    self.c = c
    self.colorizer = colorizer
    self.highlighter = highlighter # a QSyntaxHighlighter
    self.p = None
    self.w = w
    assert(w == self.c.frame.body.bodyCtrl)

    # Used by recolor and helpers...
    self.actualColorDict = {} # Used only by setTag.
    self.hyperCount = 0
    self.defaultState = 'default-state:' # The name of the default state.
    self.nextState = 1 # Dont use 0.
    self.restartDict = {} # Keys are state numbers, values are restart functions.
    self.stateDict = {} # Keys are state numbers, values state names.
    self.stateNameDict = {} # Keys are state names, values are state numbers.

    # Attributes dict ivars: defaults are as shown...
    self.default = 'null'
    self.digit_re = ''
    self.escape = ''
    self.highlight_digits = True
    self.ignore_case = True
    self.no_word_sep = ''
    # Config settings...
    self.showInvisibles = c.config.getBool("show_invisibles_by_default")
    self.colorizer.showInvisibles = self.showInvisibles
    # g.trace(self.showInvisibles)
        # Also set in init().
    self.underline_undefined = c.config.getBool("underline_undefined_section_names")
    self.use_hyperlinks = c.config.getBool("use_hyperlinks")
    # Debugging...
    self.count = 0 # For unit testing.
    self.allow_mark_prev = True # The new colorizer tolerates this nonsense :-)
    self.tagCount = 0
    self.trace = False or c.config.getBool('trace_colorizer')
    self.trace_leo_matches = False
    self.trace_match_flag = False
        # True: trace all matching methods.
        # This isn't so useful now that colorRangeWithTag shows g.callers(2).
    self.verbose = False
    # Profiling...
    self.recolorCount = 0 # Total calls to recolor
    self.stateCount = 0 # Total calls to setCurrentState
    self.totalChars = 0 # The total number of characters examined by recolor.
    self.totalStates = 0
    self.maxStateNumber = 0
    self.totalKeywordsCalls = 0
    self.totalLeoKeywordsCalls = 0
    # Mode data...
    self.defaultRulesList = []
    self.importedRulesets = {}
    self.prev = None # The previous token.
    self.fonts = {} # Keys are config names.  Values are actual fonts.
    self.keywords = {} # Keys are keywords, values are 0..5.
    self.language_name = None # The name of the language for the current mode.
    self.last_language = None # The language for which configuration tags are valid.
    self.modes = {} # Keys are languages, values are modes.
    self.mode = None # The mode object for the present language.
    self.modeBunch = None # A bunch fully describing a mode.
    self.modeStack = []
    self.rulesDict = {}
    # self.defineAndExtendForthWords()
    self.word_chars = {} # Inited by init_keywords().
    self.setFontFromConfig()
    self.tags = [
    
        # To be removed...
    
            # Used only by the old colorizer.
            # 'bracketRange',
            # "comment",
            # "cwebName"
            # "keyword",
            # "latexBackground","latexKeyword","latexModeKeyword",
            # "pp",
            # "string",
            
            # Wiki styling.  These were never user options.
            # "bold","bolditalic","elide","italic",
            
            # Marked as Leo jEdit tags, but not used.
            # '@color', '@nocolor','doc_part', 'section_ref',
        
        # 8 Leo-specific tags.
        "blank",  # show_invisibles_space_color
        "docpart",
        "leokeyword",
        "link",
        "name",
        "namebrackets",
        "tab", # show_invisibles_space_color
        "url",
        
        # jEdit tags.
        'comment1','comment2','comment3','comment4',
        # default, # exists, but never generated.
        'function',
        'keyword1','keyword2','keyword3','keyword4',
        'label','literal1','literal2','literal3','literal4',
        'markup','operator',
    ]

    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
#@+node:ekr.20110605121601.18573: *9* defineLeoKeywordsDict
def defineLeoKeywordsDict(self):

    self.leoKeywordsDict = {}

    for key in g.globalDirectiveList:
        self.leoKeywordsDict [key] = 'leokeyword'
#@+node:ekr.20110605121601.18574: *9* defineDefaultColorsDict
def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {
    
        # Used in Leo rules...
    
        # tag name      :( option name,                  default color),
        'blank'         :('show_invisibles_space_color', '#E5E5E5'), # gray90
        'docpart'       :('doc_part_color',              'red'),
        'leokeyword'    :('leo_keyword_color',           'blue'),
        'link'          :('section_name_color',          'red'),
        'name'          :('undefined_section_name_color','red'),
        'namebrackets'  :('section_name_brackets_color', 'blue'),
        'tab'           :('show_invisibles_tab_color',   '#CCCCCC'), # gray80
        'url'           :('url_color',                   'purple'),
        
        # Used by the old colorizer: to be removed.
        
        # 'bracketRange'   :('bracket_range_color',     'orange'), # Forth.
        # 'comment'        :('comment_color',           'red'),
        # 'cwebName'       :('cweb_section_name_color', 'red'),
        # 'keyword'        :('keyword_color',           'blue'),
        # 'latexBackground':('latex_background_color',  'white'),
        # 'pp'             :('directive_color',         'blue'),
        # 'string'         :('string_color',            '#00aa00'), # Used by IDLE.

        # jEdit tags.
        # tag name  :( option name,     default color),
        'comment1'  :('comment1_color', 'red'),
        'comment2'  :('comment2_color', 'red'),
        'comment3'  :('comment3_color', 'red'),
        'comment4'  :('comment4_color', 'red'),
        'function'  :('function_color', 'black'),
        'keyword1'  :('keyword1_color', 'blue'),
        'keyword2'  :('keyword2_color', 'blue'),
        'keyword3'  :('keyword3_color', 'blue'),
        'keyword4'  :('keyword4_color', 'blue'),
        'keyword5'  :('keyword5_color', 'blue'),
        'label'     :('label_color',    'black'),
        'literal1'  :('literal1_color', '#00aa00'),
        'literal2'  :('literal2_color', '#00aa00'),
        'literal3'  :('literal3_color', '#00aa00'),
        'literal4'  :('literal4_color', '#00aa00'),
        'markup'    :('markup_color',   'red'),
        'null'      :('null_color',     None), #'black'),
        'operator'  :('operator_color', None), #'black'),
    }
#@+node:ekr.20110605121601.18575: *9* defineDefaultFontDict
def defineDefaultFontDict (self):

    self.default_font_dict = {
    
        # Used in Leo rules...
        
            # tag name      : option name
            'blank'         :'show_invisibles_space_font', # 2011/10/24.
            'docpart'       :'doc_part_font',
            'leokeyword'    :'leo_keyword_font',
            'link'          :'section_name_font',
            'name'          :'undefined_section_name_font',
            'namebrackets'  :'section_name_brackets_font',
            'tab'           : 'show_invisibles_tab_font', # 2011/10/24.
            'url'           : 'url_font',
        
        # Used by old colorizer.
        
            # 'bracketRange'   :'bracketRange_font', # Forth.
            # 'comment'       :'comment_font',
            # 'cwebName'      :'cweb_section_name_font',
            # 'keyword'       :'keyword_font',
            # 'latexBackground':'latex_background_font',
            # 'pp'            :'directive_font',
            # 'string'        :'string_font',
    
         # jEdit tags.
         
             # tag name     : option name
            'comment1'      :'comment1_font',
            'comment2'      :'comment2_font',
            'comment3'      :'comment3_font',
            'comment4'      :'comment4_font',
            #'default'       :'default_font',
            'function'      :'function_font',
            'keyword1'      :'keyword1_font',
            'keyword2'      :'keyword2_font',
            'keyword3'      :'keyword3_font',
            'keyword4'      :'keyword4_font',
            'keyword5'      :'keyword5_font',
            'label'         :'label_font',
            'literal1'      :'literal1_font',
            'literal2'      :'literal2_font',
            'literal3'      :'literal3_font',
            'literal4'      :'literal4_font',
            'markup'        :'markup_font',
            # 'nocolor' This tag is used, but never generates code.
            'null'          :'null_font',
            'operator'      :'operator_font',
    }
#@+node:ekr.20110605121601.18576: *8* addImportedRules
def addImportedRules (self,mode,rulesDict,rulesetName):

    '''Append any imported rules at the end of the rulesets specified in mode.importDict'''

    if self.importedRulesets.get(rulesetName):
        return
    else:
        self.importedRulesets [rulesetName] = True

    names = hasattr(mode,'importDict') and mode.importDict.get(rulesetName,[]) or []

    for name in names:
        savedBunch = self.modeBunch
        ok = self.init_mode(name)
        if ok:
            rulesDict2 = self.rulesDict
            for key in rulesDict2.keys():
                aList = self.rulesDict.get(key,[])
                aList2 = rulesDict2.get(key)
                if aList2:
                    # Don't add the standard rules again.
                    rules = [z for z in aList2 if z not in aList]
                    if rules:
                        # g.trace([z.__name__ for z in rules])
                        aList.extend(rules)
                        self.rulesDict [key] = aList
        # g.trace('***** added rules for %s from %s' % (name,rulesetName))
        self.initModeFromBunch(savedBunch)
#@+node:ekr.20110605121601.18577: *8* addLeoRules
def addLeoRules (self,theDict):

    '''Put Leo-specific rules to theList.'''

    table = (
        # Rules added at front are added in **reverse** order.
        ('@',  self.match_leo_keywords,True), # Called after all other Leo matchers.
            # Debatable: Leo keywords override langauge keywords.
        ('@',  self.match_at_color,    True),
        ('@',  self.match_at_killcolor,True),
        ('@',  self.match_at_language, True), # 2011/01/17
        ('@',  self.match_at_nocolor,  True),
        ('@',  self.match_at_nocolor_node,True),
        ('@',  self.match_doc_part,    True),
        ('f',  self.match_url_f,        True),
        ('h',  self.match_url_h,       True),
        ('<',  self.match_section_ref, True), # Called **first**.
        # Rules added at back are added in normal order.
        (' ',  self.match_blanks,      False),
        ('\t', self.match_tabs,        False),
    )

    for ch, rule, atFront, in table:

        # Replace the bound method by an unbound method.

        if g.isPython3:
            rule = rule.__func__
        else:
            rule = rule.im_func
        # g.trace(rule)

        theList = theDict.get(ch,[])
        if rule not in theList:
            if atFront:
                theList.insert(0,rule)
            else:
                theList.append(rule)
            theDict [ch] = theList

    # g.trace(g.listToString(theDict.get('@')))
#@+node:ekr.20111024091133.16702: *8* configure_hard_tab_width
def configure_hard_tab_width (self):
    
    # The stated default is 40, but apparently it must be set explicitly.
    
    trace = False and not g.unitTesting
    c,w = self.c,self.w
 
    if 0:
        # No longer used: c.config.getInt('qt-tab-width')
        hard_tab_width = abs(10*c.tab_width)
        if trace: g.trace('hard_tab_width',hard_tab_width,self.w)
    else:
        # For some reason, the size is not accurate.
        font = w.widget.currentFont()
        info = QtGui.QFontInfo(font)
        size = info.pointSizeF()
        pixels_per_point = 1.0 # 0.9
        hard_tab_width = abs(int(pixels_per_point*size*c.tab_width))
        
        if trace: g.trace(
            'family',font.family(),'point size',size,
            'tab_width',c.tab_width,
            'hard_tab_width',hard_tab_width) # ,self.w)
    
    w.widget.setTabStopWidth(hard_tab_width)
#@+node:ekr.20110605121601.18578: *8* configure_tags
def configure_tags (self):

    trace = False and not g.unitTesting
    traceColors = False
    traceFonts = False
    c = self.c ; w = self.w
    isQt = g.app.gui.guiName().startswith('qt')

    if trace: g.trace(self.colorizer.language)

    if w and hasattr(w,'start_tag_configure'):
        w.start_tag_configure()

    # Get the default body font.
    defaultBodyfont = self.fonts.get('default_body_font')
    if not defaultBodyfont:
        defaultBodyfont = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize)
        self.fonts['default_body_font'] = defaultBodyfont

    # Configure fonts.
    if trace and traceFonts: g.trace('*'*10,'configuring fonts')
    keys = list(self.default_font_dict.keys()) ; keys.sort()
    for key in keys:
        option_name = self.default_font_dict[key]
        # First, look for the language-specific setting, then the general setting.
        for name in ('%s_%s' % (self.colorizer.language,option_name),(option_name)):
            if trace and traceFonts: g.trace(name)
            font = self.fonts.get(name)
            if font:
                if trace and traceFonts:
                    g.trace('**found',name,id(font))
                w.tag_configure(key,font=font)
                break
            else:
                family = c.config.get(name + '_family','family')
                size   = c.config.get(name + '_size',  'size')   
                slant  = c.config.get(name + '_slant', 'slant')
                weight = c.config.get(name + '_weight','weight')
                if family or slant or weight or size:
                    family = family or g.app.config.defaultFontFamily
                    size   = size or c.config.defaultBodyFontSize
                    slant  = slant or 'roman'
                    weight = weight or 'normal'
                    font = g.app.gui.getFontFromParams(family,size,slant,weight)
                    # Save a reference to the font so it 'sticks'.
                    self.fonts[key] = font
                    if trace and traceFonts:
                        g.trace('**found',key,name,family,size,slant,weight,id(font))
                    w.tag_configure(key,font=font)
                    break

        else: # Neither the general setting nor the language-specific setting exists.
            if list(self.fonts.keys()): # Restore the default font.
                if trace and traceFonts:
                    g.trace('default',key,font)
                self.fonts[key] = font # 2010/02/19: Essential
                w.tag_configure(key,font=defaultBodyfont)
            else:
                if trace and traceFonts:
                    g.trace('no fonts')
                    
        if isQt and key == 'url' and font:
            font.setUnderline(True) # 2011/03/04

    if trace and traceColors: g.trace('*'*10,'configuring colors')
    keys = list(self.default_colors_dict.keys()) ; keys.sort()
    for name in keys:
        # if name == 'operator': g.pdb()
        option_name,default_color = self.default_colors_dict[name]
        color = (
            c.config.getColor('%s_%s' % (self.colorizer.language,option_name)) or
            c.config.getColor(option_name) or
            default_color
        )
        if trace and traceColors: g.trace(option_name,color)

        # Must use foreground, not fg.
        try:
            w.tag_configure(name, foreground=color)
        except: # Recover after a user error.
            g.es_exception()
            w.tag_configure(name, foreground=default_color)

    # underline=var doesn't seem to work.
    if 0: # self.use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
        w.tag_configure("link",underline=1) # defined
        w.tag_configure("name",underline=0) # undefined
    else:
        w.tag_configure("link",underline=0)
        if self.underline_undefined:
            w.tag_configure("name",underline=1)
        else:
            w.tag_configure("name",underline=0)

    self.configure_variable_tags()

    try:
        w.end_tag_configure()
    except AttributeError:
        pass
#@+node:ekr.20110605121601.18579: *8* configure_variable_tags
def configure_variable_tags (self):

    c = self.c ; w = self.w

    # g.trace()

    for name,option_name,default_color in (
        ("blank","show_invisibles_space_background_color","Gray90"),
        ("tab",  "show_invisibles_tab_background_color",  "Gray80"),
        ("elide", None,                                   "yellow"),
    ):
        if self.showInvisibles:
            color = option_name and c.config.getColor(option_name) or default_color
        else:
            option_name,default_color = self.default_colors_dict.get(name,(None,None),)
            color = option_name and c.config.getColor(option_name) or ''
        try:
            w.tag_configure(name,background=color)
        except: # A user error.
            w.tag_configure(name,background=default_color)

    # Special case:
    if not self.showInvisibles:
        w.tag_configure("elide",elide="1")
#@+node:ekr.20110605121601.18580: *8* init (jeditColorizer)
def init (self,p,s):

    trace = False and not g.unitTesting

    if p: self.p = p.copy()
    self.all_s = s or ''

    if trace: g.trace('='*20,
        'tabwidth',self.c.tab_width,
        self.colorizer.language) #,g.callers(4))

    # State info.
    self.all_s = s
    self.global_i,self.global_j = 0,0
    self.global_offset = 0

    # These *must* be recomputed.
    self.nextState = 1 # Dont use 0.
    self.stateDict = {}
    self.stateNameDict = {}
    self.restartDict = {}
    self.init_mode(self.colorizer.language)
    self.clearState()
    self.showInvisibles = self.colorizer.showInvisibles
        # The show/hide-invisible commands changes this.

    # Used by matchers.
    self.prev = None
    if self.last_language != self.colorizer.language:
        # Must be done to support per-language @font/@color settings.
        self.configure_tags()
        self.last_language = self.colorizer.language
        
    self.configure_hard_tab_width() # 2011/10/04
#@+node:ekr.20110605121601.18581: *8* init_mode & helpers
def init_mode (self,name):

    '''Name may be a language name or a delegate name.'''

    trace = False and not g.unitTesting
    if not name: return False
    h = self.highlighter
    language,rulesetName = self.nameToRulesetName(name)
    bunch = self.modes.get(rulesetName)
    if bunch:
        if bunch.language == 'unknown-language':
            if trace: g.trace('found unknown language')
            return False
        else:
            if trace: g.trace('found',language,rulesetName)
            self.initModeFromBunch(bunch)
            self.language_name = language # 2011/05/30
            return True
    else:
        if trace: g.trace(language,rulesetName)
        path = g.os_path_join(g.app.loadDir,'..','modes')
        # Bug fix: 2008/2/10: Don't try to import a non-existent language.
        fileName = g.os_path_join(path,'%s.py' % (language))
        if g.os_path_exists(fileName):
            mode = g.importFromPath (language,path)
        else: mode = None

        if mode:
            # A hack to give modes/forth.py access to c.
            if hasattr(mode,'pre_init_mode'):
                mode.pre_init_mode(self.c)
        else:
            # Create a dummy bunch to limit recursion.
            self.modes [rulesetName] = self.modeBunch = g.Bunch(
                attributesDict  = {},
                defaultColor    = None,
                keywordsDict    = {},
                language        = 'unknown-language',
                mode            = mode,
                properties      = {},
                rulesDict       = {},
                rulesetName     = rulesetName,
                word_chars      = self.word_chars, # 2011/05/21
            )
            if trace: g.trace('***** No colorizer file: %s.py' % language)
            self.rulesetName = rulesetName
            self.language_name = 'unknown-language'
            return False
        self.colorizer.language = language
        self.rulesetName = rulesetName
        self.properties = hasattr(mode,'properties') and mode.properties or {}
        self.keywordsDict = hasattr(mode,'keywordsDictDict') and mode.keywordsDictDict.get(rulesetName,{}) or {}
        self.setKeywords()
        self.attributesDict = hasattr(mode,'attributesDictDict') and mode.attributesDictDict.get(rulesetName) or {}
        # if trace: g.trace(rulesetName,self.attributesDict)
        self.setModeAttributes()
        self.rulesDict = hasattr(mode,'rulesDictDict') and mode.rulesDictDict.get(rulesetName) or {}
        # if trace: g.trace(self.rulesDict)
        self.addLeoRules(self.rulesDict)
        self.defaultColor = 'null'
        self.mode = mode
        self.modes [rulesetName] = self.modeBunch = g.Bunch(
            attributesDict  = self.attributesDict,
            defaultColor    = self.defaultColor,
            keywordsDict    = self.keywordsDict,
            language        = self.colorizer.language,
            mode            = self.mode,
            properties      = self.properties,
            rulesDict       = self.rulesDict,
            rulesetName     = self.rulesetName,
            word_chars      = self.word_chars, # 2011/05/21
        )
        # Do this after 'officially' initing the mode, to limit recursion.
        self.addImportedRules(mode,self.rulesDict,rulesetName)
        self.updateDelimsTables()
        initialDelegate = self.properties.get('initialModeDelegate')
        if initialDelegate:
            if trace: g.trace('initialDelegate',initialDelegate)
            # Replace the original mode by the delegate mode.
            self.init_mode(initialDelegate)
            language2,rulesetName2 = self.nameToRulesetName(initialDelegate)
            self.modes[rulesetName] = self.modes.get(rulesetName2)
            self.language_name = language2  # 2011/05/30
        else:
            self.language_name = language  # 2011/05/30
        return True
#@+node:ekr.20110605121601.18582: *9* nameToRulesetName
def nameToRulesetName (self,name):

    '''Compute language and rulesetName from name, which is either a language or a delegate name.'''

    if not name: return ''

    i = name.find('::')
    if i == -1:
        language = name
        rulesetName = '%s_main' % (language)
    else:
        language = name[:i]
        delegate = name[i+2:]
        rulesetName = self.munge('%s_%s' % (language,delegate))

    # if rulesetName == 'php_main': rulesetName = 'php_php'

    # g.trace(name,language,rulesetName)
    return language,rulesetName
#@+node:ekr.20110605121601.18583: *9* setKeywords
def setKeywords (self):

    '''Initialize the keywords for the present language.

     Set self.word_chars ivar to string.letters + string.digits
     plus any other character appearing in any keyword.'''

    # Add any new user keywords to leoKeywordsDict.
    d = self.keywordsDict
    keys = list(d.keys())
    for s in g.globalDirectiveList:
        key = '@' + s
        if key not in keys:
            d [key] = 'leokeyword'

    # Create a temporary chars list.  It will be converted to a dict later.
    chars = [g.toUnicode(ch) for ch in (string.ascii_letters + string.digits)]

    for key in list(d.keys()):
        for ch in key:
            if ch not in chars:
                chars.append(g.toUnicode(ch))

    # jEdit2Py now does this check, so this isn't really needed.
    # But it is needed for forth.py.
    for ch in (' ', '\t'):
        if ch in chars:
            # g.es_print('removing %s from word_chars' % (repr(ch)))
            chars.remove(ch)

    # g.trace(self.colorizer.language,[str(z) for z in chars])

    # Convert chars to a dict for faster access.
    self.word_chars = {}
    for z in chars:
        self.word_chars[z] = z
#@+node:ekr.20110605121601.18584: *9* setModeAttributes
def setModeAttributes (self):

    '''Set the ivars from self.attributesDict,
    converting 'true'/'false' to True and False.'''

    d = self.attributesDict
    aList = (
        ('default',         'null'),
	    ('digit_re',        ''),
        ('escape',          ''), # New in Leo 4.4.2.
	    ('highlight_digits',True),
	    ('ignore_case',     True),
	    ('no_word_sep',     ''),
    )

    # g.trace(d)

    for key, default in aList:
        val = d.get(key,default)
        if val in ('true','True'): val = True
        if val in ('false','False'): val = False
        setattr(self,key,val)
        # g.trace(key,val)
#@+node:ekr.20110605121601.18585: *9* initModeFromBunch
def initModeFromBunch (self,bunch):

    self.modeBunch = bunch
    self.attributesDict = bunch.attributesDict
    self.setModeAttributes()
    self.defaultColor   = bunch.defaultColor
    self.keywordsDict   = bunch.keywordsDict
    self.colorizer.language = bunch.language
    self.mode           = bunch.mode
    self.properties     = bunch.properties
    self.rulesDict      = bunch.rulesDict
    self.rulesetName    = bunch.rulesetName
    self.word_chars     = bunch.word_chars # 2011/05/21
#@+node:ekr.20110605121601.18586: *9* updateDelimsTables
def updateDelimsTables (self):

    '''Update g.app.language_delims_dict if no entry for the language exists.'''

    d = self.properties
    lineComment = d.get('lineComment')
    startComment = d.get('commentStart')
    endComment = d.get('commentEnd')

    if lineComment and startComment and endComment:
        delims = '%s %s %s' % (lineComment,startComment,endComment)
    elif startComment and endComment:
        delims = '%s %s' % (startComment,endComment)
    elif lineComment:
        delims = '%s' % lineComment
    else:
        delims = None

    if delims:
        d = g.app.language_delims_dict
        if not d.get(self.colorizer.language):
            d [self.colorizer.language] = delims
            # g.trace(self.colorizer.language,'delims:',repr(delims))
#@+node:ekr.20110605121601.18587: *8* munge
def munge(self,s):

    '''Munge a mode name so that it is a valid python id.'''

    valid = string.ascii_letters + string.digits + '_'

    return ''.join([g.choose(ch in valid,ch.lower(),'_') for ch in s])
#@+node:ekr.20110605121601.18588: *8* setFontFromConfig
def setFontFromConfig (self):

    c = self.c

    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.color_tags_list = []
#@+node:ekr.20110605121601.18589: *7*  Pattern matchers
#@+node:ekr.20110605121601.18590: *8*  About the pattern matchers
@nocolor-node
@

The following jEdit matcher methods return the length of the matched text if the
match succeeds, and zero otherwise. In most cases, these methods colorize all
the matched text.

The following arguments affect matching:

- at_line_start         True: sequence must start the line.
- at_whitespace_end     True: sequence must be first non-whitespace text of the line.
- at_word_start         True: sequence must start a word.
- hash_char             The first character that must match in a regular expression.
- no_escape:            True: ignore an 'end' string if it is preceded by
                        the ruleset's escape character.
- no_line_break         True: the match will not succeed across line breaks.
- no_word_break:        True: the match will not cross word breaks.

The following arguments affect coloring when a match succeeds:

- delegate              A ruleset name. The matched text will be colored recursively
                        by the indicated ruleset.
- exclude_match         If True, the actual text that matched will not be colored.
- kind                  The color tag to be applied to colored text.
#@+node:ekr.20110605121601.18591: *8* dump
def dump (self,s):

    if s.find('\n') == -1:
        return s
    else:
        return '\n' + s + '\n'
#@+node:ekr.20110605121601.18592: *8* Leo rule functions
#@+node:ekr.20110605121601.18593: *9* match_at_color
def match_at_color (self,s,i):

    if self.trace_leo_matches: g.trace()

    seq = '@color'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        self.colorizer.flag = True # Enable coloring.
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,'leokeyword')
        self.clearState()
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18594: *9* match_at_language
def match_at_language (self,s,i):

    trace = (False or self.trace_leo_matches) and not g.unitTesting
    if trace: g.trace(i,repr(s))

    seq = '@language'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        j = i + len(seq)
        j = g.skip_ws(s,j)
        k = g.skip_c_id(s,j)
        name = s[j:k]
        ok = self.init_mode(name)
        if trace: g.trace(ok,name)
        if ok:
            self.colorRangeWithTag(s,i,k,'leokeyword')
        self.clearState()
        return k - i
    else:
        return 0
#@+node:ekr.20110605121601.18595: *9* match_at_nocolor & restarter
def match_at_nocolor (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    # Only matches at start of line.
    if i == 0 and not g.match(s,i,'@nocolor-') and g.match_word(s,i,'@nocolor'):
        self.setRestart(self.restartNoColor)
        return len(s) # Match everything.
    else:
        return 0
#@+node:ekr.20110605121601.18596: *10* restartNoColor
def restartNoColor (self,s):

    if self.trace_leo_matches: g.trace(repr(s))

    if g.match_word(s,0,'@color'):
        self.clearState()
    else:
        self.setRestart(self.restartNoColor)

    return len(s) # Always match everything.
#@+node:ekr.20110605121601.18597: *9* match_at_killcolor & restarter
def match_at_killcolor (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@killcolor'

    if g.match_word(s,i,tag):
        self.setRestart(self.restartKillColor)
        return len(s) # Match everything.
    else:
        return 0

#@+node:ekr.20110605121601.18598: *10* restartKillColor
def restartKillColor(self,s):

    self.setRestart(self.restartKillColor)
    return len(s)+1
#@+node:ekr.20110605121601.18599: *9* match_at_nocolor_node & restarter
def match_at_nocolor_node (self,s,i):

    if self.trace_leo_matches: g.trace()

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@nocolor-node'

    if g.match_word(s,i,tag):
        self.setRestart(self.restartNoColorNode)
        return len(s) # Match everything.
    else:
        return 0
#@+node:ekr.20110605121601.18600: *10* restartNoColorNode
def restartNoColorNode(self,s):

    self.setRestart(self.restartNoColorNode)
    return len(s)+1
#@+node:ekr.20110605121601.18601: *9* match_blanks
def match_blanks (self,s,i):

    if not self.showInvisibles:
        return 0

    j = i ; n = len(s)

    while j < n and s[j] == ' ':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'blank')
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18602: *9* match_doc_part & restarter
def match_doc_part (self,s,i):

    # New in Leo 4.5: only matches at start of line.
    if i != 0:
        return 0
    elif g.match_word(s,i,'@doc'):
        j = i + 4
    elif g.match(s,i,'@') and (i+1 >= len(s) or s[i+1] in (' ','\t','\n')):
        j = i + 1
    else:
        return 0

    self.colorRangeWithTag(s,i,j,'leokeyword')
    self.colorRangeWithTag(s,j,len(s),'docpart')
    self.setRestart(self.restartDocPart)

    return len(s)
#@+node:ekr.20110605121601.18603: *10* restartDocPart
def restartDocPart (self,s):

    for tag in ('@c','@code'):
        if g.match_word(s,0,tag):
            j = len(tag)
            self.colorRangeWithTag(s,0,j,'leokeyword') # 'docpart')
            self.clearState()
            return j
    else:
        self.setRestart(self.restartDocPart)
        self.colorRangeWithTag(s,0,len(s),'docpart')

        return len(s)
#@+node:ekr.20110605121601.18604: *9* match_leo_keywords
def match_leo_keywords(self,s,i):

    '''Succeed if s[i:] is a Leo keyword.'''

    # g.trace(i,g.get_line(s,i))

    self.totalLeoKeywordsCalls += 1

    if s[i] != '@':
        return 0

    # fail if something besides whitespace precedes the word on the line.
    i2 = i-1
    while i2 >= 0:
        ch = s[i2]
        if ch == '\n':
            break
        elif ch in (' ','\t'):
            i2 -= 1
        else:
            # g.trace('not a word 1',repr(ch))
            return 0

    # Get the word as quickly as possible.
    j = i+1
    while j < len(s) and s[j] in self.word_chars:
        j += 1
    word = s[i+1:j] # entries in leoKeywordsDict do not start with '@'.

    if j < len(s) and s[j] not in (' ','\t','\n'):
        # g.trace('not a word 2',repr(word))
        return 0 # Fail, but allow a rescan, as in objective_c.

    if self.leoKeywordsDict.get(word):
        kind = 'leokeyword'
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j-i+1 # Bug fix: skip the last character.
        self.trace_match(kind,s,i,j)
        # g.trace('*** match',repr(s))
        return result
    else:
        # 2010/10/20: also check the keywords dict here.
        # This allows for objective_c keywords starting with '@'
        # This will not slow down Leo, because it is called
        # for things that look like Leo directives.
        word = '@' + word
        kind = self.keywordsDict.get(word)
        if kind:
            self.colorRangeWithTag(s,i,j,kind)
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            # g.trace('found',word)
            return j-i
        else:
            # g.trace('fail',repr(word),repr(self.word_chars))
            return -(j-i+1) # An important optimization.
#@+node:ekr.20110605121601.18605: *9* match_section_ref
def match_section_ref (self,s,i):

    if self.trace_leo_matches: g.trace()
    c = self.c ; p = c.currentPosition()
    w = self.w

    if not g.match(s,i,'<<'):
        return 0
    k = g.find_on_line(s,i+2,'>>')
    if k is not None:
        j = k + 2
        self.colorRangeWithTag(s,i,i+2,'namebrackets')
        ref = g.findReference(c,s[i:j],p)
        if ref:
            if self.use_hyperlinks:
                << set the hyperlink >>
            else:
                self.colorRangeWithTag(s,i+2,k,'link')
        else:
            self.colorRangeWithTag(s,i+2,k,'name')
        self.colorRangeWithTag(s,k,j,'namebrackets')
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18606: *10* << set the hyperlink >>
# Set the bindings to vnode callbacks.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
ref.tagName = tagName
#@+node:ekr.20110605121601.18607: *9* match_tabs
def match_tabs (self,s,i):

    if not self.showInvisibles:
        return 0

    if self.trace_leo_matches: g.trace()

    j = i ; n = len(s)

    while j < n and s[j] == '\t':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'tab')
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18608: *9* match_url_any/f/h  (new)
url_regex_f = re.compile(r"""(file|ftp)://[^\s'"]+[\w=/]""")
url_regex_h = re.compile(r"""(http|https)://[^\s'"]+[\w=/]""")
url_regex   = re.compile(r"""(file|ftp|http|https)://[^\s'"]+[\w=/]""")

def match_any_url(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):

def match_url_f(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_f)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):
    
def match_url_h(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_h)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):
#@+node:ekr.20110605121601.18609: *8* match_compiled_regexp (new)
def match_compiled_regexp (self,s,i,kind,regexp,delegate=''):

    '''Succeed if the compiled regular expression regexp matches at s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

    # if at_line_start and i != 0 and s[i-1] != '\n': return 0
    # if at_whitespace_end and i != g.skip_ws(s,0): return 0
    # if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0

    n = self.match_compiled_regexp_helper(s,i,regexp)
    if n > 0:
        j = i + n
        assert (j-i == n)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18610: *9* match_compiled_regexp_helper
def match_compiled_regexp_helper (self,s,i,regex):
    
    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = regex.match(s,i) # re_obj.search(s,i) 

    if mo is None:
        return 0
    start, end = mo.start(), mo.end()
    if start != i:
        return 0
    # if trace:
        # g.trace('pattern',pattern)
        # g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
        # g.trace('groups',mo.groups())
    return end - start
#@+node:ekr.20110605121601.18611: *8* match_eol_span
def match_eol_span (self,s,i,
    kind=None,seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if seq matches s[i:]'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        return 0

    if g.match(s,i,seq):
        j = len(s)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j # (was j-1) With a delegate, this could clear state.
    else:
        return 0
#@+node:ekr.20110605121601.18612: *8* match_eol_span_regexp
def match_eol_span_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if the regular expression regex matches s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,regexp)
    if n > 0:
        j = len(s)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18613: *8* match_everything
# def match_everything (self,s,i,kind=None,delegate='',exclude_match=False):

    # '''Match the entire rest of the string.'''

    # j = len(s)
    # self.colorRangeWithTag(s,i,j,kind,delegate=delegate)

    # return j
#@+node:ekr.20110605121601.18614: *8* match_keywords
# This is a time-critical method.
def match_keywords (self,s,i):

    '''Succeed if s[i:] is a keyword.'''

    # trace = False
    self.totalKeywordsCalls += 1

    # Important.  Return -len(word) for failure greatly reduces
    # the number of times this method is called.

    # We must be at the start of a word.
    if i > 0 and s[i-1] in self.word_chars:
        # if trace: g.trace('not at word start',s[i-1])
        return 0

    # Get the word as quickly as possible.
    j = i ; n = len(s) ; chars = self.word_chars
    while j < n and s[j] in chars:
        j += 1

    word = s[i:j]
    if self.ignore_case: word = word.lower()
    kind = self.keywordsDict.get(word)
    if kind:
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j - i
        # if trace: g.trace('success',word,kind,j-i)
        self.trace_match(kind,s,i,j)
        return result
    else:
        # if trace: g.trace('fail',word,kind)
        return -len(word) # An important new optimization.
#@+node:ekr.20110605121601.18615: *8* match_line
def match_line (self,s,i,kind=None,delegate='',exclude_match=False):

    '''Match the rest of the line.'''

    j = g.skip_to_end_of_line(s,i)

    self.colorRangeWithTag(s,i,j,kind,delegate=delegate)

    return j-i
#@+node:ekr.20110605121601.18616: *8* match_mark_following & getNextToken
def match_mark_following (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    trace = (True or self.verbose) and not g.unitTesting
    if not self.allow_mark_prev: return 0

    # if trace: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(pattern) + 1 < len(s) and s[i+len(pattern)] in self.word_chars:
        return 0 # 7/5/2008

    if g.match(s,i,pattern):
        j = i + len(pattern)
        # self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
        k = self.getNextToken(s,j)
        # 2011/05/31: Do not match *anything* unless there is a token following.
        if k > j:
            self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
            self.colorRangeWithTag(s,j,k,kind,exclude_match=False)
            j = k
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            return j - i
        else:
            return 0
    else:
        return 0
#@+node:ekr.20110605121601.18617: *9* getNextToken
def getNextToken (self,s,i):

    '''Return the index of the end of the next token for match_mark_following.

    The jEdit docs are not clear about what a 'token' is, but experiments with jEdit
    show that token means a word, as defined by word_chars.'''
    
    # 2011/05/31: Might we extend the concept of token?
    # If s[i] is not a word char, should we return just it?

    while i < len(s) and s[i] in self.word_chars:
        i += 1

    # 2011/05/31: was i+1
    return min(len(s),i)
#@+node:ekr.20110605121601.18618: *8* match_mark_previous
def match_mark_previous (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Return the length of a matched SEQ or 0 if no match.

    'at_line_start':    True: sequence must start the line.
    'at_whitespace_end':True: sequence must be first non-whitespace text of the line.
    'at_word_start':    True: sequence must start a word.'''

    # This match was causing most of the syntax-color problems.
    return 0 # 2009/6/23
#@+node:ekr.20110605121601.18619: *8* match_regexp_helper
def match_regexp_helper (self,s,i,pattern):

    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

    trace = False and not g.unitTesting
    if trace: g.trace('%-10s %-20s %s' % (
        self.colorizer.language,pattern,s)) # g.callers(1)

    try:
        flags = re.MULTILINE
        if self.ignore_case: flags|= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        # Do not call g.es here!
        g.trace('Invalid regular expression: %s' % (pattern))
        return 0

    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = re_obj.match(s,i) # re_obj.search(s,i) 

    if mo is None:
        return 0
    else:
        start, end = mo.start(), mo.end()
        if start != i: # Bug fix 2007-12-18: no match at i
            return 0
        if trace:
            g.trace('pattern',pattern)
            g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
            g.trace('groups',mo.groups())
        return end - start
#@+node:ekr.20110605121601.18620: *8* match_seq
def match_seq (self,s,i,
    kind='',seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if s[:] mathces seq.'''

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars:  # 7/5/2008
        j = i
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        j = i # 7/5/2008
    elif g.match(s,i,seq):
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
    else:
        j = i
    return j - i
#@+node:ekr.20110605121601.18621: *8* match_seq_regexp
def match_seq_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if the regular expression regexp matches at s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0

    n = self.match_regexp_helper(s,i,regexp)
    j = i + n
    assert (j-i == n)
    self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
    self.prev = (i,j,kind)
    self.trace_match(kind,s,i,j)
    return j - i
#@+node:ekr.20110605121601.18622: *8* match_span & helper & restarter
def match_span (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False,no_word_break=False):

    '''Succeed if s[i:] starts with 'begin' and contains a following 'end'.'''

    trace = False and not g.unitTesting
    if i >= len(s): return 0

    # g.trace(begin,end,no_escape,no_line_break,no_word_break)

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars:
        j = i
    elif at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        j = i
    elif not g.match(s,i,begin):
        j = i
    else:
        # We have matched the start of the span.
        j = self.match_span_helper(s,i+len(begin),end,
            no_escape,no_line_break,no_word_break=no_word_break)
        # g.trace('** helper returns',j,len(s))
        if j == -1:
            j = i # A real failure.
        else:
            # A match
            i2 = i + len(begin) ; j2 = j + len(end)
            if delegate:
                self.colorRangeWithTag(s,i,i2,kind,delegate=None,    exclude_match=exclude_match)
                self.colorRangeWithTag(s,i2,j,kind,delegate=delegate,exclude_match=exclude_match)
                self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
            else:
                self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
            j = j2
            self.prev = (i,j,kind)

    self.trace_match(kind,s,i,j)

    if j > len(s):
        j = len(s) + 1
        def boundRestartMatchSpan(s):
            # Note: bindings are frozen by this def.
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate,end,exclude_match,kind,
                no_escape,no_line_break,no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keywords args.
            delegate=delegate,end=end,
            exclude_match=exclude_match,
            kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)

        if trace: g.trace('***Continuing',kind,i,j,len(s))
    elif j != i:
        if trace: g.trace('***Ending',kind,i,j,s[i:j])
        self.clearState()

    return j - i # Correct, whatever j is.
#@+node:ekr.20110605121601.18623: *9* match_span_helper
def match_span_helper (self,s,i,pattern,no_escape,no_line_break,no_word_break):

    '''Return n >= 0 if s[i] ends with a non-escaped 'end' string.'''

    esc = self.escape

    while 1:
        j = s.find(pattern,i)
        # g.trace(no_line_break,j,len(s))
        if j == -1:
            # Match to end of text if not found and no_line_break is False
            if no_line_break:
                return -1
            else:
                return len(s)+1
        elif no_word_break and j > 0 and s[j-1] in self.word_chars:
            return -1 # New in Leo 4.5.
        elif no_line_break and '\n' in s[i:j]:
            return -1
        elif esc and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == esc:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # Continue searching past the escaped pattern string.
                i = j + len(pattern) # Bug fix: 7/25/07.
                # g.trace('escapes',escapes,repr(s[i:]))
            else:
                return j
        else:
            return j
#@+node:ekr.20110605121601.18624: *9* restart_match_span
def restart_match_span (self,s,
    delegate,end,exclude_match,kind,
    no_escape,no_line_break,no_word_break):

    '''Remain in this state until 'end' is seen.'''

    trace = False and not g.unitTesting

    i = 0
    j = self.match_span_helper(s,i,end,no_escape,no_line_break,no_word_break)
    if j == -1:
        j2 = len(s)+1
    elif j > len(s):
        j2 = j
    else:
        j2 = j + len(end)

    if delegate:
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
    else: # avoid having to merge ranges in addTagsToList.
        self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
    j = j2

    self.trace_match(kind,s,i,j)

    if j > len(s):
        def boundRestartMatchSpan(s):
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate,end,exclude_match,kind,
                no_escape,no_line_break,no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keywords args.
            delegate=delegate,end=end,kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)

        if trace: g.trace('***Re-continuing',i,j,len(s),s,g.callers(5))
    else:
        if trace: g.trace('***ending',i,j,len(s),s)
        self.clearState()

    return j # Return the new i, *not* the length of the match.
#@+node:ekr.20110605121601.18625: *8* match_span_regexp
def match_span_regexp (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False, no_word_break=False,
):

    '''Succeed if s[i:] starts with 'begin' (a regular expression) and contains a following 'end'.'''

    if self.verbose: g.trace('begin',repr(begin),'end',repr(end),self.dump(s[i:]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,begin)
    # We may have to allow $n here, in which case we must use a regex object?
    if n > 0:
        j = i + n
        j2 = s.find(end,j)
        if j2 == -1: return 0
        if self.escape and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == self.escape:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # An escaped end **aborts the entire match**:
                # there is no way to 'restart' the regex.
                return 0
        i2 = j2 - len(end)
        if delegate:
            self.colorRangeWithTag(s,i,j,kind, delegate=None,     exclude_match=exclude_match)
            self.colorRangeWithTag(s,j,i2,kind, delegate=delegate,exclude_match=False)
            self.colorRangeWithTag(s,i2,j2,kind,delegate=None,    exclude_match=exclude_match)
        else: # avoid having to merge ranges in addTagsToList.
            self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j2)
        return j2 - i
    else: return 0
#@+node:ekr.20110605121601.18626: *8* match_word_and_regexp
def match_word_and_regexp (self,s,i,
    kind1='',word='',
    kind2='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    if not self.allow_mark_prev: return 0

    if (False or self.verbose): g.trace(i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0
    if at_word_start and i + len(word) + 1 < len(s) and s[i+len(word)] in self.word_chars:
        j = i

    if not g.match(s,i,word):
        return 0

    j = i + len(word)
    n = self.match_regexp_helper(s,j,pattern)
    if n == 0:
        return 0
    self.colorRangeWithTag(s,i,j,kind1,exclude_match=exclude_match)
    k = j + n
    self.colorRangeWithTag(s,j,k,kind2,exclude_match=False)    
    self.prev = (j,k,kind2)
    self.trace_match(kind1,s,i,j)
    self.trace_match(kind2,s,j,k)
    return k - i
#@+node:ekr.20110605121601.18627: *8* skip_line
def skip_line (self,s,i):

    if self.escape:
        escape = self.escape + '\n'
        n = len(escape)
        while i < len(s):
            j = g.skip_line(s,i)
            if not g.match(s,j-n,escape):
                return j
            # g.trace('escape',s[i:j])
            i = j
        return i
    else:
        return g.skip_line(s,i)
            # Include the newline so we don't get a flash at the end of the line.
#@+node:ekr.20110605121601.18628: *8* trace_match
def trace_match(self,kind,s,i,j):

    if j != i and self.trace_match_flag:
        g.trace(kind,i,j,g.callers(2),self.dump(s[i:j]))
#@+node:ekr.20110605121601.18629: *7*  State methods
#@+node:ekr.20110605121601.18630: *8* clearState
def clearState (self):

    self.setState(-1)
#@+node:ekr.20110605121601.18631: *8* computeState
def computeState (self,f,keys):

    '''Compute the state name associated with f and all the keys.

    Return a unique int n representing that state.'''

    # Abbreviate arg names.
    d = {
        'delegate':'del:',
        'end':'end',
        'at_line_start':'line-start',
        'at_whitespace_end':'ws-end',
        'exclude_match':'exc-match',
        'no_escape':'no-esc',
        'no_line_break':'no-brk',
        'no_word_break':'no-word-brk',
    }
    result = [
        f.__name__,
        self.colorizer.language,
        self.rulesetName]
    for key in keys:
        keyVal = keys.get(key)
        val = d.get(key)
        if val is None:
            val = keys.get(key)
            result.append('%s=%s' % (key,val))
        elif keyVal is True:
            result.append('%s' % val)
        elif keyVal is False:
            pass
        elif keyVal not in (None,''):
            result.append('%s=%s' % (key,keyVal))
    state = ';'.join(result)

    n = self.stateNameToStateNumber(f,state)
    return n
#@+node:ekr.20110605121601.18632: *8* currentState and prevState
def currentState(self):

    return self.highlighter.currentBlockState()

def prevState(self):

    return self.highlighter.previousBlockState()
#@+node:ekr.20110605121601.18633: *8* setRestart
def setRestart (self,f,**keys):

    n = self.computeState(f,keys)
    self.setState(n)
#@+node:ekr.20110605121601.18634: *8* setState
def setState (self,n):

    trace = False and not g.unitTesting

    self.highlighter.setCurrentBlockState(n)

    if trace:
        stateName = self.showState(n)
        g.trace(stateName,g.callers(4))
#@+node:ekr.20110605121601.18635: *8* showState & showCurrentState
def showState (self,n):

    if n == -1: 
        return 'default-state'
    else:
        return self.stateDict.get(n,'<no state>')

def showCurrentState(self):

    n = self.currentState()
    return self.showState(n)

def showPrevState(self):

    n = self.prevState()
    return self.showState(n)
#@+node:ekr.20110605121601.18636: *8* stateNameToStateNumber
def stateNameToStateNumber (self,f,stateName):

    # stateDict:     Keys are state numbers, values state names.
    # stateNameDict: Keys are state names, values are state numbers.
    # restartDict:   Keys are state numbers, values are restart functions

    n = self.stateNameDict.get(stateName)
    if n is None:
        n = self.nextState
        self.stateNameDict[stateName] = n
        self.stateDict[n] = stateName
        self.restartDict[n] = f
        self.nextState += 1
        # g.trace('========',n,stateName)

    return n
#@+node:ekr.20110605121601.18637: *7* colorRangeWithTag
def colorRangeWithTag (self,s,i,j,tag,delegate='',exclude_match=False):

    '''Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.'''

    trace = False and not g.unitTesting
        # A superb trace: enable this first to see what gets colored.

    # Pattern matcher may set the .flag ivar.
    if self.colorizer.killColorFlag or not self.colorizer.flag:
        if trace: g.trace('disabled')
        return

    if delegate:
        if trace:
            s2 = g.choose(len(repr(s[i:j])) <= 20,repr(s[i:j]),repr(s[i:i+17-2]+'...'))
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (delegate,tag)),i,j,s2,g.callers(2)))
        # self.setTag(tag,s,i,j) # 2011/05/31: Do the initial color.
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        while 0 <= i < j and i < len(s):
            progress = i
            assert j >= 0,j
            for f in self.rulesDict.get(s[i],[]):
                n = f(self,s,i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n > 0:
                    # if trace: g.trace('delegate',delegate,i,n,f.__name__,repr(s[i:i+n]))
                    i += n ; break
            else:
                # New in Leo 4.6: Use the default chars for everything else.
                # New in Leo 4.8 devel: use the *delegate's* default characters if possible.
                default_tag = self.attributesDict.get('default')
                # g.trace(default_tag)
                self.setTag(default_tag or tag,s,i,i+1)
                i += 1
            assert i > progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        if trace:
            s2 = g.choose(len(repr(s[i:j])) <= 20,repr(s[i:j]),repr(s[i:i+17-2]+'...'))
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (self.language_name,tag)),i,j,s2,g.callers(2)))
        self.setTag(tag,s,i,j)
        
    if tag != 'url':
        # Allow URL's *everywhere*.
        j = min(j,len(s))
        while i < j:
            if s[i].lower() in 'fh': # file|ftp|http|https
                n = self.match_any_url(s,i)
                i += max(1,n)
            else:
                i += 1
#@+node:ekr.20110605121601.18638: *7* mainLoop & restart
def mainLoop(self,n,s):

    '''Colorize a *single* line s, starting in state n.'''

    trace = False and not g.unitTesting
    traceMatch = True
    traceState = True
    verbose = False
    
    if trace:
        if traceState:
            g.trace('%-30s' % ('** start: %s' % self.showState(n)),repr(s))
        else:
            g.trace(self.language_name,repr(s))
                # Called from recolor.

    i = 0
    if n > -1:
        i = self.restart(n,s,trace and traceMatch)
    if i == 0:
        self.setState(self.prevState())
        
    if False and trace:
        aList = self.rulesDict.get('<')
        for f in aList:
            g.trace(f.__name__)
        
        
    while i < len(s):
        progress = i
        functions = self.rulesDict.get(s[i],[])
        for f in functions:
            n = f(self,s,i)
            if n is None:
                g.trace('Can not happen: n is None',repr(f))
                break
            elif n > 0: # Success.
                if trace and traceMatch and f.__name__!='match_blanks':
                    g.trace('%-30s' % ('   match: %s' % (f.__name__,)),
                        repr(s[i:i+n]))
                # The match has already been colored.
                i += n
                break # Stop searching the functions.
            elif n < 0: # Fail and skip n chars.
                if trace and traceMatch and verbose:
                    g.trace('fail: %-30s %s' % (
                        f.__name__,repr(s[i:i+n])))
                i += -n
                break # Stop searching the functions.
            else: # Fail. Try the next function.
                pass # Do not break or change i!
        else:
            i += 1
        assert i > progress

    # Don't even *think* about clearing state here.
    # We remain in the starting state unless a match happens.
    if trace and traceState:
        g.trace('%-30s' % ('** end:   %s' % self.showCurrentState()),repr(s))
#@+node:ekr.20110605121601.18639: *8* restart
def restart (self,n,s,traceMatch):

    f = self.restartDict.get(n)
    if f:
        i = f(s)
        fname = f.__name__
        if traceMatch:
            if i > 0:
                g.trace('** restart match',fname,s[:i])
            else:
                g.trace('** restart fail',fname,s)
    else:
        g.trace('**** no restart f')
        i = 0

    return i
#@+node:ekr.20110605121601.18640: *7* recolor
def recolor (self,s):

    '''Recolor a *single* line, s.'''

    trace = False and not g.unitTesting
    callers = False ; line = True ; state = True

    # Update the counts.
    self.recolorCount += 1
    self.totalChars += len(s)

    if self.colorizer.changingText:
        return
    if not self.colorizer.flag:
        return

    # Get the previous state.
    n = self.prevState() # The state at the end of the previous line.
    if trace:
        if line and state:
            g.trace('%2s %s %s' % (n,self.showState(n),repr(s)))
        elif line:
            g.trace('%2s %s' % (n,repr(s)))
        if callers:
            # Called from colorize:rehightlight,highlightBlock
            g.trace(g.callers())

    if s.strip() or self.showInvisibles:
        self.mainLoop(n,s)
    else:
        self.setState(n) # Required
#@+node:ekr.20110605121601.18641: *7* setTag
def setTag (self,tag,s,i,j):

    trace = False and not g.unitTesting

    if i == j:
        if trace: g.trace('empty range')
        return

    w = self.w # A leoQTextEditWidget
    tag = tag.lower() # 2011/10/28
    colorName = w.configDict.get(tag)

    # Munge the color name.
    if not colorName:
        if trace: g.trace('no color for %s' % tag)
        return

    if colorName[-1].isdigit() and colorName[0] != '#':
        colorName = colorName[:-1]

    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name',colorName,g.callers())

    underline = w.configUnderlineDict.get(tag)

    format = QtGui.QTextCharFormat()

    font = self.fonts.get(tag)
    if font:
        format.setFont(font)

    if trace:
        self.tagCount += 1
        g.trace(
            '%3s %3s %3s %9s %7s' % (i,j,len(s),font and id(font) or '<no font>',colorName),
            '%-10s %-25s' % (tag,s[i:j]),g.callers(2))

    if tag in ('blank','tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setFontUnderline(True)
    else:
        format.setForeground(color)

    self.highlighter.setFormat (i,j-i,format)

#@+node:ekr.20110605121601.18556: *5* scanColorDirectives (leoQtColorizer) & helper
def scanColorDirectives(self,p):
    
    '''Set self.language based on the directives in p's tree.'''

    trace = False and not g.unitTesting
    c = self.c
    if c == None: return None # self.c may be None for testing.
    
    root = p.copy()
    self.language = None
    self.rootMode = None # None, "code" or "doc"

    for p in root.self_and_parents():
        theDict = g.get_directives_dict(p)
        # if trace: g.trace(p.h,theDict)
        << Test for @language >>
        << Test for @root, @root-doc or @root-code >>
        
    # 2011/05/28: If no language, get the language from any @<file> node.
    if self.language:
        if trace: g.trace('found @language %s' % (self.language))
        return self.language
        
    #  Attempt to get the language from the nearest enclosing @<file> node.
    self.language = g.getLanguageFromAncestorAtFileNode(root)

    if not self.language:
        if trace: g.trace('using default',c.target_language)
        self.language = c.target_language

    return self.language # For use by external routines.
#@+node:ekr.20110605121601.18557: *6* << Test for @language >>
if 'language' in theDict:
    s = theDict["language"]
    i = g.skip_ws(s,0)
    j = g.skip_c_id(s,i)
    aList = self.findLanguageDirectives(p)
    # In the root node, we use the first (valid) @language directive,
    # no matter how many @language directives the root node contains.
    # In ancestor nodes, only unambiguous @language directives
    # set self.language.
    if p == root or len(aList) == 1:
        self.languageList = aList
        self.language = aList and aList[0] or []
        break
#@+node:ekr.20110605121601.18558: *6* << Test for @root, @root-doc or @root-code >>
if 'root' in theDict and not self.rootMode:

    s = theDict["root"]
    if g.match_word(s,0,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,0,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@+node:ekr.20110605121601.18559: *6* findLanguageDirectives
def findLanguageDirectives (self,p):

    '''Scan p's body text for *valid* @language directives.

    Return a list of languages.'''
    
    # Speed not very important: called only for nodes containing @language directives.
    trace = False and not g.unitTesting
    aList = []
    for s in g.splitLines(p.b):
        if g.match_word(s,0,'@language'):
            i = len('@language')
            i = g.skip_ws(s,i)
            j = g.skip_id(s,i)
            if j > i:
                word = s[i:j]
                if self.isValidLanguage(word):
                    aList.append(word)
                else:
                    if trace:g.trace('invalid',word)

    if trace: g.trace(aList)
    return aList
#@+node:ekr.20110605121601.18560: *6* isValidLanguage
def isValidLanguage (self,language):
    
    fn = g.os_path_join(g.app.loadDir,'..','modes','%s.py' % (language))
    return g.os_path_exists(fn)
#@+node:ekr.20111114085925.9932: *4* Why does the unittest/output folder contain empty files?
#@+node:ekr.20031218072017.1462: *5* ic.exportHeadlines
def exportHeadlines (self,fileName):

    c = self.c ; p = c.p
    nl = g.u(self.output_newline)
    
    if not p: return
    self.setEncoding()
    firstLevel = p.level()

    try:
        theFile = open(fileName,'w')
    except IOError:
        g.es("can not open",fileName,color="blue")
        c.testManager.fail()
        return
    for p in p.self_and_subtree():
        head = p.moreHead(firstLevel,useVerticalBar=True)
        s = head + nl
        if not g.isPython3: # 2010/08/27
            s = g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
        theFile.write(s)
    theFile.close()
#@+node:ekr.20051104075904.78: *5* TM.makeImportExportSuite
def makeImportExportSuite(self,parentHeadline,doImport):

    """Create an Import/Export test for every descendant of testParentHeadline.."""

    tm = self
    c = self.c
    parent = tm.findNodeAnywhere(parentHeadline)
    assert parent,'node not found: %s' % (parentHeadline)
    temp = tm.findNodeInTree(parent,"tempNode")
    assert temp,'node not found: tempNode'

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)

    for p in parent.children():
        if p != temp:
            # 2009/10/02: avoid copy arg to iter
            p2 = p.copy()
            dialog = tm.findNodeInTree(p2,"dialog")
            assert(dialog)
            test = importExportTestCase(c,p2,dialog,temp,doImport)
            suite.addTest(test)

    return suite
#@+node:ekr.20051104075904.79: *5* class importExportTestCase
class importExportTestCase(unittest.TestCase):

    """Data-driven unit tests for Leo's edit body commands."""

    @others
#@+node:ekr.20051104075904.80: *6* __init__ (importExportTestCase)
def __init__ (self,c,p,dialog,temp_p,doImport):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.dialog = dialog
    self.p = p.copy()
    self.temp_p = temp_p.copy()

    self.gui = None
    self.oldGui = None
    self.wasChanged = c.changed
    self.fileName = ""
    self.doImport = doImport

    self.old_p = c.p
#@+node:ekr.20051104075904.81: *6*  fail (importExportTestCase)
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@+node:ekr.20051104075904.82: *6* importExport
def importExport (self):

    c = self.c ; p = self.p

    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    commandName = p.h
    command = getattr(c,commandName) # Will fail if command does not exist.
    command(event=None)

    failedMethod = g.app.unitTestDict.get("fail")
    self.failIf(failedMethod,failedMethod)
#@+node:ekr.20051104075904.83: *6* runTest
def runTest(self):

    # """Import Export Test Case"""

    self.importExport()
#@+node:ekr.20051104075904.84: *6* setUp
def setUp(self):

    trace = False
    c = self.c ; temp_p = self.temp_p
    d = self.dialog

    temp_p.setBodyString('')

    # Create a node under temp_p.
    child = temp_p.insertAsLastChild()
    assert(child)
    c.setHeadString(child,"import/export test: " + self.p.h)
    c.selectPosition(child)

    assert(d)
    s = d.bodyString()
    lines = s.split('\n')
    name = lines[0]
    fileName = lines[1]

    # Replace '\\' by os.path.sep in fileName
    try:
        # os.path.sep does not exist in Python 2.2.x.
        sep = os.path.sep
        fileName = fileName.replace('\\',sep)
    except AttributeError:
        fileName = g.os_path_normpath(fileName)

    self.fileName = fileName = g.os_path_finalize_join(g.app.loadDir,"..",fileName)
    if trace: g.trace('(importExportTestCase',fileName)

    if self.doImport:
        theDict = {name: [fileName]}
    else:
        theDict = {name: fileName}

    self.oldGui = g.app.gui
    self.gui = leoGui.unitTestGui(theDict,trace=False)
#@+node:ekr.20051104075904.85: *6* shortDescription
def shortDescription (self):

    try:
        return "ImportExportTestCase: %s %s" % (self.p.h,self.fileName)
    except Exception:
        return "ImportExportTestCase"
#@+node:ekr.20051104075904.86: *6* tearDown
def tearDown (self):

    c = self.c ; temp_p = self.temp_p

    if self.gui:
        self.gui.destroySelf()
        self.gui = None

    temp_p.setBodyString("")
    temp_p.clearDirty()

    if not self.wasChanged:
        c.setChanged (False)

    if 1: # Delete all children of temp node.
        while temp_p.firstChild():
            temp_p.firstChild().doDelete()

    g.app.gui = self.oldGui
    c.selectPosition(self.old_p)
#@+node:ekr.20031218072017.2850: *5* c.exportHeadlines
def exportHeadlines (self,event=None):

    '''Export all headlines to an external file.'''

    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="headlines.txt",
        title="Export Headlines",
        filetypes=filetypes,
        defaultextension=".txt")
    c.bringToFront()

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.exportHeadlines(fileName)
#@+node:ekr.20110730093802.15134: *3* Bugs
#@+node:ekr.20110621074459.14904: *4* Fixed ancient hanger in paste-retaining-clones
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/800157

In a new file containing only a "NewHeadline" and that being selected, execute:

copy-node
insert-child
<<enter>>
undo
paste-retaining-clones

Leo's UI freezes and loops forever with 100% CPU.

Note: If one does not undo, Leo prints "Invalid paste: nodes may not descend
from themselves". I guess the undo circumvents such a check. However, that
should not be the case, as paste-retaining-clones inserts the clones _after_ and
not as children of the selected node "NewHeadline".

I guess that the undo forgets to set the selection back to "NewHeadline", so
that Leo tries to insert the clones after the undone child node - therefore as
child of "NewHeadline".

====================

EKR: only getLeoOutlineFromClipboar calls checkPaste.
#@+node:ekr.20110705101348.14898: *4* Fixed bug in p.setAllAncestorAtFileNodesDirty
@nocolor-node


The code that marks descendant @<file> nodes dirty now tests
p2.isAnyAtFileNode().  The old code tested p2.isAtThinFileNode().
#@+node:ekr.20110717110529.14970: *4* Removed timer hack from double-click code
#@+node:ekr.20110726130504.15081: *4* Fixed double-click problem
@nocolor-node

CAUTION: new double click handling code

http://groups.google.com/group/leo-editor/browse_thread/thread/dbd63b9b38911906

The problem isn't single/double, but double click not stopping the
event processing.  It has the correct form:

if g.doHook('doubleClick1') is None:
   do-normal-double-click-stuff
g.doHook('doubleClick2')

but I think some other route through the code, or additional processing
of the event means that even thought the handler registered on
doubleClick1 returns non-None, the node goes into headline edit mode,
with focus.

This is bad, because the doubleClick1 on an @url node attempts to
select and raise a different commander (tab), so now you're looking at
one commander but focus is in another, so what you type trashes the
headline in the original commander.

The timer shouldn't be needed - a 'doubleClick1' hook which returns
non-None should stop the headline going into edit mode.  If you can
make that be the case, all is well.
#@+node:ekr.20110728112148.6735: *4* Fixed url focus issues
#@+node:ekr.20110728093358.6702: *4* Fixed p1 > p2
#@+node:ekr.20110730091449.15132: *4* Fixed cacher problem
@nocolor-node

- leoCommands.__init__ now sets self.db = {}
- initGlobalDB now returns {} instead of None if there is no cacher.
#@+node:ekr.20110908155830.6875: *4* Fixed encoding problem with @shadow
@nocolor-node

Important notes:
    
readOpenFile reads the private shadow file, detecting the encoding.
#@+node:ekr.20110917130105.6873: *4* Fixed a w.see botch.
@nocolor-node

The call to w.see(ins+5) in rp_reformat created a big problem.

Replacing this with w.see(ins) is much better.
#@+node:ekr.20111003135314.15480: *4* Fixed a major DnD bug
#@+node:ekr.20111008073427.15594: *4* Fixed macro crash
# A misspelling:
    
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 409, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 1967, in fullCommand
    c.macroCommands.startrecordingMacro(event)
AttributeError: macroCommandsClass instance has no attribute 'startrecordingMacro'
#@+node:ekr.20111009162434.7206: *4* Regularized slashes in @edit/@file
@nocolor-node

Examples:
    
    @edit C:/leo.repo/ipython-0.12/IPython/frontend/qt/console/pygments_highlighter.py
        # The filename comes from g.app.gui.runOpenFileDialog
    
    @file C:\leo.repo\ipython-0.12\IPython\frontend\qt\console\pygments_highlighter.py
        # Created by import.
        
The problem was the call to g.os_path_normpath in importDerived files:
    it converts slashes to backslashes on windows (!!)
#@+node:ekr.20111010082822.15544: *4* Made sure Leo's write code auto-detects file extension
@nocolor-node

- Added getLanguageFromAncestorAtFileNode.

- Revised code in at.scanAllDirectives & leoQtColorizer.scanColorDirectives.
#@+node:ekr.20111010154337.15599: *4* Fixed k.setLabelRed
#@+node:ekr.20111012162536.9380: *4* Fixed cycle-editor-focus bug
qtBody can use the leoBody code.
#@+node:ekr.20111012093116.9386: *4* Fix the body-text scrolling reversion
@nocolor-node

- Marked with ### 2011/09/30

- Alt-x resets the scrollbar position!
    The focus gets pulled away, but the scrollbar position does not get saved.
#@+node:ekr.20111014074810.15650: *4* Fixed recent createFrame crash
#@+node:ekr.20111015150822.9346: *4* Fixed Py3k crash in quicksearch.py
@nocolor-node
 
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\plugins\quicksearch.py", line 187, in returnPressed
    self.scon.doSearch(t)
  File "c:\leo.repo\trunk\leo\plugins\quicksearch.py", line 289, in doSearch
    self.addBodyMatches(bm)
  File "c:\leo.repo\trunk\leo\plugins\quicksearch.py", line 257, in addBodyMatches
    self.its[it] = (p, None)
TypeError: unhashable type: 'QListWidgetItem'
#@+node:ekr.20111015150822.13125: *4* Removed all references to scrolledmessage plugin
@nocolor-node

The scrolledmessage plugin no longer exists.

The runScrolledMessageDialog *does* still exist, but it now uses the
viewrendered plugin.
#@+node:ekr.20111016210000.15951: *4* Support @ignore when installing @command/@button nodes
@nocolor-node

Changed doButtons and doCommands kind handlers.

This allows us to put example nodes in leoSettings.leo.
#@+node:ekr.20111020113237.15895: *4* Fixed crasher in runScrolledMessageDialog
#@+node:ekr.20111017132257.15885: *4* Macro expansion now forces a full recolor
@nocolor-node

Could this be done as part of abbreviation expansion?
#@+node:ekr.20111021105253.9479: *4* Fixed serious atFile read bug
@nocolor-node

Changed at.readEndOthers and at.readEndRef so that they
always set at.inCode = True
#@+node:ekr.20111021105253.9480: *4* Fixed unicode bugs with @shadow
@nocolor-node

Fixed several encoding problems related to this thread: @shadow - @encoding windows-1250 - problem
http://groups.google.com/group/leo-editor/browse_thread/thread/a4ba80559447218a/9a37a4ed6c44d452

There were several real problems fixed.  The summary: @encoding directives were always required.

In detail:

1. at.initWriteIvars now checks for a Python # -*- coding: line.
   If present, it must be the very first line.
   If present, it will override any @encoding directives.

2. g.getPythonEncodingFromString now can deal with either of the following lines:

    @first # -*- coding: utf-8 -*-
    # -*- coding: utf-8 -*-

That is, g.getPythonEncodingFromString can strip the leading @first.

3. g.readlineForceUnixNewline and x.propagate_changes now catch UnicodeDecodeError.
   This is very important: previously decoding errors crashed Leo!.

All unit tests pass with both Python 2.x and 3.x.

#@+node:ekr.20111024091133.16699: *4* Recompute width of hard tabs depending on @tabwidth
@nocolor-node

Added configure_hard_tab_width method.
#@+node:ekr.20111024170505.16464: *4* Applied patch for Bug 800311: Undo: Word granularity should recognize cursor movements
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/800311

Having set undo to word granularity, I often change something, move to a
different line and continue editing there. When I want to undo my last change,
Leo also undoes the change in the other place, as word granularity currently
only recognises a new undo step when a new word is started, no matter if we
moved to a completely different position first.

The attached patch fixes the issue by remembering the previous cursor position.

Something else about the undo code:

- oldSel and newSel are never set to None in the constructor -> it's quite hard
  to know they are there without reading the whole code

- It would be cool if there could be some more comments in that section; e.g. to
  tell that oldSel and newSel from which old_row, old_col, new_row and new_col
  actually mean: old = "the position right before doing the change" and new =
  "the position right after doing the change" and that old != "the position
  after the change before" (which I added as prevSel) - it took me ages to
  discover this

- There are duplicate "The new and old characters are not contiguous." checks.
  Are they different/necessary?

- The "We have just inserted a line." section is not only entered on a new line
  (see other attached patch)
#@+node:ekr.20111024170505.16460: *4* Applied patch for Bug 800312: Collapsing node moves should be optional
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/800312
#@+node:ekr.20111025062953.16480: *4* Fixed Bug 880975: Binding Meta and print-bindings
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/880975

Bug: The Meta+Ctrl section [of print-bindings] is always empty and this makes it
misleading.

Fix: the prefix list in k.printBindings must be sure that if two prefixes have a
common leading part the longer prefix appears first in the lists.
#@+node:ekr.20111026091322.16493: *4* Fixed bug 823601: cascade-windows fails
exception executing command
Traceback (most recent call last):
  File "/home/bob/bzrWork/pluginPath/leo/core/leoCommands.py", line 408, in doCommand
    val = command(event)
  File "/home/bob/bzrWork/pluginPath/leo/plugins/qtGui.py", line 4965, in cascade
    w.setGeometry(x,y,r.width(),r.height())
TypeError: setGeometry() takes exactly 2 arguments (5 given)
#@+node:ekr.20111026115337.16527: *4* Generalized stylesheet handling
# A temporary fix while waiting for Terry's css work.
#@+node:ekr.20111026115337.16529: *5* Notes
@language rest

Here's how it works:  code that wants to set a particular part of a
widget's style sheet calls::

   g.app.gui.update_style_sheet(w,key,value)

where w is the widget whose stylesheet is to be changed, key is unique
to the method (or group of methods), and value is the new version of
the stylesheet **for the particular key** to be added.  Examples::

   # In setEditorColors.
   sheet = 'background-color: %s; color: %s' % (bg,fg)
   g.app.gui.update_style_sheet(obj,'colors',sheet)

   # In add_border.
   sheet = "border: %spx solid %s" % (
       c.focus_border_width,c.focus_border_color)
   self.update_style_sheet(w,'border',sheet)

   # In remove_border.
   sheet = "border: %spx solid white" % (c.focus_border_width)
   self.update_style_sheet(w,'border',sheet)

So add_border and remove_border work together because they use the
same 'border' key.

g.app.gui.update_style_sheet is straightforward: it injects a Python
dict called leo_stylesheet_dict into the widget, and computes the
total stylesheet as follows::

   # Step one: update the dict.
   d = hasattr(w,'leo_styles_dict') and w.leo_styles_dict or {}
   d[key] = value
   w.leo_styles_dict = d

   # Step two: update the stylesheet.
   aList = [d.get(key) for key in list(d.keys())]
   s = ';'.join(aList)
   w.setStyleSheet(s)
#@+node:ekr.20111026231721.16616: *4* Scrolling bug
@nocolor-node

An attempt at fixing the scrolling bug
http://groups.google.com/group/leo-editor/browse_thread/thread/de76f22b16ebc8f/7f6aa691002f1fca

Private email from Viktor
test-leo-rev-4506.leo

It looks like I can reproduce the scrolling problem with your file as follows:

- Select the last node: AM-Session
- Manually scroll down to the last line.
- Click at the end of text: the body pane scrolls.  Bug!


Downloaded leo-editor-snapshot-201110240253.zip and tried it out. Noticed that
when I added a dozen or so blank lines at the end of a body pane and moved the
mouse cursor to the last line and left-clicked the body pane jumped backwards
about 10 lines or so as though I had scrolled up. When I dragged the scroll
button to the end of the pane, the insertion point was still at the end of the
pane. This does not happen for all panes.
#@+node:ekr.20111123030145.10211: *5* Notes
@nocolor-node

Methods relating to this problem:

g.trace_scroll
w.see
w.seeInsertPoint
w.get/setYScrollPosition
p.restoreCursorAndScroll
v.restoreCursorAndScroll

leoKeyHandler:
    k.keykBoardQuit
    k.showStateAndMode
    k.setLabel
        ***** calls w.widget.ensureCursorVisible

leoQtBody:
    onFocusColorHelper
        ***** calls w.widget.ensureCursorVisible
        
leoQtBaseTextWidget:
    mouseReleaseEvent
        Added code that didn't work: now commented out.
        
leoEditCommands:
    updateAutoIndent
        ***** calls w.seeInsertPoint
#@+node:ekr.20111001155050.15480: *6* First attempt
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/de76f22b16ebc8f

As explained in detail in the thread, "dangerous" code is no longer executed immediately,
but instead executed at idle time using g.app.gui.runAtIdle.
#@+node:ekr.20110930174206.15471: *5* Second attempt
@nocolor-node

The last time it happened:
    
- Search for something.
- Manually scroll the pane.
- Click scrolls the pane again.
#@+node:ekr.20110930174206.15474: *6* Changed
#@+node:ekr.20110605121601.18209: *7* deactivateEditors (qtBody)
def deactivateEditors(self,wrapper):

    '''Deactivate all editors except wrapper's editor.'''

    trace = False and not g.unitTesting
    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        wrapper2 = d.get(key)
        w2 = wrapper2.widget
        if hasattr(w2,'leo_active'):
            active = w2.leo_active
        else:
            active = True
        if wrapper2 != wrapper and active:
            w2.leo_active = False
            self.unselectLabel(wrapper2)
            w2.leo_scrollBarSpot = wrapper2.getYScrollPosition()
            w2.leo_insertSpot = wrapper2.getInsertPoint()
            w2.leo_selection = wrapper2.getSelectionRange()
            if trace: g.trace('**deactivate wrapper %s w %s' % (
                id(wrapper2),id(w2)))
            self.onFocusOut(w2)
#@+node:ekr.20070424080640: *7* deactivateActiveEditor (leoBody)
def deactivateActiveEditor(self,w):

    '''Inactivate the previously active editor.'''

    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.getYScrollPosition()
            w2.leo_insertSpot = w2.getInsertPoint()
            w2.leo_selection = w2.getSelectionRange()
            return
#@+node:ekr.20110605121601.18027: *7* injectIvars (leoQtBaseTextWidget)
def injectIvars (self,name='1',parentFrame=None):

    w = self ; p = self.c.currentPosition()

    if name == '1':
        w.leo_p = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()

    w.leo_active = True

    # New in Leo 4.4.4 final: inject the scrollbar items into the text widget.
    w.leo_bodyBar = None
    w.leo_bodyXBar = None
    w.leo_chapter = None
    w.leo_frame = None
    w.leo_name = name
    w.leo_label = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    return w
#@+node:ekr.20110605121601.18211: *7* injectIvars (qtBody)
def injectIvars (self,parentFrame,name,p,wrapper):

    trace = False and not g.unitTesting

    w = wrapper.widget
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    assert isinstance(w,QtGui.QTextEdit),w

    if trace: g.trace(w)

    # Inject ivars
    if name == '1':
        w.leo_p = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()

    w.leo_active = True
    w.leo_bodyBar = None
    w.leo_bodyXBar = None
    w.leo_chapter = None
    # w.leo_colorizer = None # Set in leoQtColorizer ctor.
    w.leo_frame = parentFrame
    w.leo_insertSpot = None
    # w.leo_label = None # Injected by packLabel.
    w.leo_name = name
    # w.leo_on_focus_in = onFocusInCallback
    w.leo_scrollBarSpot = None
    w.leo_selection = None
    w.leo_wrapper = wrapper
#@+node:ekr.20070423102603: *7* selectEditorHelper (leoBody)
def selectEditorHelper (self,w):

    c = self.c ; cc = c.chapterController ; d = self.editorWidgets

    trace = False

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return # (for Tk) 'break'

    if trace:
        g.trace('==1',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.h)

    self.deactivateActiveEditor(w)

    # The actual switch.
    c.frame.body.bodyCtrl = w
    w.leo_active = True

    self.switchToChapter(w)
    self.selectLabel(w)

    if not self.ensurePositionExists(w):
        g.trace('***** no position editor!')
        return # (for Tk) 'break'

    if trace:
        g.trace('==2',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.h)

    # g.trace('expanding ancestors of ',w.leo_p.h,g.callers())
    c.redraw(w.leo_p)
    c.recolor()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocus()
    return # (for Tk) 'break'
#@+node:ekr.20061017083312.1: *8* << restore the selection, insertion point and the scrollbar >> selectEditorHelper leoBody.selectEditorBody
spot = hasattr(w,'leo_insertSpot') and w.leo_insertSpot or 0
w.setInsertPoint(0)
    
if hasattr(w,'leo_selection') and w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass

# Don't restore the scrollbar here.
#@+node:ekr.20110605121601.18203: *7* selectEditorHelper (qtBody)
def selectEditorHelper (self,wrapper):

    trace = False and not g.unitTesting
    c = self.c ; cc = c.chapterController
    d = self.editorWidgets
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    w = wrapper.widget
    assert isinstance(w,QtGui.QTextEdit),w

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    # The actual switch.
    self.deactivateEditors(wrapper)
    self.recolorWidget (w.leo_p,wrapper) # switches colorizers.
    # g.trace('c.frame.body',c.frame.body)
    # g.trace('c.frame.body.bodyCtrl',c.frame.body.bodyCtrl)
    # g.trace('wrapper',wrapper)
    c.frame.body.bodyCtrl = wrapper
    c.frame.body.widget = wrapper # Major bug fix: 2011/04/06
    w.leo_active = True

    self.switchToChapter(wrapper)
    self.selectLabel(wrapper)

    if not self.ensurePositionExists(w):
        return g.trace('***** no position editor!')
    if not (hasattr(w,'leo_p') and w.leo_p):
        return g.trace('***** no w.leo_p',w)
        
    # if not (hasattr(w,'leo_chapter') and w.leo_chapter):
        # return g.trace('***** no w.leo_chapter',w)

    p = w.leo_p
    assert p,p

    if trace: g.trace('wrapper %s chapter %s old %s p %s' % (
        id(wrapper),w.leo_chapter,c.p.h,p.h))

    c.expandAllAncestors(p)
    c.selectPosition(p) # Calls assignPositionToEditor.
    c.redraw()
    c.recolor_now()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18204: *8* << restore the selection, insertion point and the scrollbar >> qtBody.selectEditorHelper
spot = hasattr(w,'leo_insertSpot') and w.leo_insertSpot or 0
wrapper.setInsertPoint(spot)

if hasattr(w,'leo_selection') and w.leo_selection:
    try:
        start,end = w.leo_selection
        wrapper.setSelectionRange(start,end)
    except Exception:
        pass

# Don't restore the scrollbar here.
#@+node:ekr.20070423101911: *7* selectHelper (leoTree)
# Do **not** try to "optimize" this by returning if p==c.p.
# 2011/11/06: *event handlers* are called only if p != c.p.

def selectHelper (self,p,scroll):

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.p
    
    call_event_handlers = p != old_p

    if p:
        # 2009/10/10: selecting a foreign position
        # will not be pretty.
        assert p.v.context == c
    else:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace and (verbose or call_event_handlers):
        g.trace(p and p.h)
        # if old_p:
            # g.trace('old: %s %s new: %s %s' % (
                # len(old_p.b),old_p.h,len(p.b),p.h))
        # else:
            # g.trace('old: <none> new: %s %s' % (len(p.b),p.h))
            
            
    if 1: # 2011/11/06
        if call_event_handlers:
            unselect = not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        else:
            unselect = True
        if unselect:
            << unselect the old node >>
        
    else: # Old code
        if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
            if old_p:
                << unselect the old node >>
    
    if call_event_handlers: # 2011/11/06
        g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        
    if call_event_handlers: # 2011/11/06
        if call_event_handlers:
            select = not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        else:
            select = True
        if select:
            << select the new node >>
            c.nodeHistory.update(p) # Remember this position.
    else: # old code
        if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
            << select the new node >>
            c.nodeHistory.update(p) # Remember this position.
        
    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    # if trace and (verbose or call_event_handlers):
        # g.trace('**** after old: %s new %s' % (
            # old_p and len(old_p.b),len(p.b)))

    # what UNL.py used to do
    c.frame.clearStatusLine()
    c.frame.putStatusLine(p.get_UNL())

    if call_event_handlers: # 2011/11/06
        g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return # (for Tk) 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129: *8* << unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
    
    # g.trace('set insert spot',insertSpot)
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p and old_p != p:
    # 2010/02/11: Don't change the *new* node's insert point!
    old_p.v.scrollBarSpot = yview
    old_p.v.insertSpot = insertSpot
    if g.trace_scroll: g.trace('old scroll: %s insert: %s' % (
        yview,insertSpot))
#@+node:ekr.20040803072955.130: *8* << select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.h
frame.setWrap(p)
self.setBodyTextAfterSelect(p,old_p)
#@+node:ekr.20040803072955.133: *8* << set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

# Was in ctor.
use_chapters = c.config.getBool('use_chapters')

if use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.h)

c.treeFocusHelper() # 2010/12/14
c.undoer.onSelect(old_p,p)
#@+node:ekr.20031218072017.3344: *7* v.__init
# To support ZODB, the code must set v._p_changed = 1 whenever
# v.unknownAttributes or any mutable vnode object changes.

def __init__ (self,context):

    # The primary data: headline and body text.
    self._headString = g.u('newHeadline')
    self._bodyString = g.u('')

    # Structure data...
    self.children = [] # Ordered list of all children of this node.
    self.parents = [] # Unordered list of all parents of this node.

    # Other essential data...
    self.fileIndex = g.app.nodeIndices.getNewIndex()
        # The immutable file index for this vnode.
        # New in Leo 4.6 b2: allocate gnx (fileIndex) immediately.
    self.iconVal = 0 # The present value of the node's icon.
    self.statusBits = 0 # status bits

    # v.t no longer exists.  All code must now be aware of the one-node world.
    # self.t = self # For compatibility with scripts and plugins.

    # Information that is never written to any file...
    self.context = context # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.insertSpot = None # Location of previous insert point.
    self.scrollBarSpot = None # Previous value of scrollbar position.
    self.selectionLength = 0 # The length of the selected body text.
    self.selectionStart = 0 # The start of the selected body text.
#@+node:ekr.20100303074003.5636: *7* v.restoreCursorAndScroll
# Called only by setBodyTextAfterSelect.

def restoreCursorAndScroll (self,w):

    trace = g.trace_scroll and not g.unitTesting
    v = self
    spot = v and v.insertSpot or 0
    w.setInsertPoint(spot)
        
    # 2011/10/26: *only* restore the scrollbar setting.  Do not call see.
    if v and v.scrollBarSpot != None:
        pos = v.scrollBarSpot
        if trace: print('v.restoreCursorAndScroll %s' % pos)
        w.setYScrollPosition(pos)
        
    # Never call w.see here.

#@+node:ekr.20100303074003.5638: *7* v.saveCursorAndScroll(w)
def saveCursorAndScroll(self,w):

    v = self
    if not w: return
    
    try:
        v.scrollBarSpot = w.getYScrollPosition()
        v.insertSpot = w.getInsertPoint()
    except AttributeError:
        # 2011/03/21: w may not support the high-level interface.
        pass
#@+node:ekr.20111026231721.16619: *5* Third attempt, apparently successful
#@+node:ekr.20111026231721.16620: *6* Changed
#@+node:ekr.20100303074003.5636: *7* v.restoreCursorAndScroll
# Called only by setBodyTextAfterSelect.

def restoreCursorAndScroll (self,w):

    trace = g.trace_scroll and not g.unitTesting
    v = self
    spot = v and v.insertSpot or 0
    w.setInsertPoint(spot)
        
    # 2011/10/26: *only* restore the scrollbar setting.  Do not call see.
    if v and v.scrollBarSpot != None:
        pos = v.scrollBarSpot
        if trace: print('v.restoreCursorAndScroll %s' % pos)
        w.setYScrollPosition(pos)
        
    # Never call w.see here.

#@+node:ekr.20110605121601.18084: *7* getYScrollPosition (leoQTextEditWidget)
def getYScrollPosition(self):
    
    # **Important**: There is a Qt bug here: the scrollbar position
    # is valid only if cursor is visible.  Otherwise the *reported*
    # scrollbar position will be such that the cursor *is* visible.

    w = self.widget
    sb = w.verticalScrollBar()
    i = sb.sliderPosition()
    if g.trace_scroll: g.trace('(LeoQTextEditWidget)',i)
    return i
#@+node:ekr.20110605121601.18098: *7* setYScrollPosition (leoQTextEditWidget)
def setYScrollPosition(self,pos):
    
    trace = g.trace_scroll and not g.unitTesting   
    if trace: print(
        'leoQTextEditWidget.setYScrollPosition %s' % (pos))

    if 1: # disabled 2011/12/21, enabled 2012/02/25
        w = self.widget
        sb = w.verticalScrollBar()
        sb.setSliderPosition(pos)
#@+node:ekr.20061017083312.1: *7* << restore the selection, insertion point and the scrollbar >> selectEditorHelper leoBody.selectEditorBody
spot = hasattr(w,'leo_insertSpot') and w.leo_insertSpot or 0
w.setInsertPoint(0)
    
if hasattr(w,'leo_selection') and w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass

# Don't restore the scrollbar here.
#@+node:ekr.20110605121601.18204: *7* << restore the selection, insertion point and the scrollbar >> qtBody.selectEditorHelper
spot = hasattr(w,'leo_insertSpot') and w.leo_insertSpot or 0
wrapper.setInsertPoint(spot)

if hasattr(w,'leo_selection') and w.leo_selection:
    try:
        start,end = w.leo_selection
        wrapper.setSelectionRange(start,end)
    except Exception:
        pass

# Don't restore the scrollbar here.
#@+node:ekr.20070424080640: *7* deactivateActiveEditor (leoBody)
def deactivateActiveEditor(self,w):

    '''Inactivate the previously active editor.'''

    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.getYScrollPosition()
            w2.leo_insertSpot = w2.getInsertPoint()
            w2.leo_selection = w2.getSelectionRange()
            return
#@+node:ekr.20111028111441.16588: *4* Fixed html colorizing by fixing a bad bug in g.importFromPath
@nocolor-node
    
g.importFromPath ('html','C:/leo.repo/trunk/leo/modes/html.py')
returned the standard Python html module!

#@+node:ekr.20111029055127.16635: *4* Allow lower case keywords in colorizer
# The fix was to use lowercase versions of docPart,leoKeyword,nameBrackets.
#@+node:ekr.20111102072143.10017: *4* Fixed recent problem in createMenuEntries
#@+node:ekr.20111103102153.9716: *4* Fixed rst3 pdf problem
@nocolor-node

Worked around docutils problem in writeToDocutils.
#@+node:ekr.20111104104831.9823: *4* Added unit test that all plugins have an init method
@nocolor-node

- The tests should not register the plugin.

- There should be a test that top-level code does not register the plugin.

Top-level calls to registerHandler:
    
    Fixed:
        examples/__overrideClasses.py
        examples/override_commands.py
        examples/redefine_put.py  (Tk)
        examples/chinese_menu.py
        examples/french_fm.py
    
        at_view.py
        test/failed_import.py
        scripts_menu.py
#@+node:ekr.20111105054152.9949: *4* Removed traceback when cancelling a write
not written: c:\recent\data3.html
exception removing: 
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 5280, in remove
    os.remove(fileName)
WindowsError: [Error 3] The system cannot find the path specified: ''
#@+node:ekr.20111105055134.9769: *4* Fixed removeBlankLinesTokens
@nocolor-node

There were two bugs:
    
- baseScannerClass.skipWsToken must not skip newlines!
- tokenize must add any remaining whitespace at the end of the loop.
#@+node:ekr.20111105110308.9717: *4* Fixed crasher in config.set
# The code didn't work for c == None.
#@+node:ekr.20111107055809.9704: *4* Fixed resize-to-screen and minimize-all
#@+node:ekr.20111029055127.16609: *4* Fixed html import problems
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/3c319daba37cd0ef

- Created a separate html importer, a very simple subclass of the xml scanner
  whose only difference is that it uses @data import_html_tags instead of @data
  import_xml_tags.

- The case of tags in @data import_html_tags and @data import_xml_tags no longer matters.

- checkTrialWrite now writes a file *with* sentinels, to handle @others correctly.
  It then removes the sentinels.
  
  This means that the import tests must use the correct @language directives.
  
- The import check now uses a token-based comparison.  
#@+node:ekr.20111109151106.9906: *4* Removed extra newlines in g.trace
@nocolor-node

The fix was in g.pr:
    
Restored the call to sys.stdout.write(s2) (instead of print)

sys.stdout.write(s2) writes no additional newline at the end of s2.

Aha!  At last I know how to unit test g.pr, g.trace, etc.: redirect stdout!  Doh!
#@+node:ekr.20111110091847.10070: *4* Fixed crash in compareTokens
@nocolor-node


 File "/usr/fetching/leo-editor/leo/core/leoImport.py", line 2074, in
scanAndCompare
   n1,n2,ok = self.compareTokens(tokens1,tokens2)
 File "/usr/fetching/leo-editor/leo/core/leoImport.py", line 2094, in
compareTokens
   else:      kind1,val1 = 'eof','',n1
ValueError: too many values to unpack
#@+node:ekr.20111109151106.9745: *4* Finished import work
@nocolor-node


- Created stand-alone unit tests from @test import dataN.html.
- All leoImport unit tests may now be run externally.
    The Python unit tests were failing because of intermixed tabs and blanks.
    This was fixed by putting @tabwidth -4 in all @test nodes for Python.
- Made sure lines are printed when unit tests fail unexpectedly.
- Added .js & javascript entries to global data structures for javascript unit tests.
- Completed xmlScanner.filterTokens.
- Don't create declaration nodes for html.
- Make sure html tags are as expected.
- Ignore case of html/xml tags.
#@+node:ekr.20111112064924.9777: *5* What I did
@language rest

Rev 4774.1.1:
=============

Fixed all known html-import problems in a clean way. Unit tests exists, but they
use external files. They will be converted soon.

Important changes:

1. Added hasNestedClasses ivar in the baseScannerClass, True only for xml/html scanners.

When True, scanHelper and skipDecls allocate a substring to be used for all further scanning.
This is the *only* way to limit Leo's scanners properly.

This was, in essence, the fix for duplicate code generation arising from unbalanced tags:
skipToEndOfTag and skipToMatchingTag can't match outside the present tag because
the 's' argument passed to those methods has already been truncated.

This is a simple, elegant solution, and in essence the *only* proper solution.
For example, it would not work to past an 'end' argument to skipToEndOfTag and skipToMatchingTag
because the scanners inside those methods do not understand an 'end' argument.

Thus, the simplest, most efficient solution is for scanHelper and skipDecls to truncate the
string to be scanned. That way, the truncation happens at most once per "class".

2. Added hasDecls in the baseScannerClass, False only for xml/html scanners.

Various methods call skipDecls only if this ivar is True.

Rev 4773:
=========

Fixed recent botch: both single and double quotes are allowed in html. 

Rev 4772:
=========

Solved "between element" problem by extending classes up to the next class.
data.html imports "correctly", but not perfectly due to tag mismatches in
skipToMatchingTag.
#@+node:ekr.20111112193858.9831: *4* Fixed hard crash when deleting body editor 3 times
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/421ebf4c3f2d5f59

Adding/deleting body editor 3 times hard-crashed Python

The changes were straightforward:
    
- set w.leo_label to None when calling unpackWidget.

- Test for w.leo_label before using it.

Added a minitest.  To test by hand, add the following @button nodes:
    
    @button add-ed
    w = c.frame.body.addEditor()
    
    @button del-ed
    w = c.frame.body.deleteEditor()
    
Click away in any order...

#@+node:ekr.20111111065410.12913: *4* Fixed add/delete html comments
@nocolor-node

The new add-comments command adds the comment character at the leftmost column.

The new delete-comments command will remove the comment characters inserted by
either the old or new version of the add-comments command.
#@+node:ekr.20111118090912.12874: *4* Fixed bug that prevented text bindings from working in log tabs
@nocolor-node

Example: ctrl-shift-home.

The fix was to set self.widget = contents in leoQtLog.selectTab.
#@+node:ekr.20111118190243.10170: *4* Fixed cycle-all-focus command
@nocolor-node
    
- Added disabled code to inject event filter in TabbedFrameFactory.createFrame.

- Added cycle-tab-focus command.

- cycle-all-focus command uses cycleTabFocus as a helper: this greatly simplifies the code.
    
- Added binding for "Find" tab in leoQtLog.createTab.

- DynamicWindow.createFindTab injects leo_find_widget ivar for leoQtLog.createTab.

- Added isLogWidget to leoQtLog and nullLog classes.  They are helpers for cycleAllFocus.

- Revised leoQtLog.selectHelper: selecting a new tab does *not* change logCtrl (log.widget).

- Added bindings to Find tab
#@+node:ekr.20111121084517.10188: *4* Fixed crashers involving calls to w.setSelectionRange
#@+node:ekr.20111121222953.10973: *4* Fixed hang in cycleAllFocus
@nocolor-node

The safe default pane is the body pane.  It's also the simplest code.
#@+node:ekr.20111121222953.10974: *4* Fixed crasher in k.handleDefaultChar
@nocolor-node

The code must be careful that the log widget supports the HighLevelInterface.
#@+node:ekr.20111121210400.11142: *4* Fixed bug: Focus lost after opening or closing tab
#@+node:ekr.20111122094453.10201: *4* Ignore unbound Alt/Ctrl keys, especially Alt/Ctrl-N
@nocolor-node

The bug was in k.handleDefaultChar.  No substantial change made to eventFilter.
#@+node:ekr.20111124082644.10919: *4* Fixed bug: ensure global @buttons work
@nocolor-node

What I did:
    
1. Fixed major bug in settingsTreeParser.visitNode.
   It now does p.copy() to protect the callers traverals.
   This could have significant impacts on people's settings.
   
2. Added g.app.unitTestDict for unit testing.

3. Leo now extends the list of @buttons and @commands, rather than replacing them.
   This is reasonable only because leoSettings.leo should never define *active*
   buttons or commands.
#@+node:ekr.20111204102027.10279: *4* Fixed bug in p.moveToFirstChild
#@+node:ekr.20111125072438.10203: *4* Fixed bug 804960: Refreshing unlinks clones, just reopening connects them again
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/804960

When we clone a node inside an @shadow (containing @others) node and then
refresh the @shadow node from file, the clone is unlinked and marked as changed.
If we now save, close the .leo file and open it again, the nodes are linked
again! (showing "cloned" symbol) User's thought: "How the heck can the file
change _between save and re-open_ when I changed nothing?"

I think what should be done about this is the check that Leo does when it opens
the file again, and that check should be done immediately after the "refresh
node from file" operation. Also, at this point, the "Recovered nodes" node
should appear (if file and node have both changed), not only after the next .leo
file close/reopen (as that happens quite infrequently, I guess, e.g. once a day
for me). Otherwise, the user can easily lose data.
#@+node:ekr.20111210131839.10311: *5* changed...
#@+node:ekr.20090218115025.5: *6* fc.initIvars
def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding

    # The bin param doesn't exist in Python 2.3;
    # the protocol param doesn't exist in earlier versions of Python.
    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    # self.python23 = g.CheckVersion(version,'2.3')

    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentTnodeUaDictList = []
    self.descendentVnodeUaDictList = []
    self.ratio = 0.5

    self.currentVnode = None
    self.rootVnode = None

    # For writing
    self.read_only = False
    self.rootPosition = None
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    # self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.gnxDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are vnodes.
        # 2011/12/10: This dict is never re-inited.
    # g.trace('***clearing gnxDict',c)
        
    self.vnodesDict = {}
        # keys are gnx strings; values are ignored
#@+node:ekr.20031218072017.1559: *6* fc.getLeoOutlineFromClipboard & helpers
def getLeoOutlineFromClipboard (self,s,reassignIndices=True):

    '''Read a Leo outline from string s in clipboard format.'''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; current = c.p ; check = not reassignIndices
    checkAfterRead = False or c.config.getBool('check_outline_after_read')

    self.initReadIvars() # 2010/02/05

    # Save the hidden root's children.
    children = c.hiddenRootNode.children

    # 2011/12/10: never recreate the gnxDict.
        # Always recreate the gnxDict
        # self.gnxDict = {}
    # g.trace('*** clearing gnxDict',g.callers())
    
    # 2011/12/12: save and clear gnxDict.
    # This ensures that new indices will be used for all nodes.
    if reassignIndices:
        oldGnxDict = self.gnxDict
        self.gnxDict = {}
    else:
        # Make sure all pasted nodes are entered into the gnxDict.
        x = g.app.nodeIndices
        for v in c.all_unique_nodes():
            index = x.toString(v.fileIndex)
            self.gnxDict[index] = v

    self.usingClipboard = True
    try:
        # This encoding must match the encoding used in putLeoOutline.
        s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)
        if trace: g.trace(s)

        # readSaxFile modifies the hidden root.
        v = self.readSaxFile(
            theFile=None, fileName='<clipboard>',
            silent=True, # don't tell about stylesheet elements.
            inClipboard=True,reassignIndices=reassignIndices,s=s)
        if not v:
            return g.es("the clipboard is not valid ",color="blue")
    finally:
        self.usingClipboard = False

    # Restore the hidden root's children
    c.hiddenRootNode.children = children

    # Unlink v from the hidden root.
    v.parents.remove(c.hiddenRootNode)

    p = leoNodes.position(v)

    # Important: we must not adjust links when linking v
    # into the outline.  The read code has already done that.
    if current.hasChildren() and current.isExpanded():
        if check and not self.checkPaste(current,p):
            return None
        p._linkAsNthChild(current,0,adjust=False)
    else:
        if check and not self.checkPaste(current.parent(),p):
            return None
        p._linkAfter(current,adjust=False)

    if reassignIndices:
        self.gnxDict = oldGnxDict
            # 2011/12/12: restore gnxDict.
        for p2 in p.self_and_subtree():
            v = p2.v
            v.fileIndex = index = g.app.nodeIndices.getNewIndex()
            self.gnxDict[index] = v

    if trace and verbose:
        g.trace('**** dumping outline...')
        c.dumpOutline()

    if checkAfterRead:
        g.trace('checking outline after paste',color='blue')
        c.checkOutline(event=None,verbose=True,unittest=False,full=True)

    c.selectPosition(p)
    self.initReadIvars() # 2010/02/05
    return p

getLeoOutline = getLeoOutlineFromClipboard # for compatibility
#@+node:ekr.20080410115129.1: *7* checkPaste
def checkPaste (self,parent,p):

    '''Return True if p may be pasted as a child of parent.'''

    if not parent: return True

    parents = [z.copy() for z in parent.self_and_parents()]

    for p in p.self_and_subtree():
        for z in parents:
            # g.trace(p.h,id(p.v),id(z.v))
            if p.v == z.v:
                g.es('Invalid paste: nodes may not descend from themselves',color="blue")
                return False

    return True
#@+node:ekr.20060919142200.1: *6* fc.initReadIvars
def initReadIvars (self):

    self.descendentTnodeUaDictList = []
    self.descendentVnodeUaDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
        # 2011/12/10: never re-init this dict.
        # self.gnxDict = {}
        # g.trace('*** clearing gnxDict',g.callers())
    self.c.nodeConflictList = [] # 2010/01/05
    self.c.nodeConflictFileName = None # 2010/01/05
#@+node:ekr.20111213092149.10324: *4* Fixed crasher in reportMismatch
@nocolor-node

>  File "/path/to/leo/core/leoImport.py", line 2070, in reportMismatch
>    line = repr(lines2[i])
> IndexError: list index out of range
#@+node:ekr.20111214093735.10286: *4* Disabled section-reference handling in @auto files
#@+node:ekr.20111109122014.9792: *4* Fix bug: Allow @all only in top-level @<file> nodes (test2.leo)
@nocolor-node

The fix was to at.putBody.
#@+node:ekr.20111121084517.10189: *4* Removed all calls to w.see, w.seeInsertPoint, w.setYScrollPosition
# See "Scrolling bug" notes.
#@+node:ekr.20110605121601.18090: *5* see & seeInsertPoint (leoQTextEditWidget)
def see(self,i):
    
    if g.trace_see and not g.unitTesting:
        print('leoQTextEditWidget.see (ensureCursorVisible)')

    if 1: # Disabled 2011/12/21, enabled 2012/02/26
        self.widget.ensureCursorVisible()

def seeInsertPoint (self):
    
    if g.trace_see and not g.unitTesting:
        print('leoQTextEditWidget.seeInsertPoint')

    if 1: # Disabled 2011/12/21, enabled 2012/02/26
        self.widget.ensureCursorVisible()
#@+node:ekr.20111002125540.7021: *5* get/setYScrollPosition (LeoQTextBrowser)
def getYScrollPosition(self):
    
    trace = g.trace_scroll and not g.unitTesting
    w = self
    sb = w.verticalScrollBar()
    i = sb.sliderPosition()
    
    if trace:
        print('leoQTextBrowser.getYScrollPosition %s' % i)
    return i

def setYScrollPosition(self,pos):
    
    trace = g.trace_scroll and not g.unitTesting
    print('leoQTextBrowser.setYScrollPosition %s' % pos)

    if 1: # disabled 2011/12/21, restored 2012/02/25
        w = self
        sb = w.verticalScrollBar()
        if pos is None: pos = 0
        sb.setSliderPosition(pos)
#@+node:ekr.20110605121601.18098: *5* setYScrollPosition (leoQTextEditWidget)
def setYScrollPosition(self,pos):
    
    trace = g.trace_scroll and not g.unitTesting   
    if trace: print(
        'leoQTextEditWidget.setYScrollPosition %s' % (pos))

    if 1: # disabled 2011/12/21, enabled 2012/02/25
        w = self.widget
        sb = w.verticalScrollBar()
        sb.setSliderPosition(pos)
#@+node:ekr.20120109111947.9962: *4* Fixed erroneous "file changed" message
@nocolor-node

has been modified outside of Leo. Overwrite this file?
http://groups.google.com/group/leo-editor/browse_thread/thread/daf581ace0de871e

Steps to reproduce:

- Create a node "@edit ~/aaa.txt" assuming aaa.txt does not exist
- Ctrl-S save outline, log reports creating ~/aaa.txt
- Edit text in body
- Ctrl-S save outline, pop-up pops-up erroneously.

The problem was that replaceTargetFileIfDifferent should set root.v.at_read.
Now it does.

Note: both replaceFileWithString methods are part of the @shadow logic,
so there is no need to set any at_read bit in those methods.
#@+node:ekr.20120110174009.9963: *4* Fixed bug 889175: Changing @auto paths overwrites files without warning
@nocolor-node

I loaded an outline with @auto nodes pointing to an out of date path. So body
texts were empty. I updated the paths in the node headlines and saved the file,
expecting to be prompted for overwriting the existing files (now the paths were
correct again), but they were over-written with the blank content without
warning. Damn.

Steps to reproduce in a simpler way below, but don't write the
below of as contrived, because the above is the real problem.

Create @auto /home/tbrown/text.txt

enter text, save file

Edit headline to @auto /home/tbrown/Desktop/text.txt

enter text, save file

Edit headline back to /home/tbrown/text.txt

-----

I now see this happens also if the path change is in a @path node ancestor of the @auto node.
#@+node:ekr.20120110174009.9965: *5* at.shouldPromptForDangerousWrite
def shouldPromptForDangerousWrite(self,fn,p):
    
    '''Return True if a prompt should be issued
    when writing p (an @<file> node) to fn.
    '''
    
    if not g.os_path_exists(fn):
        return False
            # No danger of overwriting fn.
    elif hasattr(p.v,'at_read'):
        return fn not in p.v.at_read
            # The path is new.
    else:
        return True
            # The file was never read.
#@+node:ekr.20120112084820.10001: *5* at.rememberReadPath
def rememberReadPath(self,fn,p):
    
    v = p.v
    
    if not hasattr(v,'at_read'):
        v.at_read = []
        
    if not fn in v.at_read:
        v.at_read.append(fn)
#@+node:ekr.20120110174009.9964: *5* Found: at_read
#@+node:ekr.20090225080846.5: *6* at.writeOneAtEditNode
def writeOneAtEditNode(self,p,toString,force=False):

    '''Write one @edit node.'''

    at = self ; c = at.c
    root = p.copy()
    c.endEditing()
    c.init_error_dialogs()

    fn = p.atEditNodeName()
    if not fn and not toString: return False

    if p.hasChildren():
        g.es('@edit nodes must not have children',color='red')
        g.es('To save your work, convert @edit to @auto or @thin')
        return False

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fn = c.os_path_finalize_join(at.default_directory,fn)
    if not force and at.shouldPromptForDangerousWrite(fn,root):
        # Prompt if writing a new @edit node would overwrite the existing file.
        ok = self.promptForDangerousWrite(fn,kind='@edit')
        if ok:
            # Fix bug 889175: Remember the full fileName.
            at.rememberReadPath(fn,root)
        else:
            g.es("not written:",fn)
            return False

    at.targetFileName = fn
    at.initWriteIvars(root,at.targetFileName,
        atAuto=True, atEdit=True,
        nosentinels=True,thinFile=False,
        scriptWrite=False,toString=toString)

    # Compute the file's contents.
    # Unlike the @nosent file logic it does not add a final newline.
    contents = ''.join([s for s in g.splitLines(p.b)
        if at.directiveKind4(s,0) == at.noDirective])

    if toString:
        at.stringOutput = contents
        return True

    ok = at.openFileForWriting(root,fileName=fn,toString=False)
    if ok:
        self.os(contents)
        at.closeWriteFile()
    if ok and at.errors == 0:
        at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
    else:
        g.es("not written:",at.targetFileName) # 2010/10/22
        root.setDirty()
        root.setOrphan() # 2010/10/22
        
    c.raise_error_dialogs(kind='write')

    return ok
#@+node:ekr.20031218072017.3210: *6* ic.createOutline
def createOutline (self,fileName,parent,
    atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    w = c.frame.body
    at = c.atFileCommands

    self.default_directory = g.setDefaultDirectory(c,parent,importing=False)
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    fileName = fileName.replace('\\','/') # 2011/11/25
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        if atShadow: kind = '@shadow '
        elif atAuto: kind = '@auto '
        else: kind = ''
        s,e = g.readFileIntoString(fileName,encoding=self.encoding,kind=kind)
        if s is None: return None
        if e: self.encoding = e

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        elif self.treeType is None:
            # 2010/09/29: by convention, we use the short file name.
            p.initHeadString(g.shortFileName(fileName))
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    if self.treeType == '@root': # 2010/09/29.
        self.rootLine = "@root-code "+self.fileName+'\n'
    else:
        self.rootLine = ''

    if p.isAtAutoRstNode(): # @auto-rst is independent of file extension.
        func = self.scanRstText
    else:
        func = self.importDispatchDict.get(ext)

    if func and not c.config.getBool('suppress_import_parsing',default=False):
        s = s.replace('\r','')
        func(s,p,atAuto=atAuto)
    else:
        # Just copy the file to the parent node.
        s = s.replace('\r','')
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    if atAuto:
        # Fix bug 488894: unsettling dialog when saving Leo file
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName,p)

    p.contract()
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
#@+node:ekr.20041005105605.21: *6* at.read & helpers
def read(self,root,importFileName=None,
    fromString=None,atShadow=False,force=False
):

    """Read an @thin or @file tree."""

    trace = False and not g.unitTesting
    if trace: g.trace(root.h)
    at = self ; c = at.c
    fileName = at.initFileName(fromString,importFileName,root)
    if not fileName:
        at.error("Missing file name.  Restoring @file tree from .leo file.")
        return False
    # Fix bug 760531: always mark the root as read, even if there was an error.
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(at.fullPath(root),root)

    # Bug fix 2011/05/23: Restore orphan trees from the outline.
    if root.isOrphan():
        g.es("reading:",root.h)
        # g.warning('The outline contains an orphan node!\nRetaining the outline')
        g.es_print('orphan node in',root.h,color='red')
        g.es_print('retaining the data from the .leo file',color='blue')
        return False
    at.initReadIvars(root,fileName,
        importFileName=importFileName,atShadow=atShadow)
    at.fromString = fromString
    if at.errors:
        if trace: g.trace('Init error')
        return False

    fileName = at.openFileForReading(fromString=fromString)
        # For @shadow files, calls x.updatePublicAndPrivateFiles.
    if fileName and at.inputFile:
        c.setFileTimeStamp(fileName)
    elif fromString: # 2010/09/02.
        pass
    else:
        if trace: g.trace('No inputFile')
        return False

    # Get the file from the cache if possible.
    if fromString:
        s,loaded,fileKey = fromString,False,None
    else:
        s,loaded,fileKey = c.cacher.readFile(fileName,root)
    # Never read an external file with file-like sentinels from the cache.
    isFileLike = loaded and at.isFileLike(s)
    if not loaded or isFileLike:
        # if trace: g.trace('file-like file',fileName)
        force = True # Disable caching.
    if loaded and not force:
        if trace: g.trace('in cache',fileName)
        at.inputFile.close()
        root.clearDirty()
        return True
    if not g.unitTesting:
        g.es("reading:",root.h)
    if isFileLike:
        if g.unitTesting:
            if 0: print("converting @file format in",root.h)
            g.app.unitTestDict['read-convert']=True
        else:
            g.es("converting @file format in",root.h,color='red')
    root.clearVisitedInTree()

    at.scanAllDirectives(root,importing=at.importing,reading=True)
        # Sets the following ivars:
            # at.default_directory
            # at.encoding: **Important**: changed later
            #     by readOpenFile/at.scanHeader.
            # at.explicitLineEnding
            # at.language
            # at.output_newline
            # at.page_width
            # at.tab_width

    if trace: g.trace(repr(at.encoding),fileName)
    thinFile = at.readOpenFile(root,at.inputFile,fileName,deleteNodes=True)
        # Calls at.scanHeader, which sets at.encoding.
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        at.deleteUnvisitedNodes(root)
        at.deleteTnodeList(root)
    if at.errors == 0 and not at.importing:
        # Used by mod_labels plugin.
        at.copyAllTempBodyStringsToVnodes(root,thinFile)
    at.deleteAllTempBodyStrings()
    if isFileLike and at.errors == 0: # Old-style sentinels.
        # 2010/02/24: Make the root @file node dirty so it will
        # be written automatically when saving the file.
        # Do *not* set the orphan bit here!
        root.clearOrphan()
        root.setDirty()
        c.setChanged(True) # Essential, to keep dirty bit set.
    elif at.errors > 0:
        # 2010/10/22: Dirty bits are *always* cleared.
        # Only the orphan bit is preserved.
        # root.setDirty() # 2011/06/17: Won't be preserved anyway
        root.setOrphan()
        # c.setChanged(True) # 2011/06/17.
    else:
        root.clearOrphan()
    if at.errors == 0 and not isFileLike and not fromString:
        c.cacher.writeFile(root,fileKey)

    if trace: g.trace('at.errors',at.errors)
    return at.errors == 0
#@+node:ekr.20041005105605.25: *7* at.deleteAllTempBodyStrings
def deleteAllTempBodyStrings(self):

    for v in self.c.all_unique_nodes():
        if hasattr(v,"tempBodyString"):
            delattr(v,"tempBodyString")
        if hasattr(v,"tempBodyList"):
            delattr(v,"tempBodyList")
#@+node:ekr.20100122130101.6174: *7* at.deleteTnodeList
def deleteTnodeList (self,p): # atFile method.

    '''Remove p's tnodeList.'''

    v = p.v

    if hasattr(v,"tnodeList"):

        if False: # Not an error, but a useful trace.
            s = "deleting tnodeList for " + repr(v)
            g.es_print(s,color="blue")

        delattr(v,"tnodeList")
        v._p_changed = True
#@+node:ekr.20071105164407: *7* at.deleteUnvisitedNodes & helpers
def deleteUnvisitedNodes (self,root):

    '''Delete unvisited nodes in root's subtree, not including root.

    Actually, instead of deleting the nodes, we move them to be children of the
    'Resurrected Nodes' r.
    '''

    at = self

    if not root.hasChildren():
        return

    # Carefully set up the arguments.
    aList = [z.copy() for z in root.subtree() if not z.isVisited()]
    if not aList: return

    r = at.createResurrectedNodesNode()
    assert r not in aList
    callback=at.defineResurrectedNodeCallback(r,root)

    # Now move the nodes.
    root.firstChild().deletePositionsInList(aList,callback)
#@+node:ekr.20100803073751.5817: *8* createResurrectedNodesNode
def createResurrectedNodesNode(self):

    '''Create a 'Resurrected Nodes' node as the last top-level node.'''

    at = self ; c = at.c ; tag = 'Resurrected Nodes'

    # Find the last top-level node.
    last = c.rootPosition()
    while last.hasNext():
        last.moveToNext()

    if last.h == tag:
        # The 'Resurrected Nodes' node already exists.
        p = last
    else:
        # Create the 'Resurrected Nodes' node after 'last'.
        p = last.insertAfter()
        p.setHeadString(tag)

    p.expand()
    return p
#@+node:ekr.20100803073751.5818: *8* defineResurrectedNodeCallback
def defineResurrectedNodeCallback (self,r,root):

    '''Define a callback that moves node p as r's last child.'''

    def callback(p,r=r.copy(),root=root):

        '''The resurrected nodes callback.'''

        child = r.insertAsLastChild()
        child.h = 'From %s' % root.h
        p.moveToLastChildOf(child)

        if g.unitTesting:
            # g.trace(p.h,r.h)
            pass 
        else:
            g.es('resurrected node:',p.h,color='red')
            g.es('in file:',root.h,color='blue')

    return callback


#@+node:ekr.20041005105605.22: *7* at.initFileName
def initFileName (self,fromString,importFileName,root):

    if fromString:
        fileName = "<string-file>"
    elif importFileName:
        fileName = importFileName
    elif root.isAnyAtFileNode():
        fileName = root.anyAtFileNodeName()
    else:
        fileName = None

    return fileName
#@+node:ekr.20100224050618.11547: *7* at.isFileLike
def isFileLike (self,s):

    '''Return True if s has file-like sentinels.'''

    trace = False and not g.unitTesting
    at = self ; tag = "@+leo"
    s = g.toUnicode(s)
    i = s.find(tag)
    if i == -1:
        if trace: g.trace('found: False',repr(s))
        return True # Don't use the cashe.
    else:
        j,k = g.getLine(s,i)
        line = s[j:k]
        valid,new_df,start,end,isThin = \
            at.parseLeoSentinel(line)
        if trace: g.trace('found: True isThin:',
            isThin,repr(line))
        return not isThin
#@+node:ekr.20041005105605.26: *6* at.readAll
def readAll(self,root,partialFlag=False):

    """Scan vnodes, looking for @<file> nodes to read."""

    use_tracer = False
    if use_tracer: tt = g.startTracer()

    at = self ; c = at.c
    force = partialFlag
    if partialFlag:
        # Capture the current headline only if
        # we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()

    scanned_tnodes = set()
    c.init_error_dialogs()

    if partialFlag: after = p.nodeAfterTree()    
    else: after = c.nullPosition()

    while p and p != after:
        gnx = p.gnx
        #skip clones
        if gnx in scanned_tnodes:
            p.moveToNodeAfterTree()
            continue
        scanned_tnodes.add(gnx)

        if not p.h.startswith('@'):
            p.moveToThreadNext()
        elif p.isAtIgnoreNode():
            if p.isAnyAtFileNode() :
                c.ignored_at_file_nodes.append(p.h)
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            at.read(p,force=force)
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode():
            fileName = p.atAutoNodeName()
            at.readOneAtAutoNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtEditNode():
            fileName = p.atEditNodeName()
            at.readOneAtEditNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtShadowFileNode():
            fileName = p.atShadowFileNodeName()
            at.readOneAtShadowNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p,force=force)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                # However, the dirty bit gets cleared.
                # p.setDirty() # 2011/06/17: won't be preserved anyway.
                    # Expensive, but it can't be helped.
                p.setOrphan() # 2010/10/22: the dirty bit gets cleared.
                # c.setChanged(True) # 2011/06/17
            p.moveToNodeAfterTree()
        else:
            if p.isAtAsisFileNode() or p.isAtNoSentFileNode():
                at.rememberReadPath(at.fullPath(p),p)
            p.moveToThreadNext()

    # 2010/10/22: Preserve the orphan bits: the dirty bits will be cleared!
    #for v in c.all_unique_nodes():
    #    v.clearOrphan()

    if partialFlag and not anyRead and not g.unitTesting:
        g.es("no @<file> nodes in the selected tree")

    if use_tracer: tt.stop()
    
    c.raise_error_dialogs()  # 2011/12/17
#@+node:ekr.20070909100252: *6* at.readOneAtAutoNode
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    # 2010/7/28: Remember that we have seen the @auto node.
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fileName,p)

    s,ok,fileKey = c.cacher.readFile(fileName,p)
    if ok:
        g.doHook('after-auto',c=c,p=p)
            # call after-auto callbacks
            # 2011/09/30: added call to g.doHook here.
        return

    if not g.unitTesting:
        g.es("reading:",p.h)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        # Note: the file contains an @ignore,
        # so no unintended write can happen.
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        c.cacher.writeFile(p,fileKey)
        g.doHook('after-auto',c=c,p=p)
            # call after-auto callbacks
            # 2011/09/30: add 'c' keyword arg.
#@+node:ekr.20090225080846.3: *6* at.readOneAtEditNode
def readOneAtEditNode (self,fn,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fn = c.os_path_finalize_join(at.default_directory,fn)
    junk,ext = g.os_path_splitext(fn)

    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fn,p)

    if not g.unitTesting:
        g.es("reading @edit:", g.shortFileName(fn))

    s,e = g.readFileIntoString(fn,kind='@edit')
    if s is None: return
    encoding = g.choose(e is None,'utf-8',e)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    changed = c.isChanged()
    head = ''
    ext = ext.lower()
    if ext in ('.html','.htm'):   head = '@language html\n'
    elif ext in ('.txt','.text'): head = '@nocolor\n'
    else:
        language = ic.languageForExtension(ext)
        if language and language != 'unknown_language':
            head = '@language %s\n' % language
        else:
            head = '@nocolor\n'

    p.b = g.u(head) + g.toUnicode(s,encoding=encoding,reportErrors='True')

    if not changed: c.setChanged(False)
    g.doHook('after-edit',p=p)
#@+node:ekr.20080711093251.7: *6* at.readOneAtShadowNode
def readOneAtShadowNode (self,fn,p,force=False):

    trace = False and not g.unitTesting
    at = self ; c = at.c ; x = c.shadowController

    if not fn == p.atShadowFileNodeName():
        return at.error('can not happen: fn: %s != atShadowNodeName: %s' % (
            fn, p.atShadowFileNodeName()))

    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fn,p)

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fn = c.os_path_finalize_join(at.default_directory,fn)
    shadow_fn     = x.shadowPathName(fn)
    shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
        
    if trace:
        g.trace('shadow_exists',shadow_exists,shadow_fn)

    if shadow_exists:
        at.read(p,atShadow=True,force=force)
    else:
        if not g.unitTesting: g.es("reading:",p.h)
        ok = at.importAtShadowNode(fn,p)
        if ok:
            # Create the private file automatically.
            at.writeOneAtShadowNode(p,toString=False,force=True)
#@+node:ekr.20080712080505.1: *7* at.importAtShadowNode
def importAtShadowNode (self,fn,p):

    at = self ; c = at.c  ; ic = c.importCommands
    oldChanged = c.isChanged()

    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()

    # Import the outline, exactly as @auto does.
    ic.createOutline(fn,parent=p.copy(),atAuto=True,atShadow=True)

    if ic.errors:
        g.es_print('errors inhibited read @shadow',fn,color='red')

    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
        c.setChanged(oldChanged)

    # else: g.doHook('after-shadow', p = p)

    return ic.errors == 0
#@+node:ekr.20041005105605.27: *6* at.readOpenFile & helpers
def readOpenFile(self,root,theFile,fileName,deleteNodes=False):

    '''Read an open derived file.

    Leo 4.5 and later can only read 4.x derived files.'''

    trace = False and not g.unitTesting
    at = self

    firstLines,read_new,thinFile = at.scanHeader(theFile,fileName)
        # Important: this sets at.encoding, used by at.readLine.
    at.thinFile = thinFile
        # 2010/01/22: use *only* the header to set self.thinFile.

    if deleteNodes and at.shouldDeleteChildren(root,thinFile):
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName,root)
        while root.hasChildren():
            root.firstChild().doDelete()

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        firstLines = [] ; lastLines = []
        if at.atShadow:
            g.trace(g.callers())
            g.trace('invalid @shadow private file',fileName)
            at.error('invalid @shadow private file',fileName)
        else:
            at.error('can not read 3.x derived file',fileName)
            g.es('you may upgrade these file using Leo 4.0 through 4.4.x')
            g.trace('root',root and root.h,fileName)

    if root:
        root.v.setVisited() # Disable warning about set nodes.

    << handle first and last lines >>
    
    if trace: g.trace(at.encoding,fileName) # root.v.tempBodyString)

    return thinFile
#@+node:ekr.20041005105605.28: *7* << handle first and last lines >> (at.readOpenFile)
# The code below only deals with the root node!
# We terminate the root's body text if it exists.
# This is a hack to allow us to handle @first and @last.
v = root.v
tempString = hasattr(v,'tempBodyString') and v.tempBodyString or ''
tempList = hasattr(v,'tempBodyList') and ''.join(v.tempBodyList) or ''

if at.readVersion5:
    if hasattr(v,'tempBodyList'):
        body = tempList
        delattr(v,'tempBodyList') # So the change below "takes".
    elif hasattr(v,'tempBodyString'):
        body = tempString
        delattr(v,'tempBodyString')
    else:
        body = ''
else:
    body = tempString

lines = body.split('\n')

at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)

s = '\n'.join(lines).replace('\r', '')

# *Always* put the temp body text into at.v.tempBodyString.
v.tempBodyString = s
#@+node:ekr.20100122130101.6175: *7* at.shouldDeleteChildren
def shouldDeleteChildren (self,root,thinFile):

    '''Return True if we should delete all children before a read.'''

    # Delete all children except for old-style @file nodes

    if root.isAtNoSentFileNode():
        return False
    elif root.isAtFileNode() and not thinFile:
        return False
    else:
        return True
#@+node:ekr.20041005105605.117: *7* at.completeFirstDirective
# 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @first directives
# and appends the corresponding line from 'firstLines' to each @first 
# directive found.  NOTE: the @first directives must be the very first
# lines in 'out'.
def completeFirstDirectives(self,out,firstLines):

    tag = "@first"
    foundAtFirstYet = 0
    outRange = range(len(out))
    j = 0
    for k in outRange:
        # skip leading whitespace lines
        if (not foundAtFirstYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @first directive
        i = 0
        if not g.match(out[k],i,tag): break
        foundAtFirstYet = 1
        # quit if no leading lines to apply
        if j >= len(firstLines): break
        # make the new @first directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @first directive
        leadingLine = " " + firstLines[j]
        out[k] = tag + leadingLine.rstrip() ; j += 1
#@+node:ekr.20041005105605.118: *7* at.completeLastDirectives
# 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @last directives
# and appends the corresponding line from 'lastLines' to each @last 
# directive found.  NOTE: the @last directives must be the very last
# lines in 'out'.
def completeLastDirectives(self,out,lastLines):

    tag = "@last"
    foundAtLastYet = 0
    outRange = range(-1,-len(out),-1)
    j = -1
    for k in outRange:
        # skip trailing whitespace lines
        if (not foundAtLastYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @last directive
        i = 0
        if not g.match(out[k],i,tag): break
        foundAtLastYet = 1
        # quit if no trailing lines to apply
        if j < -len(lastLines): break
        # make the new @last directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @last directive
        trailingLine = " " + lastLines[j]
        out[k] = tag + trailingLine.rstrip() ; j -= 1
#@+node:ekr.20041005105605.154: *6* at.asisWrite
def asisWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    c.init_error_dialogs()
    try:
        # Note: @asis always writes all nodes,
        # so there can be no orphan or ignored nodes.
        targetFileName = root.atAsisFileNodeName()
        at.initWriteIvars(root,targetFileName,toString=toString)
        # "look ahead" computation of eventual fileName.
        eventualFileName = c.os_path_finalize_join(
            at.default_directory,at.targetFileName)
        if at.shouldPromptForDangerousWrite(eventualFileName,root):
            # Prompt if writing a new @asis node would overwrite the existing file.
            ok = self.promptForDangerousWrite(eventualFileName,kind='@asis')
            if ok:
                # Fix bug 889175: Remember the full fileName.
                at.rememberReadPath(eventualFileName,root)
            else:
                g.es("not written:",eventualFileName)
                return
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString):
            # openFileForWriting calls root.setDirty() if there are errors.
            return

        for p in root.self_and_subtree():
            << Write p's headline if it starts with @@ >>
            << Write p's body >>
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
        
    except Exception:
        at.writeException(root) # Sets dirty and orphan bits.

silentWrite = asisWrite # Compatibility with old scripts.
#@+node:ekr.20041005105605.155: *7* << Write p's headline if it starts with @@ >>
s = p.h

if g.match(s,0,"@@"):
    s = s[2:]
    if s and len(s) > 0:
        # at.outputFile is a fileLikeObject.
        s = g.toEncodedString(s,at.encoding,reportErrors=True)
        at.outputFile.write(s)
#@+node:ekr.20041005105605.156: *7* << Write p's body >>
s = p.b

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
#@+node:ekr.20041005105605.144: *6* at.write & helper
def write (self,root,
    kind = '@unknown', # Should not happen.
    nosentinels = False,
    thinFile = False,
    scriptWrite = False,
    toString = False,
):
    """Write a 4.x derived file.
    root is the position of an @<file> node"""

    trace = False and not g.unitTesting
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels = nosentinels, thinFile = thinFile,
        scriptWrite = scriptWrite, toString = toString,
    )

    # "look ahead" computation of eventual fileName.
    eventualFileName = c.os_path_finalize_join(
        at.default_directory,at.targetFileName)

    if trace:
        g.trace('default_dir',
            g.os_path_exists(at.default_directory),
            at.default_directory)
        g.trace('eventual_fn',eventualFileName)

    if not scriptWrite and not toString:
        if at.shouldPromptForDangerousWrite(eventualFileName,root):
            # Prompt if writing a new @file or @thin node would
            # overwrite an existing file.
            ok = self.promptForDangerousWrite(eventualFileName,kind)
            if ok:
                at.rememberReadPath(eventualFileName,root)
            else:
                g.es("not written:",eventualFileName)
                << set dirty and orphan bits >> # 2010/10/21.
                return

    if not at.openFileForWriting(root,at.targetFileName,toString):
        # openFileForWriting calls root.setDirty() if there are errors.
        if trace: g.trace('open failed',eventualFileName)
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        assert root==at.root,'write'
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            if hasattr(self.root.v,'tnodeList'):
                delattr(self.root.v,'tnodeList')
            root.v._p_changed = True
        else:
            at.closeWriteFile()
            if at.errors > 0 or root.isOrphan():
                << set dirty and orphan bits >>
                g.es("not written:",at.outputFileName)
            else:
                # Fix bug 889175: Remember the full fileName.
                at.rememberReadPath(eventualFileName,root)
                at.replaceTargetFileIfDifferent(root)
                    # Sets/clears dirty and orphan bits.

    except Exception:
        if hasattr(self.root.v,'tnodeList'):
            delattr(self.root.v,'tnodeList')
        if toString:
            at.exception("exception preprocessing script")
            root.v._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145: *7* << set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
    if not at.targetFileName:
        # We have an @file node.
        at.targetFileName = root.atFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@+node:ekr.20041005105605.146: *7* << set dirty and orphan bits >>
# Setting the orphan and dirty flags tells Leo to write the tree..
root.setOrphan()
root.setDirty()
# Delete the temp file.
if at.outputFileName:
    self.remove(at.outputFileName) 

#@+node:ekr.20070806141607: *6* at.writeOneAtAutoNode
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName and not toString: return False

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fileName = c.os_path_finalize_join(at.default_directory,fileName)
    if not toString and at.shouldPromptForDangerousWrite(fileName,root):
        # Prompt if writing a new @auto node would overwrite the existing file.
        ok = self.promptForDangerousWrite(fileName,kind='@auto')
        if not ok:
            g.es("not written:",fileName)
            return

    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fileName,root)
    
    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)

    at.initWriteIvars(root,at.targetFileName,
        atAuto=True,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    isAtAutoRst = root.isAtAutoRstNode()
    if ok:
        if isAtAutoRst:
            ok2 = c.rstCommands.writeAtAutoFile(root,fileName,self.outputFile)
            if not ok2: at.errors += 1
        else:
            at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        # g.trace('at.errors',at.errors)
        if at.errors == 0:
            # g.trace('toString',toString,'force',force,'isAtAutoRst',isAtAutoRst)
            at.replaceTargetFileIfDifferent(root,ignoreBlankLines=isAtAutoRst)
                # Sets/clears dirty and orphan bits.
        else:
            g.es("not written:",fileName)
            root.setDirty() # New in Leo 4.4.8.
            root.setOrphan() # 2010/10/22.

    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        root.setOrphan() # 2010/10/22.
        g.es("not written:",fileName)

    return ok
#@+node:ekr.20080711093251.5: *6* at.writeOneAtShadowNode & helpers
def writeOneAtShadowNode(self,p,toString,force):

    '''Write p, an @shadow node.

    File indices *must* have already been assigned.'''

    trace = False and not g.unitTesting
    at = self ; c = at.c ; x = c.shadowController
    root = p.copy() 

    fn = p.atShadowFileNodeName()
    if trace: g.trace(p.h,fn)
    if not fn:
        g.es_print('can not happen: not an @shadow node',p.h,color='red')
        return False

    # A hack to support unknown extensions.
    self.adjustTargetLanguage(fn) # May set c.target_language.

    fn = at.fullPath(p)
    at.default_directory = g.os_path_dirname(fn)

    # Bug fix 2010/01/18: Make sure we can compute the shadow directory.
    private_fn = x.shadowPathName(fn)
    if not private_fn:
        return False

    if not toString and at.shouldPromptForDangerousWrite(fn,root):
        # Prompt if writing a new @shadow node would overwrite the existing public file.
        ok = self.promptForDangerousWrite(fn,kind='@shadow')
        if ok:
            # Fix bug 889175: Remember the full fileName.
            at.rememberReadPath(fn,root)
        else:
            g.es("not written:",fn)
            return

    c.endEditing() # Capture the current headline.

    at.initWriteIvars(root,targetFileName=None, # Not used.
        atShadow=True,
        nosentinels=None, # set below.  Affects only error messages (sometimes).
        thinFile=True, # New in Leo 4.5 b2: private files are thin files.
        scriptWrite=False,
        toString=False, # True: create a fileLikeObject.  This is done below.
        forcePythonSentinels=True) # A hack to suppress an error message.
            # The actual sentinels will be set below.
            
    # g.trace('encoding',repr(at.encoding))

    # Bug fix: Leo 4.5.1: use x.markerFromFileName to force the delim to match
    #                     what is used in x.propegate changes.
    marker = x.markerFromFileName(fn)
    at.startSentinelComment,at.endSentinelComment=marker.getDelims()

    if g.app.unitTesting: ivars_dict = g.getIvarsDict(at)

    # Write the public and private files to public_s and private_s strings.
    data = []
    for sentinels in (False,True):
        # 2011/09/09: specify encoding explicitly.
        theFile = at.openStringFile(fn,encoding=at.encoding)
        at.sentinels = sentinels
        at.writeOpenFile(root,
            nosentinels=not sentinels,toString=False)
            # nosentinels only affects error messages, and then only if atAuto is True.
        s = at.closeStringFile(theFile)
        data.append(s)

    # Set these new ivars for unit tests.
    at.public_s, at.private_s = data

    if g.app.unitTesting:
        exceptions = ('public_s','private_s','sentinels','stringOutput')
        assert g.checkUnchangedIvars(at,ivars_dict,exceptions),'writeOneAtShadowNode'

    if at.errors == 0 and not toString:
        # Write the public and private files.
        if trace: g.trace('writing',fn)
        x.makeShadowDirectory(fn) # makeShadowDirectory takes a *public* file name.
        at.replaceFileWithString(private_fn,at.private_s)
        at.replaceFileWithString(fn,at.public_s)

    self.checkPythonCode(root,s=at.private_s,targetFn=fn)

    if at.errors == 0:
        root.clearOrphan()
        root.clearDirty()
    else:
        g.es("not written:",at.outputFileName,color='red')
        root.setDirty() # New in Leo 4.4.8.
        root.setOrphan() # 2010/10/22.

    return at.errors == 0
#@+node:ekr.20080819075811.13: *7* adjustTargetLanguage
def adjustTargetLanguage (self,fn):

    """Use the language implied by fn's extension if
    there is a conflict between it and c.target_language."""

    at = self ; c = at.c

    if c.target_language:
        junk,target_ext = g.os_path_splitext(fn)  
    else:
        target_ext = ''

    junk,ext = g.os_path_splitext(fn)

    if ext:
        if ext.startswith('.'): ext = ext[1:]

        language = g.app.extension_dict.get(ext)
        if language:
            c.target_language = language
        else:
            # An unknown language.
            pass # Use the default language, **not** 'unknown_language'
#@+node:ekr.20041005105605.212: *6* replaceTargetFileIfDifferent (atFile)
def replaceTargetFileIfDifferent (self,root,ignoreBlankLines=False):

    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.

    Return True if the original file was changed.
    '''

    trace = False and not g.unitTesting
    c = self.c ; at = c.atFileCommands

    assert(self.outputFile is None)

    if self.toString:
        # Do *not* change the actual file or set any dirty flag.
        self.fileChangedFlag = False
        return False

    if root:
        # The default: may be changed later.
        root.clearOrphan()
        root.clearDirty()

    if trace: g.trace(
        'ignoreBlankLines',ignoreBlankLines,
        'target exists',g.os_path_exists(self.targetFileName),
        self.outputFileName,self.targetFileName)

    if g.os_path_exists(self.targetFileName):
        if self.compareFiles(
            self.outputFileName,
            self.targetFileName,
            ignoreLineEndings=not self.explicitLineEnding,
            ignoreBlankLines=ignoreBlankLines):
            # Files are identical.
            ok = self.remove(self.outputFileName)
            if trace: g.trace('files are identical')
            if ok:
                g.es('unchanged:',self.shortFileName)
            else:
                g.es('error writing',self.shortFileName,color='red')
                g.es('not written:',self.shortFileName)
                if root:
                    root.setDirty() # New in 4.4.8.
                    root.setOrphan() # 2010/10/22.
            self.fileChangedFlag = False
            return False
        else:
            # A mismatch.
            self.checkPythonCode(root)
            << report if the files differ only in line endings >>
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                c.setFileTimeStamp(self.targetFileName)
                g.es('wrote:',self.shortFileName)
            else:
                g.es('error writing',self.shortFileName,color='red')
                g.es('not written:',self.shortFileName)
                if root:
                    root.setDirty() # New in 4.4.8.
                    root.setOrphan() # 2010/10/22.

            self.fileChangedFlag = ok
            return ok
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            c.setFileTimeStamp(self.targetFileName)
            g.es('created:',self.targetFileName)
            if root:
                # Fix bug 889175: Remember the full fileName.
                at.rememberReadPath(self.targetFileName,root)
        else:
            # self.rename gives the error.
            if root:
                root.setDirty() # New in 4.4.8.
                root.setOrphan() # 2010/10/22.

        # No original file to change. Return value tested by a unit test.
        self.fileChangedFlag = False 
        return False
#@+node:ekr.20041019090322: *7* << report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in:",self.targetFileName,color="blue")
#@+node:ekr.20120116060011.13558: *4* Fixed bug in DynamicWindow.setGeometry
@nocolor-node

DynamicWindow.setGeometry now does *not* change the window size when using the qttabs gui.

Added a comment to this effect in leoSettings.leo.
#@+node:ekr.20111024170505.16459: *4* Fixed bug 87933: Redefining a key binding breaks menu items with same binding
@nocolor-node

What I did:
    
- Fixed the Shift-Tab buglet by adding lower-case entries in app.tkNamesList
    This matches what is done in k.settingsNameDict.
- Created << define global key dicts >> in leoApp.py.
- Changed si.val to si.stroke.
- Replaced g.bunch by GeneralSetting & ShortcutInfo.
- Replaced bunchList by aList.
- Removed dynamic_menus "compile-time" constant.
- onAboutToShow now recomputes the contents of menus whenever menus are invoked.
- leo_update_shortcut now shows all shortcuts for a command.
- Wrote and tested merge_settings_dict.
#@+node:ekr.20120128103510.13674: *5*  Report
@nocolor-node

Bug 879331: Redefining a key binding breaks menu items with same binding

https://bugs.launchpad.net/leo-editor/+bug/879331

> Now I understand.  If I override the shortcut associated with the menu
> item, in this case Alt-A, the menu breaks.

This is a serious bug!  The menu item now executes the command bound
to Alt-A!  Very bad.

=========

http://groups.google.com/group/leo-editor/browse_thread/thread/762e832909c3c530/d99d48eed45d1061

http://mail.google.com/mail/#inbox/1331909dd653f3c9

Redefining a binding, say for Alt-a, in x.leo will cause the sort-siblings menu
(bound to alt-a) to execute the command specified by the command bound to Alt-a!

https://bugs.launchpad.net/leo-editor/+bug/815564

This anomaly only occurs when all of the following conditions are true:

1) There is a global command name X that is the "same" as the root name of the
file containing a plugin Y. Here, "same" means equal after the command name is
converted to lower case and all underlines in the root name are replaced by
dashes.

2) A shortcut (a.k.a. keystroke) is bound to command name X.

When these conditions are true, then the Plugins dropdown menu shows the key
binding next to the plugin name and left-clicking the plugin name executes the
global command--and, there is no way to display the plugin's help.

Plugin Help Rendering: Plugin help is rendered by the viewrendered plugin, not
by the old scrolledmessage.py plugin.

Leo-editor revision: 4433
OS: Ubuntu 11.04 (natty)

Startup log pane:
Leo Log Window
Leo 4.9 final, build 4411, June 21, 2011
Python 2.7.1, qt version 4.7.2
linux2
#@+node:ekr.20120128103510.13676: *6* Bug 815564: Plugin Menu-Keystroke binding can prevent plugin help display
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/815564

===== Probably the same as bug 879331 =====

This anomaly only occurs when all of the following conditions are true:

1) There is a global command name X that is the "same" as the root name of the
file containing a plugin Y. Here, "same" means equal after the command name is
converted to lower case and all underlines in the root name are replaced by
dashes.

2) A shortcut (a.k.a. keystroke) is bound to command name X.

When these conditions are true, then the Plugins dropdown menu shows the key
binding next to the plugin name and left-clicking the plugin name executes the
global command--and, there is no way to display the plugin's help.

Plugin Help Rendering: Plugin help is rendered by the viewrendered plugin, not
by the old scrolledmessage.py plugin.

Leo-editor revision: 4433
OS: Ubuntu 11.04 (natty)

Startup log pane:
Leo Log Window
Leo 4.9 final, build 4411, June 21, 2011
Python 2.7.1, qt version 4.7.2
linux2
#@+node:ekr.20120129174505.10242: *5* New
#@+node:ekr.20120123143207.10223: *6* g.GeneralSetting & isGeneralSetting
# Important: The startup code uses this class,
# so it is convenient to define it in leoGlobals.py.
class GeneralSetting:
    
    '''A class representing any kind of setting except shortcuts.'''
    
    def __init__ (self,kind,encoding=None,ivar=None,setting=None,val=None,path=None,tag='setting'):
    
        self.encoding = encoding
        self.ivar = ivar
        self.kind = kind
        self.path = path
        self.setting = setting
        self.val = val
        self.tag = tag
        
    def __repr__ (self):
        
        result = ['GeneralSetting kind: %s' % (self.kind)]
        ivars = ('ivar','path','setting','val','tag')
        for ivar in ivars:
            if hasattr(self,ivar):
                val =  getattr(self,ivar)
                if val is not None:
                    result.append('%s: %s' % (ivar,val))
        return ','.join(result)
        
    dump = __repr__
        
def isGeneralSetting(obj):
    return isinstance(obj,GeneralSetting)
#@+node:ekr.20120123115816.10209: *6* g.ShortcutInfo & isShortcutInfo
# bindKey:            ShortcutInfo(kind,commandName,func,pane)
# bindKeyToDict:      ShortcutInfo(kind,commandName,func,pane,stroke)
# createModeBindings: ShortcutInfo(kind,commandName,func,nextMode,stroke)

# Important: The startup code uses this class,
# so it is convenient to define it in leoGlobals.py.
class ShortcutInfo:
    
    '''A class representing any kind of key binding line.
    
    This includes other information besides just the KeyStroke.'''
        
    @others

def isShortcutInfo(obj):
    return isinstance(obj,ShortcutInfo)
#@+node:ekr.20120129040823.10254: *7*  ctor (ShortcutInfo)
def __init__ (self,kind,commandName='',func=None,nextMode=None,pane=None,stroke=None):
    
    trace = False and commandName=='new' and not g.unitTesting

    if not (stroke is None or g.isStroke(stroke)):
        g.trace('***** (ShortcutInfo) oops',repr(stroke))

    self.kind = kind
    self.commandName = commandName
    self.func = func
    self.nextMode = nextMode
    self.pane = pane
    self.stroke = stroke
        # The *caller* must canonicalize the shortcut.

    if trace: g.trace('(ShortcutInfo)',commandName,stroke,g.callers())
#@+node:ekr.20120203153754.10031: *7* __hash__ (ShortcutInfo)
def __hash__ (self):
    
    return self.stroke.__hash__() if self.stroke else 0
#@+node:ekr.20120125045244.10188: *7* __repr__ & ___str_& dump (ShortcutInfo)
def __repr__ (self):
    
    return self.dump()

__str__ = __repr__

def dump (self):
    si = self    
    result = ['ShortcutInfo %17s' % (si.kind)]
    # Print all existing ivars.
    table = ('commandName','func','nextMode','pane','stroke')
    for ivar in table:
        if hasattr(si,ivar):
            val =  getattr(si,ivar)
            if val not in (None,'none','None',''):
                if ivar == 'func': val = val.__name__
                s = '%s %s' % (ivar,val)
                result.append(s)
    return '[%s]' % ' '.join(result).strip()
#@+node:ekr.20120129040823.10226: *7* isModeBinding
def isModeBinding (self):
    
    return self.kind.startswith('*mode')
#@+node:ekr.20120124042346.12937: *6* define_enable_table
def define_enable_dict (self):
    
    c = self.c
    
    if not c.commandsDict:
        return # This is not an error: it happens during init.

    self.enable_dict = d = {
    
        # File menu...
            # 'revert':         True, # Revert is always enabled.               
        'open-with':            g.app.hasOpenWithMenu,
        
        # Edit menu...
        'undo':                 c.undoer.canUndo,
        'redo':                 c.undoer.canRedo,
        'extract-names':        c.canExtractSectionNames,
        'extract':              c.canExtract,
        'match-brackets':       c.canFindMatchingBracket,
        
        # Top-level Outline menu...
        'cut-node':             c.canCutOutline,
        'delete-node':          c.canDeleteHeadline,
        'paste-node':           c.canPasteOutline,
        'paste-retaining-clones':   c.canPasteOutline,
        'clone-node':           c.canClone,
        'sort-siblings':        c.canSortSiblings,
        'hoist':                c.canHoist,
        'de-hoist':             c.canDehoist,
        
        # Outline:Expand/Contract menu...
        'contract-parent':      c.canContractParent,
        'contract-node':        lambda: c.p.hasChildren() and c.p.isExpanded(),
        'contract-or-go-left':  lambda: c.p.hasChildren() and c.p.isExpanded() or c.p.hasParent(),
        'expand-node':          lambda: c.p.hasChildren() and not c.p.isExpanded(),
        'expand-prev-level':    lambda: c.p.hasChildren() and c.p.isExpanded(),
        'expand-next-level':    lambda: c.p.hasChildren(),
        'expand-to-level-1':    lambda: c.p.hasChildren() and c.p.isExpanded(),
        'expand-or-go-right':   lambda: c.p.hasChildren(),
        
        # Outline:Move menu...
        'move-outline-down':    lambda: c.canMoveOutlineDown(),
        'move-outline-left':    lambda: c.canMoveOutlineLeft(),
        'move-outline-right':   lambda: c.canMoveOutlineRight(),
        'move-outline-up':      lambda: c.canMoveOutlineUp(),
        'promote':              lambda: c.canPromote(),
        'demote':               lambda: c.canDemote(),
        
        # Outline:Go To menu...
        'goto-prev-history-node':   lambda: c.nodeHistory.canGoToPrevVisited(),
        'goto-next-history-node':   lambda: c.nodeHistory.canGoToNextVisited(),
        'goto-prev-visible':        lambda: c.canSelectVisBack(),
        'goto-next-visible':        lambda: c.canSelectVisNext(),
        # These are too slow...
            # 'go-to-next-marked':  c.canGoToNextMarkedHeadline,
            # 'go-to-next-changed': c.canGoToNextDirtyHeadline,
        'goto-next-clone':          lambda: c.p.isCloned(),
        'goto-prev-node':           lambda: c.canSelectThreadBack(),
        'goto-next-node':           lambda: c.canSelectThreadNext(),
        'goto-parent':              lambda: c.p.hasParent(),
        'goto-prev-sibling':        lambda: c.p.hasBack(),
        'goto-next-sibling':        lambda: c.p.hasNext(),
        
        # Outline:Mark menu...
        'mark-subheads':            lambda: c.p.hasChildren(),
        # too slow...
            # 'mark-changed-items':   c.canMarkChangedHeadlines,
    }
    
    for i in range(1,9):
        d ['expand-to-level-%s' % (i)] = lambda: c.p.hasChildren()

    if 0: # Initial testing.
        commandKeys = list(c.commandsDict.keys())
        for key in sorted(d.keys()):
            if key not in commandKeys:
                g.trace('*** bad entry for %s' % (key))
#@+node:ekr.20120124103240.10250: *5* Changed
#@+node:ekr.20061031131434.3: *6* << about key dicts >>
@nocolor
@

ivar                    Keys                Values
----                    ----                ------
c.commandsDict          command names (1)   functions
k.inverseCommandsDict   func.__name__       command names
k.bindingsDict          shortcuts           lists of ShortcutInfo objects
k.masterBindingsDict    scope names (2)     Interior masterBindingDicts (3)
k.masterGuiBindingsDict strokes             list of widgets in which stoke is bound
k.settingsNameDict (4)  settings.lower()    "Real" Tk specifiers
inverseBindingDict (5)  command names       lists of tuples (pane,key)
modeCommandsDict (6)    command name (7)    inner modeCommandsDicts (8)

Notes:

(1) Command names are minibuffer names (strings)
(2) Scope names are 'all','text',etc.
(3) Interior masterBindingDicts: Keys are strokes; values are ShortcutInfo objects.
(4) k.settingsNameDict has no inverse.
(5) inverseBindingDict is **not** an ivar: it is computed by k.computeInverseBindingDict.
(6) A global dict: g.app.gui.modeCommandsDict
(7) enter-x-command
(8) Keys are command names, values are lists of ShortcutInfo objects.
#@+node:ekr.20031218072017.1723: *6* createMenuEntries (leoMenu) & helpers
def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    c = self.c ; k = c.k
    if g.app.unitTesting: return
    if not menu: return
    
    self.traceMenuTable(table)

    for data in table:
        label,command,done = self.getMenuEntryInfo(data,menu)
        if done: continue
        commandName = self.getMenuEntryBindings(command,dynamicMenu,label)
        if not commandName: continue
            
        masterMenuCallback = self.createMasterMenuCallback(
            dynamicMenu,command,commandName)

        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")

        # c.add_command ensures that c.outerUpdate is called.
        c.add_command(menu,label=realLabel,
            accelerator='', # The accelerator is now computed dynamically.
            command=masterMenuCallback,
            commandName=commandName,
            underline=amp_index)
#@+node:ekr.20111102072143.10016: *7* createMasterMenuCallback
def createMasterMenuCallback(self,dynamicMenu,command,commandName):
    
    trace = False and not g.unitTesting
    c = self.c
    
    def setWidget():
        w = c.frame.getFocus()
        if w and sys.platform.startswith('darwin'):
             # 2012/01/11: redirect (MacOS only).
            wname = c.widget_name(w) or ''
            if wname.startswith('head'):
                w = c.frame.tree.edit_widget(c.p)
        return w

    if dynamicMenu:
        if command:
            def masterDynamicMenuCallback (c=c,command=command):
                # 2012/01/07: set w here.
                w = setWidget()
                if trace: g.trace(command.__name__,w) 
                event = g.app.gui.create_key_event(c,None,None,w)
                return c.k.masterCommand(func=command,event=event)
            return masterDynamicMenuCallback
        else:
            g.internalError('no callback for dynamic menu item.')
            def dummyMasterMenuCallback():
                pass
            return dummyMasterMenuCallback
    else:
        def masterStaticMenuCallback (c=c,commandName=commandName):
            # 2011/10/28: Use only the command name to dispatch the command.
            # 2012/01/07: Bug fix: set w here.
            w = setWidget()
            if trace: g.trace(commandName,w,c)
            event = g.app.gui.create_key_event(c,None,None,w)
            return c.k.masterCommand(commandName=commandName,event=event)
        return masterStaticMenuCallback
#@+node:ekr.20111028060955.16568: *7* getMenuEntryBindings
def getMenuEntryBindings(self,command,dynamicMenu,label):
    
    '''Compute commandName from command.'''

    trace = False and not g.unitTesting
    c = self.c

    if type(command) == type(''):
        # Command is really a command name.
        commandName = command 
    else:
        # First, get the old-style name.
        commandName = self.computeOldStyleShortcutKey(label)
        
    command = c.commandsDict.get(commandName)
        
    if trace and not command and not dynamicMenu:
        # This may come from a plugin that normally isn't enabled.
        g.trace('No inverse for %s' % commandName)
        
    return commandName
#@+node:ekr.20111028060955.16565: *7* getMenuEntryInfo
def getMenuEntryInfo (self,data,menu):
    
    done = False

    if g.isString(data):
        # A single string is both the label and the command.
        s = data
        removeHyphens = s and s[0]=='*'
        if removeHyphens: s = s[1:]
        label = self.capitalizeMinibufferMenuName(s,removeHyphens)
        command = s.replace('&','').lower()
        if label == '-':
            self.add_separator(menu)
            done = True # That's all.
    else:
        ok = type(data) in (type(()), type([])) and len(data) in (2,3)
        if ok:
            if len(data) == 2:
                # Command can be a minibuffer-command name.
                label,command = data
            else:
                # Ignore shortcuts bound in menu tables.
                label,junk,command = data
    
            if label in (None,'-'):
                self.add_separator(menu)
                done = True # That's all.
        else:
            g.trace('bad data in menu table: %s' % repr(data))
            done = True # Ignore bad data
            
    return label,command,done
#@+node:ekr.20111028060955.16563: *7* traceMenuTable
def traceMenuTable (self,table):
    
    trace = False and not g.unitTesting
    
    if not trace: return
    format = '%40s %s'
    g.trace('*'*40,g.callers())
    for data in table:
        if type(data) in (type(()), type([])):
            n = len(data)
            if n == 2:
                print(format % (data[0],data[1]))
            elif n == 3:
                name,junk,func = data
                print(format % (name,func and func.__name__ or '<NO FUNC>'))
        else:
            print(format % (data,''))
#@+node:ekr.20041117062717.14: *6* getShortcut (g.app.config)
def getShortcut (self,c,commandName):

    '''Return rawKey,accel for shortcutName'''
    
    trace = False and not g.unitTesting # commandName in ('new','print-bindings')
    
    if not c.frame.menu:
        # Called from doPlugins.
        g.trace('no menu: %32s' % (commandName))
            #,'\n',g.callers(8))
        return None,[]

    key = c.frame.menu.canonicalizeMenuName(commandName)
    key = key.replace('&','') # Allow '&' in names.

    # New code: use the dicts created by merge_settings_dict.
    table = (
        ('local',            c and self.localShortcutsDict.get(c.hash(),{})),
        ('myLeoSettings.leo',g.app.config.immutable_my_leo_settings_shortcuts_dict),
        ('leoSettings.leo',  g.app.config.immutable_leo_settings_shortcuts_dict),
    )
    aList = []
    for tag,d in table:
        if d:
            if trace: g.trace(tag,len(list(d.keys())))
            aList = d.get(commandName,[])
            if aList:
                for si in aList:
                    assert isinstance(si,g.ShortcutInfo),si
                break
                
    # It's very important to filter empty strokes here.
    aList = [si for si in aList
        if si.stroke and si.stroke.lower() != 'none']

    if trace: g.trace('getShortcut',tag,aList)

    return key,aList
#@+node:ekr.20041227063801.2: *6* gcm.initDicts
def initDicts (self):

    # Only the settings parser needs to search all dicts.
    self.dictList = [self.defaultsDict]

    for key,kind,val in self.defaultsData:
        self.defaultsDict[self.munge(key)] = g.GeneralSetting(
            kind,setting=key,val=val,tag='defaults')

    for key,kind,val in self.ivarsData:
        self.ivarsDict[self.munge(key)] = g.GeneralSetting(
            kind,ivar=key,val=val,tag='ivars')

    for key,kind,val in self.encodingIvarsData:
        self.encodingIvarsDict[self.munge(key)] = g.GeneralSetting(
            kind,encoding=val,ivar=key,tag='encoding')
#@+node:ekr.20061031131434.89: *6* k.bindKey & helpers
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False,tag=None):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.
    
    tag gives the source of the binding.
    
    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    if not k.check_bind_key(commandName,pane,shortcut):
        return False

    aList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %17s %s' % (pane,shortcut,tag,commandName))
    try:
        if not shortcut:
            stroke = None
        elif g.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s,stroke
        else:
            stroke = k.strokeFromSetting(shortcut)

        si = g.ShortcutInfo(kind=tag,pane=pane,
            func=callback,commandName=commandName,stroke=stroke)
    
        if shortcut: #####
            k.bindKeyToDict(pane,shortcut,si)
        if not modeFlag:
            if shortcut:
                k.remove_conflicting_definitions(aList,pane,shortcut)
        aList.append(si)
        if shortcut:
            assert stroke
            k.bindingsDict [stroke] = aList
            if trace: g.trace(shortcut,aList)
        return True
    except Exception: # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20120130074511.10228: *7* k.check_bind_key
def check_bind_key(self,commandName,pane,shortcut):
    
    if not shortcut:
        return False

    k = self
    assert g.isStroke(shortcut)

    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter','leave'):
        if shortcut.lower().find(s) > -1:
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return False

    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    else:
        return True
#@+node:ekr.20120130074511.10227: *7* k.kill_one_shortcut
def kill_one_shortcut (self,stroke):
    
    '''Update the dicts so that c.config.getShortcut(name) will return None
    for all names *presently* bound to the stroke.'''
    
    k = self ; c = k.c
    lm = g.app.loadManager
    
    # A crucial shortcut: inverting and uninverting dictionaries is slow.
    # Important: the comparison is valid regardless of the type of stroke.
    if stroke in (None,'None','none'):
        return
        
    assert g.isStroke(stroke),stroke
        
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.ShortcutInfo)

    inv_d = lm.invert(d)
    aList = inv_d.get(stroke,[])
    inv_d[stroke] = []
    
    c.config.shortcutsDict = lm.uninvert(inv_d)
#@+node:ekr.20061031131434.92: *7* k.remove_conflicting_definitions
def remove_conflicting_definitions (self,aList,pane,shortcut):
    
    trace = False and not g.unitTesting
    k = self
    result = []
    for si in aList:
        assert g.isShortcutInfo(si),si
        if pane in ('button','all',si.pane):
            if trace: g.trace('removing %s' % (si.dump()))
            k.kill_one_shortcut(shortcut)
        else:
            result.append(si)
    aList = result
    
    # aList = [si for si in aList if pane not in ('button','all',si.pane)]
#@+node:ekr.20061031131434.93: *7* k.bindKeyToDict
def bindKeyToDict (self,pane,stroke,si):
    
    '''Update k.masterBindingsDict for the stroke.'''

    trace = False and not g.unitTesting
        # and stroke.lower().find('tab') != -1 
    k = self
    
    assert g.isStroke(stroke),stroke
    
    # New in Leo 4.4.1: Allow redefintions.
    d = k.masterBindingsDict.get(pane,{})
    d[stroke] = si
    k.masterBindingsDict [pane] = d
#@+node:ekr.20061031131434.94: *7* k.bindOpenWith
def bindOpenWith (self,d):

    '''Register an open-with command.'''

    k = self ; c = k.c
    
    shortcut = d.get('shortcut')
    name = d.get('name')
    
    # g.trace(d)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,d=d):
        return c.openWith(d=d)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='all',verbose=False)
#@+node:ekr.20120120095156.10260: *6* leo_update_shortcut
def leo_update_shortcut(self,action,commandName):
    
    trace = False and not g.unitTesting
    c = self.c ; k = c.k
    
    if action:
        s = action.text()
        parts = s.split('\t')
        if len(parts) >= 2: s = parts[0]
        key,aList = c.config.getShortcut(commandName)
        if aList:
            result = []
            for si in aList:
                assert g.isShortcutInfo(si),si
                # Don't show mode-related bindings.
                if not si.isModeBinding():
                    accel = k.prettyPrintKey(si.stroke)
                    if trace: g.trace('%20s %s' % (accel,si.dump()))
                    result.append(accel)
                    # Break here if we want to show only one accerator.
            action.setText('%s\t%s' % (s,', '.join(result)))
        else:
            action.setText(s)
    else:
        g.trace('can not happen: no action for %s' % (commandName))
#@+node:ekr.20110605121601.18460: *6* onAboutToShow & helpers (qtMenuWrapper)
def onAboutToShow(self,*args,**keys):
    
    trace = False and not g.unitTesting ; verbose = True
    name = self.leo_menu_label
    if not name: return

    for action in self.actions():
        commandName = hasattr(action,'leo_command_name') and action.leo_command_name
        if commandName:
            if trace: g.trace(commandName)
            self.leo_update_shortcut(action,commandName)
            self.leo_enable_menu_item(action,commandName)
            self.leo_update_menu_label(action,commandName)
   
#@+node:ekr.20120120095156.10261: *7* leo_enable_menu_item
def leo_enable_menu_item (self,action,commandName):

    func = self.c.frame.menu.enable_dict.get(commandName)

    if action and func:
        val = func()
        # g.trace('%5s %20s %s' % (val,commandName,val))
        action.setEnabled(bool(val))
        
#@+node:ekr.20120124115444.10190: *7* leo_update_menu_label
def leo_update_menu_label(self,action,commandName):
    
    c = self.c
    
    if action and commandName == 'mark':
        action.setText('UnMark' if c.p.isMarked() else 'Mark')
        self.leo_update_shortcut(action,commandName)
            # Set the proper shortcut.
#@+node:ekr.20120120095156.10260: *7* leo_update_shortcut
def leo_update_shortcut(self,action,commandName):
    
    trace = False and not g.unitTesting
    c = self.c ; k = c.k
    
    if action:
        s = action.text()
        parts = s.split('\t')
        if len(parts) >= 2: s = parts[0]
        key,aList = c.config.getShortcut(commandName)
        if aList:
            result = []
            for si in aList:
                assert g.isShortcutInfo(si),si
                # Don't show mode-related bindings.
                if not si.isModeBinding():
                    accel = k.prettyPrintKey(si.stroke)
                    if trace: g.trace('%20s %s' % (accel,si.dump()))
                    result.append(accel)
                    # Break here if we want to show only one accerator.
            action.setText('%s\t%s' % (s,', '.join(result)))
        else:
            action.setText(s)
    else:
        g.trace('can not happen: no action for %s' % (commandName))
#@+node:ekr.20041120112043: *6* parseShortcutLine (ParserBaseClass)
def parseShortcutLine (self,kind,s):

    '''Parse a shortcut line.  Valid forms:

    --> entry-command
    settingName = shortcut
    settingName ! paneName = shortcut
    command-name --> mode-name = binding
    command-name --> same = binding
    '''

    trace = False and not g.unitTesting and kind == '*mode-setting*'
    c,k = self.c,self.c.k
    assert c
    name = val = nextMode = None ; nextMode = 'none'
    i = g.skip_ws(s,0)

    if g.match(s,i,'-->'): # New in 4.4.1 b1: allow mode-entry commands.
        j = g.skip_ws(s,i+3)
        i = g.skip_id(s,j,'-')
        entryCommandName = s[j:i]
        if trace: g.trace('-->',entryCommandName)
        return None,g.ShortcutInfo('*entry-command*',commandName=entryCommandName)

    j = i
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name:
        if trace: g.trace('no name',repr(s))
        return None,None

    # New in Leo 4.4b2.
    i = g.skip_ws(s,i)
    if g.match(s,i,'->'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+2)
        i = g.skip_id(s,j)
        nextMode = s[j:i]

    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]

    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i > 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    stroke = k.strokeFromSetting(val)
    assert g.isStrokeOrNone(stroke),stroke
    # g.trace('stroke',stroke)
    si = g.ShortcutInfo(kind=kind,nextMode=nextMode,pane=pane,stroke=stroke)
    if trace: g.trace('%25s %s' % (name,si))
    return name,si
#@+node:ekr.20041120094940.9: *6* set (ParserBaseClass)
def set (self,p,kind,name,val):

    """Init the setting for name to val."""

    trace = False and not g.unitTesting
    if trace: g.trace(kind,name,val)

    c = self.c

    # Note: when kind is 'shortcut', name is a command name.
    key = self.munge(name)

    # if kind and kind.startswith('setting'): g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    gs = d.get(key)
    if gs:
        assert isinstance(gs,g.GeneralSetting),gs
        path = gs.path
        if c.os_path_finalize(c.mFileName) != c.os_path_finalize(path):
            g.es("over-riding setting:",name,"from",path)

    # Important: we can't use c here: it may be destroyed!
    d [key] = g.GeneralSetting(kind,path=c.mFileName,val=val,tag='setting')
#@+node:ekr.20120128103510.13670: *5* Updating dependent dicts
@nocolor-node


k.computeInversBinding() called by print-commands and for auto-completion.

k.bindKey sets k.bindingsDict.

k.bindKeyToDict sets k.masterBindingDict.
#@+node:ekr.20061031131434.98: *6* k.makeAllBindings
def makeAllBindings (self):

    k = self ; c = k.c

    # g.trace(c.shortFileName())

    k.bindingsDict = {}
    if g.new_modes:
        k.modeController.addModeCommands()
    else:
        k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    c.frame.body.createBindings()
    c.frame.log.setTabBindings('Log')
    if c.frame.statusLine: c.frame.statusLine.setBindings()
    c.frame.tree.setBindings()
    c.frame.setMinibufferBindings()
    k.completeAllBindings()
    k.checkBindings()
#@+node:ekr.20061031131434.93: *6* k.bindKeyToDict
def bindKeyToDict (self,pane,stroke,si):
    
    '''Update k.masterBindingsDict for the stroke.'''

    trace = False and not g.unitTesting
        # and stroke.lower().find('tab') != -1 
    k = self
    
    assert g.isStroke(stroke),stroke
    
    # New in Leo 4.4.1: Allow redefintions.
    d = k.masterBindingsDict.get(pane,{})
    d[stroke] = si
    k.masterBindingsDict [pane] = d
#@+node:ekr.20061031131434.176: *6* k.computeInverseBindingDict
def computeInverseBindingDict (self):

    k = self ; d = {}

    # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict.keys():
        assert g.isStroke(stroke),repr(stroke)
        aList = k.bindingsDict.get(stroke,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            shortcutList = d.get(si.commandName,[])
            
            # The shortcutList consists of tuples (pane,stroke).
            # k.inverseBindingDict has values consisting of these tuples.
            aList = k.bindingsDict.get(stroke,g.ShortcutInfo(kind='dummy',pane='all'))
                    # Important: only si.pane is required below.
            for si in aList:
                assert g.isShortcutInfo(si),si
                pane = '%s:' % (si.pane)
                data = (pane,stroke)
                if data not in shortcutList:
                    shortcutList.append(data)

            d [si.commandName] = shortcutList

    return d
#@+node:ekr.20061031131434.80: *6* k.finishCreate & helpers
def finishCreate (self):

    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: print('k.finishCreate')

    k = self ; c = k.c
    self.w = c.frame.miniBufferWidget
        # Will be None for nullGui.

    k.createInverseCommandsDict()
    k.makeAllBindings()
    self.inited = True

    k.setDefaultInputState()
    k.resetLabel()
#@+node:ekr.20061031131434.81: *7* createInverseCommandsDict
def createInverseCommandsDict (self):

    '''Add entries to k.inverseCommandsDict using c.commandDict.

    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict:
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))

        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())
#@+node:ekr.20061031131434.131: *6* k.registerCommand
def registerCommand (self,commandName,shortcut,func,
    pane='all',verbose=False, wrap=True):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.

    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if wrap:
        func = c.universalCallback(func)
    f = c.commandsDict.get(commandName)

    if f and f.__name__ != 'dummyCallback' and trace and verbose:
        g.es_print('redefining',commandName, color='red')
        
    assert not g.isStroke(shortcut)

    c.commandsDict [commandName] = func
    fname = func.__name__
    k.inverseCommandsDict [fname] = commandName
    if trace and fname != 'minibufferCallback':
        g.trace('leoCommands %24s = %s' % (fname,commandName))

    if shortcut:
        if trace: g.trace('shortcut',shortcut,g.callers())
        stroke = k.strokeFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a stroke from leoSettings.leo.
        stroke = None
        junk,aList = c.config.getShortcut(commandName)
        for si in aList:
            assert g.isShortcutInfo(si),si
            assert g.isStrokeOrNone(si.stroke)
            if si.stroke and not si.pane.endswith('-mode'):
                if trace: g.trace('*** found',si)
                stroke = si.stroke
                break

    if stroke:
        if trace: g.trace('stroke',stroke,'pane',pane,commandName)
        ok = k.bindKey (pane,stroke,func,commandName,tag='register-command') # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if trace and verbose and ok and not g.app.silentMode:
            # g.trace(g.callers())
            g.es_print('','@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
        c.frame.tree.setBindings()
    elif trace and verbose and not g.app.silentMode:
        g.trace(g.callers())
        g.es_print('','@command: %s' % (commandName),color='blue')

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
#@+node:ekr.20120129174505.10243: *5* The missing settings bug (c.hash)
#@+node:ekr.20041130173135: *6* c.hash
# This is a bad idea.
def hash (self):
    c = self
    if c.mFileName:
        return c.os_path_finalize(c.mFileName).lower()
    else:
        return 0
#@+node:ekr.20120130074511.10226: *4* Fixed bug: @button @key=x does not override x
@nocolor-node

Created k.kill_one_shortcut, called from k.remove_conflicting_definitions.
#@+node:ekr.20061031131434.89: *5* k.bindKey & helpers
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False,tag=None):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.
    
    tag gives the source of the binding.
    
    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    if not k.check_bind_key(commandName,pane,shortcut):
        return False

    aList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %17s %s' % (pane,shortcut,tag,commandName))
    try:
        if not shortcut:
            stroke = None
        elif g.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s,stroke
        else:
            stroke = k.strokeFromSetting(shortcut)

        si = g.ShortcutInfo(kind=tag,pane=pane,
            func=callback,commandName=commandName,stroke=stroke)
    
        if shortcut: #####
            k.bindKeyToDict(pane,shortcut,si)
        if not modeFlag:
            if shortcut:
                k.remove_conflicting_definitions(aList,pane,shortcut)
        aList.append(si)
        if shortcut:
            assert stroke
            k.bindingsDict [stroke] = aList
            if trace: g.trace(shortcut,aList)
        return True
    except Exception: # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20120130074511.10228: *6* k.check_bind_key
def check_bind_key(self,commandName,pane,shortcut):
    
    if not shortcut:
        return False

    k = self
    assert g.isStroke(shortcut)

    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter','leave'):
        if shortcut.lower().find(s) > -1:
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return False

    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    else:
        return True
#@+node:ekr.20120130074511.10227: *6* k.kill_one_shortcut
def kill_one_shortcut (self,stroke):
    
    '''Update the dicts so that c.config.getShortcut(name) will return None
    for all names *presently* bound to the stroke.'''
    
    k = self ; c = k.c
    lm = g.app.loadManager
    
    # A crucial shortcut: inverting and uninverting dictionaries is slow.
    # Important: the comparison is valid regardless of the type of stroke.
    if stroke in (None,'None','none'):
        return
        
    assert g.isStroke(stroke),stroke
        
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.ShortcutInfo)

    inv_d = lm.invert(d)
    aList = inv_d.get(stroke,[])
    inv_d[stroke] = []
    
    c.config.shortcutsDict = lm.uninvert(inv_d)
#@+node:ekr.20061031131434.92: *6* k.remove_conflicting_definitions
def remove_conflicting_definitions (self,aList,pane,shortcut):
    
    trace = False and not g.unitTesting
    k = self
    result = []
    for si in aList:
        assert g.isShortcutInfo(si),si
        if pane in ('button','all',si.pane):
            if trace: g.trace('removing %s' % (si.dump()))
            k.kill_one_shortcut(shortcut)
        else:
            result.append(si)
    aList = result
    
    # aList = [si for si in aList if pane not in ('button','all',si.pane)]
#@+node:ekr.20061031131434.93: *6* k.bindKeyToDict
def bindKeyToDict (self,pane,stroke,si):
    
    '''Update k.masterBindingsDict for the stroke.'''

    trace = False and not g.unitTesting
        # and stroke.lower().find('tab') != -1 
    k = self
    
    assert g.isStroke(stroke),stroke
    
    # New in Leo 4.4.1: Allow redefintions.
    d = k.masterBindingsDict.get(pane,{})
    d[stroke] = si
    k.masterBindingsDict [pane] = d
#@+node:ekr.20061031131434.94: *6* k.bindOpenWith
def bindOpenWith (self,d):

    '''Register an open-with command.'''

    k = self ; c = k.c
    
    shortcut = d.get('shortcut')
    name = d.get('name')
    
    # g.trace(d)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,d=d):
        return c.openWith(d=d)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='all',verbose=False)
#@+node:ekr.20120218130028.10478: *4* Fixed Bug: @mark-for-unit-tests nodes
@nocolor-node

The new TM.findMarkForUnitTestNodes allows both
TM.FindAllUnitTestsNodes and createOutline to be much simpler.
#@+node:ekr.20120225202614.10234: *4* The clean,clear& sort recent files commands now work
#@+node:ekr.20120225072226.10290: *5* Reference
#@+node:ekr.20120219154958.10484: *6* LM.initApp
def initApp (self,verbose):
    
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: print('LM.initApp')
    
    assert g.app.loadManager
    
    import leo.core.leoConfig as leoConfig
    import leo.core.leoNodes as leoNodes
    import leo.core.leoPlugins as leoPlugins
    
    # Make sure we call the new leoPlugins.init top-level function.
    # This prevents a crash when run is called repeatedly from
    # IPython's lleo extension.
    leoPlugins.init()
    
    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    
    # Create early classes *after* doing plugins.init()
    g.app.recentFilesManager = RecentFilesManager()
    g.app.config = leoConfig.GlobalConfigManager()
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)

    # Complete the plugins class last.
    g.app.pluginsController.finishCreate()
#@+node:ekr.20120223062418.10412: *6* LM.readOpenedLeoFile
def readOpenedLeoFile(self,c,gui,fn,readAtFileNodesFlag,theFile):
    
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    
    lm = self
    rf = g.app.recentFilesManager

    ok = c.fileCommands.openLeoFile(theFile,fn,
        readAtFileNodesFlag=readAtFileNodesFlag)
            # closes file.

    if ok:
        if not c.openDirectory:
            theDir = c.os_path_finalize(g.os_path_dirname(fn))
            c.openDirectory = c.frame.openDirectory = theDir 
    else:
        g.app.closeLeoWindow(c.frame)
    
    return ok
#@+node:ekr.20031218072017.2079: *6* Recent Files submenu & allies
#@+node:ekr.20031218072017.2080: *7* c.clearRecentFiles
def clearRecentFiles (self,event=None):

    """Clear the recent files list, then add the present file."""
    
    c = self
    g.app.recentFilesManager.clearRecentFiles(c)
#@+node:ekr.20031218072017.2081: *7* c.openRecentFile
def openRecentFile(self,fn=None):
    
    c = self

    # Automatically close the previous window if...
    closeFlag = (
        c.frame.startupWindow and
            # The window was open on startup
        not c.changed and not c.frame.saved and
            # The window has never been changed
        g.app.numberOfUntitledWindows == 1)
            # Only one untitled window has ever been opened.

    if g.doHook("recentfiles1",c=c,p=c.p,v=c.p,fileName=fn,closeFlag=closeFlag):
        return
    
    c2 = g.openWithFileName(fn,old_c=c)

    if closeFlag and c2 and c2 != c:
        g.app.destroyWindow(c.frame)
        c2.setLog()
        g.doHook("recentfiles2",
            c=c2,p=c2.p,v=c2.p,fileName=fn,closeFlag=closeFlag)
#@+node:tbrown.20080509212202.6: *7* c.cleanRecentFiles
def cleanRecentFiles(self,event=None):
    
    '''Remove items from the recent files list that are no longer valid.'''
    
    c = self
    g.app.recentFilesManager.cleanRecentFiles(c)
#@+node:tbrown.20080509212202.8: *7* c.sortRecentFiles
def sortRecentFiles(self,event=None):
    
    '''Sort the recent files list.'''

    c = self
    g.app.recentFilesManager.sortRecentFiles(c)
#@+node:tbrown.20080509212202.7: *6* deleteRecentFilesMenuItems (leoMenu)
def deleteRecentFilesMenuItems(self,menu):
    
    """Delete recent file menu entries"""

    rf = g.app.recentFilesManager

    # Why not just delete all the entries?
    recentFiles = rf.getRecentFiles()
    toDrop = len(recentFiles) + len(rf.getRecentFilesTable())
    self.delete_range(menu,0,toDrop)

    for i in rf.groupedMenus:
        menu = self.getMenu(i)
        if menu:
            self.destroy(menu)
            self.destroyMenu(i)
#@+node:ekr.20031218072017.1723: *6* createMenuEntries (leoMenu) & helpers
def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    c = self.c ; k = c.k
    if g.app.unitTesting: return
    if not menu: return
    
    self.traceMenuTable(table)

    for data in table:
        label,command,done = self.getMenuEntryInfo(data,menu)
        if done: continue
        commandName = self.getMenuEntryBindings(command,dynamicMenu,label)
        if not commandName: continue
            
        masterMenuCallback = self.createMasterMenuCallback(
            dynamicMenu,command,commandName)

        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")

        # c.add_command ensures that c.outerUpdate is called.
        c.add_command(menu,label=realLabel,
            accelerator='', # The accelerator is now computed dynamically.
            command=masterMenuCallback,
            commandName=commandName,
            underline=amp_index)
#@+node:ekr.20111102072143.10016: *7* createMasterMenuCallback
def createMasterMenuCallback(self,dynamicMenu,command,commandName):
    
    trace = False and not g.unitTesting
    c = self.c
    
    def setWidget():
        w = c.frame.getFocus()
        if w and sys.platform.startswith('darwin'):
             # 2012/01/11: redirect (MacOS only).
            wname = c.widget_name(w) or ''
            if wname.startswith('head'):
                w = c.frame.tree.edit_widget(c.p)
        return w

    if dynamicMenu:
        if command:
            def masterDynamicMenuCallback (c=c,command=command):
                # 2012/01/07: set w here.
                w = setWidget()
                if trace: g.trace(command.__name__,w) 
                event = g.app.gui.create_key_event(c,None,None,w)
                return c.k.masterCommand(func=command,event=event)
            return masterDynamicMenuCallback
        else:
            g.internalError('no callback for dynamic menu item.')
            def dummyMasterMenuCallback():
                pass
            return dummyMasterMenuCallback
    else:
        def masterStaticMenuCallback (c=c,commandName=commandName):
            # 2011/10/28: Use only the command name to dispatch the command.
            # 2012/01/07: Bug fix: set w here.
            w = setWidget()
            if trace: g.trace(commandName,w,c)
            event = g.app.gui.create_key_event(c,None,None,w)
            return c.k.masterCommand(commandName=commandName,event=event)
        return masterStaticMenuCallback
#@+node:ekr.20111028060955.16568: *7* getMenuEntryBindings
def getMenuEntryBindings(self,command,dynamicMenu,label):
    
    '''Compute commandName from command.'''

    trace = False and not g.unitTesting
    c = self.c

    if type(command) == type(''):
        # Command is really a command name.
        commandName = command 
    else:
        # First, get the old-style name.
        commandName = self.computeOldStyleShortcutKey(label)
        
    command = c.commandsDict.get(commandName)
        
    if trace and not command and not dynamicMenu:
        # This may come from a plugin that normally isn't enabled.
        g.trace('No inverse for %s' % commandName)
        
    return commandName
#@+node:ekr.20111028060955.16565: *7* getMenuEntryInfo
def getMenuEntryInfo (self,data,menu):
    
    done = False

    if g.isString(data):
        # A single string is both the label and the command.
        s = data
        removeHyphens = s and s[0]=='*'
        if removeHyphens: s = s[1:]
        label = self.capitalizeMinibufferMenuName(s,removeHyphens)
        command = s.replace('&','').lower()
        if label == '-':
            self.add_separator(menu)
            done = True # That's all.
    else:
        ok = type(data) in (type(()), type([])) and len(data) in (2,3)
        if ok:
            if len(data) == 2:
                # Command can be a minibuffer-command name.
                label,command = data
            else:
                # Ignore shortcuts bound in menu tables.
                label,junk,command = data
    
            if label in (None,'-'):
                self.add_separator(menu)
                done = True # That's all.
        else:
            g.trace('bad data in menu table: %s' % repr(data))
            done = True # Ignore bad data
            
    return label,command,done
#@+node:ekr.20111028060955.16563: *7* traceMenuTable
def traceMenuTable (self,table):
    
    trace = False and not g.unitTesting
    
    if not trace: return
    format = '%40s %s'
    g.trace('*'*40,g.callers())
    for data in table:
        if type(data) in (type(()), type([])):
            n = len(data)
            if n == 2:
                print(format % (data[0],data[1]))
            elif n == 3:
                name,junk,func = data
                print(format % (name,func and func.__name__ or '<NO FUNC>'))
        else:
            print(format % (data,''))
#@+node:ekr.20120225072226.10283: *5* class RecentFilesManager
class RecentFilesManager:
    
    '''A class to manipulate leoRecentFiles.txt.'''
    
    def __init__ (self):

        self.groupedMenus = []
            # Set in rf.createRecentFilesMenuItems.
        self.recentFiles = []
            # List of g.Bunches describing .leoRecentFiles.txt files.
        self.recentFileMessageWritten = False
            # To suppress all but the first message.
        self.write_recent_files_as_needed = False
            # Will be set later.

    @others
#@+node:ekr.20041201080436: *6* rf.appendToRecentFiles
def appendToRecentFiles (self,files):
    
    rf = self

    files = [theFile.strip() for theFile in files]

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for name in files:
        # Remove all variants of name.
        for name2 in rf.recentFiles[:]:
            if munge(name) == munge(name2):
                rf.recentFiles.remove(name2)

        rf.recentFiles.append(name)
#@+node:ekr.20120225072226.10289: *6* rf.cleanRecentFiles
def cleanRecentFiles(self,c):
    
    '''Removed items from the recent files list that are no longer valid.'''
    
    rf = self

    dat = c.config.getData('path-demangle')
    if not dat:
        g.es('No @data path-demangle setting')
        return

    changes = []
    replace = None
    for line in dat:
        text = line.strip()
        if text.startswith('REPLACE: '):
            replace = text.split(None, 1)[1].strip()
        if text.startswith('WITH:') and replace is not None:
            with_ = text[5:].strip()
            changes.append((replace, with_))
            g.es('%s -> %s' % changes[-1])

    orig = [z for z in rf.recentFiles if z.startswith("/")]
    
    rf.recentFiles = []

    for i in orig:
        t = i
        for change in changes:
            t = t.replace(*change)
        rf.updateRecentFiles(t)

    rf.writeRecentFilesFile(c,force=True)
        # Force the write message.
#@+node:ekr.20120225072226.10297: *6* rf.clearRecentFiles
def clearRecentFiles (self,c):

    """Clear the recent files list, then add the present file."""

    rf = self ; u = c.undoer ; menu = c.frame.menu
    
    bunch = u.beforeClearRecentFiles()

    recentFilesMenu = menu.getMenu("Recent Files...")
    menu.deleteRecentFilesMenuItems(recentFilesMenu)

    rf.recentFiles = [c.fileName()]
    for frame in g.app.windowList:
        rf.createRecentFilesMenuItems(frame.c)

    u.afterClearRecentFiles(bunch)

    # Write the file immediately.
    rf.writeRecentFilesFile(c,force=True)
        # Force the write message.
#@+node:ekr.20120225072226.10301: *6* rf.createRecentFilesMenuItems
def createRecentFilesMenuItems (self,c):
    
    rf = self
    menu = c.frame.menu

    recentFilesMenu = menu.getMenu("Recent Files...")

    if not recentFilesMenu and not g.unitTesting:
        g.trace('Recent Files Menu does not exist',g.callers())
        return
        
    # Delete all previous entries.
    menu.deleteRecentFilesMenuItems(recentFilesMenu)

    # Create the permanent (static) menu entries.
    table = rf.getRecentFilesTable()
    menu.createMenuEntries(recentFilesMenu,table)

    # Create all the other entries (a maximum of 36).
    accel_ch = string.digits + string.ascii_uppercase # Not a unicode problem.
    i = 0
    n = len(accel_ch)

    # see if we're grouping when files occur in more than one place
    rf_group = c.config.getBool("recent_files_group")
    rf_always = c.config.getBool("recent_files_group_always")
    groupedEntries = rf_group or rf_always

    if groupedEntries:  # if so, make dict of groups
        dirCount = {}
        for fileName in rf.getRecentFiles()[:n]:
            dirName, baseName = g.os_path_split(fileName)
            if baseName not in dirCount:
                dirCount[baseName] = {'dirs':[], 'entry': None}
            dirCount[baseName]['dirs'].append(dirName)

    for name in rf.getRecentFiles()[:n]:
        if name.strip() == "":
            continue  # happens with empty list/new file

        def recentFilesCallback (event=None,c=c,name=name):
            c.openRecentFile(name)

        if groupedEntries:
            dirName, baseName = g.os_path_split(name)

            entry = dirCount[baseName]

            if len(entry['dirs']) > 1 or rf_always:  # sub menus
                if entry['entry'] is None:
                    entry['entry'] = menu.createNewMenu(baseName, "Recent Files...")
                    # acts as a flag for the need to create the menu
                c.add_command(menu.getMenu(baseName), label=dirName,
                    command=recentFilesCallback, underline=0)
            else:  # single occurence, no submenu
                c.add_command(recentFilesMenu,label=baseName,
                    command=recentFilesCallback,underline=0)

        else:  # original behavior
            label = "%s %s" % (accel_ch[i],g.computeWindowTitle(name))
            c.add_command(recentFilesMenu,label=label,
                command=recentFilesCallback,underline=0)
        i += 1

    if groupedEntries:  # store so we can delete them later
        rf.groupedMenus = [i for i in dirCount
            if dirCount[i]['entry'] is not None]
#@+node:ekr.20120225072226.10286: *6* rf.getRecentFiles
def getRecentFiles (self):
    
    return self.recentFiles
#@+node:ekr.20120225072226.10304: *6* rf.getRecentFilesTable
def getRecentFilesTable (self):
    
    return (
        "*clear-recent-files",
        "*clean-recent-files",
        "*sort-recent-files",
        # ("-",None,None),
    )
#@+node:ekr.20070224115832: *6* rf.readRecentFiles & helpers
def readRecentFiles (self,localConfigFile):

    '''Read all .leoRecentFiles.txt files.'''

    # The order of files in this list affects the order of the recent files list.
    rf = self
    seen = [] 
    localConfigPath = g.os_path_dirname(localConfigFile)

    for path in (
        g.app.homeLeoDir,
        g.app.globalConfigDir,
        localConfigPath,
    ):
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
        if path and path not in seen:
            ok = rf.readRecentFilesFile(path)
            if ok: seen.append(path)

    if not seen and rf.write_recent_files_as_needed:
        rf.createRecentFiles()
#@+node:ekr.20061010121944: *7* rf.createRecentFiles
def createRecentFiles (self):

    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeLeoDir,g.app.globalConfigDir):
        if theDir:
            try:
                fn = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = open(fn,'w')
                f.close()
                g.es_print('created',fn,color='red')
                return
            except Exception:
                g.es_print('can not create',fn,color='red')
                g.es_exception()
#@+node:ekr.20050424115658: *7* rf.readRecentFilesFile
def readRecentFilesFile (self,path):

    trace = False and not g.unitTesting
    rf = self
    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
        try:
            if g.isPython3:
                f = open(fileName,encoding='utf-8',mode='r')
            else:
                f = open(fileName,'r')
        except IOError:
            g.trace('can not open',fileName)
            return False

        if trace: g.trace(('reading %s' % fileName))
        lines = f.readlines()
        if lines and rf.sanitize(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line)) for line in lines]
            rf.appendToRecentFiles(lines)

    return ok
#@+node:ekr.20120225072226.10285: *6* rf.sanitize
def sanitize (self,name):
    
    '''Return a sanitized file name.'''

    if name is None:
        return None

    name = name.lower()
    for ch in ('-','_',' ','\n'):
        name = name.replace(ch,'')

    return name or None
#@+node:ekr.20120215072959.12478: *6* rf.setRecentFiles
def setRecentFiles (self,files):
    
    '''Update the recent files list.'''
    
    rf = self
    rf.appendToRecentFiles(files)
#@+node:ekr.20120225072226.10293: *6* rf.sortRecentFiles
def sortRecentFiles(self,c):
    
    '''Sort the recent files list.'''

    rf = self

    aList = rf.recentFiles
    aList.sort(key=lambda s: g.os_path_basename(s).lower()) 
    aList.reverse()

    rf.recentFiles = []
    for z in aList:
        rf.updateRecentFiles(z)

    rf.writeRecentFilesFile(c,force=True)
        # Force the write message.
#@+node:ekr.20031218072017.2083: *6* rf.updateRecentFiles
def updateRecentFiles (self,fileName):

    """Create the RecentFiles menu.  May be called with Null fileName."""

    rf = self

    if g.app.unitTesting: return

    def munge(name):
        return g.os_path_finalize(name or '').lower()
    def munge2(name):
        return g.os_path_finalize_join(g.app.loadDir,name or '')

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        for frame in g.app.windowList:
            # Remove all versions of the file name.
            for name in rf.recentFiles:
                if (munge(fileName) == munge(name) or
                    munge2(fileName) == munge2(name)
                ):
                    rf.recentFiles.remove(name)
            rf.recentFiles.insert(0,fileName)
            # Recreate the Recent Files menu.
            rf.createRecentFilesMenuItems(frame.c)
    else:
        for frame in g.app.windowList:
            rf.createRecentFilesMenuItems(frame.c)
#@+node:ekr.20050424114937.2: *6* rf.writeRecentFilesFile & helper
def writeRecentFilesFile (self,c,force=False):

    '''Write the appropriate .leoRecentFiles.txt file.
    
    Write a message if force is True, or if it hasn't been written yet.'''

    tag = '.leoRecentFiles.txt'
    rf = self
    if g.app.unitTesting:
        return

    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None

    written = False
    seen = []
    for path in (localPath,g.app.globalConfigDir,g.app.homeLeoDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName) and not fileName.lower() in seen:
                seen.append(fileName.lower())
                ok = rf.writeRecentFilesFileHelper(fileName)
                if force or not rf.recentFileMessageWritten:
                    if ok:
                        g.pr('wrote recent file: %s' % fileName)
                        written = True
                    else:
                        g.pr('failed to recent file: %s' % (fileName),color='red')
                # Bug fix: Leo 4.4.6: write *all* recent files.

    if written:
        rf.recentFileMessageWritten = True
    else:
        pass # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
#@+node:ekr.20050424131051: *7* rf.writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):

    # g.trace(g.toUnicode(fileName))

    # Don't update the file if it begins with read-only.
    rf = self
    theFile = None
    try:
        theFile = open(fileName)
        lines = theFile.readlines()
        if lines and rf.sanitize(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return False
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        if g.isPython3:
            theFile = open(fileName,encoding='utf-8',mode='w')
        else:
            theFile = open(fileName,mode='w')
        if rf.recentFiles:
            s = '\n'.join(rf.recentFiles)
        else:
            s = '\n'
        if not g.isPython3:
            s = g.toEncodedString(s,reportErrors=True)
        theFile.write(s)

    except IOError:
        if 1: # The user may have erased a file.  Not an error.
            g.es_print('error writing',fileName,color='red')
            g.es_exception()
            return False

    except Exception:
        g.es('unexpected exception writing',fileName,color='red')
        g.es_exception()
        if g.unitTesting: raise
        return False

    if theFile:
        theFile.close()
        return True
    else:
        return False
#@+node:ekr.20120225062633.10162: *4* Fixed the wretched scrolling bug
@nocolor-node

What I did:
    
1. Enabled see, seeInsertPoint, get/setYScrollPosition.

2. (The fix): save/restore YScroll position in body.setSelectionAreas.

3. Added g.trace_see: g.trace_scroll already existed.

Failure case 1:
    - Search for something.
    - Manually scroll the pane.
    - Click scrolls the pane again.
    
Failure case 2:
    - reformat-paragraph.
#@+node:ekr.20120225062633.10161: *5* Found: .see
#@+node:ekr.20111123030145.10211: *6* Notes
@nocolor-node

Methods relating to this problem:

g.trace_scroll
w.see
w.seeInsertPoint
w.get/setYScrollPosition
p.restoreCursorAndScroll
v.restoreCursorAndScroll

leoKeyHandler:
    k.keykBoardQuit
    k.showStateAndMode
    k.setLabel
        ***** calls w.widget.ensureCursorVisible

leoQtBody:
    onFocusColorHelper
        ***** calls w.widget.ensureCursorVisible
        
leoQtBaseTextWidget:
    mouseReleaseEvent
        Added code that didn't work: now commented out.
        
leoEditCommands:
    updateAutoIndent
        ***** calls w.seeInsertPoint
#@+node:ekr.20111001155050.15480: *7* First attempt
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/de76f22b16ebc8f

As explained in detail in the thread, "dangerous" code is no longer executed immediately,
but instead executed at idle time using g.app.gui.runAtIdle.
#@+node:ekr.20111121084517.10189: *6* Removed all calls to w.see, w.seeInsertPoint, w.setYScrollPosition
# See "Scrolling bug" notes.
#@+node:ekr.20110605121601.18090: *7* see & seeInsertPoint (leoQTextEditWidget)
def see(self,i):
    
    if g.trace_see and not g.unitTesting:
        print('leoQTextEditWidget.see (ensureCursorVisible)')

    if 1: # Disabled 2011/12/21, enabled 2012/02/26
        self.widget.ensureCursorVisible()

def seeInsertPoint (self):
    
    if g.trace_see and not g.unitTesting:
        print('leoQTextEditWidget.seeInsertPoint')

    if 1: # Disabled 2011/12/21, enabled 2012/02/26
        self.widget.ensureCursorVisible()
#@+node:ekr.20111002125540.7021: *7* get/setYScrollPosition (LeoQTextBrowser)
def getYScrollPosition(self):
    
    trace = g.trace_scroll and not g.unitTesting
    w = self
    sb = w.verticalScrollBar()
    i = sb.sliderPosition()
    
    if trace:
        print('leoQTextBrowser.getYScrollPosition %s' % i)
    return i

def setYScrollPosition(self,pos):
    
    trace = g.trace_scroll and not g.unitTesting
    print('leoQTextBrowser.setYScrollPosition %s' % pos)

    if 1: # disabled 2011/12/21, restored 2012/02/25
        w = self
        sb = w.verticalScrollBar()
        if pos is None: pos = 0
        sb.setSliderPosition(pos)
#@+node:ekr.20110605121601.18098: *7* setYScrollPosition (leoQTextEditWidget)
def setYScrollPosition(self,pos):
    
    trace = g.trace_scroll and not g.unitTesting   
    if trace: print(
        'leoQTextEditWidget.setYScrollPosition %s' % (pos))

    if 1: # disabled 2011/12/21, enabled 2012/02/25
        w = self.widget
        sb = w.verticalScrollBar()
        sb.setSliderPosition(pos)
#@+node:ekr.20111114102224.9937: *6* immutable redirection methods (HighLevelInterface)
def appendText(self,s):
    if self.widget: self.widget.appendText(s)
def delete(self,i,j=None):
    if self.widget: self.widget.delete(i,j)
def deleteTextSelection (self):
    if self.widget: self.widget.deleteTextSelection()
def get(self,i,j):
    return self.widget and self.widget.get(i,j) or ''
def getAllText(self):
    return self.widget and self.widget.getAllText() or ''
def getInsertPoint(self):
    return self.widget and self.widget.getInsertPoint() or 0
def getSelectedText(self):
    return self.widget and self.widget.getSelectedText() or ''
def getSelectionRange (self):
    return self.widget and self.widget.getSelectionRange() or (0,0)
def getYScrollPosition (self):
    return self.widget and self.widget.getYScrollPosition() or 0
def hasSelection(self):
    # Take special care with this, for the benefit of LeoQuickSearchWidget.
    # This problem only happens with the qttabs gui.
    w = self.widget
    return bool(w and hasattr(w,'hasSelection') and w.hasSelection())
def insert(self,i,s):
    if self.widget: self.widget.insert(i,s)    
def replace (self,i,j,s):
    if self.widget: self.widget.replace(i,j,s)
def see(self,i):
    if self.widget: self.widget.see(i)
def seeInsertPoint (self):
    if self.widget: self.widget.seeInsertPoint()
def selectAllText (self,insert=None):
    if self.widget: self.widget.selectAllText(insert)
def setAllText (self,s):
    if self.widget: self.widget.setAllText(s)
def setBackgroundColor(self,color):
    if self.widget: self.widget.setBackgroundColor(color)
def setFocus(self):
    if self.widget: self.widget.setFocus()
def setForegroundColor(self,color):
    if self.widget: self.widget.setForegroundColor(color)
def setInsertPoint(self,pos):
    if self.widget: self.widget.setInsertPoint(pos)
def setSelectionRange (self,i,j,insert=None):
    if self.widget: self.widget.setSelectionRange(i,j,insert=insert)
def setYScrollPosition (self,i):
    if self.widget: self.widget.setYScrollPosition(i)
def tag_configure (self,colorName,**keys):
    if self.widget: self.widget.tag_configure(colorName,**keys)
#@+node:ekr.20031218072017.1827: *6* c.findMatchingBracket, helper and test
def findMatchingBracket (self,event=None):

    '''Select the text between matching brackets.'''

    c = self ; w = c.frame.body.bodyCtrl

    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}<>"
    s = w.getAllText()
    ins = w.getInsertPoint()
    ch1 = 0 <= ins-1 < len(s) and s[ins-1] or ''
    ch2 = 0 <= ins   < len(s) and s[ins] or ''
    # g.trace(repr(ch1),repr(ch2),ins)

    # Prefer to match the character to the left of the cursor.
    if ch1 and ch1 in brackets:
        ch = ch1 ; index = max(0,ins-1)
    elif ch2 and ch2 in brackets:
        ch = ch2 ; index = ins
    else:
        return

    index2 = self.findMatchingBracketHelper(s,ch,index)
    # g.trace('index,index2',index,index2)
    if index2 is not None:
        if index2 < index:
            w.setSelectionRange(index2,index+1,insert=index2) # was insert=index2+1
            # g.trace('case 1',s[index2:index+1])
        else:
            w.setSelectionRange(index,index2+1,insert=min(len(s),index2+1))
            # g.trace('case2',s[index:index2+1])
        w.see(index2)
    else:
        g.es("unmatched",repr(ch))
#@+node:ekr.20061113221414: *7* findMatchingBracketHelper
# To do: replace comments with blanks before scanning.
# Test  unmatched())
def findMatchingBracketHelper(self,s,ch,index):

    c = self
    open_brackets  = "([{<" ; close_brackets = ")]}>"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    # g.trace('index',index,'ch',repr(ch),'brackets',brackets)
    for n in range(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    else:
        return None
    # g.trace('index',index,'ch',repr(ch),'match_ch',repr(match_ch))
    level = 0
    while 1:
        if forward and index >= len(s):
            # g.trace("not found")
            return None
        ch2 = 0 <= index < len(s) and s[index] or ''
        # g.trace('forward',forward,'ch2',repr(ch2),'index',index)
        if ch2 == ch:
            level += 1
        if ch2 == match_ch:
            level -= 1
            if level <= 0:
                return index
        if not forward and index <= 0:
            # g.trace("not found")
            return None
        index += g.choose(forward,1,-1)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched
#@+node:ekr.20101118113953.5842: *6* rp_reformat
def rp_reformat (self,head,oldSel,oldYview,original,result,tail,undoType):

    '''Reformat the body and update the selection.'''

    c = self ; body = c.frame.body ; w = body.bodyCtrl
    s = w.getAllText()

    # This destroys recoloring.
    junk, ins = body.setSelectionAreas(head,result,tail)

    changed = original != head + result + tail
    if changed:
        # 2010/11/16: stay in the paragraph.
        body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)
    else:
        # Advance to the next paragraph.
        ins += 1 # Move past the selection.
        while ins < len(s):
            i,j = g.getLine(s,ins)
            line = s[i:j]
            # 2010/11/16: it's annoying, imo, to treat @ lines differently.
            if line.isspace():
                ins = j+1
            else:
                ins = i ; break

        # setSelectionAreas has destroyed the coloring.
        c.recolor()

    w.setSelectionRange(ins,ins,insert=ins)
    
    # 2011/10/26: Calling see does more harm than good.
        # w.see(ins)
#@+node:ekr.20110916215321.6708: *6* selectToMatchingBracket (leoEditCommands)
def selectToMatchingBracket (self,event):
    
    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return
    
    i = w.getInsertPoint()
    s = w.getAllText()
    
    allBrackets = self.openBracketsList + self.closeBracketsList
    
    if i < len(s) and s[i] in allBrackets:
        ch = s[i]
    elif i > 0 and s[i-1] in allBrackets:
        i -= 1
        ch = s[i]
    else:
        g.es('no bracket selected')
        return

    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)
    
    # This should be generalized...
    language = g.findLanguageDirectives(c,c.p)
    if language in ('c','cpp','csharp'):
        j = g.skip_matching_c_delims(s,i,ch,delim2,reverse=reverse)
    else:
        j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    # g.trace(i,j,ch,delim2,reverse,language)
    if j not in (-1,i):
        if reverse:
            i += 1; j += 1
        w.setSelectionRange(i,j,insert=j)
            # 2011/11/21: Bug fix: was ins=j.
        w.see(j)
#@+node:ekr.20051025071455.40: *6* find & helpers
def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; w = body.bodyCtrl

    # Reload the work pane from the present node.
    s = w.getAllText().rstrip()
    self.workCtrl.delete(0,"end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = w.getInsertPoint()
    self.workCtrl.setInsertPoint(ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        # Save the selection range.
        ins = w.getInsertPoint()
        i,j = w.getSelectionRange()
        self.tab.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocus()
        # Restore the selection range.
        w.setSelectionRange(i,j,insert=ins)
        w.see(ins)
    else:
        g.es("no more misspellings")
        self.tab.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocus()
#@+node:ekr.20051025071455.45: *7* findNextMisspelledWord
def findNextMisspelledWord(self):
    """Find the next unknown word."""

    trace = False and not g.unitTesting
    c = self.c ; p = c.p
    w = c.frame.body.bodyCtrl
    sc = self.spellController
    alts = None ; word = None
    try:
        while 1:
            i,j,p,word = self.findNextWord(p)
            # g.trace(i,j,p and p.h or '<no p>')
            if not p or not word:
                alts = None
                break
            alts = sc.processWord(word)
            if trace: g.trace('alts',alts and len(alts) or 0,i,j,word,p and p.h or 'None')
            if alts:
                redraw = not p.isVisible(c)
                # New in Leo 4.4.8: show only the 'sparse' tree when redrawing.
                if c.sparse_spell and not c.p.isAncestorOf(p):
                    for p2 in c.p.self_and_parents():
                        p2.contract()
                        redraw = True
                for p2 in p.parents():
                    if not p2.isExpanded():
                        p2.expand()
                        redraw = True
                if redraw:
                    c.redraw(p)
                else:
                    c.selectPosition(p)
                w.setSelectionRange(i,j,insert=j)
                break
    except Exception:
        g.es_exception()
    return alts, word
#@+node:ekr.20051025071455.47: *7* findNextWord (spellTab)
def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    trace = False and not g.unitTesting
    c = self.c ; p = p.copy()
    while 1:
        s = self.workCtrl.getAllText()
        i = self.workCtrl.getInsertPoint()
        while i < len(s) and not g.isWordChar1(s[i]):
            i += 1
        # g.trace('p',p and p.h,'i',i,'len(s)',len(s))
        if i < len(s):
            # A non-empty word has been found.
            j = i
            while j < len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # This trace verifies that all words have been checked.
            # g.trace(repr(word))
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(i,j,insert=j)
            if trace: g.trace(i,j,word,p.h)
            return i,j,p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            self.workCtrl.delete(0,'end')
            self.workCtrl.insert(0,p.b)
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(0,0,insert=0)
            if trace: g.trace(0,0,'-->',p.h)

    return None,None,None,None
#@+node:ekr.20060528110922: *6* << create text widget w >> leoBody.addEditor
w = self.createTextWidget(f,name=name,p=p)
w.delete(0,'end')
w.insert('end',p.b)
w.see(0)

self.setFontFromConfig(w=w)
self.setColorFromConfig(w=w)
self.createBindings(w=w)
c.k.completeAllBindingsForWidget(w)

self.recolorWidget(p,w)
#@+node:ekr.20070130115927.7: *6* leoFrame.pasteText
def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    trace = False and not g.unitTesting
    f = self ; c = f.c
    w = event and event.widget
    wname = (w and c.widget_name(w)) or '<no widget>'
    if trace: g.trace(g.app.gui.isTextWidget(w),w)
    if not w or not g.app.gui.isTextWidget(w): return

    i,j = oldSel = w.getSelectionRange()  # Returns insert point if no selection.
    oldText = w.getAllText()

    if middleButton and c.k.previousSelection is not None:
        start,end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()

    s = g.toUnicode(s)

    # g.trace('pasteText','wname',wname,'s',s,g.callers())

    singleLine = wname.startswith('head') or wname.startswith('minibuffer')

    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    if 1: # Was a try.
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)
        w.see(i+len(s) + 2) # 2011/06/01

        if wname.startswith('body'):
            c.frame.body.forceFullRecolor()
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.getAllText()
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            # 2011/11/14: headline width methods do nothing at present.
            # if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                # width = f.tree.headWidth(p=None,s=s)
                # w.setWidth(width)
        else: pass

    return

OnPasteFromMenu = pasteText
#@+node:ekr.20110605121601.18050: *6* HighLevelInterface (leoQtBaseTextWidget)
# Do not delete.
# The redirection methods of HighLevelInterface redirect calls
# from leoBody & leoLog to *this* class.

# Essential methods...
def getName (self):
    return self.name

# Optional methods...
def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75):
    pass

def getYScrollPosition(self):           return None # A flag
def seeInsertPoint (self):              self.see(self.getInsertPoint())
def setBackgroundColor(self,color):     pass
def setEditorColors (self,bg,fg):       pass
def setForegroundColor(self,color):     pass
def setYScrollPosition(self,pos):       pass

# Must be defined in subclasses.
def getAllText(self):                           self.oops()
def getInsertPoint(self):                       self.oops()
def getSelectionRange(self,sort=True):          self.oops()
def hasSelection(self):                         self.oops()
def see(self,i):                                self.oops()
def setAllText(self,s,insert=None,new_p=None):  self.oops()
def setInsertPoint(self,i):                     self.oops()
#@+node:ekr.20110605121601.18056: *7* tag_configure (leoQtBaseTextWidget)
def tag_configure (self,*args,**keys):

    trace = False and not g.unitTesting
    if trace: g.trace(args,keys)

    if len(args) == 1:
        key = args[0]
        self.tags[key] = keys
        val = keys.get('foreground')
        underline = keys.get('underline')
        if val:
            # if trace: g.trace(key,val)
            self.configDict [key] = val
        if underline:
            self.configUnderlineDict [key] = True
    else:
        g.trace('oops',args,keys)

tag_config = tag_configure
#@+node:ekr.20110605121601.18191: *6* High-level interface (qtBody)
# The required high-level interface.
def appendText (self,s):                return self.widget.appendText(s)
def clipboard_append(self,s):           return self.widget.clipboard_append(s)
def clipboard_clear(self):              return self.widget.clipboard_append()
def delete(self,i,j=None):              self.widget.delete(i,j)
def deleteTextSelection (self):         return self.widget.deleteTextSelection()
def flashCharacter(self,i,
    bg='white',fg='red',
    flashes=3,delay=75):                return self.widget(i,bg,fg,flashes,delay)
def get(self,i,j=None):                 return self.widget.get(i,j)
def getAllText (self):                  return self.widget.getAllText()
def getFocus (self):                    return self.widget.getFocus()
def getInsertPoint(self):               return self.widget.getInsertPoint()
def getSelectedText (self):             return self.widget.getSelectedText()
def getSelectionRange(self):            return self.widget.getSelectionRange()
def getYScrollPosition (self):          return self.widget.getYScrollPosition()
def hasSelection (self):                return self.widget.hasSelection()
def insert(self,i,s):                   return self.widget.insert(i,s)
def replace (self,i,j,s):               self.widget.replace (i,j,s)
def rowColToGuiIndex (self,s,row,col):  return self.widget.rowColToGuiIndex(s,row,col)
def see(self,index):                    return self.widget.see(index)
def seeInsertPoint(self):               return self.widget.seeInsertPoint()
def selectAllText (self,insert=None):   self.widget.selectAllText(insert)
def setAllText (self,s,new_p=None):     return self.widget.setAllText(s,new_p=new_p)
def setBackgroundColor (self,color):    return self.widget.setBackgroundColor(color)
def setFocus (self):                    return self.widget.setFocus()
def setForegroundColor (self,color):    return self.widget.setForegroundColor(color)
def setInsertPoint (self,pos):          return self.widget.setInsertPoint(pos)
def setSelectionRange (self,i,j,insert=None):
    self.widget.setSelectionRange(i,j,insert=insert)
def setYScrollPosition (self,i):        return self.widget.setYScrollPosition(i)
def tag_configure(self,colorName,**keys):pass
def toPythonIndex(self,index):          return self.widget.toPythonIndex(index)
def toPythonIndexRowCol(self,index):    return self.widget.toPythonIndexRowCol(index)

set_focus = setFocus
toGuiIndex = toPythonIndex
#@+node:ekr.20110605121601.18196: *6* createEditor (qtBody)
def createEditor (self,name):

    c = self.c ; p = c.p
    f = c.frame.top.leo_ui.leo_body_inner_frame
        # Valid regardless of qtGui.useUI
    n = self.numberOfEditors

    # Step 1: create the editor.
    # w = QtGui.QTextBrowser(f)
    w = LeoQTextBrowser(f,c,self)
    w.setObjectName('richTextEdit') # Will be changed later.
    wrapper = leoQTextEditWidget(w,name='body',c=c)
    self.packLabel(w)

    # Step 2: inject ivars, set bindings, etc.
    self.injectIvars(f,name,p,wrapper)
    self.updateInjectedIvars(w,p)
    wrapper.setAllText(p.b)
    wrapper.see(0)
    self.createBindings(w=wrapper)
    c.k.completeAllBindingsForWidget(wrapper)
    self.recolorWidget(p,wrapper)

    return f,wrapper
#@+node:ekr.20120225062633.10163: *5* trace_scroll
#@+node:ekr.20120212060348.10374: *6*  << global switches >>
trace_startup = False
    # These traces use print instead of g.trace so that
    # the traces can add class info the method name.

new_modes = False
    # True: use ModeController and ModeInfo classes.
if new_modes: print('***** new_modes')

new_keys = False
    # This project hardly seems urgent.
    # True: Qt input methods produce a **user setting**, not a stroke.
if new_keys: print('***** new_keys')

# Traces of scrolling problems.
trace_scroll = False
    # Trace calls to get/setYScrollPosition
trace_see = False
    # Trace calls to see and setInsertPoint.

# Switches to trace the garbage collector.
trace_gc = False           
trace_gc_calls = False    
trace_gc_calls = False 
trace_gc_verbose = False
trace_gc_inited = False

trace_masterCommand = False
trace_masterKeyHandler = False
trace_masterKeyHandlerGC = False
trace_minibuffer = False
trace_modes = False

enableDB = True
    # Don't even think about eliminating this constant:
    # it is needed for debugging.
    
# These print statements have been moved to writeWaitingLog.
# This allows for better --silent operation.
if 0:
    print('*** isPython3: %s' % isPython3)
    if not enableDB:
        print('** leoGlobals.py: caching disabled')
#@+node:ekr.20111002125540.7021: *6* get/setYScrollPosition (LeoQTextBrowser)
def getYScrollPosition(self):
    
    trace = g.trace_scroll and not g.unitTesting
    w = self
    sb = w.verticalScrollBar()
    i = sb.sliderPosition()
    
    if trace:
        print('leoQTextBrowser.getYScrollPosition %s' % i)
    return i

def setYScrollPosition(self,pos):
    
    trace = g.trace_scroll and not g.unitTesting
    print('leoQTextBrowser.setYScrollPosition %s' % pos)

    if 1: # disabled 2011/12/21, restored 2012/02/25
        w = self
        sb = w.verticalScrollBar()
        if pos is None: pos = 0
        sb.setSliderPosition(pos)
#@+node:ekr.20110605121601.18090: *6* see & seeInsertPoint (leoQTextEditWidget)
def see(self,i):
    
    if g.trace_see and not g.unitTesting:
        print('leoQTextEditWidget.see (ensureCursorVisible)')

    if 1: # Disabled 2011/12/21, enabled 2012/02/26
        self.widget.ensureCursorVisible()

def seeInsertPoint (self):
    
    if g.trace_see and not g.unitTesting:
        print('leoQTextEditWidget.seeInsertPoint')

    if 1: # Disabled 2011/12/21, enabled 2012/02/26
        self.widget.ensureCursorVisible()
#@+node:ekr.20110605121601.18095: *6* setInsertPoint (leoQTextEditWidget)
def setInsertPoint(self,i):
    
    trace = g.trace_scroll and not g.unitTesting
    if trace: print('leoQTextEditWidget.setInsertPoint %s' % i)
    
    w = self.widget
    s = w.toPlainText()
    i = self.toPythonIndex(i)
    i = max(0,min(i,len(s)))
    cursor = w.textCursor()
    cursor.setPosition(i)
    w.setTextCursor(cursor)
#@+node:ekr.20110605121601.18096: *6* setSelectionRangeHelper & helper (leoQTextEditWidget)
def setSelectionRangeHelper(self,i,j,insert=None):

    trace = g.trace_scroll and not g.unitTesting
    w = self.widget
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)

    n = self.lengthHelper()
    i = max(0,min(i,n))
    j = max(0,min(j,n))
    if insert is None:
        ins = max(i,j)
    else:
        ins = self.toPythonIndex(insert)
        ins = max(0,min(ins,n))

    if trace: print(
        'leoQTextEditWidget.setSelectionRangeHelper %s %s %s' % (
            i,j,insert),g.callers())

    # 2010/02/02: Use only tc.setPosition here.
    # Using tc.movePosition doesn't work.
    tc = w.textCursor()
    if i == j:
        tc.setPosition(i)
    elif ins == j:
        # Put the insert point at j
        tc.setPosition(i)
        tc.setPosition(j,tc.KeepAnchor)
    else:
        # Put the insert point a i
        tc.setPosition(j)
        tc.setPosition(i,tc.KeepAnchor)

    w.setTextCursor(tc)
#@+node:ekr.20110605121601.18097: *7* lengthHelper
def lengthHelper(self):

    '''Return the length of the text.'''

    w = self.widget
    tc = w.textCursor()
    tc.movePosition(QtGui.QTextCursor.End)
    n = tc.position()
    return n

#@+node:ekr.20110605121601.18098: *6* setYScrollPosition (leoQTextEditWidget)
def setYScrollPosition(self,pos):
    
    trace = g.trace_scroll and not g.unitTesting   
    if trace: print(
        'leoQTextEditWidget.setYScrollPosition %s' % (pos))

    if 1: # disabled 2011/12/21, enabled 2012/02/25
        w = self.widget
        sb = w.verticalScrollBar()
        sb.setSliderPosition(pos)
#@+node:ekr.20100303074003.5636: *6* v.restoreCursorAndScroll
# Called only by setBodyTextAfterSelect.

def restoreCursorAndScroll (self,w):

    trace = g.trace_scroll and not g.unitTesting
    v = self
    spot = v and v.insertSpot or 0
    w.setInsertPoint(spot)
        
    # 2011/10/26: *only* restore the scrollbar setting.  Do not call see.
    if v and v.scrollBarSpot != None:
        pos = v.scrollBarSpot
        if trace: print('v.restoreCursorAndScroll %s' % pos)
        w.setYScrollPosition(pos)
        
    # Never call w.see here.

#@+node:ekr.20101118113953.5839: *5* c.reformatParagraph & helpers
def reformatParagraph (self,event=None,undoType='Reformat Paragraph'):

    """Reformat a text paragraph

    Wraps the concatenated text to present page width setting. Leading tabs are
    sized to present tab width setting. First and second line of original text is
    used to determine leading whitespace in reformatted text. Hanging indentation
    is honored.

    Paragraph is bound by start of body, end of body and blank lines. Paragraph is
    selected by position of current insertion cursor.

"""

    c = self ; body = c.frame.body ; w = body.bodyCtrl
    
    # g.trace(c.page_width)

    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasSelection():
        i,j = w.getSelectionRange()
        w.setInsertPoint(i)

    oldSel,oldYview,original,pageWidth,tabWidth = c.rp_get_args()
    head,lines,tail = c.findBoundParagraph()
    if lines:
        indents,leading_ws = c.rp_get_leading_ws(lines,tabWidth)
        result = c.rp_wrap_all_lines(indents,leading_ws,lines,pageWidth)
        c.rp_reformat(head,oldSel,oldYview,original,result,tail,undoType)
#@+node:ekr.20031218072017.1825: *6* c.findBoundParagraph
def findBoundParagraph (self,event=None):

    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None

    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        << trace head_lines, ins, tail_lines >>

    # Scan backwards.
    i = len(head_lines)
    while i > 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    for line in tail_lines:
        if not line or line.isspace() or line.startswith('@'):
            break
        i += 1

    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]

    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    return head,result,tail # string, list, string
#@+node:ekr.20031218072017.1826: *7* << trace head_lines, ins, tail_lines >>
if 0:
    g.pr("\nhead_lines")
    for line in head_lines:
        g.pr(line)
    g.pr("\nins", ins)
    g.pr("\ntail_lines")
    for line in tail_lines:
        g.pr(line)
else:
    g.es_print("head_lines: ",head_lines)
    g.es_print("ins: ",ins)
    g.es_print("tail_lines: ",tail_lines)
#@+node:ekr.20101118113953.5840: *6* rp_get_args
def rp_get_args (self):

    '''Compute and return oldSel,oldYview,original,pageWidth,tabWidth.'''

    c = self ; body = c.frame.body ;  w = body.bodyCtrl

    d = c.scanAllDirectives()
    
    # g.trace(c.editCommands.fillColumn)

    if c.editCommands.fillColumn > 0:
        pageWidth = c.editCommands.fillColumn
    else:
        pageWidth = d.get("pagewidth")
        
    tabWidth  = d.get("tabwidth")
    original = w.getAllText()
    oldSel =  w.getSelectionRange()
    oldYview = body.getYScrollPosition()

    return oldSel,oldYview,original,pageWidth,tabWidth
#@+node:ekr.20101118113953.5841: *6* rp_get_leading_ws
def rp_get_leading_ws (self,lines,tabWidth):

    '''Compute and return indents and leading_ws.'''

    c = self

    indents = [0,0]
    leading_ws = ["",""]

    for i in (0,1):
        if i < len(lines):
            # Use the original, non-optimized leading whitespace.
            leading_ws[i] = ws = g.get_leading_ws(lines[i])
            indents[i] = g.computeWidth(ws,tabWidth)

    indents[1] = max(indents)

    if len(lines) == 1:
        leading_ws[1] = leading_ws[0]

    return indents,leading_ws
#@+node:ekr.20101118113953.5842: *6* rp_reformat
def rp_reformat (self,head,oldSel,oldYview,original,result,tail,undoType):

    '''Reformat the body and update the selection.'''

    c = self ; body = c.frame.body ; w = body.bodyCtrl
    s = w.getAllText()

    # This destroys recoloring.
    junk, ins = body.setSelectionAreas(head,result,tail)

    changed = original != head + result + tail
    if changed:
        # 2010/11/16: stay in the paragraph.
        body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)
    else:
        # Advance to the next paragraph.
        ins += 1 # Move past the selection.
        while ins < len(s):
            i,j = g.getLine(s,ins)
            line = s[i:j]
            # 2010/11/16: it's annoying, imo, to treat @ lines differently.
            if line.isspace():
                ins = j+1
            else:
                ins = i ; break

        # setSelectionAreas has destroyed the coloring.
        c.recolor()

    w.setSelectionRange(ins,ins,insert=ins)
    
    # 2011/10/26: Calling see does more harm than good.
        # w.see(ins)
#@+node:ekr.20101118113953.5843: *6* rp_wrap_all_lines
def rp_wrap_all_lines (self,indents,leading_ws,lines,pageWidth):

    '''compute the result of wrapping all lines.'''

    trailingNL = lines and lines[-1].endswith('\n')
    lines = [g.choose(z.endswith('\n'),z[:-1],z) for z in lines]

    # Wrap the lines, decreasing the page width by indent.
    result = g.wrap_lines(lines,
        pageWidth-indents[1],
        pageWidth-indents[0])

    # prefix with the leading whitespace, if any
    paddedResult = []
    paddedResult.append(leading_ws[0] + result[0])
    for line in result[1:]:
        paddedResult.append(leading_ws[1] + line)

    # Convert the result to a string.
    result = '\n'.join(paddedResult)
    if trailingNL: result = result + '\n'

    return result
#@+node:ekr.20031218072017.4037: *5* setSelectionAreas (leoBody)
def setSelectionAreas (self,before,sel,after):

    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    body = self ; w = body.bodyCtrl
    
    # 2012/02/05: save/restore Yscroll position.
    pos = w.getYScrollPosition()
    s = w.getAllText()
    before = before or ''
    sel = sel or ''
    after = after or ''
    w.delete(0,len(s))
    w.insert(0,before+sel+after)
    i = len(before)
    j = max(i,len(before)+len(sel)-1)
    # g.trace(i,j,repr(sel))
    w.setSelectionRange(i,j,insert=j)
    w.setYScrollPosition(pos)
    return i,j
#@+node:ekr.20120226183512.10192: *4* Fixed bug: @int pagewidth now set c.page_width
@nocolor-node

Fixing this bug is important: it allows you to set a default
page width in myLeoSettings.leo for use, for example, in the
reformat-paragraph command.

Without a proper default c.page_width setting, you would have
to use @page_width instead, which is much less convenient.

The fix was the following lines in c.initConfigSettings:
    
    c.page_width = getInt('page_width') or 132
        # 2012/02/27: this appears to be a fix of an *ancient* bug.
#@+node:ekr.20120228164039.10046: *4* Fixed bug: goto end line handler is broken 
@nocolor-node

The fix was easy: moveWithinLineHelper does *not* call
leoMoveCursorHelper for the case spot == 'end-line'
#@-all

# Put this @language after the @all as a kind of permanent unit test.

#@@language python # Override the default .txt coloring.

#@@pagewidth 60
#@-leo
