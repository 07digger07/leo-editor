.. @+leo-ver=5-thin
.. @+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
.. @+all
.. @+node:ekr.20150417044242.1: ** 5.1.1 Documentation
@language rest
@wrap
.. @+node:ekr.20150512102759.1: *3* Code
.. @+node:ekr.20150512102801.1: *4* Decorators simplify Leo's command dispatching
Please read carefully if you write plugins or are one of Leo's core developers.  Everyone else can safely ignore this post.

The present (g.new_dispatch) project simplifies Leo's code as follows:

1. Decorators will define all Leo commands.  All getPublicCommands methods will disappear, along with their association lists of command names and bound methods.

2. Leo will never call c.universalCallback.

I understand neither it's docstring, nor its code, nor why it is needed. Leo will be better off without it and the corresponding 'wrap' argument to k.registerCommand. This wrapper gives rise to wretched code::

    @g.command('cke-text-open')
    def cmd_OpenEditor(kwargs, at_rich=False):
        '''Open the rich text editor, hide the regular editor.'''
        c = kwargs['c'] if isinstance(kwargs, dict) else kwargs

Apparently, kwargs might be two different kinds of objects depending on who calls the function.  This kind of code must go.  In an emergency, code could add ivars/attributes to exiting events, but even that would be too complex by half.

3. The Plugin class in plugins_menu.py creates Leo commands for functions whose names start with ``cmd_``.  It took me hours yesterday to figure out that this was happening.

<< Look for additional commands >> creates yet another wrapper, with yet another signature. The wrapper now has a more conforming signature and a better name::

    def plugins_menu_wrapper(kwargs, cmd=cmd):
        return cmd(kwargs['c'])

This signature allows a unit test to pass even when plugins_menu_wrapper is not wrapped again.

Happily, all of this is going to go away. ``@g.command`` will define all commands in plugins. No more invisible ``cmd_`` naming convention.

4. class AtButtonCallback now supports the __name__ attribute using a new __getattr__ method. This allows k.registerCommand not to know about the AtButtonCallback wrapper.

5. The LeoKeyEvent class now has a get method.  Code can now call event.get('c') in all cases.  Probably ditto for kwargs.get('c').

**Summary**

The new_dispatch project simplifies some of the most complex code in Leo.  It is worth a week's work.

I followed three principles while simplifying the code:

1. Eliminate malignant if statements::

    c = kwargs['c'] if isinstance(kwargs, dict) else kwargs

proliferates implementation details from one part of Leo to another.  As a result, it becomes much harder to change code without side effects.  I have been dealing with such side effects all week.

2. Regularize interfaces.

- ``@cmd`` or ``@g.command`` decorators will define all Leo commands.
- The ``cmd_`` convention will disappear, along with the complex code that creates it.
- event.get('c') will work in any code decorated by ``@cmd`` or ``@g.command``.
- AtButtonCallback instances now have a __name__.

3. Regularize objects.

Changing the interface of an object by wrapping it is unacceptable. c.universalCallback must go.

.. @+node:ekr.20150513163611.1: *5* What I did
@language rest
@wrap

- Defined all commands in leoPlugins.leo with @g.command.
- Eliminate the "cmd_" convention.
  The g.command decorator now sets func.is_command and func.command_name.
  Plugin.create_menu is now much simpler.
- All decorated commands now use the "event" arg:

    @g.command('command-name')
    def my_command(event=None):
        ...
    
    @cmd('command-name')
    def my_command(self,event=None):
        ...
.. @+node:ekr.20160229081126.1: *4* Removed g.isChar
A bad idea.
.. @+node:ekr.20150501041440.1: *4* Reorganized Leo's commands files
The leo/commands directory contains the new code.
.. @+node:ekr.20150503050557.1: *4* Replace all has_key by "in"
.. @+node:ekr.20150622130738.1: *4* Verified that c.p.copy() is always redundant
Examined c.p and c.currentPosition
.. @+node:ekr.20150427042446.1: *3* Features
.. @+node:ekr.20160225053416.1: *4* Major feature: improved searching
The new **clone-find-marked** commands and improved **clone-find** commands revolutionize my workflow.

.. @+node:ekr.20150619082025.1: *5* Added optional Find Dialog
Enable with: @bool use_find_dialog = True
Related setting: @bool close-find-dialog-after-search = False

Defaults are as shown above.
.. @+node:ekr.20160225050603.1: *5* Improved cfa and cff commands
@language rest
@wrap

Rev 38db98ff improves Leo's *existing* clone-find commands:

- cff (clone-find-flattened)
- cfa (clone-find-all)

in the following extremely important ways:

1. These commands search the entire outline, regardless of the presently selected node. This is a *huge* improvement to my workflow—I don't have to worry about where I start searches. These commands do honor suboutline-only searches. For me, this is moot because I almost never use suboutline-only-restricted searches.

2. These commands ignore @ignore trees and any @<file> tree whose root nodes contains an @all directive. This is a super tweak: I don't get false matches about nodes in the attic.

3. These commands are significantly than before because they search body text in one step.

​
​Just to wrap this up, the new commands, cff, cfa, cffm and cfam are are revolution in my work flow. They pass the acid test. Three things make the new commands work:

1. The command names are short enough that they don't need either key bindings or pre-loaded entries in command history. Indeed, I've basically stopped using command history.

2. The commands search the entire outline, except for @ignore trees and @<file> node containing ​@all in the top-level node.

3. The commands put their results in the last top-level node and (usually, there is a little bug lurking somewhere) select that node.

This means that these commands are so convenient that they become temporary. I don't keep them around because it's easy to recreate them.

Because they are so convenient, I almost always use them instead of Ctrl-F. After I create the clone-find node, I then use Ctrl-F (with the existing find pattern) to search the clone-find results.

This is the pattern I have been looking for. I'm not looking for anything better. Notice, it no longer matters how many clones there are.

Edward


.. @+node:ekr.20160225045341.1: *5* Added clone-marked commands
@language rest
@wrap

I said previously that clones are just fine as they are. What is needed isn't fancier clones, but rather better search commands.

Rev c8a3581c9 adds two commands that will revolutionize my workflow:
    
- cffm, aka clone-find-flattened-marked
- cfam, aka clone-find-all-marked

These commands create a "target" node as the last top-level node, and clone all marked nodes under the target node.  cffm makes each marked node a child of the target. cfam does not create a child for marked nodes that are descendants of a marked node.

This makes gathering nodes a snap. Just go through the outline, marking the desired nodes, then execute cfam or cffm.  I prefer cffm because all found nodes appear as direct children of the target. These two commands are much better than auto-moving clones as they are made, as I had intended to do yesterday.

Leo's clone-find and clone-find-marked commands allow me to quickly gather desired nodes without duplicates, *regardless* of how many clones there are in an outline. These commands are the magic bullets for searching that I have wanted for decades.

Please try these commands. They are extremely useful.
.. @+node:ekr.20150425135844.1: *5* Added support for @data history-list
If you aren't using the @data history-list setting chances are that you missing a big chance to simplify your workflow. At one time I thought the history list was a minor feature.  I could not have been more wrong.

The body of the @data history-list node should contain a list of command names, one per line.  This list can include commands created by @command/@button nodes.

You execute items in the history list by doing Alt-X followed by an up arrow to get the first item in the list, or one or more down arrows to get later items in the list.  The last item you execute from this list goes to the head of the list.  Once you have executed an item, Ctrl-P (repeat complex command) will re-execute it.

The history list works well for commands that aren't quite worth a separate key binding, but that nevertheless you find you using quite often.

Even better, the history list is a perfect complement to @button and @command nodes that are tailored for a particular outline. For example, there is a button called cfa-code in leoPy.leo that executes the clone-find-all-flattened command starting at the top-level "Code" node.
.. @+node:ekr.20150325052301.1: *5* Added enhancement 165: vim-open-file command
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/165

Later: preserve cursor positions.

All the changes were to the ExternalFilesController class.
.. @+node:ekr.20150530084545.1: *5* Added support for @beautify and @nobeautify
These directives are inherited as usual.
.. @+node:ekr.20150420130845.1: *5* Added File:Print menus
jasonic

Leo deserves good friendly printing features which anyone can use. At the moment we have a confusing patchwork of choices. Printing Leo seems to be both harder and easier than  first meets the eye.

print-to-web (htmlize) should definitely be on Leo's missing PRINT MENU.

Having a little library of export scripts--well named, documented and intended to aid printing woudl go a long way. Thesse scripts anyone coiuld be called by onayone given a Leo Outline, accessing a navabr button. PRINT MENU or list. Or they can just insert the appropriate script  into an outline giving finer grained print control on the fly.
.. @+node:ekr.20150609110852.1: *5* Alt-N (goto-next-clone) falls backs to find-next-clone
.. @+node:ekr.20150619075613.1: *5* Leo now shows find status in status line
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/177

Rev a1c8133:


Leo now more clearly shows the status of successful or failed searches in the status line. Imo, this is an important addition, especially for failed searches.  You could call this the last part of #177

Without this feedback, a failed search appears to do nothing, and my inevitable response was, "huh?, what just happened?"  The feedback is useful for successful searches, but successful searches change at least the selected text and often also change the selected node, so there is less huh? involved.

By default, Leo reports successful searches with white text on a blue background and failed searches with white text on a red background. These colors work pretty well even for dark themes.

You can choose these colors using the following settings in

    leoSettings.leo#@settings-->Appearance (change these first)-->
    Qt Gui settings-->Colors-->Status area colors::
   
         @color find-found-bg = blue
         @color find-found-fg = white
         @color find-not-found-bg = red
         @color find-not-found-fg = white
     
find.showStatus now gets proper colors from settings.
     
Changed the signature of QtStatusLineClass.putStatusLine and its helpers.
.. @+node:ekr.20150629080742.1: *5* cfa commands now preload search pattern with selected text
- c.cloneFindAll/FlattenedAtNode now preload the search argument
  *before* selecting the node.
- extendToWord now takes a new "w" keyword arg, so event is not needed.
- minibufferCloneFindAll/Flattened now take a new "preloaded" keyword argument.
.. @+node:ekr.20150227040245.10: *5* Added find-def & find-var
@language rest
@wrap

Leo's new find-def & find-var commands
https://groups.google.com/d/msg/leo-editor/mq_sQ2cpa9k/3rtHZyKnMTIJ

About recent changes to Leo's find commands
https://groups.google.com/d/msg/leo-editor/_y1u2Vlm-0I/LoAGSH_HBgsJ

Done:
- find-def and F3/F2 work together.
- @bool find-ignore-duplicates = False
- Ctrl-click on a word executes find-def.

(Maybe) Multiple defs:
- Prefer matches in @<file> trees.
- Do cfa-flattened. (Only if enabled by @bool find-def-uses-cfa-flattened).
- Bring up popup.

Leo now supports find-def and find-var commands.  They find the definitions of classes, defs or vars.

They work as follows:

- Select the word at the cursor, if text is not already selected.
- Save the find settings in effect before the command started.
- find-def sets the search pattern to "class word" or "def word" depending on whether word is capitalized.
- find-var sets the search pattern to "word =".
- Set word-find to True
- Start the search at the root position of the outline.

This will find the first definition of the word.  Thereafter, you can use F3 (find-next) to find additional definitions.

When the search fails, Leo restores the Find settings to what they were previously.

A new setting, @bool find-ignore-duplicates (default False), controls whether any search command ignores duplicate matches.  Ctrl-F restarts searches, clearing a list of vnodes that have already been seen.  Any failed search also clears the list of vnodes.

Obviously, this scheme is a bit naive.  The search patterns could be improved.  However, even this simple scheme is surprisingly useful.  Furthermore, these commands have implications that I'll discuss in another thread.
.. @+node:ekr.20150629080954.1: *6* posts
https://groups.google.com/d/msg/leo-editor/p3MR1es0Ez0/U4ME-UAuf0AJ

===== Matt

Wanted Leo function or plugin: Ctrl-X click or R-click {selected text} or ... that jumps to the associated node or function.

Consider the following code:

    print "Downloading", ', '.join(packages)
    for p in packages:
        do_download(p)
        ball(p)
        md5(p)

Wouldn't be nice to ctrl-click `do_download` and have Leo navigate to whatever node contains def do_download(): ?

===== Terry:

Seems like the codewise ctags thing Ville worked on does most of that, may need refreshing though. 

.. @+node:ekr.20150630092648.1: *6* ctrl-click now supports find-def
The code involves lqtb.onMouseUp and g.openUrlOnClick
.. @+node:ekr.20150630160037.1: *5* Added clone-to-at-spot command
Create a clone of the selected node and move it to the last @spot node
of the outline. Create the @spot node if necessary.
.. @+node:ekr.20150710064429.1: *5* Added @bool preload-find-pattern
Rev abe5563f

Added @bool preload-find-pattern and associated logic.
.. @+node:ekr.20150513180101.1: *5* find-all now write to the body of a new top-level node
Pretty much like clone-find-all.
.. @+node:ekr.20150412053053.1: *4* Finished leoOPML plugin
.. @+node:ekr.20150416060248.1: *4* Allow Leo directives in @data abbreviations-subst-env
The fix was to create a dummy root position in abbrev.init_env.
.. @+node:ekr.20150422124650.1: *4* Added c.backup
Useful for per-file backups.
.. @+node:ekr.20150426052139.1: *4* Added @ifenv, improved @ifplatform & @ifhostname
@language rest
@wrap

Here are the details:

@ifenv name, one-or-more-comma-separated values
 
Includes descendant settings if os.getenv(name) matches any of the values.

- Case is significant in the *name* of the environment variable.
- Case is ignored in the *values*.

Examples:

@ifenv HOSTNAME,bob
    Enables descendant settings if os.environ('HOSTNAME') is 'Bob' or 'bob'
   
@ifenv EDITOR,leo,lion
    Enables descendant settings if os.environ('Editor') is 'Leo' or 'Lion', etc.

@ifplatform name,  one-or-more-comma-separated values.
  
Includes descendant settings if sys.platform matches any of the values, ignoring case.

Examples:

@ifplatform darwin,linux2
    Enables descendant settings for MacOS and Linux.

@ifplatform win32
    Enables descendant settings for Windows
  
@ifhostname name

Includes descendant settings if os.environ('HOSTNAME') == name

@ifhostname !name

Includes descendant settings if os.environ('HOSTNAME') != name
.. @+node:ekr.20150211131925.4: *4* abbreviations now support auto-close quotes
https://groups.google.com/d/msg/leo-editor/yJLz-p3I4mY/Pqa1phYN_10J
.. @+node:ekr.20150619082041.1: *4* Completed enhancement 177: Improved operation of Find commands
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/177

1. Leo now shows find-status in the status area in the main window and the Find dialog if it exists.

2. Ctrl-F pre-loads any selected text into the search text.

3. If the search text is mixed case, then ignore case is forced off.

This is controlled by the new @bool auto-set-ignore-case setting, True by default.

.. @+node:ekr.20150611163526.1: *4* Completed enhancement 183: Improve focus-border handling in qt stylesheet
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/183

Added @ignore @data qt-gui-user-style-sheet to leoSettings.leo.
This contains  alternative active pane highlighting.

This completes enhancement #183: mprove focus-border handling in qt stylesheet
https://github.com/leo-editor/leo-editor/issues/183

It would be tricky, and not terribly useful, to fold this user stylesheet into
the main @data qt-gui-plugin-style-sheet, especially considering that
themes may want to use qt-gui-user-style-sheet.

Also, the default settings aren't bad, but I prefer to change qt-gui-user-style-sheet directly.
.. @+node:ekr.20150620103337.1: *4* Added new Themes machinery
leoSettings.leo now contains a new top-level node::

    @ignore Themes: copy to last top-level setting in myLeoSettings.leo

The body text tells what to do with it, namely:

To enable a theme:
   
1. Copy this entire tree to myLeoSettings.leo.
2. Move the tree so it is the last top-level node under @settings.
3. Remove the @ignore from the copy of this node.
4. Enable one of the three themes below by removing @ignore for its node.
5. Test by opening another Leo outline.

Important Notes

1. The "Themes" node does not define @data qt-gui-plugin-style-sheet.

Instead the new themes machinery uses the so-called "fully parameterized" stylesheet that we have all been using for at least several months now.  This stylesheet is defined as a descendant of the "Appearance" node.

2. The only functional theme is a new ekr_dark theme.  It illustrates how to use the new themes machinery.

- This theme uses a small, custom @data qt-gui-user-style-sheet that adjust colors around outline indicators.

- There is a tree call "Common to all themes" which contains settings that probably can be shared by most themes.  Naturally, setting in that tree can be overridden as you desire.

3. The new themes machinery is supposed to be completely self contained.  That is, there should be no need to use a script to generate a theme.

Yes, the user must fill in all appearance-related settings.  But most users will already have done this, so adjusting the settings for a theme should be straightforward.

4. The "Common to all themes" node contains an "Outline indicators" node that specifies a relative path to outline indicator icons (arrow icons or plus/minus) icons.  The path can be relative to either the users home directory or (as shown in leoSettings.leo) relative to the leo/Icons directory. 
.. @+node:ekr.20150622075706.1: *4* @wrap now honored immediately
This fixes an annoying hangnail.

- Added match_at_wrap to jEdit colorizers.
- Added force keyword option to all setWrap methods.
  This is needed because text can be colorized before c.p.b stabilizes.
.. @+node:ekr.20150628182314.1: *4* Added help-for-keystroke command
Useful: tells the command name or names associated with any keystroke.

Prompts for a single character: shows corresponding command.

Added leoHelpCommands.helpForKeystroke
.. @+node:ekr.20150611163439.1: *4* Completed enhancement 186: Left Gutter Line numbers
https://github.com/leo-editor/leo-editor/issues/186

Controlled by the following new settings in leoSettings.leo, with defaults as shown::
    
    @bool use_gutter = True
    @color gutter-bg = @LightSteelBlue1
    @color gutter-fg = black
    @int gutter-w-adjust = 12
    @int gutter-y-adjust = 10
    @string gutter-font-family = @font-family
    @string gutter-font-size = @small-font-size
    @string gutter-font-style = @font-style
    @string gutter-font-weight = @font-weight
    
Code involves:
    
- dw.createBodyPane.
- class NumberBar(QFrame)
- class LeoLineTextWidget(QFrame)
.. @+node:ekr.20150710085715.1: *4* Added support for @bool syntax-error-popup
@language rest
@wrap
.. @+node:ekr.20150717103242.1: *4* Added clear-log command
.. @+node:ekr.20160124055305.1: *4* Created make_stub_files.py
@language rest
@wrap

Announcing make_stub_files.py

This post introduces the make_stub_files.py script, explaining what it does, how it works and why it is important. The script is at
GitHubGist: https://gist.github.com/edreamleo/5c2d625e223e3d04c11d.
All contributions welcome.

===== Executive summary

The make_stub_files script eliminates much of the drudgery of creating
python stub (.pyi) files https://www.python.org/dev/peps/pep-0484/#stub-files
from python source files. To my knowledge, no such tool presently exists.

The script does no type inference. Instead, it creates function annotations using user-supplied **type conventions**, pairs of strings of the form "name: type-annotation".

A **configuration file**, ~/stubs/make_stub_files.cfg, specifies the **source list**, (a list files to be processed), the type conventions, and a list of **prefix lines** to be inserted verbatim at the start of each stub file.

This script should encourage more people to use mypy. Stub files can be used by people using Python 2.x code bases. As discussed below, stub files can be thought of as design documents or as executable and checkable design tools.

===== What the script does

For each file in source list (file names may contain wildcards), the script creates a corresponding stub file in the ~/stubs directory.  This is the default directory for mypy stubs. For each source file, the script does the following:

1. The script writes the prefix lines verbatim. This makes it easy to add common code to the start of stub files.  For example:

    from typing import TypeVar, Iterable, Tuple
    T = TypeVar('T', int, float, complex)
    
2. The script walks the parse (ast) tree for the source file, generating stub lines for each function, class or method. The script generates no stub lines for defs nested within other defs.

For example, given the naming conventions:

    aList: Sequence
    i: int
    c: Commander
    s: str
    
and a function:

    def scan(s, i, x):
        whatever
        
the script will generate:

    def scan(s: str, i:int, x): --> (see below)
    
===== Handling function returns
    
The script handles function returns pragmatically.  The tree walker simply writes a list of return expressions for each def.  For example, here is the output at the start of leoAst.pyi:

class AstDumper:
    def dump(self, node: ast.Ast, level=number) -> 
        repr(node), 
        str%(name,sep,sep1.join(aList)), 
        str%(name,str.join(aList)), 
        str%str.join(str%(sep,self.dump(z,level+number)) for z in node): ...
    def get_fields(self, node: ast.Ast) -> result: ...
    def extra_attributes(self, node: ast.Ast) -> Sequence: ...

The stub for the dump function is not syntactically correct because there are 4 returns listed. You must edit stubs to specify a proper return type.  For the dump method, all the returns are obviously strings, so its stub should be:

    def dump(self, node: ast.Ast, level=number) -> str: ...

Not all types are obvious from naming conventions. In that case, the human will have to update the stub using the actual source code as a guide. For example, the type of "result" in get_fields could be just about anything. In fact, it is a list of strings.

===== The configuration file

As mentioned above, the configuration file, make_stub_files.cfg, is located in the ~/stubs directory.  This is mypy's default directory for stubs.

The configuration file uses the .ini format. It has two sections. The [Global] section specifies the files list and prefix lines.  The [Types] section specifies naming conventions.  For example:

    [Global]
    files:
        ~/leo-editor/leo/core/*.py
        
    prefix:
        from typing import TypeVar, Iterable, Tuple
        T = TypeVar('T', int, float, complex)

    [Types]
    aList: Sequence
    c: Commander
    i: int
    j: int
    k: int
    n: int
    node: ast.Ast
    p: Position
    result: str
    s: str
    v: VNode

===== Why this script is important

The script eliminates most of the drudgery from creating stub files. Creating a syntactically correct stub file from the output of the script is straightforward.  

Stub files are real data. mypy will check the syntax for us. More importantly, mypy will do its type inference on the stub files.  That means that mypy will discover both errors in the stubs and actual type errors in the program under test. There is now a simple way to use mypy!

Stubs express design intentions and intuitions as well as types. We programmers think we *do* know most of the types of arguments passed into and out of functions and methods. Up until now, there has been no practical way of expressing and *testing* these assumptions. Using mypy, we can be as specific as we like about types.  For example, we can simply say that d is a dict, or we can say that d is a dict whose keys are strings and whose values are executables with a union of possible signatures.  In short, stubs are the easy way to play with type inference.

Most importantly, from my point of view, stub files clarify issues that I have been struggling with for many years. To what extent *do* we understand types? mypy will tell us. How dynamic (RPython-like) *are* our programs?  mypy will tell us. Could we use type annotation to convert our programs to C.  Heh, not likely, but the data in the stubs will tell where things get sticky.

Finally, stubs can simplify the general type inference problem.  Without type hints or annotations, the type of everything depends on the type of everything else. Stubs could allow robust, maybe even complete, type inference to be done locally. We might expect stubs to make mypy work faster.

===== Summary

The make-stub-files script does for type/design analysis what Leo's c2py command did for converting C sources to python. It eliminates much of the drudgery associated with creating stub files, leaving the programmer to make non-trivial inferences.

Stub files allow us to explore type checking using mypy as a guide and helper. Stub files are both a design document and an executable, checkable, type specification. Stub files allow those with a Python 2 code base to use mypy.

One could imagine a similar insert_annotations script that would inject function annotations into source files using stub files as data. This "reverse" script should be about as straightforward as the make-stub-files script.

Edward
.. @+node:ekr.20150710063700.1: *4* Added optional popup on syntax error
Added @bool syntax-error-popup & supporting logic: c.syntaxErrorDialog
.. @+node:ekr.20160127031500.1: *4* is flatten-outline-to-node new?
.. @+node:ekr.20150710103707.1: *4* Ctrl-G now resets status line
Useful after a failed Ctrl-F
.. @+node:ekr.20160225155031.1: *4* Added new predicates for limiting search
​Recent revs add the following new position methods:

- p.is_at_all():  True if p is an @<file> node containing an @all directive.
- p.in_at_all(): True if p is in an @<file> tree whose root contains @all.
- p.is_at_ignore(): True if p is an @ignore node
- p.in_at_ignore_tree(): True if p is in an @ignore tree.

These predicates make it easy to create other predicates that skip @ignore trees or @<file> trees containing @all.  cffm and cfam do not skip such trees, on the theory that one would typically unmark nodes first before marking nodes to be cloned.

So here is how to gather only those marked nodes that lie outside any @ignore tree:

    def isMarked(p):
        return p.isMarked() and not p.in_at_ignore_tree()

      
    self.cloneFindByPredicate(
        generator = self.all_unique_positions,
        predicate = isMarked,
        flatten = flatten,
        undoType = 'gather-marked',
    )
.. @+node:ekr.20160301094120.1: *4* Allow wildcard expansion of filenames on the command-line
Sheesh.  Like leo leo\test\*.leo.
Previously, Leo crashed!
.. @+node:ekr.20160303043126.1: *4* Use Qt code to show invisibles
Better looking than the old way.
.. @+node:ekr.20150427042510.1: *3* Bugs Fixed/Investigated
@language rest
@wrap
.. @+node:ekr.20150417045902.1: *4* Recover from orphan bit in leoPyBad.leo
Rev dc1bf6f

The orphan bit was set in @file leoGlobals.py.
This prevented the file from being updated.

Changed:
- at.read.
- at.readAll
- fc.putVnode no longer writes orphan bits.
. VNode constants section: # unused    = 0x10 # (was orphanBit)
.. @+node:ekr.20150417053733.1: *4* Fixed @tabwidth bug
Using c.tab_width is wrong: it is the *default* tab width.

Created c.getTabWidth()
.. @+node:ekr.20150403035558.1: *4* Fixed #169: import-file does not preserve gnx of root @file node
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/169
import-file does not preserve gnx of root @file node

The fix was a special case in at.readStartNode.
.. @+node:ekr.20150428112500.1: *4* Fixed abbreviation bugs and improved abbreviations
@language rest
@wrap

The fixes were in abbrev.expandAbbrev and helpers.

Rev 585d2f4 improves abbreviations as follows:

- Match longest prefix first: e;; no longer interferes with date;;
- Predefine 'x' as the empty string before executing abbreviation scripts.
- Split @data abbreviations-subst-env into separate nodes.
- Defined do() and insert() functions in @data abbreviations-subst-env as follows::

@language python

    def do(commandName):
        '''Execute a command by name.'''
        c.k.simulateCommand(commandName,event=None)
    
    def insert(s):
        '''Insert the string s in the current widget.'''
        try:
            w = c.abbrevCommands.w
            if w:
                i = w.getInsertPoint()
                w.insert(i,s)
        except AttributeError:
            pass
            
@language rest
@wrap

Note:  Because of a glitch in how abbreviations scripts are created, you can't do::

    do(['command1','command2'])

even though c.k.simulateCommand allows list arguments.  Instead, do this::

    do('command1');do('command2');

The following abbreviations insert matching characters (no need to do x='' in them)::

    (={|{insert('()');do('back-char')}|}
    [={|{insert('[]');do('back-char')}|}
    {={|{insert('{}');do('back-char')}|}

This is an implementation of auto-close-quotes, done entirely with abbreviations! For example, typing '(' inserts '()' and puts the cursor between the parens.

I personally dislike these abbreviations.  I find it harder to skip past the ')' than to type it later.  ymmv.
.. @+node:ekr.20150428153124.1: *4* Removed warning in at.read about orphan bits
.. @+node:ekr.20150430175300.1: *4* Improved Ctrl-LtArrow
Ctrl-LtArrow and Ctrl-RtArrow leave the cursor at the start of a word.
This is the way most editors work.

The fix was in moveWordHelper.
.. @+node:ekr.20150509180744.1: *4* Fixed remove-blank-lines command
It now works when there is no text selection.
.. @+node:ekr.20150514115247.1: *4* Fixed cut/paste from menus
.. @+node:ekr.20150520071422.1: *4* Fixed #150: Importing file to @clean produces section references...
Importing file to @clean produces section references following class constructor
https://github.com/leo-editor/leo-editor/issues/150

The bug was a typo in plugins/importers/basescanner.py.

Also improved reporting in the RecursiveImportController class.
.. @+node:ekr.20150608184148.1: *4* Fixed #193: goto-global-line doesn't work properly in @clean files
https://github.com/leo-editor/leo-editor/issues/193
goto-global-line doesn't work properly in @clean files

The fix was in GoToLineNumber.go: it must test for p.isAtCleanNode()
.. @+node:ekr.20150502050809.1: *4* Fixed #131: Insert time in headline now inserts time in body
Insert time in headline now inserts time in body
https://github.com/leo-editor/leo-editor/issues/131

The fix was to replace:
    
    w = self.editWidget()
    
by::
    
    w = c.frame.tree.edit_widget(p)
    
    
in editCommands.insertHeadlineTime.
.. @+node:ekr.20150609082814.1: *4* Fixed #162: Valid language list in Docs not up to date
@language rest
@wrap

Valid language list in Docs not up to date
https://github.com/leo-editor/leo-editor/issues/162

cm.isValidLanguage accepts any language x for which leo/modes/X.py exists.

Added a script in LeoDocs.leo that will generate all valid languages.
.. @+node:ekr.20150609111916.1: *4* Fixed #195: fcol when using @first directive is inaccurate
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/195
fcol when using @first directive is inaccurate

1. p.textOffset returns None if no @<file> node is an ancestor.
2. p.textOffset never caches its result.
    In any case, it was quite wrong to cache results in positions.
3. Rewrote p.textOffset to simplify it.
4. QtStatusLineClass.update prints '' for fcol if p.textOffset returns None.
5. Changed unit tests accordingly.
.. @+node:ekr.20150609103947.1: *4* Investigated #188: Find/Replace All Suboutline only same as Node only
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/188
Find/Replace All Suboutline only same as Node only

This bug appears to be invalid.

.. @+node:ekr.20150609082814.2: *4* Fixed #181: Focus remains in previous file
@language rest
@wrap

Focus remains in previous file
https://github.com/leo-editor/leo-editor/issues/181

LM.finishOpen now calls c.outerUpdate.
.. @+node:ekr.20150609082815.1: *4* Fixed #182: Long filenames do not wrap in notification dialogues
@language rest
@wrap

Long filenames do not wrap in notification dialogues
https://github.com/leo-editor/leo-editor/issues/182

Added g.splitLongFileName and called it from several file dialogs.
.. @+node:ekr.20150609101848.1: *4* Fixed #136: Viewrendered2 chokes on displaying @html nodes
Revised some of the code, but probably more work is needed.
.. @+node:ekr.20150620103158.1: *4* Fixed #199: The "already open" logic hard crashes Leo
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/199

Leo now warns in the log pane and raises a summary dialog about possibly already-open files.  However, all files are opened as usual, leaving it to the user to determine what to do.

A (new?) bug *won't* be fixed.  Closing a file removes the file's entry from g.app.db, so reopening the file *again* won't give another warning.  This is a very minor matter.

What I did: (See app.Detecting already-open files)

- Added g.app.already_open_files list.
- Added calls to new runAlreadyOpenDialog method in c.open and LM.doPostPluginsInit.
- Rewrote app.checkForOpenFile.
.. @+node:ekr.20150622070146.1: *4* Fixed #198: Find tab 'ignore case' tick box has no effect
https://github.com/leo-editor/leo-editor/issues/198
.. @+node:ekr.20150623040812.1: *4* Fixed #200: goto-global-line logic is too complex and buggy
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/200

- Added leo.commands.gotoCommands module.
- Removed almost all old code.
- Added goto.get_external_file_with_sentinels.
  This returns the external file *with* sentinels, even if
  it normally does not have sentinels.
- Added goto.scan_nonsentinel_lines & goto.scan_sentinel_lines.
  These contain the essential algorithms.
- Added code to force any particular write to use sentinels.
.. @+node:ekr.20150623053643.1: *5* checkin log 1
Several changes, preparing to simplify goto-global-line logic:

leoAtFile.py:
- Added at.scriptWrite ivar, set from the scriptWrite keyword arg to at.write.
- at.nodeSentinelText now writes full sentinels if at.scriptWrite is True.
  This makes sentinels available to goto-global-line.
  
leoCommands.py:
- Removed the now-unused "script" keyword argument from c.goToScriptLineNumber.
- Added GoToLineNumber.find_script_line.
  This explicitly sets up the goto-global-line logic for scripts.
  It may not be needed eventually, but for now it's a good step.
- Removed the scriptData keyword argument from GoToLineNumber.find_file_line.
  It's no longer needed now that GoToLineNumber.find_script_line exists.
  
leoAtShadow.py:
- AtShadowTestCase.makePrivateLines now calls at.write with scriptWrite=False.
  This retains the simplified node sentinels needed by AtShadowTestCase.
  All @shadow-related unit tests pass, so this change is benign.

leoGlobals.py:
- Added g.goto_last_exception.
  It works, modulo problems with goto-global-line.
  
unitTest.leo:
- Changed several unit tests re goto-global-line to reflect new signatures.

.. @+node:ekr.20150624062219.1: *5* checkin log 2
Created goto.scan_sentinel_lines, a complete, simple solution to finding lines in scripts.

Leo now automatically finds script lines that generate exceptions:
http://sourceforge.net/forum/message.php?msg_id=3593116

It is a partial solution for issue #200: goto-global-line logic is too complex and buggy
https://github.com/leo-editor/leo-editor/issues/200

Still to do: associate lines in external files with nodes/offsets within an @<file> tree.
.. @+node:ekr.20150625112217.1: *5* checkin log 3
The grand changeover to the new line-number scheme. All tests pass.

leoAtFile.py:
- Added forceSentinels ivar and logic.
- Added forceSentinels keyword argument to at.writeOneAtAutoNode.
- Changed at.nodeSentinelsText (a major change):
    1. Made an explicit test for at_shadow_test_hack.
       This supports some mischief in the AtShadowTestCase.
    2. Otherwise, a full node sentinel is generated if::
    
        at.thinFile or at.scriptWrite or at.forceSentinels:
        
- In all other places, the write code generates sentinels if::

        at.sentinels or at.forceSentinels.
    
gotoCommands.py:
- debugged and improved goto.scan_sentinel/nonsentinel_lines.
- Moved the following to the attic:
    - countLines & helpers.
    - setup_file & setup_script.
    - find_vnode & helpers.
- All methods are now zero-based.

leoGlobals.py:
- g.gotoLastException adjust the calls to make them zero-based.

leoShadow.py
- makePrivateLines sets and clears the at.at_shadow_test_hack ivar
  rather than setting at.scriptWrite.

    
.. @+node:ekr.20150625161350.1: *5* checkin log 4
Added support for general delimiters:

Separated goto.show_results into goto.success and goto.fail.
.. @+node:ekr.20150626105504.1: *5* checkin log 5
The new line-number scheme now works with all kinds of @auto files.
All tests pass, including new unit tests for @auto-markdown, @auto-org, @auto-otl, @auto-rst.

- Fixed several bugs that show up only when two comment delims are in effect.
- Added forceSentinels keyword argument of all write methods in subclasses of the BaseWriter class.
- The writer methods call the new BaseWriter.put_node_sentinel method when forceSentines is True. put_node_sentinel is similar to corresponding AtFile code.
.. @+node:ekr.20150609082813.1: *4* Investigated #153: Leo acts on some operator input when the Leo window is NOT the top window
@language rest
@wrap

Leo acts on some operator input when the Leo window is NOT the top window
https://github.com/leo-editor/leo-editor/issues/153

This problem is discussed in the Leo-Editor forum thread:
https://groups.google.com/forum/?fromgroups#!topic/leo-editor/3PPObn4JRik

I can't reliably reproduce this problem, so I can't give you a test case that demonstrates it.

The symptom that I first noticed was unexpected, unpredictable changes in what the tree pane showed when I switched back to Leo-Editor after switching away from Leo-Editor by executing open-url.

Sometimes the node selected was unchanged, but it had been scrolled up in the tree pane; and sometimes it had been scrolled all the way out of the tree pane.

Sometimes the node selected had been changed to a sibling node after the node that was selected when I switched away from Leo-Editor.

In all cases, the body pane correctly showed the contents of the currently selected node.

Sometimes an Alt-F4 when a non-Leo-Editor window is the only window showing, causes Leo-Editor to exit or display its "Save changes before exit?" query.

Edward K. Ream currently believes: "The culprit is likely a delayed action (on the order of 0.5 sec) that Leo takes on focus-in events. If the user responds to a focus-in event before that time there will be problems."

My test system:

Xubuntu32 12.04
Python 2.7.3, PyQt version 4.8.1

The problem has been observed on Leo-Editor commit f6cdb2b. It seems to occur slightly more frequently on more recent commits such as 42a5207.


.. @+node:ekr.20150626134708.1: *4* Fixed #196: Traceback using graphcanvas.py
https://github.com/leo-editor/leo-editor/issues/196

The fix was to use setBackground instead of setBackgroundColor.
No real testing was done.
.. @+node:ekr.20150626141225.1: *4* Investigated #188: Find/Replace All Suboutline only same as Node only
https://github.com/leo-editor/leo-editor/issues/188
  
Rev e8b134:
    
Improved reporting of find options.  The report now shows suboutline-only and node-only.
- Just after Ctrl-F the status line contains:

    Find (wixbhacf[esn]): <list of options>

- When the command completes, the status line contains:

    found/not found (<list of options>): <find pattern>

This makes it much easier to see what is going on.

I suspect that #188 is invalid.  These changes will reduce confusion.
.. @+node:ekr.20150715093109.1: *4* Fixed Python 3k problem with @lineending
Rev a7e2e86 fixes atFile.create.
.. @+node:ekr.20151202133537.1: *4* Fixed #224: TypeError: unorderable types...
https://github.com/leo-editor/leo-editor/issues/224

The fix was in c.checkGnxs
.. @+node:ekr.20151227104921.1: *4* Fixed #220: @spot bug
https://github.com/leo-editor/leo-editor/issues/220

Executing clone-to-at-spot with an @spot node selected causes Leo to become
unresponsive and python process slowly eats up all system memory.
.. @+node:ekr.20151010055931.1: *4* Fixed #211: Saving untitled document on window close not working on Qt GUI
https://github.com/leo-editor/leo-editor/issues/211

Saving untitled document on window close not working on Qt GUI
.. @+node:ekr.20151026105904.1: *4* Fixed #215: insert-file-name doesn't process ~
https://github.com/leo-editor/leo-editor/issues/215
.. @+node:ekr.20151118152036.1: *4* Fixed #218: Select Text and Clipboard
https://github.com/leo-editor/leo-editor/issues/218

Here's a shell script you can run in a console

https://gist.github.com/tbnorth/4b781ba2b8f59c83dd5e

to show the content of the primary and secondary selections, and the
clip-board.  You'll probably need to install xclip

When the mouse is released after drag-selecting text in Leo, the
primary selection updates as expected.  This doesn't happen with
shift-arrow selection.

It looks like keyboard shift-arrow selection should call
QClipboard::setText(const QString & text, Mode mode = QClipboard::Selection)
.. @+node:ekr.20150622103132.1: *4* Fixed Find crash
@language rest
@wrap

https://groups.google.com/d/msg/leo-editor/tA5Q2YrEu-w/9mzqFAHMcX4J

The fix was in find.changeSelection

I'm getting weirdness when trying to use minibuffer replace, first if nothing is selected it tells me "no text selected", if I have text selected sometimes it just deletes the selected text and sometimes I see this:


File "C:\Users\L\Documents\sourcetreeapp\leo-editor\leo\core\leoCommands.py", line 5496, in doCommand

val = command(event)

File "C:\Users\L\Documents\sourcetreeapp\leo-editor\leo\core\leoGlobals.py", line 1334, in wrapper

func(self, event=event)

File "C:\Users\L\Documents\sourcetreeapp\leo-editor\leo\core\leoFind.py", line 1121, in change

self.changeSelection()

File "C:\Users\L\Documents\sourcetreeapp\leo-editor\leo\core\leoFind.py", line 1194, in changeSelection

c.frame.tree.drawIcon(p) # redraw only the icon.

File "C:\Users\L\Documents\sourcetreeapp\leo-editor\leo\plugins\qt_tree.py", line 709, in drawIcon

itemOrTree = self.position2item(p) or w

File "C:\Users\L\Documents\sourcetreeapp\leo-editor\leo\plugins\qt_tree.py", line 847, in position2item

item = self.position2itemDict.get(p.key())
AttributeError: 'NoneType' object has no attribute 'key' 
.. @+node:ekr.20160123062001.1: *4* Fixed #in p.__eq__(!!)
.. @+node:ekr.20160301135653.1: *4* Fixed #234: hard crash on UnicodeDecodeError
https://github.com/leo-editor/leo-editor/issues/234

/path/leo-editor/leo/core/leoCommands.py:581: UnicodeWarning: Unicode equal comparison failed to convert both arguments to Unicode - interpreting them as being unequal
  test(expected == got, 'stroke: %s, expected char: %s, got: %s' % (
/path/leo-editor/leo/core/leoGlobals.py:359: UnicodeWarning: Unicode equal comparison failed to convert both arguments to Unicode - interpreting them as being unequal
  elif hasattr(other, 's'): return self.s == other.s
Traceback (most recent call last):
  File "/path/leo-editor/leo/plugins/qt_events.py", line 126, in eventFilter
    k.masterKeyHandler(event)
  File "/path/leo-editor/leo/core/leoKeys.py", line 3313, in masterKeyHandler
    k.handleUnboundKeys(event, char, stroke)
  File "/path/leo-editor/leo/core/leoKeys.py", line 3529, in handleUnboundKeys
    k.masterCommand(event=event, stroke=stroke)
  File "/path/leo-editor/leo/core/leoKeys.py", line 3173, in masterCommand
    expanded = c.abbrevCommands.expandAbbrev(event, stroke)
  File "/path/leo-editor/leo/commands/abbrevCommands.py", line 251, in expandAbbrev
    word = prefix + ch
UnicodeDecodeError: 'ascii' codec can't decode byte 0xdc in position 0: ordinal not in range(128)
fish: â€œ./launchLeo.pyâ€ terminated by signal SIGABRT (Abort)
.. @+node:ekr.20150514043850.11: *5* abbrev.expandAbbrev & helpers (entry point)
def expandAbbrev(self, event, stroke):
    '''
    Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.

    Words start with '@'.
    '''
    trace = False and not g.unitTesting
    verbose = False
    c = self.c
    ch = g.toUnicode(event and event.char or '')
    w = self.editWidget(event, forceFocus=False)
    if not w: return False
    if self.expanding: return False
    if w.hasSelection(): return False
    assert g.isStrokeOrNone(stroke), stroke
    if stroke in ('BackSpace', 'Delete'):
        if trace and verbose: g.trace(stroke)
        return False
    d = {'Return': '\n', 'Tab': '\t', 'space': ' ', 'underscore': '_'}
    if stroke:
        ch = d.get(stroke.s, stroke.s)
        if len(ch) > 1:
            if (stroke.find('Ctrl+') > -1 or
                stroke.find('Alt+') > -1 or
                stroke.find('Meta+') > -1
            ):
                ch = ''
            else:
                ch = event and event.char or ''
    else:
        ch = event.char
    if trace and verbose: g.trace('ch', repr(ch), 'stroke', repr(stroke))
    # New code allows *any* sequence longer than 1 to be an abbreviation.
    # Any whitespace stops the search.
    s = w.getAllText()
    j = w.getInsertPoint()
    i, prefixes = j - 1, []
    while i >= 0 and s[i] not in ' \t\n':
        prefixes.append(s[i: j])
        i -= 1
    prefixes = list(reversed(prefixes))
    if '' not in prefixes: prefixes.append('')
    for prefix in prefixes:
        i = j - len(prefix)
        word = g.toUnicode(prefix) + ch
        val, tag = self.tree_abbrevs_d.get(word), 'tree'
        # if val: g.trace('*****',word,'...\n\n',len(val))
        if not val:
            val, tag = self.abbrevs.get(word, (None, None))
        if val:
            if trace and verbose: g.trace(repr(word), 'val', val, 'tag', tag)
            # Require a word match if the abbreviation is itself a word.
            if ch in ' \t\n': word = word.rstrip()
            if word.isalnum() and word[0].isalpha():
                if i == 0 or s[i - 1] in ' \t\n':
                    break
                else:
                    i -= 1
            else:
                break
        else: i -= 1
    else:
        return False
    c.abbrev_subst_env['_abr'] = word
    if tag == 'tree':
        self.last_hit = c.p.copy()
        self.expand_tree(w, i, j, val, word)
        c.frame.body.forceFullRecolor()
        c.bodyWantsFocusNow()
    else:
        # Never expand a search for text matches.
        place_holder = '__NEXT_PLACEHOLDER' in val
        if place_holder:
            expand_search = bool(self.last_hit)
        else:
            self.last_hit = None
            expand_search = False
        if trace: g.trace('expand_search', expand_search, 'last_hit', self.last_hit)
        self.expand_text(w, i, j, val, word, expand_search)
        c.frame.body.forceFullRecolor()
        c.bodyWantsFocusNow()
        # Restore the selection range.
        if self.save_ins:
            if trace: g.trace('sel', self.save_sel, 'ins', self.save_ins)
            ins = self.save_ins
            # pylint: disable=unpacking-non-sequence
            sel1, sel2 = self.save_sel
            if sel1 != sel2:
                # some abbreviations *set* the selection range
                # so only restore non-empty ranges
                w.setSelectionRange(sel1, sel2, insert=ins)
    return True
.. @+node:ekr.20150514043850.12: *6* abbrev.expand_text
def expand_text(self, w, i, j, val, word, expand_search=False):
    '''Make a text expansion at location i,j of widget w.'''
    c = self.c
    if word == c.config.getString("abbreviations-next-placeholder"):
        val = ''
        do_placeholder = True
    else:
        val, do_placeholder = self.make_script_substitutions(i, j, val)
    self.replace_abbrev_name(w, i, j, val)
    # Search to the end.  We may have been called via a tree abbrev.
    p = c.p.copy()
    if expand_search:
        while p:
            if self.find_place_holder(p, do_placeholder):
                return
            else:
                p.moveToThreadNext()
    else:
        self.find_place_holder(p, do_placeholder)
.. @+node:ekr.20150514043850.13: *6* abbrev.expand_tree & helper
def expand_tree(self, w, i, j, tree_s, word):
    '''Paste tree_s as children of c.p.'''
    c, u = self.c, self.c.undoer
    if not c.canPasteOutline(tree_s):
        return g.trace('bad copied outline: %s' % tree_s)
    old_p = c.p.copy()
    bunch = u.beforeChangeTree(old_p)
    self.replace_abbrev_name(w, i, j, None)
    self.paste_tree(old_p, tree_s)
    # Make all script substitutions first.
    do_placeholder = False
    for p in old_p.subtree():
        # Search for the next place-holder.
        val, do_placeholder = self.make_script_substitutions(0, 0, p.b)
        if not do_placeholder: p.b = val
    # Now search for all place-holders.
    for p in old_p.subtree():
        if self.find_place_holder(p, do_placeholder):
            break
    u.afterChangeTree(old_p, 'tree-abbreviation', bunch)
.. @+node:ekr.20150514043850.14: *6* abbrev.find_place_holder
def find_place_holder(self, p, do_placeholder):
    '''
    Search for the next place-holder.
    If found, select the place-holder (without the delims).
    '''
    c = self.c
    s = p.b
    if do_placeholder or c.abbrev_place_start and c.abbrev_place_start in s:
        new_s, i, j = self.next_place(s, offset=0)
        if i is None:
            return False
        w = c.frame.body.wrapper
        switch = p != c.p
        if switch:
            c.selectPosition(p)
        else:
            scroll = w.getYScrollPosition()
        oldSel = w.getSelectionRange()
        w.setAllText(new_s)
        c.frame.body.onBodyChanged(undoType='Typing', oldSel=oldSel)
        c.p.b = new_s
        if switch:
            c.redraw()
        w.setSelectionRange(i, j, insert=j)
        if switch:
            w.seeInsertPoint()
        else:
            # Keep the scroll point if possible.
            w.setYScrollPosition(scroll)
            w.seeInsertPoint()
        return True
    else:
        return False
.. @+node:ekr.20150514043850.15: *6* abbrev.make_script_substitutions
def make_script_substitutions(self, i, j, val):
    '''Make scripting substitutions in node p.'''
    trace = False and not g.unitTesting
    c = self.c
    if not c.abbrev_subst_start:
        if trace: g.trace('no subst_start')
        return val, False
    # Nothing to undo.
    if c.abbrev_subst_start not in val:
        return val, False
    # Perform all scripting substitutions.
    self.save_ins = None
    self.save_sel = None
    while c.abbrev_subst_start in val:
        prefix, rest = val.split(c.abbrev_subst_start, 1)
        content = rest.split(c.abbrev_subst_end, 1)
        if len(content) != 2:
            break
        content, rest = content
        if trace: g.trace('**content', content)
        try:
            self.expanding = True
            c.abbrev_subst_env['x'] = ''
            exec(content, c.abbrev_subst_env, c.abbrev_subst_env)
        finally:
            self.expanding = False
        x = c.abbrev_subst_env.get('x')
        if x is None: x = ''
        val = "%s%s%s" % (prefix, x, rest)
        # Save the selection range.
        w = c.frame.body.wrapper
        self.save_ins = w.getInsertPoint()
        self.save_sel = w.getSelectionRange()
        if trace: g.trace('sel', self.save_sel, 'ins', self.save_ins)
    if val == "__NEXT_PLACEHOLDER":
        # user explicitly called for next placeholder in an abbrev.
        # inserted previously
        val = ''
        do_placeholder = True
    else:
        do_placeholder = False
        # Huh?
        oldSel = i, j
        c.frame.body.onBodyChanged(undoType='Typing', oldSel=oldSel)
    if trace:
        g.trace(do_placeholder, val)
    return val, do_placeholder
.. @+node:ekr.20150514043850.16: *6* abbrev.next_place
def next_place(self, s, offset=0):
    """
    Given string s containing a placeholder like <| block |>,
    return (s2,start,end) where s2 is s without the <| and |>,
    and start, end are the positions of the beginning and end of block.
    """
    trace = False
    c = self.c
    new_pos = s.find(c.abbrev_place_start, offset)
    new_end = s.find(c.abbrev_place_end, offset)
    if (new_pos < 0 or new_end < 0) and offset:
        new_pos = s.find(c.abbrev_place_start)
        new_end = s.find(c.abbrev_place_end)
        if not (new_pos < 0 or new_end < 0):
            g.es("Found placeholder earlier in body")
    if new_pos < 0 or new_end < 0:
        if trace: g.trace('new_pos', new_pos, 'new_end', new_end)
        return s, None, None
    start = new_pos
    place_holder_delim = s[new_pos: new_end + len(c.abbrev_place_end)]
    place_holder = place_holder_delim[
        len(c.abbrev_place_start): -len(c.abbrev_place_end)]
    s2 = s[: start] + place_holder + s[start + len(place_holder_delim):]
    end = start + len(place_holder)
    if trace: g.trace(start, end, g.callers())
    return s2, start, end
.. @+node:ekr.20150514043850.17: *6* abbrev.paste_tree
def paste_tree(self, old_p, s):
    '''Paste the tree corresponding to s (xml) into the tree.'''
    c = self.c
    c.fileCommands.leo_file_encoding = 'utf-8'
    p = c.pasteOutline(s=s, redrawFlag=False, undoFlag=False)
    if p:
        # Promote the name node, then delete it.
        p.moveToLastChildOf(old_p)
        c.selectPosition(p)
        c.promote(undoFlag=False)
        p.doDelete()
    else:
        g.trace('paste failed')
.. @+node:ekr.20150514043850.18: *6* abbrev.replace_abbrev_name
def replace_abbrev_name(self, w, i, j, s):
    '''Replace the abbreviation name by s.'''
    c = self.c
    if i == j:
        abbrev = ''
    else:
        abbrev = w.get(i, j)
        w.delete(i, j)
    if s is not None:
        w.insert(i, s)
    oldSel = j, j
    c.frame.body.onBodyChanged(undoType='Abbreviation', oldSel=oldSel)
    # Adjust self.save_sel & self.save_ins
    if s is not None and self.save_sel is not None:
        # pylint: disable=unpacking-non-sequence
        i, j = self.save_sel
        ins = self.save_ins
        delta = len(s) - len(abbrev)
        # g.trace('abbrev',abbrev,'s',repr(s),'delta',delta)
        self.save_sel = i + delta, j + delta
        self.save_ins = ins + delta
.. @+node:ekr.20150620062019.1: *3* Docs
.. @+node:ekr.20150620062023.1: *4* My git work flow
Imo, git rivals python as the greatest productivity tool ever devised for programmers.

My workflow on Ubuntu and Windows is essentially identical. Simple aliases (Ubuntu) and .bat files (Windows) support the following console commands::

    gs  (expands to git status)
    gd (git diff)  Uses an external diff program,
                   but I'm starting to prefer text diffs.
    ga . (git add .)
    ga file (git add file)
    gc (git commit: configured to open Scite to create a commit message)
    gc -m "a one-line commit message"
    push (git push)

I use gitk on both platforms to review commits.

And that's about it. I use "git help" and "git help command" as needed.

.. @+node:ekr.20150703072334.1: *4* New commands greatly improve work flow
@language rest
@wrap

Recent revs make ctrl-click execute the find-def command if what is under the cursor is not a url.  There is no need to select the word--that's done automatically.

This quickly becomes indispensable. I have the following bindings defined, so there there is no need to move the mouse:

Ctrl-4: find-def
Ctrl-5: find-var

Furthermore, several recent changes/additions are remarkably useful:

clone-to-at-spot

This command does the following:

1. Clones the selected node.
2. Moves the clone to the last child of the last @spot node in the outline.
3. Collapses all nodes in the outline.
4. Selects the newly-cloned node, thereby making it visible.

I typically create the following project node:

   @spot re: the project name

pre-loaded find patterns

Today I improved the clone-find-all commands so they pre-select the find pattern more usefully.  leoPy.leo defines @button cfa-code as::

c.cloneFindAllFlattenedAtNode('Code',top_level=True)

This code now preloads the find pattern before selecting the top-level "Code" node.

These new and improved commands make a big difference to my work flow.

Edward
.. @+node:ekr.20160128201207.1: *3* ==== Code academy posts
@language rest
@wrap

To do:
- Using g.trace and g.pdb: example: splitter.open_window
- Find all nodes with a give uA.
- Create log pane.
    - Put Qt stuff in it.
- Key bindings.
- Create new panes.
- Scripts can handle events.

- Redraw mode that hides siblings.
- Key bindings in the nav pane.
    - Arrow keys.
    - Enter shift to outline pane.
    - Some key to shift back to the nav pane.
- Clone-find-predicate.
.. @+node:ekr.20160303072415.1: *4* Task oriented docs
Leo's tutorial, reference and cheat sheet have been thinly disguised encyclopedias. Very dry.  Soporific.

Contrast this with the Code Academy.  The "lectures" deal with solving real problems. Shorter code, more useful. Exciting, maybe.

This would be a good model for a rewritten tutorial.

People have talked about task-oriented documentation in the past, but I haven't understood what they meant until now.

This isn't really about telling stories that "stick".  It's about solving important problems.  Now that's something that has a chance of getting people involved.
.. @+node:ekr.20160129054828.1: *4* First post: topics
@language rest
@wrap

Here is a quick list topics for the code academy.  Most can already be done easy, if you know where to look.  Some may require a few new lines in Leo's core. These topics should also be included in Leo's cheat sheet, or somewhere similar.

**uA's**

They are crucial to flexible data management. uA's can associate arbitrary data with any vnode or position, as describe here.

Everyone needs to know how to get, set and search uA's.  You can get and set uA's with v.u. Just a few lines of code will search the entire outline for all nodes/positions having a given uA.

Quick additions to Leo's core:
- Define the p.u property, so code can do p.u instead of p.v.u.
- Possibly make the api for uA's more convenient.

A more ambitious addition: Define a gui interface for uA's.

**Other topics**

- Clones: making and deleting them. Clones are cheap to create!
- How to create new panes in the log window, and how to put cool stuff in them.
- How to hoist outlines programmatically.
- How to write a plugin so it can respond to events.
- How to create new panes in Leo's window with Terry's free_layout and nested_splitter plugins.  In essence, these plugin are part of Leo's core.
- How to put multiple icons in a single headline.  This may be possible already.  If not it would require just a few lines of code in Leo's core.

We discussed the so-called Easter-Egg interface to create new panes this from the gui, but a summary of how to do this programmatically is needed. Note: it's possible to save the layout so that Leo will restore it when Leo starts up the next time.

- How to change what is shown in the outline pane.  Chapters and hoists exploit existing capabilities.  If need be, more could be added with just a few lines of code in Leo's main outline redrawing code.

**New directions**

Putting all this together, we all agreed that being able to make uA's visible somehow would give Leo many of the cool features of the ECCO outliner. We envisage a uA tab in the outline pane that would allow the user to:

- See all and only nodes with given attributes.  This is similar to Leo's clone-find-all (or clone-find-all-flattened) commands, combined with something like a hoist.

- List all such nodes in the uA pane, similar to the Nav Pane (Quicksearch plugin), so that clicking on a node would select the node in the entire outline, with only ancestors of the selected node expanded.  Pretty easy to do.  Alternatively, perhaps some  tag (uA) oriented features can be added to existing plugins.
.. @+node:ekr.20160129103906.1: *4* uA's and the new p.u property
A recent rev added the p.u property, which you can think of as a synonym for p.v.unknownAttributes on both sides of an assignment.

The example in Leo's documentation for access uA's is way too complicated. In fact, the following suffices to set the 'n' attribute for test_plugin:

    plugin_name = 'test_plugin'
    d = p.u.get(plugin_name,{})
    d ['n'] = 8
    p.u [plugin_name] = d

p.u is the outer dictionary. p.u.get.(plugin_name, {}) is the inner dictionary. The last line is all that is needed to update the outer dictionary!

It is very easy to search for particular uA's. The following script prints all the keys in the outer-level uA dictionaries:

    for p in c.all_unique_positions():
        if p.u:
            print(p.h, sorted(p.u.keys()))

This is a typical usage of Leo's generators.  Generators visit each position (or node) quickly. Even if you aren't going to program much, you should be aware of how easy it is to get and set the data in each node. In fact, now would be a great time to read Leo's Scripting Tutorial again :-) This will allow you to "dream bigger" with Leo.

The following script creates a list of all positions having an icon, that is, an outer uA dict with a 'lineYOffset' key.

    aList = [p.copy() for p in c.all_unique_positions() if 'lineYOffset' in p.u]
    print('\n'.join([p.h for p in aList]))

Yes, the lineYOffset key is wonky and unhelpful, but it can't be changed now.  Hmm, maybe the code could support an an alternative clearer key, say str_core_icon.  Furthermore, the str_core_* keys should probably be reserved for Leo's core.

Important: If you don't understand these lines, please study Python's list comprehensions.  They are incredibly useful. '\n'.join(aList) is a great idiom to know.  str.join is one of python's most useful string methods. It converts between lists and strings.

Imo, Leo should have p.temp_u and v.temp_u properties, so that getting and setting temp uA's will be as easy as getting and setting uA's. I'll do this today.

These Code Academy threads are having an immediate impact.  Focusing on simple, practical tasks has revealed rough spots in both Leo's code and Leo's docs.

As always with the Code Academy, questions and comments are strongly encouraged. Make sure you understand the code examples in this post. They are the foundation for programming in Leo.
.. @+node:ekr.20160129101736.1: *4* icons
@language rest
@wrap

During our conference call, someone asked whether nodes may have more than one icon.  Indeed they can.

For example, running this script will insert three icons. Running the script again will insert three more.

@language python

    table = (
        'edittrash.png',
        'connect_no.png',
        'error.png',
    )
    for icon in table:
        fn = g.os_path_finalize_join(g.app.loadDir,
            '..', 'Icons', 'Tango', '16x16', 'status', icon)
        if g.os_path_exists(fn):
            c.editCommands.insertIconFromFile(path=fn)
        
@language rest
@wrap
        
With a minor change to Leo's core, it is now easy to delete the icons of the node at position p:

    c.editCommands.deleteNodeIcons(p=p)
.. @+node:ekr.20160129103813.1: *4* git
If you are going to do interesting work on Leo and its plugins, you should be using Leo’s latest sources from GitHub using git. Once git is installed, getting the latest version of Leo is easy:

    git clone https://github.com/leo-editor/leo-editor.git

Once you have done that, you can get the latest sources with:

    git pull

Git is great in tracking history and reverting unwanted changes. And it has many other benefits.

I've been wondering when to say this, but recent developments have forced my hand.  Today, as the result of our Code Academy discussion, I have added the p.u property and a keyword arg to c.editCommands.deleteNodeIcons.  If you don't use git you will quickly get out of the loop.

Although git is unique behind the scenes, using git is very similar to using bzr or hg or any other SCCS.  To change Leo, you add files, you commit files, and you push files.  That's about it.

I'll be happy to answer any git-related questions here.  Again, I strongly encourage all would-be Leo programmers to use Leo's git repo.
.. @+node:ekr.20160225050421.1: *4* Code Academy: find by predicate or attribute
@language rest
@wrap

Writing the cffm and cfam commands was snap using c.cloneFindByPredicate, a powerful new addition to Leo.

Here is the entire code for the new commands:

@language python

    @cmd('clone-find-all-marked')
    @cmd('cfam')
    def cloneFindAllMarked(self, event=None):
        '''The clone-find-all-marked command.'''
        self.cloneFindMarkedHelper(flatten=False)
        
    @cmd('clone-find-all-flattened-marked')
    @cmd('cffm')
    def cloneFindAllFlattenedMarked(self, event=None):
        '''The clone-find-all-flattened-marked command.'''
        self.cloneFindMarkedHelper(flatten=True)

    def cloneFindMarkedHelper(self, flatten):
        '''Helper for clone-find-marked commands.'''
        
        def isMarked(p):
            return p.isMarked()
            
        self.cloneFindByPredicate(
            generator = self.all_unique_positions,
            predicate = isMarked,
            failMsg = 'nothing found',
            flatten = flatten,
            undoType = 'clone-find-marked',
        )
        
@language rest
@wrap

It's hard to imagine anything simpler. **Important**: the predicate could filter on an attribute or *combination* of attributes. For example, the predicate could return p has attributes A and B but *not* attribute C. Instantly we have full database query capabilities. If we then hoist the resulting node we see *all and only* those nodes satisfying the query.
        
Here is c.findNodeByPredicate. **Important**: Rev c8a3581c9b corrects a serious blunder in c.cloneFindByPredicate. Don't use previous versions!

@language python
    
    def cloneFindByPredicate(self,
        generator,     # The generator used to traverse the tree.   
        predicate,     # A function of one argument p, returning True
                       # if p should be included in the results.
        flatten=False, # True: Put all matches at the top level.
        undoType=None, # The undo name, shown in the Edit:Undo menu.
                       # The default is 'clone-find-predicate'
    ):
        '''
        Traverse the tree given using the generator, cloning all positions
        for which predicate(p) is True. Undoably move all clones to a new
        node, created as the last top-level node. Arguments:
    
        generator,      The generator used to traverse the tree.
        predicate,      A function of one argument p returning true if
                        p should be included.
        flatten=False,  True: Move all node to be parents of the root node.
        undo_type=None, The undo/redo name shown in the Edit:Undo menu.
                        The default is 'clone-find-predicate'
        '''
        c = self
        u, undoType = c.undoer, undoType or 'clone-find-predicate'
        clones, seen = [], set(), 
        for p in generator():
            if predicate(p) and p.v not in seen:
                if flatten:
                    seen.add(p.v)
                else:
                    for p2 in p.self_and_subtree():
                        seen.add(p2.v)
                clones.append(p.copy())
        if clones:
            undoData = u.beforeInsertNode(c.p)
            root = c.createCloneFindPredicateRoot(flatten, undoType)
            # This was botched in previous versions.
            # The result was low-level vnode failures.
            for p in clones: 
                clone = p.clone()
                clone.moveToLastChildOf(root)
            u.afterInsertNode(root, undoType, undoData, dirtyVnodeList=[])
            c.selectPosition(root)
            c.setChanged(True)
            c.redraw()
        else:
            g.es_print('not found:', undoType)
.. @+node:ekr.20160303072516.1: *3* To be documented
.. @+node:ekr.20160303072543.1: *4* Add to FAQ: Leo Dark on Linux
Zoom.Quiet: Leo Dark on Linux
https://groups.google.com/d/msg/leo-editor/B3_1e9k69oQ/cLKXFq_fXw8J

I've played a bit with my theme since I wanted a dark one in order to save my eyes. Here is a screenshot:
https://lh3.googleusercontent.com/-kb-RnBVq8zU/VIlThQ9MGuI/AAAAAAAAAD8/j-AAOKiHvFI/s1600/leo-dark-ubuntu.png

It's pretty straightforward to get it :
 - install this nice theme : http://gnome-look.org/content/show.php/HackStation?content=167255

 - then just override Leo's qt style sheet by adding an empty @data qt-gui-plugin-style-sheet to your @settings

 - I struggled a bit to finally find out that the only settings that are not handled by qt are the log pane text colors, so add those settings :
-  @color log_text_foreground_color = #93a1a1
@color log_error_color = #dc322f
@color log_warning_color = #268bd2

Finally, I've made a pack of transparent icons to be used more generically :
@string color_theme = transparent
.. @+node:ekr.20160303073053.1: *4* Leo in virtualenv
https://groups.google.com/d/msg/leo-editor/LePOMe_ckeg/_UasKCKP6NMJ

Some time ago there were a discussion about Leo in virtualenv.

Now I could test it in Python3, PyQt5 on Kubuntu:

Here are the steps (I worked in a folder with write permission '/leo'):

1. Install PyQt5 in the system:

sudo aptitude install python3-pyqt5

2. Create the virtual environment with the '--system-site-packages' switch and without pip (I've found this the only way, which worked):

pyvenv-3.4 --system-site-packages --without-pip py3-pyqt5

3. Install setuptools and pip into the created environment:

wget --no-check-certificate https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py -O ez_setup.py

py3-pyqt5/bin/python ez_setup.py --insecure

wget --no-check-certificate https://pypi.python.org/packages/source/p/pip/pip-6.0.8.tar.gz#md5=2332e6f97e75ded3bddde0ced01dbda3

tar xzvf pip-6.0.8.tar.gz

cd pip-6.0.8

../py3-pyqt5/bin/python setup.py install

cd ..

Now you can install what you want in the created environment, without affecting the system.

py3-pyqt5/bin/pip install Sphinx

4. From the leo-editor source folder launch Leo with the new interpreter:

In my case:

/leo/py3-pyqt5/bin/python launchLeo.py
.. @+node:ekr.20160303073516.1: *4* Rev 419a82d changes handling of orphan bits
April 15, 2015

Rev 419a82d changes several aspects of how Leo handles the so-called orphan bit in vnodes.  These are major changes, but I believe they will be for the best.

The orphan bit indicates that there was a problem writing an @<file> node.  It will be set, for example, when an @file node contains children but has no @others directive.  Leo simply cannot write the external file in that case.

However, Leo went overboard with the error logic. Here are the recent changes:

1. Leo no longer writes the orphan bit ('O' bit in vnode attr) in .leo files. This kind of persistent error bit seems unwise.

2. Leo clears the bit and issues a warning when reading a vnode with the 'O' attr.

Previously, Leo would refuse to update the outline from the external file if the orphan bit was set! 

This change could have unforeseen consequences, but I suspect nobody will ever notice.  The foreseen consequence is that Leo will keep the outline and external files in synch more often.
.. @+node:ekr.20160303073917.1: *4* ENB: Instant history of a code checking breakthrough
June 7, 2015: The code is now in leoCheck.py.

There has been an amazing breakthrough in code analysis.  Not sure where it will lead, or how much more work I shall do on this project.

This is an Engineering notebook post.  You can safely ignore it.

This is an "instant" history of work completed in the last few days.  I am writing this now, before the details blurred. I'm pretty sure I have remembered the general timing of events correctly.

On Wednesday, June3, I posted a "farewell" message on the static type checking group.  But, that just got me thinking about code analysis again :-) Sigh.  This post discusses some intuitions.

On Thursday, June 4, I reviewed my old code analysis code.  I know it was Thursday because I was reviewed all of its problems while driving to a swim lesson.  In short, the code was clumsy and inflexible.

Sometime later, perhaps that night, I started revising one of my old tests. I stumbled across two major simplifications:

1. I revised the testing framework so that there would only ever be one "test".

For backup, a copy of the testing framework, @@button show-data, is in the attic (leoNotes.txt).  Originally, all the code was in a Test class defined as a child of the @button node.  The code soon moved into the new leoCheck.py file.

2. As a prototype, I decided to use regular expressions to "parse" the source code.

I had become aware of how fast regular expressions can be by studying Python's tokenizer code in Lib/tokenize.py.  That's probably what had me choose re's for the prototype.

Using regex's turned out to be a stupendous bit of good luck! My focus shifted from all the technical details of traversing parse trees to what I actually wanted to see, namely the relationships between definitions of functions/methods and all the calls to and returns from those routines.

The prototype code created globals dictionaries of classes, defs, calls to defs and return statements.  The show_results method created reports, organized by def name.

The result was amazing!  In just a few hours work I had a better picture of Leo's code than I had been able to produce in months of work with the old stc project.  Here is just one example:

printGc
    2 definitions...
        leoGlobals.py: def printGc(tag=None):
           leoTest.py: def printGc(message=None):

    1 call...
        leoTest.py::runGc: printGc(message=message)

    2 returns...
        leoGlobals.py: return None
           leoTest.py: return delta

The present code doesn't always find all calls to a function, partly because calls to F can have a prefix, like g.F.

Calls to library functions do not show up in such reports.  Instead, they are listed separately.  For example, here is the entry for the currentItem Qt method:

currentItem 4 calls...
          LeoQtTree::getCurrentItem: w.currentItem()
      LeoQListWidget::get_selection: self.currentItem()
    LeoQListWidget::select_callback: self.currentItem()
       LeoQListWidget::tab_callback: self.currentItem()

And here is the decode function from the standard library:

decode 4 calls...
    ZimImportController::parseZimIndex: urllib.unquote(result[2]).decode('utf-8')
              leoGlobals.py::toUnicode: s.decode(encoding,'strict')
              leoGlobals.py::toUnicode: s.decode(encoding,'replace')
    ZimImportController::parseZimIndex: result[1].decode('utf-8')


By Friday afternoon I was in a state of shock. I kept shaking my head, telling Rebecca how I couldn't believe how lucky I was to have stumbled upon using regex's.  I kept saying that I could never have created these reports had I been focused on parse trees.

Getting real

The simple regex's I used do not handle strings or comments properly.  My first thought was that perhaps the tokenizing beautifier could "parse" the code easily. Friday evening I played around with this approach, but I quickly realized it was going nowhere.

Here is the checking log for 72658e8, Friday, June 05, 2015 10:24:06 PM:

QQQ
Added an alternative tokenizing implementation, but...Wow: the prototype using simple line-oriented regex's and string find is MUCH simpler and faster than using tokenizing code.
QQQ

Early (1 a.m.) Saturday morning, thoughts about translating the regex-based prototype to an parse-tree based code did not allow me to sleep.  Using the prototype as a guide path, it took about 6 hours to create the present code.

Yes, in theory, I could have written the Ast traversers without the prototype, but in practice I would never have thought to do things this way.  I have found a cool new pattern by pure luck.

Here is the Ast Visitor for FunctionDef nodes in the ShowDataTraverser class:

# FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)

def do_FunctionDef(self, node):
    # Format.
    args = self.formatter.format(node.args) if node.args else ''
    s = 'def %s(%s):' % (node.name, args)
    if self.trace: g.trace(s)
    # Enter the new context.
    context_tuple = self.fn, 'def', s
    self.context_stack.append(context_tuple)
    # Update controller data.
    def_tuple = self.context_stack[: -1], s
    aList = self.controller.defs_d.get(node.name, [])
    aList.append(def_tuple)
    self.controller.defs_d[node.name] = aList
    # Visit.
    for z in node.decorator_list:
        self.visit(z)
    self.visit(node.args)
    for z in node.body:
        self.visit(z)
    # Leave the context.
    self.context_stack.pop()

This is the simplest possible code! Instead of dealing with Ast nodes, this code using only strings.  s describes the function. The context stack contains strings describing enclosing def and class nodes.

Instead of injecting data into Ast nodes, the code creates entries in global dictionaries in the "controller" object, in this case, self.controller.defs_d.

Speed

The ShowDataTraverser class is a subclass of the AstFullTraverser class in leoAst.py.  All visitors must explicitly visit subnodes.  As a result, the visit method collapses:

def visit(self, node):
    '''
    Visit a *single* ast node.
    Visitors are responsible for visiting children!
    '''
    method = getattr(self, 'do_' + node.__class__.__name__)
    method(node)

Clearly, this is the fastest possible way to traverse parse trees.

Traversing parse trees is significantly faster than using tokens, and is almost as fast as using improper regex's:

Parse trees: 3.8 sec to generate all reports.
Tokens: 3.3 sec just for tokenizing.
Regex: 2.2 sec to generate all reports.

Here are the figures for the latest run over all of Leo's core files:

files: 69 lines: 86,312 chars: 3,534,400 classes: 210
defs: 3,994 calls: 6,682 undefined calls: 2,090 returns: 2,179
run done:  3.8 sec.

The statistic for undefined calls is probably inaccurate.

Further work

The present project has already demonstrated, for the first time, that my intuitions about code are reasonable.

The reports gather all data about a routine in one place.  In most cases, the names of def args correspond in an obvious way to the names of call args. Imo, this what allows us programmers to have confidence in our code.  We certainly do not do type analysis!

That is, the names of functions and ivars often indicates their types types.  Yes, the names can be misleading, which is why pylint is useful ;-)

Using only strings can create problems.  One idea is to use the Ast nodes (or their id's) as dictionary keys.  Easy: do_FunctionDef will just set node_tuple to def_tuple = node, self.context_stack[: -1], s

It would be possible to add information about assignments to vars and ivars merely by adding Ast visitors for assignments.  That way might lead to full type checking.  Not sure I'm going to do that.

There are a number of bugs in the reports.  I'll look into them. Furthermore, it's tempting to reorganize dictionaries in new ways.

Summary

It is almost infinitely easier to deal with Python dictionaries than to deal with Ast trees!

The prototype created a new pattern.  Node visitors have no smarts.  They simply create entries in global dictionaries.  Later code can analyze the dictionaries.

Enough for now.  I think I've described the big picture well enough.

Edward

P. S. The prototype code is no longer in leoCheck.py.  It's in the attic, in the node:

    A great prototype: scan (inaccurate) & helpers
.. @+node:ekr.20160303074234.1: *4* Find now shows status
June 22, 2015

After a find command completes (successfully or not), the status areas shows:

- Whether the find command completed successfully.
- The find options in effect for the search.

Previously, the status line was only updated for unsuccessful searches, and it did not contain the find options in effect.  The new status line is much more helpful than the old.

.. @+node:ekr.20160303074307.1: *4* Improved @wrap
June 22, 2015

Leo now immediately wraps the body pane when @wrap is in effect.

Previously, the user had to reselect the node when typing "@wrap".  Now, the colorizer ensures that wrapping is on, so wrapping happens immediately.
.. @+node:ekr.20160303093954.1: *4* A real-world example of cff
@language python

tc = c.theTagController
people, teams = None, None
for p in c.rootPosition().self_and_siblings():
    if p.h.lower() == 'people':
        people = p.copy()
    if p.h.lower() == 'teams':
        teams = p.copy()
tasks = c.lastTopLevel().insertAfter()
tasks.h = 'Tasks'
table = (
    (people, 'People'),
    (teams, 'Team'),
)
for group, h in table:
    if not group: continue
    root = tasks.insertAsLastChild()
    root.h = '%s Tasks' % h
    for child in group.children():

        def isOpenTask(p):
            tags = tc.get_tags(p)
            return 'open' in tags and 'todo' in tags and child.isAncestorOf(p)

        # Requires Rev dcd63426e22 or later.
        # Prevents flash due to extra redraws.
        p = c.cloneFindByPredicate(
            generator = c.all_unique_positions,
            predicate = isOpenTask,
            flatten = True,
            redraw = False, # Prevents flash.
            undoType = 'cfa-todo')
        if p:
            p.h = child.h
            p.moveToLastChildOf(root)
c.selectPosition(tasks)
tasks.expand()
# optional:
# c.hoist()
c.redraw()
.. @+node:ekr.20160303114324.1: *4* Controlling Leo remotely
Terry Brown July 29, 2015

Controlling Leo remotely
https://groups.google.com/d/msg/leo-editor/wWWUgfDhPi4/VmRRRa_xDAAJ

Prompted by the IRC discussion today, I've added remote code execution
abilities to mod_http.py  Relevant part of the doc.s pasted below.

This is a plus for a couple of reasons - previously you had to use
the leoremote plug-in which used sockets and was really python only,
this new approach just uses HTTP GET requests which can be generated by
almost anything (language, link in a doc., browser bookmark, etc.).
Also leoremote doesn't work in Python 3.x.

This code to load a file into Leo from the command line:
https://github.com/leo-editor/snippets/blob/master/utils/led.py

Can be replaced with this version:
https://github.com/leo-editor/snippets/blob/master/utils/led.sh

Executing code remotely
-----------------------

.. warning::

    Allowing remote code execution is a **HUGE SECURITY HOLE**, you need to
    be sure that the url from which you access Leo (typically
    http://localhost:8130/) is accessible only by people and software you trust.

    Remote execution is turned off by default, you need to manually / locally
    change the @setting ``@bool http_allow_remote_exec = False`` to ``True``
    to enable it.

Commands to be executed are submitted via HTTP GET requests, which can
be generated in almost any language and also triggered from shortcuts,
links in other documents or applications, etc. etc.

The basic form is::

    http://localhost:8130/_/exec/?cmd=<python code for Leo to execute>

The query parameters are:

``cmd`` (required)
    A valid python snippet for Leo to execute.  Executed by
    the ``vs-eval`` command in the ``valuespace`` plug-in.  Can be
    specified multiple times, each is executed in order.  May contain
    newlines, see examples.
``c`` (optional)
    Which currently loaded outline to use, can be an integer, starting
    from zero, or the full path+filename, or just the base filename.
    Defaults to 0 (zero), i.e. the "first" open outline.
``enc`` (optional)
    Encoding for response, 'str', 'repr', or 'json'.  Used to render
    the returned value.
``mime_type`` (optional)
    Defaults to ``text/plain``.  Could be useful to use ``text/html`` etc.

A special variant url is::

    http://localhost:8130/_/exec/commanders/

which returns a list of open outlines.

Examples
========

This command::

    curl http://localhost:8130/_/exec/?cmd='c.bringToFront()' >/dev/null

will raise the Leo window, or at least make the window manager signal the
need to raise it.

::

    curl --get --data-urlencode \
      cmd='g.handleUrl("file:///home/tbrown/.leo/.contacts.leo#Contacts", c)' \
      http://localhost:8130/_/exec/ >/dev/null

will cause a running Leo instance to open ``/some/path/contacts.leo`` and select
the ``Contacts`` node.  A desktop icon link, browser bookmark, or link in a
spread-sheet or other document could be used the same way.

In the ``bash`` shell language, this code::

    TEXT="$@"
    curl --silent --show-error --get --data-urlencode cmd="
        nd = c.rootPosition().insertAfter()
        nd.h = 'TODO: $TEXT'
        import time
        nd.b = '# created %s' % time.asctime()
        c.selectPosition(nd)
        c.redraw()
        'To do item created\n'
    " http://localhost:8130/_/exec/

could be written in a file called ``td``, and then, assuming that file is
executable and on the shell's path, entering::

    td remember to vacuum the cat

on the command line would create a node at the top of the first open outline in
Leo with a headline ``TODO: remember to vacuum the cat`` and a body text ``#
created Wed Jul 29 16:42:26 2015``. The command ``vs-eval`` returns the value of
the last expression in a block, so the trailing ``'To do item created\n'`` gives
better feedback than ``None`` generated by ``c.redraw()``.
``c.selectPosition(nd)`` is important ant to stop Leo getting confused about
which node is selected.
.. @+node:ekr.20160303114520.1: *4* NEW: Edit Settings menu
Terry Brown August 23, 2015
https://groups.google.com/d/msg/leo-editor/pM8aVJ1D6ao/Z8lq43t7FAAJ

There's now an "Edit settings" menu under the main Settings menu.

It's not going to make everyone (anyone?) happy, you still have to edit
the content of a Leo headline to change font size etc.  The new
functionality is that it finds the appropriate setting and copies it to
the appropriate outline for you, so knowing what to look for and how to
manage it is handled.

Sometimes you'll see this:

    The relevant setting, '@bookmarks_base_color', is using the value of
    a more general setting, '@text-foreground'.  Would you like to edit
    the more specific setting, '@bookmarks_base_color', or the more
    general setting, '@text-foreground'?  The more general setting may
    alter appearance / behavior in more places, which may or may not be
    what you prefer.

                            Edit specific   Edit general   Cancel

Wordy, but I think easy enough to follow.  I guess everything after the
last comma could be deleted :-)

If the setting is in leoSettings.leo, you see:

    The setting '@body-font-family' is in the Leo global configuration
    file 'leoSettings.leo' and should probably be copied to
    'myLeoSettings.leo' before editing.
    It may make more sense to copy a group or category of settings.

    Please enter 1, 2, 3, or 4:
    1. copy the one setting, '@body-font-family'
    2. copy the setting group, 'Body font' (Recommended)
    3. copy the setting whole category, 'Fonts'
    4. edit the setting in 'leoSettings.leo' anyway

Again, wordy, but I think easy enough to understand.

(Having to enter a number to pick an option is clunky, a
 gui-independent 'pick item from list widget' can be added to Leo, I
 just didn't want to mix that task into the current task.)

Note "Reload settings" isn't working as effectively as I think it
should, that may need to be addressed as well.  Unrelated to the new
code.

So, this isn't a silver bullet for the newbie setting editing woes, but
it does eliminate a lot of the Leo specific knowledge required (apart
from "edit a headline").  Also this new approach can be developed
further based on feedback, just wanted to get what I had so far into
the main branch for testing etc.
.. @+node:ekr.20160303114700.1: *4* A note to new users
John Lunzer, August 30, 2015
https://groups.google.com/d/msg/leo-editor/WupMUqlclaQ/dtAjRiytFgAJ

A new user recently said to me, "Leo is powerful and flexible -- and complex and bewildering". This is true. I believe it is always the goal of developers to make their software less complex and bewildering but keep in mind that Leo has been in development for over 20 years and has ~1.5 million lines of code (IIRC). This puts it right up there with Vim and Emacs in terms of maturity. My own experience with Vim and Emacs have been quite similar to my experience with Leo. All three are powerful and flexible and complex and bewildering in their own right.

I believe with tools of this weight and impact, there will always be an investment in learning them. They're all vast forests of features filled with hidden treasures and in the case of each of them he/she that invests in the tool will be rewarded for their effort. It is, however, the responsibility of the community (led by the developers) to help make that treasure hunt as enjoyable and adventurous as possible, as any good treasure hunt should be. 


===============
Geoff Evans, September 1, 2015

As the 'new' (since 2009) user John mentioned, I totally endorse what he says about how friendly and helpful the Leo community is in dealing with questions.   But I'm also old enough to be fond of written documentation.  This note is one offering towards Edward's desire for outreach to more users and how the documentation could serve that purpose.  I am looking for something that will persuade a non-user to try leo, and persuade a new user that a small effort in learning a bit more often brings a big reward.  Years of editing and reviewing for international scientific journals, plus decades of making my own mistakes, have taught me the value of just-in-time delivery of ideas, and of writing to the interface not the implementation.  So before even the Tutorial (which is still basically about How rather than What and Why) I envisage a section built around people's needs and indicating how they would go about meeting them with Leo.  Something like (trying to use the format in Jacob Peck's scripting example):
-A Taste of Leo
  Leo is a system that lets you enter information and keep track
  of how it's organized.  Leo's main window has two large parts 
  that contain your information:  an outline pane toward the top
  left and a body pane [I always toggle the split direction] on
  the right.  The body pane contains information related to the
  highlighed headline in the outline pane; headline and body pane
  together are referred to as a node.
    -Staples
      There are many ways to instruct Leo: commands, directives,
      scripts, buttons, abbreviations ....  This part gives
      brief examples of the kind of thing each does.
        -Command
          Does something immediately.
          You want to insert a new node into your outline:
            Alt-X insert-node  [Ctrl-I]
          Typing 'Alt-X' put you in a minibuffer at the bottom of
          the main window, where you type the rest of the 
          command.  This is such a common command that there is a
          keyboard shortcut for it.  But there are scores of
          commands, most of which have to be entered the Alt-X
          way (tab completion can make it less onerous).
          You want to seach for something in the outline:
            Alt-X find   [Ctrl-F]
          is a flexible command that, for example, lets you 
          search only headlines, and offers search-and-replace.
        -Directive
          Doesn't do anything immediately, but sets up ground
          rules that will be followed in that node and all 
          children until overridden.
          You want syntax colouring appropriate the the language
          you're programming in
            @language python
          turns it on.
          You want to save a subtree in an external file where
          another program can access it.
            @file file.name
          directs that the node and all children will be saved in
          a separate file called file.name .
        -Setting
          Controls how a whole Leo session will look.
          You always want your body pane to the right of the
          outline pane, whereas by default Leo will put it below.
          Edit the file myLeoSetttings.leo (which you access by
          clicking the Settings tab near the top of the main
          window -- or the Help tab in older Leo versions such
          as the picture in the current Leo5.1 documentation) by
          adding a line
            @bool split_direction = vertical
          Settings don't take efffect immediately, but only in
          the next leo session you open.  [Though when you're
          experimenting to see how they work, you can put a
          @settings tree in the outline you're working on,
          add your lines there, and they take effect when you
          save and reopen the file in the same Leo session.]
        -Script
          I can't give an example of something I want that a 
          script will do for me.
    -Treats
      This is the place to put some representative gems.  I seem
      to recall Edward suggesting this somewhere in the thread on 
      Leo's future, though I can't find it now.  But they have to
      be things that make a new user say: "I hadn't thought of
      using Leo for that.  Now that I think of it, I can see
      wanting to.  I'm confident now I can work out how for my
      own needs."  
      But the first treat is obvious:
        -Clone
          You have a task that belongs in Project A, that you 
          need to work on next week.  So you enter a node for
          the task under <Project A>, type Ctrl-` , and you have
          a copy of the node you can move to under <Do next week>
          *and* when you modify your description in one place,
          the same modifications happen in the other.
Okay, that's enough ignorant comment from me.  People who really know Leo can correct all the mistakes I've made and add more and better treats and examples.  
One other thought:  there are places where the documentation has "Go here for help" links.  If they were to point to the leo-editor-users group, rather than leo-editor, people might be less inhibited about using them.  It would feel less like interrupting the work of the developers.

And this is where Leo does not falter, in the helpfulness of its community (small though it may be). I will reiterate what Edward has said many times, do not struggle on your own if you are lost, confused, or bewildered. Please ask questions. If the documentation or examples do not meet your needs, please ask questions. In my own experience as a once new user (though there may be the occasional disagreement) you will not be chided, scorned, or belittled but will be met with more even more help than you originally asked for. 
.. @+node:ekr.20160303115117.1: *4* Why Leo is noteworthy
https://groups.google.com/d/msg/leo-editor/F-WA_OpHKPA/xPJNpHR8CgAJ

This post discusses what I think matters most about Leo. This post assumes you are an experienced Leo user.  It does not try to duplicate Leo's Tutorial.

This post will be pre-writing for a version that will be posted to Leo's web site. All comments are welcome.

Leo is a superb tool for understanding, studying and organizing any kind of complex data, including computer programs. The first great Aha in Leo's history was that webs (literate programs) are outlines in disguise. Leo's importers (@auto) make it easy to studying other people's programs. Leo's always-present outline structure clarifies overall program structure and makes many kinds of comments unnecessary.

Leo is a superb browser for code and data. Unlike many other folding editors, Leo remembers which nodes were expanded when you last saved an outline. This is surprisingly important. And Leo's clones let you organize any data as you want, even if all folds are collapsed.

Leo is a uniquely powerful scripting environment. This power comes from three sources: Leo's API, Leo's ability to compose scripts from outlines and Leo's underlying data structure, a Directed Acyclic Graph, the basis for Leo's clones.

Leo's API consists primarily of generators, such as c.all_positions(), p.self_and_subtree(), etc. and properties, such as p.b, p.h, p.gnx and p.v.u.  Leo's API makes it trivial to write scripts to access or change any node. AFAIK, these capabilities are unique.  Simulating them in vim or Emacs is possible, but so is simulating Python's capabilities in C...

Afaik, no other scripting environment allows you to compose scripts from outlines.  @file, @clean, @auto, @others and section references and definitions make this possible.  Section references and definitions are modeled on the noweb language, but all of Leo's script composition features are fully integrated into Leo's outline structure.

Leo's outline nodes have headlines (p.h) and body text (p.b) and extensible information (p.v.u).  Headlines are descriptions (meta-data) of the data in p.b and p.v.u.  Scripts can rapidly discover and categorize data using metadata.  Leo's @ convention for headlines (@clean, @file, @auto, @html, etc.) show how extensible this node typing is.

So much for the theory.  The following also are important in practice:

- Native scripting in Python, with full access to all of Leo's sources.
- Leo's plugin architecture.
- Leo's rst3 command, vim, xemacs and ILeo (IPython bridge), and leoBridge module.
- Leo's minibuffer commands, borrowed shamelessly from Emacs.
- @test and @suite: Leo's outline-oriented unit testing framework.
- @button: bringing scripts to data.
- Leo's outline-oriented directives.

The invention/discovery of @clean earlier this year completes Leo is some sense.

Acknowledgements: Working with Leo's community of Leo's developers and users has been a great pleasure for over 20 years. My only regret is that Bernhard Mulder and Bob Fitzwater are no longer with us. Both made essential contributions. Bob Fitzwater was my mentor. He gently pushed me to consider design, not just "bit twiddling".  Bernhard Mulder contributed two of the most important elements of Leo: Leo's traversers (generators) and the original @shadow algorithm.  Neither @clean nor the revised Mulder/Ream algorithm could possibly have happened without him.  I miss both these great thinkers.  Both would have been proud of what they helped create.

A successful software tool is one that was used to do something undreamed of by its author.'
-- Stephen Johnson

Leo is a wild success on this score. I foresaw none of these developments 20 years ago:  Leo's minibuffer, @button, @test, @auto, @clean, Leo's plugin architecture, the rst3 command, the Leo bridge and the IPython bridge.  Surely many other features and uses could be added. None of these would have happened without Leo's community of brilliant people. These features create the Leonine world.  Who knows what will be the result...

Edward

P. S. As I write this, I see that @button is nowhere mentioned in Leo's History Chapter.  That's crazy: @button is arguably the most brilliant scripting idea ever created anywhere.  Many thanks to 'e', whoever you are.  I'd like to thank you by name.  @button lead directly to @test.
.. @+node:ekr.20160303115314.1: *5* Offray Cárdenas
Offray Cárdenas

This idea of an always present outline has been key to me for organizing writings. Some coworkers have found in the past that this helps them when we're correcting their text. On a sightly off-topic, most of them are school teachers making their master studies on education. Some of them were doctors working on writing complex documents. They're good at what they do, but having not technical expertise on computers (or not the proper permissions on school and office machines to install their software, so they weren't unable to continue using Leo)

-----

> Leo's clones let you organize any data as you want, even if all folds are collapsed.

For me this is the most powerful but misunderstood feature of Leo. Most of the people which compares it with other IDE rant about why Leo doesn't works more automatically imposing structure, but in Leo you're in charger. You impose infrastructure.


-----

For me the second main insight of Leo (besides emergent always present tree structure on almost any file) was to have a tree that is a programmable structure that can be understood and changed by any node inside that tree. I think that Leo brings structure and self-referentiality to the dumb flat file word. So you can create a tree from one (or several) files, deconstruct and reconstructut it they way you want and automatize the way in behaves and talks with the external world. Previously I had compared Leo with the Smalltalk object in the sense that it makes for files kind of what Smalltalk makes for objects. The more I start to focus on interactive writing and going away of the unix inspired OS world, the more the second insight become important to me. I didn't need to deconstruct/reconstruct or impose structure over flat files but to use outlining for structure thought by (interactive) writing and I need the outline be a fully programable object. That's the essence of most of my Leo experience and what I'm trying to bridge with the Pharo Smalltalk world (with the advantage of a fully introspective, portable and moldable computing and visualization environment)

Thanks for Leo and all the key inspiration it brings. And, as always, thanks to the Leo community for the food for thought.
.. @+node:ekr.20160303115506.1: *5* Speed's comments
My only input is what makes Leo so special to me.

After learning just a few things about Leo, and after replacing << section references >> mostly with @others,
writing code becomes a game rather than a chore.

As soon as an idea becomes complicated, I add a new @others, and break down the complication into chunks until all the complications are now simple.

I'll typically clone that section an the bottom of the outline, then add enough logic at a parent level so that the complication can be tested with control B.

This is my backward implementation of unit testing. This kind of 'unit testing' never has to be refactored when the code is (invariably) improved.

The cloned 'test piece' can be relegated to a testing section, and the new chunks subsequently cloned into whatever structure make real sense for the project.

In practice, this is just fun for me.

Coding without Leo is not not really fun any more. I recently finished a c++ socket server using Microsoft's Visual Studio, in concert with someone who didn't have Leo. Microsoft's tools are great, and the project went off without a hitch,  but the fun was just plain gone.

Anyway, thanks for the great perspective on Leo.
.. @+node:ekr.20160303115722.1: *4* Make stub files
For several years now I have been attempting to do something interesting re type checking.  Yesterday, that effort finally bore fruit. This post explains the make-stub-files command (see recent revs), tells why it is important and how it can be improved.

Executive summary

The make-stub-files does for type/design analysis what the c2py command did for converting C to python.  The command eliminates most of the drudgery associated with creating python stub (.pyi) files. This makes it possible to use mypy without changing Leo's source code.

What the command does

The make-stub-files command makes python stub (.pyi) files for @<file> x.py nodes "close" to the selected node.

Stub files are discussed in pep484 (type hints) and also this page in the mypy documentation. Stub files contain function annotations (pep 3107) for the mypy type checker.  Leo can't use annotations because they raise syntax errors in Python 2.x.

The make-stub-files command is very simple. It walks the ast (parse) tree for x.py, writing annotations for all defs and classes to the corresponding x.pyi file in the ~/stubs directory.  This is the default directory for mypy stubs.

The make-stub-files command knows nothing about types!  It only knows about naming conventions.  At present, this knowledge is hard-wired into this Python dictionary:

    {
        'aList': 'Sequence',
        'aList2': 'Sequence',
        'c': 'Commander',
        'i': 'int',
        'j': 'int',
        'k': 'int',
        'node': 'ast.Ast',
        'p': 'Position',
        's': 'str',
        's2': 'str',
        'v': 'VNode',
    }

This is a good start for Leo's own source code. It will be generalized using one or more @data nodes.  We want to be able to specify default conventions that can be overridden on a file-by-file basis.

It's easy for the command to use these conventions for function arguments.  For example, the dict above says to replace:

    def foo(s):
        return s

by

    def foo(s: str):
        return s

The command handles function returns is in a pragmatic way.  The tree walker simply associates a list of return expressions with each def.  For example, here is the output at the start of leoAst.pyi:

class AstDumper:
    def dump(self, node: ast.Ast, level=number) ->
        str%(name,sep,sep1.join(aList)),
        str%str.join(str%(sep,self.dump(z,level+number)) for z in node),
        str%(name,str.join(aList)),
        repr(node): ...
    def get_fields(self, node: ast.Ast) -> result: ...
    def extra_attributes(self, node: ast.Ast) -> aList: ...

Notes:

1. The stub for the dump function is not syntactically correct because there are 4 returns listed. It is up to a human to specify a proper return type.  In this case, all the returns are obviously (to a human) strings, so a human could replace the first stub by:

    def dump(self, node: ast.Ast, level=number) -> str: ...

2. At present, the command makes no substitutions for aList, etc. within return values.  It will do so fairly soon.  So the stub for extra_attributes would become:

  def extra_attributes(self, node: ast.Ast) -> Sequence: ...

3. The present dictionary contains only class names, but type aliases could also be used to make the results clearer. The definitions of these aliases could be added by hand at the start of the stub file, or could be automatically inserted somehow.

4. Not all types are obvious from naming conventions. In that case, the human will have to update the stub using the actual source code of the def as a guide. For example, the type of "result" in get_fields could be just about anything.  Actually, it is a list of strings.

Why this command is important

1. The command eliminates most of the drudgery from creating stub files. Creating a syntactically correct stub file from the output of the command is straightforward.  The command will be made more flexible using @data nodes.

2. The make-stub-files code does no type inference.  This is a giant breakthrough. We can gain the benefits of mypy without doing anything clever.

The make-stub-files command is much simpler than c2py. The StubTraverser class overrides only three (simple!) visitors.  The  base AstFullTraverser class does all the other work. The format_returns method could be improved as discussed above, but even as is the command is extremely useful.

3. Stub files are real data.  Mypy will check the syntax for us. More importantly, mypy will do its type inference on the stub files.  That means that mypy will a) find errors in the stubs and b) actual type errors in Leo. There is now a simple way to use mypy!

4. Stubs express design intentions as well as types.  In most cases, programmers do know the expected types of arguments. Up until now, there has been no official/practical way of expressing this knowledge in Python 2.

5. One could imagine a "reverse" command that would inject function annotations into files from stub files. The command would be about as simple as make-stub-files.

Edward

P.S. The make-stub-files command works as follows:

1. It creates the stub file, x.pyi, if c.p (the selected node) is an @<file> node for x.py.
2. If not,the command creates sub files for all @<file> nodes in c.p.subtree().
3. If steps 1 and 2 did not find any @<file> nodes, the command looks at p.parents() for the first @<file> node.

This is typical behavior for Leo's file-oriented commands.
.. @+node:ekr.20160303130202.1: *4* Rev 645b4ec2f9 fixes a bug in p.__eq__
Here is the checkin log:

Fixed a bug in p.__eq__, introduced at rev d0dd25b7b (2015-11-14 18:37:06).

p.__eq__ must *not* return NotImplemented when p2 is None.

This bug caused most of the run-x-unit-tests-y commands not to find desired tests.  It surely must have caused other problems.

All unit tests now pass (except for broken Javascript importer tests), including a new test:
@test p.__eq__.
.. @+node:ekr.20160303130247.1: *4* Aha: always run unit tests locally using clones
January 23, 2016
https://groups.google.com/d/msg/leo-editor/ewa_87LomP0/5wIRxFeqDwAJ

Running a unit test locally, without exiting Leo, saves a lots of time.  It's much faster than having to load unitTest.leo or even a small .leo file.

The question is, how to use the newest code?  imp.reload often doesn't work. But just yesterday I saw a way that usually does work.  Clone the code under development and put it under an @test node.  The script in the @test node uses @others to gain access to the code, not an import.

For instance, here is the @test node I use to develop the new javascript importer:

g.cls()
p1 = p.copy()
if c.isChanged():
    c.save()
import leo.plugins.importers.basescanner as basescanner
@others
scanner = JavaScriptScanner(c.importCommands, atAuto = False)
h = '@ignore js-test'
p = g.findNodeAnywhere(c, h)
if p:
    while p.firstChild():
        p.firstChild().doDelete()
else:
    p = c.insertHeadline()
    p.h = h
c.selectPosition(p)
fn = r'c:\prog\jQuery-short2.js'
s = open(fn, 'r').read()
print('Sources..\n\n%s\n\n' % s)
scanner.scan(s, p)
c.selectPosition(p1)
c.redraw()
print('done')

To repeat, the code under test is a child of this node, so the script uses @others to gain access to it.  It's super fast.

There is another happy consequence of this Aha.  There is no longer any great need ever to run unit tests externally, so I can use the following key bindings:

run-selected-unit-tests-locally     = Alt-4
run-marked-unit-tests-locally       = Alt-5
run-all-unit-tests-locally          = Alt-6

This is much easier to remember--I don't have to remember which bindings apply to external tests and which to local. It's easy to remember that Alt-4 runs the fewest tests, Alt-5 runs more tests and Alt-6 runs all the tests.

You could call this an extension of the "stupendous Aha".
.. @+node:ekr.20160303130514.1: *4* Relations in Leo
https://groups.google.com/d/msg/leo-editor/HpOT2YWNQZY/R9IZcBIrBAAJ
My present opinion is that uA's are simply a background implementation detail.

In mathematics, a relation is just a set of tuples. Imo, we should define the following two important terms:

    A Leo predicate is a function/method taking a position
    argument that returns True or False (or equivalent).

Predicates are typically implied by the conversation.  We say p.parent() == x rather than pedantically giving the actual predicate function.

    A Leo relation (on an outline) is the (unordered) set of positions
    for which the associated Leo predicate returns True.

Again, we can simply refer to relations by the associated predicate. That is, predicates instantly give rise to relations: the set of positions for which the predicate is True.

It's best to define relations on positions rather than vnodes.  This allows us to define relations such as p.parent() == x. If outline structure is not important, we can define the relation on the underlying vnode:  p.v.u == x, for instance.

These definitions are clearly the most general possible. In particular, we can easily define Leo relations such as "p has a given attribute/uA/icon/whatever" The resulting predicates and relations are unconstrained by outline structure. They would work in multi-trees. They work in general graphs.

I am going to be writing next at length about the "relationships" between Leo predicates, relations, views, attributes, work flow and (perhaps most important) gui.

I would like to see a general user interface that would associate icons with attributes/predicate/relation. That way the user can see all the nodes with a given attribute. Stay tuned.
.. @+node:ekr.20160303130755.1: *4* cff and cfa
3. The cff and cfa commands now always search the entire outline. This is a major improvement, imo. 

4. The cff and cfa commands now always collapse the entire outline. This is almost always what I want, and it ensures that the newly-created node will be selected properly, something that was not always true before.

These seemingly small improvements actually fix most of my complaints re clones!

And one more improvement:  These commands ignore @ignore trees and any @<file> tree whose root nodes contains an @all directive. This is a super tweak:  I don't get false matches about nodes in the attic.​
 

    These seemingly small improvements actually fix most of my complaints re clones!


​And two new commands, the clone-find-marked commands, fix all my complaints about clones. I'll discuss these commands in a new thread so they get the attention they rightly deserve.

.. @+node:ekr.20160303130916.1: *4* Code Academy: find by predicate or attribute
Writing the cffm and cfam commands was snap using c.cloneFindByPredicate, a powerful new addition to Leo. Here is the entire code for the new commands:

    @cmd('clone-find-all-marked')
    @cmd('cfam')
    def cloneFindAllMarked(self, event=None):
        '''The clone-find-all-marked command.'''
        self.cloneFindMarkedHelper(flatten=False)
       
    @cmd('clone-find-all-flattened-marked')
    @cmd('cffm')
    def cloneFindAllFlattenedMarked(self, event=None):
        '''The clone-find-all-flattened-marked command.'''
        self.cloneFindMarkedHelper(flatten=True)

    def cloneFindMarkedHelper(self, flatten):
        '''Helper for clone-find-marked commands.'''
       
        def isMarked(p):
            return p.isMarked()
           
        self.cloneFindByPredicate(
            generator = self.all_unique_positions,
            predicate = isMarked,
            flatten = flatten,
            undoType = 'clone-find-marked',
        )

It's hard to imagine anything simpler. Important: the predicate could filter on an attribute or combination of attributes. For example, the predicate could return p has attributes A and B but not attribute C. Instantly we have full database query capabilities. If we then hoist the resulting node we see all and only those nodes satisfying the query.

Here is c.findNodeByPredicate. Important: Rev c8a3581c9b corrects a serious blunder in c.cloneFindByPredicate. Don't use previous versions!
    
    def cloneFindByPredicate(self,
        generator,     # The generator used to traverse the tree.  
        predicate,     # A function of one argument p, returning True
                       # if p should be included in the results.
        flatten=False, # True: Put all matches at the top level.
        undoType=None, # The undo name, shown in the Edit:Undo menu.
                       # The default is 'clone-find-predicate'
    ):
        '''
        Traverse the tree given using the generator,
        cloning all positions
        for which predicate(p) is True.
        Undoably move all clones to a new
        node, created as the last top-level node. Arguments:
   
        generator,      The generator used to traverse the tree.
        predicate,      A function of one argument p returning true if
                        p should be included.
        flatten=False,  True: Move all node to be parents of the root node.
        undo_type=None, The undo/redo name shown in the Edit:Undo menu.
                        The default is 'clone-find-predicate'
        '''
        c = self
        u, undoType = c.undoer, undoType or 'clone-find-predicate'
        clones, seen = [], set(),
        for p in generator():
            if predicate(p) and p.v not in seen:
                if flatten:
                    seen.add(p.v)
                else:
                    for p2 in p.self_and_subtree():
                        seen.add(p2.v)
                clones.append(p.copy())
        if clones:
            undoData = u.beforeInsertNode(c.p)
            root = c.createCloneFindPredicateRoot(flatten, undoType)
            # This was botched in previous versions.
            # The result was low-level vnode failures.
            for p in clones:
                clone = p.clone()
                clone.moveToLastChildOf(root)
            u.afterInsertNode(root, undoType, undoData, dirtyVnodeList=[])
            c.selectPosition(root)
            

            c.setChanged(True)
            c.redraw()
        else:
            g.es_print('not found:', undoType)

Imo, this is the dawn of a new era in Leo's database capabilities.

c.cloneFindByPredicate now supports an optional failMsg keyword arg. This is the warning given if no nodes are found.​


Recent revs add the following new position methods:

- p.is_at_all():  True if p is an @<file> node containing an @all directive.
- p.in_at_all(): True if p is in an @<file> tree whose root contains @all.
- p.is_at_ignore(): True if p is an @ignore node
- p.in_at_ignore_tree(): True if p is in an @ignore tree.

These predicates make it easy to create other predicates that skip @ignore trees or @<file> trees containing @all.  cffm and cfam do not skip such trees, on the theory that one would typically unmark nodes first before marking nodes to be cloned.

So here is how to gather only those marked nodes that lie outside any @ignore tree:

    def isMarked(p):
        return p.isMarked() and not p.in_at_ignore_tree()
      
    self.cloneFindByPredicate(
        generator = self.all_unique_positions,
        predicate = isMarked,
        flatten = flatten,
        undoType = 'gather-marked',
    )

.. @+node:ekr.20160303131234.1: *4* Added syntax coloring for coffeescript
.. @-all
.. @@killbeautify
.. @@language rest
.. @@wrap
.. @@pagewidth 60
.. @-leo
