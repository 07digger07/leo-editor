#@+leo-ver=5-thin
#@+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
#@+all
#@+node:ekr.20111103205308.9698: ** Unit tests
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)

s1 = '''
<table id="1"> <table id="2">
<contents/>
</table>
</table>
'''

s2 = '''
<table id="1"> 
<table id="2">
<contents/>
</table>
</table>
'''

t1 = 
assert result == expected,'expected...\n%s\ngot...\n%s' % (
    repr(expected),repr(result))
#@+node:ekr.20100907115157.5905: *3* @ignore Ancient tests
#@+node:ekr.20100208095423.5940: *4* @test leoCache
import leo.core.leoCache as leoCache

cacher = leoCache.cacher(c)

if 0:
    import os
    os.system('cls')

assert cacher.test()
#@+node:ekr.20100906165118.5915: *4* @test leoInkCommands
ic = c.inkscapeCommands
screenshot = r'c:\leo.repo\inkcall\some_screen_shot.png'
template_fn = r'c:\leo.repo\inkcall\template.svg'
png_fn = r'c:\leo.repo\inkcall\output.png'
svg_fn = r'c:\leo.repo\inkcall\temp.svg'
callouts = [
        "This goes here",
        "These are those, but slightly longer",
        "Then you pull this, but this text needs to be longer for testing",]
ic.run(
    screenshot,
    callouts=callouts,
    numbers=[2,4,17],
    edit_flag = True, # True: call inkscape to edit the working file.
    png_fn=png_fn, # Optional: Name of output png file.
    svg_fn=svg_fn, # Optional: Name of working svg file.
    template_fn=template_fn, # Optional: Name of template svg file.
)
#@+node:ekr.20111102123707.9629: *4* @ignore test of marked unit-test trees
#@+node:ekr.20111102123707.9630: *5* @test assert False
assert False
#@+node:ekr.20111102123707.9631: *5* @test assert True
assert True
#@+node:ekr.20111107092526.9799: *4* @test detection of external unit tests
# This test is redundant, and another test sets import_html_tags

# print('g.app.isExternalUnitTest',g.app.isExternalUnitTest)
if g.app.isExternalUnitTest:
    fn = c.shortFileName()
    assert fn.endswith('dynamicUnitTest.leo'),fn
    data = c.config.getData('import_html_tags')
    assert len(data) == 85 # length of data in leoSettings.leo.
else:
    data = c.config.getData('import_html_tags')
    assert len(data) == 85,len(data)
#@+node:ekr.20111107092526.9800: *5* doTests...
def doTests(c,all=None,marked=None,p=None,verbosity=1):

    trace = False ; verbose = False
    if all:
        p = c.rootPosition()
    elif not p:
        p = c.p
    p1 = c.p.copy() # 2011/10/31: always restore the selected position.
    
    g.trace(g.app.isExternalUnitTest)
    
    # This seems a bit risky when run in unitTest.leo.
    # c.save() # Eliminate the need for ctrl-s.
    
    if trace: g.trace('marked',marked,'c',c)

    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)

        # New in Leo 4.4.8: ignore everything in @ignore trees.
        last = None if all else p.nodeAfterTree()
        
        aList = findAllUnitTestNodes(c,p,last,all,marked,
            lookForMark=False,lookForNodes=True)
       
        found = False
        for p in aList:
            if isTestNode(p):
                if trace: g.trace('adding',p.h)
                test = makeTestCase(c,p)
            elif isSuiteNode(p): # @suite
                if trace: g.trace('adding',p.h)
                test = makeTestSuite(c,p)
            else:
                test = None
            if test:
                suite.addTest(test)
                found = True
        
        # Verbosity: 1: print just dots.
        if not found:
            # 2011/10/30: run the body of p as a unit test.
            test = makeTestCase(c,c.p)
            if test:
                suite.addTest(test)
                found = True
        if found:
            res = unittest.TextTestRunner(verbosity=verbosity).run(suite)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
                c.cacher.db[key] = archive
        else:
            g.es_print('no %s@test or @suite nodes in %s outline' % (
                g.choose(marked,'marked ',''),
                g.choose(all,'entire','selected')),color='red')
    finally:
        c.setChanged(changed) # Restore changed state.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.contractAllHeadlines()
            c.redraw(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20111107092526.9801: *6* class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20111107092526.9802: *7* __init__ (generalTestCase)
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@+node:ekr.20111107092526.9803: *7*  fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@+node:ekr.20111107092526.9804: *7* tearDown
def tearDown (self):

    pass

    # Restore the outline.
    self.c.outerUpdate()
#@+node:ekr.20111107092526.9805: *7* setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p.copy()) # 2010/02/03
#@+node:ekr.20111107092526.9806: *7* runTest (generalTestCase)
def runTest (self,define_g = True):

    trace = False
    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)
    
    if c.shortFileName() == 'dynamicUnitTest.leo':
        c.write_script_file = True

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p and p.copy(),'self':self,}
    else:
        d = {'self':self,}

    script = script + '\n'
    if trace: g.trace('p: %s c: %s write script: %s script:\n%s' % (
        p and p.h,c.shortFileName(),c.write_script_file,script))

    # Execute the script. Let the unit test handle any errors!
    # 2011/11/02: pass the script sources to exec or execfile.
    if c.write_script_file:
        scriptFile = c.writeScriptFile(script)
        if g.isPython3:
            exec(compile(script,scriptFile,'exec'),d)
        else:
            execfile(scriptFile,d)
    else:
        exec(script,d)
#@+node:ekr.20111107092526.9807: *7* shortDescription
def shortDescription (self):

    s = self.p.h

    # g.trace(s)

    return s + '\n'
#@+node:ekr.20111107092526.9808: *6* makeTestSuite (leoTest)
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()
    # g.trace('c.write_script_file',c.write_script_file)
    script = g.getScript(c,p).strip()
    if not script:
        print("no script in %s" % h)
        return None
    try:
        if 0: #debugging
            n,lines = 0,g.splitLines(script)
            for line in lines:
                print(n,line)
                n += 1
                
        # 2011/11/02: make script sources available.
        d = {'c':c,'g':g,'p':p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            if g.isPython3:
                exec(compile(script,scriptFile,'exec'),d)
            else:
                execfile(scriptFile,d)
        else:
            exec(script + '\n',d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("makeTestSuite: %s script did not set g.app.scriptDict" % p.h)
        return suite
    except Exception:
        print('makeTestSuite: exception creating test cases for %s' % p.h)
        g.es_exception()
        return None
#@+node:ekr.20111107092526.9809: *6* makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.b.strip():
        return generalTestCase(c,p)
    else:
        return None
#@+node:ekr.20111107092526.9810: *5* main & helpers (leoDynamicTest.py)
def main ():

    trace = False
    readSettings = True 
    tag = 'leoDynamicTests.leo'
    if trace: t1 = time.time()

    # Setting verbose=True prints messages that would be sent to the log pane.
    path,gui,silent = scanOptions()
    # print('(leoDynamicTest.py:main)','silent',silent)

    # Not loading plugins and not reading settings speeds things up considerably.
    bridge = leoBridge.controller(gui=gui,
        loadPlugins=False, # Must be False: plugins will fail when run externally.
        readSettings=True, # True adds about 0.3 seconds.  Is it useful?
        silent=True,
        verbose=False)

    if trace:
         t2 = time.time()
         print('%s open bridge:  %0.2fsec' % (tag,t2-t1))

    if bridge.isOpen():
        g = bridge.globals()
        g.app.silentMode = silent
        g.app.isExternalUnitTest = True
        path = g.os_path_finalize_join(g.app.loadDir,'..','test',path)
        c = bridge.openLeoFile(path)
        if trace:
            t3 = time.time()
            print('%s open file: %0.2fsec' % (tag,t3-t2))
        runUnitTests(c,g)
#@+node:ekr.20111107092526.9811: *6* runUnitTests
def runUnitTests (c,g):

    p = c.rootPosition()
    #g.es_print('running dynamic unit tests...')
    c.selectPosition(p)
    c.debugCommands.runAllUnitTestsLocally()
#@+node:ekr.20111107092526.9812: *6* scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('--path',dest='path')
    parser.add_option('--gui',dest="gui")
    parser.add_option('--silent',action="store_true",dest="silent")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)

    # -- path
    # We can't finalize the path here, because g does not exist ye.
    path = options.path or 'dynamicUnitTest.leo'

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('qttabs','qt'):
        gui = 'nullGui'

    # --silent
    silent = options.silent

    return path,gui,silent
#@+node:ekr.20111116161118.10248: *3* Recent tests
#@+node:ekr.20111104132424.9909: *4* @test assert True
# It's useful to have this do-nothing test.

assert True
#@+node:ekr.20111107092526.9819: *4* @test cls
g.cls() # Clear the screen
#@+node:ekr.20111110085739.10265: *4* @test html string
s = '''\
<HTML>
<head>
    <title>Bodystring</title>
</head>
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
</html>
'''

html_tags = ('body','head','html','table',) # 'div',
setting = 'import_html_tags'

# Settings now work when run externally.
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.app.unitTestDict ['expectedErrors'] = 0

showTree = True

c.importCommands.htmlUnitTest(p,s=s,showTree=showTree)

if showTree:
    # g.cls()
    for p in p.subtree():
        print('\n***** %s\n' %p.h)
        print(p.b)
#@+node:ekr.20120112100822.10003: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120112100822.10004: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120112100822.10005: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120112100822.10006: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120203153754.10033: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120203153754.10034: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120203153754.10035: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120203153754.10036: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120204061120.10061: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120204061120.10062: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120204061120.10063: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120204061120.10064: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20111109151106.9746: *4* @test htmlScanner.filterTokens
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)
strip = hs.stripTokens
dump  = hs.formatTokens

s1 = '''<table id="1"><table id="2">
<contents/>
</table>
</table>'''

s2 = '<table id="1"><table id="2"><contents/></table></table>'
    
t1 = hs.tokenize(s1)
t2 = hs.tokenize(s2)
f1 = hs.filterTokens(t1)
f2 = hs.filterTokens(t2)

assert strip(f1) == strip(f2),'f1...\n%s\nf2...\n%s' % (
    dump(f1),dump(f2))
    
if 0:
    print(dump(f1))
#@+node:ekr.20111110084957.10092: *4* @test import dataN.html
fn = r'c:\recent\data.html'

# fn = r'c:\recent\data-smaller.html'
# fn = r'c:\recent\data666.html'

# These all pass on data.html:
    # html_tags = ('html','head','body',)
    # html_tags = ('html','head','body','table',)
    # html_tags = ('html','head','body','table','div',)
    # html_tags = ('html','head','body','table','div','script',)
    # html_tags = ('html','head','body','table','div','script','link',)
    # html_tags = ('html','head','body','table','div','script','link','p',)

html_tags = ('html','head','body','table','div','script','p','td','tr',)

# Settings now work when run externally.
setting = 'import_html_tags'
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.cls()

c.importCommands.importFilesCommand(files=[fn], treeType='@file')
#@+node:ekr.20111109105907.9795: *4* @test unicode stuff
@first # -*- coding: utf-8 -*-

table = (
    'test',
    'Ä 궯 奠',
    'Ä 궯 奠 after', # fails with cp6501: after is duplicated.
)

print('*'*20)
print('isPython3: %s' % g.isPython3)

for s in table:
    if g.isPython3:
        s = s.encode('ascii','replace') # create bytes.
    g.es(repr(s))
    g.es(s)
    g.pr ('g.pr(s)       : %s' % s)
    g.pr ('g.pr(repr(s)) : %s' % repr(s))
    print('print(s)      : %s' % s)
    print('print(repr(s)): %s' % s)
#@+node:ekr.20111113064104.9841: *4* @test external text operations
assert g.app.isExternalUnitTest

body = c.frame.body
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl

w = body.bodyCtrl
w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111112131605.9789: *4* @test nullBody text operations
# print('isExternalUnitTest',g.app.isExternalUnitTest)

if g.app.isExternalUnitTest:
    body = c.frame.body
else:
    import leo.core.leoCommands as leoCommands
    import leo.core.leoFrame as leoFrame
    import leo.core.leoGui as leoGui
    
    # Important: external unit tests should execute in this environment.
    nullGui   = leoGui.nullGui('null gui')
    nullFrame = leoFrame.nullFrame(title='nullFrame title',gui=nullGui)
    c2 = leoCommands.Commands(nullFrame,fileName='<empty fileName>')
    nullFrame.c = c2
    body = leoFrame.nullBody(frame=nullFrame,parentFrame=None)
    assert repr(body).startswith('<leo.core.leoFrame.nullBody')

# Now test some basic operations.
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl
w = body.bodyCtrl

w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111115155710.9835: *4* @test g.python_tokenize
# h = 'g.python_tokenize'
# p = p.firstChild()
# assert p.h == h
tokens = g.python_tokenize(p.b,line_numbers=False)

# tokens = [(kind,val) for (kind,val,line_number) in tokens]

# First, the basic check
tokens1 = [val for kind,val in tokens]
s = ''.join(tokens1)
assert p.b == s,repr(s)

if 0:
    for z in tokens:
        kind,val = z
        print('%6s %s' % (kind,repr(val)))
        
# Next, start filtering.
tokens = [(kind,g.choose(kind=='string','"S"',val)) for kind,val in tokens]

if 0: # Delete whitespace.
    tokens = [(kind,val) for (kind,val) in tokens if kind != 'ws']
    tokens = [(kind,g.choose(kind=='id',val+' ',val)) for (kind,val) in tokens]

# Last: stringize.
tokens = [val for kind,val in tokens if kind != 'comment']
# print(''.join(tokens))

if 1: # Print lines containing '='
    s = ''.join(tokens)
    for ch in '()[]{}<>.,:=+-/':
        s = s.replace(' '+ch,ch)
    aList = [z for z in g.splitLines(s)
        if z.find('=') > -1] # and not z.find('+=')>-1 and not z.find('-=')>-1]
    print(''.join(aList))
    
#@+node:ekr.20111204110514.10287: *4* @test p.moveToFirst/LastChild
def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()

child = p.firstChild()
assert child
setup(child)
p2 = child.insertAfter()
p2.h = "test"
try:
    assert c.positionExists(p2),p2
    p2.moveToFirstChildOf(child)
    assert c.positionExists(p2),p2
    p2.moveToLastChildOf(child)
    assert c.positionExists(p2),p2
finally:
    if 1:
        setup(child)
    c.redraw(p)
#@+node:ekr.20111210100047.10306: *5* child
#@+node:ekr.20111116161118.10247: *3* Old lint tests
#@+node:ekr.20111116103733.9845: *4*  Naming tests
# http://docs.python.org/reference/executionmodel.html#naming-and-binding

if 0:
    def test():
        a = b
        b = 1 # UnboundLocalError
        
print('***')
          
def test():
    global g2
    g2 = 4
    def test2():
        print(g2)
    test2()
    g2 = 3
    print(g2)
    
g2 = 'g2'
print(g2)

test()
#@+node:ekr.20111116103733.9846: *5* << define s>>
s = '''



'''

s = g.adjustTripleString(s,-4)
#@+node:ekr.20111116103733.9839: *4* @test create lots of data structures
# A simple prototype of data-centric design.
# 0.023 sec to create 100,000 dicts.
# 0.230 sec to create 1,000,000 dicts.

import time

t1 = time.clock()
n = 1000000

d = {}
for z in range(n):
    d[n] = {'n':n,}

t2 = time.clock()
print('Created %s dicts in %2.3f sec.' % (n,t2-t1))
#@+node:ekr.20111116103733.9844: *4* @test dumper (to outNodes)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outNodes.txt'

outStream = open(out,'w')
u.AstDumper().dumpFileAsNodes(fn,outStream)
#@+node:ekr.20111116103733.9840: *4* @test dumper (to outString)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outString.txt'

outStream = open(out,'w')
u.AstDumper(brief=True).dumpFileAsString(fn,outStream)
#@+node:ekr.20111116103733.9838: *4* @test speed of AstTraverser (one file)
import leo.core.leoGlobals as g
import leo.core.leoInspect as leoInspect
import ast
import time

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
    
t1 = time.clock()
s = open(fn,'r').read()
t2 = time.clock()
tree = ast.parse(s,filename=fn,mode='exec')
t3 = time.clock()
leoInspect.AstTraverser(fn).visit(tree)
t4 = time.clock()

if 1:
    print('read:     %2.3f sec.' % (t2-t1))
    print('parse:    %2.3f sec.' % (t3-t2))
    print('traverse: %2.3f sec.' % (t4-t3))
    print('total:    %2.3f sec.' % (t4-t1))
#@+node:ekr.20111128103520.10237: *3* Tests of @shadow from unitTest.leo
#@+node:ekr.20111128103520.10238: *4* @@shadow ../test/unittest/at-shadow-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10239: *5* spam
def spam():
    pass
#@+node:ekr.20111128103520.10240: *5* eggs
def eggs():
    pass
#@+node:ekr.20111128103520.10241: *4* @@shadow unittest/at-shadow-line-number-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10242: *5* child
def child():
    pass
#@+node:ekr.20111128103520.10243: *4* @test @shadow: shape of tree
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow ../test/unittest/at-shadow-test.py'
    p = g.findNodeAnywhere(c,h)
    assert p
    
    table = (
        (p.firstChild(),'spam'),
        (p.firstChild().next(),'eggs')
    )
    
    assert not p.isDirty(),p.h # Do not ignore this failure!
    
    for p2,h2 in table:
        assert len(p2.h) == len(h2)
#@+node:ekr.20111128103520.10244: *4* @test goto-global-line @shadow
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow unittest/at-shadow-line-number-test.py'
    root1 = g.findNodeAnywhere(c,h)
    assert root1
    assert root1.isAnyAtFileNode()
    
    fileName,lines,n,root2 = c.goToLineNumber(c).setup_file(n=6,p=root1)
    assert fileName == h[8:],'fileName'
    assert root2 == root1
    
    if 0:
        print('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
            root and root.h,isRaw,n,len(lines)))
#@+node:ekr.20111116103733.9818: *3* LeoInspect tests
#@+node:ekr.20111116103733.10672: *4* @test leoInspect with multiple files
import leo.core.leoInspect as inspect
import os
import time

<< define old_s >>
<< define s >>

@others

g.cls()

aList = (
    'leoAtFile.py',
    'leoEditCommands.py',
)
test(files=aList,print_stats=False,s=None,print_times=True)
#@+node:ekr.20111116103733.10451: *5* << define old_s >>
# import leo.core.leoGlobals
# import leo.core.leoGlobals as g
# from leo.core.leoGlobals import pr as pr2
# from leo.core.leoGlobals import trace

s_old = '''\
import sys

aGlobal = 5
# aGlobal2 is not explicitly defined.

c = [z for z in 'abc']

def myFunc():
    n1,n2,n3,junk,junk=sys.version_info
    a = self.b
    for z in a:
        print(z)
    with A() as a:
        print(a,b)
        
def test():
    a = b # UnboundLocalError.
    b = 1
    c = 2 # Any def will do at present.
    print(g)
    print(c.frame.body)
    print(c.frame.body.xxx.yyy)
    print(b.yyy) # no check will be made.
    print(xxx.yyy)
    for c in 'abc':
        print(c,b)
        print(g)


class myClass:
    
    def __init__(self,c):
        self.a = True
        self.b = None
        c.frame.xxxx
        
    def spam(self,a,b,c=5,*args,**keys):
        global aGlobal2
        aGlobal2 = 'abc'
        self.a = b
        self.a = x
        
    def no_self(a):
        pass
        
    def test_lambda(self):
        f = lambda a,b: a

    def test_comprehension(self):
        z2 = [z for z in 'abc']
        
aGlobal3 = 4 # This should be defined everywhere.

def test():
    # a = ','.join(['a','b'])
    p = 5
    # print(p.parent().h)
    # print(g.app.windowList[0])
    print(p)
    print(g)

'''

# import leo.core.leoCommands as leoCommands
#@+node:ekr.20111116103733.10452: *5* << define s >>
s = '''\

import leo.core.leoGlobals as g

def test(c):
    a = 5
    f = c.frame
    c.frame.body.bodyCtrl = w

'''

s = g.adjustTripleString(s,-4)
# print(s)
#@+node:ekr.20111116103733.10450: *5* test
def test(files,print_stats=True,s=None,print_times=True):
   
    t1 = time.clock()
    sd = inspect.SemanticData(controller=None)

    if s: # Use test string.
        fn = '<test file>'
        inspect.InspectTraverser(fn,sd).traverse(s)
    else:
        for fn in files:
            print(g.shortFileName(fn))
            s = inspect.LeoCoreFiles().get_source(fn)
            if s:
                inspect.InspectTraverser(fn,sd).traverse(s)
            else:
                print('file not found: %s' % (fn))
           
    sd.total_time = time.clock()-t1
    
    if print_times: sd.print_times()
    if print_stats: sd.print_stats()
#@+node:ekr.20111116103733.10449: *4* @test leoInspect.module.classes
import leo.core.leoInspect as inspect

dump_classes = False
print_modules = True
print_functions = True
print_stats = False
print_times = False

# if dump_modules or print_stats:
    # g.cls()

m = inspect.module(fn='leoApp.py',sd=None,
    print_stats=print_stats,print_times=print_times)
    
print(m)
for o in m.classes():
    if dump_classes:
        o.dump(verbose=False)
    if print_modules:
        print(o)
    if print_functions:
        for f in o.functions():
            print('  %s' % f)
#@+node:ekr.20111116161118.10212: *4* @test leoInspect.module.classes 2
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(fn='leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.classes():
    print(z)
#@+node:ekr.20111116161118.10218: *4* @test leoInspect.module.defs
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(fn='leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
print(m)
    
for z in m.classes():
    print(z)
    for z2 in z.defs():
        name = z2._tree.name
        aList = z2.call_args_of(name)
        args = ','.join(aList)
        print(' %s(%s)' % (name,args))
#@+node:ekr.20111116161118.10181: *4* @test leoInspect.module.statements
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(fn='leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)

print(m)
for z in m.classes():
    print(z)
    for z2 in z.defs():
        print(z2)
#@+node:ekr.20111116161118.10230: *4* @test leoInspect (leoEditCommands.py)
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(fn='leoEditCommands.py')

def show(o):
    print('%-5s %s' % (o.line_number(),o.format()))

var = '.widget'
func = 'w.insert'

if 0:
    
    print('\nAssignments to %s...\n' % (var))
    for o in m.assignments_to(var):
        show(o)
        
    print('\nAssignments using %s...\n' % (var))
    for o in m.assignments_using(var):
        show(o)
        
    print('\nCalls to %s...\n' % (func))
    for o in m.calls_to(func):
        show(o)
        
    if 1:
        classes = m.classes()
        for d in classes[0].defs():
            print('')
            print(d)
            for z in d.statements():
                # print(z.tree())
                # print(z.sd.dump_ast(z.tree()))
                lines = g.splitLines(z.format())
                for line in lines:
                    print('  %s' % (line))
#@+node:ekr.20111127153202.10231: *4* @test speed of AstTraverser (all Leo core files)
import leo.core.leoGlobals as g
import leo.core.leoInspect as inspect
import ast
import time

read_time,parse_time,traverse_time = 0.0,0.0,0.0
t_start = time.clock()
count = 0
for fn in inspect.LeoCoreFiles().files:
    count += 1
    t2 = time.clock()
    s = open(fn,'r').read()
    t3 = time.clock()
    tree = ast.parse(s,filename=fn,mode='exec')
    t4 = time.clock()
    inspect.AstTraverser(fn).visit(tree)
    t5 = time.clock()
    read_time += t3-t2
    parse_time += t4-t3
    traverse_time += t5-t4
t_end = time.clock()
total_time = t_end-t_start
if 1:
    print('files:    %s' % (count))
    print('read:     %2.3f sec.' % (read_time))
    print('parse:    %2.3f sec.' % (parse_time))
    print('traverse: %2.3f sec.' % (traverse_time))
    print('total:    %2.3f sec.' % (total_time))
#@+node:ekr.20111127090852.10227: *4* @test leoInspect (all core files)
import leo.core.leoInspect as inspect
import time

sd = inspect.SemanticData()
start_time = time.clock()

count = 0
for fn in inspect.LeoCoreFiles().files:
    print(fn)
    m = inspect.module(fn,sd=sd)
    count += 1

end_time = time.clock()
total_time = end_time-start_time

if 1:
    print('files: %s' % (count))
    print('total: %2.3f sec.' % (total_time))
if 1:
    sd.print_stats()
#@+node:ekr.20111117031039.10762: *4* @test leoInspect.module (s)
import leo.core.leoInspect as inspect

g.cls()

def show(o,indent):
    # print('\n%s\n' % o.sd.dump_ast(o.tree()))
    print('%s%s' % (' '*4*indent,o.format()))

<< define s >>
print('Input...\n%s\n' % (s.rstrip()))

m = inspect.module(s=s)

if 1:
    print(show(m,0))

print('\nAssignments to a...\n')
for o in m.assignments_to('a'):
    print(o.format())
    
print('\nAssignments using d...\n')
for o in m.assignments_using('d'):
    print(o.format())
    
print('\nCalls to f...\n')
for o in m.calls_to('f'):
    print(o.format())

if 1:
    for s in m.statements():
        show(s,0)
    
    for f in m.functions():
        show(f,0)
        for z in f.statements():
            show(z,1)
    
    for cls in m.classes():
        show(cls,0)
        for d in cls.defs():
            show(d,1)
            for z in d.statements():
                show(z,1)
#@+node:ekr.20111117031039.10763: *5* << define s >>
s = '''
x.y = b(arg1,arg2=5,*args,**args).c[1:2:3].d
a=b+c
f(a=1,b=2,*args,**keys)
'''


# def outer_function(a,b=99,c=88,*args,**keys):
    # print('hello')
    
# class myClass:
    # def method():
        # pass
    
#@+node:ekr.20111116103733.9838: *4* @test speed of AstTraverser (one file)
import leo.core.leoGlobals as g
import leo.core.leoInspect as leoInspect
import ast
import time

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
    
t1 = time.clock()
s = open(fn,'r').read()
t2 = time.clock()
tree = ast.parse(s,filename=fn,mode='exec')
t3 = time.clock()
leoInspect.AstTraverser(fn).visit(tree)
t4 = time.clock()

if 1:
    print('read:     %2.3f sec.' % (t2-t1))
    print('parse:    %2.3f sec.' % (t3-t2))
    print('traverse: %2.3f sec.' % (t4-t3))
    print('total:    %2.3f sec.' % (t4-t1))
#@+node:ekr.20120116073928.10114: *3* Unit tests for settings
#@+node:ekr.20120126050844.10386: *4* @ignore print dicts unit tests
#@+node:ekr.20120117095916.10124: *5* @test printMenusList
def printMenusList(aList,level=0):
    
    for z in aList:
        a,b,c = z
        print('*** kind',a)
        if type(b) in (type(()),type([])):
            for z2 in b:
                a1,b1,c1 = z2
                if a1.startswith('@menu') and type(b1) in (type(()),type([])):
                    print()
                    print('*** inner menu: %s' % (level+1))
                    print(a1)
                    for z3 in b1:
                        print(z3)
                    if c1: print(c1)
                else:
                    print(z2)
            if c: print(c)
        else:
            print(b)
        print()
        break #
        
printMenusList(c.config.getMenusList())
       
#@+node:ekr.20120117095916.10140: *5* @test printInverseBindingDict
print('\ninverseBindingDict...\n')

d = c.k.computeInverseBindingDict()

for key in sorted(list(d.keys())):

    if 1 == len(d.get(key)):
        print(key,d.get(key))
    else:
        print()
        print(key)
        print(d.get(key))
        print()
#@+node:ekr.20120123113111.10925: *5* @test printBindingsDict
import leo.core.leoConfig as leoConfig # for ShortcutInfo
    
partial = True

d = c.k.bindingsDict
    # Keys are shortcuts; values are *lists* leoConfig.ShortcutInfo objects.
    
print('\nk.bindingsDict%s...\n' % ' (partial)' if partial else '')
    
for key in list(sorted(d.keys())):
    aList = d.get(key,[])
    for b in aList:
        assert isinstance(b,leoConfig.ShortcutInfo)
        if not partial or b.kind != 'leosettings.leo':
            print(b)
#@+node:ekr.20120117095916.10141: *5* @test printMasterBindingsDict
partial = True

panes = ('all','body','button','log','tree','text',
    'command','insert','overwrite',)

d = c.k.masterBindingsDict
    # Keys are scope names (in panes) or mode names.
    # Values are dicts:
        # keys are strokes; values are leoConfig.ShortcutInfo objects.
        
print('\nk.masterBindingsDict%s...\n' % ' (partial)' if partial else '')

for pane in sorted(list(d.keys())):
    kind = 'pane' if pane in panes else 'mode'
    print('%s: %s...' % (kind,pane))
    d2 = d.get(pane)
    for stroke in sorted(list(d2.keys())):
        b = d2.get(stroke)
        if not partial or b.kind != 'leosettings.leo':
            print('%6s %25s %17s %s' % (b.pane,stroke,b.kind,b.commandName))
            assert b.pane == pane
            assert b.stroke == stroke
    print()
#@+node:ekr.20120126080450.10187: *4* @ignore passed
#@+node:ekr.20120126080450.10189: *5* @test mode-related info
@

g.app.config.modeCommandsDict
    Keys are command names: enter-x-mode.
    Values are inner dictionaries:
        Keys are command names, values are lists of ShortcutInfo nodes.
@c

d = g.app.config.modeCommandsDict
    
for key in sorted(d.keys()):
    print('*** mode ***',key)
    d2 = d.get(key)
    for key2 in sorted(d2.keys()):
        aList = d2.get(key2)
        print(key2)
        for si in aList:
            print('   ',si)
#@+node:ekr.20120120095156.10262: *5* @test types of contents of settings dicts
@
ivar                    Keys                Values
----                    ----                ------
c.commandsDict          command names (1)   functions
k.inverseCommandsDict   func.__name__       command names
k.bindingsDict          shortcuts           list of ShortcutInfo objects
k.masterBindingsDict    scope names (2)     inner masterBindingDicts (3)
k.masterGuiBindingsDict strokes             list of widgets in which stoke is bound
k.settingsNameDict (4)  settings.lower()    "Real" Tk specifiers
inverseBindingDict (5)  command names       lists of tuples (pane,key)
modeCommandsDict (6)    command name (7)    inner modeCommandsDicts (8)

Notes:
(1) Command names are minibuffer names (strings)
(2) Scope names are 'all','text',etc.
(3) inner masterBindingDicts: Keys are strokes; values are ShortcutInfo objects.
(4) k.settingsNameDict has no inverse.
(5) inverseBindingDict is **not** an ivar: it is computed by k.computeInverseBindingDict.
(6) A global dict: g.app.gui.modeCommandsDict
(7) enter-x-command
(8) Keys are command names, values are lists of ShortcutInfo objects.
@c

si_type = c.k.ShortcutInfo
disabled_func_type = None # Should be any bound method.
k = c.k

@others

test_dict_of_objects(c.commandsDict,type('s'),disabled_func_type,'commandsDict')
test_dict_of_objects(k.inverseCommandsDict,type('s'),type('s'),'inverseCommandsDict')
test_dict_of_lists(k.bindingsDict,si_type,'bindingsDict')
test_dict_of_dicts(k.masterBindingsDict,si_type,'masterBindingsDict')
test_dict_of_lists(k.masterGuiBindingsDict,None,'masterGuiBindingsDict')
test_dict_of_objects(k.settingsNameDict,type('s'),type('s'),'settingsNameDict')
test_dict_of_lists(k.computeInverseBindingDict(),type(tuple()),'inverseBindingDict')

# Test individual dicts separately.
d = g.app.config.modeCommandsDict
test_dict_of_dicts(d,None,'modeCommandsDict')
for key in sorted(d.keys()):
    d2 = d.get(key)
    test_dict_of_lists(d2,si_type,'inner modeCommandsDict')
        # This requires a hack to special-case the
        # '*entry-commands*' and '*command-prompt*' keys.
#@+node:ekr.20120126080450.10193: *6* test_dict_of_dicts
def test_dict_of_dicts(d,theType,tag):

    assert d,tag

    for key in d.keys():
        d2 = d.get(key)
        assert type(d2) == type({})
        for key in d2.keys():
            obj = d2.get(key)
            if theType:
                assert type(obj) == theType,repr(obj)
#@+node:ekr.20120126080450.10191: *6* test_dict_of_lists
def test_dict_of_lists(d,theType,tag):

    assert d,tag

    for key in d.keys():
        obj = d.get(key)
        if key in ('*entry-commands*','*command-prompt*'):
            # Special case for g.app.config.modeCommandsDict
            assert type(obj)==type([]),repr(obj)
        else:
            assert type(obj) == type([])
            # Don't check types of list elements if theType is None.
            if theType:
                for z in obj:
                    assert type(z)==theType,'key: %s obj: %s' % (key,repr(obj))
#@+node:ekr.20120126080450.10195: *6* test_dict_of_objects
def test_dict_of_objects(d,keyType,valueType,tag):

    assert d,tag

    for key in d.keys():
        assert type(key) == keyType,repr(key)
        obj = d.get(key)
        # Don't check type of obj if valueType is None.
        if valueType:
            assert type(obj) == valueType,'\nobj: %s\nvalueType: %s' % (repr(obj),valueType)
#@+node:ekr.20120126080450.10194: *6* Unused
# import types
# types.ListType does not exist in Python 3.x.
# assert isinstance(aList,list().__class__)
#@+node:ekr.20120127084215.10238: *5* @test merge_settings_dicts
@others

# import os ; os.system('cls')
    
d1 = g.app.config.immutable_leo_settings_shortcuts_dict
d2 = g.app.config.immutable_my_leo_settings_shortcuts_dict
d3 = g.app.config.merge_settings_dicts(d1,d2)

if False:
    patterns = (
        'backward-find-character-extend-selection',
    )
    for pattern in patterns:
        print(dump_dict(d1,pattern,tag='d1'))
        print(dump_dict(d2,pattern,tag='d2'))
        print(dump_dict(d3,pattern,tag='d3'))

test(d1,d2,d3)
#@+node:ekr.20120127145909.10227: *6* dump & dump_dict (@test merge_settings_dicts)
def dump(aList,pattern=None,tag=None):
    
    return '\n'.join([repr(z) for z in aList])
    

def dump_dict(d,pattern=None,tag=None):
    
    result = [] # '\ndump of %s...' % (tag)
    
    for key in d.keys():
        if pattern in (key,None):
            result.append(key)
            aList = d.get(key)
            for z in aList:
                result.append('    %s' % (z))
                
    return '\n'.join(result)
#@+node:ekr.20120127084215.10239: *6* test (@test merge_settings_dicts)
def test(old_d,new_d,result_d):
    
    '''Test that result_d is the result of upating old_d with new_d.
    
    This test is tricky: only inverted dicts have ShortcutInfo nodes as keys.'''
    
    invert,uninvert = g.app.config.invert,g.app.config.uninvert

    # Compute the inversions of all the dicts.
    inv_old,inv_new,inv_res = invert(old_d),invert(new_d),invert(result_d)
    
    # Part 1: Ensure we test all keys.
    keys = list(inv_old.keys())
    keys.extend(list(inv_new.keys()))
    keys.extend(list(inv_res.keys()))
    keys = sorted(list(set(keys)))
    assert None not in keys
    for key in inv_old.keys(): assert key in keys,key
    for key in inv_new.keys(): assert key in keys,key
    for key in inv_res.keys(): assert key in keys,key
    
    # Part 2: Carefully test the inverted result.
    def si_name_key(si): return si.commandName or ''

    for key in keys:
        # Compute the *sorted* list of 
        res_list = sorted(inv_res.get(key,[]),key=si_name_key)
        old_list = sorted(inv_old.get(key,[]),key=si_name_key)
        new_list = sorted(inv_new.get(key,[]),key=si_name_key)
        assert res_list,'no res_list.get(%s)' % (key)
        # if new_list: print(key,dump(new_list))
        if new_list:
            assert new_list == res_list,'key %s\nnew:\n%s\nres:\n%s' % (
                key,dump(new_list),dump(res_list))
        else:
            assert old_list == res_list,'key %s\nold:\n%s\nres:\n%s' % (
                key,dump(old_list),dump(res_list))
    
    # Part 3: Test that result_d == uninvert(invert(result_d)).
    # A.  They must have the same keys.
    unv_res = uninvert(inv_res)
    assert sorted(list(result_d.keys())) == sorted(list(unv_res.keys()))

    # B. The values of for each key must match after being sorted.
    def si_stroke_key(si): return si.stroke or ''
        
    for key in sorted(result_d.keys()):
        res_list = sorted(result_d.get(key,[]),key=si_stroke_key)
        unv_list = sorted( unv_res.get(key,[]),key=si_stroke_key)
        assert res_list == unv_list,'key %s\nres:\n%s\nunv:\n%s' % (
            key,dump(res_list),dump(unv_list))
   
#@+node:ekr.20120203153754.10032: *5* @test KeyStroke
ks = c.k.KeyStroke

@others

a1 = ks('a')
a2 = ks('a')
b1 = ks('b')
assert a1 == a2
d = {}
d[a1] = a1.s
d[a2] = a2.s
d[b1] = b1.s

for key in sorted(d):
    print(key,d.get(key))
#@+node:ekr.20120205022040.17748: *5* @test g.TypedDict
d = g.TypedDictOfLists('ks',type('s'),type(9))
d.add('a',1)
d.add('a',2)
d.add('b',3)

print(d)
for s in sorted(d.keys()):
    print(s,d.get(s,[]))

print('after replace...')
d.replace('a',[8,9,10])

for s in sorted(d.keys()):
    print(s,d.get(s,[]))
#@+node:ekr.20120215062153.14233: *3* @mark-for-unit-tests
#@+node:ekr.20080412053100.5: *4* @settings
#@+node:ekr.20080412053100.4: *5* @bool fixedWindow = False
#@+node:ekr.20100902154544.5872: *5* @bool enable-abbreviations = True
#@+node:ekr.20111123042248.12701: *5* @@@enabled-plugins
# Leo loads plugins in the order they appear here.

# Highly-recommended plugins:

plugins_menu.py
free_layout.py # needs to be early
viewrendered.py
mod_scripting.py
bigdash.py
#@+node:ekr.20111031081007.9985: *5* @shortcuts
run-selected-unit-tests-externally = Alt-4 # Standard binding, unchanged.
run-marked-unit-tests-externally = Alt-5
run-marked-unit-tests-locally = Alt-6
#@+node:ekr.20120329072206.9700: ** 4.10
#@+node:ekr.20120322073519.10401: *3* b1
#@+node:ekr.20120318110848.9734: *4* Added import-org-mode script
#@+node:ekr.20120318110848.9735: *5* import-org-mode (command, not used)
class ImportOrgMode:
    @others

def importOrgMode (self,event):
    c = self.c
    self.ImportOrgMode(c).go(c.p)
    c.bodyWantsFocus()

if False and g.app.inScript:
    print('='*40)
    ImportOrgMode(c).test()
    print('done')
#@+node:ekr.20120318110848.9736: *6* ctor
def __init__ (self,c):
    
    self.c = c
#@+node:ekr.20120318110848.9737: *6* go
def go (self,p):
    
    '''Prompt for a file and pass the contents to scan().'''
#@+node:ekr.20120318110848.9738: *6* scan
def scan (self,fn,p,s):

    self.c = c
    root = p.insertAsLastChild()
    root.h = fn
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        g.trace(repr(s))
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1
                level += 1
            if level > len(stack):
                g.trace('bad level',repr(s))
                last = None
            elif level == len(stack):
                last = stack[-1]
                last.b = ''.join(body)
            else:
                last = stack[-1]
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            p = parent.insertAsLastChild()
            p.h = s.strip()
            stack.append(p)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        parent = stack[-1]
        parent.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
#@+node:ekr.20120318110848.9739: *6* test
def test (self):
    
    s = '''
* A1
    a1.1
    a1.2
** B11
** B12
b12.1
*** C121
c121.1
    c121.2
c121.3
* A2
a2.1
** B21
*** C211
c211.1
*** C212
** B22
    b22.1
b22.1
* A3
* A4
a4.1
* A5
** B51
*** C511
**** D5111
***** E51111
** B52
*** C521
c521.1
'''

    tag = 'test-import-org-mode'
    p = g.findNodeAnywhere(c,tag)
    s = g.adjustTripleString(s,-4)
    if p:
        try:
            self.scan('test-file',p,s)
        except Exception:
            c.redraw(p)
    else:
        print('not found: %s' % tag)
#@+node:ekr.20120318110848.9740: *5* @@button import-org-mode
'''Import each file in the files list after the presently selected node.'''


files = (
    r'c:\Users\edreamleo\test\import-org-mode.txt',
    r'c:\Users\edreamleo\test\import-org-mode.txt',
)

@others

for fn in files:
    try:
        root = c.p.copy()
        f = open(fn)
        s = f.read()
        scan(c,fn,s)
        c.selectPosition(root)
    except IOError:
        print('can not open %s' % fn)
#@+node:ekr.20120318110848.9741: *6* scan
def scan (c,fn,s):

    last = root = c.p.insertAsLastChild()
    last.h = g.shortFileName(fn)
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1 ; level += 1
            if level > len(stack):
                g.trace('bad level',repr(s))
            elif level == len(stack):
                last.b = ''.join(body)
            else:
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            last = parent.insertAsLastChild()
            last.h = s.strip()
            stack.append(last)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        last.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
#@+node:ekr.20120318110848.9742: *5* test-import-org-mode
#@+node:ekr.20120318110848.9747: *4* Code for displaying a function call hierarchy in Leo
From Brian Theado

The other day I stumbled across Ville's code in scripts.leo which displays the
output of python's trace module in a leo outline. The output of the trace module
is not very friendly and I didn't find the result very usable. I was inspired to
write some code to translate the output so the tree of function calls is
displayed via Leo headlines. Thanks to Ville for sharing that code. I never
would have figure this out without that starting point.

Just copy (Ctrl-Shift-V) the child outline into a leo outline and hit ctrl-b on
the "call tree" node. The execution tree of the 'scroll-outline-up-line'
minibuffer command will be displayed to stdout and also as a tree of leo
headlines.
#@+node:ekr.20120318110848.9748: *5* call tree
import trace

@language python
@others

# http://docs.python.org/library/trace.html for documentation
# on the trace module
tracer = trace.Trace(countcallers=1)

# Trace a minibuffer command.

# Any function call will work. Leo's minibuffer commands are easily discoverable
# via tab completion and the 'print-commands' command.

#tracer.runfunc(c.executeMinibufferCommand, 'goto-prev-node')
tracer.runfunc(c.executeMinibufferCommand, 'scroll-outline-up-line')

top = p.insertAsLastChild().copy()
top.h = 'trace session'
displayCalltree(top, tracer.results().callers.keys())
c.redraw()
#@+node:ekr.20120318110848.9749: *6* displayCalltree
def displayCalltree(p, callinfo):
   '''
   Converts the function call hierarchy in 'callinfo' into a tree of function
   calls.  The function call tree is displayed to stdout as indented text
   and is inserted as a tree of leo nodes rooted at the given position 'p'
   '''
   callers = [k[0] for k in callinfo]
   callees = [k[1] for k in callinfo]

   # The first set of children will be those that don't have any callers
   # listed in callinfo
   toplevels = list(set(callers) - set(callees))
   positions = {}
   path = []

   # Depth-first traversal of the call hierarchy represented by 'callinfo'
   # 'levels' is a stack which grows during descend and shrinks
   # during ascend.  Each element of 'levels' is a list of unprocessed
   # siblings of each other
   levels = [toplevels]
   while len(levels) > 0:
       while len(levels[-1]) > 0:
           # Process the first element in the 'deepest' (i.e. last) list of siblings
           cur = levels[-1][0]
           levels[-1] = levels[-1][1:]
           indent = " " * 4 * (len(levels)-1)
           if cur not in path:
               if cur in positions.keys():
                   # Function already seen, so make a clone
                   clone = positions[cur].clone()
                   clone.moveToLastChildOf(p)
                   print (indent + "%s %s ..." % cur[1:])
               else:
                   # Haven't seen this function, so insert a new headline
                   p = p.insertAsLastChild().copy()
                   p.h = "%s %s" % cur[1:]
                   print (indent + p.h)

                   # Remember the position so it can be cloned if seen again
                   positions[cur] = p

                   # Find all callees of this function and descend
                   levels.append([c[1] for c in callinfo if c[0] == cur])
                   path.append(cur)
           else:
               r = p.insertAsLastChild().copy()
               r.h = "(recursive call) %s %s" % (cur[1], cur[2])
               print(indent + r.h + "...")

       # Ascend back up one level
       path = path[0:-1]
       p = p.parent()
       levels = levels[0:-1]
#@+node:ekr.20120318110848.9750: *6* trace session
#@+node:ekr.20120314064059.9737: *4* Use ctrl-click to open url's
- (Done) Added the following commands:
    
    - ctrl-click-icon
    - ctrl-click-at-cursor
    - open-url
    - open-url-under-cursor
    
- (Done) Double-click *only* edits headline.
- (Done) Only look at first line of the body in @url nodes.
- (Done) Ctrl-click in body allows spaces in url's.

#@+node:ekr.20120322073519.10402: *3* final
#@+node:ekr.20120327163022.9737: *4* Bugs
#@+node:ekr.20120322073519.9785: *5* Fixed crasher in flattenOutline
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 553, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 2120, in flattenOutline
    c.importCommands.flattenOutline(fileName)
  File "c:\leo.repo\trunk\leo\core\leoImport.py", line 479, in flattenOutline
    theFile.write(s)
TypeError: must be str, not bytes
#@+node:ekr.20031218072017.1147: *6* ic.flattenOutline
def flattenOutline (self,fileName):

    c = self.c ; nl = g.u(self.output_newline)
    p = c.currentVnode()
    if not p: return
    self.setEncoding()
    firstLevel = p.level()

    try:
        theFile = open(fileName,'wb')
            # Fix crasher: open in 'wb' mode.
    except IOError:
        g.es("can not open",fileName,color="blue")
        c.testManager.fail()
        return

    for p in p.self_and_subtree():
        head = p.moreHead(firstLevel)
        s = head + nl
        if g.isPython3:
            s = g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
        theFile.write(s)
        body = p.moreBody() # Inserts escapes.
        if len(body) > 0:
            s = g.toEncodedString(body + nl,self.encoding,reportErrors=True)
            theFile.write(s)
    theFile.close()
#@+node:ekr.20120323110755.9687: *5* Fix viewrendered crash
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoPlugins.py", line 337, in callTagHandler
    result = handler(tag,keywords)
  File "c:\leo.repo\trunk\leo\plugins\viewrendered.py", line 560, in update
    f(s,keywords)
  File "c:\leo.repo\trunk\leo\plugins\viewrendered.py", line 655, in update_graphics_script
    pc.gs = QtGui.QGraphicsScene(pc.splitter)
AttributeError: 'ViewRenderedController' object has no attribute 'splitter'
#@+node:ekr.20120323124339.9722: *5* Fixed(mostly)scrolling problem with multiple editors
@language python
@language rest
Selecting body editor with clicks doesn't save/restore visual ivars.
The solution would be to create a new onClick event handler...
#@+node:ekr.20120212060348.10374: *6*  << global switches >>
trace_startup = False
    # These traces use print instead of g.trace so that
    # the traces can add class info the method name.

new_modes = False
    # True: use ModeController and ModeInfo classes.
if new_modes: print('***** new_modes')

new_keys = False
    # This project hardly seems urgent.
    # True: Qt input methods produce a **user setting**, not a stroke.
if new_keys: print('***** new_keys')

# Debugging options...

enableDB = True
    # Don't even think about eliminating this constant:
    # it is needed for debugging.

no_scroll = False
    # True: disable all calls to w.setYScrollPosition.
no_see = False
    # True: disable all calls to w.see and w.seeInsertPoint.
    
# Tracing options...

trace_scroll = False
    # Trace calls to get/setYScrollPosition
trace_see = False
    # Trace calls to see and setInsertPoint.

# Switches to trace the garbage collector.
trace_gc = False           
trace_gc_calls = False    
trace_gc_calls = False 
trace_gc_verbose = False
trace_gc_inited = False

trace_masterCommand = False
trace_masterKeyHandler = False
trace_masterKeyHandlerGC = False
trace_minibuffer = False
trace_modes = False

# These print statements have been moved to writeWaitingLog.
# This allows for better --silent operation.
if 0:
    print('*** isPython3: %s' % isPython3)
    if not enableDB:
        print('** leoGlobals.py: caching disabled')

#@+node:ekr.20120324124808.9839: *6* Not changed
#@+node:ekr.20060528170438: *7* cycleEditorFocus (leoBody)
def cycleEditorFocus (self,event=None):

    '''Cycle keyboard focus between the body text editors.'''

    trace = False and not g.unitTesting
    c = self.c ; d = self.editorWidgets
    w = c.frame.body.bodyCtrl
    values = list(d.values())
    if len(values) > 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = list(d.values())[i]
        assert(w!=w2)
        self.selectEditor(w2)
        c.frame.body.bodyCtrl = w2
#@+node:ekr.20110605121601.18223: *7* Event handlers (qtBody)
#@+node:ekr.20110930174206.15472: *8* onFocusIn (qtBody)
def onFocusIn (self,obj):

    '''Handle a focus-in event in the body pane.'''

    trace = False and not g.unitTesting
    c = self.c
    
    if trace: g.trace(str(obj.objectName()))

    # 2010/08/01: Update the history only on focus in events.
    # 2011/04/02: Update history only in leoframe.tree.select.
    # c.nodeHistory.update(c.p)
    
    if obj.objectName() == 'richTextEdit':
        wrapper = hasattr(obj,'leo_wrapper') and obj.leo_wrapper
        if wrapper and wrapper != self.bodyCtrl:
            self.selectEditor(wrapper)
        self.onFocusColorHelper('focus-in',obj)
        obj.setReadOnly(False)
        obj.setFocus() # Weird, but apparently necessary.
#@+node:ekr.20110930174206.15473: *8* onFocusOut (qtBody)
def onFocusOut (self,obj):

    '''Handle a focus-out event in the body pane.'''
    
    trace = False and not g.unitTesting

    if trace: g.trace(str(obj.objectName()))
    
    # Apparently benign.
    if obj.objectName() == 'richTextEdit':
        self.onFocusColorHelper('focus-out',obj)
        obj.setReadOnly(True)
    
#@+node:ekr.20110605121601.18224: *8* onFocusColorHelper (qtBody)
badFocusColors = []

def onFocusColorHelper(self,kind,obj):

    trace = False and not g.unitTesting
    
    c = self.c ; w = c.frame.body.bodyCtrl
    
    if trace: g.trace(kind)
    
    if kind == 'focus-in':
        # if trace: g.trace('%9s' % (kind),'calling c.k.showStateColors()')
        c.k.showStateColors(inOutline=False,w=self.widget)
    else:
        bg = self.unselectedBackgroundColor
        fg = self.unselectedForegroundColor
        c.frame.body.setEditorColors(bg,fg)

    w.widget.ensureCursorVisible()
        # 2011/10/02: Fix cursor-movement bug.
#@+node:ekr.20111002125540.7021: *7* get/setYScrollPosition (LeoQTextBrowser)
def getYScrollPosition(self):
    
    trace = False and g.trace_scroll and not g.unitTesting

    w = self
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    if trace: g.trace(pos)
    return pos

def setYScrollPosition(self,pos):
    
    trace = g.trace_scroll and not g.unitTesting
    w = self

    if g.no_scroll:
        return
    elif pos is None:
        if trace: g.trace('None')
    else:
        if trace: g.trace(pos,g.callers())
        sb = w.verticalScrollBar()
        sb.setSliderPosition(pos)
#@+node:ekr.20031218072017.4037: *7* setSelectionAreas (leoBody)
def setSelectionAreas (self,before,sel,after):

    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    body = self ; w = body.bodyCtrl
    
    # 2012/02/05: save/restore Yscroll position.
    pos = w.getYScrollPosition()
    s = w.getAllText()
    before = before or ''
    sel = sel or ''
    after = after or ''
    w.delete(0,len(s))
    w.insert(0,before+sel+after)
    i = len(before)
    j = max(i,len(before)+len(sel)-1)
    # g.trace(i,j,repr(sel))
    w.setSelectionRange(i,j,insert=j)
    w.setYScrollPosition(pos)
    return i,j
#@+node:ekr.20110605121601.18098: *7* setYScrollPosition (leoQTextEditWidget)
def setYScrollPosition(self,pos):
    
    trace = False and g.trace_scroll and not g.unitTesting
    w = self.widget
    
    if g.no_scroll:
        return
    elif pos is None:
        if trace: g.trace('None')
    else:
        if trace: g.trace(pos,g.callers())
        sb = w.verticalScrollBar()
        sb.setSliderPosition(pos)
#@+node:ekr.20031218072017.3344: *7* v.__init
# To support ZODB, the code must set v._p_changed = 1 whenever
# v.unknownAttributes or any mutable vnode object changes.

def __init__ (self,context):

    # The primary data: headline and body text.
    self._headString = g.u('newHeadline')
    self._bodyString = g.u('')

    # Structure data...
    self.children = [] # Ordered list of all children of this node.
    self.parents = [] # Unordered list of all parents of this node.

    # Other essential data...
    self.fileIndex = g.app.nodeIndices.getNewIndex()
        # The immutable file index for this vnode.
        # New in Leo 4.6 b2: allocate gnx (fileIndex) immediately.
    self.iconVal = 0 # The present value of the node's icon.
    self.statusBits = 0 # status bits

    # v.t no longer exists.  All code must now be aware of the one-node world.
    # self.t = self # For compatibility with scripts and plugins.

    # Information that is never written to any file...
    self.context = context # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.insertSpot = None # Location of previous insert point.
    self.scrollBarSpot = None # Previous value of scrollbar position.
    self.selectionLength = 0 # The length of the selected body text.
    self.selectionStart = 0 # The start of the selected body text.
#@+node:ekr.20100303074003.5638: *7* v.saveCursorAndScroll
def saveCursorAndScroll(self,w):
    
    trace = (False or g.trace_scroll) and not g.unitTesting

    v = self
    if not w: return
    
    try:
        v.scrollBarSpot = w.getYScrollPosition()
        v.insertSpot = w.getInsertPoint()
        if trace: g.trace(v.scrollBarSpot,v.insertSpot)
    except AttributeError:
        # 2011/03/21: w may not support the high-level interface.
        pass
#@+node:ekr.20120324124808.9835: *6* Changed
@language python
@language rest

- Removed insert=None,new_p=None args from all versions of setAllText.
  These are entirely misguided, and may have contributed to scrolling problems.
  
  setAllText now *only* sets text, nothing else!

- All calls to leoMoveCursorHelper are follwed by code that updates
  v.insertSpot, v.selectionStart and v.selectionLength.
  
- v.restoreCursorAndScroll now *carefully* restores selection
  based on v.insertSpot, v.selectionStart and v.selectionLength.
  It also restores the scrollbar using v.scrollBarSpot.
  
- < < unselect the old node > > (selectHelper) now *only*
  sets v.scrollBarSpot.
  
#@+node:ekr.20050920084036.136: *7* exchangePointMark
def exchangePointMark (self,event):

    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''

    trace = False and not g.unitTesting
    c = self.c
    w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind='exchange',extend=False)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange(sort=False)
        if i == j: return

        ins = w.getInsertPoint()
        ins = g.choose(ins==i,j,i)
        w.setInsertPoint(ins)
        w.setSelectionRange(i,j,insert=None)
#@+node:ekr.20090530181848.6035: *7* movePageHelper
def movePageHelper(self,event,kind,extend): # kind in back/forward.

    '''Move the cursor up/down one page, possibly extending the selection.'''

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    linesPerPage = 15 # To do.

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(
            kind=g.choose(kind=='forward','page-down','page-up'),
            extend=extend,linesPerPage=linesPerPage)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        ins = w.getInsertPoint()
        s = w.getAllText()
        lines = g.splitLines(s)
        row,col = g.convertPythonIndexToRowCol(s,ins)
        row2 = g.choose(kind=='back',
            max(0,row-linesPerPage),
            min(row+linesPerPage,len(lines)-1))
        if row == row2: return
        spot = g.convertRowColToPythonIndex(s,row2,col,lines=lines)
        if trace: g.trace('spot',spot,'row2',row2)
        self.extendHelper(w,extend,spot,upOrDown=True)
#@+node:ekr.20100109094541.6227: *7* moveToBufferHelper
def moveToBufferHelper (self,event,spot,extend):

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        if spot == 'home':
            self.moveToHelper(event,0,extend=extend)
        elif spot == 'end':
            s = w.getAllText()
            self.moveToHelper(event,len(s),extend=extend)
        else:
            g.trace('can not happen: bad spot',spot)
#@+node:ekr.20100109094541.6228: *7* moveToCharacterHelper
def moveToCharacterHelper (self,event,spot,extend):

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        i = w.getInsertPoint()
        if spot == 'left':
            i=max(0,i-1)
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'right':
            i = min(i+1,len(w.getAllText()))
            self.moveToHelper(event,i,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@+node:ekr.20060113105246.1: *7* moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=direction,extend=extend)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        # Find the start of the next/prev line.
        row,col = g.convertPythonIndexToRowCol(s,ins)
        if trace:
            gui_ins = w.toGuiIndex(ins)
            bbox = w.bbox(gui_ins)
            if bbox:
                x,y,width,height = bbox
                # bbox: x,y,width,height;  dlineinfo: x,y,width,height,offset
                g.trace('gui_ins',gui_ins,'dlineinfo',w.dlineinfo(gui_ins),'bbox',bbox)
                g.trace('ins',ins,'row',row,'col',col,
                    'event.x',event and event.x,'event.y',event and event.y)
                g.trace('subtracting line height',w.index('@%s,%s' % (x,y-height)))
                g.trace('adding      line height',w.index('@%s,%s' % (x,y+height)))
        i,j = g.getLine(s,ins)
        if direction == 'down':
            i2,j2 = g.getLine(s,j)
        else:
            i2,j2 = g.getLine(s,i-1)

        # The spot is the start of the line plus the column index.
        n = max(0,j2-i2-1) # The length of the new line.
        col2 = min(col,n)
        spot = i2 + col2
        if trace: g.trace('spot',spot,'n',n,'col',col,'line',repr(s[i2:j2]))

        self.extendHelper(w,extend,spot,upOrDown=True)
#@+node:ekr.20100109094541.6231: *7* moveWithinLineHelper
def moveWithinLineHelper (self,event,spot,extend):

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    # g.trace(hasattr(w,'leoMoveCursorHelper'))
    
    # Bug fix: 2012/02/28: don't use the Qt end-line logic:
    # it apparently does not work for wrapped lines.
    if hasattr(w,'leoMoveCursorHelper') and spot != 'end-line':
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i,j = g.getLine(s,ins)
        if spot == 'start-line':
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'end-line':
            # Bug fix: 2011/11/13: Significant in external tests.
            if g.match(s,j-1,'\n'): j -= 1
            self.moveToHelper(event,j,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@+node:ekr.20110605121601.18077: *7* leoMoveCursorHelper & helper (leoQTextEditWidget)
def leoMoveCursorHelper (self,kind,extend=False,linesPerPage=15):

    '''Move the cursor in a QTextEdit.'''

    trace = False and not g.unitTesting
    verbose = True
    w = self.widget
    if trace:
        g.trace(kind,'extend',extend)
        if verbose:
            g.trace(len(w.toPlainText()))

    tc = QtGui.QTextCursor
    d = {
        'exchange': True, # Dummy.
        'down':tc.Down,'end':tc.End,'end-line':tc.EndOfLine,
        'home':tc.Start,'left':tc.Left,'page-down':tc.Down,
        'page-up':tc.Up,'right':tc.Right,'start-line':tc.StartOfLine,
        'up':tc.Up,
    }
    kind = kind.lower()
    op = d.get(kind)
    mode = g.choose(extend,tc.KeepAnchor,tc.MoveAnchor)

    if not op:
        return g.trace('can not happen: bad kind: %s' % kind)

    if kind in ('page-down','page-up'):
        self.pageUpDown(op, mode)
    elif kind == 'exchange': # exchange-point-and-mark
        cursor = w.textCursor()
        anchor = cursor.anchor()
        pos = cursor.position()
        cursor.setPosition(pos,tc.MoveAnchor)
        cursor.setPosition(anchor,tc.KeepAnchor)
        w.setTextCursor(cursor)
    else:
        if not extend:
            # Fix an annoyance. Make sure to clear the selection.
            cursor = w.textCursor()
            cursor.clearSelection()
            w.setTextCursor(cursor)
        w.moveCursor(op,mode)
        
    # 2012/03/25.  Add this common code.
    self.seeInsertPoint()
    self.rememberSelectionAndScroll()
    self.c.frame.updateStatusLine()
#@+node:btheado.20120129145543.8180: *8* pageUpDown
def pageUpDown (self, op, moveMode):

    '''The QTextEdit PageUp/PageDown functionality seems to be "baked-in"
       and not externally accessible.  Since Leo has its own keyhandling
       functionality, this code emulates the QTextEdit paging.  This is
       a straight port of the C++ code found in the pageUpDown method
       of gui/widgets/qtextedit.cpp'''

    control = self.widget
    cursor = control.textCursor()
    moved = False
    lastY = control.cursorRect(cursor).top()
    distance = 0
    # move using movePosition to keep the cursor's x
    while True:
        y = control.cursorRect(cursor).top()
        distance += abs(y - lastY)
        lastY = y
        moved = cursor.movePosition(op, moveMode)
        if (not moved or distance >= control.height()):
            break
    tc = QtGui.QTextCursor
    sb = control.verticalScrollBar()
    if moved:
        if (op == tc.Up):
            cursor.movePosition(tc.Down, moveMode)
            sb.triggerAction(QtGui.QAbstractSlider.SliderPageStepSub)
        else:
            cursor.movePosition(tc.Up, moveMode)
            sb.triggerAction(QtGui.QAbstractSlider.SliderPageStepAdd)
    control.setTextCursor(cursor)
#@+node:ekr.20110605121601.18209: *7* deactivateEditors (qtBody)
def deactivateEditors(self,wrapper):

    '''Deactivate all editors except wrapper's editor.'''

    trace = False and not g.unitTesting
    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        wrapper2 = d.get(key)
        w2 = wrapper2.widget
        if hasattr(w2,'leo_active'):
            active = w2.leo_active
        else:
            active = True
        if wrapper2 != wrapper and active:
            w2.leo_active = False
            self.unselectLabel(wrapper2)
            if trace: g.trace(w2)
            self.onFocusOut(w2)
#@+node:ekr.20120325032957.9730: *7* rememberSelectionAndScroll (leoQtBaseTextWidget)
def rememberSelectionAndScroll(self):

    trace = (False or g.trace_scroll) and not g.unitTesting

    w = self
    v = self.c.p.v # Always accurate.
    v.insertSpot = ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    if i > j: i,j = j,i
    assert(i<=j)
    v.selectionStart = i
    v.selectionLength = j-i
    v.scrollBarSpot = spot = w.getYScrollPosition()
    
    if trace: g.trace(id(v),id(w),i,j,ins,spot,v.h)
#@+node:ekr.20110605121601.18044: *7* selectAllText (leoQtBaseTextWidget)
def selectAllText(self,insert=None):

    w = self.widget
    w.selectAll()
    # if insert is not None:
        # self.setInsertPoint(insert)
    # Bug fix: 2012/03/25.
    self.setSelectionRange(0,'end',insert=insert)
   
#@+node:ekr.20110605121601.18203: *7* selectEditorHelper (qtBody)
def selectEditorHelper (self,wrapper):

    trace = False and not g.unitTesting
    c = self.c ; cc = c.chapterController
    d = self.editorWidgets
    assert isinstance(wrapper,leoQTextEditWidget),wrapper
    w = wrapper.widget
    assert isinstance(w,QtGui.QTextEdit),w

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    # The actual switch.
    self.deactivateEditors(wrapper)
    self.recolorWidget (w.leo_p,wrapper) # switches colorizers.
    # g.trace('c.frame.body',c.frame.body)
    # g.trace('c.frame.body.bodyCtrl',c.frame.body.bodyCtrl)
    # g.trace('wrapper',wrapper)
    
    c.frame.body.bodyCtrl = wrapper
    c.frame.body.widget = wrapper # Major bug fix: 2011/04/06
    w.leo_active = True

    self.switchToChapter(wrapper)
    self.selectLabel(wrapper)

    if not self.ensurePositionExists(w):
        return g.trace('***** no position editor!')
    if not (hasattr(w,'leo_p') and w.leo_p):
        return g.trace('***** no w.leo_p',w)
        
    p = w.leo_p
    assert p,p

    if trace: g.trace('wrapper %s old %s p %s' % (
        id(wrapper),c.p.h,p.h))

    c.expandAllAncestors(p)
    c.selectPosition(p)
        # Calls assignPositionToEditor.
        # Calls p.v.restoreCursorAndScroll.
    c.redraw()
    c.recolor_now()
    c.bodyWantsFocus()
#@+node:ekr.20070423101911: *7* selectHelper (leoTree) (changed 4.10)
# Do **not** try to "optimize" this by returning if p==c.p.
# 2011/11/06: *event handlers* are called only if p != c.p.

def selectHelper (self,p,scroll):

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.p
    
    call_event_handlers = p != old_p

    if p:
        # 2009/10/10: selecting a foreign position
        # will not be pretty.
        assert p.v.context == c
    else:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    # if trace and (verbose or call_event_handlers):
        # g.trace(p and p.h,g.callers())
            
    if call_event_handlers:
        unselect = not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    else:
        unselect = True

    if unselect:
        << unselect the old node >>
        
    if call_event_handlers:
        g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        
    if call_event_handlers:
        if call_event_handlers:
            select = not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        else:
            select = True
        if select:
            << select the new node >>
            c.nodeHistory.update(p) # Remember this position.
    else:
        if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
            << select the new node >>
            c.nodeHistory.update(p) # Remember this position.
        
    c.setCurrentPosition(p)
    << set the current node >>
    p.restoreCursorAndScroll(w)
        # Was in setBodyTextAfterSelect (in <select the new node>)
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    # if trace and (verbose or call_event_handlers):
        # g.trace('**** after old: %s new %s' % (
            # old_p and len(old_p.b),len(p.b)))

    # what UNL.py used to do
    c.frame.clearStatusLine()
    c.frame.putStatusLine(p.get_UNL())

    if call_event_handlers: # 2011/11/06
        g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
#@+node:ekr.20120325072403.7771: *8* << unselect the old node >> (selectHelper)
# Remember the position of the scrollbar *before* making any changes.
# This does not work if we are switching body editors!
    # if old_p:
        # old_p.v.scrollBarSpot = yview = body.getYScrollPosition() if body else None
        # if trace: g.trace('old scroll: %3s insert: %3s %s' % (
            # yview,old_p.v.insertSpot,old_p.h))
        
# Remember the selection range and insert point.
# This does not work if we are switching body editors!
# Instead, w.setInsertPoint and w.setSelectionRangeHelper should do the saving.

    # if old_p and body:
        # old_p.v.insertSpot = ins = body.getInsertPoint()
        # i,j = body.getSelectionRange()
        # assert(i<=j)
        # old_p.v.selectionStart = i
        # old_p.v.selectionLength = j-i
        # if trace: g.trace(i,j,ins)
    
# New in Leo 4.10: the code sets v.insertSpot as soon as it changes (not here).

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)
#@+node:ekr.20040803072955.133: *8* << set the current node >> (selectHelper)
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

# Was in ctor.
use_chapters = c.config.getBool('use_chapters')

if use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.h)

c.treeFocusHelper() # 2010/12/14
c.undoer.onSelect(old_p,p)
#@+node:ekr.20120325072403.7767: *8* << select the new node >> (selectHelper)
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.h
frame.setWrap(p)
self.setBodyTextAfterSelect(p,old_p)
#@+node:ekr.20110605121601.18092: *7* setAllText (leoQTextEditWidget) & helper (changed 4.10)
def setAllText(self,s):

    '''Set the text of the widget.

    If insert is None, the insert point, selection range and scrollbars are initied.
    Otherwise, the scrollbars are preserved.'''

    trace = False and not g.unitTesting
    verbose = False
    c,w = self.c,self.widget
    colorizer = c.frame.body.colorizer
    highlighter = colorizer.highlighter
    colorer = highlighter.colorer

    # Set a hook for the colorer.
    colorer.initFlag = True

    if trace and verbose: t1 = g.getTime()

    try:
        self.changingText = True # Disable onTextChanged
        colorizer.changingText = True
        w.setReadOnly(False)
        w.setPlainText(s)
    finally:
        self.changingText = False
        colorizer.changingText = False

    if trace and verbose: g.trace(g.timeSince(t1))
    
#@+node:ekr.20090608081524.6109: *7* setBodyTextAfterSelect (changed 4.10)
def setBodyTextAfterSelect (self,p,old_p):
    
    # trace = g.trace_scroll and not g.unitTesting

    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c ; w = c.frame.body.bodyCtrl
    s = p.v.b # Guaranteed to be unicode.
    old_s = w.getAllText()

    if p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
        pass
    else:
        # w.setAllText destroys all color tags, so do a full recolor.
        w.setAllText(s)
        colorizer = c.frame.body.colorizer
        if hasattr(colorizer,'setHighlighter'):
            colorizer.setHighlighter(p)
        self.frame.body.recolor(p)

    # This is now done after c.p has been changed.
        # p.restoreCursorAndScroll(w)
#@+node:ekr.20110605121601.18095: *7* setInsertPoint (leoQTextEditWidget)
def setInsertPoint(self,i):
    
    # Fix bug 981849: incorrect body content shown.
    # Use the more careful code in setSelectionRangeHelper & lengthHelper.
    self.setSelectionRangeHelper(i=i,j=i,insert=i)
    
    # trace = (True or g.trace_scroll) and not g.unitTesting

    # w = self.widget
    # s = w.toPlainText()
    # i = self.toPythonIndex(i)
    # i = max(0,min(i,len(s)))
    
    # cursor = w.textCursor()
    # cursor.setPosition(i)
    # w.setTextCursor(cursor)
    
    # # Remember the values for v.restoreCursorAndScroll.
    # v = self.c.p.v # Always accurate.
    # v.insertSpot = i
    # v.selectionStart = i
    # v.selectionLength = 0
    # v.scrollBarSpot = spot = w.getYScrollPosition()
    
    # if trace: g.trace(i,v.h)

#@+node:ekr.20110605121601.18096: *7* setSelectionRangeHelper & helper (leoQTextEditWidget)
def setSelectionRangeHelper(self,i,j,insert=None):

    trace = (False or g.trace_scroll) and not g.unitTesting

    w = self.widget
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)

    n = self.lengthHelper()
    i = max(0,min(i,n))
    j = max(0,min(j,n))
    if insert is None:
        ins = max(i,j)
    else:
        ins = self.toPythonIndex(insert)
        ins = max(0,min(ins,n))

    # 2010/02/02: Use only tc.setPosition here.
    # Using tc.movePosition doesn't work.
    tc = w.textCursor()
    if i == j:
        tc.setPosition(i)
    elif ins == j:
        # Put the insert point at j
        tc.setPosition(i)
        tc.setPosition(j,tc.KeepAnchor)
    else:
        # Put the insert point a i
        tc.setPosition(j)
        tc.setPosition(i,tc.KeepAnchor)
    w.setTextCursor(tc)

    # Remember the values for v.restoreCursorAndScroll.
    v = self.c.p.v # Always accurate.
    v.insertSpot = ins
    if i > j: i,j = j,i
    assert(i<=j)
    v.selectionStart = i
    v.selectionLength = j-i
    v.scrollBarSpot = spot = w.getYScrollPosition()
    if trace: g.trace('i: %s j: %s ins: %s spot: %s %s' % (i,j,ins,spot,v.h))
#@+node:ekr.20110605121601.18097: *8* lengthHelper
def lengthHelper(self):

    '''Return the length of the text.'''

    w = self.widget
    tc = w.textCursor()
    tc.movePosition(QtGui.QTextCursor.End)
    n = tc.position()
    return n

#@+node:ekr.20100303074003.5636: *7* v.restoreCursorAndScroll (changed 4.10)
# Called only by leoTree.selectHelper.

def restoreCursorAndScroll (self,w):
    
    trace = (False or g.trace_scroll) and not g.unitTesting
    v = self
    ins = v.insertSpot
    start,n = v.selectionStart,v.selectionLength
    spot = v.scrollBarSpot
    
    # Fix bug 981849: incorrect body content shown.
    if ins is None: ins = 0
    w.setInsertPoint(ins)

    if g.no_scroll:
        return

    # Override any changes to the scrollbar setting that might
    # have been done above by w.setSelectionRange or w.setInsertPoint.
    if spot is not None:
        w.setYScrollPosition(spot)
    v.scrollBarSpot = spot
        
    if trace: g.trace('start: %s n: %s ins: %s spot: %s %s' % (
        start,n,ins,spot,v.h))
        
    # Never call w.see here.
#@+node:ekr.20120327062318.9731: *5* Ensure selected @test node is run
In earlier version of Leo if one runs test externally with the selected
position under @test node, that @test was executed with (run-marked-unit-tests-externally)

The fix was to the "important special case" in TM.findAllUnitTestNodes.
#@+node:ekr.20120327062318.9732: *5* Made sure the new load code loads plugins at most once
@language python
@language rest

new load code, double init. for free layout
http://groups.google.com/group/leo-editor/browse_thread/thread/dd16ac6dc1832eb2

bookmarks.py was the culprit. The code in onCreate must test to see if c.free_layout already exists.
#@+node:ekr.20120326061010.9726: *5* fixed problem with file:/// url's on Windows
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/bb063866875a81c3#

In my installation, now on the latest revision ( r5195) I'm still
experiencing an issue with the '@url command' using 'File-URL' in a Windows
environement.

I'm able to create the Leo User documentation locally. - However, when I
try to read the documentation using the 'File-URL'

file:///D:/Branches/leo-editor/leo/doc/html/_build/html/leo_toc.html

I get the following message in the Leo-Log.

<log>

File 'D:\D:\Branches\leo-editor\leo\doc\html\_build\html\leo_toc.html' does not exist

</log>

However if I enter this URL directly into FF it is found and displayed properly.

EKR: Obviously, the 'D:\D:\' is the problem.

The fix is simply to special-case file:/// on Windows in g.computeFileUrl.
#@+node:ekr.20120327163022.9736: *5* fixed get_fn in viewrendered plugin
@language rest
groups.google.com/group/leo-editor/browse_thread/thread/bb063866875a81c3/6162e6108b09428e

The new code is much like g.computeFileUrl.
#@+node:ekr.20120327163022.9741: *5* Restored special case for run-selected-unit-tests
@language rest

Added code to findAllUnitTestNodes to look up the tree for @test & @suite nodes
if none have been found so far.  Only for the run-unit-tests-externally/locally.
#@+node:ekr.20120321174708.9744: *5* Fixed failing unit tests in distro
@nocolor-node

The @test at.readOneAtShadowNode retains @shadow links node
give fail1: test not set up properly.
The outline is then corrupted, causing other unit tests to fail.
The partial solution is not to call the undo command in the finally clause.
#@+node:ekr.20120327163022.9739: *4* Features
#@+node:ekr.20120324124808.9833: *5* Alt-Home & Alt-End collapse all possible nodes
#@+node:ekr.20120326061010.9728: *5* Added g.restore_selection_range
@nocolor-node

If off, only the insert point is restored.

It's kinda pointless to make this a user option.
#@+node:ekr.20120212060348.10374: *6*  << global switches >>
trace_startup = False
    # These traces use print instead of g.trace so that
    # the traces can add class info the method name.

new_modes = False
    # True: use ModeController and ModeInfo classes.
if new_modes: print('***** new_modes')

new_keys = False
    # This project hardly seems urgent.
    # True: Qt input methods produce a **user setting**, not a stroke.
if new_keys: print('***** new_keys')

# Debugging options...

enableDB = True
    # Don't even think about eliminating this constant:
    # it is needed for debugging.

no_scroll = False
    # True: disable all calls to w.setYScrollPosition.
no_see = False
    # True: disable all calls to w.see and w.seeInsertPoint.
    
# Tracing options...

trace_scroll = False
    # Trace calls to get/setYScrollPosition
trace_see = False
    # Trace calls to see and setInsertPoint.

# Switches to trace the garbage collector.
trace_gc = False           
trace_gc_calls = False    
trace_gc_calls = False 
trace_gc_verbose = False
trace_gc_inited = False

trace_masterCommand = False
trace_masterKeyHandler = False
trace_masterKeyHandlerGC = False
trace_minibuffer = False
trace_modes = False

# These print statements have been moved to writeWaitingLog.
# This allows for better --silent operation.
if 0:
    print('*** isPython3: %s' % isPython3)
    if not enableDB:
        print('** leoGlobals.py: caching disabled')

#@+node:ekr.20100303074003.5636: *6* v.restoreCursorAndScroll (changed 4.10)
# Called only by leoTree.selectHelper.

def restoreCursorAndScroll (self,w):
    
    trace = (False or g.trace_scroll) and not g.unitTesting
    v = self
    ins = v.insertSpot
    start,n = v.selectionStart,v.selectionLength
    spot = v.scrollBarSpot
    
    # Fix bug 981849: incorrect body content shown.
    if ins is None: ins = 0
    w.setInsertPoint(ins)

    if g.no_scroll:
        return

    # Override any changes to the scrollbar setting that might
    # have been done above by w.setSelectionRange or w.setInsertPoint.
    if spot is not None:
        w.setYScrollPosition(spot)
    v.scrollBarSpot = spot
        
    if trace: g.trace('start: %s n: %s ins: %s spot: %s %s' % (
        start,n,ins,spot,v.h))
        
    # Never call w.see here.
#@+node:ekr.20120327163022.9738: *4* Home page
#@+node:ekr.20111027103125.16545: *5* Added link to home page from the TOC
#@+node:ekr.20120229173025.20629: *5* Removed online-tutorial link
http://groups.google.com/group/leo-editor/browse_thread/thread/2157d8bfc0f381f1

es, choosing Help-->"Open Online Tutorial" tries to go to a page on
3dTree.com the site for which is no longer held.

Should the Quick Intro be brought back instead? 
#@+node:ekr.20111027103125.16539: *5* Added search box to Leo's home page
<div id="searchbox" style="">
<h3>Quick search</h3>

<form class="search" method="get" action="search.html">

<p class="searchtip" style="font-size: 90%"> Enter search terms or a module, class or function name. </p>
</div>
#@+node:ekr.20111020120612.15896: *5* Added link to glossary from Leo's home page
#@+node:ekr.20111027103125.16544: *5* Added screen shot to Leo's home page
#@+node:ekr.20110930174206.15470: *5* Brought screen shots up to date
#@+node:ekr.20120326061010.9727: *5* Scaled the screenshot on home page
http://groups.google.com/group/leo-editor/browse_thread/thread/ea3c29888d8ac92b

> - Added a full-sized screenshot at the bottom of the page.
>  I'm not sure whether this is a good idea.  What do you think?

Scaled the screen-shot using:

http://stackoverflow.com/questions/3029422/image-auto-resize-to-fit-div-container
#@+node:ekr.20120323124339.9721: *4* Investigated problem with desktop shortcut
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/a03661d8c1eec0c6

I'm experimenting with the latest version (WinXP). This is really odd. If I
launch Leo using the desktop shortcut, I'm not able to open *any* valid
.leo file except  LeoSettings.leo. This is the shortcut:
C:\Python32\pythonw.exe "C:\Program Files\Leo-4.10-b1\launchLeo.py"

However, if I launch using my Windows batch file, I'm able to open all
files as expected. The code is:
C:\Python32\python "C:\Program Files\Leo-4.10-b1\launchLeo.py" %*

Anyone else experiencing this? Any possible explanation?

EKR: Are you doing this in a console window? 

No, that's why I used the batch file so I can launch w/ a console. When I
do, it works fine. 

I just installed on another box w/ Python 2.6.2 That works fine. The other
box has Python 3.2, not sure why that matters, but it might be a clue.
#@+node:ekr.20120327163022.9742: *5* EKR response
@language rest

There are two differences between the two ways of launching.

1. pythonw.exe vs python.exe

2. The former has no "%*" argument.  It's possible that you have no
workbook.leo file in your home directory, which might cause a failure,
iirc.

I suggest first changing pythonw to python.  This will open a console,
but probably too briefly to read.  To fix this, add a -i argument,
which will drop python into interactive mode, which has the side
effect of leaving the console open.  This should tell you why exactly
nothing happens.

I suspect that adding the "%*" argument will fix the problem,
regardless of whether you use pythonw or python.

If not, please feel free to ask more questions.
#@+node:ekr.20120329072206.9701: ** 4.10.1
#@+node:ekr.20120330040023.9780: *3* Bugs
#@+node:ekr.20120330040023.9779: *4* Restore focus on window activation
#@+node:ekr.20110607182447.16456: *5* Event handlers (qtGui)
#@+node:ekr.20110605121601.18480: *6* onActivateEvent (qtGui)
# Called from eventFilter

def onActivateEvent (self,event,c,obj,tag):

    '''Put the focus in the body pane when the Leo window is
    activated, say as the result of an Alt-tab or click.'''

    # This is called several times for each window activation.
    # We only need to set the focus once.

    trace = False and not g.unitTesting

    if trace: g.trace(tag)
    
    if c.exists and tag == 'body':
        self.active = True
        # Retain the focus that existed when the deactivate event happened.
            # c.bodyWantsFocusNow()
        g.doHook('activate',c=c,p=c.p,v=c.p,event=event)
#@+node:ekr.20110605121601.18481: *6* onDeactiveEvent (qtGui)
def onDeactivateEvent (self,event,c,obj,tag):

    '''Put the focus in the body pane when the Leo window is
    activated, say as the result of an Alt-tab or click.'''

    trace = False and not g.unitTesting

    # This is called several times for each window activation.
    # Save the headline only once.

    if c.exists and tag.startswith('tree'):
        self.active = False
        if trace: g.trace()
        c.k.keyboardQuit(setFocus=False)
            # 2011/06/13.
            # 2011/09/29. Don't change the tab in the log pane.
        # c.endEditing()
        g.doHook('deactivate',c=c,p=c.p,v=c.p,event=event)
#@+node:ekr.20120409074150.9940: *4* The @auto read code now catches failed asserts in import code.
@nocolor-node

If an assert fails, the entire file is read into a single node.
#@+node:ekr.20120409182030.10028: *4* Fixed several problems with c-to-py command
@nocolor-node

An assert failed during scanning in mungeAllFunctions.

Added defensive code to mungeAllFunctions, dedentBlocks and
replaceComments. The new code simply increments a pointer if a "progress"
assert would fail. (The progress assert still exists, as a double-check.)

Fixed bug: the call to u.afterChangeGroup in the go() method is called only once.

Suppress warning messages given by CPrettyPrinter.indent.
#@+node:ekr.20120401144849.10036: *4* Fixed bug 971171: re .leoRecentFiles
@language python
@language rest

If If $(HOME)/.leo/.leoRecentFiles.txt does not exist,
the only recent file ever is the current file
https://bugs.launchpad.net/leo-editor/+bug/971171

The fix: rf.writeRecentFilesFile creates $(HOME)/.leo/.leoRecentFiles.txt if it does not exist.
#@+node:ekr.20120401144849.10035: *4* Fixed bugs 971166 & 979142 re copy/paste
@language python
@language rest

These bugs are really the same bug

Node body contents displayed is unpredictably incorrect
https://bugs.launchpad.net/leo-editor/+bug/979142

Prints to tabs in the Log Pane are UTF-8 encoded
https://bugs.launchpad.net/leo-editor/+bug/971166

The fix was:

1. Use the "slow" code in leoQTextEditWidget.get.
2. Use w.get/setAllText in leoFrame.pasteText.
#@+node:ekr.20120413152012.10048: *4* Minimize scrolling during paste-text
#@+node:ekr.20070130115927.7: *5* leoFrame.pasteText
def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    trace = False and not g.unitTesting
    f = self ; c = f.c
    w = event and event.widget
    wname = (w and c.widget_name(w)) or '<no widget>'
    if trace: g.trace(g.app.gui.isTextWidget(w),w)
    if not w or not g.app.gui.isTextWidget(w): return

    i,j = oldSel = w.getSelectionRange()  # Returns insert point if no selection.
    oldText = w.getAllText()

    if middleButton and c.k.previousSelection is not None:
        start,end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()

    # g.trace(type(s),s[:25])

    s = g.toUnicode(s)

    # g.trace('pasteText','wname',wname,'s',s,g.callers())

    singleLine = wname.startswith('head') or wname.startswith('minibuffer')

    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)
    w.see(i+len(s) + 2) # 2011/06/01

    if wname.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif singleLine:
        s = w.getAllText()
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # 2011/11/14: headline width methods do nothing at present.
        # if wname.startswith('head'):
            # The headline is not officially changed yet.
            # p.initHeadString(s)
            # width = f.tree.headWidth(p=None,s=s)
            # w.setWidth(width)
    else: pass

    return

OnPasteFromMenu = pasteText
#@+node:ekr.20110605121601.18092: *5* setAllText (leoQTextEditWidget) & helper (changed 4.10)
def setAllText(self,s):

    '''Set the text of the widget.

    If insert is None, the insert point, selection range and scrollbars are initied.
    Otherwise, the scrollbars are preserved.'''

    trace = False and not g.unitTesting
    verbose = False
    c,w = self.c,self.widget
    colorizer = c.frame.body.colorizer
    highlighter = colorizer.highlighter
    colorer = highlighter.colorer

    # Set a hook for the colorer.
    colorer.initFlag = True

    if trace and verbose: t1 = g.getTime()

    try:
        self.changingText = True # Disable onTextChanged
        colorizer.changingText = True
        w.setReadOnly(False)
        w.setPlainText(s)
    finally:
        self.changingText = False
        colorizer.changingText = False

    if trace and verbose: g.trace(g.timeSince(t1))
    
#@+node:ekr.20110605121601.18079: *5* delete (avoid call to setAllText) (leoQTextEditWidget)
def delete(self,i,j=None):

    trace = False and not g.unitTesting
    c,w = self.c,self.widget
    colorer = c.frame.body.colorizer.highlighter.colorer
    n = colorer.recolorCount

    if trace: g.trace(self.getSelectionRange())

    i = self.toGuiIndex(i)
    if j is None: j = i+1
    j = self.toGuiIndex(j)
    if i > j: i,j = j,i

    if trace: g.trace(i,j)

    # Set a hook for the colorer.
    colorer.initFlag = True

    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    cursor = w.textCursor()

    try:
        self.changingText = True # Disable onTextChanged

        old_i,old_j = self.getSelectionRange()
        if i == old_i and j == old_j:
            # Work around an apparent bug in cursor.movePosition.
            cursor.removeSelectedText()
        elif i == j:
            pass
        else:
            # g.trace('*** using dubious code')
            cursor.setPosition(i)
            moveCount = abs(j-i)
            cursor.movePosition(cursor.Right,cursor.KeepAnchor,moveCount)
            w.setTextCursor(cursor)  # Bug fix: 2010/01/27
            if trace:
                i,j = self.getSelectionRange()
                g.trace(i,j)
            cursor.removeSelectedText()
            if trace: g.trace(self.getSelectionRange())
    finally:
        self.changingText = False

    sb.setSliderPosition(pos)

    # g.trace('%s calls to recolor' % (colorer.recolorCount-n))
#@+node:ekr.20110605121601.18089: *5* insert (avoid call to setAllText) (leoQTextWidget)
def insert(self,i,s):

    c,w = self.c,self.widget
    colorer = c.frame.body.colorizer.highlighter.colorer
    n = colorer.recolorCount

    # Set a hook for the colorer.
    colorer.initFlag = True
    i = self.toGuiIndex(i)
    cursor = w.textCursor()
    try:
        self.changingText = True # Disable onTextChanged.
        cursor.setPosition(i)
        cursor.insertText(s) # This cause an incremental call to recolor.
        w.setTextCursor(cursor) # Bug fix: 2010/01/27
    finally:
        self.changingText = False
#@+node:ekr.20120418065452.10029: *4* Fixed bug 981849: incorrect body content shown
@language python
@language rest

https://bugs.launchpad.net/leo-editor/+bug/981849

Use the more careful code in setSelectionRangeHelper & lengthHelper.
#@+node:ekr.20100303074003.5636: *5* v.restoreCursorAndScroll (changed 4.10)
# Called only by leoTree.selectHelper.

def restoreCursorAndScroll (self,w):
    
    trace = (False or g.trace_scroll) and not g.unitTesting
    v = self
    ins = v.insertSpot
    start,n = v.selectionStart,v.selectionLength
    spot = v.scrollBarSpot
    
    # Fix bug 981849: incorrect body content shown.
    if ins is None: ins = 0
    w.setInsertPoint(ins)

    if g.no_scroll:
        return

    # Override any changes to the scrollbar setting that might
    # have been done above by w.setSelectionRange or w.setInsertPoint.
    if spot is not None:
        w.setYScrollPosition(spot)
    v.scrollBarSpot = spot
        
    if trace: g.trace('start: %s n: %s ins: %s spot: %s %s' % (
        start,n,ins,spot,v.h))
        
    # Never call w.see here.
#@+node:ekr.20110605121601.18096: *5* setSelectionRangeHelper & helper (leoQTextEditWidget)
def setSelectionRangeHelper(self,i,j,insert=None):

    trace = (False or g.trace_scroll) and not g.unitTesting

    w = self.widget
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)

    n = self.lengthHelper()
    i = max(0,min(i,n))
    j = max(0,min(j,n))
    if insert is None:
        ins = max(i,j)
    else:
        ins = self.toPythonIndex(insert)
        ins = max(0,min(ins,n))

    # 2010/02/02: Use only tc.setPosition here.
    # Using tc.movePosition doesn't work.
    tc = w.textCursor()
    if i == j:
        tc.setPosition(i)
    elif ins == j:
        # Put the insert point at j
        tc.setPosition(i)
        tc.setPosition(j,tc.KeepAnchor)
    else:
        # Put the insert point a i
        tc.setPosition(j)
        tc.setPosition(i,tc.KeepAnchor)
    w.setTextCursor(tc)

    # Remember the values for v.restoreCursorAndScroll.
    v = self.c.p.v # Always accurate.
    v.insertSpot = ins
    if i > j: i,j = j,i
    assert(i<=j)
    v.selectionStart = i
    v.selectionLength = j-i
    v.scrollBarSpot = spot = w.getYScrollPosition()
    if trace: g.trace('i: %s j: %s ins: %s spot: %s %s' % (i,j,ins,spot,v.h))
#@+node:ekr.20110605121601.18097: *6* lengthHelper
def lengthHelper(self):

    '''Return the length of the text.'''

    w = self.widget
    tc = w.textCursor()
    tc.movePosition(QtGui.QTextCursor.End)
    n = tc.position()
    return n

#@+node:ekr.20110605121601.18095: *5* setInsertPoint (leoQTextEditWidget)
def setInsertPoint(self,i):
    
    # Fix bug 981849: incorrect body content shown.
    # Use the more careful code in setSelectionRangeHelper & lengthHelper.
    self.setSelectionRangeHelper(i=i,j=i,insert=i)
    
    # trace = (True or g.trace_scroll) and not g.unitTesting

    # w = self.widget
    # s = w.toPlainText()
    # i = self.toPythonIndex(i)
    # i = max(0,min(i,len(s)))
    
    # cursor = w.textCursor()
    # cursor.setPosition(i)
    # w.setTextCursor(cursor)
    
    # # Remember the values for v.restoreCursorAndScroll.
    # v = self.c.p.v # Always accurate.
    # v.insertSpot = i
    # v.selectionStart = i
    # v.selectionLength = 0
    # v.scrollBarSpot = spot = w.getYScrollPosition()
    
    # if trace: g.trace(i,v.h)

#@+node:ekr.20120427064024.10062: *4* Fixed bug 711158: Warn if same .leo file open in another Leo instance
@language python
@language rest

Warn if same .leo file open in another Leo instance
https://bugs.launchpad.net/leo-editor/+bug/711158


What I did:

- The PickleShareDB object is created even if caching (of files) is disabled.
  This allows us to used g.app.db even when --no-cache is in effect.
  
- Added the three methods in app.Detecting already-open files.
#@+node:ekr.20100208082353.5920: *5* initGlobalDb
def initGlobalDB (self):

    trace = False and not g.unitTesting

    # New in Leo 4.10.1.
    # We always create the global db, even if caching is disabled.
    try:
        dbdirname = g.app.homeLeoDir + "/db/global"
        self.db = db = PickleShareDB(dbdirname)
        if trace: g.trace(db,dbdirname)
        self.inited = True
        return db
    except Exception:
        return {} # Use a plain dict as a dummy.
#@+node:ekr.20031218072017.1553: *5* fc.getLeoFile & helpers
# The caller should follow this with a call to c.redraw().

def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    # g.trace('*****',fileName)
    fc,c = self,self.c
    c.setChanged(False) # May be set when reading @file nodes.
    fc.warnOnReadOnlyFiles(fileName)
    fc.checking = False
    fc.mFileName = c.mFileName
    fc.initReadIvars()

    try:
        c.loading = True # disable c.changed
        ok = True if silent else g.app.checkForOpenFile(c,fileName)
        if ok:
            ok = fc.getLeoFileHelper(theFile,fileName,silent)
                # Read the .leo file and create the outline.
                
        # Always remember the file, even if we are going to close it immediately.
        g.app.rememberOpenFile(fileName)
    
        if ok:
            fc.resolveTnodeLists()
                # Do this before reading external files.
            c.setFileTimeStamp(fileName)
            
            if readAtFileNodesFlag:
                # Redraw before reading the @file nodes so the screen isn't blank.
                # This is important for big files like LeoPy.leo.
                c.redraw()
                fc.readExternalFiles(fileName)
            
            if c.config.getBool('check_outline_after_read'):
                c.checkOutline(event=None,verbose=True,unittest=False,full=True)
    finally:
        c.loading = False # reenable c.changed

    if c.changed:
        fc.propegateDirtyNodes()
    c.setChanged(c.changed) # Refresh the changed marker.
    fc.initReadIvars()
    return ok, c.frame.ratio
#@+node:ekr.20090526081836.5841: *6* fc.getLeoFileHelper
def getLeoFileHelper(self,theFile,fileName,silent):

    '''Read the .leo file and create the outline.'''

    c,fc = self.c,self
    try:
        ok = True
        v = fc.readSaxFile(theFile,fileName,silent,inClipboard=False,reassignIndices=False)
        if v: # v is None for minimal .leo files.
            c.setRootVnode(v)
            fc.rootVnode = v
        else:
            v = leoNodes.vnode(context=c)
            v.setHeadString('created root node')
            p = leoNodes.position(v)
            p._linkAsRoot(oldRoot=None)
            fc.rootVnode = v
            # c.setRootPosition()
            c.changed = False
    except BadLeoFile:
        junk, message, junk = sys.exc_info()
        if not silent:
            g.es_exception()
            c.alert(fc.mFileName + " is not a valid Leo file: " + str(message))
        ok = False

    return ok
#@+node:ekr.20100205060712.8314: *6* fc.handleNodeConflicts & helper
def handleNodeConflicts (self):

    c = self.c
    if not c.nodeConflictList: return

    # Find the last top-level node.
    sib = c.rootPosition()
    while sib.hasNext():
        sib.moveToNext()

    # Create the 'Recovered Nodes' node.
    root = sib.insertAfter()
    root.setHeadString('Recovered Nodes')
    root.expand()

    # For each conflict, create one child and two grandchildren.
    for bunch in c.nodeConflictList:
        tag = bunch.get('tag') or ''
        gnx = bunch.get('gnx') or ''
        fn  = bunch.get('fileName') or ''
        b1,h1 = bunch.get('b_old'),bunch.get('h_old')
        b2,h2 = bunch.get('b_new'),bunch.get('h_new')
        child = root.insertAsLastChild()
        h = 'Recovered node "%s from %s' % (h1,g.shortFileName(fn))
        child.setHeadString(h)
        # child.setBodyString('%s %s' % (tag,gnx))
        line1 = '%s %s\nDiff...\n' % (tag,gnx)
        d = difflib.Differ().compare(g.splitLines(b2),g.splitLines(b1))
        # d = difflib.unified_diff(g.splitLines(b2),g.splitLines(b1))
        diffLines = [z for z in d]
        lines = [line1]
        lines.extend(diffLines)
        # There is less need to show trailing newlines because
        # we don't report changes involving only trailing newlines.
        child.setBodyString(''.join(lines)) # .replace('\n','\\n\n'))
        n1 = child.insertAsNthChild(0)
        n2 = child.insertAsNthChild(1)
        n1.setHeadString('old:'+h1)
        n1.setBodyString(b1)
        n2.setHeadString('new:'+h2)
        n2.setBodyString(b2)

    return root
#@+node:ekr.20100701112151.5959: *7* getDiff
def getDiff (self,s1,s2):

    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)
    diffLines = difflib.Differ.compare(lines1,lines2)
    return diffLines
#@+node:ekr.20100124110832.6212: *6* fc.propegateDirtyNodes
def propegateDirtyNodes (self):

    fc = self ; c = fc.c

    aList = [z.copy() for z in c.all_positions() if z.isDirty()]
    for p in aList:
        p.setAllAncestorAtFileNodesDirty()
#@+node:ekr.20120212220616.10537: *6* fc.readExternalFiles
def readExternalFiles(self,fileName):

    c,fc = self.c,self
    
    c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
    recoveryNode = fc.handleNodeConflicts()

    # Do this after reading external files.
    # The descendent nodes won't exist unless we have read the @thin nodes!
    fc.restoreDescendentAttributes()

    fc.setPositionsFromVnodes()
    c.selectVnode(recoveryNode or c.p) # load body pane
#@+node:ekr.20031218072017.1554: *6* fc.warnOnReadOnlyFiles
def warnOnReadOnlyFiles (self,fileName):

    # os.access may not exist on all platforms.

    try:
        self.read_only = not os.access(fileName,os.W_OK)
    except AttributeError:
        self.read_only = False
    except UnicodeError:
        self.read_only = False

    if self.read_only and not g.unitTesting:
        g.es("read only:",fileName,color="red")
#@+node:ekr.20120427064024.10068: *5* app.Detecting already-open files
#@+node:ekr.20120427064024.10064: *6* app.checkForOpenFile
def checkForOpenFile (self,c,fn):
    
    d,tag = g.app.db,'open-leo-files'

    if d is None or g.app.unitTesting or g.app.batchMode:
        return True
    else:
        aList = d.get(tag) or []
        if fn in aList:
            result = g.app.gui.runAskYesNoDialog(c,
                title='Open Leo File Again?',
                message='%s is already open.  Open it again?' % (fn),
            )
            return result == 'yes'
        else:
            return True
#@+node:ekr.20120427064024.10066: *6* app.forgetOpenFile
def forgetOpenFile (self,fn):

    trace = False and not g.unitTesting
    d,tag = g.app.db,'open-leo-files'

    if d is None or g.app.unitTesting or g.app.batchMode:
        pass
    else:
        aList = d.get(tag) or []
        if fn in aList:
            if trace: g.trace('removing: %s' % (fn))
            aList.remove(fn)
            d[tag] = aList
        else:
            if trace: g.trace('did not remove: %s' % (fn))
#@+node:ekr.20120427064024.10065: *6* app.rememberOpenFile
def rememberOpenFile(self,fn):
    
    trace = False and not g.unitTesting
    d,tag = g.app.db,'open-leo-files'

    if d is None or g.app.unitTesting or g.app.batchMode:
        pass
    elif g.app.preReadFlag:
        pass
    else:
        aList = d.get(tag) or []
        # It's proper to add duplicates to this list.
        if trace: g.trace('adding: %s: %s' % (fn,aList))
        aList.append(fn)
        d[tag] = aList
#@+node:ekr.20120330040023.9781: *3* Features
#@+node:ekr.20120409074150.9941: *4* baseNativeTree.onHeadChanged now truncates headlines
@nocolor-node

The new code works like leoTree.onHeadChanged.

The code can be called twice, so it is a bit tricky
to only issue warnings once.
#@+node:ekr.20061008140603: *5* TM.runEditCommandTest
def runEditCommandTest (self,p):

    tm = self
    c = self.c
    atTest = p.copy()
    w = c.frame.body.bodyCtrl

    h = atTest.h
    assert h.startswith('@test '),'expected head: %s, got: %s' % ('@test',h)
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, 'no command: %s' % (commandName)

    work,before,after = tm.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node,h in ((work,'work'),(before,before_h),(after,after_h)):
        h2 = node.h
        assert h2.startswith(h),'expected head: %s, got: %s' % (h,h2)

    sels = []
    for node,h in ((before,before_h),(after,after_h)):
        sel = node.h[len(h):].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    sel1,sel2 = sels
    #g.trace(repr(sels))

    c.selectPosition(work)
    c.setBodyString(work,before.b)
    #g.trace(repr(sel1[0]),repr(sel1[1]))
    w.setSelectionRange(sel1[0],sel1[1],insert=sel1[1])
    c.k.simulateCommand(commandName)
    s1 = work.b ; s2 = after.b
    assert s1 == s2, 'mismatch in body\nexpected: %s\n     got: %s' % (repr(s2),repr(s1))
    sel3 = w.getSelectionRange()
    ins = w.toGuiIndex(w.getInsertPoint())
    #g.trace('ins',ins,'s1[j:...]',repr(s1[j:j+10]))
    # Convert both selection ranges to gui indices.
    sel2_orig = sel2
    # g.trace(w)
    assert len(sel2) == 2,'Bad headline index.  Expected index,index.  got: %s' % sel2
    i,j = sel2 ; sel2 = w.toGuiIndex(i),w.toGuiIndex(j)
    assert len(sel3) == 2,'Bad headline index.  Expected index,index.  got: %s' % sel3
    i,j = sel3 ; sel3 = w.toGuiIndex(i),w.toGuiIndex(j)
    assert sel2 == sel3, 'mismatch in sel\nexpected: %s = %s, got: %s' % (sel2_orig,sel2,sel3)
    c.selectPosition(atTest)
    atTest.contract()
    # Don't redraw.
#@+node:ekr.20110605121601.17912: *5* onHeadChanged (nativeTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None,e=None):

    '''Officially change a headline.'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; u = c.undoer
    if not p:
        if trace: g.trace('** no p')
        return

    item = self.getCurrentItem()
    if not item:
        if trace and verbose: g.trace('** no item')
        return
    if not e:
        e = self.getTreeEditorForItem(item)
    if not e:
        if trace and verbose: g.trace('** not editing')
        return

    s = g.u(e.text())

    if g.doHook("headkey1",c=c,p=c.p,v=c.p,s=s):
        return

    self.closeEditorHelper(e,item)
    oldHead = p.h
    changed = s != oldHead
    if changed:
        # New in Leo 4.10.1.
        if trace: g.trace('new',repr(s),'old',repr(p.h))
        << truncate s if it has multiple lines >>
        p.initHeadString(s)
        item.setText(0,s) # Required to avoid full redraw.
        undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)

    g.doHook("headkey2",c=c,p=c.p,v=c.p,s=s)

    # This is a crucial shortcut.
    if g.unitTesting: return

    if changed:
        self.redraw_after_head_changed()

    if 0: # Don't do this: it interferes with clicks, and is not needed.
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()

    c.outerUpdate()
#@+node:ekr.20120409185504.10028: *6* << truncate s if it has multiple lines >>
# Remove trailing newlines before warning of truncation.
while s and s[-1] == '\n':
    s = s[:-1]

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    s = s[:i]
    if s != oldHead:
        g.es("truncating headline to one line",color="blue")

limit = 1000
if len(s) > limit:
    s = s[:limit]
    if s != oldHead:
        g.es("truncating headline to",limit,"characters",color="blue")
#@+node:ekr.20120411095406.10036: *4* Sorted statistics in profile_leo
#@+node:ekr.20031218072017.2607: *5* profile_leo (runLeo.py)
@ To gather statistics, do the following in a console window:
    
    python profileLeo.py <list of .leo files>
@c

def profile_leo ():

    """Gather and print statistics about Leo"""
    
    # Work around a Python distro bug: can fail on Ubuntu.
    try:
        import pstats
    except ImportError:
        g.es_print('can not import pstats: this is a Python distro bug')
        g.es_print('https://bugs.launchpad.net/ubuntu/+source/python-defaults/+bug/123755')
        g.es_print('try installing pstats yourself')
        return

    import cProfile as profile
    import leo.core.leoGlobals as g
    import os

    theDir = os.getcwd()

    # On Windows, name must be a plain string. An apparent cProfile bug.
    name = str(g.os_path_normpath(g.os_path_join(theDir,'leoProfile.txt')))
    print ('profiling to %s' % name)
    profile.run('import leo ; leo.run()',name)
    p = pstats.Stats(name)
    p.strip_dirs()
    # p.sort_stats('module','calls','time','name')
    p.sort_stats('cumulative','time')
    #reFiles='leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'
    #p.print_stats(reFiles)
    p.print_stats()

prof = profile_leo
#@+node:ekr.20120410175141.10027: *4* Added --no-plugins option
#@+node:ekr.20120219154958.10486: *5* LM.scanOptions & helper
def scanOptions(self,fileName,pymacs):

    '''Handle all options, remove them from sys.argv and set lm.options.'''

    trace = False
    lm = self
    
    # print('scanOptions',sys.argv)

    # Note: this automatically implements the --help option.
    parser = optparse.OptionParser()
    add = parser.add_option
    
    add('--fullscreen',   action="store_true",
        help = 'start fullscreen (Qt only)')
    add('--ipython',      action="store_true",dest="use_ipython",
        help = 'enable ipython support')
    add('--gui',
        help = 'gui to use (qt/qttabs)')
    add('--maximized',    action="store_true",
        help = 'start maximized (Qt only)')
    add('--minimized',    action="store_true",
        help = 'start minimized')
    add('--no-cache',     action="store_true", dest='no_cache',
        help = 'disable reading of cached files')
    add('--no-plugins',   action="store_true", dest='no_plugins',
        help = 'disable all plugins')
    add('--no-splash',    action="store_true", dest='no_splash_screen',
        help = 'disable the splash screen')
    add('--screen-shot',  dest='screenshot_fn',
        help = 'take a screen shot and then exit')
    add('--script',       dest="script",
        help = 'execute a script and then exit')
    add('--script-window',dest="script_window",
        help = 'open a window for scripts')
    add('--select',       dest='select',
        help='headline or gnx of node to select')
    add('--session-restore',action="store_true",dest='session_restore',
        help = 'restore previously stored session tabs')
    add('--session-save',action="store_true",dest='session_save',
        help = 'restore previously stored session tabs')
    add('--silent',       action="store_true", dest="silent",
        help = 'disable all log messages')
    add('--version',      action="store_true", dest="version",
        help='print version number and exit')
    add('--window-size',  dest='window_size',
        help='initial window size in height x width format')

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    if trace:
        # print('scanOptions:',sys.argv)
        g.trace('options',options)

    # Handle the args...

    # --gui
    gui = options.gui

    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            g.app.qt_use_tabs = True
        elif gui in ('curses','qt','null'):
            g.app.qt_use_tabs = False
        else:
            print('scanOptions: unknown gui: %s.  Using qt gui' % gui)
            gui = 'qt'
            g.app.qt_use_tabs = False
    elif sys.platform == 'darwin':
        gui = 'qt'
        g.app.qt_use_tabs = False
    else:
        gui = 'qttabs'
        g.app.qt_use_tabs = True

    assert gui
    g.app.guiArgName = gui
    
    # --ipython
    g.app.useIpython = options.use_ipython
    if trace: g.trace('g.app.useIpython',g.app.useIpython)
    
    # --fullscreen
    # --minimized
    # --maximized
    g.app.start_fullscreen = options.fullscreen
    g.app.start_maximized = options.maximized
    g.app.start_minimized = options.minimized

    # --no-cache
    if options.no_cache:
        if trace: print('scanOptions: disabling caching')
        g.enableDB = False
        
    # --no-plugins
    if options.no_plugins:
        if trace: print('scanOptions: disabling plugins')
        g.app.enablePlugins = False
        
    # --no-splash
    # g.trace('--no-splash',options.no_splash_screen)
    g.app.use_splash_screen = not options.no_splash_screen
    
    # --screen-shot=fn
    screenshot_fn = options.screenshot_fn
    if screenshot_fn:
        screenshot_fn = screenshot_fn.strip('"')
        if trace: print('scanOptions: screenshot_fn',screenshot_fn)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        script,e = g.readFileIntoString(script_name,kind='script:')
        # print('script_name',repr(script_name))
    else:
        script = None
        # if trace: print('scanOptions: no script')

    # --select
    select = options.select
    if select:
        select = select.strip('"')
        if trace: print('scanOptions: select',repr(select))
        
    # --session-restore & --session-save
    g.app.restore_session = bool(options.session_restore)
    g.app.save_session = bool(options.session_save)

    # --silent
    g.app.silentMode = options.silent
    # print('scanOptions: silentMode',g.app.silentMode)

    # --version: print the version and exit.
    versionFlag = options.version
    

    # --window-size
    windowSize = options.window_size
    if windowSize:
        if trace: print('windowSize',repr(windowSize))
        try:
            h,w = windowSize.split('x')
        except ValueError:
            windowSize = None
            g.trace('bad --window-size:',windowSize)
            
    # Compute lm.files
    lm.files = lm.computeFilesList(fileName)
    
    # Post-process the options.
    if pymacs:
        script = None
        windowFlag = None

    # Compute the return values.
    windowFlag = script and script_path_w
    d = {
        'gui':gui,
        'screenshot_fn':screenshot_fn,
        'script':script,
        'select':select,
        'version':versionFlag,
        'windowFlag':windowFlag,
        'windowSize':windowSize,
    }
    
    if trace: g.trace(d)

    return d
#@+node:ekr.20120219154958.10483: *6* LM.computeFilesList
def computeFilesList(self,fileName):

    lm = self
    files = []
    if fileName:
        files.append(fileName)

    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)

    return [lm.completeFileName(z) for z in files]
#@+node:ekr.20031218072017.1416: *5* app.__init__
def __init__(self):
    
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: print('leoApp.__init__')

    # These ivars are Leo's global vars.
    # leoGlobals.py contains global switches to be set by hand.
    
    # Command-line arguments...
    self.batchMode = False          # True: run in batch mode.
    self.enablePlugins = True       # True: run start1 hook to load plugins. --no-plugins
    self.gui = None                 # The gui class.
    self.guiArgName = None          # The gui name given in --gui option.
    self.qt_use_tabs = False        # True: allow tabbed main window.
    self.restore_session = False    # True: restore session on startup.
    self.silentMode = False         # True: no signon.
    self.start_fullscreen = False   # For qtGui plugin.
    self.start_maximized = False    # For qtGui plugin.
    self.start_minimized = False    # For qtGui plugin.
    self.translateToUpperCase = False # Never set to True.
    self.useIpython = False         # True: add support for IPython.
    self.use_psyco = False          # True: use psyco optimization.
    self.use_splash_screen = True   # True: put up a splash screen.

    # Debugging & statistics...
    self.count = 0                  # General purpose debugging count.
    self.debug = False              # Enable debugging. (Can be slow.)
    self.debugSwitch = 0            # 0: Brief; 1: Full.
    self.disableSave = False        # May be set by plugins.
    self.positions = 0              # The number of positions generated.
    self.scanErrors = 0             # The number of errors seen by g.scanError.
    self.statsDict = {}             # dict used by g.stat, g.clear_stats, g.print_stats.
    
    # Error messages...
    self.atPathInBodyWarning = None # Set by get_directives_dict.
    self.menuWarningsGiven = False  # True: supress warnings in menu code.
    self.unicodeErrorGiven = True   # True: suppres unicode tracebacks.
    
    # Global directories...
    self.extensionsDir = None   # The leo/extensions directory
    self.globalConfigDir = None # leo/config directory
    self.globalOpenDir = None   # The directory last used to open a file.
    self.homeDir = None         # The user's home directory.
    self.homeLeoDir = None      # The user's home/.leo directory.
    self.loadDir = None         # The leo/core directory.
    self.machineDir = None      # The machine-specific directory.
    
    # Global data...
    self.globalKillBuffer = []      # The global kill buffer.
    self.globalRegisters = {}       # The global register list.
    self.leoID = None               # The id part of gnx's.
    self.lossage = []               # List of last 100 keystrokes.
    self.numberOfUntitledWindows=0  # Number of opened untitled windows.
    self.windowList = []            # Global list of all frames.
    self.realMenuNameDict = {}      # Translations of menu names.
    
    # Global controller/manager objects...
    self.config = None              # The singleton leoConfig instance.
    self.db = None                  # The singleton leoCacher instance.
    self.loadManager = None         # The singleton LoadManager instance.
    # self.logManager = None        # The singleton LogManager instance.
    # self.openWithManager = None   # The singleton OpenWithManager instance.
    self.nodeIndices = None         # The singleton nodeIndices instance.
    self.pluginsController = None   # The singleton PluginsManager instance.
    self.sessionManager = None      # The singleton SessionManager instance.
    
    # Global status vars...
    
    if 1: #### To be moved to the Commands class...
        self.commandName = None         # The name of the command being executed.
        self.commandInterruptFlag=False # True: command within a command.
            
    self.dragging = False           # True: dragging.
    self.inBridge = False           # True: running from leoBridge module.
    self.inScript = False           # True: executing a script.
    self.initing  = True            # True: we are initiing the app.
    self.killed   = False           # True: we are about to destroy the root window.
    self.preReadFlag = False        # True: we are pre-reading a settings file.
    self.quitting = False           # True: quitting.  Locks out some events.
    
    #### To be moved to the LogManager.

    # The global log...
    self.log = None                 # The LeoFrame containing the present log.
    self.logInited = False          # False: all log message go to logWaiting list.
    self.logIsLocked = False        # True: no changes to log are allowed.
    self.logWaiting = []            # List of messages waiting to go to a log.
    self.printWaiting = []          # Queue of messages to be sent to the printer.
    self.signon = ''
    self.signon2 = ''
    self.signon_printed = False
    
    # Global types.
    import leo.core.leoFrame as leoFrame
    import leo.core.leoGui as leoGui
    self.nullGui = leoGui.nullGui()
    self.nullLog = leoFrame.nullLog()
    
    #### To be moved to OpenWithManager.
    
    # Open with data...
    self.hasOpenWithMenu = False    # True: open with plugin has been loaded.
    self.openWithFiles = []         # List of data used by Open With command.
    self.openWithFileNum = 0        # Number of Open-With temp file names.
    self.openWithTable = None       # Passed to createOpenWithMenuFromTable.
    
    #### To be moved to to the pluginsController.

    # Plugins and event handlers...
    self.afterHandler = None
    self.hookError = False      # True: suppress further calls to hooks.
    self.hookFunction = None    # Application wide hook function.
    self.idle_imported = False  # True: we have done an import idle
    self.idleTimeDelay = 100    # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False   # True: the global idleTimeHookHandler will reshedule itself.
    
    # Support for scripting...
    self.searchDict = {}    # For communication between find/change scripts.
    self.scriptDict = {}    # For use by scripts.

    # Unit testing...
    self.isExternalUnitTest = False # True: we are running a unit test externally.
    self.unitTestDict = {}          # For communication between unit tests and code.
    self.unitTestGui = None         # A way to override the gui in external unit tests.
    self.unitTesting = False        # True if unit testing.
    self.unitTestMenusDict = {}
        # Created in leoMenu.createMenuEntries for a unit test.
        # keys are command names. values are sets of strokes.

    << Define global constants >>
    << Define global data structures >>
#@+node:ekr.20031218072017.1417: *6* << define global constants >>
# self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"
self.prolog_namespace_string = \
    'xmlns:leo="http://edreamleo.org/namespaces/leo-python-editor/1.1"'
#@+node:ekr.20031218072017.368: *6* << define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "cython"        : "#",
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "javascript"    : "// /* */", # EKR: 2011/11/12: For javascript import test.
    "javaserverpage": "<%-- --%>", # EKR: 2011/11/25
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lisp"          : ";", # EKR: 2010/09/29
    "lua"           : "--",  # ddm 13/02/06
    "matlab"        : "%", # EKR: 2011/10/21
    "nsi"           : ";", # EKR: 2010/10/27
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "scala"         : "// /* */",
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--',
        # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

# Used only by c.getOpenWithExt.
self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    #"cython"        : "pyd",
    #"cython"        : "pyi",
    "cython"        : "pyx", # Only one extension is valid at present.
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "javascript"    : "js", # EKR: 2011/11/12: For javascript import test.
    "javaserverpage": "jsp", # EKR: 2011/11/25
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "matlab"        : "m", # EKR: 2011/10/21
    "nsi"           : "nsi", # EKR: 2010/10/27
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    # "rst"           : "rst", # caught by pylint.
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "scala"         : "scala",
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "js"    : "javascript", # EKR: 2011/11/12: For javascript import test.
    "jsp"   : "javaserverpage", # EKR: 2011/11/25: For @shadow.
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "m"     : "matlab", # EKR 2011/10/21
    "nsi"   : "nsi", # EKR: 2010/10/27
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "pyd"   : "cython",
    "pyi"   : "cython",
    "pyx"   : "cython",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "scala" : "scala",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nsi'   : 'none', # Leo 4.8.
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
#@+node:ekr.20120305084218.9915: *4* Show all commands after <alt-x><tab>
@nocolor-node

A simple change to k.computeCompletionList was all that was needed.

#@+node:ekr.20120415133744.10050: *4* Make sure tab completion only happens on explicit tab
#@+node:ekr.20061031131434.111: *5* fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    trace = False and not g.unitTesting
    verbose = True
    k = self ; c = k.c ; gui = g.app.gui
    recording = c.macroCommands.recordingMacro
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    c.check_event(event)
    ch = char = event and event.char or ''
    stroke = event and event.stroke or None

    if trace: g.trace('recording',recording,'state',state,char)
    
    # 2011/06/06: remember these events also.
    if recording:
        c.macroCommands.startRecordingMacro(event)
        
    if state > 0:
        k.setLossage(char,stroke)
    
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif char == 'Ins' or k.isFKey(char):
        pass
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n','Return'):
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif char in ('\t','Tab'):
        if trace and verbose: g.trace('***Tab')
        k.doTabCompletion(list(c.commandsDict.keys()),allow_empty_completion=True)
        c.minibufferWantsFocus()
    elif char in ('\b','BackSpace'):
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return # (for Tk) 'break'
#@+node:ekr.20061031131434.112: *6* callAltXFunction
def callAltXFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event and event.widget
        if hasattr(w,'permanent') and not w.permanent:
            g.es('Can not execute commands from headlines')
        else:
            c.widgetWantsFocusNow(event and event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(commandName)
    else:
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
#@+node:ekr.20061031131434.128: *5* k.getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    trace = False and not g.app.unitTesting
    state = k.getState('getArg')
    
    c.check_event(event)
    
    # 2011/06/06: remember these events also.
    if c.macroCommands.recordingMacro and state > 0:
        c.macroCommands.startRecordingMacro(event)

    char = event and event.char or ''
    if state > 0:
        k.setLossage(char,stroke)
    
    if trace: g.trace(
        'state',state,'char',repr(char),'stroke',repr(stroke),
        'isPlain',k.isPlainKey(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n','Return',) or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes:
            k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = char ##
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        if trace: g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif char in('\t','Tab'):
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif char in ('\b','BackSpace'):
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        pass
        # 2011/03/01: ignore F-keys. Ignoring all except plain keys would kill unicode searches.
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return # (for Tk) 'break'
#@+node:ekr.20061031131434.129: *6* << init altX vars >>
k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@+node:ekr.20061031131434.178: *5* k.doTabCompletion
# Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList,redraw=True,allow_empty_completion=False):

    '''Handle tab completion when the user hits a tab.'''

    k = self ; c = k.c ; s = k.getLabel().strip()

    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        # g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex >= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        if redraw:
            # g.trace('** recomputing default completions')
            k.computeCompletionList(defaultTabList,
                backspace=False,
                allow_empty_completion=allow_empty_completion)

    c.minibufferWantsFocus()
#@+node:ekr.20061031131434.175: *5* k.computeCompletionList
# Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace,allow_empty_completion=False):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)
    c.frame.log.clearTab(tabName)
    
    if not k.mb_tabList and allow_empty_completion:
        # Return *all* completions.
        k.mb_tabList = sorted(defaultTabList)
        common_prefix = ''

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.
        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)

        inverseBindingDict = k.computeInverseBindingDict()
        data,n = [],0
        for commandName in k.mb_tabList:
            dataList = inverseBindingDict.get(commandName,[('',''),])
            for z in dataList:
                pane,key = z
                s1a = '%s ' % (pane) if pane != 'all:' else ''
                s1b = k.prettyPrintKey(key)
                s1 = s1a + s1b
                s2 = commandName
                data.append((s1,s2),)
                n = max(n,len(s1))
        aList = ['%*s %s' % (-n,s1,s2) for s1,s2 in data]
        g.es('','\n'.join(aList),tabName=tabName)
    c.bodyWantsFocus()
#@+node:ekr.20111017132257.15891: *4* IPython now works with all versions of IPython
#@+node:ekr.20120330110655.10023: *5*  Notes
@language rest

Investigate how IPython hijacks event loops
http://groups.google.com/group/leo-editor/browse_thread/thread/e1dc6439bf8b17f9

pyos_inputhook is relevant

IPython lib.inputhook
http://ipython.org/ipython-doc/stable/api/generated/IPython.lib.inputhook.html


* IPython seems to require Python 2.x.
* I can run IPython from either C:\prog\ipython-0.12 or from python\lib\site-packages

From C:\prog\ipython-0.12\IPython\scripts

#!/usr/bin/env python
"""Terminal-based IPython entry point.
"""

from IPython.frontend.terminal.ipapp import launch_new_instance

launch_new_instance()

Here is ipapi.get::

@language python

    def get():
        """Get the global InteractiveShell instance."""
        from IPython.core.interactiveshell import InteractiveShell
        return InteractiveShell.instance()
#@+node:ekr.20120330110655.10025: *6* @url ipython api
http://ipython.org/ipython-doc/rel-0.12/api/index.html
#@+node:ekr.20120330110655.10024: *6* @url ipython-dev archive
http://mail.scipy.org/pipermail/ipython-dev/
#@+node:ekr.20120330110655.10026: *6* @url ipython.core.interactiveshell
http://ipython.org/ipython-doc/rel-0.12/api/generated/IPython.core.interactiveshell.html
#@+node:ekr.20120403093858.10043: *6* pylint

c:\leo.repo\trunk>pylint -r

E0602:182:LeoWorkbook.<lambda>: Undefined variable 'c'
E0602:205:LeoWorkbook.require: Undefined variable '_leo_push_history'
E1101:241:GlobalIPythonManager.embed_ipython: Instance of 'GlobalIPythonManager' has no 'qtApp' member
E1103:290:GlobalIPythonManager.get_history: Instance of 'list' has no 'get' member (but some types could not be inferred
)
E0602:325:GlobalIPythonManager.init_ipython: Undefined variable 'push_mark_req'
E0602:326:GlobalIPythonManager.init_ipython: Undefined variable 'push_cl_node'
E0602:329:GlobalIPythonManager.init_ipython: Undefined variable 'push_ipython_script'
E0602:330:GlobalIPythonManager.init_ipython: Undefined variable 'push_plain_python'
E0602:331:GlobalIPythonManager.init_ipython: Undefined variable 'push_ev_node'
E1101:344:GlobalIPythonManager.expose_ileo_push: Instance of 'GlobalIPythonManager' has no 'push_from_leo' member
E0602:426:GlobalIPythonManager.new_push_to_ipython: Undefined variable 'ipy_leo'
E0602:445:GlobalIPythonManager.push_cl_node: Undefined variable 'c'
E0602:462:GlobalIPythonManager.push_ev_node: Undefined variable 'ip'
E0602:523:GlobalIPythonManager.push_mark_req: Undefined variable '_leo_push_history'
E0602:536:GlobalIPythonManager.push_plain_python: Undefined variable 'ip'
E1101:549:GlobalIPythonManager.run_leo_startup_node: Instance of 'GlobalIPythonManager' has no 'push_from_leo' member
E0602:764:LeoNode.ipush: Undefined variable 'push_from_leo'
W0106:787:LeoNode.script: Expression "(" Method to get the 'tangled' contents of the node\n\n            (parse @others,
 %s references etc.)\n            ") % (g.angleBrackets(' section '))" is assigned to nothing
E1101:966:add_var: Class 'LeoNode' has no 'p' member
E1101:971:add_var: Class 'LeoNode' has no 'p' member
E1101:990:all_cells: Class 'LeoNode' has no 'p' member
E1101:1009:edit_macro: Function 'edit_object_in_leo' has no 'when_type' member
E1101:1121:rootnode: Class 'LeoNode' has no 'p' member
R0923:601:LeoInterface: Interface not implemented
('EKR: exit status', 14)

c:\leo.repo\trunk>
#@+node:ekr.20120401144849.10152: *6* What I did
@language rest

- Import logic looks for legacy IPython first (0.11 and prev),
  then looks for new-style IPython (0.12 and above).

- Created GlobalIPythonManager class, assigned to leoIPython.gipm and g.app.gipm.

- Added self.c ivar to LeoNode class.  This is the same as p.v.context.
#@+node:ekr.20120415174008.10062: *5* Startup...
#@+node:ekr.20110605121601.18134: *6* init (qtGui.py top level) (qtPdb)
def init():
    
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace and g.trace_startup: print('qtGui.__init__')

    if g.app.unitTesting: # Not Ok for unit testing!
        return False

    if not QtCore:
        return False

    if g.app.gui:
        return g.app.gui.guiName() == 'qt'
    else:
        g.app.gui = leoQtGui()

        # Override g.pdb
        def qtPdb(message=''):
            if message: print(message)
            import pdb
            if not g.app.useIpython:
                QtCore.pyqtRemoveInputHook()
            pdb.set_trace()
        g.pdb = qtPdb

        g.app.gui.finishCreate()
        g.plugin_signon(__name__)
        return True
#@+node:ekr.20110605121601.18483: *6* runMainLoop (qtGui)
def runMainLoop(self):

    '''Start the Qt main loop.'''
    
    g.app.gui.dismiss_splash_screen()
    
    if self.script:
        log = g.app.log
        if log:
            g.pr('Start of batch script...\n')
            log.c.executeScript(script=self.script)
            g.pr('End of batch script')
        else:
            g.pr('no log, no commander for executeScript in qtGui.runMainLoop')
    elif g.app.useIpython and g.app.ipm:
        # g.app.ipm exists only if IPython was imported properly.
        g.app.ipm.embed_ipython()
            # Runs main loop and calls sys.exit.
    else:
        sys.exit(self.qtApp.exec_())
#@+node:ekr.20120401144849.10116: *6* start_new_api
def start_new_api(self):

    # No c is available: we can't get @string ipython_argv setting.
    sys.argv =  ['ipython']
    
    self.started = True

    # Prints signon.
    # self.ip set in update_commander.
    ipapp.launch_new_instance()

        # Doesn't print signon.
        # shell = ishell.TerminalInteractiveShell()
        # self.ip = shell
        # shell.mainloop()
#@+node:ekr.20120415174008.10061: *5* Conversion to new api...
#@+node:ekr.20120415174008.10063: *6* get_ip
def get_ip (self):
    
    """Get the global InteractiveShell instance."""
    
    shell = InteractiveShell.instance()
    
    return shell
#@+node:ekr.20120401144849.10140: *6* pushToIPythonCommand (g.command push-to-ipython)
@g.command('push-to-ipython')
def pushToIPythonCommand(event=None):

    '''The push-to-ipython command.

    IPython must be started, but the commander need not be inited.'''
    
    trace = False and not g.unitTesting
    
    # Ensure that the correct commander is set.
    startIPython(event=event)
    
    g_ipm.push_to_ipython()
#@+node:ekr.20120401144849.10142: *6* push_to_ipython
def push_to_ipython(self):
    
    c,ip = self.c,self.ip
    if not c:
        return g.trace('can not happen: no c.')
        
    if not self.ip:
        return g.trace('can not happen: no ip.')
        
    c.inCommand = False # Disable the command lockout logic
        
    n = LeoNode(c.p)
    
    def f(self=self,n=n):
        self.push_ipython_script(n)
        return True
    d = CommandChainDispatcher()
    d.add(f)
    d()
#@+node:ekr.20120415133744.10049: *6* Found: ip.IP
#@+node:ekr.20120401144849.10084: *7* get_history
def get_history(self,hstart = 0):
    res = []
    
    ip = self.ip
    
    if g_legacy:
        ihist = ip.IP.input_hist
        ihist_raw = ip.IP.input_hist_raw
        ohist = ip.IP.output_hist
    else:
        m = ip.history_manager
        ihist = m.input_hist_parsed
        ihist_raw = m.input_hist_raw
        ohist = m.output_hist

    # for idx in range(hstart, len(ip.IP.input_hist)):
    for idx in range(hstart, len(ihist)):
        val = ohist.get(idx,None)
        has_output = True
        # inp = ip.IP.input_hist_raw[idx]
        inp = ihist_raw[idx]
        if inp.strip():
            res.append('In [%d]: %s' % (idx, inp))
        if val:
            res.append(pprint.pformat(val))
            res.append('\n')    
    return ''.join(res)
#@+node:ekr.20120401144849.10099: *7* push_ipython_script
def push_ipython_script(self,node):
    """ Execute the node body in IPython,
    as if it was entered in interactive prompt """
    
    trace = False
    c = self.c
    ip = self.ip
    try:
        if 0:
            g.trace()
            for z in sorted(dir(ip)):
                print('%30s %s' % (z,getattr(ip,z).__class__))
        
        if g_legacy:
            ihist = ip.IP.input_hist
            ohist = ip.IP.output_hist 
            hstart = len(ip.IP.input_hist)
        else:
            m = ip.history_manager
            hstart = ip.history_length
            ihist = m.input_hist_parsed
            ohist = m.output_hist

        if trace:
            g.trace('ihist',ihist)
            g.trace('ohist',ohist)
    
        script = node.script()

        # The current node _p needs to handle
        # wb.require() and recursive ipushes.
        old_p = ip.user_ns.get('_p',None)
        ip.user_ns['_p'] = node
        
        if g_legacy:
            ip.runlines(script)
        else:
            ip.runcode(script)

        ip.user_ns['_p'] = old_p
        if old_p is None:
            del ip.user_ns['_p']

        has_output = False
        # for idx in range(hstart,len(ip.IP.input_hist)):
        for idx in range(hstart,len(ihist)):
            val = ohist.get(idx,None)
            if val is not None:
                has_output = True
                # inp = ip.IP.input_hist[idx]
                inp = ihist[idx]
                if inp.strip():
                    es('In: %s' % (inp[:40], ))
                es('<%d> %s' % (idx,pprint.pformat(ohist[idx],width=40)))

        if not has_output:
            es('ipy run: %s (%d LL)' %(node.h,len(script)))
    finally:
        # if trace: g.trace('end push_ipython_script')
        c.redraw()
#@+node:ekr.20120401144849.10091: *7* mb_completer
def mb_completer(event):
    
    """ Custom completer for minibuffer """
    
    c = g_ipm.c
    ip = g_ipm.ip

    cmd_param = event.line.split()
    if event.line.endswith(' '):
        cmd_param.append('')
        
    if len(cmd_param) > 2:
        if g_legacy:
            return ip.IP.Completer.file_matches(event.symbol)
        else:
            completer = IPCompleter(shell=ip,
                namespace=ip.user_ns,
                global_namespace=None,
                alias_table=None,
                use_readline=True,
                config=None)
            return completer.file_matches(event.symbol)

    return sorted(list(c.commandsDict.keys()))
#@+node:ekr.20120415174008.10064: *5* Inited IPython properly
@nocolor-node

- Replaced push_from_leo by CommandChainDispatcher().
#@+node:ekr.20120401144849.10102: *6* push_position_from_leo
def push_position_from_leo(self,p):
    
    try:
        d = CommandChainDispatcher(LeoNode(p))
        d()

    except AttributeError as e:
        if e.args == ("Commands instance has no attribute 'frame'",):
            es("Error: ILeo not associated with .leo document")
            es("Press alt+shift+I to fix!")
        else:
            raise
#@+node:ekr.20120401144849.10098: *6* push_from_leo
# push_from_leo = CommandChainDispatcher()
#@+node:ekr.20120401063816.10144: *6* init_ipython
def init_ipython(self):
    
    """ This will be run by _ip.load('ipy_leo') 

    Leo still needs to run update_commander() after this.

    """
    
    ip = self.ip
    # g.trace(ip)
    
    if self.inited:
        return
    
    self.show_welcome()

    #### Shell.hijack_tk()
    ip.set_hook('complete_command',mb_completer,str_key = '%mb')
    
    f = ip.expose_magic if g_legacy else ip.define_magic
    
    f('mb',mb_f)
    f('lee',lee_f)
    f('leoref',leoref_f)
    f('lleo',lleo_f)    
    f('lshadow',lshadow_f)
    f('lno',lno_f)

    # Note that no other push command should EVER have lower than 0
    g_ipm.expose_ileo_push(g_ipm.push_mark_req,-1)
    g_ipm.expose_ileo_push(g_ipm.push_cl_node,100)
    # this should be the LAST one that will be executed,
    # and it will never raise TryNext.
    g_ipm.expose_ileo_push(g_ipm.push_ipython_script,1000)
    g_ipm.expose_ileo_push(g_ipm.push_plain_python,100)
    g_ipm.expose_ileo_push(g_ipm.push_ev_node,100)
    
    ip.set_hook('pre_prompt_hook',ileo_pre_prompt_hook) 
        
    # global wb
    # wb = LeoWorkbook()
    ip.user_ns['wb'] = self.wb
#@+node:ekr.20120401144849.10119: *6* show_welcome
def show_welcome(self):

    print("------------------")
    print("Welcome to Leo-enabled IPython session!")
    print("Try %leoref for quick reference.")

    if g_legacy:
        import IPython.platutils as u
        u.set_term_title('ILeo')
        u.freeze_term_title()
    else:
        import IPython.utils.terminal as u
        u.toggle_set_term_title(True)
        u.set_term_title('ILeo')
#@+node:ekr.20120419095424.9924: *4* Integrated free_layout into Leo's core
#@+node:ekr.20120217070122.10470: *5* c.initObjects
def initObjects(self,gui):
    
    trace = (False or g.trace_startup) and not g.unitTesting
    c = self
    
    if trace:
        print('g.initObjects %s %s' % (
            c.shortFileName(),g.app.gui))

    self.hiddenRootNode = leoNodes.vnode(context=c)
    self.hiddenRootNode.setHeadString('<hidden root vnode>')
    
    # Create the gui frame.
    title = c.computeWindowTitle(c.mFileName)
    
    if not g.app.initing:
        g.doHook("before-create-leo-frame",c=c)

    self.frame = gui.createLeoFrame(c,title)
    assert self.frame
    assert self.frame.c == c
    
    self.nodeHistory = nodeHistory(c)
    
    self.initConfigSettings()

    c.setWindowPosition() # Do this after initing settings.

    # Break circular import dependencies by importing here.
    # These imports take almost 3/4 sec in the leoBridge.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoCache as leoCache
    import leo.core.leoChapters as leoChapters
    import leo.core.leoEditCommands as leoEditCommands
    import leo.core.leoKeys as leoKeys
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoRst as leoRst
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoTest as leoTest
    import leo.core.leoUndo as leoUndo
    
    self.keyHandler = self.k = leoKeys.keyHandlerClass(c)
    self.chapterController  = leoChapters.chapterController(c)
    self.shadowController   = leoShadow.shadowController(c)
    self.fileCommands       = leoFileCommands.fileCommands(c)
    self.atFileCommands     = leoAtFile.atFile(c)
    self.importCommands     = leoImport.leoImportCommands(c)
    self.rstCommands        = leoRst.rstCommands(c)
    self.tangleCommands     = leoTangle.tangleCommands(c)
    self.testManager        = leoTest.TestManager(c)
    
    self.editCommandsManager = leoEditCommands.EditCommandsManager(c)
    self.editCommandsManager.createEditCommanders()

    self.cacher = leoCache.cacher(c)
    self.cacher.initFileDB(self.mFileName)
    self.undoer = leoUndo.undoer(self)
    
    import leo.plugins.free_layout as free_layout
    self.free_layout = free_layout.FreeLayoutController(c)
#@+node:tbrown.20110203111907.5521: *5* init (free_layout.py)
def init():
    
    if 1:
        return g.app.gui.guiName() == "qt"
    else:
        # g.trace('free_layout.py')
        if g.app.gui.guiName() != "qt":
            return False
    
        g.registerHandler('after-create-leo-frame',bindControllers)
        g.registerHandler('after-create-leo-frame2',loadLayouts)
        g.plugin_signon(__name__)
        
        return True
#@+node:ekr.20110318080425.14390: *5*  ctor (FreeLayoutController)
def __init__ (self,c):
    
    # g.trace('(FreeLayoutController)',c) # ,g.callers(files=True))
    
    # if hasattr(c,'free_layout'):
        # return
    
    self.c = c
    
    # c.free_layout = self
        # To be removed
    
    self.windows = []  
    # list of top level free-layout windows opened from 'Open Window'
    # splitter handle context menu
    
    # g.registerHandler('after-create-leo-frame',self.bindControllers)
    
    # attach to an outline
    g.registerHandler('after-create-leo-frame',self.init)
    
    # now that the outline's set up (plugins etc.), load layout for
    # outline, can't do that sooner as plugins must be loaded first
    # to provide their widgets in panels etc.
    g.registerHandler('after-create-leo-frame2',self.loadLayouts)
    
    ### self.init()
    
#@+node:tbrown.20110203111907.5522: *5* init (FreeLayoutController)
def init(self,tag,keys):
    """Attach to an outline and
    
    - add tags to widgets to indicate that they're essential
      (tree, body, log-window-tabs) and
      
    - tag the log-window-tabs widget as the place to put widgets
      from free-laout panes which are closed
      
    - register this FreeLayoutController as a provider of menu items
      for NestedSplitter
    """

    c = self.c

    if c != keys.get('c'):
        return
        
    # g.trace(c.frame.title)

    # Careful: we could be unit testing.

    splitter = self.get_top_splitter() # A NestedSplitter.
    if not splitter:
        # g.trace('no splitter!')
        return None
        
    # by default NestedSplitter's context menus are disabled, needed
    # once to globally enable them
    NestedSplitter.enabled = True

    # when NestedSplitter disposes of children, it will either close
    # them, or move them to another designated widget.  Here we set
    # up two designated widgets

    logTabWidget = splitter.findChild(QtGui.QWidget, "logTabWidget")
    splitter.root.holders['_is_from_tab'] = logTabWidget
    splitter.root.holders['_is_permanent'] = 'TOP'

    # allow body and tree widgets to be "removed" to tabs on the log tab panel    
    bodyWidget = splitter.findChild(QtGui.QFrame, "bodyFrame")
    bodyWidget._is_from_tab = "Body"

    treeWidget = splitter.findChild(QtGui.QFrame, "outlineFrame")
    treeWidget._is_from_tab = "Tree"
    # also the other tabs will have _is_from_tab set on them by the
    # offer_tabs menu callback above

    # if the log tab panel is removed, move it back to the top splitter
    logWidget = splitter.findChild(QtGui.QFrame, "logFrame")
    logWidget._is_permanent = True

    # tag core Leo components (see ns_provides)
    splitter.findChild(QtGui.QWidget, "outlineFrame")._ns_id = '_leo_pane:outlineFrame'
    splitter.findChild(QtGui.QWidget, "logFrame")._ns_id = '_leo_pane:logFrame'
    splitter.findChild(QtGui.QWidget, "bodyFrame")._ns_id = '_leo_pane:bodyFrame'

    splitter.register_provider(self)
#@+node:ekr.20120419095424.9927: *5* loadLayouts (FreeLayoutController)
def loadLayouts(self,tag,keys):
    
    c = self.c
    
    if c != keys.get('c'):
        return
        
    # g.trace(c.frame.title)
  
    layout = c.config.getData("free-layout-layout")
    
    if layout:
        layout = json.loads('\n'.join(layout))
        
    if '_ns_layout' in c.db:
        name = c.db['_ns_layout']
        if layout:
            g.es("NOTE: embedded layout in @settings/@data free-layout-layout " \
                "overrides saved layout "+name)
        else:
            layout = g.app.db['ns_layouts'][name]

    if layout:
        # Careful: we could be unit testing.
        splitter = c.free_layout.get_top_splitter()
        if splitter:
            splitter.load_layout(layout)
#@+node:ekr.20110605121601.18503: *5* runScrolledMessageDialog (qtGui)
def runScrolledMessageDialog (self,
    short_title= '',
    title='Message',
    label= '',
    msg='',
    c=None,**kw
):

    if g.unitTesting: return None

    def send(title=title, label=label, msg=msg, c=c, kw=kw):
        return g.doHook('scrolledMessage',
            short_title=short_title,title=title,
            label=label, msg=msg,c=c, **kw)

    if not c or not c.exists:
        << no c error>>
    else:        
        retval = send()
        if retval: return retval
        << load viewrendered plugin >>
        retval = send()
        if retval: return retval
        << no dialog error >>

    << emergency fallback >>
#@+node:ekr.20110605121601.18504: *6* << no c error>>
g.es_print_error('%s\n%s\n\t%s' % (
    "The qt plugin requires calls to g.app.gui.scrolledMessageDialog to include 'c'",
    "as a keyword argument",
    g.callers()
))
#@+node:ekr.20110605121601.18505: *6* << load viewrendered plugin >>
pc = g.app.pluginsController
# 2011/10/20: load viewrendered (and call vr.onCreate)
# *only* if not already loaded.
if not pc.isLoaded('viewrendered.py'):
    vr = pc.loadOnePlugin('viewrendered.py')
    if vr:
        g.es('viewrendered plugin loaded.', color='blue')
        vr.onCreate('tag',{'c':c})
#@+node:ekr.20110605121601.18506: *6* << no dialog error >>
g.es_print_error(
    'No handler for the "scrolledMessage" hook.\n\t%s' % (
        g.callers()))
#@+node:ekr.20110605121601.18507: *6* << emergency fallback >>
b = QtGui.QMessageBox
d = b(None) # c.frame.top)
d.setWindowFlags(QtCore.Qt.Dialog) # That is, not a fixed size dialog.

d.setWindowTitle(title)
if msg: d.setText(msg)
d.setIcon(b.Information)
yes = d.addButton('Ok',b.YesRole)
c.in_qt_dialog = True
d.exec_()
c.in_qt_dialog = False
#@-all

# Put this @language after the @all as a kind of permanent unit test.

#@@language python # Override the default .txt coloring.

#@@pagewidth 60
#@-leo
