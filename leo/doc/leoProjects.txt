#@+leo-ver=5-thin
#@+node:ekr.20100120072650.6089: * @file ../doc/leoProjects.txt
#@+all
#@+node:ekr.20111103205308.9698: ** Unit tests
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)

s1 = '''
<table id="1"> <table id="2">
<contents/>
</table>
</table>
'''

s2 = '''
<table id="1"> 
<table id="2">
<contents/>
</table>
</table>
'''

t1 = 
assert result == expected,'expected...\n%s\ngot...\n%s' % (
    repr(expected),repr(result))
#@+node:ekr.20100907115157.5905: *3* @ignore Ancient tests
#@+node:ekr.20100208095423.5940: *4* @test leoCache
import leo.core.leoCache as leoCache

cacher = leoCache.cacher(c)

if 0:
    import os
    os.system('cls')

assert cacher.test()
#@+node:ekr.20100906165118.5915: *4* @test leoInkCommands
ic = c.inkscapeCommands
screenshot = r'c:\leo.repo\inkcall\some_screen_shot.png'
template_fn = r'c:\leo.repo\inkcall\template.svg'
png_fn = r'c:\leo.repo\inkcall\output.png'
svg_fn = r'c:\leo.repo\inkcall\temp.svg'
callouts = [
        "This goes here",
        "These are those, but slightly longer",
        "Then you pull this, but this text needs to be longer for testing",]
ic.run(
    screenshot,
    callouts=callouts,
    numbers=[2,4,17],
    edit_flag = True, # True: call inkscape to edit the working file.
    png_fn=png_fn, # Optional: Name of output png file.
    svg_fn=svg_fn, # Optional: Name of working svg file.
    template_fn=template_fn, # Optional: Name of template svg file.
)
#@+node:ekr.20111102123707.9629: *4* @ignore test of marked unit-test trees
#@+node:ekr.20111102123707.9630: *5* @test assert False
assert False
#@+node:ekr.20111102123707.9631: *5* @test assert True
assert True
#@+node:ekr.20111107092526.9799: *4* @test detection of external unit tests
# This test is redundant, and another test sets import_html_tags

# print('g.app.isExternalUnitTest',g.app.isExternalUnitTest)
if g.app.isExternalUnitTest:
    fn = c.shortFileName()
    assert fn.endswith('dynamicUnitTest.leo'),fn
    data = c.config.getData('import_html_tags')
    assert len(data) == 85 # length of data in leoSettings.leo.
else:
    data = c.config.getData('import_html_tags')
    assert len(data) == 85,len(data)
#@+node:ekr.20111107092526.9800: *5* doTests...
def doTests(c,all=None,marked=None,p=None,verbosity=1):

    trace = False ; verbose = False
    if all:
        p = c.rootPosition()
    elif not p:
        p = c.p
    p1 = c.p.copy() # 2011/10/31: always restore the selected position.
    
    g.trace(g.app.isExternalUnitTest)
    
    # This seems a bit risky when run in unitTest.leo.
    # c.save() # Eliminate the need for ctrl-s.
    
    if trace: g.trace('marked',marked,'c',c)

    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)

        # New in Leo 4.4.8: ignore everything in @ignore trees.
        last = None if all else p.nodeAfterTree()
        
        aList = findAllUnitTestNodes(c,p,last,all,marked,
            lookForMark=False,lookForNodes=True)
       
        found = False
        for p in aList:
            if isTestNode(p):
                if trace: g.trace('adding',p.h)
                test = makeTestCase(c,p)
            elif isSuiteNode(p): # @suite
                if trace: g.trace('adding',p.h)
                test = makeTestSuite(c,p)
            else:
                test = None
            if test:
                suite.addTest(test)
                found = True
        
        # Verbosity: 1: print just dots.
        if not found:
            # 2011/10/30: run the body of p as a unit test.
            test = makeTestCase(c,c.p)
            if test:
                suite.addTest(test)
                found = True
        if found:
            res = unittest.TextTestRunner(verbosity=verbosity).run(suite)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
                c.cacher.db[key] = archive
        else:
            g.es_print('no %s@test or @suite nodes in %s outline' % (
                g.choose(marked,'marked ',''),
                g.choose(all,'entire','selected')),color='red')
    finally:
        c.setChanged(changed) # Restore changed state.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.contractAllHeadlines()
            c.redraw(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20111107092526.9801: *6* class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20111107092526.9802: *7* __init__ (generalTestCase)
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@+node:ekr.20111107092526.9803: *7*  fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@+node:ekr.20111107092526.9804: *7* tearDown
def tearDown (self):

    pass

    # Restore the outline.
    self.c.outerUpdate()
#@+node:ekr.20111107092526.9805: *7* setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p.copy()) # 2010/02/03
#@+node:ekr.20111107092526.9806: *7* runTest (generalTestCase)
def runTest (self,define_g = True):

    trace = False
    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)
    
    if c.shortFileName() == 'dynamicUnitTest.leo':
        c.write_script_file = True

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p and p.copy(),'self':self,}
    else:
        d = {'self':self,}

    script = script + '\n'
    if trace: g.trace('p: %s c: %s write script: %s script:\n%s' % (
        p and p.h,c.shortFileName(),c.write_script_file,script))

    # Execute the script. Let the unit test handle any errors!
    # 2011/11/02: pass the script sources to exec or execfile.
    if c.write_script_file:
        scriptFile = c.writeScriptFile(script)
        if g.isPython3:
            exec(compile(script,scriptFile,'exec'),d)
        else:
            execfile(scriptFile,d)
    else:
        exec(script,d)
#@+node:ekr.20111107092526.9807: *7* shortDescription
def shortDescription (self):

    s = self.p.h

    # g.trace(s)

    return s + '\n'
#@+node:ekr.20111107092526.9808: *6* makeTestSuite (leoTest)
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()
    # g.trace('c.write_script_file',c.write_script_file)
    script = g.getScript(c,p).strip()
    if not script:
        print("no script in %s" % h)
        return None
    try:
        if 0: #debugging
            n,lines = 0,g.splitLines(script)
            for line in lines:
                print(n,line)
                n += 1
                
        # 2011/11/02: make script sources available.
        d = {'c':c,'g':g,'p':p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            if g.isPython3:
                exec(compile(script,scriptFile,'exec'),d)
            else:
                execfile(scriptFile,d)
        else:
            exec(script + '\n',d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("makeTestSuite: %s script did not set g.app.scriptDict" % p.h)
        return suite
    except Exception:
        print('makeTestSuite: exception creating test cases for %s' % p.h)
        g.es_exception()
        return None
#@+node:ekr.20111107092526.9809: *6* makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.b.strip():
        return generalTestCase(c,p)
    else:
        return None
#@+node:ekr.20111107092526.9810: *5* main & helpers (leoDynamicTest.py)
def main ():

    trace = False
    readSettings = True 
    tag = 'leoDynamicTests.leo'
    if trace: t1 = time.time()

    # Setting verbose=True prints messages that would be sent to the log pane.
    path,gui,silent = scanOptions()
    # print('(leoDynamicTest.py:main)','silent',silent)

    # Not loading plugins and not reading settings speeds things up considerably.
    bridge = leoBridge.controller(gui=gui,
        loadPlugins=False, # Must be False: plugins will fail when run externally.
        readSettings=True, # True adds about 0.3 seconds.  Is it useful?
        silent=True,
        verbose=False)

    if trace:
         t2 = time.time()
         print('%s open bridge:  %0.2fsec' % (tag,t2-t1))

    if bridge.isOpen():
        g = bridge.globals()
        g.app.silentMode = silent
        g.app.isExternalUnitTest = True
        path = g.os_path_finalize_join(g.app.loadDir,'..','test',path)
        c = bridge.openLeoFile(path)
        if trace:
            t3 = time.time()
            print('%s open file: %0.2fsec' % (tag,t3-t2))
        runUnitTests(c,g)
#@+node:ekr.20111107092526.9811: *6* runUnitTests
def runUnitTests (c,g):

    p = c.rootPosition()
    #g.es_print('running dynamic unit tests...')
    c.selectPosition(p)
    c.debugCommands.runAllUnitTestsLocally()
#@+node:ekr.20111107092526.9812: *6* scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('--path',dest='path')
    parser.add_option('--gui',dest="gui")
    parser.add_option('--silent',action="store_true",dest="silent")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)

    # -- path
    # We can't finalize the path here, because g does not exist ye.
    path = options.path or 'dynamicUnitTest.leo'

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('qttabs','qt'):
        gui = 'nullGui'

    # --silent
    silent = options.silent

    return path,gui,silent
#@+node:ekr.20111116161118.10248: *3* Recent tests
#@+node:ekr.20111104132424.9909: *4* @test assert True
# It's useful to have this do-nothing test.

assert True
#@+node:ekr.20111107092526.9819: *4* @test cls
g.cls() # Clear the screen
#@+node:ekr.20111110085739.10265: *4* @test html string
s = '''\
<HTML>
<head>
    <title>Bodystring</title>
</head>
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
</html>
'''

html_tags = ('body','head','html','table',) # 'div',
setting = 'import_html_tags'

# Settings now work when run externally.
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.app.unitTestDict ['expectedErrors'] = 0

showTree = True

c.importCommands.htmlUnitTest(p,s=s,showTree=showTree)

if showTree:
    # g.cls()
    for p in p.subtree():
        print('\n***** %s\n' %p.h)
        print(p.b)
#@+node:ekr.20120112100822.10003: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120112100822.10004: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120112100822.10005: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120112100822.10006: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120203153754.10033: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120203153754.10034: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120203153754.10035: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120203153754.10036: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20120204061120.10061: *5* @file c:/leo.repo/trunk/leo/core/html string
@language xml
@tabwidth -4
@others

#@+node:ekr.20120204061120.10062: *6* html
<HTML>
@others
</html>
#@+node:ekr.20120204061120.10063: *7* head

<head>
    <title>Bodystring</title>
</head>
#@+node:ekr.20120204061120.10064: *7* body
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
#@+node:ekr.20111109151106.9746: *4* @test htmlScanner.filterTokens
import leo.core.leoImport as leoImport
ic = c.importCommands
hs = leoImport.htmlScanner(importCommands=ic,atAuto=True)
strip = hs.stripTokens
dump  = hs.formatTokens

s1 = '''<table id="1"><table id="2">
<contents/>
</table>
</table>'''

s2 = '<table id="1"><table id="2"><contents/></table></table>'
    
t1 = hs.tokenize(s1)
t2 = hs.tokenize(s2)
f1 = hs.filterTokens(t1)
f2 = hs.filterTokens(t2)

assert strip(f1) == strip(f2),'f1...\n%s\nf2...\n%s' % (
    dump(f1),dump(f2))
    
if 0:
    print(dump(f1))
#@+node:ekr.20111110084957.10092: *4* @test import dataN.html
fn = r'c:\recent\data.html'

# fn = r'c:\recent\data-smaller.html'
# fn = r'c:\recent\data666.html'

# These all pass on data.html:
    # html_tags = ('html','head','body',)
    # html_tags = ('html','head','body','table',)
    # html_tags = ('html','head','body','table','div',)
    # html_tags = ('html','head','body','table','div','script',)
    # html_tags = ('html','head','body','table','div','script','link',)
    # html_tags = ('html','head','body','table','div','script','link','p',)

html_tags = ('html','head','body','table','div','script','p','td','tr',)

# Settings now work when run externally.
setting = 'import_html_tags'
c.config.set(setting,'data',html_tags)
tags = c.config.getData(setting)
assert tags == html_tags,len(tags)

g.cls()

c.importCommands.importFilesCommand(files=[fn], treeType='@file')
#@+node:ekr.20111109105907.9795: *4* @test unicode stuff
@first # -*- coding: utf-8 -*-

table = (
    'test',
    'Ä 궯 奠',
    'Ä 궯 奠 after', # fails with cp6501: after is duplicated.
)

print('*'*20)
print('isPython3: %s' % g.isPython3)

for s in table:
    if g.isPython3:
        s = s.encode('ascii','replace') # create bytes.
    g.es(repr(s))
    g.es(s)
    g.pr ('g.pr(s)       : %s' % s)
    g.pr ('g.pr(repr(s)) : %s' % repr(s))
    print('print(s)      : %s' % s)
    print('print(repr(s)): %s' % s)
#@+node:ekr.20111113064104.9841: *4* @test external text operations
assert g.app.isExternalUnitTest

body = c.frame.body
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl

w = body.bodyCtrl
w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111112131605.9789: *4* @test nullBody text operations
# print('isExternalUnitTest',g.app.isExternalUnitTest)

if g.app.isExternalUnitTest:
    body = c.frame.body
else:
    import leo.core.leoCommands as leoCommands
    import leo.core.leoFrame as leoFrame
    import leo.core.leoGui as leoGui
    
    # Important: external unit tests should execute in this environment.
    nullGui   = leoGui.nullGui('null gui')
    nullFrame = leoFrame.nullFrame(title='nullFrame title',gui=nullGui)
    c2 = leoCommands.Commands(nullFrame,fileName='<empty fileName>')
    nullFrame.c = c2
    body = leoFrame.nullBody(frame=nullFrame,parentFrame=None)
    assert repr(body).startswith('<leo.core.leoFrame.nullBody')

# Now test some basic operations.
assert repr(body.widget).startswith('stringTextWidget')
assert body.widget == body.bodyCtrl
w = body.bodyCtrl

w.setAllText(p.b)
assert p.b == w.getAllText()
#@+node:ekr.20111115155710.9835: *4* @test g.python_tokenize
# h = 'g.python_tokenize'
# p = p.firstChild()
# assert p.h == h
tokens = g.python_tokenize(p.b,line_numbers=False)

# tokens = [(kind,val) for (kind,val,line_number) in tokens]

# First, the basic check
tokens1 = [val for kind,val in tokens]
s = ''.join(tokens1)
assert p.b == s,repr(s)

if 0:
    for z in tokens:
        kind,val = z
        print('%6s %s' % (kind,repr(val)))
        
# Next, start filtering.
tokens = [(kind,g.choose(kind=='string','"S"',val)) for kind,val in tokens]

if 0: # Delete whitespace.
    tokens = [(kind,val) for (kind,val) in tokens if kind != 'ws']
    tokens = [(kind,g.choose(kind=='id',val+' ',val)) for (kind,val) in tokens]

# Last: stringize.
tokens = [val for kind,val in tokens if kind != 'comment']
# print(''.join(tokens))

if 1: # Print lines containing '='
    s = ''.join(tokens)
    for ch in '()[]{}<>.,:=+-/':
        s = s.replace(' '+ch,ch)
    aList = [z for z in g.splitLines(s)
        if z.find('=') > -1] # and not z.find('+=')>-1 and not z.find('-=')>-1]
    print(''.join(aList))
    
#@+node:ekr.20111204110514.10287: *4* @test p.moveToFirst/LastChild
def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()

child = p.firstChild()
assert child
setup(child)
p2 = child.insertAfter()
p2.h = "test"
try:
    assert c.positionExists(p2),p2
    p2.moveToFirstChildOf(child)
    assert c.positionExists(p2),p2
    p2.moveToLastChildOf(child)
    assert c.positionExists(p2),p2
finally:
    if 1:
        setup(child)
    c.redraw(p)
#@+node:ekr.20111210100047.10306: *5* child
#@+node:ekr.20111116161118.10247: *3* Old lint tests
#@+node:ekr.20111116103733.9845: *4*  Naming tests
# http://docs.python.org/reference/executionmodel.html#naming-and-binding

if 0:
    def test():
        a = b
        b = 1 # UnboundLocalError
        
print('***')
          
def test():
    global g2
    g2 = 4
    def test2():
        print(g2)
    test2()
    g2 = 3
    print(g2)
    
g2 = 'g2'
print(g2)

test()
#@+node:ekr.20111116103733.9846: *5* << define s>>
s = '''



'''

s = g.adjustTripleString(s,-4)
#@+node:ekr.20111116103733.9839: *4* @test create lots of data structures
# A simple prototype of data-centric design.
# 0.023 sec to create 100,000 dicts.
# 0.230 sec to create 1,000,000 dicts.

import time

t1 = time.clock()
n = 1000000

d = {}
for z in range(n):
    d[n] = {'n':n,}

t2 = time.clock()
print('Created %s dicts in %2.3f sec.' % (n,t2-t1))
#@+node:ekr.20111116103733.9844: *4* @test dumper (to outNodes)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outNodes.txt'

outStream = open(out,'w')
u.AstDumper().dumpFileAsNodes(fn,outStream)
#@+node:ekr.20111116103733.9840: *4* @test dumper (to outString)
import leo.core.leoGlobals as g
import sys
import lintutils as u

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
out = 'c:/leo.repo/new-pylint/outString.txt'

outStream = open(out,'w')
u.AstDumper(brief=True).dumpFileAsString(fn,outStream)
#@+node:ekr.20111116103733.9838: *4* @test speed of AstTraverser (one file)
import leo.core.leoGlobals as g
import leo.core.leoInspect as leoInspect
import ast
import time

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
    
t1 = time.clock()
s = open(fn,'r').read()
t2 = time.clock()
tree = ast.parse(s,filename=fn,mode='exec')
t3 = time.clock()
leoInspect.AstTraverser(fn).visit(tree)
t4 = time.clock()

if 1:
    print('read:     %2.3f sec.' % (t2-t1))
    print('parse:    %2.3f sec.' % (t3-t2))
    print('traverse: %2.3f sec.' % (t4-t3))
    print('total:    %2.3f sec.' % (t4-t1))
#@+node:ekr.20111128103520.10237: *3* Tests of @shadow from unitTest.leo
#@+node:ekr.20111128103520.10238: *4* @@shadow ../test/unittest/at-shadow-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10239: *5* spam
def spam():
    pass
#@+node:ekr.20111128103520.10240: *5* eggs
def eggs():
    pass
#@+node:ekr.20111128103520.10241: *4* @@shadow unittest/at-shadow-line-number-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20111128103520.10242: *5* child
def child():
    pass
#@+node:ekr.20111128103520.10243: *4* @test @shadow: shape of tree
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow ../test/unittest/at-shadow-test.py'
    p = g.findNodeAnywhere(c,h)
    assert p
    
    table = (
        (p.firstChild(),'spam'),
        (p.firstChild().next(),'eggs')
    )
    
    assert not p.isDirty(),p.h # Do not ignore this failure!
    
    for p2,h2 in table:
        assert len(p2.h) == len(h2)
#@+node:ekr.20111128103520.10244: *4* @test goto-global-line @shadow
# Not valid for external tests: uses @<file> node.
if not g.app.isExternalUnitTest:

    h = '@shadow unittest/at-shadow-line-number-test.py'
    root1 = g.findNodeAnywhere(c,h)
    assert root1
    assert root1.isAnyAtFileNode()
    
    fileName,lines,n,root2 = c.goToLineNumber(c).setup_file(n=6,p=root1)
    assert fileName == h[8:],'fileName'
    assert root2 == root1
    
    if 0:
        print('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
            root and root.h,isRaw,n,len(lines)))
#@+node:ekr.20111116103733.9818: *3* LeoInspect tests
#@+node:ekr.20111116103733.10672: *4* @test leoInspect with multiple files
import leo.core.leoInspect as inspect

import os

<< define old_s >>
<< define s >>

g.cls()

aList = (
    'leoAtFile.py',
    'leoEditCommands.py',
)
inspect.test(c,aList,print_stats=False,s=None,print_times=True)
#@+node:ekr.20111116103733.10451: *5* << define old_s >>
# import leo.core.leoGlobals
# import leo.core.leoGlobals as g
# from leo.core.leoGlobals import pr as pr2
# from leo.core.leoGlobals import trace

s_old = '''\
import sys

aGlobal = 5
# aGlobal2 is not explicitly defined.

c = [z for z in 'abc']

def myFunc():
    n1,n2,n3,junk,junk=sys.version_info
    a = self.b
    for z in a:
        print(z)
    with A() as a:
        print(a,b)
        
def test():
    a = b # UnboundLocalError.
    b = 1
    c = 2 # Any def will do at present.
    print(g)
    print(c.frame.body)
    print(c.frame.body.xxx.yyy)
    print(b.yyy) # no check will be made.
    print(xxx.yyy)
    for c in 'abc':
        print(c,b)
        print(g)


class myClass:
    
    def __init__(self,c):
        self.a = True
        self.b = None
        c.frame.xxxx
        
    def spam(self,a,b,c=5,*args,**keys):
        global aGlobal2
        aGlobal2 = 'abc'
        self.a = b
        self.a = x
        
    def no_self(a):
        pass
        
    def test_lambda(self):
        f = lambda a,b: a

    def test_comprehension(self):
        z2 = [z for z in 'abc']
        
aGlobal3 = 4 # This should be defined everywhere.

def test():
    # a = ','.join(['a','b'])
    p = 5
    # print(p.parent().h)
    # print(g.app.windowList[0])
    print(p)
    print(g)

'''

# import leo.core.leoCommands as leoCommands
#@+node:ekr.20111116103733.10452: *5* << define s >>
s = '''\

import leo.core.leoGlobals as g

def test(c):
    a = 5
    f = c.frame
    c.frame.body.bodyCtrl = w

'''

s = g.adjustTripleString(s,-4)
# print(s)
#@+node:ekr.20111116103733.10450: *5* test
def test(c,files,print_stats=True,s=None,print_times=True):
   
    t1 = time.clock()
    sd = SemanticData(controller=None)

    if s: # Use test string.
        fn = '<test file>'
        InspectTraverser(c,fn,sd,s).traverse(s)
    else:
        for fn in files:
            print(g.shortFileName(fn))
            s = LeoCoreFiles().get_source(fn)
            if s:
                InspectTraverser(c,fn,sd,s).traverse(s)
            else:
                print('file not found: %s' % (fn))
           
    sd.total_time = time.clock()-t1
    
    if print_times: sd.print_times()
    if print_stats: sd.print_stats()
#@+node:ekr.20111116103733.10449: *4* @test leoInspect.module.classes
import leo.core.leoInspect as inspect

dump_modules = False
print_modules = True
print_functions = False
print_stats = False
print_times = True

if dump_modules or print_stats:
    g.cls()

m = inspect.module(c,'leoEditCommands.py',sd=None,
    print_stats=print_stats,print_times=print_times)
    
for o in m.classes():
    if dump_modules:
        o.dump(verbose=False)
    if print_modules:
        print(o)
    if print_functions:
        for f in o.functions:
            print('  %s' % f)
#@+node:ekr.20111116161118.10212: *4* @test leoInspect.module.classes 2
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(c,'leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.classes():
    print(z)
#@+node:ekr.20111116161118.10218: *4* @test leoInspect.module.defs
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(c,'leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.defs():
    print(z)
#@+node:ekr.20111116161118.10181: *4* @test leoInspect.module.statements
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(c,'leoEditCommands.py')
    #,sd=None,print_stats=False,print_times=False)
    
for z in m.statements():
    print(z)
#@+node:ekr.20111116161118.10230: *4* @test leoInspect (leoEditCommands.py)
import leo.core.leoInspect as inspect

g.cls()

m = inspect.module(fn='leoEditCommands.py')

def show(o):
    print('%-5s %s' % (o.line_number(),o.format()))

var = '.widget'
func = 'w.insert'

if 0:
    
    print('\nAssignments to %s...\n' % (var))
    for o in m.assignments_to(var):
        show(o)
        
    print('\nAssignments using %s...\n' % (var))
    for o in m.assignments_using(var):
        show(o)
        
    print('\nCalls to %s...\n' % (func))
    for o in m.calls_to(func):
        show(o)
        
    if 1:
        classes = m.classes()
        for d in classes[0].defs():
            print('')
            print(d)
            for z in d.statements():
                # print(z.tree())
                # print(z.sd.dump_ast(z.tree()))
                lines = g.splitLines(z.format())
                for line in lines:
                    print('  %s' % (line))
#@+node:ekr.20111127153202.10231: *4* @test speed of AstTraverser (all Leo core files)
import leo.core.leoGlobals as g
import leo.core.leoInspect as inspect
import ast
import time

read_time,parse_time,traverse_time = 0.0,0.0,0.0
t_start = time.clock()
count = 0
for fn in inspect.LeoCoreFiles().files:
    count += 1
    t2 = time.clock()
    s = open(fn,'r').read()
    t3 = time.clock()
    tree = ast.parse(s,filename=fn,mode='exec')
    t4 = time.clock()
    inspect.AstTraverser(fn).visit(tree)
    t5 = time.clock()
    read_time += t3-t2
    parse_time += t4-t3
    traverse_time += t5-t4
t_end = time.clock()
total_time = t_end-t_start
if 1:
    print('files:    %s' % (count))
    print('read:     %2.3f sec.' % (read_time))
    print('parse:    %2.3f sec.' % (parse_time))
    print('traverse: %2.3f sec.' % (traverse_time))
    print('total:    %2.3f sec.' % (total_time))
#@+node:ekr.20111127090852.10227: *4* @test leoInspect (all core files)
import leo.core.leoInspect as inspect
import time

sd = inspect.SemanticData()
start_time = time.clock()

count = 0
for fn in inspect.LeoCoreFiles().files:
    # print(fn)
    m = inspect.module(fn,sd=sd)
    count += 1

end_time = time.clock()
total_time = end_time-start_time

if 1:
    print('files: %s' % (count))
    print('total: %2.3f sec.' % (total_time))
if 1:
    sd.print_stats()
#@+node:ekr.20111117031039.10762: *4* @test leoInspect.module (s)
import leo.core.leoInspect as inspect

g.cls()

def show(o,indent):
    # print('\n%s\n' % o.sd.dump_ast(o.tree()))
    print('%s%s' % (' '*4*indent,o.format()))

<< define s >>
print('Input...\n%s\n' % (s.rstrip()))

m = inspect.module(s=s)

if 1:
    print(show(m,0))

print('\nAssignments to a...\n')
for o in m.assignments_to('a'):
    print(o.format())
    
print('\nAssignments using d...\n')
for o in m.assignments_using('d'):
    print(o.format())
    
print('\nCalls to f...\n')
for o in m.calls_to('f'):
    print(o.format())

if 1:
    for s in m.statements():
        show(s,0)
    
    for f in m.functions():
        show(f,0)
        for z in f.statements():
            show(z,1)
    
    for cls in m.classes():
        show(cls,0)
        for d in cls.defs():
            show(d,1)
            for z in d.statements():
                show(z,1)
#@+node:ekr.20111117031039.10763: *5* << define s >>
s = '''
x.y = b(arg1,arg2=5,*args,**args).c[1:2:3].d
a=b+c
f(a=1,b=2,*args,**keys)
'''


# def outer_function(a,b=99,c=88,*args,**keys):
    # print('hello')
    
# class myClass:
    # def method():
        # pass
    
#@+node:ekr.20111116103733.9838: *4* @test speed of AstTraverser (one file)
import leo.core.leoGlobals as g
import leo.core.leoInspect as leoInspect
import ast
import time

fn = 'c:/leo.repo/trunk/leo/core/leoApp.py'
    
t1 = time.clock()
s = open(fn,'r').read()
t2 = time.clock()
tree = ast.parse(s,filename=fn,mode='exec')
t3 = time.clock()
leoInspect.AstTraverser(fn).visit(tree)
t4 = time.clock()

if 1:
    print('read:     %2.3f sec.' % (t2-t1))
    print('parse:    %2.3f sec.' % (t3-t2))
    print('traverse: %2.3f sec.' % (t4-t3))
    print('total:    %2.3f sec.' % (t4-t1))
#@+node:ekr.20120116073928.10114: *3* Unit tests for settings
#@+node:ekr.20120126050844.10386: *4* @ignore print dicts unit tests
#@+node:ekr.20120117095916.10124: *5* @test printMenusList
def printMenusList(aList,level=0):
    
    for z in aList:
        a,b,c = z
        print('*** kind',a)
        if type(b) in (type(()),type([])):
            for z2 in b:
                a1,b1,c1 = z2
                if a1.startswith('@menu') and type(b1) in (type(()),type([])):
                    print()
                    print('*** inner menu: %s' % (level+1))
                    print(a1)
                    for z3 in b1:
                        print(z3)
                    if c1: print(c1)
                else:
                    print(z2)
            if c: print(c)
        else:
            print(b)
        print()
        break #
        
printMenusList(c.config.getMenusList())
       
#@+node:ekr.20120117095916.10140: *5* @test printInverseBindingDict
print('\ninverseBindingDict...\n')

d = c.k.computeInverseBindingDict()

for key in sorted(list(d.keys())):

    if 1 == len(d.get(key)):
        print(key,d.get(key))
    else:
        print()
        print(key)
        print(d.get(key))
        print()
#@+node:ekr.20120123113111.10925: *5* @test printBindingsDict
import leo.core.leoConfig as leoConfig # for ShortcutInfo
    
partial = True

d = c.k.bindingsDict
    # Keys are shortcuts; values are *lists* leoConfig.ShortcutInfo objects.
    
print('\nk.bindingsDict%s...\n' % ' (partial)' if partial else '')
    
for key in list(sorted(d.keys())):
    aList = d.get(key,[])
    for b in aList:
        assert isinstance(b,leoConfig.ShortcutInfo)
        if not partial or b.kind != 'leosettings.leo':
            print(b)
#@+node:ekr.20120117095916.10141: *5* @test printMasterBindingsDict
partial = True

panes = ('all','body','button','log','tree','text',
    'command','insert','overwrite',)

d = c.k.masterBindingsDict
    # Keys are scope names (in panes) or mode names.
    # Values are dicts:
        # keys are strokes; values are leoConfig.ShortcutInfo objects.
        
print('\nk.masterBindingsDict%s...\n' % ' (partial)' if partial else '')

for pane in sorted(list(d.keys())):
    kind = 'pane' if pane in panes else 'mode'
    print('%s: %s...' % (kind,pane))
    d2 = d.get(pane)
    for stroke in sorted(list(d2.keys())):
        b = d2.get(stroke)
        if not partial or b.kind != 'leosettings.leo':
            print('%6s %25s %17s %s' % (b.pane,stroke,b.kind,b.commandName))
            assert b.pane == pane
            assert b.stroke == stroke
    print()
#@+node:ekr.20120126080450.10187: *4* @ignore passed
#@+node:ekr.20120126080450.10189: *5* @test mode-related info
@

g.app.config.modeCommandsDict
    Keys are command names: enter-x-mode.
    Values are inner dictionaries:
        Keys are command names, values are lists of ShortcutInfo nodes.
@c

d = g.app.config.modeCommandsDict
    
for key in sorted(d.keys()):
    print('*** mode ***',key)
    d2 = d.get(key)
    for key2 in sorted(d2.keys()):
        aList = d2.get(key2)
        print(key2)
        for si in aList:
            print('   ',si)
#@+node:ekr.20120120095156.10262: *5* @test types of contents of settings dicts
@
ivar                    Keys                Values
----                    ----                ------
c.commandsDict          command names (1)   functions
k.inverseCommandsDict   func.__name__       command names
k.bindingsDict          shortcuts           list of ShortcutInfo objects
k.masterBindingsDict    scope names (2)     inner masterBindingDicts (3)
k.masterGuiBindingsDict strokes             list of widgets in which stoke is bound
k.settingsNameDict (4)  settings.lower()    "Real" Tk specifiers
inverseBindingDict (5)  command names       lists of tuples (pane,key)
modeCommandsDict (6)    command name (7)    inner modeCommandsDicts (8)

Notes:
(1) Command names are minibuffer names (strings)
(2) Scope names are 'all','text',etc.
(3) inner masterBindingDicts: Keys are strokes; values are ShortcutInfo objects.
(4) k.settingsNameDict has no inverse.
(5) inverseBindingDict is **not** an ivar: it is computed by k.computeInverseBindingDict.
(6) A global dict: g.app.gui.modeCommandsDict
(7) enter-x-command
(8) Keys are command names, values are lists of ShortcutInfo objects.
@c

si_type = c.k.ShortcutInfo
disabled_func_type = None # Should be any bound method.
k = c.k

@others

test_dict_of_objects(c.commandsDict,type('s'),disabled_func_type,'commandsDict')
test_dict_of_objects(k.inverseCommandsDict,type('s'),type('s'),'inverseCommandsDict')
test_dict_of_lists(k.bindingsDict,si_type,'bindingsDict')
test_dict_of_dicts(k.masterBindingsDict,si_type,'masterBindingsDict')
test_dict_of_lists(k.masterGuiBindingsDict,None,'masterGuiBindingsDict')
test_dict_of_objects(k.settingsNameDict,type('s'),type('s'),'settingsNameDict')
test_dict_of_lists(k.computeInverseBindingDict(),type(tuple()),'inverseBindingDict')

# Test individual dicts separately.
d = g.app.config.modeCommandsDict
test_dict_of_dicts(d,None,'modeCommandsDict')
for key in sorted(d.keys()):
    d2 = d.get(key)
    test_dict_of_lists(d2,si_type,'inner modeCommandsDict')
        # This requires a hack to special-case the
        # '*entry-commands*' and '*command-prompt*' keys.
#@+node:ekr.20120126080450.10193: *6* test_dict_of_dicts
def test_dict_of_dicts(d,theType,tag):

    assert d,tag

    for key in d.keys():
        d2 = d.get(key)
        assert type(d2) == type({})
        for key in d2.keys():
            obj = d2.get(key)
            if theType:
                assert type(obj) == theType,repr(obj)
#@+node:ekr.20120126080450.10191: *6* test_dict_of_lists
def test_dict_of_lists(d,theType,tag):

    assert d,tag

    for key in d.keys():
        obj = d.get(key)
        if key in ('*entry-commands*','*command-prompt*'):
            # Special case for g.app.config.modeCommandsDict
            assert type(obj)==type([]),repr(obj)
        else:
            assert type(obj) == type([])
            # Don't check types of list elements if theType is None.
            if theType:
                for z in obj:
                    assert type(z)==theType,'key: %s obj: %s' % (key,repr(obj))
#@+node:ekr.20120126080450.10195: *6* test_dict_of_objects
def test_dict_of_objects(d,keyType,valueType,tag):

    assert d,tag

    for key in d.keys():
        assert type(key) == keyType,repr(key)
        obj = d.get(key)
        # Don't check type of obj if valueType is None.
        if valueType:
            assert type(obj) == valueType,'\nobj: %s\nvalueType: %s' % (repr(obj),valueType)
#@+node:ekr.20120126080450.10194: *6* Unused
# import types
# types.ListType does not exist in Python 3.x.
# assert isinstance(aList,list().__class__)
#@+node:ekr.20120127084215.10238: *5* @test merge_settings_dicts
@others

# import os ; os.system('cls')
    
d1 = g.app.config.immutable_leo_settings_shortcuts_dict
d2 = g.app.config.immutable_my_leo_settings_shortcuts_dict
d3 = g.app.config.merge_settings_dicts(d1,d2)

if False:
    patterns = (
        'backward-find-character-extend-selection',
    )
    for pattern in patterns:
        print(dump_dict(d1,pattern,tag='d1'))
        print(dump_dict(d2,pattern,tag='d2'))
        print(dump_dict(d3,pattern,tag='d3'))

test(d1,d2,d3)
#@+node:ekr.20120127145909.10227: *6* dump & dump_dict (@test merge_settings_dicts)
def dump(aList,pattern=None,tag=None):
    
    return '\n'.join([repr(z) for z in aList])
    

def dump_dict(d,pattern=None,tag=None):
    
    result = [] # '\ndump of %s...' % (tag)
    
    for key in d.keys():
        if pattern in (key,None):
            result.append(key)
            aList = d.get(key)
            for z in aList:
                result.append('    %s' % (z))
                
    return '\n'.join(result)
#@+node:ekr.20120127084215.10239: *6* test (@test merge_settings_dicts)
def test(old_d,new_d,result_d):
    
    '''Test that result_d is the result of upating old_d with new_d.
    
    This test is tricky: only inverted dicts have ShortcutInfo nodes as keys.'''
    
    invert,uninvert = g.app.config.invert,g.app.config.uninvert

    # Compute the inversions of all the dicts.
    inv_old,inv_new,inv_res = invert(old_d),invert(new_d),invert(result_d)
    
    # Part 1: Ensure we test all keys.
    keys = list(inv_old.keys())
    keys.extend(list(inv_new.keys()))
    keys.extend(list(inv_res.keys()))
    keys = sorted(list(set(keys)))
    assert None not in keys
    for key in inv_old.keys(): assert key in keys,key
    for key in inv_new.keys(): assert key in keys,key
    for key in inv_res.keys(): assert key in keys,key
    
    # Part 2: Carefully test the inverted result.
    def si_name_key(si): return si.commandName or ''

    for key in keys:
        # Compute the *sorted* list of 
        res_list = sorted(inv_res.get(key,[]),key=si_name_key)
        old_list = sorted(inv_old.get(key,[]),key=si_name_key)
        new_list = sorted(inv_new.get(key,[]),key=si_name_key)
        assert res_list,'no res_list.get(%s)' % (key)
        # if new_list: print(key,dump(new_list))
        if new_list:
            assert new_list == res_list,'key %s\nnew:\n%s\nres:\n%s' % (
                key,dump(new_list),dump(res_list))
        else:
            assert old_list == res_list,'key %s\nold:\n%s\nres:\n%s' % (
                key,dump(old_list),dump(res_list))
    
    # Part 3: Test that result_d == uninvert(invert(result_d)).
    # A.  They must have the same keys.
    unv_res = uninvert(inv_res)
    assert sorted(list(result_d.keys())) == sorted(list(unv_res.keys()))

    # B. The values of for each key must match after being sorted.
    def si_stroke_key(si): return si.stroke or ''
        
    for key in sorted(result_d.keys()):
        res_list = sorted(result_d.get(key,[]),key=si_stroke_key)
        unv_list = sorted( unv_res.get(key,[]),key=si_stroke_key)
        assert res_list == unv_list,'key %s\nres:\n%s\nunv:\n%s' % (
            key,dump(res_list),dump(unv_list))
   
#@+node:ekr.20120203153754.10032: *5* @test KeyStroke
ks = c.k.KeyStroke

@others

a1 = ks('a')
a2 = ks('a')
b1 = ks('b')
assert a1 == a2
d = {}
d[a1] = a1.s
d[a2] = a2.s
d[b1] = b1.s

for key in sorted(d):
    print(key,d.get(key))
#@+node:ekr.20120205022040.17748: *5* @test g.TypedDict
d = g.TypedDictOfLists('ks',type('s'),type(9))
d.add('a',1)
d.add('a',2)
d.add('b',3)

print(d)
for s in sorted(d.keys()):
    print(s,d.get(s,[]))

print('after replace...')
d.replace('a',[8,9,10])

for s in sorted(d.keys()):
    print(s,d.get(s,[]))
#@+node:ekr.20120215062153.14233: *3* @mark-for-unit-tests
#@+node:ekr.20080412053100.5: *4* @settings
#@+node:ekr.20080412053100.4: *5* @bool fixedWindow = False
#@+node:ekr.20100902154544.5872: *5* @bool enable-abbreviations = True
#@+node:ekr.20111123042248.12701: *5* @enabled-plugins
# Leo loads plugins in the order they appear here.

# Highly-recommended plugins:

plugins_menu.py
free_layout.py # needs to be early
viewrendered.py
mod_scripting.py
bigdash.py
#@+node:ekr.20111031081007.9985: *5* @shortcuts
run-selected-unit-tests-externally = Alt-4 # Standard binding, unchanged.
run-marked-unit-tests-externally = Alt-5
run-marked-unit-tests-locally = Alt-6
#@+node:ekr.20120313074006.16133: ** Keep for now
@nocolor-node

All these are already copied to leoDocs.leo
#@+node:ekr.20120304214900.9938: *3* Fixed bug 917814: Switching Log Pane tabs is done incompletely
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/917814

Switching Log Pane tabs is not done cleanly and completely. To see this do the following:

1) Start Leo-Editor
2) Shift-Ctrl-F. This brings the Nav tab to the foreground and
   leaves the focus in the search string field of the Nav pane.
3) Click on the Log tab of the Log pane.
4) Ctrl-A. This causes the following messags to be displayed in the Log tab of the Log pane:

exception executing command
Traceback (most recent call last):
  File "/home/bob/bzrWork/trunk/leo/core/leoCommands.py", line 419, in doCommand
    val = command(event)
  File "/home/bob/bzrWork/trunk/leo/core/leoEditCommands.py", line 5755, in selectAllText
    return w.selectAllText()
  File "/home/bob/bzrWork/trunk/leo/core/leoFrame.py", line 168, in selectAllText
    def selectAllText (self,insert=None): self.widget and self.widget.selectAllText(insert)
AttributeError: 'LeoQuickSearchWidget' object has no attribute 'selectAllText'


That is, it appears that the focus is on the Log tab and the
intention is to select-all in the log tab, but Leo-Editor
tries to select-all in the Nav pane.

Strangely, doing a Ctrl-A in the Nav tab of the Log pane
seems to do nothing---no errors, no select.

-------
Ubuntu 11.10 with Fluxbox window manager
Leo Log Window
Leo 4.9.1 devel, build 4928, 2012-01-14 11:27:18
Python 2.7.2, qt version 4.7.3
linux2
setting leoID from os.getenv('USER'): 'bob'
load dir: /home/bob/bzrWork/trunk/leo/core
global config dir: /home/bob/bzrWork/trunk/leo/config
home dir: /home/bob
reading settings in /home/bob/bzrWork/trunk/leo/config/leoSettings.leo
reading settings in /home/bob/.leo/myLeoSettings.leo
reading settings in /home/bob/.leo/workbook.leo
reading: /home/bob/.leo/workbook.leo
#@+node:ekr.20110605121601.18331: *4* selectTab & helper (leoQtLog)
def selectTab (self,tabName,createText=True,widget=None,wrap='none'):
    # createText is used by leoLog.selectTab.

    '''Create the tab if necessary and make it active.'''

    trace = False and not g.unitTesting
    c = self.c ; w = self.tabWidget
    
    if trace: g.trace(tabName,g.callers())

    # Step 1: See if the tab exits.
    ok = self.selectHelper(tabName)
    if ok: return

    # Step 2: create tab if necessary.
    self.createTab(tabName,widget=widget,wrap=wrap)
    self.selectHelper(tabName)
#@+node:ekr.20110605121601.18332: *5* selectHelper (leoQtLog)
def selectHelper (self,tabName):

    trace = False and not g.unitTesting
    c,w = self.c,self.tabWidget

    for i in range(w.count()):
        if tabName == w.tabText(i):
            w.setCurrentIndex(i)
            
            widget = w.widget(i)
            
            # 2011/11/21: Set the .widget ivar only if there is a wrapper.
            wrapper = hasattr(widget,'leo_log_wrapper') and widget.leo_log_wrapper
            if wrapper:
                self.widget = wrapper
            if trace: g.trace(tabName,'widget',widget,'wrapper',wrapper)
            
            # Do *not* set focus here!
                # c.widgetWantsFocus(tab_widget)

            if tabName == 'Spell':
                # the base class uses this as a flag to see if
                # the spell system needs initing
                self.frameDict['Spell'] = widget
                
            self.tabName = tabName # 2011/11/20
            return True
    else:
        self.tabName = None # 2011/11/20
        if trace: g.trace('** not found',tabName)
        return False
#@+node:ekr.20120304214900.9940: *4* Event handler (leoQtLog)
def onCurrentChanged(self,idx):
    
    trace = False and not g.unitTesting

    tabw = self.tabWidget
    w = tabw.widget(idx)
    
    # Fixes bug 917814: Switching Log Pane tabs is done incompletely
    wrapper = hasattr(w,'leo_log_wrapper') and w.leo_log_wrapper
    if wrapper:
        self.widget = wrapper

    if trace: g.trace(idx,tabw.tabText(idx),self.c.frame.title) # wrapper and wrapper.widget)
#@+node:ekr.20110605121601.18312: *4* class leoQtLog (leoLog)
class leoQtLog (leoFrame.leoLog):

    """A class that represents the log pane of a Qt window."""

    @others
#@+node:ekr.20110605121601.18313: *5* leoQtLog Birth
#@+node:ekr.20110605121601.18314: *6* leoQtLog.__init__
def __init__ (self,frame,parentFrame):

    # g.trace('(leoQtLog)',frame,parentFrame)

    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)

    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    # self.logCtrl = None # The text area for log messages.
        # logCtrl is now a property of the base leoLog class.

    self.contentsDict = {} # Keys are tab names.  Values are widgets.
    self.eventFilters = [] # Apparently needed to make filters work!
    self.logDict = {} # Keys are tab names text widgets.  Values are the widgets.
    self.menu = None # A menu that pops up on right clicks in the hull or in tabs.

    self.tabWidget = tw = c.frame.top.leo_ui.tabWidget
        # The Qt.QTabWidget that holds all the tabs.
    
    # Fixes bug 917814: Switching Log Pane tabs is done incompletely.
    tw.connect(tw,QtCore.SIGNAL('currentChanged(int)'),self.onCurrentChanged)

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),True,False)

    if 0: # Not needed to make onActivateEvent work.
        # Works only for .tabWidget, *not* the individual tabs!
        theFilter = leoQtEventFilter(c,w=tw,tag='tabWidget')
        tw.installEventFilter(theFilter)

    self.setFontFromConfig()
    self.setColorFromConfig()
#@+node:ekr.20110605121601.18315: *6* leoQtLog.finishCreate
def finishCreate (self):

    c = self.c ; log = self ; w = self.tabWidget

    # Remove unneeded tabs.
    for name in ('Tab 1','Page'):
        for i in range(w.count()):
            if name == w.tabText(i):
                w.removeTab(i)
                break

    # Rename the 'Tab 2' tab to 'Find'.
    for i in range(w.count()):
        if w.tabText(i) in ('Find','Tab 2'):
            w.setTabText(i,'Find')
            self.contentsDict['Find'] = w.currentWidget()
            break

    # Create the log tab as the leftmost tab.
    # log.selectTab('Log')
    log.createTab('Log')
    logWidget = self.contentsDict.get('Log')
    logWidget.setWordWrapMode(
        g.choose(self.wrap,
            QtGui.QTextOption.WordWrap,
            QtGui.QTextOption.NoWrap))

    for i in range(w.count()):
        if w.tabText(i) == 'Log':
            w.removeTab(i)
    w.insertTab(0,logWidget,'Log')

    c.searchCommands.openFindTab(show=False)
    c.spellCommands.openSpellTab()
#@+node:ekr.20110605121601.18316: *6* leoQtLog.getName
def getName (self):
    return 'log' # Required for proper pane bindings.
#@+node:ekr.20110605121601.18317: *5* Do nothings (leoQtLog)
#@+node:ekr.20110605121601.18318: *6* Config (leoQtLog)
# These will probably be replaced by style sheets.

def configureBorder(self,border):               pass
def configureFont(self,font):                   pass
def getFontConfig (self):                       pass
def setColorFromConfig (self):                  pass
def SetWidgetFontFromConfig (self,logCtrl=None): pass
def saveAllState (self):                        pass
def restoreAllState (self,d):                   pass
#@+node:ekr.20110605121601.18319: *6* Focus & update (leoQtLog)
def onActivateLog (self,event=None):    pass
def hasFocus (self):                    return None
def forceLogUpdate (self,s):            pass
#@+node:ekr.20120304214900.9940: *5* Event handler (leoQtLog)
def onCurrentChanged(self,idx):
    
    trace = False and not g.unitTesting

    tabw = self.tabWidget
    w = tabw.widget(idx)
    
    # Fixes bug 917814: Switching Log Pane tabs is done incompletely
    wrapper = hasattr(w,'leo_log_wrapper') and w.leo_log_wrapper
    if wrapper:
        self.widget = wrapper

    if trace: g.trace(idx,tabw.tabText(idx),self.c.frame.title) # wrapper and wrapper.widget)
#@+node:ekr.20111120124732.10184: *5* isLogWidget (leoQtLog)
def isLogWidget(self,w):
    
    val = w == self or w in list(self.contentsDict.values())
    # g.trace(val,w)
    return val
#@+node:ekr.20110605121601.18321: *5* put & putnl (leoQtLog)
#@+node:ekr.20110605121601.18322: *6* put (leoQtLog)
# All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):

    c = self.c
    if g.app.quitting or not c or not c.exists:
        print('qtGui.log.put fails',repr(s))
        return

    if color:
        color = leoColor.getColor(color,'black')
    else:
        color = leoColor.getColor('black')

    self.selectTab(tabName or 'Log')

    # Note: this must be done after the call to selectTab.
    w = self.logCtrl.widget
        # w is a QTextBrowser

    if w:
        sb = w.horizontalScrollBar()
        pos = sb.sliderPosition()
        # g.trace(pos,sb,g.callers())
        s=s.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
        if not self.wrap: # 2010/02/21: Use &nbsp; only when not wrapping!
            s = s.replace(' ','&nbsp;')
        s = s.rstrip().replace('\n','<br>')
        s = '<font color="%s">%s</font>' % (color,s)
        w.append(s)
        w.moveCursor(QtGui.QTextCursor.End)
        sb.setSliderPosition(0) # Force the slider to the initial position.
    else:
        # put s to logWaiting and print s
        g.app.logWaiting.append((s,color),)
        if g.isUnicode(s):
            s = g.toEncodedString(s,"ascii")
        print(s)
#@+node:ekr.20110605121601.18323: *6* putnl (leoQtLog)
def putnl (self,tabName='Log'):

    if g.app.quitting:
        return

    if tabName:
        self.selectTab(tabName)

    w = self.logCtrl.widget
    
    if w:
        sb = w.horizontalScrollBar()
        pos = sb.sliderPosition()
        # Not needed!
            # contents = w.toHtml()
            # w.setHtml(contents + '\n')
        w.moveCursor(QtGui.QTextCursor.End)
        sb.setSliderPosition(pos)
        w.repaint() # Slow, but essential.
    else:
        # put s to logWaiting and print  a newline
        g.app.logWaiting.append(('\n','black'),)
#@+node:ekr.20110605121601.18324: *5* Tab (leoQtLog)
#@+node:ekr.20110605121601.18325: *6* clearTab
def clearTab (self,tabName,wrap='none'):

    w = self.logDict.get(tabName)
    if w:
        w.clear() # w is a QTextBrowser.
#@+node:ekr.20110605121601.18326: *6* createTab (leoQtLog)
def createTab (self,tabName,widget=None,wrap='none'):
    """ Create a new tab in tab widget

    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """

    trace = False and not g.unitTesting
    c = self.c
    
    if trace: g.trace(tabName,widget and g.app.gui.widget_name(widget) or '<no widget>')

    if widget is None:

        widget = LeoQTextBrowser(parent=None,c=c,wrapper=self)
            # widget is subclass of QTextBrowser.
        contents = leoQTextEditWidget(widget=widget,name='log',c=c)
            # contents a wrapper.
        widget.leo_log_wrapper = contents
            # Inject an ivar into the QTextBrowser that points to the wrapper.
            
        if trace: g.trace('** creating',tabName,'self.widget',contents,'wrapper',widget)
        
        widget.setWordWrapMode(
            g.choose(self.wrap,
                QtGui.QTextOption.WordWrap,
                QtGui.QTextOption.NoWrap))

        widget.setReadOnly(False) # Allow edits.
        self.logDict[tabName] = widget
        if tabName == 'Log':
            self.widget = contents # widget is an alias for logCtrl.
            widget.setObjectName('log-widget')

        if True: # 2011/05/28.
            # Set binding on all text widgets.
            theFilter = leoQtEventFilter(c,w=self,tag='log')
            self.eventFilters.append(theFilter) # Needed!
            widget.installEventFilter(theFilter)
            
        if True and tabName == 'Log':
    
            assert c.frame.top.__class__.__name__ == 'DynamicWindow'
            find_widget = c.frame.top.leo_find_widget
            
            # 2011/11/21: A hack: add an event filter.
            find_widget.leo_event_filter = leoQtEventFilter(c,w=widget,tag='find-widget')
            find_widget.installEventFilter(find_widget.leo_event_filter)
            if trace: g.trace('** Adding event filter for Find',find_widget)
            
            # 2011/11/21: A hack: make the find_widget an official log widget.
            self.contentsDict['Find']=find_widget
    
        self.contentsDict[tabName] = widget
        self.tabWidget.addTab(widget,tabName)
    else:
        contents = widget
            # Unlike text widgets, contents is the actual widget.
        widget.leo_log_wrapper = contents
            # The leo_log_wrapper is the widget itself.
        if trace: g.trace('** using',tabName,widget)
        
        if 1: # Now seems to work.
            theFilter = leoQtEventFilter(c,w=contents,tag='tabWidget')
            self.eventFilters.append(theFilter) # Needed!
            widget.installEventFilter(theFilter)
    
        self.contentsDict[tabName] = contents
        self.tabWidget.addTab(contents,tabName)

    return contents
#@+node:ekr.20110605121601.18327: *6* cycleTabFocus (leoQtLog)
def cycleTabFocus (self,event=None):

    '''Cycle keyboard focus between the tabs in the log pane.'''
    
    trace = False and not g.unitTesting
    c = self.c
    w = self.tabWidget

    i = w.currentIndex()
    i += 1
    if i >= w.count():
        i = 0

    tabName = w.tabText(i)
    
    self.selectTab(tabName,createText=False)
    if trace: g.trace(i,tabName)

#@+node:ekr.20110605121601.18328: *6* deleteTab
def deleteTab (self,tabName,force=False):

    c = self.c ; w = self.tabWidget

    if force or tabName not in ('Log','Find','Spell'):
        for i in range(w.count()):
            if tabName == w.tabText(i):
                w.removeTab(i)
                break

    self.selectTab('Log')
    c.invalidateFocus()
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18329: *6* hideTab
def hideTab (self,tabName):

    self.selectTab('Log')
#@+node:ekr.20111122080923.10185: *6* orderedTabNames (leoQtLog)
def orderedTabNames (self):
    
    '''Return a list of tab names in the order in which they appear in the QTabbedWidget.'''
    
    w = self.tabWidget

    return [w.tabText(i) for i in range(w.count())]

#@+node:ekr.20110605121601.18330: *6* numberOfVisibleTabs (leoQtLog)
def numberOfVisibleTabs (self):

    return len([val for val in self.contentsDict.values() if val != None])
        # **Note**: the base-class version of this uses frameDict.
#@+node:ekr.20110605121601.18331: *6* selectTab & helper (leoQtLog)
def selectTab (self,tabName,createText=True,widget=None,wrap='none'):
    # createText is used by leoLog.selectTab.

    '''Create the tab if necessary and make it active.'''

    trace = False and not g.unitTesting
    c = self.c ; w = self.tabWidget
    
    if trace: g.trace(tabName,g.callers())

    # Step 1: See if the tab exits.
    ok = self.selectHelper(tabName)
    if ok: return

    # Step 2: create tab if necessary.
    self.createTab(tabName,widget=widget,wrap=wrap)
    self.selectHelper(tabName)
#@+node:ekr.20110605121601.18332: *7* selectHelper (leoQtLog)
def selectHelper (self,tabName):

    trace = False and not g.unitTesting
    c,w = self.c,self.tabWidget

    for i in range(w.count()):
        if tabName == w.tabText(i):
            w.setCurrentIndex(i)
            
            widget = w.widget(i)
            
            # 2011/11/21: Set the .widget ivar only if there is a wrapper.
            wrapper = hasattr(widget,'leo_log_wrapper') and widget.leo_log_wrapper
            if wrapper:
                self.widget = wrapper
            if trace: g.trace(tabName,'widget',widget,'wrapper',wrapper)
            
            # Do *not* set focus here!
                # c.widgetWantsFocus(tab_widget)

            if tabName == 'Spell':
                # the base class uses this as a flag to see if
                # the spell system needs initing
                self.frameDict['Spell'] = widget
                
            self.tabName = tabName # 2011/11/20
            return True
    else:
        self.tabName = None # 2011/11/20
        if trace: g.trace('** not found',tabName)
        return False
#@+node:ekr.20110605121601.18333: *5* leoQtLog color tab stuff
def createColorPicker (self,tabName):

    g.es('color picker not ready for qt',color='blue')
#@+node:ekr.20110605121601.18334: *5* leoQtLog font tab stuff
#@+node:ekr.20110605121601.18335: *6* createFontPicker
def createFontPicker (self,tabName):

    log = self
    QFont = QtGui.QFont
    font,ok = QtGui.QFontDialog.getFont()
    if not (font and ok): return

    style = font.style()
    table = (
        (QFont.StyleNormal,'normal'),
        (QFont.StyleItalic,'italic'),
        (QFont.StyleOblique,'oblique'))
    for val,name in table:
        if style == val:
            style = name ; break
    else: style = ''

    weight = font.weight()
    table = (
        (QFont.Light,'light'),
        (QFont.Normal,'normal'),
        (QFont.DemiBold,'demibold'),
        (QFont.Bold	,'bold'),
        (QFont.Black,'black'))
    for val,name in table:
        if weight == val:
            weight = name ; break
    else: weight = ''

    table = (
        ('family',str(font.family())),
        ('size  ',font.pointSize()),
        ('style ',style),
        ('weight',weight),
    )

    for key,val in table:
        if val:
            g.es(key,val,tabName='Fonts')
#@+node:ekr.20110605121601.18336: *6* createBindings (fontPicker)
def createBindings (self):
    
    pass
#@+node:ekr.20110605121601.18337: *6* getFont
def getFont(self,family=None,size=12,slant='roman',weight='normal'):

    return g.app.config.defaultFont
#@+node:ekr.20110605121601.18338: *6* setFont
def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):

    pass
#@+node:ekr.20110605121601.18339: *6* hideFontTab
def hideFontTab (self,event=None):

    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@+node:ekr.20111026091322.16496: *3* Tried, and failed, to fix bug 844953: copy-clone-pasted node appears in other tab
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/844953

1. Open two empty files with the LEO revision 4451/trunk using the qttabs GUI and save them both.
2. Create a new node and write "Abc" in its head.
3. Select "Copy Node" from the outline menu.
4. Select "Paste Node As Clone" from the outline menu:
   Node is not inserted as clone, but inserted as a copy in the second file/tab.

Sometimes even a standard Copy-Paste action results in the node being inserted in the other file.

EKR: This a unity menu problem, not a problem with the paste commands per se.

The problem is that only a single unity menu exists, and we must ensure that
it is the menu for the presently-selected tab.


The new code consists of calls to c.enableMenuBar, but the code has no effect, so it will be eliminated.
#@+node:ekr.20110605121601.18456: *4* select (leoTabbedTopLevel)
def select (self,c):

    '''Select the tab for c.'''
    
    dw = c.frame.top # A DynamicWindow
    i = self.indexOf(dw)
    self.setCurrentIndex(i)
    
    # Fix bug 844953: tell Unity which menu to use.
    c.enableMenuBar()

    # g.trace(i,c.frame.title,c.frame.menu.menuBar)
#@+node:ekr.20120223062418.10405: *4* LM.createMenu
def createMenu(self,c,fn=None):

    # Create the menu as late as possible so it can use user commands.
    lm = self

    if not g.doHook("menu1",c=c,p=c.p,v=c.p):

        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2",c=c,p=c.p,v=c.p)
        g.doHook("after-create-leo-frame",c=c)
        g.doHook("after-create-leo-frame2",c=c)

        # Fix bug 844953: tell Unity which menu to use.
        c.enableMenuBar()
#@+node:ekr.20120306130648.9849: *4* c.enableMenuBar
def enableMenuBar(self):
    
    '''A failed attempt to work around Ubuntu Unity memory bugs.'''
    
    c = self
    
    # g.trace(c.frame.title,g.callers())
    
    if 0:
        if c.frame.menu.isNull:
            return
    
        for frame in g.app.windowList:
            if frame != c.frame:
                frame.menu.menuBar.setDisabled(True)
    
        c.frame.menu.menuBar.setEnabled(True)
#@+node:ekr.20120308112021.9881: *3* Fixed bug 875327: Positioning outside of hoisted outline" usually causes problems
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/875327
Positioning outside of hoisted outline" usually causes problems

The fix was to c.selectPosition.  This has a chance of being a general solution.
#@+node:ekr.20120309075544.9884: *3* Fixed Bug: multiple @language directive not colored correctly
@language rest

Example: typing in this rest section recolors as *Python*.
The correct coloring is restored when the entire text is recolored.

In this case, a workaround, and a performance improvement, would be to put
the ``@language python`` directive before the ``language rest``.

@language python


#@+node:ekr.20090214075058.6: *4* g.findLanguageDirectives (must be fast)
g_language_pat = re.compile(r'(^@language)',re.MULTILINE)

def findLanguageDirectives(c,p):

    '''Return the language in effect at position p.'''

    trace = False and not g.unitTesting

    if c is None:
        return # c may be None for testing. 
    if c.target_language:
        language = c.target_language.lower()
    else:
        language = 'python'
    found = False
    # 2009/10/02: no need for copy arg to iter.
    for p in p.self_and_parents():
        if found: break
        for s in p.h,p.b:
            if found: break
            anIter = g_language_pat.finditer(s)
            for m in anIter:
                word = m.group(0)
                i = m.start(0)
                j = i + len(word)
                k = g.skip_line(s,j)
                language = s[j:k].strip()
                found = True

    if trace: g.trace(language)
    return language
#@+node:ekr.20110605121601.18553: *4* colorize (leoQtColorizer) & helper
def colorize(self,p,incremental=False,interruptable=True):

    '''The main colorizer entry point.'''

    trace = False and not g.unitTesting ; verbose = False

    self.count += 1 # For unit testing.
    if not incremental:
        self.full_recolor_count += 1

    if len(p.b) > self.max_chars_to_colorize > 0:
        self.flag = False
    elif self.enabled:
        oldFlag = self.flag
        self.updateSyntaxColorer(p)
            # sets self.flag and self.language and self.languageList.
        if trace and verbose:
            g.trace('old: %s, new: %s, %s' % (
                self.oldLanguageList,self.languageList,repr(p.h)))
                
        # fullRecolor is True if we can not do an incremental recolor.
        fullRecolor = (
            oldFlag != self.flag or
            self.oldV != p.v or
            self.oldLanguageList != self.languageList or
            not incremental
        )
                
        # 2012/03/09: Determine the present language from the insertion
        # point if there are more than one @language directives in effect
        # and we are about to do an incremental recolor.
        if len(self.languageList) > 0 and not fullRecolor:
            language = self.scanColorByPosition(p) # May reset self.language
            if language != self.colorer.language_name:
                if trace: g.trace('** must rescan',self.c.frame.title,language)
                fullRecolor = True
                self.language = language
           
        if fullRecolor:
            if trace: g.trace('** calling rehighlight')
            self.oldLanguageList = self.languageList[:]
            self.oldV = p.v
            self.highlighter.rehighlight(p)

    return "ok" # For unit testing.
#@+node:ekr.20120309075544.9888: *5* scanColorByPosition (leoQtColorizer)
def scanColorByPosition(self,p):

    c = self.c
    w = c.frame.body.bodyCtrl
    i = w.getInsertPoint()
    s = w.getAllText()
    
    i1,i2 = g.getLine(s,i)
    tag = '@language'
    language = self.language
    for s in g.splitLines(s[:i1]):
        if s.startswith(tag):
            language = s[len(tag):].strip()

    return language
            
#@+node:ekr.20110605121601.18556: *4* scanColorDirectives (leoQtColorizer) & helper
def scanColorDirectives(self,p):
    
    '''Set self.language based on the directives in p's tree.'''

    trace = False and not g.unitTesting
    c = self.c
    if c == None: return None # self.c may be None for testing.
    
    root = p.copy()
    self.language = None
    self.rootMode = None # None, "code" or "doc"

    for p in root.self_and_parents():
        theDict = g.get_directives_dict(p)
        # if trace: g.trace(p.h,theDict)
        << Test for @language >>
        << Test for @root, @root-doc or @root-code >>
        
    # 2011/05/28: If no language, get the language from any @<file> node.
    if self.language:
        if trace: g.trace('found @language %s %s' % (self.language,self.languageList))
        return self.language
        
    #  Attempt to get the language from the nearest enclosing @<file> node.
    self.language = g.getLanguageFromAncestorAtFileNode(root)

    if not self.language:
        if trace: g.trace('using default',c.target_language)
        self.language = c.target_language

    return self.language # For use by external routines.
#@+node:ekr.20110605121601.18557: *5* << Test for @language >>
if 'language' in theDict:
    s = theDict["language"]
    i = g.skip_ws(s,0)
    j = g.skip_c_id(s,i)
    aList = self.findLanguageDirectives(p)
    # In the root node, we use the first (valid) @language directive,
    # no matter how many @language directives the root node contains.
    # In ancestor nodes, only unambiguous @language directives
    # set self.language.
    if p == root or len(aList) == 1:
        self.languageList = aList
        self.language = aList and aList[0] or []
        break
#@+node:ekr.20110605121601.18558: *5* << Test for @root, @root-doc or @root-code >>
if 'root' in theDict and not self.rootMode:

    s = theDict["root"]
    if g.match_word(s,0,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,0,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@+node:ekr.20110605121601.18559: *5* findLanguageDirectives
def findLanguageDirectives (self,p):

    '''Scan p's body text for *valid* @language directives.

    Return a list of languages.'''
    
    # Speed not very important: called only for nodes containing @language directives.
    trace = False and not g.unitTesting
    aList = []
    for s in g.splitLines(p.b):
        if g.match_word(s,0,'@language'):
            i = len('@language')
            i = g.skip_ws(s,i)
            j = g.skip_id(s,i)
            if j > i:
                word = s[i:j]
                if self.isValidLanguage(word):
                    aList.append(word)
                else:
                    if trace:g.trace('invalid',word)

    if trace: g.trace(aList)
    return aList
#@+node:ekr.20110605121601.18560: *5* isValidLanguage
def isValidLanguage (self,language):
    
    fn = g.os_path_join(g.app.loadDir,'..','modes','%s.py' % (language))
    return g.os_path_exists(fn)
#@+node:ekr.20110605121601.18550: *4* Syntax coloring
#@+node:ekr.20110605121601.18551: *5* leoQtColorizer
# This is c.frame.body.colorizer

class leoQtColorizer:

    '''An adaptor class that interfaces Leo's core to two class:

    1. a subclass of QSyntaxHighlighter,

    2. the jEditColorizer class that contains the
       pattern-matchin code from the threading colorizer plugin.'''

    @others

#@+node:ekr.20110605121601.18552: *6*  ctor (leoQtColorizer)
def __init__ (self,c,w):

    # g.trace('(leoQtColorizer)',w)

    self.c = c
    self.w = w

    # Step 1: create the ivars.
    self.changingText = False
    self.count = 0 # For unit testing.
    self.enabled = c.config.getBool('use_syntax_coloring')
    self.error = False # Set if there is an error in jeditColorizer.recolor
    self.flag = True # Per-node enable/disable flag.
    self.full_recolor_count = 0 # For unit testing.
    self.killColorFlag = False
    self.language = 'python' # set by scanColorDirectives.
    self.languageList = [] # List of color directives in the node the determines it.
    self.max_chars_to_colorize = c.config.getInt('qt_max_colorized_chars') or 0
    self.oldLanguageList = []
    self.oldV = None
    self.showInvisibles = False # 2010/1/2

    # Step 2: create the highlighter.
    self.highlighter = leoQtSyntaxHighlighter(c,w,colorizer=self)
    self.colorer = self.highlighter.colorer
    w.leo_colorizer = self

    # Step 3: finish enabling.
    if self.enabled:
        self.enabled = hasattr(self.highlighter,'currentBlock')
#@+node:ekr.20110605121601.18553: *6* colorize (leoQtColorizer) & helper
def colorize(self,p,incremental=False,interruptable=True):

    '''The main colorizer entry point.'''

    trace = False and not g.unitTesting ; verbose = False

    self.count += 1 # For unit testing.
    if not incremental:
        self.full_recolor_count += 1

    if len(p.b) > self.max_chars_to_colorize > 0:
        self.flag = False
    elif self.enabled:
        oldFlag = self.flag
        self.updateSyntaxColorer(p)
            # sets self.flag and self.language and self.languageList.
        if trace and verbose:
            g.trace('old: %s, new: %s, %s' % (
                self.oldLanguageList,self.languageList,repr(p.h)))
                
        # fullRecolor is True if we can not do an incremental recolor.
        fullRecolor = (
            oldFlag != self.flag or
            self.oldV != p.v or
            self.oldLanguageList != self.languageList or
            not incremental
        )
                
        # 2012/03/09: Determine the present language from the insertion
        # point if there are more than one @language directives in effect
        # and we are about to do an incremental recolor.
        if len(self.languageList) > 0 and not fullRecolor:
            language = self.scanColorByPosition(p) # May reset self.language
            if language != self.colorer.language_name:
                if trace: g.trace('** must rescan',self.c.frame.title,language)
                fullRecolor = True
                self.language = language
           
        if fullRecolor:
            if trace: g.trace('** calling rehighlight')
            self.oldLanguageList = self.languageList[:]
            self.oldV = p.v
            self.highlighter.rehighlight(p)

    return "ok" # For unit testing.
#@+node:ekr.20120309075544.9888: *7* scanColorByPosition (leoQtColorizer)
def scanColorByPosition(self,p):

    c = self.c
    w = c.frame.body.bodyCtrl
    i = w.getInsertPoint()
    s = w.getAllText()
    
    i1,i2 = g.getLine(s,i)
    tag = '@language'
    language = self.language
    for s in g.splitLines(s[:i1]):
        if s.startswith(tag):
            language = s[len(tag):].strip()

    return language
            
#@+node:ekr.20110605121601.18554: *6* enable/disable
def disable (self,p):

    g.trace(g.callers(4))

    if self.enabled:
        self.flag = False
        self.enabled = False
        self.highlighter.rehighlight(p) # Do a full recolor (to black)

def enable (self,p):

    g.trace(g.callers(4))

    if not self.enabled:
        self.enabled = True
        self.flag = True
        # Do a full recolor, but only if we aren't changing nodes.
        if self.c.currentPosition() == p:
            self.highlighter.rehighlight(p)
#@+node:ekr.20110605121601.18555: *6* minor entry points
def interrupt(self):
    pass

def isSameColorState (self):
    return True # Disable some logic in leoTree.select.

def kill (self):
    pass
#@+node:ekr.20110605121601.18556: *6* scanColorDirectives (leoQtColorizer) & helper
def scanColorDirectives(self,p):
    
    '''Set self.language based on the directives in p's tree.'''

    trace = False and not g.unitTesting
    c = self.c
    if c == None: return None # self.c may be None for testing.
    
    root = p.copy()
    self.language = None
    self.rootMode = None # None, "code" or "doc"

    for p in root.self_and_parents():
        theDict = g.get_directives_dict(p)
        # if trace: g.trace(p.h,theDict)
        << Test for @language >>
        << Test for @root, @root-doc or @root-code >>
        
    # 2011/05/28: If no language, get the language from any @<file> node.
    if self.language:
        if trace: g.trace('found @language %s %s' % (self.language,self.languageList))
        return self.language
        
    #  Attempt to get the language from the nearest enclosing @<file> node.
    self.language = g.getLanguageFromAncestorAtFileNode(root)

    if not self.language:
        if trace: g.trace('using default',c.target_language)
        self.language = c.target_language

    return self.language # For use by external routines.
#@+node:ekr.20110605121601.18557: *7* << Test for @language >>
if 'language' in theDict:
    s = theDict["language"]
    i = g.skip_ws(s,0)
    j = g.skip_c_id(s,i)
    aList = self.findLanguageDirectives(p)
    # In the root node, we use the first (valid) @language directive,
    # no matter how many @language directives the root node contains.
    # In ancestor nodes, only unambiguous @language directives
    # set self.language.
    if p == root or len(aList) == 1:
        self.languageList = aList
        self.language = aList and aList[0] or []
        break
#@+node:ekr.20110605121601.18558: *7* << Test for @root, @root-doc or @root-code >>
if 'root' in theDict and not self.rootMode:

    s = theDict["root"]
    if g.match_word(s,0,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,0,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@+node:ekr.20110605121601.18559: *7* findLanguageDirectives
def findLanguageDirectives (self,p):

    '''Scan p's body text for *valid* @language directives.

    Return a list of languages.'''
    
    # Speed not very important: called only for nodes containing @language directives.
    trace = False and not g.unitTesting
    aList = []
    for s in g.splitLines(p.b):
        if g.match_word(s,0,'@language'):
            i = len('@language')
            i = g.skip_ws(s,i)
            j = g.skip_id(s,i)
            if j > i:
                word = s[i:j]
                if self.isValidLanguage(word):
                    aList.append(word)
                else:
                    if trace:g.trace('invalid',word)

    if trace: g.trace(aList)
    return aList
#@+node:ekr.20110605121601.18560: *7* isValidLanguage
def isValidLanguage (self,language):
    
    fn = g.os_path_join(g.app.loadDir,'..','modes','%s.py' % (language))
    return g.os_path_exists(fn)
#@+node:ekr.20110605121601.18561: *6* setHighlighter
# Called *only* from leoTree.setBodyTextAfterSelect

def setHighlighter (self,p):

    trace = False and not g.unitTesting
    c = self.c

    if self.enabled:
        self.flag = self.updateSyntaxColorer(p)
        if self.flag:
            # Do a full recolor, but only if we aren't changing nodes.
            if self.c.currentPosition() == p:
                self.highlighter.rehighlight(p)
        else:
            self.highlighter.rehighlight(p) # Do a full recolor (to black)
    else:
        self.highlighter.rehighlight(p) # Do a full recolor (to black)

    if trace: g.trace('enabled: %s flag: %s %s' % (
        self.enabled,self.flag,p.h),g.callers())
#@+node:ekr.20110605121601.18562: *6* updateSyntaxColorer
def updateSyntaxColorer (self,p):

    trace = False and not g.unitTesting
    p = p.copy()

    if len(p.b) > self.max_chars_to_colorize > 0:
        self.flag = False
    else:
        # self.flag is True unless an unambiguous @nocolor is seen.
        self.flag = self.useSyntaxColoring(p)
        self.scanColorDirectives(p) # Sets self.language

    if trace: g.trace(self.flag,len(p.b),self.language,p.h,g.callers(5))
    return self.flag
#@+node:ekr.20110605121601.18563: *6* useSyntaxColoring & helper
def useSyntaxColoring (self,p):

    """Return True unless p is unambiguously under the control of @nocolor."""

    trace = False and not g.unitTesting
    if not p:
        if trace: g.trace('no p',repr(p))
        return False

    p = p.copy()
    first = True ; kind = None ; val = True
    self.killColorFlag = False
    for p in p.self_and_parents():
        d = self.findColorDirectives(p)
        color,no_color = 'color' in d,'nocolor' in d
        # An @nocolor-node in the first node disabled coloring.
        if first and 'nocolor-node' in d:
            kind = '@nocolor-node'
            self.killColorFlag = True
            val = False ; break
        # A killcolor anywhere disables coloring.
        elif 'killcolor' in d:
            kind = '@killcolor %s' % p.h
            self.killColorFlag = True
            val = False ; break
        # A color anywhere in the target enables coloring.
        elif color and first:
            kind = 'color %s' % p.h
            val = True ; break
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            kind = '@nocolor %s' % p.h
            val = False ; break
        elif color and not no_color:
            kind = '@color %s' % p.h
            val = True ; break
        first = False

    if trace: g.trace(val,kind)
    return val
#@+node:ekr.20110605121601.18564: *7* findColorDirectives
color_directives_pat = re.compile(
    # Order is important: put longest matches first.
    r'(^@color|^@killcolor|^@nocolor-node|^@nocolor)'
    ,re.MULTILINE)

def findColorDirectives (self,p):

    '''Scan p for @color, @killcolor, @nocolor and @nocolor-node directives.

    Return a dict containing pointers to the start of each directive.'''

    trace = False and not g.unitTesting

    d = {}
    anIter = self.color_directives_pat.finditer(p.b)
    for m in anIter:
        # Remove leading '@' for compatibility with
        # functions in leoGlobals.py.
        word = m.group(0)[1:]
        d[word] = word

    if trace: g.trace(d)
    return d
#@+node:ekr.20110605121601.18565: *5* leoQtSyntaxHighlighter
# This is c.frame.body.colorizer.highlighter

class leoQtSyntaxHighlighter(QtGui.QSyntaxHighlighter):

    '''A subclass of QSyntaxHighlighter that overrides
    the highlightBlock and rehighlight methods.

    All actual syntax coloring is done in the jeditColorer class.'''

    @others
#@+node:ekr.20110605121601.18566: *6* ctor (leoQtSyntaxHighlighter)
def __init__ (self,c,w,colorizer):

    self.c = c
    self.w = w

    # print('leoQtSyntaxHighlighter.__init__',w)

    # Not all versions of Qt have the crucial currentBlock method.
    self.hasCurrentBlock = hasattr(self,'currentBlock')

    # Init the base class.
    QtGui.QSyntaxHighlighter.__init__(self,w)

    self.colorizer = colorizer

    self.colorer = jEditColorizer(c,
        colorizer=colorizer,
        highlighter=self,
        w=c.frame.body.bodyCtrl)
#@+node:ekr.20110605121601.18567: *6* highlightBlock
def highlightBlock (self,s):
    """ Called by QSyntaxHiglighter """

    if self.hasCurrentBlock and not self.colorizer.killColorFlag:
        if g.isPython3:
            s = str(s)
        else:
            s = unicode(s)
        self.colorer.recolor(s)

#@+node:ekr.20110605121601.18568: *6* rehighlight
def rehighlight (self,p):

    '''Override base rehighlight method'''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; tree = c.frame.tree
    self.w = c.frame.body.bodyCtrl.widget
    s = p.b
    self.colorer.init(p,s)
    n = self.colorer.recolorCount
    
    if trace: g.trace(p.h)

    # Call the base class method, but *only*
    # if the crucial 'currentBlock' method exists.
    if self.colorizer.enabled and self.hasCurrentBlock:
        # Lock out onTextChanged.
        old_selecting = c.frame.tree.selecting
        try:
            c.frame.tree.selecting = True
            QtGui.QSyntaxHighlighter.rehighlight(self)
        finally:
            c.frame.tree.selecting = old_selecting

    if trace and verbose:
        g.trace('%s %s calls to recolor' % (
            p.h,self.colorer.recolorCount-n))
#@+node:ekr.20110605121601.18569: *5* class jeditColorizer
# This is c.frame.body.colorizer.highlighter.colorer

class jEditColorizer:

    '''This class contains jEdit pattern matchers adapted
    for use with QSyntaxHighlighter.'''

    << about the line-oriented jEdit colorizer >>

    @others
#@+node:ekr.20110605121601.18570: *6* << about the line-oriented jEdit colorizer >>
@nocolor-node
@

The aha behind the line-oriented jEdit colorizer is that we can define one or
more *restarter* methods for each pattern matcher that could possibly match
across line boundaries. I say "one or more" because we need a separate restarter
method for all combinations of arguments that can be passed to the jEdit pattern
matchers. In effect, these restarters are lambda bindings for the generic
restarter methods.

In actuality, very few restarters are needed. For example, for Python, we need
restarters for continued strings, and both flavors of continued triple-quoted
strings. For python, these turn out to be three separate lambda bindings for
restart_match_span.

When a jEdit pattern matcher partially succeeds, it creates the lambda binding
for its restarter and calls setRestart to set the ending state of the present
line to an integer representing the bound restarter. setRestart calls
computeState to create a *string* representing the lambda binding of the
restarter. setRestart then calls stateNameToStateNumber to convert that string
to an integer state number that then gets passed to Qt's setCurrentBlockState.
The string is useful for debugging; Qt only uses the corresponding number.
#@+node:ekr.20110605121601.18571: *6*  Birth & init
#@+node:ekr.20110605121601.18572: *7* __init__ (jeditColorizer)
def __init__(self,c,colorizer,highlighter,w):

    # Basic data...
    self.c = c
    self.colorizer = colorizer
    self.highlighter = highlighter # a QSyntaxHighlighter
    self.p = None
    self.w = w
    assert(w == self.c.frame.body.bodyCtrl)

    # Used by recolor and helpers...
    self.actualColorDict = {} # Used only by setTag.
    self.hyperCount = 0
    self.defaultState = 'default-state:' # The name of the default state.
    self.nextState = 1 # Dont use 0.
    self.restartDict = {} # Keys are state numbers, values are restart functions.
    self.stateDict = {} # Keys are state numbers, values state names.
    self.stateNameDict = {} # Keys are state names, values are state numbers.

    # Attributes dict ivars: defaults are as shown...
    self.default = 'null'
    self.digit_re = ''
    self.escape = ''
    self.highlight_digits = True
    self.ignore_case = True
    self.no_word_sep = ''
    # Config settings...
    self.showInvisibles = c.config.getBool("show_invisibles_by_default")
    self.colorizer.showInvisibles = self.showInvisibles
    # g.trace(self.showInvisibles)
        # Also set in init().
    self.underline_undefined = c.config.getBool("underline_undefined_section_names")
    self.use_hyperlinks = c.config.getBool("use_hyperlinks")
    # Debugging...
    self.count = 0 # For unit testing.
    self.allow_mark_prev = True # The new colorizer tolerates this nonsense :-)
    self.tagCount = 0
    self.trace = False or c.config.getBool('trace_colorizer')
    self.trace_leo_matches = False
    self.trace_match_flag = False
        # True: trace all matching methods.
        # This isn't so useful now that colorRangeWithTag shows g.callers(2).
    self.verbose = False
    # Profiling...
    self.recolorCount = 0 # Total calls to recolor
    self.stateCount = 0 # Total calls to setCurrentState
    self.totalChars = 0 # The total number of characters examined by recolor.
    self.totalStates = 0
    self.maxStateNumber = 0
    self.totalKeywordsCalls = 0
    self.totalLeoKeywordsCalls = 0
    # Mode data...
    self.defaultRulesList = []
    self.importedRulesets = {}
    self.prev = None # The previous token.
    self.fonts = {} # Keys are config names.  Values are actual fonts.
    self.keywords = {} # Keys are keywords, values are 0..5.
    self.language_name = None # The name of the language for the current mode.
    self.last_language = None # The language for which configuration tags are valid.
    self.modes = {} # Keys are languages, values are modes.
    self.mode = None # The mode object for the present language.
    self.modeBunch = None # A bunch fully describing a mode.
    self.modeStack = []
    self.rulesDict = {}
    # self.defineAndExtendForthWords()
    self.word_chars = {} # Inited by init_keywords().
    self.setFontFromConfig()
    self.tags = [
    
        # To be removed...
    
            # Used only by the old colorizer.
            # 'bracketRange',
            # "comment",
            # "cwebName"
            # "keyword",
            # "latexBackground","latexKeyword","latexModeKeyword",
            # "pp",
            # "string",
            
            # Wiki styling.  These were never user options.
            # "bold","bolditalic","elide","italic",
            
            # Marked as Leo jEdit tags, but not used.
            # '@color', '@nocolor','doc_part', 'section_ref',
        
        # 8 Leo-specific tags.
        "blank",  # show_invisibles_space_color
        "docpart",
        "leokeyword",
        "link",
        "name",
        "namebrackets",
        "tab", # show_invisibles_space_color
        "url",
        
        # jEdit tags.
        'comment1','comment2','comment3','comment4',
        # default, # exists, but never generated.
        'function',
        'keyword1','keyword2','keyword3','keyword4',
        'label','literal1','literal2','literal3','literal4',
        'markup','operator',
    ]

    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
#@+node:ekr.20110605121601.18573: *8* defineLeoKeywordsDict
def defineLeoKeywordsDict(self):

    self.leoKeywordsDict = {}

    for key in g.globalDirectiveList:
        self.leoKeywordsDict [key] = 'leokeyword'
#@+node:ekr.20110605121601.18574: *8* defineDefaultColorsDict
def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {
    
        # Used in Leo rules...
    
        # tag name      :( option name,                  default color),
        'blank'         :('show_invisibles_space_color', '#E5E5E5'), # gray90
        'docpart'       :('doc_part_color',              'red'),
        'leokeyword'    :('leo_keyword_color',           'blue'),
        'link'          :('section_name_color',          'red'),
        'name'          :('undefined_section_name_color','red'),
        'namebrackets'  :('section_name_brackets_color', 'blue'),
        'tab'           :('show_invisibles_tab_color',   '#CCCCCC'), # gray80
        'url'           :('url_color',                   'purple'),
        
        # Used by the old colorizer: to be removed.
        
        # 'bracketRange'   :('bracket_range_color',     'orange'), # Forth.
        # 'comment'        :('comment_color',           'red'),
        # 'cwebName'       :('cweb_section_name_color', 'red'),
        # 'keyword'        :('keyword_color',           'blue'),
        # 'latexBackground':('latex_background_color',  'white'),
        # 'pp'             :('directive_color',         'blue'),
        # 'string'         :('string_color',            '#00aa00'), # Used by IDLE.

        # jEdit tags.
        # tag name  :( option name,     default color),
        'comment1'  :('comment1_color', 'red'),
        'comment2'  :('comment2_color', 'red'),
        'comment3'  :('comment3_color', 'red'),
        'comment4'  :('comment4_color', 'red'),
        'function'  :('function_color', 'black'),
        'keyword1'  :('keyword1_color', 'blue'),
        'keyword2'  :('keyword2_color', 'blue'),
        'keyword3'  :('keyword3_color', 'blue'),
        'keyword4'  :('keyword4_color', 'blue'),
        'keyword5'  :('keyword5_color', 'blue'),
        'label'     :('label_color',    'black'),
        'literal1'  :('literal1_color', '#00aa00'),
        'literal2'  :('literal2_color', '#00aa00'),
        'literal3'  :('literal3_color', '#00aa00'),
        'literal4'  :('literal4_color', '#00aa00'),
        'markup'    :('markup_color',   'red'),
        'null'      :('null_color',     None), #'black'),
        'operator'  :('operator_color', None), #'black'),
    }
#@+node:ekr.20110605121601.18575: *8* defineDefaultFontDict
def defineDefaultFontDict (self):

    self.default_font_dict = {
    
        # Used in Leo rules...
        
            # tag name      : option name
            'blank'         :'show_invisibles_space_font', # 2011/10/24.
            'docpart'       :'doc_part_font',
            'leokeyword'    :'leo_keyword_font',
            'link'          :'section_name_font',
            'name'          :'undefined_section_name_font',
            'namebrackets'  :'section_name_brackets_font',
            'tab'           : 'show_invisibles_tab_font', # 2011/10/24.
            'url'           : 'url_font',
        
        # Used by old colorizer.
        
            # 'bracketRange'   :'bracketRange_font', # Forth.
            # 'comment'       :'comment_font',
            # 'cwebName'      :'cweb_section_name_font',
            # 'keyword'       :'keyword_font',
            # 'latexBackground':'latex_background_font',
            # 'pp'            :'directive_font',
            # 'string'        :'string_font',
    
         # jEdit tags.
         
             # tag name     : option name
            'comment1'      :'comment1_font',
            'comment2'      :'comment2_font',
            'comment3'      :'comment3_font',
            'comment4'      :'comment4_font',
            #'default'       :'default_font',
            'function'      :'function_font',
            'keyword1'      :'keyword1_font',
            'keyword2'      :'keyword2_font',
            'keyword3'      :'keyword3_font',
            'keyword4'      :'keyword4_font',
            'keyword5'      :'keyword5_font',
            'label'         :'label_font',
            'literal1'      :'literal1_font',
            'literal2'      :'literal2_font',
            'literal3'      :'literal3_font',
            'literal4'      :'literal4_font',
            'markup'        :'markup_font',
            # 'nocolor' This tag is used, but never generates code.
            'null'          :'null_font',
            'operator'      :'operator_font',
    }
#@+node:ekr.20110605121601.18576: *7* addImportedRules
def addImportedRules (self,mode,rulesDict,rulesetName):

    '''Append any imported rules at the end of the rulesets specified in mode.importDict'''

    if self.importedRulesets.get(rulesetName):
        return
    else:
        self.importedRulesets [rulesetName] = True

    names = hasattr(mode,'importDict') and mode.importDict.get(rulesetName,[]) or []

    for name in names:
        savedBunch = self.modeBunch
        ok = self.init_mode(name)
        if ok:
            rulesDict2 = self.rulesDict
            for key in rulesDict2.keys():
                aList = self.rulesDict.get(key,[])
                aList2 = rulesDict2.get(key)
                if aList2:
                    # Don't add the standard rules again.
                    rules = [z for z in aList2 if z not in aList]
                    if rules:
                        # g.trace([z.__name__ for z in rules])
                        aList.extend(rules)
                        self.rulesDict [key] = aList
        # g.trace('***** added rules for %s from %s' % (name,rulesetName))
        self.initModeFromBunch(savedBunch)
#@+node:ekr.20110605121601.18577: *7* addLeoRules
def addLeoRules (self,theDict):

    '''Put Leo-specific rules to theList.'''

    table = (
        # Rules added at front are added in **reverse** order.
        ('@',  self.match_leo_keywords,True), # Called after all other Leo matchers.
            # Debatable: Leo keywords override langauge keywords.
        ('@',  self.match_at_color,    True),
        ('@',  self.match_at_killcolor,True),
        ('@',  self.match_at_language, True), # 2011/01/17
        ('@',  self.match_at_nocolor,  True),
        ('@',  self.match_at_nocolor_node,True),
        ('@',  self.match_doc_part,    True),
        ('f',  self.match_url_f,       True),
        ('g',  self.match_url_g,       True),
        ('h',  self.match_url_h,       True),
        ('m',  self.match_url_m,       True),
        ('n',  self.match_url_n,       True),
        ('p',  self.match_url_p,       True),
        ('t',  self.match_url_t,       True),
        ('w',  self.match_url_w,       True),
        ('<',  self.match_section_ref, True), # Called **first**.
        # Rules added at back are added in normal order.
        (' ',  self.match_blanks,      False),
        ('\t', self.match_tabs,        False),
    )

    for ch, rule, atFront, in table:

        # Replace the bound method by an unbound method.

        if g.isPython3:
            rule = rule.__func__
        else:
            rule = rule.im_func
        # g.trace(rule)

        theList = theDict.get(ch,[])
        if rule not in theList:
            if atFront:
                theList.insert(0,rule)
            else:
                theList.append(rule)
            theDict [ch] = theList

    # g.trace(g.listToString(theDict.get('@')))
#@+node:ekr.20111024091133.16702: *7* configure_hard_tab_width
def configure_hard_tab_width (self):
    
    # The stated default is 40, but apparently it must be set explicitly.
    
    trace = False and not g.unitTesting
    c,w = self.c,self.w
 
    if 0:
        # No longer used: c.config.getInt('qt-tab-width')
        hard_tab_width = abs(10*c.tab_width)
        if trace: g.trace('hard_tab_width',hard_tab_width,self.w)
    else:
        # For some reason, the size is not accurate.
        font = w.widget.currentFont()
        info = QtGui.QFontInfo(font)
        size = info.pointSizeF()
        pixels_per_point = 1.0 # 0.9
        hard_tab_width = abs(int(pixels_per_point*size*c.tab_width))
        
        if trace: g.trace(
            'family',font.family(),'point size',size,
            'tab_width',c.tab_width,
            'hard_tab_width',hard_tab_width) # ,self.w)
    
    w.widget.setTabStopWidth(hard_tab_width)
#@+node:ekr.20110605121601.18578: *7* configure_tags
def configure_tags (self):

    trace = False and not g.unitTesting
    traceColors = False
    traceFonts = False
    c = self.c ; w = self.w
    isQt = g.app.gui.guiName().startswith('qt')

    if trace: g.trace(self.colorizer.language)

    if w and hasattr(w,'start_tag_configure'):
        w.start_tag_configure()

    # Get the default body font.
    defaultBodyfont = self.fonts.get('default_body_font')
    if not defaultBodyfont:
        defaultBodyfont = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize)
        self.fonts['default_body_font'] = defaultBodyfont

    # Configure fonts.
    if trace and traceFonts: g.trace('*'*10,'configuring fonts')
    keys = list(self.default_font_dict.keys()) ; keys.sort()
    for key in keys:
        option_name = self.default_font_dict[key]
        # First, look for the language-specific setting, then the general setting.
        for name in ('%s_%s' % (self.colorizer.language,option_name),(option_name)):
            if trace and traceFonts: g.trace(name)
            font = self.fonts.get(name)
            if font:
                if trace and traceFonts:
                    g.trace('**found',name,id(font))
                w.tag_configure(key,font=font)
                break
            else:
                family = c.config.get(name + '_family','family')
                size   = c.config.get(name + '_size',  'size')   
                slant  = c.config.get(name + '_slant', 'slant')
                weight = c.config.get(name + '_weight','weight')
                if family or slant or weight or size:
                    family = family or g.app.config.defaultFontFamily
                    size   = size or c.config.defaultBodyFontSize
                    slant  = slant or 'roman'
                    weight = weight or 'normal'
                    font = g.app.gui.getFontFromParams(family,size,slant,weight)
                    # Save a reference to the font so it 'sticks'.
                    self.fonts[key] = font
                    if trace and traceFonts:
                        g.trace('**found',key,name,family,size,slant,weight,id(font))
                    w.tag_configure(key,font=font)
                    break

        else: # Neither the general setting nor the language-specific setting exists.
            if list(self.fonts.keys()): # Restore the default font.
                if trace and traceFonts:
                    g.trace('default',key,font)
                self.fonts[key] = font # 2010/02/19: Essential
                w.tag_configure(key,font=defaultBodyfont)
            else:
                if trace and traceFonts:
                    g.trace('no fonts')
                    
        if isQt and key == 'url' and font:
            font.setUnderline(True) # 2011/03/04

    if trace and traceColors: g.trace('*'*10,'configuring colors')
    keys = list(self.default_colors_dict.keys()) ; keys.sort()
    for name in keys:
        # if name == 'operator': g.pdb()
        option_name,default_color = self.default_colors_dict[name]
        color = (
            c.config.getColor('%s_%s' % (self.colorizer.language,option_name)) or
            c.config.getColor(option_name) or
            default_color
        )
        if trace and traceColors: g.trace(option_name,color)

        # Must use foreground, not fg.
        try:
            w.tag_configure(name, foreground=color)
        except: # Recover after a user error.
            g.es_exception()
            w.tag_configure(name, foreground=default_color)

    # underline=var doesn't seem to work.
    if 0: # self.use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
        w.tag_configure("link",underline=1) # defined
        w.tag_configure("name",underline=0) # undefined
    else:
        w.tag_configure("link",underline=0)
        if self.underline_undefined:
            w.tag_configure("name",underline=1)
        else:
            w.tag_configure("name",underline=0)

    self.configure_variable_tags()

    try:
        w.end_tag_configure()
    except AttributeError:
        pass
#@+node:ekr.20110605121601.18579: *7* configure_variable_tags
def configure_variable_tags (self):

    c = self.c ; w = self.w

    # g.trace()

    for name,option_name,default_color in (
        ("blank","show_invisibles_space_background_color","Gray90"),
        ("tab",  "show_invisibles_tab_background_color",  "Gray80"),
        ("elide", None,                                   "yellow"),
    ):
        if self.showInvisibles:
            color = option_name and c.config.getColor(option_name) or default_color
        else:
            option_name,default_color = self.default_colors_dict.get(name,(None,None),)
            color = option_name and c.config.getColor(option_name) or ''
        try:
            w.tag_configure(name,background=color)
        except: # A user error.
            w.tag_configure(name,background=default_color)

    # Special case:
    if not self.showInvisibles:
        w.tag_configure("elide",elide="1")
#@+node:ekr.20110605121601.18580: *7* init (jeditColorizer)
def init (self,p,s):

    trace = False and not g.unitTesting

    if p: self.p = p.copy()
    self.all_s = s or ''

    if trace: g.trace('='*20,
        'tabwidth',self.c.tab_width,
        self.colorizer.language) #,g.callers(4))

    # State info.
    self.all_s = s
    self.global_i,self.global_j = 0,0
    self.global_offset = 0

    # These *must* be recomputed.
    self.nextState = 1 # Dont use 0.
    self.stateDict = {}
    self.stateNameDict = {}
    self.restartDict = {}
    self.init_mode(self.colorizer.language)
    self.clearState()
    self.showInvisibles = self.colorizer.showInvisibles
        # The show/hide-invisible commands changes this.

    # Used by matchers.
    self.prev = None
    if self.last_language != self.colorizer.language:
        # Must be done to support per-language @font/@color settings.
        self.configure_tags()
        self.last_language = self.colorizer.language
        
    self.configure_hard_tab_width() # 2011/10/04
#@+node:ekr.20110605121601.18581: *7* init_mode & helpers
def init_mode (self,name):

    '''Name may be a language name or a delegate name.'''

    trace = False and not g.unitTesting
    if not name: return False
    h = self.highlighter
    language,rulesetName = self.nameToRulesetName(name)
    bunch = self.modes.get(rulesetName)
    if bunch:
        if bunch.language == 'unknown-language':
            if trace: g.trace('found unknown language')
            return False
        else:
            if trace: g.trace('found',language,rulesetName)
            self.initModeFromBunch(bunch)
            self.language_name = language # 2011/05/30
            return True
    else:
        if trace: g.trace(language,rulesetName)
        path = g.os_path_join(g.app.loadDir,'..','modes')
        # Bug fix: 2008/2/10: Don't try to import a non-existent language.
        fileName = g.os_path_join(path,'%s.py' % (language))
        if g.os_path_exists(fileName):
            mode = g.importFromPath (language,path)
        else: mode = None

        if mode:
            # A hack to give modes/forth.py access to c.
            if hasattr(mode,'pre_init_mode'):
                mode.pre_init_mode(self.c)
        else:
            # Create a dummy bunch to limit recursion.
            self.modes [rulesetName] = self.modeBunch = g.Bunch(
                attributesDict  = {},
                defaultColor    = None,
                keywordsDict    = {},
                language        = 'unknown-language',
                mode            = mode,
                properties      = {},
                rulesDict       = {},
                rulesetName     = rulesetName,
                word_chars      = self.word_chars, # 2011/05/21
            )
            if trace: g.trace('***** No colorizer file: %s.py' % language)
            self.rulesetName = rulesetName
            self.language_name = 'unknown-language'
            return False
        self.colorizer.language = language
        self.rulesetName = rulesetName
        self.properties = hasattr(mode,'properties') and mode.properties or {}
        self.keywordsDict = hasattr(mode,'keywordsDictDict') and mode.keywordsDictDict.get(rulesetName,{}) or {}
        self.setKeywords()
        self.attributesDict = hasattr(mode,'attributesDictDict') and mode.attributesDictDict.get(rulesetName) or {}
        # if trace: g.trace(rulesetName,self.attributesDict)
        self.setModeAttributes()
        self.rulesDict = hasattr(mode,'rulesDictDict') and mode.rulesDictDict.get(rulesetName) or {}
        # if trace: g.trace(self.rulesDict)
        self.addLeoRules(self.rulesDict)
        self.defaultColor = 'null'
        self.mode = mode
        self.modes [rulesetName] = self.modeBunch = g.Bunch(
            attributesDict  = self.attributesDict,
            defaultColor    = self.defaultColor,
            keywordsDict    = self.keywordsDict,
            language        = self.colorizer.language,
            mode            = self.mode,
            properties      = self.properties,
            rulesDict       = self.rulesDict,
            rulesetName     = self.rulesetName,
            word_chars      = self.word_chars, # 2011/05/21
        )
        # Do this after 'officially' initing the mode, to limit recursion.
        self.addImportedRules(mode,self.rulesDict,rulesetName)
        self.updateDelimsTables()
        initialDelegate = self.properties.get('initialModeDelegate')
        if initialDelegate:
            if trace: g.trace('initialDelegate',initialDelegate)
            # Replace the original mode by the delegate mode.
            self.init_mode(initialDelegate)
            language2,rulesetName2 = self.nameToRulesetName(initialDelegate)
            self.modes[rulesetName] = self.modes.get(rulesetName2)
            self.language_name = language2  # 2011/05/30
        else:
            self.language_name = language  # 2011/05/30
        return True
#@+node:ekr.20110605121601.18582: *8* nameToRulesetName
def nameToRulesetName (self,name):

    '''Compute language and rulesetName from name, which is either a language or a delegate name.'''

    if not name: return ''

    i = name.find('::')
    if i == -1:
        language = name
        rulesetName = '%s_main' % (language)
    else:
        language = name[:i]
        delegate = name[i+2:]
        rulesetName = self.munge('%s_%s' % (language,delegate))

    # if rulesetName == 'php_main': rulesetName = 'php_php'

    # g.trace(name,language,rulesetName)
    return language,rulesetName
#@+node:ekr.20110605121601.18583: *8* setKeywords
def setKeywords (self):

    '''Initialize the keywords for the present language.

     Set self.word_chars ivar to string.letters + string.digits
     plus any other character appearing in any keyword.'''

    # Add any new user keywords to leoKeywordsDict.
    d = self.keywordsDict
    keys = list(d.keys())
    for s in g.globalDirectiveList:
        key = '@' + s
        if key not in keys:
            d [key] = 'leokeyword'

    # Create a temporary chars list.  It will be converted to a dict later.
    chars = [g.toUnicode(ch) for ch in (string.ascii_letters + string.digits)]

    for key in list(d.keys()):
        for ch in key:
            if ch not in chars:
                chars.append(g.toUnicode(ch))

    # jEdit2Py now does this check, so this isn't really needed.
    # But it is needed for forth.py.
    for ch in (' ', '\t'):
        if ch in chars:
            # g.es_print('removing %s from word_chars' % (repr(ch)))
            chars.remove(ch)

    # g.trace(self.colorizer.language,[str(z) for z in chars])

    # Convert chars to a dict for faster access.
    self.word_chars = {}
    for z in chars:
        self.word_chars[z] = z
#@+node:ekr.20110605121601.18584: *8* setModeAttributes
def setModeAttributes (self):

    '''Set the ivars from self.attributesDict,
    converting 'true'/'false' to True and False.'''

    d = self.attributesDict
    aList = (
        ('default',         'null'),
	    ('digit_re',        ''),
        ('escape',          ''), # New in Leo 4.4.2.
	    ('highlight_digits',True),
	    ('ignore_case',     True),
	    ('no_word_sep',     ''),
    )

    # g.trace(d)

    for key, default in aList:
        val = d.get(key,default)
        if val in ('true','True'): val = True
        if val in ('false','False'): val = False
        setattr(self,key,val)
        # g.trace(key,val)
#@+node:ekr.20110605121601.18585: *8* initModeFromBunch
def initModeFromBunch (self,bunch):

    self.modeBunch = bunch
    self.attributesDict = bunch.attributesDict
    self.setModeAttributes()
    self.defaultColor   = bunch.defaultColor
    self.keywordsDict   = bunch.keywordsDict
    self.colorizer.language = bunch.language
    self.mode           = bunch.mode
    self.properties     = bunch.properties
    self.rulesDict      = bunch.rulesDict
    self.rulesetName    = bunch.rulesetName
    self.word_chars     = bunch.word_chars # 2011/05/21
#@+node:ekr.20110605121601.18586: *8* updateDelimsTables
def updateDelimsTables (self):

    '''Update g.app.language_delims_dict if no entry for the language exists.'''

    d = self.properties
    lineComment = d.get('lineComment')
    startComment = d.get('commentStart')
    endComment = d.get('commentEnd')

    if lineComment and startComment and endComment:
        delims = '%s %s %s' % (lineComment,startComment,endComment)
    elif startComment and endComment:
        delims = '%s %s' % (startComment,endComment)
    elif lineComment:
        delims = '%s' % lineComment
    else:
        delims = None

    if delims:
        d = g.app.language_delims_dict
        if not d.get(self.colorizer.language):
            d [self.colorizer.language] = delims
            # g.trace(self.colorizer.language,'delims:',repr(delims))
#@+node:ekr.20110605121601.18587: *7* munge
def munge(self,s):

    '''Munge a mode name so that it is a valid python id.'''

    valid = string.ascii_letters + string.digits + '_'

    return ''.join([g.choose(ch in valid,ch.lower(),'_') for ch in s])
#@+node:ekr.20110605121601.18588: *7* setFontFromConfig
def setFontFromConfig (self):

    c = self.c

    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.color_tags_list = []
#@+node:ekr.20110605121601.18589: *6*  Pattern matchers
#@+node:ekr.20110605121601.18590: *7*  About the pattern matchers
@nocolor-node
@

The following jEdit matcher methods return the length of the matched text if the
match succeeds, and zero otherwise. In most cases, these methods colorize all
the matched text.

The following arguments affect matching:

- at_line_start         True: sequence must start the line.
- at_whitespace_end     True: sequence must be first non-whitespace text of the line.
- at_word_start         True: sequence must start a word.
- hash_char             The first character that must match in a regular expression.
- no_escape:            True: ignore an 'end' string if it is preceded by
                        the ruleset's escape character.
- no_line_break         True: the match will not succeed across line breaks.
- no_word_break:        True: the match will not cross word breaks.

The following arguments affect coloring when a match succeeds:

- delegate              A ruleset name. The matched text will be colored recursively
                        by the indicated ruleset.
- exclude_match         If True, the actual text that matched will not be colored.
- kind                  The color tag to be applied to colored text.
#@+node:ekr.20110605121601.18591: *7* dump
def dump (self,s):

    if s.find('\n') == -1:
        return s
    else:
        return '\n' + s + '\n'
#@+node:ekr.20110605121601.18592: *7* Leo rule functions
#@+node:ekr.20110605121601.18593: *8* match_at_color
def match_at_color (self,s,i):

    if self.trace_leo_matches: g.trace()

    seq = '@color'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        self.colorizer.flag = True # Enable coloring.
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,'leokeyword')
        self.clearState()
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18594: *8* match_at_language
def match_at_language (self,s,i):

    trace = (False or self.trace_leo_matches) and not g.unitTesting
    if trace: g.trace(i,repr(s))

    seq = '@language'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        j = i + len(seq)
        j = g.skip_ws(s,j)
        k = g.skip_c_id(s,j)
        name = s[j:k]
        ok = self.init_mode(name)
        if trace: g.trace(ok,name,self.language_name)
        if ok:
            self.colorRangeWithTag(s,i,k,'leokeyword')
        self.clearState()
        return k - i
    else:
        return 0
#@+node:ekr.20110605121601.18595: *8* match_at_nocolor & restarter
def match_at_nocolor (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    # Only matches at start of line.
    if i == 0 and not g.match(s,i,'@nocolor-') and g.match_word(s,i,'@nocolor'):
        self.setRestart(self.restartNoColor)
        return len(s) # Match everything.
    else:
        return 0
#@+node:ekr.20110605121601.18596: *9* restartNoColor
def restartNoColor (self,s):

    if self.trace_leo_matches: g.trace(repr(s))

    if g.match_word(s,0,'@color'):
        self.clearState()
    else:
        self.setRestart(self.restartNoColor)

    return len(s) # Always match everything.
#@+node:ekr.20110605121601.18597: *8* match_at_killcolor & restarter
def match_at_killcolor (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@killcolor'

    if g.match_word(s,i,tag):
        self.setRestart(self.restartKillColor)
        return len(s) # Match everything.
    else:
        return 0

#@+node:ekr.20110605121601.18598: *9* restartKillColor
def restartKillColor(self,s):

    self.setRestart(self.restartKillColor)
    return len(s)+1
#@+node:ekr.20110605121601.18599: *8* match_at_nocolor_node & restarter
def match_at_nocolor_node (self,s,i):

    if self.trace_leo_matches: g.trace()

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@nocolor-node'

    if g.match_word(s,i,tag):
        self.setRestart(self.restartNoColorNode)
        return len(s) # Match everything.
    else:
        return 0
#@+node:ekr.20110605121601.18600: *9* restartNoColorNode
def restartNoColorNode(self,s):

    self.setRestart(self.restartNoColorNode)
    return len(s)+1
#@+node:ekr.20110605121601.18601: *8* match_blanks
def match_blanks (self,s,i):

    if not self.showInvisibles:
        return 0

    j = i ; n = len(s)

    while j < n and s[j] == ' ':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'blank')
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18602: *8* match_doc_part & restarter
def match_doc_part (self,s,i):

    # New in Leo 4.5: only matches at start of line.
    if i != 0:
        return 0
    elif g.match_word(s,i,'@doc'):
        j = i + 4
    elif g.match(s,i,'@') and (i+1 >= len(s) or s[i+1] in (' ','\t','\n')):
        j = i + 1
    else:
        return 0

    self.colorRangeWithTag(s,i,j,'leokeyword')
    self.colorRangeWithTag(s,j,len(s),'docpart')
    self.setRestart(self.restartDocPart)

    return len(s)
#@+node:ekr.20110605121601.18603: *9* restartDocPart
def restartDocPart (self,s):

    for tag in ('@c','@code'):
        if g.match_word(s,0,tag):
            j = len(tag)
            self.colorRangeWithTag(s,0,j,'leokeyword') # 'docpart')
            self.clearState()
            return j
    else:
        self.setRestart(self.restartDocPart)
        self.colorRangeWithTag(s,0,len(s),'docpart')

        return len(s)
#@+node:ekr.20110605121601.18604: *8* match_leo_keywords
def match_leo_keywords(self,s,i):

    '''Succeed if s[i:] is a Leo keyword.'''

    # g.trace(i,g.get_line(s,i))

    self.totalLeoKeywordsCalls += 1

    if s[i] != '@':
        return 0

    # fail if something besides whitespace precedes the word on the line.
    i2 = i-1
    while i2 >= 0:
        ch = s[i2]
        if ch == '\n':
            break
        elif ch in (' ','\t'):
            i2 -= 1
        else:
            # g.trace('not a word 1',repr(ch))
            return 0

    # Get the word as quickly as possible.
    j = i+1
    while j < len(s) and s[j] in self.word_chars:
        j += 1
    word = s[i+1:j] # entries in leoKeywordsDict do not start with '@'.

    if j < len(s) and s[j] not in (' ','\t','\n'):
        # g.trace('not a word 2',repr(word))
        return 0 # Fail, but allow a rescan, as in objective_c.

    if self.leoKeywordsDict.get(word):
        kind = 'leokeyword'
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j-i+1 # Bug fix: skip the last character.
        self.trace_match(kind,s,i,j)
        # g.trace('*** match',repr(s))
        return result
    else:
        # 2010/10/20: also check the keywords dict here.
        # This allows for objective_c keywords starting with '@'
        # This will not slow down Leo, because it is called
        # for things that look like Leo directives.
        word = '@' + word
        kind = self.keywordsDict.get(word)
        if kind:
            self.colorRangeWithTag(s,i,j,kind)
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            # g.trace('found',word)
            return j-i
        else:
            # g.trace('fail',repr(word),repr(self.word_chars))
            return -(j-i+1) # An important optimization.
#@+node:ekr.20110605121601.18605: *8* match_section_ref
def match_section_ref (self,s,i):

    if self.trace_leo_matches: g.trace()
    c = self.c ; p = c.currentPosition()
    w = self.w

    if not g.match(s,i,'<<'):
        return 0
    k = g.find_on_line(s,i+2,'>>')
    if k is not None:
        j = k + 2
        self.colorRangeWithTag(s,i,i+2,'namebrackets')
        ref = g.findReference(c,s[i:j],p)
        if ref:
            if self.use_hyperlinks:
                << set the hyperlink >>
            else:
                self.colorRangeWithTag(s,i+2,k,'link')
        else:
            self.colorRangeWithTag(s,i+2,k,'name')
        self.colorRangeWithTag(s,k,j,'namebrackets')
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18606: *9* << set the hyperlink >>
# Set the bindings to vnode callbacks.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
ref.tagName = tagName
#@+node:ekr.20110605121601.18607: *8* match_tabs
def match_tabs (self,s,i):

    if not self.showInvisibles:
        return 0

    if self.trace_leo_matches: g.trace()

    j = i ; n = len(s)

    while j < n and s[j] == '\t':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'tab')
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18608: *8* match_url_any/f/h  (new)
# Fix bug 893230: URL coloring does not work for many Internet protocols.
# Added support for: gopher, mailto, news, nntp, prospero, telnet, wais
url_regex_f = re.compile(  r"""(file|ftp)://[^\s'"]+[\w=/]""")
url_regex_g = re.compile(      r"""gopher://[^\s'"]+[\w=/]""")
url_regex_h = re.compile(r"""(http|https)://[^\s'"]+[\w=/]""")
url_regex_m = re.compile(      r"""mailto://[^\s'"]+[\w=/]""")
url_regex_n = re.compile( r"""(news|nntp)://[^\s'"]+[\w=/]""")
url_regex_p = re.compile(    r"""prospero://[^\s'"]+[\w=/]""")
url_regex_t = re.compile(      r"""telnet://[^\s'"]+[\w=/]""")
url_regex_w = re.compile(        r"""wais://[^\s'"]+[\w=/]""")

kinds = '(file|ftp|gopher|http|https|mailto|news|nntp|prospero|telnet|wais)'
# url_regex   = re.compile(r"""(file|ftp|http|https)://[^\s'"]+[\w=/]""")
url_regex   = re.compile(r"""%s://[^\s'"]+[\w=/]""" % (kinds))

def match_any_url(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex)

def match_url_f(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_f)
    
def match_url_g(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_g)

def match_url_h(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_h)
    
def match_url_m(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_m)
    
def match_url_n(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_n)
    
def match_url_p(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_p)
    
def match_url_t(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_t)

def match_url_w(self,s,i):
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_w)
#@+node:ekr.20110605121601.18609: *7* match_compiled_regexp (new)
def match_compiled_regexp (self,s,i,kind,regexp,delegate=''):

    '''Succeed if the compiled regular expression regexp matches at s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

    # if at_line_start and i != 0 and s[i-1] != '\n': return 0
    # if at_whitespace_end and i != g.skip_ws(s,0): return 0
    # if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0

    n = self.match_compiled_regexp_helper(s,i,regexp)
    if n > 0:
        j = i + n
        assert (j-i == n)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18610: *8* match_compiled_regexp_helper
def match_compiled_regexp_helper (self,s,i,regex):
    
    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = regex.match(s,i) # re_obj.search(s,i) 

    if mo is None:
        return 0
    start, end = mo.start(), mo.end()
    if start != i:
        return 0
    # if trace:
        # g.trace('pattern',pattern)
        # g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
        # g.trace('groups',mo.groups())
    return end - start
#@+node:ekr.20110605121601.18611: *7* match_eol_span
def match_eol_span (self,s,i,
    kind=None,seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if seq matches s[i:]'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        return 0

    if g.match(s,i,seq):
        j = len(s)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j # (was j-1) With a delegate, this could clear state.
    else:
        return 0
#@+node:ekr.20110605121601.18612: *7* match_eol_span_regexp
def match_eol_span_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if the regular expression regex matches s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,regexp)
    if n > 0:
        j = len(s)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    else:
        return 0
#@+node:ekr.20110605121601.18613: *7* match_everything
# def match_everything (self,s,i,kind=None,delegate='',exclude_match=False):

    # '''Match the entire rest of the string.'''

    # j = len(s)
    # self.colorRangeWithTag(s,i,j,kind,delegate=delegate)

    # return j
#@+node:ekr.20110605121601.18614: *7* match_keywords
# This is a time-critical method.
def match_keywords (self,s,i):

    '''Succeed if s[i:] is a keyword.'''

    # trace = False
    self.totalKeywordsCalls += 1

    # Important.  Return -len(word) for failure greatly reduces
    # the number of times this method is called.

    # We must be at the start of a word.
    if i > 0 and s[i-1] in self.word_chars:
        # if trace: g.trace('not at word start',s[i-1])
        return 0

    # Get the word as quickly as possible.
    j = i ; n = len(s) ; chars = self.word_chars
    while j < n and s[j] in chars:
        j += 1

    word = s[i:j]
    if self.ignore_case: word = word.lower()
    kind = self.keywordsDict.get(word)
    if kind:
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j - i
        # if trace: g.trace('success',word,kind,j-i)
        self.trace_match(kind,s,i,j)
        return result
    else:
        # if trace: g.trace('fail',word,kind)
        return -len(word) # An important new optimization.
#@+node:ekr.20110605121601.18615: *7* match_line
def match_line (self,s,i,kind=None,delegate='',exclude_match=False):

    '''Match the rest of the line.'''

    j = g.skip_to_end_of_line(s,i)

    self.colorRangeWithTag(s,i,j,kind,delegate=delegate)

    return j-i
#@+node:ekr.20110605121601.18616: *7* match_mark_following & getNextToken
def match_mark_following (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    trace = (True or self.verbose) and not g.unitTesting
    if not self.allow_mark_prev: return 0

    # if trace: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(pattern) + 1 < len(s) and s[i+len(pattern)] in self.word_chars:
        return 0 # 7/5/2008

    if g.match(s,i,pattern):
        j = i + len(pattern)
        # self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
        k = self.getNextToken(s,j)
        # 2011/05/31: Do not match *anything* unless there is a token following.
        if k > j:
            self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
            self.colorRangeWithTag(s,j,k,kind,exclude_match=False)
            j = k
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            return j - i
        else:
            return 0
    else:
        return 0
#@+node:ekr.20110605121601.18617: *8* getNextToken
def getNextToken (self,s,i):

    '''Return the index of the end of the next token for match_mark_following.

    The jEdit docs are not clear about what a 'token' is, but experiments with jEdit
    show that token means a word, as defined by word_chars.'''
    
    # 2011/05/31: Might we extend the concept of token?
    # If s[i] is not a word char, should we return just it?

    while i < len(s) and s[i] in self.word_chars:
        i += 1

    # 2011/05/31: was i+1
    return min(len(s),i)
#@+node:ekr.20110605121601.18618: *7* match_mark_previous
def match_mark_previous (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Return the length of a matched SEQ or 0 if no match.

    'at_line_start':    True: sequence must start the line.
    'at_whitespace_end':True: sequence must be first non-whitespace text of the line.
    'at_word_start':    True: sequence must start a word.'''

    # This match was causing most of the syntax-color problems.
    return 0 # 2009/6/23
#@+node:ekr.20110605121601.18619: *7* match_regexp_helper
def match_regexp_helper (self,s,i,pattern):

    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

    trace = False and not g.unitTesting
    if trace: g.trace('%-10s %-20s %s' % (
        self.colorizer.language,pattern,s)) # g.callers(1)

    try:
        flags = re.MULTILINE
        if self.ignore_case: flags|= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        # Do not call g.es here!
        g.trace('Invalid regular expression: %s' % (pattern))
        return 0

    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = re_obj.match(s,i) # re_obj.search(s,i) 

    if mo is None:
        return 0
    else:
        start, end = mo.start(), mo.end()
        if start != i: # Bug fix 2007-12-18: no match at i
            return 0
        if trace:
            g.trace('pattern',pattern)
            g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
            g.trace('groups',mo.groups())
        return end - start
#@+node:ekr.20110605121601.18620: *7* match_seq
def match_seq (self,s,i,
    kind='',seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if s[:] mathces seq.'''

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars:  # 7/5/2008
        j = i
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        j = i # 7/5/2008
    elif g.match(s,i,seq):
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
    else:
        j = i
    return j - i
#@+node:ekr.20110605121601.18621: *7* match_seq_regexp
def match_seq_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if the regular expression regexp matches at s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0

    n = self.match_regexp_helper(s,i,regexp)
    j = i + n
    assert (j-i == n)
    self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
    self.prev = (i,j,kind)
    self.trace_match(kind,s,i,j)
    return j - i
#@+node:ekr.20110605121601.18622: *7* match_span & helper & restarter
def match_span (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False,no_word_break=False):

    '''Succeed if s[i:] starts with 'begin' and contains a following 'end'.'''

    trace = False and not g.unitTesting
    if i >= len(s): return 0

    # g.trace(begin,end,no_escape,no_line_break,no_word_break)

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars:
        j = i
    elif at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        j = i
    elif not g.match(s,i,begin):
        j = i
    else:
        # We have matched the start of the span.
        j = self.match_span_helper(s,i+len(begin),end,
            no_escape,no_line_break,no_word_break=no_word_break)
        # g.trace('** helper returns',j,len(s))
        if j == -1:
            j = i # A real failure.
        else:
            # A match
            i2 = i + len(begin) ; j2 = j + len(end)
            if delegate:
                self.colorRangeWithTag(s,i,i2,kind,delegate=None,    exclude_match=exclude_match)
                self.colorRangeWithTag(s,i2,j,kind,delegate=delegate,exclude_match=exclude_match)
                self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
            else:
                self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
            j = j2
            self.prev = (i,j,kind)

    self.trace_match(kind,s,i,j)

    if j > len(s):
        j = len(s) + 1
        def boundRestartMatchSpan(s):
            # Note: bindings are frozen by this def.
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate,end,exclude_match,kind,
                no_escape,no_line_break,no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keywords args.
            delegate=delegate,end=end,
            exclude_match=exclude_match,
            kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)

        if trace: g.trace('***Continuing',kind,i,j,len(s))
    elif j != i:
        if trace: g.trace('***Ending',kind,i,j,s[i:j])
        self.clearState()

    return j - i # Correct, whatever j is.
#@+node:ekr.20110605121601.18623: *8* match_span_helper
def match_span_helper (self,s,i,pattern,no_escape,no_line_break,no_word_break):

    '''Return n >= 0 if s[i] ends with a non-escaped 'end' string.'''

    esc = self.escape

    while 1:
        j = s.find(pattern,i)
        # g.trace(no_line_break,j,len(s))
        if j == -1:
            # Match to end of text if not found and no_line_break is False
            if no_line_break:
                return -1
            else:
                return len(s)+1
        elif no_word_break and j > 0 and s[j-1] in self.word_chars:
            return -1 # New in Leo 4.5.
        elif no_line_break and '\n' in s[i:j]:
            return -1
        elif esc and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == esc:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # Continue searching past the escaped pattern string.
                i = j + len(pattern) # Bug fix: 7/25/07.
                # g.trace('escapes',escapes,repr(s[i:]))
            else:
                return j
        else:
            return j
#@+node:ekr.20110605121601.18624: *8* restart_match_span
def restart_match_span (self,s,
    delegate,end,exclude_match,kind,
    no_escape,no_line_break,no_word_break):

    '''Remain in this state until 'end' is seen.'''

    trace = False and not g.unitTesting

    i = 0
    j = self.match_span_helper(s,i,end,no_escape,no_line_break,no_word_break)
    if j == -1:
        j2 = len(s)+1
    elif j > len(s):
        j2 = j
    else:
        j2 = j + len(end)

    if delegate:
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
    else: # avoid having to merge ranges in addTagsToList.
        self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
    j = j2

    self.trace_match(kind,s,i,j)

    if j > len(s):
        def boundRestartMatchSpan(s):
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate,end,exclude_match,kind,
                no_escape,no_line_break,no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keywords args.
            delegate=delegate,end=end,kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)

        if trace: g.trace('***Re-continuing',i,j,len(s),s,g.callers(5))
    else:
        if trace: g.trace('***ending',i,j,len(s),s)
        self.clearState()

    return j # Return the new i, *not* the length of the match.
#@+node:ekr.20110605121601.18625: *7* match_span_regexp
def match_span_regexp (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False, no_word_break=False,
):

    '''Succeed if s[i:] starts with 'begin' (a regular expression) and contains a following 'end'.'''

    if self.verbose: g.trace('begin',repr(begin),'end',repr(end),self.dump(s[i:]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,begin)
    # We may have to allow $n here, in which case we must use a regex object?
    if n > 0:
        j = i + n
        j2 = s.find(end,j)
        if j2 == -1: return 0
        if self.escape and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == self.escape:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # An escaped end **aborts the entire match**:
                # there is no way to 'restart' the regex.
                return 0
        i2 = j2 - len(end)
        if delegate:
            self.colorRangeWithTag(s,i,j,kind, delegate=None,     exclude_match=exclude_match)
            self.colorRangeWithTag(s,j,i2,kind, delegate=delegate,exclude_match=False)
            self.colorRangeWithTag(s,i2,j2,kind,delegate=None,    exclude_match=exclude_match)
        else: # avoid having to merge ranges in addTagsToList.
            self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j2)
        return j2 - i
    else: return 0
#@+node:ekr.20110605121601.18626: *7* match_word_and_regexp
def match_word_and_regexp (self,s,i,
    kind1='',word='',
    kind2='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    if not self.allow_mark_prev: return 0

    if (False or self.verbose): g.trace(i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0
    if at_word_start and i + len(word) + 1 < len(s) and s[i+len(word)] in self.word_chars:
        j = i

    if not g.match(s,i,word):
        return 0

    j = i + len(word)
    n = self.match_regexp_helper(s,j,pattern)
    if n == 0:
        return 0
    self.colorRangeWithTag(s,i,j,kind1,exclude_match=exclude_match)
    k = j + n
    self.colorRangeWithTag(s,j,k,kind2,exclude_match=False)    
    self.prev = (j,k,kind2)
    self.trace_match(kind1,s,i,j)
    self.trace_match(kind2,s,j,k)
    return k - i
#@+node:ekr.20110605121601.18627: *7* skip_line
def skip_line (self,s,i):

    if self.escape:
        escape = self.escape + '\n'
        n = len(escape)
        while i < len(s):
            j = g.skip_line(s,i)
            if not g.match(s,j-n,escape):
                return j
            # g.trace('escape',s[i:j])
            i = j
        return i
    else:
        return g.skip_line(s,i)
            # Include the newline so we don't get a flash at the end of the line.
#@+node:ekr.20110605121601.18628: *7* trace_match
def trace_match(self,kind,s,i,j):

    if j != i and self.trace_match_flag:
        g.trace(kind,i,j,g.callers(2),self.dump(s[i:j]))
#@+node:ekr.20110605121601.18629: *6*  State methods
#@+node:ekr.20110605121601.18630: *7* clearState
def clearState (self):

    self.setState(-1)
#@+node:ekr.20110605121601.18631: *7* computeState
def computeState (self,f,keys):

    '''Compute the state name associated with f and all the keys.

    Return a unique int n representing that state.'''

    # Abbreviate arg names.
    d = {
        'delegate':'del:',
        'end':'end',
        'at_line_start':'line-start',
        'at_whitespace_end':'ws-end',
        'exclude_match':'exc-match',
        'no_escape':'no-esc',
        'no_line_break':'no-brk',
        'no_word_break':'no-word-brk',
    }
    result = [
        f.__name__,
        self.colorizer.language,
        self.rulesetName]
    for key in keys:
        keyVal = keys.get(key)
        val = d.get(key)
        if val is None:
            val = keys.get(key)
            result.append('%s=%s' % (key,val))
        elif keyVal is True:
            result.append('%s' % val)
        elif keyVal is False:
            pass
        elif keyVal not in (None,''):
            result.append('%s=%s' % (key,keyVal))
    state = ';'.join(result)

    n = self.stateNameToStateNumber(f,state)
    return n
#@+node:ekr.20110605121601.18632: *7* currentState and prevState
def currentState(self):

    return self.highlighter.currentBlockState()

def prevState(self):

    return self.highlighter.previousBlockState()
#@+node:ekr.20110605121601.18633: *7* setRestart
def setRestart (self,f,**keys):

    n = self.computeState(f,keys)
    self.setState(n)
#@+node:ekr.20110605121601.18634: *7* setState
def setState (self,n):

    trace = False and not g.unitTesting

    self.highlighter.setCurrentBlockState(n)

    if trace:
        stateName = self.showState(n)
        g.trace(stateName,g.callers(4))
#@+node:ekr.20110605121601.18635: *7* showState & showCurrentState
def showState (self,n):

    if n == -1: 
        return 'default-state'
    else:
        return self.stateDict.get(n,'<no state>')

def showCurrentState(self):

    n = self.currentState()
    return self.showState(n)

def showPrevState(self):

    n = self.prevState()
    return self.showState(n)
#@+node:ekr.20110605121601.18636: *7* stateNameToStateNumber
def stateNameToStateNumber (self,f,stateName):

    # stateDict:     Keys are state numbers, values state names.
    # stateNameDict: Keys are state names, values are state numbers.
    # restartDict:   Keys are state numbers, values are restart functions

    n = self.stateNameDict.get(stateName)
    if n is None:
        n = self.nextState
        self.stateNameDict[stateName] = n
        self.stateDict[n] = stateName
        self.restartDict[n] = f
        self.nextState += 1
        # g.trace('========',n,stateName)

    return n
#@+node:ekr.20110605121601.18637: *6* colorRangeWithTag
def colorRangeWithTag (self,s,i,j,tag,delegate='',exclude_match=False):

    '''Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.'''

    trace = False and not g.unitTesting
        # A superb trace: enable this first to see what gets colored.

    # Pattern matcher may set the .flag ivar.
    if self.colorizer.killColorFlag or not self.colorizer.flag:
        if trace: g.trace('disabled')
        return

    if delegate:
        if trace:
            s2 = g.choose(len(repr(s[i:j])) <= 20,repr(s[i:j]),repr(s[i:i+17-2]+'...'))
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (delegate,tag)),i,j,s2,g.callers(2)))
        # self.setTag(tag,s,i,j) # 2011/05/31: Do the initial color.
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        while 0 <= i < j and i < len(s):
            progress = i
            assert j >= 0,j
            for f in self.rulesDict.get(s[i],[]):
                n = f(self,s,i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n > 0:
                    # if trace: g.trace('delegate',delegate,i,n,f.__name__,repr(s[i:i+n]))
                    i += n ; break
            else:
                # New in Leo 4.6: Use the default chars for everything else.
                # New in Leo 4.8 devel: use the *delegate's* default characters if possible.
                default_tag = self.attributesDict.get('default')
                # g.trace(default_tag)
                self.setTag(default_tag or tag,s,i,i+1)
                i += 1
            assert i > progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        if trace:
            s2 = g.choose(len(repr(s[i:j])) <= 20,repr(s[i:j]),repr(s[i:i+17-2]+'...'))
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (self.language_name,tag)),i,j,s2,g.callers(2)))
        self.setTag(tag,s,i,j)
        
    if tag != 'url':
        # Allow URL's *everywhere*.
        j = min(j,len(s))
        while i < j:
            if s[i].lower() in 'fh': # file|ftp|http|https
                n = self.match_any_url(s,i)
                i += max(1,n)
            else:
                i += 1
#@+node:ekr.20110605121601.18638: *6* mainLoop & restart
def mainLoop(self,n,s):

    '''Colorize a *single* line s, starting in state n.'''

    trace = False and not g.unitTesting
    traceMatch = True
    traceState = True
    verbose = False
    
    if trace:
        g.trace(self.language_name)
        if traceState:
            g.trace('%-30s' % ('** start: %s' % self.showState(n)),repr(s))
        else:
            g.trace(self.language_name,repr(s))
                # Called from recolor.

    i = 0
    if n > -1:
        i = self.restart(n,s,trace and traceMatch)
    if i == 0:
        self.setState(self.prevState())
        
    if False and trace:
        aList = self.rulesDict.get('<')
        for f in aList:
            g.trace(f.__name__)
        
        
    while i < len(s):
        progress = i
        functions = self.rulesDict.get(s[i],[])
        for f in functions:
            n = f(self,s,i)
            if n is None:
                g.trace('Can not happen: n is None',repr(f))
                break
            elif n > 0: # Success.
                if trace and traceMatch and f.__name__!='match_blanks':
                    g.trace('%-30s' % ('   match: %s' % (f.__name__,)),
                        repr(s[i:i+n]))
                # The match has already been colored.
                i += n
                break # Stop searching the functions.
            elif n < 0: # Fail and skip n chars.
                if trace and traceMatch and verbose:
                    g.trace('fail: %-30s %s' % (
                        f.__name__,repr(s[i:i+n])))
                i += -n
                break # Stop searching the functions.
            else: # Fail. Try the next function.
                pass # Do not break or change i!
        else:
            i += 1
        assert i > progress

    # Don't even *think* about clearing state here.
    # We remain in the starting state unless a match happens.
    if trace and traceState:
        g.trace('%-30s' % ('** end:   %s' % self.showCurrentState()),repr(s))
#@+node:ekr.20110605121601.18639: *7* restart
def restart (self,n,s,traceMatch):

    f = self.restartDict.get(n)
    if f:
        i = f(s)
        fname = f.__name__
        if traceMatch:
            if i > 0:
                g.trace('** restart match',fname,s[:i])
            else:
                g.trace('** restart fail',fname,s)
    else:
        g.trace('**** no restart f')
        i = 0

    return i
#@+node:ekr.20110605121601.18640: *6* recolor
def recolor (self,s):

    '''Recolor a *single* line, s.'''

    trace = False and not g.unitTesting
    callers = False ; line = True ; state = True

    # Update the counts.
    self.recolorCount += 1
    self.totalChars += len(s)

    if self.colorizer.changingText:
        return
    if not self.colorizer.flag:
        return

    # Get the previous state.
    n = self.prevState() # The state at the end of the previous line.
    if trace:
        if line and state:
            g.trace('%2s %s %s' % (n,self.showState(n),repr(s)))
        elif line:
            g.trace('%2s %s' % (n,repr(s)))
        if callers:
            # Called from colorize:rehightlight,highlightBlock
            g.trace(g.callers())

    if s.strip() or self.showInvisibles:
        self.mainLoop(n,s)
    else:
        self.setState(n) # Required
#@+node:ekr.20110605121601.18641: *6* setTag
def setTag (self,tag,s,i,j):

    trace = False and not g.unitTesting

    if i == j:
        if trace: g.trace('empty range')
        return

    w = self.w # A leoQTextEditWidget
    tag = tag.lower() # 2011/10/28
    colorName = w.configDict.get(tag)

    # Munge the color name.
    if not colorName:
        if trace: g.trace('no color for %s' % tag)
        return

    if colorName[-1].isdigit() and colorName[0] != '#':
        colorName = colorName[:-1]

    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name',colorName,g.callers())

    underline = w.configUnderlineDict.get(tag)

    format = QtGui.QTextCharFormat()

    font = self.fonts.get(tag)
    if font:
        format.setFont(font)

    if trace:
        self.tagCount += 1
        g.trace(
            '%3s %3s %3s %9s %7s' % (i,j,len(s),font and id(font) or '<no font>',colorName),
            '%-10s %-25s' % (tag,s[i:j]),g.callers(2))

    if tag in ('blank','tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setFontUnderline(True)
    else:
        format.setForeground(color)

    self.highlighter.setFormat (i,j-i,format)

#@+node:ekr.20110605121601.18594: *4* match_at_language
def match_at_language (self,s,i):

    trace = (False or self.trace_leo_matches) and not g.unitTesting
    if trace: g.trace(i,repr(s))

    seq = '@language'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        j = i + len(seq)
        j = g.skip_ws(s,j)
        k = g.skip_c_id(s,j)
        name = s[j:k]
        ok = self.init_mode(name)
        if trace: g.trace(ok,name,self.language_name)
        if ok:
            self.colorRangeWithTag(s,i,k,'leokeyword')
        self.clearState()
        return k - i
    else:
        return 0
#@+node:ekr.20110605121601.18638: *4* mainLoop & restart
def mainLoop(self,n,s):

    '''Colorize a *single* line s, starting in state n.'''

    trace = False and not g.unitTesting
    traceMatch = True
    traceState = True
    verbose = False
    
    if trace:
        g.trace(self.language_name)
        if traceState:
            g.trace('%-30s' % ('** start: %s' % self.showState(n)),repr(s))
        else:
            g.trace(self.language_name,repr(s))
                # Called from recolor.

    i = 0
    if n > -1:
        i = self.restart(n,s,trace and traceMatch)
    if i == 0:
        self.setState(self.prevState())
        
    if False and trace:
        aList = self.rulesDict.get('<')
        for f in aList:
            g.trace(f.__name__)
        
        
    while i < len(s):
        progress = i
        functions = self.rulesDict.get(s[i],[])
        for f in functions:
            n = f(self,s,i)
            if n is None:
                g.trace('Can not happen: n is None',repr(f))
                break
            elif n > 0: # Success.
                if trace and traceMatch and f.__name__!='match_blanks':
                    g.trace('%-30s' % ('   match: %s' % (f.__name__,)),
                        repr(s[i:i+n]))
                # The match has already been colored.
                i += n
                break # Stop searching the functions.
            elif n < 0: # Fail and skip n chars.
                if trace and traceMatch and verbose:
                    g.trace('fail: %-30s %s' % (
                        f.__name__,repr(s[i:i+n])))
                i += -n
                break # Stop searching the functions.
            else: # Fail. Try the next function.
                pass # Do not break or change i!
        else:
            i += 1
        assert i > progress

    # Don't even *think* about clearing state here.
    # We remain in the starting state unless a match happens.
    if trace and traceState:
        g.trace('%-30s' % ('** end:   %s' % self.showCurrentState()),repr(s))
#@+node:ekr.20110605121601.18639: *5* restart
def restart (self,n,s,traceMatch):

    f = self.restartDict.get(n)
    if f:
        i = f(s)
        fname = f.__name__
        if traceMatch:
            if i > 0:
                g.trace('** restart match',fname,s[:i])
            else:
                g.trace('** restart fail',fname,s)
    else:
        g.trace('**** no restart f')
        i = 0

    return i
#@+node:ekr.20120309075544.9887: *3* Fixed Bug: multiple @language directives mess up add-comments command
@nocolor-node

- Added scanToCursor argument to c.scanAllDirectives in c.insert/removedComments.

- Added scanToCursor argument to get_directives_dict_list in c.scanAllDirectives.

- get_directives_dict_list sets scanToCursor only for the initial (root) node.

- g.get_directives_dict scans to cursor for @language directives is scanToCursor is True.
#@+node:ekr.20050312114529: *4* c.insert/removeComments
#@+node:ekr.20050312114529.1: *5* addComments
def addComments (self,event=None):
    
    << addComments docstring >>

    c = self ; p = c.p
    d = c.scanAllDirectives(p,scanToCursor=True)
    d1,d2,d3 = d.get('delims') # d1 is the line delim.
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines:
        g.es('no text selected',color='blue')
        return

    d2 = d2 or '' ; d3 = d3 or ''
    if d1: openDelim,closeDelim = d1+' ',''
    else:  openDelim,closeDelim = d2+' ',' '+d3

    # Comment out non-blank lines.
    indent = c.config.getBool('indent_added_comments',default=True)
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line,0)
            if indent:
                result.append(line[0:i]+openDelim+line[i:].replace('\n','')+closeDelim+'\n')
            else:
                result.append(openDelim+line.replace('\n','')+closeDelim+'\n')
        else:
            result.append(line)

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Add Comments',oldSel=None,oldYview=oldYview)
#@+node:ekr.20111115111842.9789: *6* << addComments docstring >>
@pagewidth 50

'''
Converts all selected lines to comment lines using
the comment delimiters given by the applicable
 @language directive.

Inserts single-line comments if possible; inserts
block comments for languages like html that lack
single-line comments.

 @bool indent_added_comments

If True (the default), inserts opening comment
delimiters just before the first non-whitespace
character of each line. Otherwise, inserts opening
comment delimiters at the start of each line.

*See also*: delete-comments.
'''
#@+node:ekr.20050312114529.2: *5* deleteComments
def deleteComments (self,event=None):
    
    << deleteComments docstring >>

    c = self ; p = c.p
    d = c.scanAllDirectives(p,scanToCursor=True)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('no text selected',color='blue')
        return

    if d1:
        # Remove the single-line comment delim in front of each line
        d1b = d1 + ' '
        n1,n1b = len(d1),len(d1b)
        for s in lines:
            i = g.skip_ws(s,0)
            if g.match(s,i,d1b):
                result.append(s[:i] + s[i+n1b:])
            elif g.match(s,i,d1):
                result.append(s[:i] + s[i+n1:])
            else:
                result.append(s)
    else:
        # Remove the block comment delimiters from each line.
        n2,n3 = len(d2),len(d3)
        for s in lines:
            i = g.skip_ws(s,0)
            j = s.find(d3,i+n2)
            if g.match(s,i,d2) and j > -1:
                first = i + n2
                if g.match(s,first,' '): first += 1
                last = j
                if g.match(s,last-1,' '): last -= 1
                result.append(s[:i] + s[first:last] + s[j+n3:])
            else:
                result.append(s)

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Delete Comments',oldSel=None,oldYview=oldYview)
#@+node:ekr.20111115111842.9790: *6* << deleteComments docstring >>
@pagewidth 50

'''
Removes one level of comment delimiters from all
selected lines.  The applicable @language directive
determines the comment delimiters to be removed.

Removes single-line comments if possible; removes
block comments for languages like html that lack
single-line comments.

*See also*: add-comments.
'''
#@+node:ekr.20080827175609.39: *4* c.scanAllDirectives
def scanAllDirectives(self,p=None,scanToCursor=False):

    '''Scan p and ancestors for directives.

    Returns a dict containing the results, including defaults.'''

    trace = False and not g.unitTesting
    c = self ; p = p or c.p

    # Set defaults
    language = c.target_language and c.target_language.lower()
    lang_dict = {
        'language':language,
        'delims':g.set_delims_from_language(language),
    }
    wrap = c.config.getBool("body_pane_wraps")
    
    table = (
        ('encoding',    None,           g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
        ('wrap',        wrap,           g.scanAtWrapDirectives),
    )
    
    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p,scanToCursor=scanToCursor)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process: do *not* set commander ivars.
    lang_dict = d.get('lang-dict')

    d = {
        "delims"        : lang_dict.get('delims'),
        "encoding"      : d.get('encoding'),
        "language"      : lang_dict.get('language'),
        "lineending"    : d.get('lineending'),
        "pagewidth"     : d.get('pagewidth'),
        "path"          : d.get('path'), # Redundant: or g.getBaseDirectory(c),
        "tabwidth"      : d.get('tabwidth'),
        "pluginsList"   : [], # No longer used.
        "wrap"          : d.get('wrap'),
    }

    if trace: g.trace(lang_dict.get('language'),g.callers())
    
    # g.trace(d.get('tabwidth'))

    return d
#@+node:ekr.20080827175609.1: *4* g.get_directives_dict_list (must be fast)
def get_directives_dict_list(p,scanToCursor=False):

    """Scans p and all its ancestors for directives.

    Returns a list of dicts containing pointers to
    the start of each directive"""

    trace = False and not g.unitTesting

    # if trace: time1 = g.getTime()

    result = []
    p1 = p.copy()

    for p in p1.self_and_parents():
        if p.hasParent(): root = None
        else:             root = [p.copy()]
        result.append(g.get_directives_dict(p,
            root=root,
            scanToCursor=scanToCursor and p == p1))

    # if trace:
        # n = len(p1.h) + len(p1.b)
        # g.trace('%4d %s' % (n,g.timeSince(time1)))

    return result
#@+node:ekr.20090214075058.9: *4* g.get_directives_dict (must be fast)
# The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].

g_noweb_root = re.compile('<'+'<'+'*'+'>'+'>'+'=',re.MULTILINE)

def get_directives_dict(p,root=None,scanToCursor=False):

    """Scan p for @directives found in globalDirectiveList.

    Returns a dict containing the stripped remainder of the line
    following the first occurrence of each recognized directive"""

    trace = False and not g.unitTesting
    verbose = False
    if trace: g.trace('*'*20,p.h)

    if root: root_node = root[0]
    d = {}

    # Do this every time so plugins can add directives.
    pat = g.compute_directives_re()
    directives_pat = re.compile(pat,re.MULTILINE)

    # The headline has higher precedence because it is more visible.
    for kind,s in (('head',p.h),('body',p.b)):
        anIter = directives_pat.finditer(s)
        for m in anIter:
            word = m.group(0)[1:] # Omit the @
            i = m.start(0)
            if (
                # 2012/03/9: Special case @language directive in the body.
                (kind == 'body' and scanToCursor and word.strip() == 'language')
                or word.strip() not in d
            ):
                j = i + 1 + len(word)
                k = g.skip_line(s,j)
                val = s[j:k].strip()
                if j < len(s) and s[j] not in (' ','\t','\n'):
                    # g.es_print('invalid character after directive',s[max(0,i-1):k-1],color='red')
                    # if trace:g.trace(word,repr(val),s[i:i+20])
                    pass # Not a valid directive: just ignore it.
                else:
                    directive_word = word.strip()
                    if directive_word == 'language':
                        if kind == 'body' and scanToCursor:
                            # 2012/03/09:Only add preceding @language directives.
                            c = p.v.context
                            w = c.frame.body.bodyCtrl
                            ins = w.getInsertPoint()
                            i1,i2 = g.getLine(s,i)
                            if trace: g.trace(kind,directive_word,val)
                            if ins >= i2:
                                d[directive_word] = val
                        else:
                            d[directive_word] = val
                    else:
                        if directive_word in ('root-doc', 'root-code'):
                            d['root'] = val # in addition to optioned version
                        d[directive_word] = val
                        
                    # g.trace(kind,directive_word,val)

                    if trace: g.trace(word.strip(),kind,repr(val))
                    # A special case for @path in the body text of @<file> nodes.
                    # Don't give an actual warning: just set some flags.
                    if kind == 'body' and word.strip() == 'path' and p.isAnyAtFileNode():
                        g.app.atPathInBodyWarning = p.h
                        d['@path_in_body'] = p.h
                        if trace: g.trace('@path in body',p.h)

    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"]=0 # value not immportant
            else:
                g.es('%s= may only occur in a topmost node (i.e., without a parent)' % (
                    g.angleBrackets('*')))
            break

    if trace and verbose: g.trace('%4d' % (len(p.h) + len(p.b)),g.callers(5))
    return d
#@+node:ekr.20090214075058.10: *5* compute_directives_re
def compute_directives_re ():

    '''Return an re pattern which will match all Leo directives.'''

    global globalDirectiveList

    aList = ['^@%s' % z for z in globalDirectiveList
                if z != 'others']

    if 0: # 2010/02/01
        # The code never uses this, and this regex is broken
        # because it can confuse g.get_directives_dict.
        # @others can have leading whitespace.
        aList.append(r'^\s@others\s')

    return '|'.join(aList)
#@+node:ekr.20120311070142.9896: *3* Fixed second bug re bug #875327: Positioning outside of hoisted outline usually causes problems
@nocolor-node

Make sure all Outline:Go To... commands work with hoists

Test procedure:
Open outline headline-body-mismatch.leo (which is attached here).
Select the node with headline 0101-01-H.
Click on Outline --- Hoist.
Alt-x, goto-first-node.

A bug had occurred. There is now a mismatch between the selected node shown in the outline pane and the body shown in the body pane.
The body pane shows "01-01-B". This is the body of the first node in the outline.
The body pane should show "0101-01-B".

There are additional problems now:
1) Outline --- De-Hoist is grayed out. There is no way to de-hoist.
2) Ctrl-h does not work. It just causes the following message on the console:
error *** no item for <pos 162306060 childIndex: 0 lvl: 0 key: 172612012:0 0101-01-H> load,runMainLoop,eventFilter,masterKeyHandler,masterCommand,doCommand,editHeadline,editLabel
--- end error message ---
 Headline "0101-01-H" can be opened for editing by double-left-clicking it.
#@+node:ekr.20120311070142.9897: *4* Commands...
#@+node:ekr.20031218072017.2894: *5* Outline menu...
#@+node:ekr.20031218072017.2895: *6*  Top Level... (Commands)
#@+node:ekr.20031218072017.1548: *7* c.Cut & Paste Outlines
#@+node:ekr.20031218072017.1549: *8* c.cutOutline
def cutOutline (self,event=None):

    '''Delete the selected outline and send it to the clipboard.'''

    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline("Cut Node")
        c.recolor()
#@+node:ekr.20031218072017.1550: *8* c.copyOutline
def copyOutline (self,event=None):

    '''Copy the selected outline to the clipboard.'''

    # Copying an outline has no undo consequences.
    c = self
    c.endEditing()
    s = c.fileCommands.putLeoOutline()
    g.app.gui.replaceClipboardWith(s)
#@+node:ekr.20031218072017.1551: *8* c.pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    '''Paste an outline into the present outline from the clipboard.
    Nodes do *not* retain their original identify.'''

    trace = False and not g.unitTesting
    c = self
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
        
    vnodeInfoDict = c.computeVnodeInfoDict() if pasteAsClone else {}
    
    # create a *position* to be pasted.
    if isLeo:
        pasted = c.fileCommands.getLeoOutlineFromClipboard(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,c.p)

    if not pasted: return None
    
    if pasteAsClone:
        copiedBunchList = c.computeCopiedBunchList(pasted,vnodeInfoDict)
    else:
        copiedBunchList = []

    undoData = c.undoer.beforeInsertNode(c.p,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)

    c.validateOutline()
    
    
    c.selectPosition(pasted)
    pasted.setDirty()
    c.setChanged(True)

    if 1:
        # This makes no sense: getLeoOutlineFromClipboard already does this.
        # ***But**, we can't change anything significant until we demonstrate the problem!
    
        # paste as first child if back is expanded.
        back = pasted.back()
        #### back = c.p.back()
    
        if back and back.hasChildren() and back.isExpanded():
            # 2011/06/21: fixed hanger: test back.hasChildren().
            pasted.moveToNthChildOf(back,0)
        # c.setRootPosition()

    if pasteAsClone:
        # Set dirty bits for ancestors of *all* pasted nodes.
        # Note: the setDescendentsDirty flag does not do what we want.
        for p in pasted.self_and_subtree():
            p.setAllAncestorAtFileNodesDirty(
                setDescendentsDirty=False)

    c.undoer.afterInsertNode(pasted,undoType,undoData)
    c.redraw(pasted)
    c.recolor()
    
    return pasted # For unit testing.
#@+node:ekr.20050418084539: *9* c.computeVnodeInfoDict
@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of nodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

def computeVnodeInfoDict (self):
    
    c,d = self,{}
    for v in c.all_unique_nodes():
        if v not in d:
            d[v] = g.Bunch(v=v,head=v.h,body=v.b)

    return d
#@+node:ekr.20050418084539.2: *9* c.computeCopiedBunchList
def computeCopiedBunchList(self,pasted,vnodeInfoDict):

    # Create a dict containing only copied vnodes.
    d = {}
    for p in pasted.self_and_subtree():
        d[p.v] = p.v
    
    # g.trace(sorted(list(d.keys())))
    
    aList = []
    for v in vnodeInfoDict:
        if d.get(v):
            bunch = vnodeInfoDict.get(v)
            aList.append(bunch)
    
    return aList
#@+node:EKR.20040610130943: *8* pasteOutlineRetainingClones
def pasteOutlineRetainingClones (self,event=None):

    '''Paste an outline into the present outline from the clipboard.
    Nodes *retain* their original identify.'''

    c = self

    return c.pasteOutline(reassignIndices=False)
#@+node:ekr.20031218072017.2028: *7* c.hoist/dehoist/clearAllHoists
#@+node:ekr.20120308061112.9865: *8* c.deHoist
def dehoist (self,event=None):

    '''Undo a previous hoist of an outline.'''

    c = self
    p = c.p

    if p and c.canDehoist():
        bunch = c.hoistStack.pop()
        if bunch.expanded: p.expand()
        else:              p.contract()
        c.redraw()

        c.frame.clearStatusLine()
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + bunch.p.h)
        else:
            c.frame.putStatusLine("No hoist")
        c.undoer.afterDehoist(p,'DeHoist')
        g.doHook('hoist-changed',c=c)

#@+node:ekr.20120308061112.9866: *8* c.clearAllHoists
def clearAllHoists(self):
    
    '''Undo a previous hoist of an outline.'''

    c = self

    c.hoistStack = []
    c.frame.putStatusLine("Hoists cleared")
    
    g.doHook('hoist-changed',c=c)
#@+node:ekr.20120308061112.9867: *8* c.hoist
def hoist (self,event=None):

    '''Make only the selected outline visible.'''

    c = self
    p = c.p
    
    if p and c.canHoist():
        # Remember the expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        p.expand()
        c.redraw(p)

        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.h)
        c.undoer.afterHoist(p,'Hoist')
        g.doHook('hoist-changed',c=c)
#@+node:ekr.20031218072017.1759: *7* Insert, Delete & Clone (Commands)
#@+node:ekr.20031218072017.1760: *8* c.checkMoveWithParentWithWarning & c.checkDrag
#@+node:ekr.20070910105044: *9* c.checkMoveWithParentWithWarning
def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""
    
    c = self

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedVnodes = {}
    for ancestor in parent.self_and_parents():
        if ancestor.isCloned():
            v = ancestor.v
            clonedVnodes[v] = v

    if not clonedVnodes:
        return True

    for p in root.self_and_subtree():
        if p.isCloned() and clonedVnodes.get(p.v):
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            elif warningFlag:
                c.alert(message)
            return False
    return True
#@+node:ekr.20070910105044.1: *9* c.checkDrag
def checkDrag (self,root,target):

    """Return False if target is any descendant of root."""

    c = self
    message = "Can not drag a node into its descendant tree."

    for z in root.subtree():
        if z == target:
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            else:
                c.alert(message)
            return False
    return True
#@+node:ekr.20031218072017.1193: *8* c.deleteOutline
def deleteOutline (self,event=None,op_name="Delete Node"):

    """Deletes the selected outline."""

    c = self ; cc = c.chapterController ; u = c.undoer
    p = c.p
    if not p: return

    c.endEditing() # Make sure we capture the headline for Undo.

    if p.hasVisBack(c): newNode = p.visBack(c)
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    if cc: # Special cases for @chapter and @chapters nodes.
        chapter = '@chapter ' ; chapters = '@chapters ' 
        h = p.h
        if h.startswith(chapters):
            if p.hasChildren():
                return cc.note('Can not delete @chapters node with children.')
        elif h.startswith(chapter):
            name = h[len(chapter):].strip()
            if name:
                # Bug fix: 2009/3/23: Make sure the chapter exists!
                # This might be an @chapter node outside of @chapters tree.
                theChapter = cc.chaptersDict.get(name)
                if theChapter:
                    return cc.removeChapterByName(name)

    undoData = u.beforeDeleteNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.doDelete(newNode)
    c.setChanged(True)
    u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    c.redraw(newNode)

    c.validateOutline()
#@+node:ekr.20031218072017.1761: *8* c.insertHeadline
def insertHeadline (self,event=None,op_name="Insert Node",as_child=False):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.p

    if not current: return

    c.endEditing()

    undoData = c.undoer.beforeInsertNode(current)
    # Make sure the new node is visible when hoisting.
    if (as_child or
        (current.hasChildren() and current.isExpanded()) or
        (c.hoistStack and current == c.hoistStack[-1].p)
    ):
        if c.config.getBool('insert_new_nodes_at_end'):
            p = current.insertAsLastChild()
        else:
            p = current.insertAsNthChild(0)
    else:
        p = current.insertAfter()
    p.setDirty(setDescendentsDirty=False)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    c.setChanged(True)
    u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    c.redrawAndEdit(p,selectAll=True)

    return p
#@+node:ekr.20071005173203.1: *8* c.insertChild
def insertChild (self,event=None):

    '''Insert a node after the presently selected node.'''

    c = self

    return c.insertHeadline(event=event,op_name='Insert Child',as_child=True)
#@+node:ekr.20031218072017.1762: *8* c.clone
def clone (self,event=None):

    '''Create a clone of the selected outline.'''

    c = self ; u = c.undoer ; p = c.p
    if not p: return

    undoData = c.undoer.beforeCloneNode(p)
    c.endEditing() # Capture any changes to the headline.
    clone = p.clone()
    dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
    c.setChanged(True)
    if c.validateOutline():
        u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
        c.redraw(clone)
        return clone # For mod_labels and chapters plugins.
    else:
        clone.doDelete()
        c.setCurrentPosition(p)
        return None
#@+node:ekr.20031218072017.1765: *8* c.validateOutline
# Makes sure all nodes are valid.

def validateOutline (self,event=None):

    c = self

    if not g.app.debug:
        return True

    root = c.rootPosition()
    parent = c.nullPosition()

    if root:
        return root.validateOutlineWithParent(parent)
    else:
        return True
#@+node:ekr.20080425060424.1: *7* Sort...
#@+node:ekr.20080503055349.1: *8* c.setPositionAfterSort
def setPositionAfterSort (self,sortChildren):

    c = self
    p = c.p
    p_v = p.v
    parent = p.parent()
    parent_v = p._parentVnode()

    if sortChildren:
        p = parent or c.rootPosition()
    else:
        if parent:
            p = parent.firstChild()
        else:
            p = leoNodes.position(parent_v.children[0])
        while p and p.v != p_v:
            p.moveToNext()
        p = p or parent

    return p
#@+node:ekr.20050415134809: *8* c.sortChildren
# New in Leo 4.7 final: this method no longer supports
# the 'cmp' keyword arg.

def sortChildren (self,event=None,key=None):

    '''Sort the children of a node.'''

    c = self ; p = c.p

    if p and p.hasChildren():
        c.sortSiblings(p=p.firstChild(),sortChildren=True,key=key)
#@+node:ekr.20050415134809.1: *8* c.sortSiblings
# New in Leo 4.7 final: this method no longer supports
# the 'cmp' keyword arg.

def sortSiblings (self, event=None, key= None, p=None, sortChildren=False,
                  reverse=False):

    '''Sort the siblings of a node.'''

    c = self ; u = c.undoer
    if p is None: p = c.p
    if not p: return

    c.endEditing()

    undoType = g.choose(sortChildren,'Sort Children','Sort Siblings')
    parent_v = p._parentVnode()
    parent = p.parent()
    oldChildren = parent_v.children[:]
    newChildren = parent_v.children[:]

    if key == None:
        def lowerKey (self):
            return (self.h.lower())
        key = lowerKey

    newChildren.sort(key=key, reverse=reverse)

    if oldChildren == newChildren:
        return

    # 2010/01/20. Fix bug 510148.
    c.setChanged(True)

    # g.trace(g.listToString(newChildren))

    bunch = u.beforeSort(p,undoType,oldChildren,newChildren,sortChildren)
    parent_v.children = newChildren
    if parent:
        dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
    else:
        dirtyVnodeList = []
    u.afterSort(p,bunch,dirtyVnodeList)

    # Sorting destroys position p, and possibly the root position.
    p = c.setPositionAfterSort(sortChildren)
    c.redraw(p)
#@+node:ekr.20040711135959.2: *6* Check Outline submenu...
#@+node:ekr.20031218072017.2072: *7* c.checkOutline
def checkOutline (self,event=None,verbose=True,unittest=False,full=True,root=None):

    """Report any possible clone errors in the outline.

    Remove any tnodeLists."""

    trace = False and not g.unitTesting
    c = self ; count = 1 ; errors = 0

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    if root: iter = root.self_and_subtree
    else:    iter = c.all_positions

    for p in iter():
        if trace: g.trace(p.h)
        try:
            count += 1
            << remove tnodeList >>
            if full: # Unit tests usually set this false.
                << do full tests >>
        except AssertionError:
            errors += 1
            << give test failed message >>
            if trace: return errors 
    if verbose or not unittest:
        << print summary message >>
    return errors
#@+node:ekr.20040313150633: *8* << remove tnodeList >>
# Empty tnodeLists are not errors.
v = p.v

if hasattr(v,"tnodeList"): # and len(v.tnodeList) > 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        g.es_print(s,color="blue")
    delattr(v,"tnodeList")
    v._p_changed = True
#@+node:ekr.20040323155951: *8* << do full tests >>
if not unittest:
    if count % 1000 == 0:
        g.es('','.',newline=False)
    if count % 8000 == 0:
        g.enl()

@others
#@+node:ekr.20040314035615: *9* assert consistency of threadNext & threadBack links
threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p!=p.threadBack().threadNext()"

if threadNext:
    assert p == threadNext.threadBack(), "p!=p.threadNext().threadBack()"
#@+node:ekr.20040314035615.1: *9* assert consistency of next and back links
back = p.back()
next = p.next()

if back:
    assert p == back.next(), 'p!=p.back().next(),  back: %s\nback.next: %s' % (
        back,back.next())

if next:
    assert p == next.back(), 'p!=p.next().back, next: %s\nnext.back: %s' % (
        next,next.back())
#@+node:ekr.20040314035615.2: *9* assert consistency of parent and child links
if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p!=parent.moveToNthChild"

for child in p.children():
    assert p == child.parent(), "p!=child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent!=parent"

if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent!=parent"
#@+node:ekr.20080426051658.1: *9* assert consistency of parent and children arrays
@
Every nodes gets visited, so we only check consistency
between p and its parent, not between p and its children.

In other words, this is a strong test.
@c

parent_v = p._parentVnode()
n = p.childIndex()

assert parent_v.children[n] == p.v,'fail 1'
#@+node:ekr.20040314044652: *8* << give test failed message >>
junk, value, junk = sys.exc_info()

s = "test failed at position %s\n%s" % (repr(p),value)

g.es_print(s,color="red")
#@+node:ekr.20040314043900: *8* <<print summary message >>
if full:
    g.enl()

if errors or verbose:
    color = g.choose(errors,'red','blue')
    g.es_print('',count,'nodes checked',errors,'errors',color=color)
#@+node:ekr.20040723094220: *7* Check Outline commands & allies
# This code is no longer used by any Leo command,
# but it will be retained for use of scripts.
#@+node:ekr.20040723094220.1: *8* c.checkAllPythonCode
def checkAllPythonCode(self,event=None,unittest=False,ignoreAtIgnore=True):

    '''Check all nodes in the selected tree for syntax and tab errors.'''

    c = self ; count = 0 ; result = "ok"

    for p in c.all_unique_positions():
        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not g.scanForAtSettings(p) and (
                not ignoreAtIgnore or not g.scanForAtIgnore(c,p)
            ):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except Exception:
                    return "surprise" # abort
                if unittest and result != "ok":
                    g.pr("Syntax error in %s" % p.cleanHeadString())
                    return result # End the unit test: it has failed.

    if not unittest:
        g.es("check complete",color="blue")

    return result
#@+node:ekr.20040723094220.2: *9* << print dots >>
if count % 100 == 0:
    g.es('','.',newline=False)

if count % 2000 == 0:
    g.enl()
#@+node:ekr.20040723094220.3: *8* c.checkPythonCode
def checkPythonCode (self,event=None,
    unittest=False,ignoreAtIgnore=True,
    suppressErrors=False,checkOnSave=False):

    '''Check the selected tree for syntax and tab errors.'''

    c = self ; count = 0 ; result = "ok"

    if not unittest:
        g.es("checking Python code   ")

    for p in c.p.self_and_subtree():

        count += 1
        if not unittest and not checkOnSave:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest,suppressErrors)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except Exception:
                    return "surprise" # abort

    if not unittest:
        g.es("check complete",color="blue")

    # We _can_ return a result for unit tests because we aren't using doCommand.
    return result
#@+node:ekr.20040723094220.4: *9* << print dots >>
if count % 100 == 0:
    g.es('','.',newline=False)

if count % 2000 == 0:
    g.enl()
#@+node:ekr.20040723094220.5: *8* c.checkPythonNode
def checkPythonNode (self,p,unittest=False,suppressErrors=False):

    c = self ; h = p.h

    # Call getScript to ignore directives and section references.
    body = g.getScript(c,p.copy())
    if not body: return

    try:
        fn = '<node: %s>' % p.h
        if not g.isPython3:
            body = g.toEncodedString(body)
        compile(body+'\n',fn,'exec')
        c.tabNannyNode(p,h,body,unittest,suppressErrors)
    except SyntaxError:
        if not suppressErrors:
            s = "Syntax error in: %s" % h
            g.es_print(s,color="blue")
            g.es_exception(full=False,color="black")
        if unittest: raise
    except Exception:
        g.es_print('unexpected exception')
        g.es_exception()
        if unittest: raise

#@+node:ekr.20040723094220.6: *8* c.tabNannyNode
# This code is based on tabnanny.check.

def tabNannyNode (self,p,headline,body,unittest=False,suppressErrors=False):

    """Check indentation using tabnanny."""

    c = self

    try:
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))

    except IndentationError:
        junk,msg,junk = sys.exc_info()
        if not suppressErrors:
            g.es("IndentationError in",headline,color="blue")
            g.es('',msg)
        if unittest: raise

    except tokenize.TokenError:
        junk, msg, junk = sys.exc_info()
        if not suppressErrors:
            g.es("TokenError in",headline,color="blue")
            g.es('',msg)
        if unittest: raise

    except tabnanny.NannyNag:
        junk, nag, junk = sys.exc_info()
        if not suppressErrors:
            badline = nag.get_lineno()
            line    = nag.get_line()
            message = nag.get_msg()
            g.es("indentation error in",headline,"line",badline,color="blue")
            g.es(message)
            line2 = repr(str(line))[1:-1]
            g.es("offending line:\n",line2)
        if unittest: raise

    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
        if unittest: raise
#@+node:ekr.20040412060927: *7* c.dumpOutline
def dumpOutline (self,event=None):

    """ Dump all nodes in the outline."""

    c = self
    seen = {}

    print ; print('='*40)
    v = c.hiddenRootNode
    v.dump()
    seen[v] = True
    for p in c.all_positions():
        if p.v not in seen:
            seen[p.v] = True
            p.v.dump()
#@+node:ekr.20040711135959.1: *7* Pretty Print commands
#@+node:ekr.20110917174948.6903: *8* class CPrettyPrinter
class CPrettyPrinter:
    
    @others
#@+node:ekr.20110917174948.6904: *9* __init__ (CPrettyPrinter)
def __init__ (self,c):
    
    self.c = c
    self.p = None # Set in indent.
    
    self.brackets = 0
        # The brackets indentation level.
    self.parens = 0
        # The parenthesis nesting level.
    self.result = []
        # The list of tokens that form the final result.
    self.tab_width = 4
        # The number of spaces in each unit of leading indentation.
        
    # No longer used.
    
    # self.ignored_brackets = 0
        # # The number of '}' to ignore before reducing self.brackets.
    # self.ignore_ws = False
        # # True: ignore the next whitespace token if any.
#@+node:ekr.20110917174948.6911: *9* indent & helpers
def indent (self,p,toList=False):

    c = self.c
    if not p.b: return
    self.p = p.copy()
    
    aList = self.tokenize(p.b)
    assert ''.join(aList) == p.b
    
    aList = self.add_statement_braces(aList)

    self.bracketLevel = 0
    self.parens = 0
    self.result = []
    for s in aList:
        # g.trace(repr(s))
        self.put_token(s)
        
    if 0:
        for z in self.result:
            print(repr(z))

    if toList:
        return self.result
    else:
        return ''.join(self.result)
#@+node:ekr.20110918225821.6815: *10* add_statement_braces
def add_statement_braces (self,s):
    
    p = self.p
    trace = False
    
    def oops(message,i,j):
        g.es('** changed ',p.h,color='red')
        g.es('%s after\n%s' % (
            message,repr(''.join(s[i:j]))))
    
    i,n,result = 0,len(s),[]
    while i < n:
        token = s[i]
        progress = i
        if token in ('if','for','while',):
            j = self.skip_ws_and_comments(s,i+1)
            if self.match(s,j,'('):
                j = self.skip_parens(s,j)
                if self.match(s,j,')'):
                    old_j = j+1
                    j = self.skip_ws_and_comments(s,j+1)
                    if self.match(s,j,';'):
                        # Example: while (*++prefix);
                        result.extend(s[i:j])
                    elif self.match(s,j,'{'):
                        result.extend(s[i:j])
                    else:
                        oops("insert '{'",i,j)
                        # Back up, and don't go past a newline or comment.
                        j = self.skip_ws(s,old_j)
                        result.extend(s[i:j])
                        result.append(' ')
                        result.append('{')
                        result.append('\n')
                        i = j
                        j = self.skip_statement(s,i)
                        result.extend(s[i:j])
                        result.append('\n')
                        result.append('}')
                        oops("insert '}'",i,j)
                else:
                    oops("missing ')'",i,j)
                    result.extend(s[i:j])
            else:
                oops("missing '('",i,j)
                result.extend(s[i:j])
            i = j
        else:
            result.append(token)
            i += 1
        assert progress < i
            
    if trace: g.trace(''.join(result))
    return result
            
#@+node:ekr.20110919184022.6903: *11* skip_ws
def skip_ws (self,s,i):
    
    while i < len(s):
        token = s[i]
        if token.startswith(' ') or token.startswith('\t'):
            i += 1
        else:
            break
        
    return i
#@+node:ekr.20110918225821.6820: *11* skip_ws_and_comments
def skip_ws_and_comments (self,s,i):
    
    while i < len(s):
        token = s[i]
        if token.isspace():
            i += 1
        elif token.startswith('//') or token.startswith('/*'):
            i += 1
        else:
            break
        
    return i
#@+node:ekr.20110918225821.6817: *11* skip_parens
def skip_parens(self,s,i):

    '''Skips from the opening ( to the matching ).

    If no matching is found i is set to len(s)'''

    assert(self.match(s,i,'('))
    
    level = 0
    while i < len(s):
        ch = s[i]
        if ch == '(':
            level += 1 ; i += 1
        elif ch == ')':
            level -= 1
            if level <= 0:  return i
            i += 1
        else: i += 1
    return i
#@+node:ekr.20110918225821.6818: *11* skip_statement
def skip_statement (self,s,i):
    
    '''Skip to the next ';' or '}' token.'''
    
    while i < len(s):
        if s[i] in ';}':
            i += 1
            break
        else:
            i += 1
    return i
#@+node:ekr.20110917204542.6967: *10* put_token & helpers
def put_token (self,s):
    
    '''Append token s to self.result as is,
    *except* for adjusting leading whitespace and comments.
    
    '{' tokens bump self.brackets or self.ignored_brackets.
    self.brackets determines leading whitespace.
    '''

    if s == '{':
        self.brackets += 1
    elif s == '}':
        self.brackets -= 1
        self.remove_indent()
    elif s == '(':
        self.parens += 1
    elif s == ')':
        self.parens -= 1
    elif s.startswith('\n'):
        if self.parens <= 0:
            s = '\n%s' % (' ' * self.brackets * self.tab_width)
        else: pass # Use the existing indentation.
    elif s.isspace():
        if self.parens <= 0 and self.result and self.result[-1].startswith('\n'):
            # Kill the whitespace.
            s = ''
        else: pass # Keep the whitespace.
    elif s.startswith('/*'):
        s = self.reformat_block_comment(s)
    else:
        pass # put s as it is.
    
    if s:
        self.result.append(s)
        
@
    # It doesn't hurt to increase indentation after *all* '{'.
    if s == '{':
        # Increase brackets unless '=' precedes it.
        if self.prev_token('='):
            self.ignored_brackets += 1
        else:
            self.brackets += 1
    elif s == '}':
        if self.ignored_brackets:
            self.ignored_brackets -= 1
        else:
            self.brackets -= 1
            self.remove_indent()
#@+node:ekr.20110917204542.6968: *11* prev_token
def prev_token (self,s):
    
    '''Return the previous token, ignoring whitespace and comments.'''
    
    i = len(self.result)-1
    while i >= 0:
        s2 = self.result[i]
        if s == s2:
            return True
        elif s.isspace() or s.startswith('//') or s.startswith ('/*'):
            i -= 1
        else:
            return False
#@+node:ekr.20110918184425.6916: *11* reformat_block_comment
def reformat_block_comment (self,s):
    
    return s
#@+node:ekr.20110917204542.6969: *11* remove_indent
def remove_indent (self):
    
    '''Remove one tab-width of blanks from the previous token.'''
    
    w = abs(self.tab_width)
    
    if self.result:
        s = self.result[-1]
        if s.isspace():
            self.result.pop()
            s = s.replace('\t',' ' * w)
            if s.startswith('\n'):
                s2 = s[1:]
                self.result.append('\n'+s2[:-w])
            else:
                self.result.append(s[:-w])
#@+node:ekr.20110918225821.6819: *9* match
def match(self,s,i,pat):
    
    return i < len(s) and s[i] == pat
#@+node:ekr.20110917174948.6930: *9* tokenize & helper
def tokenize (self,s):
    
    '''Tokenize comments, strings, identifiers, whitespace and operators.'''

    i,result = 0,[]
    while i < len(s):
        # Loop invariant: at end: j > i and s[i:j] is the new token.
        j = i
        ch = s[i]
        if ch in '@\n': # Make *sure* these are separate tokens.
            j += 1
        elif ch == '#': # Preprocessor directive.
            j = g.skip_to_end_of_line(s,i)
        elif ch in ' \t':
            j = g.skip_ws(s,i)
        elif ch.isalpha() or ch == '_':
            j = g.skip_c_id(s,i)
        elif g.match(s,i,'//'):
            j = g.skip_line(s,i)
        elif g.match(s,i,'/*'):
            j = self.skip_block_comment(s,i)
        elif ch in "'\"":
            j = g.skip_string(s,i)
        else:
            j += 1
            
        assert j > i
        result.append(''.join(s[i:j]))
        i = j # Advance.
        
    return result
    
@ The following could be added to the 'else' clause::
    # Accumulate everything else.
    while (
        j < n and
        not s[j].isspace() and
        not s[j].isalpha() and
        not s[j] in '"\'_@' and
            # start of strings, identifiers, and single-character tokens.
        not g.match(s,j,'//') and
        not g.match(s,j,'/*') and
        not g.match(s,j,'-->')
    ):
        j += 1
#@+node:ekr.20110917193725.6974: *10* skip_block_comment
def skip_block_comment (self,s,i):

    assert(g.match(s,i,"/*"))

    j = s.find("*/",i)
    if j == -1:
        return len(s)
    else:
        return j + 2
#@+node:ekr.20040711135244.5: *8* class PythonPrettyPrinter
class PythonPrettyPrinter:

    @others
#@+node:ekr.20040711135244.6: *9* __init__ (PythonPrettyPrinter)
def __init__ (self,c):

    self.array = []
        # List of strings comprising the line being accumulated.
        # Important: this list never crosses a line.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.lastName = None # The name of the previous token type.
    self.line = 0 # Same as self.srow
    self.lineParenLevel = 0
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.p
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.squareBracketLevel = 0
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False
    << define dispatch dict >>
#@+node:ekr.20041021100850: *10* << define dispatch dict >>
self.dispatchDict = {

    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}
#@+node:ekr.20040713093048: *9* clear
def clear (self):
    self.lines = []
#@+node:ekr.20040713064323: *9* dumpLines
def dumpLines (self,p,lines):

    g.pr('\n','-'*10,p.cleanHeadString())

    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,reportErrors=True)
            g.pr(line2,newline=False) # Don't add a trailing newline!)
    else:
        for i in range(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,reportErrors=True)
            g.pr("%3d" % i, repr(lines[i]))
#@+node:ekr.20040711135244.7: *9* dumpToken
def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        g.pr("----- line",srow,repr(line))
    self.line = srow

    g.pr("%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val)))
#@+node:ekr.20040713091855: *9* endUndo
def endUndo (self):

    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    current = c.p

    if self.changed:
        # Tag the end of the command.
        u.afterChangeGroup(current,undoType,dirtyVnodeList=self.dirtyVnodeList)
#@+node:ekr.20040711135244.8: *9* get
def get (self):

    if self.lastName != 'newline' and self.lines:
        # Strip the trailing whitespace from the last line.
        self.lines[-1] = self.lines[-1].rstrip()

    return self.lines
#@+node:ekr.20040711135244.4: *9* prettyPrintNode
def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.h
    s = p.b
    if not s: return

    readlines = g.readLinesClass(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("error pretty-printing",h,"not changed.",color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)
#@+node:ekr.20040711135244.9: *9* put
def put (self,s,strip=True):

    """Put s to self.array, and strip trailing whitespace if strip is True."""

    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
#@+node:ekr.20041021104237: *9* putArray
def putArray (self):

    """Add the next text by joining all the strings is self.array"""

    self.lines.append(''.join(self.array))
    self.array = []
    self.lineParenLevel = 0
#@+node:ekr.20040711135244.10: *9* putNormalToken & allies
def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row & col where the token begins in the source.
    self.erow,self.ecol = t4 # row & col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
    self.lastName = self.name
#@+node:ekr.20041021102938: *10* doEndMarker
def doEndMarker (self):

    self.putArray()
#@+node:ekr.20041021102340.1: *10* doErrorToken
def doErrorToken (self):

    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
#@+node:ekr.20041021102340.2: *10* doIndent & doDedent
def doDedent (self):

    pass

def doIndent (self):

    self.array.append(self.val)
#@+node:ekr.20041021102340: *10* doMultiLine (strings, etc).
def doMultiLine (self):

    # Ensure a blank before comments not preceded entirely by whitespace.

    if self.val.startswith('#') and self.array:
        prev = self.array[-1]
        if prev and prev[-1] != ' ':
            self.put(' ') 

    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()

    # Add a blank after the string if there is something in the last line.
    if self.array:
        line = self.array[-1]
        if line.strip():
            self.put(' ')

    # Suppress start-of-line logic.
    self.line = self.erow
#@+node:ekr.20041021101911.5: *10* doName
def doName(self):

    # Ensure whitespace or start-of-line precedes the name.
    if self.array:
        last = self.array[-1]
        ch = last[-1]
        outer = self.parenLevel == 0 and self.squareBracketLevel == 0
        chars = '@ \t{([.'
        if not outer: chars += ',=<>*-+&|/'
        if ch not in chars:
            self.array.append(' ')

    self.array.append("%s " % self.val)

    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.

    self.prevName = self.val
#@+node:ekr.20041021101911.3: *10* doNewline
def doNewline (self):

    # Remove trailing whitespace.
    # This never removes trailing whitespace from multi-line tokens.
    if self.array:
        self.array[-1] = self.array[-1].rstrip()

    self.array.append('\n')
    self.putArray()
#@+node:ekr.20041021101911.6: *10* doNumber
def doNumber (self):

    self.array.append(self.val)
#@+node:ekr.20040711135244.11: *10* doOp
def doOp (self):

    val = self.val
    outer = self.lineParenLevel <= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','<=','>=','<','>','<>','*','**','+','&','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '>>':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '<<':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and not g.isWordChar(prev[-1]):
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)
#@+node:ekr.20041021112219: *10* doStartLine
def doStartLine (self):

    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]

    if self.ws:
        self.array.append(self.ws)
#@+node:ekr.20041021101911.1: *10* oops
def oops(self):

    g.pr("unknown PrettyPrinting code: %s" % (self.name))
#@+node:ekr.20041021101911.2: *10* trace (PrettyPrint)
def trace(self):

    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val))
        ))
#@+node:ekr.20040711135244.12: *9* putToken
def putToken (self,token5tuple):

    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)
#@+node:ekr.20040713070356: *9* replaceBody
def replaceBody (self,p,lines):

    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    sel = c.frame.body.getInsertPoint()
    oldBody = p.b
    body = ''.join(lines)

    if oldBody != body:
        if not self.changed:
            # Start the group.
            u.beforeChangeGroup(p,undoType)
            self.changed = True
            self.dirtyVnodeList = []
        undoData = u.beforeChangeNodeContents(p)
        c.setBodyString(p,body)
        dirtyVnodeList2 = p.setDirty()
        self.dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterChangeNodeContents(p,undoType,undoData,dirtyVnodeList=self.dirtyVnodeList)
#@+node:ekr.20040712053025: *8* prettyPrintAllPythonCode
def prettyPrintAllPythonCode (self,event=None,dump=False):

    '''Reformat all Python code in the outline to make it look more beautiful.'''

    c = self ; pp = c.PythonPrettyPrinter(c)

    for p in c.all_unique_positions():

        # Unlike c.scanAllDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
            pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()

# For unit test of inverse commands dict.
def beautifyAllPythonCode (self,event=None,dump=False):
    
    '''Reformat all Python code in the outline.'''

    return self.prettyPrintAllPythonCode (event,dump)
#@+node:ekr.20110917174948.6877: *8* beautifyCCode
def beautifyCCode (self,event=None):

    '''Reformat all C code in the selected tree.'''

    c = self
    pp = c.CPrettyPrinter(c)
    u = c.undoer ; undoType = 'beautify-c'
    
    u.beforeChangeGroup(c.p,undoType)
    dirtyVnodeList = []
    changed = False

    for p in c.p.self_and_subtree():
        if g.scanForAtLanguage(c,p) == "c":
            bunch = u.beforeChangeNodeContents(p,oldBody=p.b)
            s = pp.indent(p)
            if p.b != s:
                # g.es('changed: %s' % (p.h))
                p.b = s
                p.v.setDirty()
                dirtyVnodeList.append(p.v)
                u.afterChangeNodeContents(p,undoType,bunch)
                changed = True

    if changed:
        u.afterChangeGroup(c.p,undoType,
            reportFlag=False,dirtyVnodeList=dirtyVnodeList)
            
    c.bodyWantsFocus()
#@+node:ekr.20040712053025.1: *8* prettyPrintPythonCode
def prettyPrintPythonCode (self,event=None,p=None,dump=False):

    '''Reformat all Python code in the selected tree.'''

    c = self

    if p: root = p.copy()
    else: root = c.p

    pp = c.PythonPrettyPrinter(c)

    for p in root.self_and_subtree():

        # Unlike c.scanAllDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()

# For unit test of inverse commands dict.
def beautifyPythonCode (self,event=None,dump=False):
    
    '''Beautify all Python code in the selected tree.'''
    return self.prettyPrintPythonCode (event,dump)

#@+node:ekr.20050729211526: *8* prettyPrintPythonNode
def prettyPrintPythonNode (self,p=None,dump=False):

    c = self

    if not p:
        p = c.p

    pp = c.PythonPrettyPrinter(c)

    # Unlike c.scanAllDirectives, scanForAtLanguage ignores @comment.
    if g.scanForAtLanguage(c,p) == "python":
        pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()
#@+node:ekr.20071001075704: *8* prettyPrintPythonTree
def prettyPrintPythonTree (self,event=None,dump=False):

    '''Beautify all Python code in the selected outline.'''

    c = self ; p = c.p ; pp = c.PythonPrettyPrinter(c)

    for p in p.self_and_subtree():

        # Unlike c.scanAllDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()

# For unit test of inverse commands dict.
def beautifyPythonTree (self,event=None,dump=False):
    
    '''Beautify all Python code in the selected outline.'''
    
    return self.prettyPrintPythonTree (event,dump)
#@+node:ekr.20031218072017.2898: *6* Expand & Contract...
#@+node:ekr.20031218072017.2899: *7* Commands (outline menu)
#@+node:ekr.20031218072017.2900: *8* contractAllHeadlines
def contractAllHeadlines (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self

    for p in c.all_unique_positions():
        p.contract()
    # Select the topmost ancestor of the presently selected node.
    p = c.p
    while p and p.hasParent():
        p.moveToParent()

    c.redraw(p,setFocus=True)

    c.expansionLevel = 1 # Reset expansion level.
#@+node:ekr.20080819075811.3: *8* contractAllOtherNodes & helper
def contractAllOtherNodes (self,event=None):

    '''Contract all nodes except those needed to make the
    presently selected node visible.'''

    c = self ; leaveOpen = c.p

    for p in c.rootPosition().self_and_siblings():
        c.contractIfNotCurrent(p,leaveOpen)

    c.redraw()

#@+node:ekr.20080819075811.7: *9* contractIfNotCurrent
def contractIfNotCurrent(self,p,leaveOpen):

    c = self

    if p == leaveOpen or not p.isAncestorOf(leaveOpen):
        p.contract()

    for child in p.children():
        if child != leaveOpen and child.isAncestorOf(leaveOpen):
            c.contractIfNotCurrent(child,leaveOpen)
        else:
            for p2 in child.self_and_subtree():
                p2.contract()
#@+node:ekr.20031218072017.2901: *8* contractNode
def contractNode (self,event=None):

    '''Contract the presently selected node.'''

    c = self ; p = c.p

    p.contract()

    if p.isCloned():
        c.redraw() # A full redraw is necessary to handle clones.
    else:
        c.redraw_after_contract(p=p,setFocus=True)
#@+node:ekr.20040930064232: *8* contractNodeOrGoToParent
def contractNodeOrGoToParent (self,event=None):

    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.p
    
    parent = p.parent()
    redraw = False

    if p.hasChildren() and p.isExpanded():
        c.contractNode()
        
    elif parent and parent.isVisible(c):
        # New in Leo 4.9.1: contract all children first.
        if c.collapse_on_lt_arrow:
            for child in parent.children():
                if child.isExpanded():
                    child.contract()
                    redraw = True
        c.goToParent()
        
    # This is a bit off-putting.
    # elif not parent and not c.hoistStack:
        # p = c.rootPosition()
        # while p:
            # if p.isExpanded():
                # p.contract()
                # redraw = True
            # p.moveToNext()

    if redraw:
        c.redraw()
#@+node:ekr.20031218072017.2902: *8* contractParent
def contractParent (self,event=None):

    '''Contract the parent of the presently selected node.'''

    c = self ; p = c.p

    parent = p.parent()
    if not parent: return

    parent.contract()

    c.redraw_after_contract(p=parent)
#@+node:ekr.20031218072017.2903: *8* expandAllHeadlines
def expandAllHeadlines (self,event=None):

    '''Expand all headlines.
    Warning: this can take a long time for large outlines.'''

    c = self

    p = c.rootPosition()
    while p:
        c.expandSubtree(p)
        p.moveToNext()

    c.redraw_after_expand(p=c.rootPosition(),setFocus=True)

    c.expansionLevel = 0 # Reset expansion level.
#@+node:ekr.20031218072017.2904: *8* expandAllSubheads
def expandAllSubheads (self,event=None):

    '''Expand all children of the presently selected node.'''

    c = self ; p = c.p
    if not p: return

    child = p.firstChild()
    c.expandSubtree(p)
    while child:
        c.expandSubtree(child)
        child = child.next()

    c.redraw(p,setFocus=True)
#@+node:ekr.20031218072017.2905: *8* expandLevel1..9
def expandLevel1 (self,event=None):
    '''Expand the outline to level 1'''
    self.expandToLevel(1)

def expandLevel2 (self,event=None):
    '''Expand the outline to level 2'''
    self.expandToLevel(2)

def expandLevel3 (self,event=None):
    '''Expand the outline to level 3'''
    self.expandToLevel(3)

def expandLevel4 (self,event=None):
    '''Expand the outline to level 4'''
    self.expandToLevel(4)

def expandLevel5 (self,event=None):
    '''Expand the outline to level 5'''
    self.expandToLevel(5)

def expandLevel6 (self,event=None):
    '''Expand the outline to level 6'''
    self.expandToLevel(6)

def expandLevel7 (self,event=None):
    '''Expand the outline to level 7'''
    self.expandToLevel(7)

def expandLevel8 (self,event=None):
    '''Expand the outline to level 8'''
    self.expandToLevel(8)

def expandLevel9 (self,event=None):
    '''Expand the outline to level 9'''
    self.expandToLevel(9)
#@+node:ekr.20031218072017.2906: *8* expandNextLevel
def expandNextLevel (self,event=None):

    '''Increase the expansion level of the outline and
    Expand all nodes at that level or lower.'''

    c = self ; v = c.currentVnode()

    # Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v

    self.expandToLevel(c.expansionLevel + 1)
#@+node:ekr.20031218072017.2907: *8* expandNode
def expandNode (self,event=None):

    '''Expand the presently selected node.'''

    trace = False and not g.unitTesting
    c = self ; p = c.p

    p.expand()

    if p.isCloned():
        if trace: g.trace('***redraw')
        c.redraw() # Bug fix: 2009/10/03.
    else:
        c.redraw_after_expand(p,setFocus=True)

#@+node:ekr.20040930064232.1: *8* expandNodeAnd/OrGoToFirstChild
def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.p

    if p.hasChildren():
        if p.isExpanded():
            c.selectPosition(p.firstChild())
        else:
            c.expandNode()
            # Fix bug 930726
            # expandNodeAndGoToFirstChild only expands or only goes to first child .
            c.selectPosition(p.firstChild())

    c.treeFocusHelper()

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.p
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode() # Calls redraw_after_expand.
        else:
            c.redraw_after_expand(p.firstChild(),setFocus=True)
#@+node:ekr.20060928062431: *8* expandOnlyAncestorsOfNode
def expandOnlyAncestorsOfNode (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self ; level = 1

    for p in c.all_unique_positions():
        p.contract()
    for p in c.p.parents():
        p.expand()
        level += 1

    c.redraw(setFocus=True)

    c.expansionLevel = level # Reset expansion level.
#@+node:ekr.20031218072017.2908: *8* expandPrevLevel
def expandPrevLevel (self,event=None):

    '''Decrease the expansion level of the outline and
    Expand all nodes at that level or lower.'''

    c = self ; v = c.currentVnode()

    # Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v

    self.expandToLevel(max(1,c.expansionLevel - 1))
#@+node:ekr.20031218072017.2909: *7* Utilities
#@+node:ekr.20031218072017.2910: *8* contractSubtree
def contractSubtree (self,p):

    for p in p.subtree():
        p.contract()
#@+node:ekr.20031218072017.2911: *8* expandSubtree
def expandSubtree (self,v):

    c = self
    last = v.lastNode()

    while v and v != last:
        v.expand()
        v = v.threadNext()

    c.redraw()
#@+node:ekr.20031218072017.2912: *8* expandToLevel (rewritten in 4.4)
def expandToLevel (self,level):

    c = self
    current = c.p
    n = current.level()
    for p in current.self_and_subtree():
        if p.level() - n + 1 < level:
            p.expand()
        else:
            p.contract()
    c.expansionLevel = level
    c.expansionNode = c.p
    c.redraw()
#@+node:ekr.20031218072017.2922: *6* Mark...
#@+node:ekr.20090905110447.6098: *7* c.cloneMarked
def cloneMarked(self,event=None):

    """Clone all marked nodes as children of a new node."""

    c = self ; u = c.undoer ; p1 = c.p.copy()

    # Create a new node to hold clones.
    parent = p1.insertAfter()
    parent.h = 'Clones of marked nodes'

    moved,n,p = [],0,c.rootPosition()
    while p:
        # Careful: don't clone already-cloned nodes.
        if p == parent:
            p.moveToNodeAfterTree()
        elif p.isMarked() and not p.v in moved:
            moved.append(p.v)
            # Moving the clone leaves position p unchanged.
            p.clone().moveToLastChildOf(parent)
            p.moveToNodeAfterTree()
            n += 1
        else:
            p.moveToThreadNext()

    if n:
        c.setChanged(True)
        parent.expand()
        c.selectPosition(parent)
        u.afterCloneMarkedNodes(p1)
    else:
        parent.doDelete()
        c.selectPosition(p1)

    if not g.unitTesting:
        g.es('cloned %s nodes' % (n),color='blue')
    c.redraw()    
#@+node:ekr.20111005081134.15540: *7* c.deleteMarked
def deleteMarked (self,event=None):
    
    """Delete all marked nodes."""
    
    c = self ; u = c.undoer ; p1 = c.p.copy()
    
    undo_data,p = [],c.rootPosition()
    while p:
        if p.isMarked():
            undo_data.append(p.copy())
            next = p.positionAfterDeletedTree()
            p.doDelete()
            p = next
        else:
            p.moveToThreadNext()

    if undo_data:
        u.afterDeleteMarkedNodes(undo_data,p1)
        if not g.unitTesting:
            g.es('deleted %s nodes' % (len(undo_data)),color='blue')
        c.setChanged(True)

    # Don't even *think* about restoring the old position.
    c.contractAllHeadlines()
    c.selectPosition(c.rootPosition())
    c.redraw()    
#@+node:ekr.20111005081134.15539: *7* c.moveMarked & helper
def moveMarked (self,event=None):

    '''Move all marked nodes as children of parent position.'''
    
    c = self ; u = c.undoer ; p1 = c.p.copy()
    
    # Check for marks.
    for v in c.all_unique_nodes():
        if v.isMarked():
            break
    else:
        return g.es('no marked nodes',color='blue')

    # Create a new root node to hold the moved nodes.
    parent = c.createMoveMarkedNode()
    assert not parent.isMarked()

    undo_data,p = [],c.rootPosition()
    while p:
        assert parent == c.rootPosition()
        # Careful: don't move already-moved nodes.
        if p.isMarked() and not parent.isAncestorOf(p):
            undo_data.append(p.copy())
            next = p.positionAfterDeletedTree()
            p.moveToLastChildOf(parent)
            p = next
        else:
            p.moveToThreadNext()

    if undo_data:
        u.afterMoveMarkedNodes(undo_data,p1)
        if not g.unitTesting:
            g.es('moved %s nodes' % (len(undo_data)),color='blue')
        c.setChanged(True)
        
    # Don't even *think* about restoring the old position.
    c.contractAllHeadlines()
    c.selectPosition(parent)
    c.redraw()    
#@+node:ekr.20111005081134.15543: *8* createMoveMarkedNode
def createMoveMarkedNode(self):
    
    c = self
    oldRoot = c.rootPosition()
    p = oldRoot.insertAfter()
    p.moveToRoot(oldRoot)
    c.setHeadString(p,'Moved marked nodes')
    return p
#@+node:ekr.20031218072017.2923: *7* markChangedHeadlines
def markChangedHeadlines (self,event=None):

    '''Mark all nodes that have been changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.p

    c.endEditing()
    u.beforeChangeGroup(current,undoType)
    for p in c.all_unique_positions():
        if p.isDirty()and not p.isMarked():
            bunch = u.beforeMark(p,undoType)
            c.setMarked(p)
            c.setChanged(True)
            u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType)
    if not g.unitTesting:
        g.es("done",color="blue")

    c.redraw_after_icons_changed()
#@+node:ekr.20031218072017.2924: *7* markChangedRoots
def markChangedRoots (self,event=None):

    '''Mark all changed @root nodes.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.p

    c.endEditing()
    u.beforeChangeGroup(current,undoType)
    for p in c.all_unique_positions():
        if p.isDirty()and not p.isMarked():
            s = p.b
            flag, i = g.is_special(s,0,"@root")
            if flag:
                bunch = u.beforeMark(p,undoType)
                c.setMarked(p)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType)
    if not g.unitTesting:
        g.es("done",color="blue")

    c.redraw_after_icons_changed()
#@+node:ekr.20031218072017.2925: *7* markAllAtFileNodesDirty
def markAllAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes as changed.'''

    c = self ; p = c.rootPosition()

    c.endEditing()
    while p:
        if p.isAtFileNode() and not p.isDirty():
            p.setDirty()
            c.setChanged(True)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    c.redraw_after_icons_changed()

#@+node:ekr.20031218072017.2926: *7* markAtFileNodesDirty
def markAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes in the selected tree as changed.'''

    c = self
    p = c.p
    if not p: return

    c.endEditing()
    after = p.nodeAfterTree()
    while p and p != after:
        if p.isAtFileNode() and not p.isDirty():
            p.setDirty()
            c.setChanged(True)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    c.redraw_after_icons_changed()

#@+node:ekr.20031218072017.2928: *7* markHeadline
def markHeadline (self,event=None):

    '''Toggle the mark of the selected node.'''

    c = self ; u = c.undoer ; p = c.p
    if not p: return

    c.endEditing()
    undoType = g.choose(p.isMarked(),'Unmark','Mark')
    bunch = u.beforeMark(p,undoType)
    if p.isMarked():
        c.clearMarked(p)
    else:
        c.setMarked(p)
    dirtyVnodeList = p.setDirty()
    c.setChanged(True)
    u.afterMark(p,undoType,bunch,dirtyVnodeList=dirtyVnodeList)

    c.redraw_after_icons_changed()
#@+node:ekr.20031218072017.2929: *7* markSubheads
def markSubheads (self,event=None):

    '''Mark all children of the selected node as changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Subheads'
    current = c.p
    if not current: return

    c.endEditing()
    u.beforeChangeGroup(current,undoType)
    dirtyVnodeList = []
    for p in current.children():
        if not p.isMarked():
            bunch = u.beforeMark(p,undoType)
            c.setMarked(p)
            dirtyVnodeList2 = p.setDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)

    c.redraw_after_icons_changed()
#@+node:ekr.20031218072017.2930: *7* unmarkAll
def unmarkAll (self,event=None):

    '''Unmark all nodes in the entire outline.'''

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.p
    if not current: return

    c.endEditing()
    u.beforeChangeGroup(current,undoType)
    changed = False
    for p in c.all_unique_positions():
        if p.isMarked():
            bunch = u.beforeMark(p,undoType)
            # c.clearMarked(p) # Very slow: calls a hook.
            p.v.clearMarked()
            p.v.setDirty()
            u.afterMark(p,undoType,bunch)
            changed = True
    dirtyVnodeList = [p.v for p in c.all_unique_positions() if p.v.isDirty()]
    if changed:
        g.doHook("clear-all-marks",c=c,p=p,v=p)
        c.setChanged(True)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)

    c.redraw_after_icons_changed()
#@+node:ekr.20031218072017.1766: *6* Move... (Commands)
#@+node:ekr.20070420092425: *7* cantMoveMessage
def cantMoveMessage (self):

    c = self ; h = c.rootPosition().h
    kind = g.choose(h.startswith('@chapter'),'chapter','hoist')
    g.es("can't move node out of",kind,color="blue")
#@+node:ekr.20031218072017.1767: *7* demote
def demote (self,event=None):

    '''Make all following siblings children of the selected node.'''

    c = self ; u = c.undoer
    p = c.p
    if not p or not p.hasNext():
        c.treeFocusHelper()
        return

    # Make sure all the moves will be valid.
    next = p.next()
    while next:
        if not c.checkMoveWithParentWithWarning(next,p,True):
            c.treeFocusHelper()
            return
        next.moveToNext()

    c.endEditing()
    parent_v = p._parentVnode()
    n = p.childIndex()
    followingSibs = parent_v.children[n+1:]
    # g.trace('sibs2\n',g.listToString(followingSibs2))

    # Remove the moved nodes from the parent's children.
    parent_v.children = parent_v.children[:n+1]
    # Add the moved nodes to p's children
    p.v.children.extend(followingSibs)
    # Adjust the parent links in the moved nodes.
    # There is no need to adjust descendant links.
    for child in followingSibs:
        child.parents.remove(parent_v)
        child.parents.append(p.v)

    p.expand()
    # Even if p is an @ignore node there is no need to mark the demoted children dirty.
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    c.setChanged(True)
    u.afterDemote(p,followingSibs,dirtyVnodeList)
    c.redraw(p,setFocus=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1768: *7* moveOutlineDown
@
Moving down is more tricky than moving up; we can't move p to be a child of
itself. An important optimization: we don't have to call
checkMoveWithParentWithWarning() if the parent of the moved node remains the
same.
@c

def moveOutlineDown (self,event=None):

    '''Move the selected node down.'''

    c = self ; u = c.undoer ; p = c.p
    if not p: return

    if not c.canMoveOutlineDown():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    next = p.visNext(c)

    while next and p.isAncestorOf(next):
        next = next.visNext(c)
    if not next:
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    c.endEditing()
    undoData = u.beforeMoveNode(p)
    << Move p down & set moved if successful >>
    if moved:
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
    c.redraw(p,setFocus=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1769: *8* << Move p down & set moved if successful >>
if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)

else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)

# Patch by nh2: 0004-Add-bool-collapse_nodes_after_move-option.patch
if c.collapse_nodes_after_move and moved and c.sparse_move and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@+node:ekr.20031218072017.1770: *7* moveOutlineLeft
def moveOutlineLeft (self,event=None):

    '''Move the selected node left if possible.'''

    c = self ; u = c.undoer ; p = c.p
    if not p: return
    if not c.canMoveOutlineLeft():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    if not p.hasParent():
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.moveAfter(parent)
    if inAtIgnoreRange and not p.inAtIgnoreRange():
        # The moved nodes have just become newly unignored.
        p.setDirty() # Mark descendent @thin nodes dirty.
    else: # No need to mark descendents dirty.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)

    # Patch by nh2: 0004-Add-bool-collapse_nodes_after_move-option.patch
    if c.collapse_nodes_after_move and c.sparse_move: # New in Leo 4.4.2
        parent.contract()
    c.redraw_now(p,setFocus=True)
    c.recolor_now() # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1771: *7* moveOutlineRight
def moveOutlineRight (self,event=None):

    '''Move the selected node right if possible.'''

    c = self ; u = c.undoer ; p = c.p
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    back = p.back()
    if not back:
        c.treeFocusHelper()
        return

    if not c.checkMoveWithParentWithWarning(p,back,True):
        c.treeFocusHelper()
        return

    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    n = back.numberOfChildren()
    p.moveToNthChildOf(back,n)
    # Moving an outline right can never bring it outside the range of @ignore.
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
    dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    # g.trace(p)
    c.redraw_now(p,setFocus=True)
    c.recolor_now()
#@+node:ekr.20031218072017.1772: *7* moveOutlineUp
def moveOutlineUp (self,event=None):

    '''Move the selected node up if possible.'''

    trace = False and not g.unitTesting
    c = self ; u = c.undoer ; p = c.p
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    back = p.visBack(c)
    if not back:
        if trace: g.trace('no visBack')
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack(c)

    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    moved = False
    << Move p up >>
    if moved:
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    c.redraw(p,setFocus=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1773: *8* << Move p up >>
if trace:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("back2.hasChildren",back2 and back2.hasChildren())
    g.trace("back2.isExpanded",back2 and back2.isExpanded())

parent = p.parent()

if not back2:
    if c.hoistStack: # hoist or chapter.
        limit,limitIsVisible = c.visLimit()
        assert limit
        if limitIsVisible:
            # canMoveOutlineUp should have caught this.
            g.trace('can not happen. In hoist')
        else:
            # g.trace('chapter first child')
            moved = True
            p.moveToFirstChildOf(limit)
    else:
        # p will be the new root node
        p.moveToRoot(oldRoot=c.rootPosition())
        moved = True

elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)
else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)

# Patch by nh2: 0004-Add-bool-collapse_nodes_after_move-option.patch
if c.collapse_nodes_after_move and moved and c.sparse_move and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@+node:ekr.20031218072017.1774: *7* promote
def promote (self,event=None):

    '''Make all children of the selected nodes siblings of the selected node.'''

    c = self ; u = c.undoer ; p = c.p
    command = 'Promote'
    if not p or not p.hasChildren():
        c.treeFocusHelper()
        return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.endEditing()
    parent_v = p._parentVnode()
    children = p.v.children
    # Add the children to parent_v's children.
    n = p.childIndex()+1
    z = parent_v.children[:]
    parent_v.children = z[:n]
    parent_v.children.extend(children)
    parent_v.children.extend(z[n:])
    # Remove v's children.
    p.v.children = []

    # Adjust the parent links in the moved children.
    # There is no need to adjust descendant links.
    for child in children:
        child.parents.remove(p.v)
        child.parents.append(parent_v)

    c.setChanged(True)
    if not inAtIgnoreRange and isAtIgnoreNode:
        # The promoted nodes have just become newly unignored.
        dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
    else: # No need to mark descendents dirty.
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    u.afterPromote(p,children,dirtyVnodeList)
    c.redraw(p,setFocus=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20071213185710: *7* c.toggleSparseMove
def toggleSparseMove (self,event=None):
    
    '''Toggle whether moves collapse the outline.'''

    c = self

    c.sparse_move = not c.sparse_move

    if not g.unitTesting:
        g.es('sparse-move: %s' % c.sparse_move,color='blue')
#@+node:ekr.20031218072017.2913: *6* Goto (Commands)
#@+node:ekr.20031218072017.1628: *7* goNextVisitedNode
def goNextVisitedNode (self,event=None):

    '''Select the next visited node.'''

    c = self

    p = c.nodeHistory.goNext()

    if p:
        c.nodeHistory.skipBeadUpdate = True
        try:
            c.selectPosition(p)
        finally:
            c.nodeHistory.skipBeadUpdate = False
            c.redraw_after_select(p)

#@+node:ekr.20031218072017.1627: *7* goPrevVisitedNode
def goPrevVisitedNode (self,event=None):

    '''Select the previously visited node.'''

    c = self

    p = c.nodeHistory.goPrev()

    if p:
        c.nodeHistory.skipBeadUpdate = True
        try:
            c.selectPosition(p)
        finally:            
            c.nodeHistory.skipBeadUpdate = False
            c.redraw_after_select(p)
#@+node:ekr.20031218072017.2914: *7* goToFirstNode
def goToFirstNode (self,event=None):

    '''Select the first node of the entire outline.'''

    c = self

    p = c.rootPosition()
    c.treeSelectHelper(p)
#@+node:ekr.20051012092453: *7* goToFirstSibling
def goToFirstSibling (self,event=None):

    '''Select the first sibling of the selected node.'''

    c = self ; p = c.p

    if p.hasBack():
        while p.hasBack():
            p.moveToBack()

    c.treeSelectHelper(p)
#@+node:ekr.20070615070925: *7* goToFirstVisibleNode
def goToFirstVisibleNode (self,event=None):

    '''Select the first visible node of the selected chapter or hoist.'''

    c = self

    p = c.firstVisible()
    if p:
        c.selectPosition(p)
        c.redraw_after_select(p)

    c.treeSelectHelper(p)
#@+node:ekr.20031218072017.2915: *7* goToLastNode
def goToLastNode (self,event=None):

    '''Select the last node in the entire tree.'''

    c = self ; p = c.rootPosition()
    while p and p.hasThreadNext():
        p.moveToThreadNext()

    c.treeSelectHelper(p)
#@+node:ekr.20051012092847.1: *7* goToLastSibling
def goToLastSibling (self,event=None):

    '''Select the last sibling of the selected node.'''

    c = self ; p = c.p

    if p.hasNext():
        while p.hasNext():
            p.moveToNext()

    c.treeSelectHelper(p)
#@+node:ekr.20050711153537: *7* c.goToLastVisibleNode
def goToLastVisibleNode (self,event=None):

    '''Select the last visible node of selected chapter or hoist.'''

    c = self

    p = c.lastVisible()
    if p:
        c.selectPosition(p)
        c.redraw_after_select(p)

    c.treeSelectHelper(p)
#@+node:ekr.20031218072017.2916: *7* goToNextClone
def goToNextClone (self,event=None):

    '''Select the next node that is a clone of the selected node.'''

    c = self ; cc = c.chapterController ; p = c.p
    if not p: return
    if not p.isCloned():
        g.es('not a clone:',p.h,color='blue')
        return

    v = p.v
    p.moveToThreadNext()
    wrapped = False
    while 1:
        # g.trace(p.v,p.h)
        if p and p.v == v:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if p:
        if cc:
            cc.selectChapterByName('main')
        c.selectPosition(p)
        c.redraw_after_select(p)
    else:
        g.es("done",color="blue")

    # if cc:
        # name = cc.findChapterNameForPosition(p)
        # cc.selectChapterByName(name)
#@+node:ekr.20071213123942: *7* findNextClone
def findNextClone (self,event=None):

    '''Select the next cloned node.'''

    c = self ; p = c.p ; cc = c.chapterController
    if not p: return

    if p.isCloned():
        p.moveToThreadNext()

    flag = False
    while p:
        if p.isCloned():
            flag = True ; break
        else:
            p.moveToThreadNext()

    if flag:
        if cc:
            # name = cc.findChapterNameForPosition(p)
            cc.selectChapterByName('main')
        c.selectPosition(p)
        c.redraw_after_select(p)
    else:
        g.es('no more clones',color='blue')
#@+node:ekr.20031218072017.2917: *7* goToNextDirtyHeadline
def goToNextDirtyHeadline (self,event=None):

    '''Select the node that is marked as changed.'''

    c = self ; p = c.p
    if not p: return

    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.isDirty():
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
#@+node:ekr.20031218072017.2918: *7* goToNextMarkedHeadline
def goToNextMarkedHeadline (self,event=None):

    '''Select the next marked node.'''

    c = self ; p = c.p
    if not p: return

    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.isMarked():
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
#@+node:ekr.20031218072017.2919: *7* goToNextSibling
def goToNextSibling (self,event=None):

    '''Select the next sibling of the selected node.'''

    c = self ; p = c.p

    c.treeSelectHelper(p and p.next())
#@+node:ekr.20031218072017.2920: *7* goToParent
def goToParent (self,event=None):

    '''Select the parent of the selected node.'''

    c = self ; p = c.p

    # g.trace(p.parent())

    c.treeSelectHelper(p and p.parent())
#@+node:ekr.20031218072017.2921: *7* goToPrevSibling
def goToPrevSibling (self,event=None):

    '''Select the previous sibling of the selected node.'''

    c = self ; p = c.p

    c.treeSelectHelper(p and p.back())
#@+node:ekr.20031218072017.2993: *7* selectThreadBack
def selectThreadBack (self,event=None):

    '''Select the node preceding the selected node in outline order.'''

    c = self ; p = c.p
    if not p: return

    p.moveToThreadBack()

    c.treeSelectHelper(p)
#@+node:ekr.20031218072017.2994: *7* selectThreadNext
def selectThreadNext (self,event=None):

    '''Select the node following the selected node in outline order.'''

    c = self ; p = c.p
    if not p: return

    p.moveToThreadNext()

    c.treeSelectHelper(p)
#@+node:ekr.20031218072017.2995: *7* selectVisBack
# This has an up arrow for a control key.

def selectVisBack (self,event=None):

    '''Select the visible node preceding the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisBack():
        c.endEditing() # 2011/05/28: A special case.
        return

    p.moveToVisBack(c)

    # g.trace(p.h)
    c.treeSelectHelper(p)
#@+node:ekr.20031218072017.2996: *7* selectVisNext
def selectVisNext (self,event=None):

    '''Select the visible node following the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisNext():
        c.endEditing() # 2011/05/28: A special case.
        return

    p.moveToVisNext(c)
    c.treeSelectHelper(p)
#@+node:ekr.20070417112650: *7* utils
#@+node:ekr.20070226121510: *8*  c.xFocusHelper
def treeEditFocusHelper (self):
    c = self
    if c.stayInTreeAfterEdit:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()

def treeFocusHelper (self):
    c = self
    if c.stayInTreeAfterSelect:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()

def initialFocusHelper (self):
    c = self
    if c.outlineHasInitialFocus:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()
#@+node:ekr.20070226113916: *8*  c.treeSelectHelper
def treeSelectHelper (self,p):

    c = self

    if not p: p = c.p

    if p:
        # Do not call expandAllAncestors here.
        c.selectPosition(p)
        c.redraw_after_select(p)

    c.treeFocusHelper()
#@+node:ekr.20031218072017.2913: *5* Goto (Commands)
#@+node:ekr.20031218072017.1628: *6* goNextVisitedNode
def goNextVisitedNode (self,event=None):

    '''Select the next visited node.'''

    c = self

    p = c.nodeHistory.goNext()

    if p:
        c.nodeHistory.skipBeadUpdate = True
        try:
            c.selectPosition(p)
        finally:
            c.nodeHistory.skipBeadUpdate = False
            c.redraw_after_select(p)

#@+node:ekr.20031218072017.1627: *6* goPrevVisitedNode
def goPrevVisitedNode (self,event=None):

    '''Select the previously visited node.'''

    c = self

    p = c.nodeHistory.goPrev()

    if p:
        c.nodeHistory.skipBeadUpdate = True
        try:
            c.selectPosition(p)
        finally:            
            c.nodeHistory.skipBeadUpdate = False
            c.redraw_after_select(p)
#@+node:ekr.20031218072017.2914: *6* goToFirstNode
def goToFirstNode (self,event=None):

    '''Select the first node of the entire outline.'''

    c = self

    p = c.rootPosition()
    c.treeSelectHelper(p)
#@+node:ekr.20051012092453: *6* goToFirstSibling
def goToFirstSibling (self,event=None):

    '''Select the first sibling of the selected node.'''

    c = self ; p = c.p

    if p.hasBack():
        while p.hasBack():
            p.moveToBack()

    c.treeSelectHelper(p)
#@+node:ekr.20070615070925: *6* goToFirstVisibleNode
def goToFirstVisibleNode (self,event=None):

    '''Select the first visible node of the selected chapter or hoist.'''

    c = self

    p = c.firstVisible()
    if p:
        c.selectPosition(p)
        c.redraw_after_select(p)

    c.treeSelectHelper(p)
#@+node:ekr.20031218072017.2915: *6* goToLastNode
def goToLastNode (self,event=None):

    '''Select the last node in the entire tree.'''

    c = self ; p = c.rootPosition()
    while p and p.hasThreadNext():
        p.moveToThreadNext()

    c.treeSelectHelper(p)
#@+node:ekr.20051012092847.1: *6* goToLastSibling
def goToLastSibling (self,event=None):

    '''Select the last sibling of the selected node.'''

    c = self ; p = c.p

    if p.hasNext():
        while p.hasNext():
            p.moveToNext()

    c.treeSelectHelper(p)
#@+node:ekr.20050711153537: *6* c.goToLastVisibleNode
def goToLastVisibleNode (self,event=None):

    '''Select the last visible node of selected chapter or hoist.'''

    c = self

    p = c.lastVisible()
    if p:
        c.selectPosition(p)
        c.redraw_after_select(p)

    c.treeSelectHelper(p)
#@+node:ekr.20031218072017.2916: *6* goToNextClone
def goToNextClone (self,event=None):

    '''Select the next node that is a clone of the selected node.'''

    c = self ; cc = c.chapterController ; p = c.p
    if not p: return
    if not p.isCloned():
        g.es('not a clone:',p.h,color='blue')
        return

    v = p.v
    p.moveToThreadNext()
    wrapped = False
    while 1:
        # g.trace(p.v,p.h)
        if p and p.v == v:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if p:
        if cc:
            cc.selectChapterByName('main')
        c.selectPosition(p)
        c.redraw_after_select(p)
    else:
        g.es("done",color="blue")

    # if cc:
        # name = cc.findChapterNameForPosition(p)
        # cc.selectChapterByName(name)
#@+node:ekr.20071213123942: *6* findNextClone
def findNextClone (self,event=None):

    '''Select the next cloned node.'''

    c = self ; p = c.p ; cc = c.chapterController
    if not p: return

    if p.isCloned():
        p.moveToThreadNext()

    flag = False
    while p:
        if p.isCloned():
            flag = True ; break
        else:
            p.moveToThreadNext()

    if flag:
        if cc:
            # name = cc.findChapterNameForPosition(p)
            cc.selectChapterByName('main')
        c.selectPosition(p)
        c.redraw_after_select(p)
    else:
        g.es('no more clones',color='blue')
#@+node:ekr.20031218072017.2917: *6* goToNextDirtyHeadline
def goToNextDirtyHeadline (self,event=None):

    '''Select the node that is marked as changed.'''

    c = self ; p = c.p
    if not p: return

    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.isDirty():
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
#@+node:ekr.20031218072017.2918: *6* goToNextMarkedHeadline
def goToNextMarkedHeadline (self,event=None):

    '''Select the next marked node.'''

    c = self ; p = c.p
    if not p: return

    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.isMarked():
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
#@+node:ekr.20031218072017.2919: *6* goToNextSibling
def goToNextSibling (self,event=None):

    '''Select the next sibling of the selected node.'''

    c = self ; p = c.p

    c.treeSelectHelper(p and p.next())
#@+node:ekr.20031218072017.2920: *6* goToParent
def goToParent (self,event=None):

    '''Select the parent of the selected node.'''

    c = self ; p = c.p

    # g.trace(p.parent())

    c.treeSelectHelper(p and p.parent())
#@+node:ekr.20031218072017.2921: *6* goToPrevSibling
def goToPrevSibling (self,event=None):

    '''Select the previous sibling of the selected node.'''

    c = self ; p = c.p

    c.treeSelectHelper(p and p.back())
#@+node:ekr.20031218072017.2993: *6* selectThreadBack
def selectThreadBack (self,event=None):

    '''Select the node preceding the selected node in outline order.'''

    c = self ; p = c.p
    if not p: return

    p.moveToThreadBack()

    c.treeSelectHelper(p)
#@+node:ekr.20031218072017.2994: *6* selectThreadNext
def selectThreadNext (self,event=None):

    '''Select the node following the selected node in outline order.'''

    c = self ; p = c.p
    if not p: return

    p.moveToThreadNext()

    c.treeSelectHelper(p)
#@+node:ekr.20031218072017.2995: *6* selectVisBack
# This has an up arrow for a control key.

def selectVisBack (self,event=None):

    '''Select the visible node preceding the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisBack():
        c.endEditing() # 2011/05/28: A special case.
        return

    p.moveToVisBack(c)

    # g.trace(p.h)
    c.treeSelectHelper(p)
#@+node:ekr.20031218072017.2996: *6* selectVisNext
def selectVisNext (self,event=None):

    '''Select the visible node following the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisNext():
        c.endEditing() # 2011/05/28: A special case.
        return

    p.moveToVisNext(c)
    c.treeSelectHelper(p)
#@+node:ekr.20070417112650: *6* utils
#@+node:ekr.20070226121510: *7*  c.xFocusHelper
def treeEditFocusHelper (self):
    c = self
    if c.stayInTreeAfterEdit:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()

def treeFocusHelper (self):
    c = self
    if c.stayInTreeAfterSelect:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()

def initialFocusHelper (self):
    c = self
    if c.outlineHasInitialFocus:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()
#@+node:ekr.20070226113916: *7*  c.treeSelectHelper
def treeSelectHelper (self,p):

    c = self

    if not p: p = c.p

    if p:
        # Do not call expandAllAncestors here.
        c.selectPosition(p)
        c.redraw_after_select(p)

    c.treeFocusHelper()
#@+node:ekr.20120311070142.9898: *4* Reference
#@+node:ekr.20070615070925.1: *5* c.firstVisible
def firstVisible(self):

    """Move to the first visible node of the present chapter or hoist."""

    c = self ; p = c.p

    while 1:
        back = p.visBack(c)
        if back and back.isVisible(c):
            p = back
        else: break
    return p
#@+node:ekr.20120308061112.9867: *5* c.hoist
def hoist (self,event=None):

    '''Make only the selected outline visible.'''

    c = self
    p = c.p
    
    if p and c.canHoist():
        # Remember the expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        p.expand()
        c.redraw(p)

        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.h)
        c.undoer.afterHoist(p,'Hoist')
        g.doHook('hoist-changed',c=c)
#@+node:ekr.20040803140033.2: *5* c.rootPosition
_rootCount = 0

def rootPosition(self):

    """Return the root position.

    Root position is the first position in the document. Other
    top level positions are siblings of this node.
    """

    c = self
    
    # g.trace(self._rootCount) ; self._rootCount += 1

    # 2011/02/25: Compute the position directly.
    if c.hiddenRootNode.children:
        v = c.hiddenRootNode.children[0]
        return leoNodes.position(v,childIndex=0,stack=None)
    else:
        return c.nullPosition()

# For compatibiility with old scripts.
rootVnode = rootPosition
findRootPosition = rootPosition
#@+node:ekr.20080416161551.196: *5* p.isVisible
def isVisible (self,c):

    p = self ; trace = False
    limit,limitIsVisible = c.visLimit()
    limit_v = limit and limit.v or None
    if p.v == limit_v:
        if trace: g.trace('*** at limit','limitIsVisible',limitIsVisible,p.h)
        return limitIsVisible

    # It's much easier with a full stack.
    n = len(p.stack)-1
    while n >= 0:
        progress = n
        # v,n = p.vParentWithStack(v,p.stack,n)
        v,junk = p.stack[n]
        if v == limit_v:  # We are at a descendant of limit.
            if trace: g.trace('*** descendant of limit',
                'limitIsVisible',limitIsVisible,
                'limit.isExpanded()',limit.isExpanded(),'v',v)
            if limitIsVisible:
                return limit.isExpanded()
            else: # Ignore the expansion state of @chapter nodes.
                return True
        if not v.isExpanded():
            if trace: g.trace('*** non-limit parent is not expanded:',v._headString,p.h)
            return False
        n -= 1
        assert progress > n

    return True
#@+node:ekr.20070226113916: *5*  c.treeSelectHelper
def treeSelectHelper (self,p):

    c = self

    if not p: p = c.p

    if p:
        # Do not call expandAllAncestors here.
        c.selectPosition(p)
        c.redraw_after_select(p)

    c.treeFocusHelper()
#@+node:ekr.20110605121601.17873: *5* full_redraw & helpers
# forceDraw not used. It is used in the Tk code.

def full_redraw (self,p=None,scroll=True,forceDraw=False):

    '''Redraw all visible nodes of the tree.

    Preserve the vertical scrolling unless scroll is True.'''

    trace = False and not g.app.unitTesting
    verbose = False
    c = self.c

    if self.busy():
        return g.trace('*** full_redraw: busy!',g.callers(5))

    if p is None:
        p = c.currentPosition()
    elif c.hoistStack and len(c.hoistStack) == 1 and p.h.startswith('@chapter') and p.hasChildren():
        # Make sure the current position is visible.
        # Part of fix of bug 875323: Hoist an @chapter node leaves a non-visible node selected.
        p = p.firstChild()
        if trace: g.trace('selecting',p.h)
        c.frame.tree.select(p)
        c.setCurrentPosition(p)
    else:
        c.setCurrentPosition(p)

    # if trace: g.trace('root',c.rootPosition())

    self.redrawCount += 1
    if trace: t1 = g.getTime()
    self.initData()
    self.nodeDrawCount = 0
    try:
        self.redrawing = True
        self.drawTopTree(p)
    finally:
        self.redrawing = False

    self.setItemForCurrentPosition(scroll=scroll)
    c.requestRedrawFlag= False

    if trace:
        theTime = g.timeSince(t1)
        g.trace('*** %s: scroll %5s drew %3s nodes in %s' % (
            self.redrawCount,scroll,self.nodeDrawCount,theTime)) # ,g.callers(3))
            
    return p # Return the position, which may have changed.

# Compatibility
redraw = full_redraw 
redraw_now = full_redraw
#@+node:ekr.20110605121601.17874: *6* drawChildren
def drawChildren (self,p,parent_item):

    trace = False and not g.unitTesting

    if trace: g.trace('children? %5s expanded? %5s %s' % (
        p.hasChildren(),p.isExpanded(),p.h))

    if not p:
        return g.trace('can not happen: no p')

    if p.hasChildren():
        if p.isExpanded():
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child,parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child,parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
#@+node:ekr.20110605121601.17875: *6* drawNode
def drawNode (self,p,parent_item):

    trace = False
    c = self.c 
    self.nodeDrawCount += 1

    # Allocate the item.
    item = self.createTreeItem(p,parent_item) 

    # Do this now, so self.isValidItem will be true in setItemIcon.
    self.rememberItem(p,item)

    # Set the headline and maybe the icon.
    self.setItemText(item,p.h)
    if p:
        self.drawItemIcon(p,item)

    if trace: g.trace(self.traceItem(item))

    return item
#@+node:ekr.20110605121601.17876: *6* drawTopTree
def drawTopTree (self,p):
    
    trace = False and not g.unitTesting
    c = self.c
    hPos,vPos = self.getScroll()
    self.clear()
    # Draw all top-level nodes and their visible descendants.
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p ; h = p.h
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            while p:
                self.drawTree(p)
                p.moveToNext()
        else:
            self.drawTree(p)
    else:
        p = c.rootPosition()
        if trace: g.trace(p)
        while p:
            self.drawTree(p)
            p.moveToNext()

    # This method always retains previous scroll position.
    self.setHScroll(hPos)
    self.setVScroll(vPos)

    self.repaint()
#@+node:ekr.20110605121601.17877: *6* drawTree
def drawTree (self,p,parent_item=None):

    # Draw the (visible) parent node.
    item = self.drawNode(p,parent_item)

    # Draw all the visible children.
    self.drawChildren(p,parent_item=item)
#@+node:ekr.20110605121601.17878: *6* initData
def initData (self):

    # g.trace('*****')

    self.item2positionDict = {}
    self.item2vnodeDict = {}
    self.position2itemDict = {}
    self.vnode2itemsDict = {}
    self.editWidgetsDict = {}
#@+node:ekr.20110605121601.17879: *6* rememberItem
def rememberItem (self,p,item):

    trace = False and not g.unitTesting
    if trace: g.trace('id',id(item),p)

    v = p.v

    # Update position dicts.
    itemHash = self.itemHash(item)
    self.position2itemDict[p.key()] = item
    self.item2positionDict[itemHash] = p.copy() # was item

    # Update item2vnodeDict.
    self.item2vnodeDict[itemHash] = v # was item

    # Update vnode2itemsDict.
    d = self.vnode2itemsDict
    aList = d.get(v,[])
    if item in aList:
        g.trace('*** ERROR *** item already in list: %s, %s' % (item,aList))
    else:
        aList.append(item)
    d[v] = aList
#@+node:ekr.20031218072017.2914: *5* goToFirstNode
def goToFirstNode (self,event=None):

    '''Select the first node of the entire outline.'''

    c = self

    p = c.rootPosition()
    c.treeSelectHelper(p)
#@+node:ekr.20040803072955.128: *5* leoTree.select & helpers
tree_select_lockout = False

def select (self,p,scroll=True):

    '''Select a node.
    Never redraws outline, but may change coloring of individual headlines.
    The scroll argument is used by the gui to suppress scrolling while dragging.'''

    if g.app.killed or self.tree_select_lockout: return None

    try:
        c = self.c ; old_p = c.p
        val = 'break'
        self.tree_select_lockout = True
        c.frame.tree.beforeSelectHint(p,old_p)
        val = self.selectHelper(p,scroll=scroll)
    finally:
        self.tree_select_lockout = False
        c.frame.tree.afterSelectHint(p,old_p)

    return val  # Don't put a return in a finally clause.
#@+node:ekr.20070423101911: *6* selectHelper (leoTree)
# Do **not** try to "optimize" this by returning if p==c.p.
# 2011/11/06: *event handlers* are called only if p != c.p.

def selectHelper (self,p,scroll):

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.p
    
    call_event_handlers = p != old_p

    if p:
        # 2009/10/10: selecting a foreign position
        # will not be pretty.
        assert p.v.context == c
    else:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace and (verbose or call_event_handlers):
        g.trace(p and p.h,g.callers())
            
    if call_event_handlers:
        unselect = not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    else:
        unselect = True

    if unselect:
        << unselect the old node >>
        
    if call_event_handlers:
        g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        
    if call_event_handlers:
        if call_event_handlers:
            select = not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        else:
            select = True
        if select:
            << select the new node >>
            c.nodeHistory.update(p) # Remember this position.
    else:
        if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
            << select the new node >>
            c.nodeHistory.update(p) # Remember this position.
        
    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    # if trace and (verbose or call_event_handlers):
        # g.trace('**** after old: %s new %s' % (
            # old_p and len(old_p.b),len(p.b)))

    # what UNL.py used to do
    c.frame.clearStatusLine()
    c.frame.putStatusLine(p.get_UNL())

    if call_event_handlers: # 2011/11/06
        g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
        g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
#@+node:ekr.20040803072955.129: *7* << unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
    
    # g.trace('set insert spot',insertSpot)
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p and old_p != p:
    # 2010/02/11: Don't change the *new* node's insert point!
    old_p.v.scrollBarSpot = yview
    old_p.v.insertSpot = insertSpot
    if g.trace_scroll: g.trace('old scroll: %s insert: %s' % (
        yview,insertSpot))
#@+node:ekr.20040803072955.130: *7* << select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.h
frame.setWrap(p)
self.setBodyTextAfterSelect(p,old_p)
#@+node:ekr.20040803072955.133: *7* << set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

# Was in ctor.
use_chapters = c.config.getBool('use_chapters')

if use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.h)

c.treeFocusHelper() # 2010/12/14
c.undoer.onSelect(old_p,p)
#@+node:ekr.20090608081524.6109: *6* setBodyTextAfterSelect
def setBodyTextAfterSelect (self,p,old_p):

    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c ; w = c.frame.body.bodyCtrl
    s = p.v.b # Guaranteed to be unicode.
    old_s = w.getAllText()

    if p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
        pass
    else:
        # w.setAllText destroys all color tags, so do a full recolor.
        w.setAllText(s,new_p=p)
        colorizer = c.frame.body.colorizer
        if hasattr(colorizer,'setHighlighter'):
            colorizer.setHighlighter(p)
        self.frame.body.recolor(p)

    p.restoreCursorAndScroll(w)
#@+node:ekr.20120311070142.9900: *4* Changed...
#@+node:ekr.20070615075643: *5* cc.selectChapterForPosition
def selectChapterForPosition (self,p):

    '''
    Select a chapter containing position p.
    Do nothing if p if p does not exist or is in the presently selected chapter.
    
    Note: this code calls c.redraw() if the chapter changes.
    '''

    trace = False and not g.unitTesting
    cc = self ; c = cc.c

    if not p:
        if trace: g.trace('no p')
        return
        
    if not c.positionExists(p):
        if trace: g.trace('does not exist',p.h) 
        return

    theChapter = cc.getSelectedChapter()
    if not theChapter:
        return

    if trace: g.trace('selected:',theChapter.name,'node',p.h)

    # First, try the presently selected chapter.
    firstName = theChapter.name
    if firstName == 'main':
        if trace: g.trace('no search: main chapter:',p.h)
        return

    if theChapter.positionIsInChapter(p):
        if trace: g.trace('position found in chapter:',theChapter.name,p.h)
        return

    for name in cc.chaptersDict:
        if name not in (firstName,'main'):
            theChapter = cc.chaptersDict.get(name)
            if theChapter.positionIsInChapter(p):
                if trace: g.trace('select:',theChapter.name)
                cc.selectChapterByName(name)
                return
    else:
        if trace: g.trace('select main')
        cc.selectChapterByName('main')
#@+node:ekr.20031218072017.2997: *5* c.selectPosition
def selectPosition(self,p):

    """Select a new position."""
    
    trace = False and not g.unitTesting
    c = self ; cc = c.chapterController

    if cc:
        cc.selectChapterForPosition(p)
            # Important: selectChapterForPosition calls c.redraw
            # if the chapter changes.
        if trace: g.trace(cc.selectedChapter,p.h)
        
    # 2012/03/08: De-hoist as necessary to make p visible.
    redraw_flag = False
    if c.hoistStack:
        while c.hoistStack:
            bunch = c.hoistStack[len(c.hoistStack)-1]
            if c.positionExists(p,bunch.p):
                break
            else:
                bunch = c.hoistStack.pop()
                redraw_flag = True
                if trace: g.trace('unhoist',bunch.p.h)

    if trace and not c.positionExists(p):
        g.trace('** does not exist: %s' % (p and p.h))

    c.frame.tree.select(p)

    # New in Leo 4.4.2.
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.
        
    if redraw_flag:
        c.redraw()

selectVnode = selectPosition
#@+node:ekr.20120312064830.9894: *3* Improved g.handleUrl and eliminated g.handleUrlInUrlNode
@nocolor-node

Improved g.handleUrl as follows:
    
- Automatically strip leading "@url".
- set p if possible.
- Handle {{expresssions}} in file urls.
- Always use webbrowser to open .html and .htm files.
#@+node:ekr.20050208101229: *4* << imports >> (leoGlobals)
if 0:
    # This is now done in run.
    import leoGlobals as g # So code can use g below.

# Don't import this here: it messes up Leo's startup code.
# import leo.core.leoTest as leoTest

try:
    import gc
except ImportError:
    gc = None

try:
    import filecmp
except ImportError: # does not exist in jython.
    filecmp = None

try:
    import gettext
except ImportError: # does not exist in jython.
    gettext = None

if isPython3:
    from functools import reduce

if isPython3:
    import io
    StringIO = io.StringIO
else:
    import cStringIO
    StringIO = cStringIO.StringIO

import imp
import inspect
import operator
import os

# Do NOT import pdb here!  We shall define pdb as a _function_ below.
# import pdb

import re
import shutil
import string
import subprocess
# import sys
import tempfile
import time
import traceback
import types

if isPython3:
    import urllib.parse as urlparse
else:
    import urlparse

# import zipfile

# These do not exist in IronPython.
# However, it *is* valid for IronPython to use the Python 2.4 libs!
    # import os
    # import string
    # import tempfile
    # import traceback
    # import types
#@+node:ekr.20080922124033.6: *4* g.os_path_expandExpression
def os_path_expandExpression (s,**keys):

    '''Expand {{anExpression}} in c's context.'''

    trace = False
    
    s1 = s
    c = keys.get('c')
    if not c:
        g.trace('can not happen: no c',g.callers())
        return s

    if not s:
        if trace: g.trace('no s')
        return ''

    i = s.find('{{')
    j = s.find('}}')
    if -1 < i < j:
        exp = s[i+2:j].strip()
        if exp:
            try:
                import os
                import sys
                p = c.p
                d = {'c':c,'g':g,'p':p,'os':os,'sys':sys,}
                val = eval(exp,d)
                s = s[:i] + str(val) + s[j+2:]
                if trace: g.trace('returns',s)
            except Exception:
                g.trace(g.callers())
                g.es_exception(full=True, c=c, color='red')

    return s
#@+node:ekr.20081006100835.1: *4* c.getNodePath & c.getNodeFileName
# Not used in Leo's core.
# Used by the UNl plugin.  Does not need to create a path.
def getNodePath (self,p):

    '''Return the path in effect at node p.'''

    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path

# Not used in Leo's core.
def getNodeFileName (self,p):

    '''Return the full file name at node p,
    including effects of all @path directives.

    Return None if p is no kind of @file node.'''

    c = self
    path = g.scanAllAtPathDirectives(c,p)
    name = ''
    for p in p.self_and_parents():
        name = p.anyAtFileNodeName()
        if name: break

    if name:
        name = g.os_path_finalize_join(path,name)
    return name
#@+node:ekr.20090829140232.6036: *4* g.os_startfile
def os_startfile(fname):
    
    if g.unitTesting:
        g.app.unitTestDict['os_startfile']=fname
        return
        
    if fname.find('"') > -1:
        quoted_fname = "'%s'" % fname
    else:
        quoted_fname = '"%s"' % fname

    if sys.platform.startswith('win'):
        os.startfile(quoted_fname)
            # Exists only on Windows.
    elif sys.platform == 'darwin':
        # From Marc-Antoine Parent.
        try:
            subprocess.call(['open', quoted_fname])
        except OSError:
            pass # There may be a spurious "Interrupted system call"
        except ImportError:
            os.system('open %s' % (quoted_fname))
    else:
        # os.system('xdg-open "%s"' % (fname))
        try:
            val = subprocess.call('xdg-open %s' % (quoted_fname),shell=True)
            if val < 0:
                g.es_print('xdg-open %s failed' % (fname))
        except Exception:
            g.es_print('error opening %s' % fname)
            g.es_exception()
#@+node:ekr.20120311151914.9916: *4* Urls... (leoGlobals.py)
kinds = '(file|ftp|gopher|http|https|mailto|news|nntp|prospero|telnet|wais)'
url_regex = re.compile(r"""%s://[^\s'"]+[\w=/]""" % (kinds))
#@+node:ekr.20120311151914.9917: *5* g.getUrlFromNode
def getUrlFromNode(p):
    
    '''Get an url from node p:
        
    1. Use the headline if it contains a valid url.
    2. Otherwise, look *only* at the first line of the body.
    '''
    
    line1 = g.splitLines(p.b)[0] if p.b else ''
    
    for s in (p.h,line1):
        if g.match_word(s,0,'@url'):
            url = s[4:].strip()
        else:
            url = s.strip()
        if g.isValidUrl(url):
            return url
    
    return None
#@+node:tbrown.20090219095555.63: *5* g.handleUrl
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file:///home/me/todolist.html
@c

def handleUrl(url,c=None,p=None):
    
    trace = False and not g.unitTesting ; verbose = False
    if c and not p:
        p = c.p
        
    if url.startswith('@url'):
        url = url[4:].lstrip()

    try:
        tag = 'file://'
        if url.startswith(tag):
            # First, replace special characters (especially %20, by their equivalent).
            url = urlparse.unquote(url)
            # Finalize the path *before* parsing the url.
            i = url.find('~')
            if i > -1:
                # Expand '~' and handle Leo expressions.
                path = url[i:]
                path = g.os_path_expanduser(path)
                path = g.os_path_expandExpression(path,c=c)
                path = g.os_path_finalize(path)
                url = url[:i] + path
            else:
                # Handle Leo expressions.
                path = url[len(tag):].lstrip()
                path = g.os_path_expandExpression(path,c=c)
                # Handle ancestor @path directives.
                if c and c.openDirectory:
                    base = c.getNodePath(p)
                    path = g.os_path_finalize_join(c.openDirectory,base,path)
                else:
                    path = g.os_path_finalize(path)
                url = '%s%s' % (tag,path)
                
        parsed   = urlparse.urlparse(url)
        fragment = parsed.fragment
        netloc   = parsed.netloc
        path     = parsed.path
        scheme   = parsed.scheme

        if netloc:
            leo_path = os.path.join(netloc, path)
            # "readme.txt" gets parsed into .netloc...
        else:
            leo_path = path
            
        if leo_path.endswith('\\'): leo_path = leo_path[:-1]
        if leo_path.endswith('/'):  leo_path = leo_path[:-1]
            
        if trace and verbose:
            print()
            g.trace('url          ',url)
            g.trace('c.frame.title',c.frame.title)
            g.trace('leo_path     ',leo_path)
            g.trace('parsed.netloc',netloc)
            g.trace('parsed.path  ',path)
            g.trace('parsed.scheme',scheme)

        if c and scheme in ('', 'file'):
            
            if not leo_path:
                # local UNLs like "node-->subnode", "-->node", and "#node"
                if '-->' in path:
                    g.recursiveUNLSearch(path.split("-->"), c)
                    return
                if not path and fragment:
                    g.recursiveUNLSearch(fragment.split("-->"), c)
                    return
    
            # .leo file
            if leo_path.lower().endswith('.leo') and os.path.exists(leo_path):
                # Immediately end editing, so that typing in the new window works properly.
                c.endEditing()
                c.redraw_now()
                if g.unitTesting:
                    g.app.unitTestDict['g.openWithFileName']=leo_path
                else:
                    c2 = g.openWithFileName(leo_path,old_c=c)
                    # with UNL after path
                    if c2 and fragment:
                        g.recursiveUNLSearch(fragment.split("-->"),c2)
                    if c2:
                        c2.bringToFront()
                        return

        isHtml = leo_path.endswith('.html') or leo_path.endswith('.htm')

        if not isHtml and scheme in ('', 'file'):
            if os.path.exists(leo_path):
                if trace: g.trace('g.os_startfile(%s)' % (leo_path))
                leo_path = urlparse.unquote(leo_path)
                g.os_startfile(leo_path)
                return
            if scheme == 'file':
                g.es("File '%s' does not exist"%leo_path)
                return
            
        import webbrowser

        if trace: g.trace('webbrowser.open(%s)' % (url))
        if g.unitTesting:
            g.app.unitTestDict['browser']=url
        else:
            # Mozilla throws a weird exception, then opens the file!
            try: webbrowser.open(url)
            except: pass
        
    except:
        g.es("exception opening",leo_path)
        g.es_exception()
#@+node:ekr.20120311151914.9918: *5* g.isValidUrl
def isValidUrl(url):
    
    '''Return true if url *looks* like a valid url.'''
    
    table = (
        'file','ftp','gopher','hdl','http','https','imap',
        'mailto','mms','news','nntp','prospero','rsync','rtsp','rtspu',
        'sftp','shttp','sip','sips','snews','svn','svn+ssh','telnet','wais',
    )

    if url.startswith('#-->'):
        # All Leo UNL's.
        return True
    elif url.startswith('@'):
        return False
    else:
        parsed = urlparse.urlparse(url)
        scheme = parsed.scheme
        # g.trace(scheme)
        for s in table:
            if scheme.startswith(s):
                return True
        return False
#@+node:ekr.20120315062642.9744: *5* g.openUrl
def openUrl(p):
    
    if not p:
        return
    
    url = g.getUrlFromNode(p)
    if url:
        c = p.v.context
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            g.handleUrl(url,c=c,p=p)
        g.doHook("@url2",c=c,p=p,v=p)
#@+node:ekr.20110605121601.18135: *5* g.openUrlOnClick (open-url-under-cursor)
@g.command('open-url-under-cursor')
def openUrlUnderCursor(event):
    return openUrlOnClick(event)
    
def openUrlOnClick(event):
    '''Open the URL under the cursor.  Return it for unit testing.'''
    c = event.get('c')
    if not c: return None
    w = c.frame.body.bodyCtrl
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    if i != j: return None # So find doesn't open the url.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    i,j = g.getLine(s,ins)
    line = s[i:j]
    for match in g.url_regex.finditer(line):
        if match.start() <= col < match.end(): # Don't open if we click after the url.
            url = match.group()
            if g.isValidUrl(url):
                p = c.p
                if not g.doHook("@url1",c=c,p=p,v=p,url=url):
                    g.handleUrl(url,c=c,p=p)
                g.doHook("@url2",c=c,p=p,v=p)
                return url
    return None
#@+node:ekr.20110605121601.18135: *4* g.openUrlOnClick (open-url-under-cursor)
@g.command('open-url-under-cursor')
def openUrlUnderCursor(event):
    return openUrlOnClick(event)
    
def openUrlOnClick(event):
    '''Open the URL under the cursor.  Return it for unit testing.'''
    c = event.get('c')
    if not c: return None
    w = c.frame.body.bodyCtrl
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    if i != j: return None # So find doesn't open the url.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    i,j = g.getLine(s,ins)
    line = s[i:j]
    for match in g.url_regex.finditer(line):
        if match.start() <= col < match.end(): # Don't open if we click after the url.
            url = match.group()
            if g.isValidUrl(url):
                p = c.p
                if not g.doHook("@url1",c=c,p=p,v=p,url=url):
                    g.handleUrl(url,c=c,p=p)
                g.doHook("@url2",c=c,p=p,v=p)
                return url
    return None
#@+node:ekr.20120203053243.10111: *3* Completed OpenWith menu
#@+node:ekr.20031218072017.2829: *4* c.openTempFileInExternalEditor
def openTempFileInExternalEditor(self,d,fn,testing=False):

    '''Open the closed mkstemp file fn in an external editor.
    The arg and openType args come from the data arg to c.openWith.
    '''

    trace = False and not g.unitTesting
    testing = testing or g.unitTesting
    
    def join(s1,s2):
        return '%s %s' % (s1,s2)
    
    if trace:
        print()
        g.trace(fn)
        for key in sorted(list(d.keys())):
            print('%15s %s' % (key,d.get(key)))
    
    arg_tuple = d.get('args',[])
    arg = ' '.join(arg_tuple)
    openType = d.get('kind')

    try:
        command = '<no command>'
        if openType == 'os.startfile':
            command = 'os.startfile(%s)' % join(arg,fn)
            if trace: g.trace(command)
            if not testing: os.startfile(join(arg,fn))
        elif openType == 'exec':
            command = 'exec(%s)' % join(arg,fn)
            if trace: g.trace(command)
            if not testing: exec(join(arg,fn),{},{})
        elif openType == 'os.spawnl':
            filename = g.os_path_basename(arg)
            command = 'os.spawnl(%s,%s,%s)' % (arg,filename,fn)
            if trace: g.trace(command)
            if not testing: os.spawnl(os.P_NOWAIT,arg,filename,fn)
        elif openType == 'os.spawnv':
            filename = os.path.basename(arg_tuple[0]) 
            vtuple = arg_tuple[1:]
            vtuple.insert(0, filename)
                # add the name of the program as the first argument.
                # Change suggested by Jim Sizelove.
            vtuple.append(fn)
            command = 'os.spawnv(%s)' % (vtuple)
            if trace: g.trace(command)
            if not testing:
                os.spawnv(os.P_NOWAIT,arg[0],vtuple) #???
        elif openType == 'subprocess.Popen':
            use_shell = True
            c_arg = join(arg,fn)
            command = 'subprocess.Popen(%s)' % c_arg
            if trace: g.trace(command)
            if not testing:
                try:
                    subprocess.Popen(c_arg,shell=use_shell)
                except OSError:
                    g.es_print('c_arg',repr(c_arg))
                    g.es_exception()
        elif g.isCallable(openType):
            # Invoke openWith like this:
            # c.openWith(data=[f,None,None])
            # f will be called with one arg, the filename
            if trace: g.trace('%s(%s)' % (openType,fn))
            command = '%s(%s)' % (openType,fn)
            if not testing: openType(fn)
        else:
            command='bad command:'+str(openType)
            if not testing: g.trace(command)
        return command # for unit testing.
    except Exception:
        g.es('exception executing open-with command:',command)
        g.es_exception()
        return 'oops: %s' % command
#@+node:ekr.20120227073551.11666: *4* @test c.openTempFileInExternalEditor
arg1 = 'arg1'
arg2 = 'arg2'
fn = 'fn'

table1 = (
    # ('os.system',       'os.system(arg1 fn)'),
    ('os.startfile',    'os.startfile(arg1 fn)'),
    ('exec',            'exec(arg1 fn)'),
    ('os.spawnl',       'os.spawnl(arg1,arg1,fn)'),
    ('subprocess.Popen','subprocess.Popen(arg1 fn)'),
    ('huh?',            'bad command:huh?'),
)

for kind,result in table1:
    d = {'kind':kind,'args':[arg1]}
    result2 = c.openTempFileInExternalEditor(d,fn,testing=True)
    assert result==result2,'kind %s expected %s, got %s' % (
        d.get('kind'),result,result2)
        
table2 = (
    ('os.spawnv',"os.spawnv(['arg1', 'arg2', 'fn'])"),
)
        
for kind,result in table2:
    d = {'kind':kind,'args':[arg1,arg2]}
    result2 = c.openTempFileInExternalEditor(d,fn,testing=True)
    assert result==result2,'kind %s expected %s, got %s' % (
        d.get('kind'),result,result2)
#@+node:ekr.20120205022040.17745: *4* @openwith docs (copy)
@language rest

@openwith nodes in @settings trees create menu items. The openWith
plugin must be active for these settings to have any effect.

The headline of an @openwith node has the form::

    @openwith name = shortcut
    
name is name of the menu item. shortcut specifies the shortcut used to invoke
the menu item. shortcut may be None.

The body text @openwith nodes should contain a single line contain a tuple of the form::

    command,arg,ext

For example::
    
    'subprocess.Popen',['pythonw','C:/Python24/Lib/idlelib/idle.pyw'],'.py'
    
When the user selects this menu item Leo executes command(arg+path) where path
is the full path to the temp file. The ext argument specifies the extension of
the temp file. Notes:

- command is a string.  Valid values are::
    
  'subprocess.Popen'
  'os.system'
  'os.startfile'
  'os.spawnl'
  'os.spawnv'
  'exec'
  
- arg is either a single string or a list of strings.

- ext is a string or None. If None, Leo computes a file extension base on what
  \@language directive is in effect.
  
- If the .leo file being loaded contains @openwith nodes, the File:Open With
menu contains only the items created by those nodes. Similarly, @openwith nodes
in myLeoSettings.leo override entries in leoSettings.leo.

- If no @openwith nodes are found anywhere the openWith plugin uses hard-coded
tables in the plugin itself.
#@+node:ekr.20120228111337.10057: *4* Creating the open-with menu
#@+node:ekr.20070926135612: *5* createMenusFromConfigList & helpers (leoMenu)
def createMenusFromConfigList (self,aList):

    '''Create menus from aList instead of 'hard coded' menus.
    The 'top' menu has already been created.'''

    c = self.c
    tag = '@menu'
    for z in aList:
        kind,val,val2 = z
        if kind.startswith(tag):
            name = kind[len(tag):].strip()
            if not self.handleSpecialMenus(name,parentName=None):
                self.createNewMenu(name) # Create top-level menu.
                self.createMenuFromConfigList(name,val,level=0)
        else:
            self.error('%s %s not valid outside @menu tree' % (kind,val))

    aList = c.config.getOpenWith()
    if aList:
        # a list of dicts.
        self.createOpenWithMenuFromTable(aList)
#@+node:ekr.20070927082205: *6* createMenuFromConfigList
def createMenuFromConfigList (self,parentName,aList,level=0):

    table = [] ; parentMenu = self.getMenu(parentName)

    for z in aList:
        kind,val,val2 = z
        if kind.startswith('@menu'):
            # Menu names can be unicode without any problem.
            name = kind[5:].strip()
            if table:
                self.createMenuEntries(parentMenu,table)
            if not self.handleSpecialMenus(name,parentName,table):
                self.createNewMenu(name,parentName) # Create submenu of parent menu.
                self.createMenuFromConfigList(name,val,level+1)
            table = []
        elif kind == '@item':
            name = str(val) # Item names must always be ascii.
            if val2:
                # Translated names can be unicode.
                table.append((val2,name),)
            else:
                table.append(name)
        else:
            g.trace('can not happen: bad kind:',kind)

    if table:
        self.createMenuEntries(parentMenu,table)
#@+node:ekr.20070927172712: *6* handleSpecialMenus
def handleSpecialMenus (self,name,parentName,table=None):

    '''Handle a special menu if name is the name of a special menu.
    return True if this method handles the menu.'''

    c = self.c
    if table is None: table = []
    name2 = name.replace('&','').replace(' ','').lower()

    if name2 == 'plugins':
        # Create the plugins menu using a hook.
        g.doHook("create-optional-menus",c=c)
        return True
    elif name2.startswith('recentfiles'):
        # Just create the menu.
        # createRecentFilesMenuItems will create the contents later.
        self.createNewMenu(name,parentName)
        return True
    elif name2 == 'help' and sys.platform == 'darwin':
        helpMenu = self.getMacHelpMenu(table)
        return helpMenu is not None
    else:
        return False
#@+node:ekr.20110605121601.18357: *5* createOpenWithMenu (QtMenu)
def createOpenWithMenu(self,parent,label,index,amp_index):

    '''Create the File:Open With submenu.

    This is called from leoMenu.createOpenWithMenuFromTable.'''

    # Use the existing Open With menu if possible.
    # g.trace(parent,label,index)

    menu = self.getMenu('openwith')

    if not menu:
        menu = self.new_menu(parent,tearoff=False,label=label)
        menu.insert_cascade(parent,index,
            label,menu,underline=amp_index)

    return menu
#@+node:ekr.20031218072017.4116: *5* createOpenWithMenuFromTable & helpers (leoMenu)
def createOpenWithMenuFromTable (self,table):

    '''table is a lists of dicts:
    
    - d.get('command'):  one of "os.startfile", "os.spawnl", "os.spawnv" or "exec".
    - d.get('shortcut'): the stroke (??)
    - d.get('name'):     the menu label.
    
    Leo executes command(arg+path) where path is the full path to the temp file.
    If ext is not None, the temp file has the given extension.
    Otherwise, Leo computes an extension based on the @language directive in effect.
'''

    trace = False and not g.unitTesting
    c,k = self.c,self.c.k
    if not table: return

    #### ?????
    g.app.openWithTable = table # Override any previous table.
    
    # Delete the previous entry.
    parent = self.getMenu("File")
    # if trace: g.trace('parent',parent)
    if not parent:
        if not g.app.batchMode:
            g.es('','createOpenWithMenuFromTable:','no File menu',color="red")
        return

    label = self.getRealMenuName("Open &With...")
    amp_index = label.find("&")
    label = label.replace("&","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except:
            g.trace('unexpected exception')
            g.es_exception()
            return
    
    # Create the Open With menu.
    openWithMenu = self.createOpenWithMenu(parent,label,index,amp_index)
    if not openWithMenu:
        g.trace('openWithMenu returns None')
        return
    
    self.setMenu("Open With...",openWithMenu)
    
    # Create the menu items in of the Open With menu.
    self.createOpenWithMenuItemsFromTable(openWithMenu,table)

    for d in table:
        k.bindOpenWith(d)
#@+node:ekr.20051022043608.1: *6* createOpenWithMenuItemsFromTable & callback (leoMenu)
def createOpenWithMenuItemsFromTable (self,menu,table):

    '''Create an entry in the Open with Menu from the table.

    Each entry should be a sequence with 2 or 3 elements.'''

    trace = False and not g.unitTesting
    # if trace: g.trace(g.callers())

    c = self.c ; k = c.k
    if g.app.unitTesting: return

    for d in table:
        label = d.get('name')
        args = d.get('args',[])
        if trace:
            print()
            for key in sorted(list(d.keys())):
                print('%15s %s' % (key,d.get(key)))

        accel = d.get('shortcut') or ''
        if label and args:
            realLabel = self.getRealMenuName(label)
            underline=realLabel.find("&")
            realLabel = realLabel.replace("&","")
            callback = self.defineOpenWithMenuCallback(d)
            c.add_command(menu,
                label=realLabel,
                accelerator=accel,
                command=callback,
                underline=underline)
#@+node:ekr.20031218072017.4118: *7* defineOpenWithMenuCallback (leoMenu)
def defineOpenWithMenuCallback(self,d):

    # The first parameter must be event, and it must default to None.
    def openWithMenuCallback(event=None,self=self,d=d):
        return self.c.openWith(d=d)

    return openWithMenuCallback
#@+node:ekr.20120227073551.10919: *4* Parsing open-with data
#@+node:ekr.20120215072959.12535: *5* c.config.getOpenWith
def getOpenWith (self):

    '''Return a list of dictionaries corresponding to @openwith nodes.'''

    val = self.get('openwithtable','openwithtable')

    return val
#@+node:ekr.20070411101643.1: *5* doOpenWith (ParserBaseClass)
def doOpenWith (self,p,kind,name,val):

    # g.trace(self.c.shortFileName(),'kind',kind,'name',name,'val',val)

    d = self.parseOpenWith(p)
    d['name']=name
    d['shortcut']=val
    # g.trace('command',d.get('command'))
    name = kind = 'openwithtable'
    self.openWithList.append(d)
    self.set(p,kind,name,self.openWithList)
#@+node:ekr.20070411101643.2: *5* parseOpenWith & helper
def parseOpenWith (self,p):

    d = {'command': None}
        # Old: command is a tuple.
        # New: d contains args, kind, etc tags.

    for line in g.splitLines(p.b):
        self.parseOpenWithLine(line,d)

    return d
#@+node:ekr.20070411101643.4: *6* parseOpenWithLine
def parseOpenWithLine (self,line,d):
    
    s = line.strip()
    if not s: return

    i = g.skip_ws(s,0)
    if g.match(s,i,'#'):
        return
    
    # try:
        # s = str(s)
    # except UnicodeError:
        # pass
        
    if 1: # new code
        j = g.skip_c_id(s,i)
        tag = s[i:j].strip()
        if not tag:
            g.es_print('@openwith lines must start with a tag: %s' % (s))
            return
        i = g.skip_ws(s,j)
        if not g.match(s,i,':'):
            g.es_print('colon must follow @openwith tag: %s' % (s))
            return
        i += 1
        val = s[i:].strip() or ''
            # An empty val is valid.
        if tag == 'arg':
            aList = d.get('args',[])
            aList.append(val)
            d['args'] = aList
        elif d.get(tag):
            g.es_print('ignoring duplicate definition of %s %s' % (tag,s))
        else:
            d[tag] = val
    else:
        d['command'] = s
#@+node:ekr.20120228111337.10058: *4* Handling the open-with data
#@+node:ekr.20031218072017.2823: *5* c.openWith and helpers
def openWith(self,event=None,d=None):

    '''This routine handles the items in the Open With... menu.

    The "d" arg is a Python dictionary whose keys and values
    are set from the body text of @openwith nodes.
    
    d.get('ext'):   The temp file's extension.
    d.get('kind'):  The method used to open the file.  One of:
        ('os.startfile','exec','os.spawnl':'os.spawnv'.'subprocess.Popen')
    d.get('args'):  A list of arguments specified by the arg tag.
    '''
    
    c = self ; p = c.p
    try:
        ext = d.get('ext')
        if not g.doHook('openwith1',c=c,p=p,v=p.v,d=d):
            ext = c.getOpenWithExt(p,ext)
            fn = c.openWithHelper(p,ext)
            if fn:
                g.enableIdleTimeHook(idleTimeDelay=500)
                c.openTempFileInExternalEditor(d,fn)
        g.doHook('openwith2',c=c,p=p,v=p.v,d=d)
    except Exception:
        g.es('unexpected exception in c.openWith')
        g.es_exception()
#@+node:ekr.20031218072017.2824: *6* c.getOpenWithExt
def getOpenWithExt (self,p,ext):

    trace = False and not g.app.unitTesting
    if trace: g.trace(ext)
    
    c = self
    
    if ext:
        for ch in ("'",'"'):
            if ext.startswith(ch): ext = ext.strip(ch)

    if not ext:
        # if node is part of @<file> tree, get ext from file name
        for p2 in p.self_and_parents():
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None,1)[1]
                ext = g.os_path_splitext(fn)[1]
                if trace: g.trace('found node:',ext,p2.h)
                break

    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
        if trace: g.trace('found directive',language,ext)

    if not ext:
        ext = '.txt'
        if trace: g.trace('use default (.txt)')

    if ext[0] != '.':
        ext = '.'+ext
        
    if trace: g.trace(ext)

    return ext
#@+node:ekr.20031218072017.2829: *6* c.openTempFileInExternalEditor
def openTempFileInExternalEditor(self,d,fn,testing=False):

    '''Open the closed mkstemp file fn in an external editor.
    The arg and openType args come from the data arg to c.openWith.
    '''

    trace = False and not g.unitTesting
    testing = testing or g.unitTesting
    
    def join(s1,s2):
        return '%s %s' % (s1,s2)
    
    if trace:
        print()
        g.trace(fn)
        for key in sorted(list(d.keys())):
            print('%15s %s' % (key,d.get(key)))
    
    arg_tuple = d.get('args',[])
    arg = ' '.join(arg_tuple)
    openType = d.get('kind')

    try:
        command = '<no command>'
        if openType == 'os.startfile':
            command = 'os.startfile(%s)' % join(arg,fn)
            if trace: g.trace(command)
            if not testing: os.startfile(join(arg,fn))
        elif openType == 'exec':
            command = 'exec(%s)' % join(arg,fn)
            if trace: g.trace(command)
            if not testing: exec(join(arg,fn),{},{})
        elif openType == 'os.spawnl':
            filename = g.os_path_basename(arg)
            command = 'os.spawnl(%s,%s,%s)' % (arg,filename,fn)
            if trace: g.trace(command)
            if not testing: os.spawnl(os.P_NOWAIT,arg,filename,fn)
        elif openType == 'os.spawnv':
            filename = os.path.basename(arg_tuple[0]) 
            vtuple = arg_tuple[1:]
            vtuple.insert(0, filename)
                # add the name of the program as the first argument.
                # Change suggested by Jim Sizelove.
            vtuple.append(fn)
            command = 'os.spawnv(%s)' % (vtuple)
            if trace: g.trace(command)
            if not testing:
                os.spawnv(os.P_NOWAIT,arg[0],vtuple) #???
        elif openType == 'subprocess.Popen':
            use_shell = True
            c_arg = join(arg,fn)
            command = 'subprocess.Popen(%s)' % c_arg
            if trace: g.trace(command)
            if not testing:
                try:
                    subprocess.Popen(c_arg,shell=use_shell)
                except OSError:
                    g.es_print('c_arg',repr(c_arg))
                    g.es_exception()
        elif g.isCallable(openType):
            # Invoke openWith like this:
            # c.openWith(data=[f,None,None])
            # f will be called with one arg, the filename
            if trace: g.trace('%s(%s)' % (openType,fn))
            command = '%s(%s)' % (openType,fn)
            if not testing: openType(fn)
        else:
            command='bad command:'+str(openType)
            if not testing: g.trace(command)
        return command # for unit testing.
    except Exception:
        g.es('exception executing open-with command:',command)
        g.es_exception()
        return 'oops: %s' % command
#@+node:ekr.20100203050306.5797: *6* c.openWithHelper
def openWithHelper (self,p,ext):

    '''create or reopen a temp file for p,
    testing for conflicting changes.
    '''

    c = self

    # May be over-ridden by mod_tempfname plugin.
    searchPath = c.openWithTempFilePath(p,ext)
    if not searchPath:
        # Check the mod_tempfname plugin.
        return g.trace('c.openWithTempFilePath failed',color='red')

    # Set d and path if a temp file already refers to p.v
    path = None
    if g.os_path_exists(searchPath):
        for d in g.app.openWithFiles:
            if p.v == d.get('v') and searchPath == d.get('path'):
                path = searchPath ; break

    if path:
        assert d.get('path') == searchPath
        fn = c.createOrRecreateTempFileAsNeeded(p,d,ext)
    else:
        fn = c.createOpenWithTempFile(p,ext)

    return fn # fn may be None.
#@+node:ekr.20031218072017.2827: *7* c.createOrRecreateTempFileAsNeeded
conflict_message = '''
Conflicting changes in outline and temp file.
Do you want to use the data in the outline?
Yes: use the data in the outline.
No: use the data in the temp file.
Cancel or Escape or Return: do nothing.
'''

def createOrRecreateTempFileAsNeeded (self,p,d,ext):

    '''test for changes in both p and the temp file:

    - If only p's body text has changed, we recreate the temp file.
    - If only the temp file has changed, do nothing here.
    - If both have changed we must prompt the user to see which code to use.

    Return the file name.
    '''
    c = self

    fn = d.get('path')
    # Get the old & new body text and modification times.
    encoding = d.get('encoding')
    old_body = d.get('body')
    new_body = g.toEncodedString(p.b,encoding,reportErrors=True)
    old_time = d.get('time')
    try:
        new_time = g.os_path_getmtime(fn)
    except Exception:
        new_time = None
    body_changed = old_body != new_body
    time_changed = old_time != new_time

    if body_changed and time_changed:
        g.es_print('Conflict in temp file for',p.h,color='red')
        result = g.app.gui.runAskYesNoCancelDialog(c,
            'Conflict!', c.conflict_message,
            yesMessage = 'Outline',
            noMessage = 'File',
            defaultButton = 'Cancel')
        if result is None or result.lower() == 'cancel':
            return False
        rewrite = result.lower() == 'yes'
    else:
        rewrite = body_changed

    if rewrite:
        # May be overridden by the mod_tempfname plugin.
        fn = c.createOpenWithTempFile(p,ext)
    else:
        g.es('reopening:',g.shortFileName(fn),color='blue')

    return fn
#@+node:ekr.20100203050306.5937: *7* c.createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    trace = False and not g.unitTesting
    c = self ; f = None

    # May be over-ridden by mod_tempfname plugin.
    fn = c.openWithTempFilePath(p,ext)

    try:
        if not g.unitTesting:
            if g.os_path_exists(fn):
                g.es('recreating:  ',g.shortFileName(fn),color='red')
            else:
                g.es('creating:  ',g.shortFileName(fn),color='blue')
        f = open(fn,'w')
        # Convert s to whatever encoding is in effect.
        d = c.scanAllDirectives(p)
        encoding = d.get('encoding',None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        if g.isPython3: # 2010/02/09
            s = p.b
        else:
            s = g.toEncodedString(p.b,encoding,reportErrors=True) 
        f.write(s)
        f.flush()
        f.close()
        try:
            time = g.os_path_getmtime(fn)
            if time and not g.unitTesting:
                g.es('time: ',time)
        except:
            time = None

        # Remove previous entry from app.openWithFiles if it exists.
        for d in g.app.openWithFiles[:]:
            if p.v == d.get('v'):
                if trace: g.trace('removing',d.get('path'))
                g.app.openWithFiles.remove(d)

        d = {
            # Used by app.destroyOpenWithFilesForFrame.
            'c':c,
            # Used here and by app.destroyOpenWithFileWithDict.
            'path':fn,
            # Used by c.testForConflicts.
            'body':s,
            'encoding':encoding,
            'time':time,
            # Used by the open_with plugin.
            'p':p.copy(),
            # Used by c.openWithHelper, and below.
            'v':p.v,
        }
        g.app.openWithFiles.append(d)
        return fn
    except:
        if f: f.close()
        g.es('exception creating temp file',color='red')
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2832: *6* c.openWithTempFilePath (may be over-ridden)
def openWithTempFilePath (self,p,ext):

    '''Return the path to the temp file corresponding to p and ext.

    This is overridden in mod_tempfname plugin
    '''

    fn = '%s_LeoTemp_%s%s' % (
        g.sanitize_filename(p.h),
        str(id(p.v)),ext)
    if g.isPython3: # 2010/02/07
        fn = g.toUnicode(fn)
    td = g.os_path_finalize(tempfile.gettempdir())
    path = g.os_path_join(td,fn)

    return path
#@+node:ekr.20120228111337.10059: *4* Newly changed code
#@+node:ekr.20070411101643.2: *5* parseOpenWith & helper
def parseOpenWith (self,p):

    d = {'command': None}
        # Old: command is a tuple.
        # New: d contains args, kind, etc tags.

    for line in g.splitLines(p.b):
        self.parseOpenWithLine(line,d)

    return d
#@+node:ekr.20070411101643.4: *6* parseOpenWithLine
def parseOpenWithLine (self,line,d):
    
    s = line.strip()
    if not s: return

    i = g.skip_ws(s,0)
    if g.match(s,i,'#'):
        return
    
    # try:
        # s = str(s)
    # except UnicodeError:
        # pass
        
    if 1: # new code
        j = g.skip_c_id(s,i)
        tag = s[i:j].strip()
        if not tag:
            g.es_print('@openwith lines must start with a tag: %s' % (s))
            return
        i = g.skip_ws(s,j)
        if not g.match(s,i,':'):
            g.es_print('colon must follow @openwith tag: %s' % (s))
            return
        i += 1
        val = s[i:].strip() or ''
            # An empty val is valid.
        if tag == 'arg':
            aList = d.get('args',[])
            aList.append(val)
            d['args'] = aList
        elif d.get(tag):
            g.es_print('ignoring duplicate definition of %s %s' % (tag,s))
        else:
            d[tag] = val
    else:
        d['command'] = s
#@+node:ekr.20061031131434.94: *5* k.bindOpenWith
def bindOpenWith (self,d):

    '''Register an open-with command.'''

    k = self ; c = k.c
    
    shortcut = d.get('shortcut')
    name = d.get('name')
    
    # g.trace(d)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,d=d):
        return c.openWith(d=d)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='all',verbose=False)
#@+node:ekr.20031218072017.4116: *5* createOpenWithMenuFromTable & helpers (leoMenu)
def createOpenWithMenuFromTable (self,table):

    '''table is a lists of dicts:
    
    - d.get('command'):  one of "os.startfile", "os.spawnl", "os.spawnv" or "exec".
    - d.get('shortcut'): the stroke (??)
    - d.get('name'):     the menu label.
    
    Leo executes command(arg+path) where path is the full path to the temp file.
    If ext is not None, the temp file has the given extension.
    Otherwise, Leo computes an extension based on the @language directive in effect.
'''

    trace = False and not g.unitTesting
    c,k = self.c,self.c.k
    if not table: return

    #### ?????
    g.app.openWithTable = table # Override any previous table.
    
    # Delete the previous entry.
    parent = self.getMenu("File")
    # if trace: g.trace('parent',parent)
    if not parent:
        if not g.app.batchMode:
            g.es('','createOpenWithMenuFromTable:','no File menu',color="red")
        return

    label = self.getRealMenuName("Open &With...")
    amp_index = label.find("&")
    label = label.replace("&","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except:
            g.trace('unexpected exception')
            g.es_exception()
            return
    
    # Create the Open With menu.
    openWithMenu = self.createOpenWithMenu(parent,label,index,amp_index)
    if not openWithMenu:
        g.trace('openWithMenu returns None')
        return
    
    self.setMenu("Open With...",openWithMenu)
    
    # Create the menu items in of the Open With menu.
    self.createOpenWithMenuItemsFromTable(openWithMenu,table)

    for d in table:
        k.bindOpenWith(d)
#@+node:ekr.20051022043608.1: *6* createOpenWithMenuItemsFromTable & callback (leoMenu)
def createOpenWithMenuItemsFromTable (self,menu,table):

    '''Create an entry in the Open with Menu from the table.

    Each entry should be a sequence with 2 or 3 elements.'''

    trace = False and not g.unitTesting
    # if trace: g.trace(g.callers())

    c = self.c ; k = c.k
    if g.app.unitTesting: return

    for d in table:
        label = d.get('name')
        args = d.get('args',[])
        if trace:
            print()
            for key in sorted(list(d.keys())):
                print('%15s %s' % (key,d.get(key)))

        accel = d.get('shortcut') or ''
        if label and args:
            realLabel = self.getRealMenuName(label)
            underline=realLabel.find("&")
            realLabel = realLabel.replace("&","")
            callback = self.defineOpenWithMenuCallback(d)
            c.add_command(menu,
                label=realLabel,
                accelerator=accel,
                command=callback,
                underline=underline)
#@+node:ekr.20031218072017.4118: *7* defineOpenWithMenuCallback (leoMenu)
def defineOpenWithMenuCallback(self,d):

    # The first parameter must be event, and it must default to None.
    def openWithMenuCallback(event=None,self=self,d=d):
        return self.c.openWith(d=d)

    return openWithMenuCallback
#@+node:ekr.20031218072017.2823: *5* c.openWith and helpers
def openWith(self,event=None,d=None):

    '''This routine handles the items in the Open With... menu.

    The "d" arg is a Python dictionary whose keys and values
    are set from the body text of @openwith nodes.
    
    d.get('ext'):   The temp file's extension.
    d.get('kind'):  The method used to open the file.  One of:
        ('os.startfile','exec','os.spawnl':'os.spawnv'.'subprocess.Popen')
    d.get('args'):  A list of arguments specified by the arg tag.
    '''
    
    c = self ; p = c.p
    try:
        ext = d.get('ext')
        if not g.doHook('openwith1',c=c,p=p,v=p.v,d=d):
            ext = c.getOpenWithExt(p,ext)
            fn = c.openWithHelper(p,ext)
            if fn:
                g.enableIdleTimeHook(idleTimeDelay=500)
                c.openTempFileInExternalEditor(d,fn)
        g.doHook('openwith2',c=c,p=p,v=p.v,d=d)
    except Exception:
        g.es('unexpected exception in c.openWith')
        g.es_exception()
#@+node:ekr.20031218072017.2824: *6* c.getOpenWithExt
def getOpenWithExt (self,p,ext):

    trace = False and not g.app.unitTesting
    if trace: g.trace(ext)
    
    c = self
    
    if ext:
        for ch in ("'",'"'):
            if ext.startswith(ch): ext = ext.strip(ch)

    if not ext:
        # if node is part of @<file> tree, get ext from file name
        for p2 in p.self_and_parents():
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None,1)[1]
                ext = g.os_path_splitext(fn)[1]
                if trace: g.trace('found node:',ext,p2.h)
                break

    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
        if trace: g.trace('found directive',language,ext)

    if not ext:
        ext = '.txt'
        if trace: g.trace('use default (.txt)')

    if ext[0] != '.':
        ext = '.'+ext
        
    if trace: g.trace(ext)

    return ext
#@+node:ekr.20031218072017.2829: *6* c.openTempFileInExternalEditor
def openTempFileInExternalEditor(self,d,fn,testing=False):

    '''Open the closed mkstemp file fn in an external editor.
    The arg and openType args come from the data arg to c.openWith.
    '''

    trace = False and not g.unitTesting
    testing = testing or g.unitTesting
    
    def join(s1,s2):
        return '%s %s' % (s1,s2)
    
    if trace:
        print()
        g.trace(fn)
        for key in sorted(list(d.keys())):
            print('%15s %s' % (key,d.get(key)))
    
    arg_tuple = d.get('args',[])
    arg = ' '.join(arg_tuple)
    openType = d.get('kind')

    try:
        command = '<no command>'
        if openType == 'os.startfile':
            command = 'os.startfile(%s)' % join(arg,fn)
            if trace: g.trace(command)
            if not testing: os.startfile(join(arg,fn))
        elif openType == 'exec':
            command = 'exec(%s)' % join(arg,fn)
            if trace: g.trace(command)
            if not testing: exec(join(arg,fn),{},{})
        elif openType == 'os.spawnl':
            filename = g.os_path_basename(arg)
            command = 'os.spawnl(%s,%s,%s)' % (arg,filename,fn)
            if trace: g.trace(command)
            if not testing: os.spawnl(os.P_NOWAIT,arg,filename,fn)
        elif openType == 'os.spawnv':
            filename = os.path.basename(arg_tuple[0]) 
            vtuple = arg_tuple[1:]
            vtuple.insert(0, filename)
                # add the name of the program as the first argument.
                # Change suggested by Jim Sizelove.
            vtuple.append(fn)
            command = 'os.spawnv(%s)' % (vtuple)
            if trace: g.trace(command)
            if not testing:
                os.spawnv(os.P_NOWAIT,arg[0],vtuple) #???
        elif openType == 'subprocess.Popen':
            use_shell = True
            c_arg = join(arg,fn)
            command = 'subprocess.Popen(%s)' % c_arg
            if trace: g.trace(command)
            if not testing:
                try:
                    subprocess.Popen(c_arg,shell=use_shell)
                except OSError:
                    g.es_print('c_arg',repr(c_arg))
                    g.es_exception()
        elif g.isCallable(openType):
            # Invoke openWith like this:
            # c.openWith(data=[f,None,None])
            # f will be called with one arg, the filename
            if trace: g.trace('%s(%s)' % (openType,fn))
            command = '%s(%s)' % (openType,fn)
            if not testing: openType(fn)
        else:
            command='bad command:'+str(openType)
            if not testing: g.trace(command)
        return command # for unit testing.
    except Exception:
        g.es('exception executing open-with command:',command)
        g.es_exception()
        return 'oops: %s' % command
#@+node:ekr.20100203050306.5797: *6* c.openWithHelper
def openWithHelper (self,p,ext):

    '''create or reopen a temp file for p,
    testing for conflicting changes.
    '''

    c = self

    # May be over-ridden by mod_tempfname plugin.
    searchPath = c.openWithTempFilePath(p,ext)
    if not searchPath:
        # Check the mod_tempfname plugin.
        return g.trace('c.openWithTempFilePath failed',color='red')

    # Set d and path if a temp file already refers to p.v
    path = None
    if g.os_path_exists(searchPath):
        for d in g.app.openWithFiles:
            if p.v == d.get('v') and searchPath == d.get('path'):
                path = searchPath ; break

    if path:
        assert d.get('path') == searchPath
        fn = c.createOrRecreateTempFileAsNeeded(p,d,ext)
    else:
        fn = c.createOpenWithTempFile(p,ext)

    return fn # fn may be None.
#@+node:ekr.20031218072017.2827: *7* c.createOrRecreateTempFileAsNeeded
conflict_message = '''
Conflicting changes in outline and temp file.
Do you want to use the data in the outline?
Yes: use the data in the outline.
No: use the data in the temp file.
Cancel or Escape or Return: do nothing.
'''

def createOrRecreateTempFileAsNeeded (self,p,d,ext):

    '''test for changes in both p and the temp file:

    - If only p's body text has changed, we recreate the temp file.
    - If only the temp file has changed, do nothing here.
    - If both have changed we must prompt the user to see which code to use.

    Return the file name.
    '''
    c = self

    fn = d.get('path')
    # Get the old & new body text and modification times.
    encoding = d.get('encoding')
    old_body = d.get('body')
    new_body = g.toEncodedString(p.b,encoding,reportErrors=True)
    old_time = d.get('time')
    try:
        new_time = g.os_path_getmtime(fn)
    except Exception:
        new_time = None
    body_changed = old_body != new_body
    time_changed = old_time != new_time

    if body_changed and time_changed:
        g.es_print('Conflict in temp file for',p.h,color='red')
        result = g.app.gui.runAskYesNoCancelDialog(c,
            'Conflict!', c.conflict_message,
            yesMessage = 'Outline',
            noMessage = 'File',
            defaultButton = 'Cancel')
        if result is None or result.lower() == 'cancel':
            return False
        rewrite = result.lower() == 'yes'
    else:
        rewrite = body_changed

    if rewrite:
        # May be overridden by the mod_tempfname plugin.
        fn = c.createOpenWithTempFile(p,ext)
    else:
        g.es('reopening:',g.shortFileName(fn),color='blue')

    return fn
#@+node:ekr.20100203050306.5937: *7* c.createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    trace = False and not g.unitTesting
    c = self ; f = None

    # May be over-ridden by mod_tempfname plugin.
    fn = c.openWithTempFilePath(p,ext)

    try:
        if not g.unitTesting:
            if g.os_path_exists(fn):
                g.es('recreating:  ',g.shortFileName(fn),color='red')
            else:
                g.es('creating:  ',g.shortFileName(fn),color='blue')
        f = open(fn,'w')
        # Convert s to whatever encoding is in effect.
        d = c.scanAllDirectives(p)
        encoding = d.get('encoding',None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        if g.isPython3: # 2010/02/09
            s = p.b
        else:
            s = g.toEncodedString(p.b,encoding,reportErrors=True) 
        f.write(s)
        f.flush()
        f.close()
        try:
            time = g.os_path_getmtime(fn)
            if time and not g.unitTesting:
                g.es('time: ',time)
        except:
            time = None

        # Remove previous entry from app.openWithFiles if it exists.
        for d in g.app.openWithFiles[:]:
            if p.v == d.get('v'):
                if trace: g.trace('removing',d.get('path'))
                g.app.openWithFiles.remove(d)

        d = {
            # Used by app.destroyOpenWithFilesForFrame.
            'c':c,
            # Used here and by app.destroyOpenWithFileWithDict.
            'path':fn,
            # Used by c.testForConflicts.
            'body':s,
            'encoding':encoding,
            'time':time,
            # Used by the open_with plugin.
            'p':p.copy(),
            # Used by c.openWithHelper, and below.
            'v':p.v,
        }
        g.app.openWithFiles.append(d)
        return fn
    except:
        if f: f.close()
        g.es('exception creating temp file',color='red')
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2832: *6* c.openWithTempFilePath (may be over-ridden)
def openWithTempFilePath (self,p,ext):

    '''Return the path to the temp file corresponding to p and ext.

    This is overridden in mod_tempfname plugin
    '''

    fn = '%s_LeoTemp_%s%s' % (
        g.sanitize_filename(p.h),
        str(id(p.v)),ext)
    if g.isPython3: # 2010/02/07
        fn = g.toUnicode(fn)
    td = g.os_path_finalize(tempfile.gettempdir())
    path = g.os_path_join(td,fn)

    return path
#@+node:ekr.20031218072017.2829: *5* c.openTempFileInExternalEditor
def openTempFileInExternalEditor(self,d,fn,testing=False):

    '''Open the closed mkstemp file fn in an external editor.
    The arg and openType args come from the data arg to c.openWith.
    '''

    trace = False and not g.unitTesting
    testing = testing or g.unitTesting
    
    def join(s1,s2):
        return '%s %s' % (s1,s2)
    
    if trace:
        print()
        g.trace(fn)
        for key in sorted(list(d.keys())):
            print('%15s %s' % (key,d.get(key)))
    
    arg_tuple = d.get('args',[])
    arg = ' '.join(arg_tuple)
    openType = d.get('kind')

    try:
        command = '<no command>'
        if openType == 'os.startfile':
            command = 'os.startfile(%s)' % join(arg,fn)
            if trace: g.trace(command)
            if not testing: os.startfile(join(arg,fn))
        elif openType == 'exec':
            command = 'exec(%s)' % join(arg,fn)
            if trace: g.trace(command)
            if not testing: exec(join(arg,fn),{},{})
        elif openType == 'os.spawnl':
            filename = g.os_path_basename(arg)
            command = 'os.spawnl(%s,%s,%s)' % (arg,filename,fn)
            if trace: g.trace(command)
            if not testing: os.spawnl(os.P_NOWAIT,arg,filename,fn)
        elif openType == 'os.spawnv':
            filename = os.path.basename(arg_tuple[0]) 
            vtuple = arg_tuple[1:]
            vtuple.insert(0, filename)
                # add the name of the program as the first argument.
                # Change suggested by Jim Sizelove.
            vtuple.append(fn)
            command = 'os.spawnv(%s)' % (vtuple)
            if trace: g.trace(command)
            if not testing:
                os.spawnv(os.P_NOWAIT,arg[0],vtuple) #???
        elif openType == 'subprocess.Popen':
            use_shell = True
            c_arg = join(arg,fn)
            command = 'subprocess.Popen(%s)' % c_arg
            if trace: g.trace(command)
            if not testing:
                try:
                    subprocess.Popen(c_arg,shell=use_shell)
                except OSError:
                    g.es_print('c_arg',repr(c_arg))
                    g.es_exception()
        elif g.isCallable(openType):
            # Invoke openWith like this:
            # c.openWith(data=[f,None,None])
            # f will be called with one arg, the filename
            if trace: g.trace('%s(%s)' % (openType,fn))
            command = '%s(%s)' % (openType,fn)
            if not testing: openType(fn)
        else:
            command='bad command:'+str(openType)
            if not testing: g.trace(command)
        return command # for unit testing.
    except Exception:
        g.es('exception executing open-with command:',command)
        g.es_exception()
        return 'oops: %s' % command
#@+node:ekr.20110929165422.15449: *3* tested section reference fix
@nocolor-node

*** Important *** This was all done in Leo 4.9

See: http://groups.google.com/group/leo-editor/browse_thread/thread/3cd5cb06d32264d

> What would work for me is if named sections in a @rst subtree
> would work exactly as they work for other derived files: they
> get inserted at the place where they are referenced.

- Add support for the following options:
    - expand_noweb_references:  default False for compatibility.
    - ignore_noweb definitions: default False for compatibility.

- When expand_noweb_references is True, definitions (typically clones)
  must be descendants of the referencing node (in the @rst tree)
#@+node:ekr.20111018104244.15918: *4* Report
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/15239f5f504cee6f

I tried it out with:

Test
.....@rst test.html
      which contains:
      This is a test (underlined)
      then the reference:
      <<test>>
...............<<test>>
                which contains: Here is some text.

In the top node Test I have:
@ @rst-options
expand_noweb_references=True
expand_noweb_recursively=True
show_headlines=False  (without this, the <<test>> headline becomes a section
heading)
@c

It sort of works:
--------------------------------------------
This is a test

<<test>>Here is some text.

Here is some text.
--------------------------------------------

The reference <<test>> does not get erased, even if the definition actually
gets inserted beside it. On the other hand, though I can suppress the
headline of the definition with the rst option, the body of the definition
gets inserted as a section anyway; definitions are not ignored by rst.

But now I can go see what happens in the code for debugging, since the
option gives a pointer into the code.

Thanks!
#@+node:ekr.20100813041139.5920: *4* Entry points
#@+node:ekr.20100812082517.5945: *5* code_to_rst_command & helpers
def code_to_rst_command (self,event=None,p=None,scriptSettingsDict=None,toString=False):

    '''Format the presently selected node as computer code.

    Settings from scriptSettingsDict override normal settings.

    On exit:
        self.source contains rst sources
        self.stringOutput contains docutils output if docutils called.
    '''

    trace = False and not g.unitTesting
    c = self.c
    if p: p = p.copy()
    else: p = c.p
    self.topNode = p.copy()
    self.topLevel = p.level()

    # **Important**: This command works as much like the rst3 command as possible.
    # Difference arise because there is no @rst node to specify a filename.
    # Instead we get the filename from scriptSettingsDict, or use 'code_to_rst.html'

    # Capture the settings, munging all settings.
    self.scriptSettingsDict = {}
    d = scriptSettingsDict
    if d:
        for key in d.keys():
            self.scriptSettingsDict[self.munge(key)] = d.get(key)

    # Init options...
    self.preprocessTree(p)
    self.init_write(p) # scanAllDirectives sets self.path and self.encoding.
    self.scanAllOptions(p) # Settings for p are valid after this call.
    callDocutils = self.getOption('call_docutils')
    writeIntermediateFile = self.getOption('write_intermediate_file')
    fn = self.getOption('output-file-name') or 'code_to_rst.html'
    junk,ext = g.os_path_splitext(fn)

    # Write the rst sources to self.sources...
    self.outputFile = StringIO()
    self.write_code_tree(p,fn)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if callDocutils or writeIntermediateFile:
        self.write_files(ext,fn,callDocutils,toString,writeIntermediateFile)
#@+node:ekr.20100812082517.5963: *6* write_code_body & helpers
def write_code_body (self,p):

    trace = False
    self.p = p.copy() # for traces.
    if not p.b.strip():
        return # No need to write any more newlines.

    showDocsAsParagraphs = self.getOption('show_doc_parts_as_paragraphs')
    lines = g.splitLines(p.b)
    parts = self.split_parts(lines,showDocsAsParagraphs)
    result = []
    for kind,lines in parts:
        if trace: g.trace(kind,len(lines),p.h)
        if kind == '@rst-option': # Also handles '@rst-options'
            pass # The prepass has already handled the options.
        elif kind == '@rst-markup':
            lines.extend('\n')
            result.extend(lines)
        elif kind == '@doc':
            if showDocsAsParagraphs:
                result.extend(lines)
                result.append('\n')
            else:
                result.extend(self.write_code_block(lines))
        elif kind == 'code':
            result.extend(self.write_code_block(lines))
        else:
            g.trace('Can not happen',kind)

    # Write the lines with exactly two trailing newlines.
    s = ''.join(result).rstrip() + '\n\n'
    self.write(s)
#@+node:ekr.20100812082517.5964: *7* split_parts
def split_parts (self,lines,showDocsAsParagraphs):

    '''Split a list of body lines into a list of tuples (kind,lines).'''

    kind,parts,part_lines = 'code',[],[]
    for s in lines:
        if g.match_word(s,0,'@ @rst-markup'):
            if part_lines: parts.append((kind,part_lines[:]),)
            kind = '@rst-markup'
            n = len('@ @rst-markup')
            after = s[n:].strip()
            part_lines = g.choose(after,[after],[])
        elif s.startswith('@ @rst-option'):
            if part_lines: parts.append((kind,part_lines[:]),)
            kind,part_lines = '@rst-option',[s] # part_lines will be ignored.
        elif s.startswith('@ ') or s.startswith('@\n') or s.startswith('@doc'):
            if showDocsAsParagraphs:
                if part_lines: parts.append((kind,part_lines[:]),)
                kind = '@doc'
                # Put only what follows @ or @doc
                n = g.choose(s.startswith('@doc'),4,1)
                after = s[n:].lstrip()
                part_lines = g.choose(after,[after],[])
            else:
                part_lines.append(s) # still in code mode.
        elif g.match_word(s,0,'@c') and kind != 'code':
            if kind == '@doc' and not showDocsAsParagraphs:
                part_lines.append(s) # Show the @c as code.
            parts.append((kind,part_lines[:]),)
            kind,part_lines = 'code',[]
        else:
            part_lines.append(s)

    if part_lines:
        parts.append((kind,part_lines[:]),)

    return parts
#@+node:ekr.20100812082517.5965: *7* write_code_block
def write_code_block (self,lines):

    result = ['::\n\n'] # ['[**code block**]\n\n']

    if self.getOption('number-code-lines'):
        i = 1
        for s in lines:
            result.append('    %d: %s' % (i,s))
            i += 1
    else:
        result.extend(['    %s' % (z) for z in lines])

    s = ''.join(result).rstrip()+'\n\n'
    return g.splitLines(s)
#@+node:ekr.20100812082517.5966: *6* write_code_headline & helper
def write_code_headline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''


    docOnly             = self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.write_code_headline_helper(p)
#@+node:ekr.20100812082517.5967: *7* write_code_headline_helper
def write_code_headline_helper (self,p):

    h = p.h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0)
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip()
    if word:
        # Never generate a section for @rst-option or @rst-options or @rst-no-head.
        if word in ('@rst-option','@rst-options','@rst-no-head','@rst-no-headlines'):
            return

        for prefix in ('@rst-ignore-node','@rst-ignore-tree','@rst-ignore'):
            if word == prefix:
                h = h [len(word):].strip()
                break

    if not h.strip(): return

    if self.getOption('show_sections'):
        self.write(self.underline(h,p))
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
#@+node:ekr.20100812082517.5968: *6* write_code_node
def write_code_node (self,p):

    '''Format a node according to the options presently in effect.

    Side effect: advance p'''

    h = p.h.strip()
    self.scanAllOptions(p)

    if self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.write_code_headline(p)
        self.write_code_body(p)
        p.moveToThreadNext()
#@+node:ekr.20100812082517.5939: *6* write_code_tree
def write_code_tree (self,p,fn):

    '''Write p's tree as code to self.outputFile.'''

    self.scanAllOptions(p) # So we can get the next option.

    if self.getOption('generate_rst_header_comment'):
        self.write('.. rst3: filename: %s\n\n' % fn)

    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    self.topNode = p.copy() # Indicate the top of this tree.
    after = p.nodeAfterTree()
    while p and p != after:
        self.write_code_node(p) # Side effect: advances p.
#@+node:ekr.20090511055302.5793: *5* rst3 command & helpers
def rst3 (self,event=None):

    '''Write all @rst nodes.'''

    self.processTopTree(self.c.p)
#@+node:ekr.20090502071837.62: *6* processTopTree
def processTopTree (self,p,justOneFile=False):

    c = self.c ; current = p.copy()

    # This strange looking code looks up and down the tree for @rst nodes.
    for p in current.self_and_parents():
        h = p.h
        if h.startswith('@rst') and not h.startswith('@rst-'):
            self.processTree(p,ext=None,toString=False,justOneFile=justOneFile)
            break
        elif h.startswith('@slides'):
            self.processTree(p,ext=None,toString=False,justOneFile=False)
            break
    else:
        self.processTree(current,ext=None,toString=False,justOneFile=justOneFile)

    g.es_print('done',color='blue')
#@+node:ekr.20090502071837.63: *6* processTree
def processTree(self,p,ext=None,toString=False,justOneFile=False):

    '''Process all @rst nodes in a tree.
    ext is the docutils extention: it's useful for scripts and unit tests.
    '''

    trace = False and not g.unitTesting
    if trace: g.trace(p.h)
    self.preprocessTree(p)
    found = False ; self.stringOutput = ''
    p = p.copy() ; after= p.nodeAfterTree()
    while p and p != after:
        h = p.h.strip()
        if g.match_word(h,0,"@rst"):
            fn = h[4:].strip()
            if ((fn and fn[0] != '-') or (toString and not fn)):
                if trace: g.trace('found: %s',p.h)
                found = True
                self.write_rst_tree(p,ext,fn,toString=toString,justOneFile=justOneFile)
                self.scanAllOptions(p) # Restore the top-level verbose setting.
                if toString:
                    return p.copy(),self.stringOutput
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        elif g.match(h,0,"@slides"):
            self.write_slides(p)
            found = True
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    if not found:
        g.es('No @rst or @slides nodes in selected tree',color='blue')
    return None,None
#@+node:ekr.20090502071837.64: *6* write_rst_tree
def write_rst_tree (self,p,ext,fn,toString=False,justOneFile=False):

    '''Convert p's tree to rst sources.
    Optionally call docutils to convert rst to output.

    On exit:
        self.source contains rst sources
        self.stringOutput contains docutils output if docutils called.
    '''

    c = self.c
    self.topNode = p.copy()
    self.topLevel = p.level()
    if toString:
        ext = ext or '.html' # 2010/08/12: Unit test found this.
    else:
        junk,ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext.startswith('.'): ext = '.' + ext

    # Init options...
    self.init_write(p) # ScanAllDirectives sets self.path and self.encoding.
    self.scanAllOptions(p) # Settings for p are valid after this call.
    callDocutils = self.getOption('call_docutils')
    writeIntermediateFile = self.getOption('write_intermediate_file')

    # Write the rst sources to self.source.
    self.outputFile = StringIO()
    self.writeTree(p,fn)
    self.source = self.outputFile.getvalue() # the rST sources.
    self.outputFile = None
    self.stringOutput = None

    if callDocutils or writeIntermediateFile:
        self.write_files(ext,fn,callDocutils,toString,writeIntermediateFile)
#@+node:ekr.20100822092546.5835: *6* write_slides & helper
def write_slides (self,p,toString=False):

    '''Convert p's children to slides.'''

    c = self.c ; p = p.copy() ; h = p.h
    i = g.skip_id(h,1) # Skip the '@'
    kind,fn = h[:i].strip(),h[i:].strip()
    if not fn: return g.es('%s requires file name' % (kind),color='red')
    title = p and p.firstChild().h or '<no slide>'
    title = title.strip().capitalize()
    n_tot = p.numberOfChildren()

    n = 1
    for child in p.children():
        self.init_write(p) # ScanAllDirectives sets self.path and self.encoding.
        self.scanAllOptions(child) # Settings for child are valid after this call.
        # Compute the slide's file name.
        fn2,ext = g.os_path_splitext(fn)
        fn2 = '%s-%03d%s' % (fn2,n,ext) # Use leading zeros for :glob:.
        n += 1
        # Write the rst sources to self.source.
        self.outputFile = StringIO()
        self.writeSlideTitle(title,n-1,n_tot)
        self.writeBody(child)
        self.source = self.outputFile.getvalue() # the rST sources.
        self.outputFile,self.stringOutput = None,None
        self.write_files(ext,fn2,
            callDocutils=self.getOption('call_docutils'),
            toString=toString,
            writeIntermediateFile=self.getOption('write_intermediate_file'))
#@+node:ekr.20100822174725.5836: *7* writeSlideTitle
def writeSlideTitle (self,title,n,n_tot):

    '''Write the title, underlined with the '#' character.'''

    if n != 1:
        title = '%s (%s of %s)' % (title,n,n_tot)

    width = max(4,len(g.toEncodedString(title,
        encoding=self.encoding,reportErrors=False)))

    self.write('%s\n%s \n\n' % (title,('#'*width)))
#@+node:ekr.20090502071837.58: *6* write methods (rst3 command)
#@+node:ekr.20090502071837.68: *7* getDocPart
def getDocPart (self,lines,n):

    # g.trace('n',n,repr(''.join(lines)))

    result = []
    << Append whatever follows @doc or @space to result >>
    while n < len(lines):
        s = lines [n] ; n += 1
        if g.match_word(s,0,'@code') or g.match_word(s,0,'@c'):
            break
        result.append(s)
    return n, result
#@+node:ekr.20090502071837.69: *8* << Append whatever follows @doc or @space to result >>
if n > 0:
    line = lines[n-1]
    if line.startswith('@doc'):
        s = line[4:].lstrip()
    elif line.startswith('@'):
        s = line[1:].lstrip()
    else:
        s = ''

    # New in Leo 4.4.4: remove these special tags.
    for tag in ('@rst-options','@rst-option','@rst-markup'):
        if g.match_word(s,0,tag):
            s = s[len(tag):].strip()

    if s.strip():
        result.append(s)
#@+node:ekr.20090502071837.81: *7* handleSpecialDocParts
def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    # g.trace(kind,g.listToString(lines))

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
#@+node:ekr.20090502071837.77: *7* isAnyDocPart
def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()
#@+node:ekr.20090502071837.79: *7* isAnySpecialDocPart
def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
#@+node:ekr.20090502071837.78: *7* isSpecialDocPart
def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) > 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    # g.trace('kind %s, result %s, s %s' % (
        # repr(kind),result,repr(s)))

    return result
#@+node:ekr.20090502071837.80: *7* removeLeoDirectives
def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,1,key):
                    # g.trace('removing %s' % s)
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
#@+node:ekr.20090502071837.82: *7* replaceCodeBlockDirectives
def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result
#@+node:ekr.20090502071837.70: *7* skip_literal_block
def skip_literal_block (self,lines,n):

    s = lines[n] ; result = [s] ; n += 1
    indent = g.skip_ws(s,0)

    # Skip lines until a non-blank line is found with same or less indent.
    while n < len(lines):
        s = lines[n]
        indent2 = g.skip_ws(s,0)
        if s and not s.isspace() and indent2 <= indent:
            break # We will rescan lines [n]
        n += 1
        result.append(s)

    # g.printList(result,tag='literal block')
    return n, result
#@+node:ekr.20090502071837.71: *7* writeBody & helpers
def writeBody (self,p):

    trace = False and not g.unitTesting
   
    if self.getOption('ignore_noweb_definitions'):
        # 2011/06/10: Ignore section definition nodes.
        name = self.isSectionDef(p)
        if name:
            if trace: g.trace('section def: %s' % (repr(name)))
            return

    # remove trailing cruft and split into lines.
    lines = g.splitLines(p.b)

    if self.getOption('code_mode'):
        # Important: code mode is no longer documented!
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('expand_noweb_references'):
            # 2011/06/10.
            lines = self.expandSectionRefs(lines,p,seen=[])
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    # Write the lines.
    s = ''.join(lines)

    # We no longer add newlines to the start of nodes because
    # we write a blank line after all sections.
    # s = g.ensureLeadingNewlines(s,1)
    s = g.ensureTrailingNewlines(s,2)
    self.write(s)
#@+node:ekr.20110610144305.6749: *8* isSectionDef/Ref
def isSectionDef (self,p):
    
    return self.isSectionRef(p.h)
    
def isSectionRef (self,s):

    n1 = s.find("<<",0)
    n2 = s.find(">>",0)
    return -1 < n1 < n2 and s[n1+2:n2].strip()
#@+node:ekr.20110610144305.6750: *8* expandSectionRefs
def expandSectionRefs (self,lines,p,seen):
    
    trace = False and not g.unitTesting
    
    if trace: g.trace(p.h,g.callers())

    result = []
    for s in lines:
        name = self.isSectionRef(s)
        if name:
            p2 = self.findSectionDef(name,p)
            if p2:
                g.trace('expanding: %s from %s' % (name,p2.h))
                result.append(s) # Append the section reference line.
                lines2 = g.splitLines(p2.b)
                if self.getOption('expand_noweb_recursively'):
                    if name in seen:
                        pass # Prevent unbounded recursion
                    else:
                        seen.append(name)
                        result.extend(self.expandSectionRefs(lines2,p,seen))
                else:
                    result.extend(lines2)
            else:
                # Undefined reference.
                result.append(s)
        else:
            result.append(s)

    return result
#@+node:ekr.20110610144305.6751: *8* findSectionDef
def findSectionDef (self,name,p):
    
    for p2 in p.subtree():
        name2 = self.isSectionDef(p2)
        if name2:
            return p2
    
    return None
#@+node:ekr.20090502071837.72: *8* handleCodeMode & helper
def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    trace = False and not g.unitTesting
    result = [] ; n = 0 ; code = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or (
                self.getOption('show_doc_parts_as_paragraphs') and
                self.isSpecialDocPart(s,None)
            )
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            # A fix, perhaps dubious, to a bug discussed at
            # http://groups.google.com/group/leo-editor/browse_thread/thread/c212814815c92aac
            # lines2 = [z.lstrip() for z in lines2]
            # g.trace('lines2',lines2)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        else:
            if not code: # Start the code block.
                result.append('')
                result.append(self.code_block_string)

            if trace: g.trace('code line: %s' % repr(s))
            code.append(s)
       
        # elif not code: # Start the code block.
            # result.append('')
            # result.append(self.code_block_string)
            # if trace: g.trace('code line: %s' % repr(s))
            # code.append(s)
        # else: # Continue the code block.
            # if trace: g.trace('code line: %s' % repr(s))
            # code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []

    # Munge the result so as to keep docutils happy.
    # Don't use self.rstripList: it's not the same.
    # g.trace(result)
    result2 = []
    for z in result:
        if z == '': result2.append('\n\n')
        # 2010/08/27: Fix bug 618482.
        # elif not z.rstrip(): pass
        elif z.endswith('\n\n'): result2.append(z) # Leave alone.
        else: result2.append('%s\n' % z.rstrip())

    return result2
#@+node:ekr.20090502071837.73: *9* formatCodeModeLine
def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
#@+node:ekr.20090502071837.74: *9* rstripList
def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    # 2010/08/27: fix bug 618482.
    s = ''.join(theList).rstrip()
    return s.split('\n')
#@+node:ekr.20090502071837.75: *9* finishCodePart
def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
#@+node:ekr.20090502071837.76: *8* handleDocOnlyMode
def handleDocOnlyMode (self,p,lines):

    '''Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.'''

    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.h)
            self.writeHeadlineHelper(p)
    return result
#@+node:ekr.20090502071837.83: *7* writeHeadline & helper
def writeHeadline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''

    docOnly             = self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    ignoreNowebDefs     = self.getOption('ignore_noweb_definitions')
    showHeadlines       = self.getOption('show_headlines')
    showOrganizers      = self.getOption('show_organizer_nodes')
    showThisHeadline    = self.getOption('show_this_headline')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers or
        ignoreNowebDefs and self.isSectionDef(p) # 2011/06/10.
    ):
        return

    self.writeHeadlineHelper(p)
#@+node:ekr.20090502071837.84: *8* writeHeadlineHelper
def writeHeadlineHelper (self,p):

    h = p.h
    if not self.atAutoWrite:
        h = h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0)
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip()
    if word:
        # Never generate a section for these...
        if word in (
            '@rst-option','@rst-options',
            '@rst-no-head','@rst-no-headlines'
        ):
            return

        # Remove all other headline commands from the headline.
        for command in self.headlineCommands:
            if word == command:
                h = h [len(word):].strip()
                break

        # New in Leo 4.4.4.
        if word.startswith('@'):
            if self.getOption('strip_at_file_prefixes'):
                for s in ('@auto','@file','@nosent','@thin',):
                    if g.match_word(word,0,s):
                        h = h [len(s):].strip()

    if not h.strip(): return

    if self.getOption('show_sections'):
        if self.getOption('generate_rst'):
            self.write(self.underline(h,p)) # Used by @auto-rst.
        else:
            self.write('\n%s\n\n' % h)
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
#@+node:ekr.20090502071837.85: *7* writeNode (leoRst)
def writeNode (self,p):

    '''Format a node according to the options presently in effect.'''

    self.initCodeBlockString(p)
    self.scanAllOptions(p)

    if 0:
        g.trace('%24s code_mode %s' % (p.h,self.getOption('code_mode')))

    h = p.h.strip()

    if self.getOption('preformat_this_node'):
        self.http_addNodeMarker(p)
        self.writePreformat(p)
        p.moveToThreadNext()
    elif self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.writeHeadline(p)
        self.writeBody(p)
        p.moveToThreadNext()
#@+node:ekr.20090502071837.86: *7* writePreformat
def writePreformat (self,p):

    '''Write p's body text lines as if preformatted.

     ::

        line 1
        line 2 etc.
    '''

    # g.trace(p.h,g.callers())

    lines = p.b.split('\n')
    lines = [' '*4 + z for z in lines]
    lines.insert(0,'::\n')

    s = '\n'.join(lines)
    if s.strip():
        self.write('%s\n\n' % s)
#@+node:ekr.20090502071837.87: *7* writeTree
def writeTree(self,p,fn):

    '''Write p's tree to self.outputFile.'''

    self.scanAllOptions(p)

    if self.getOption('generate_rst'):
        if self.getOption('generate_rst_header_comment'):
            self.write(self.rstComment(
                'rst3: filename: %s\n\n' % fn))

    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    after = p.nodeAfterTree()
    while p and p != after:
        self.writeNode(p) # Side effect: advances p.
#@+node:ekr.20090502071837.67: *5* writeNodeToString
def writeNodeToString (self,p=None,ext=None):

    '''Scan p's tree (defaults to presently selected tree) looking for @rst nodes.
    Convert the first node found to an ouput of the type specified by ext.

    The @rst may or may not be followed by a filename; the filename is *ignored*,
    and its type does not affect ext or the output generated in any way.

    ext should start with a period: .html, .tex or None (specifies rst output).

    Returns (p, s), where p is the position of the @rst node and s is the converted text.'''

    c = self.c ; current = p or c.p

    for p in current.self_and_parents():
        if p.h.startswith('@rst'):
            return self.processTree(p,ext=ext,toString=True,justOneFile=True)
    else:
        return self.processTree(current,ext=ext,toString=True,justOneFile=True)
#@+node:ekr.20090512153903.5803: *5* writeAtAutoFile
def writeAtAutoFile (self,p,fileName,outputFile,trialWrite=False):

    '''Write an @auto tree containing imported rST code.
    The caller will close the output file.'''

    try:
        self.trialWrite = trialWrite
        self.atAutoWrite = True
        self.initAtAutoWrite(p,fileName,outputFile)
        self.topNode = p.copy() # Indicate the top of this tree.
        self.topLevel = p.level()
        after = p.nodeAfterTree()
        ok = self.isSafeWrite(p)
        if ok:
            p = p.firstChild() # A hack: ignore the root node.
            while p and p != after:
                self.writeNode(p) # side effect: advances p
    finally:
        self.atAutoWrite = False
    return ok
#@+node:ekr.20090513073632.5733: *6* initAtAutoWrite (rstCommands)
def initAtAutoWrite(self,p,fileName,outputFile):

    # Set up for a standard write.
    self.createDefaultOptionsDict()
    self.nodeOptionDict = {}
    self.scanAllOptions(p)
    self.init_write(p)
    self.preprocessTree(p) # Allow @ @rst-options, for example.
    # Do the overrides.
    self.outputFile = outputFile
    # Set underlining characters.
    # It makes no sense to use user-defined
    # underlining characters in @auto-rst.
    d = p.v.u.get('rst-import',{})
    underlines2 = d.get('underlines2','')
        # Do *not* set a default for overlining characters.
    if len(underlines2) > 1:
        underlines2 = underlines2[0]
        g.trace('too many top-level underlines, using %s' % (
            underlines2),color='blue')
    underlines1 = d.get('underlines1','')
    # Bug fix:  2010/05/26: pad underlines with default characters.
    default_underlines = '=+*^~"\'`-:><_'
    if underlines1:
        for ch in default_underlines[1:]:
            if ch not in underlines1:
                underlines1 = underlines1 + ch
    else:
        underlines1 = default_underlines
    self.atAutoWriteUnderlines   = underlines2 + underlines1
    self.underlines1 = underlines1
    self.underlines2 = underlines2
#@+node:ekr.20091228080620.6499: *6* isSafeWrite
def isSafeWrite (self,p):

    '''Return True if node p contributes nothing but
    rst-options to the write.'''

    if self.trialWrite or not p.isAtAutoRstNode():
        return True # Trial writes are always safe.

    lines = g.splitLines(p.b)
    for z in lines:
        if z.strip() and not z.startswith('@') and not z.startswith('.. '):
            # A real line that will not be written.
            g.es('unsafe @auto-rst',color='red')
            g.es('body text will be ignored in\n',p.h)
            return False
    else:
        return True
#@+node:ekr.20090502071837.41: *4* Options
#@+node:ekr.20090502071837.42: *5* createDefaultOptionsDict
def createDefaultOptionsDict(self):

    # Important: these must be munged names.
    self.defaultOptionsDict = {
        # Http options...
        'clear_http_attributes':   False,
        'http_server_support':     False,
        'http_attributename':      'rst_http_attribute',
        'node_begin_marker':       'http-node-marker-',
        # Path options...
        'default_path': None, # New in Leo 4.4a4 # Bug fix: must be None, not ''.
        'stylesheet_name': 'default.css',
        'stylesheet_path': None, # Bug fix: must be None, not ''.
        'stylesheet_embed': True,
        'publish_argv_for_missing_stylesheets': None,
        # Global options...
        'call_docutils': True, # 2010/08/05
        'code_block_string': '',
        'number_code_lines': True,
        'underline_characters': '''#=+*^~"'`-:><_''',
        'verbose':True,
        'write_intermediate_file': False, # Used only if generate_rst is True.
        'write_intermediate_extension': '.txt',
        # Mode options...
        'code_mode': False, # True: generate rst markup from @code and @doc parts.
        'doc_only_mode': False, # True: generate only from @doc parts.
        'generate_rst': True, # True: generate rst markup.  False: generate plain text.
        'generate_rst_header_comment': True,
            # True generate header comment (requires generate_rst option)
        # Formatting options that apply to both code and rst modes....
        'expand_noweb_references': False,
        'ignore_noweb_definitions': False,
        'expand_noweb_recursively': True,
        'show_headlines': True,  # Can be set by @rst-no-head headlines.
        'show_organizer_nodes': True,
        'show_options_nodes': False,
        'show_sections': True,
        'strip_at_file_prefixes': True,
        'show_doc_parts_in_rst_mode': True,
        # Formatting options that apply only to code mode.
        'show_doc_parts_as_paragraphs': False,
        'show_leo_directives': True,
        'show_markup_doc_parts': False,
        'show_options_doc_parts': False,
    }
#@+node:ekr.20090502071837.43: *5* dumpSettings (debugging)
def dumpSettings (self):

    d = self.optionsDict
    keys = sorted(d)

    g.pr('present settings...')
    for key in keys:
        g.pr('%20s %s' % (key,d.get(key)))
#@+node:ekr.20090502071837.44: *5* getOption & setOption
def getOption (self,name):

    # 2010/08/12: munging names here is safe because setOption munges.
    # g.trace(name,self.optionsDict.get(self.munge(name)))
    return self.optionsDict.get(self.munge(name))

def setOption (self,name,val,tag=None):

    self.optionsDict [self.munge(name)] = val
#@+node:ekr.20090502071837.45: *5* initCodeBlockString
def initCodeBlockString(self,p):

    trace = False and not g.unitTesting
    c = self.c
    # if trace: os.system('cls')
    d = c.scanAllDirectives(p)
    language = d.get('language')
    if language is None: language = 'python'
    else: language = language.lower()
    syntax = SilverCity is not None

    if trace: g.trace('language',language,'language.title()',language.title(),p.h)

    # Note: lines that end with '\n\n' are a signal to handleCodeMode.
    s = self.getOption('code_block_string')
    if s:
        self.code_block_string = s.replace('\\n','\n')
    elif syntax and language in ('python','ruby','perl','c'):
        self.code_block_string = '**code**:\n\n.. code-block:: %s\n\n' % (
            language.title())
    else:
        self.code_block_string = '**code**:\n\n.. class:: code\n..\n\n::\n\n'
#@+node:ekr.20090502071837.46: *5* preprocessTree & helpers
def preprocessTree (self,root):

    self.nodeOptionDict = {}

    # Bug fix 12/4/05: must preprocess parents too.
    for p in root.parents():
        self.preprocessNode(p)

    for p in root.self_and_subtree():
        self.preprocessNode(p)

    if 0:
        g.trace(root.h)
        for key in self.nodeOptionDict.keys():
            g.trace(key)
            g.printDict(self.nodeOptionDict.get(key))
#@+node:ekr.20090502071837.47: *6* preprocessNode
def preprocessNode (self,p):

    d = self.nodeOptionDict.get(p.v)
    if d is None:
        d = self.scanNodeForOptions(p)
        self.nodeOptionDict [p.v] = d
#@+node:ekr.20090502071837.48: *6* parseOptionLine
def parseOptionLine (self,s):

    '''Parse a line containing name=val and return (name,value) or None.

    If no value is found, default to True.'''

    s = s.strip()
    if s.endswith(','): s = s[:-1]
    # Get name.  Names may contain '-' and '_'.
    i = g.skip_id(s,0,chars='-_')
    name = s [:i]
    if not name: return None
    j = g.skip_ws(s,i)
    if g.match(s,j,'='):
        val = s [j+1:].strip()
        # g.trace(val)
        return name,val
    else:
        # g.trace('*True')
        return name,'True'
#@+node:ekr.20090502071837.49: *6* scanForOptionDocParts
def scanForOptionDocParts (self,p,s):

    '''Return a dictionary containing all options from @rst-options doc parts in p.
    Multiple @rst-options doc parts are allowed: this code aggregates all options.
    '''

    d = {} ; n = 0 ; lines = g.splitLines(s)
    while n < len(lines):
        line = lines[n] ; n += 1
        if line.startswith('@'):
            i = g.skip_ws(line,1)
            for kind in ('@rst-options','@rst-option'):
                if g.match_word(line,i,kind):
                    # Allow options on the same line.
                    line = line[i+len(kind):]
                    d.update(self.scanOption(p,line))
                    # Add options until the end of the doc part.
                    while n < len(lines):
                        line = lines[n] ; n += 1 ; found = False
                        for stop in ('@c','@code', '@'):
                            if g.match_word(line,0,stop):
                                found = True ; break
                        if found:
                            break
                        else:
                            d.update(self.scanOption(p,line))
                    break
    return d
#@+node:ekr.20090502071837.50: *6* scanHeadlineForOptions
def scanHeadlineForOptions (self,p):

    '''Return a dictionary containing the options implied by p's headline.'''

    h = p.h.strip()

    if p == self.topNode:
        return {} # Don't mess with the root node.
    elif g.match_word(h,0,'@rst-option'):
        s = h [len('@rst-option'):]
        return self.scanOption(p,s)
    elif g.match_word(h,0,'@rst-options'):
        return self.scanOptions(p,p.b)
    else:
        # Careful: can't use g.match_word because options may have '-' chars.
        i = g.skip_id(h,0,chars='@-')
        word = h[0:i]

        for option,ivar,val in (
            ('@rst',                'code_mode',False),
            ('@rst-code',           'code_mode',True),
            ('@rst-default-path',   'default_prefix',''),
            ('@rst-doc-only',       'doc_only_mode',True),
            ('@rst-head',           'show_this_headline',True),
            # ('@rst-head' ,        'show_headlines',False),
            ('@rst-ignore',         'ignore_this_tree',True),
            ('@rst-ignore-node',    'ignore_this_node',True),
            ('@rst-ignore-tree',    'ignore_this_tree',True),
            ('@rst-no-head',        'ignore_this_headline',True),
            ('@rst-preformat',      'preformat_this_node',True),
        ):
            if word == option:
                d = { ivar: val }
                # Special case: code mode and doc-only modes are linked.
                if ivar == 'code_mode':
                    d ['doc_only_mode'] = False
                elif ivar == 'doc_only_mode':
                    d ['code_mode'] = False
                # Special case: Treat a bare @rst like @rst-no-head
                if h == '@rst':
                    d ['ignore_this_headline'] = True
                # g.trace(repr(h),d)
                return d

        if h.startswith('@rst'):
            g.trace('unknown kind of @rst headline',p.h,g.callers(4))

        return {}
#@+node:ekr.20090502071837.51: *6* scanNodeForOptions
def scanNodeForOptions (self,p):

    '''Return a dictionary containing all the option-name:value entries in p.

    Such entries may arise from @rst-option or @rst-options in the headline,
    or from @ @rst-options doc parts.'''
    
    trace = False and not g.unitTesting

    h = p.h

    d = self.scanHeadlineForOptions(p)

    d2 = self.scanForOptionDocParts(p,p.b)

    # A fine point: body options over-ride headline options.
    d.update(d2)
    
    if trace and d:
        g.trace(h)
        for z in sorted(d):
            print('    %s: %s' % (z,d.get(z)))

    return d
#@+node:ekr.20090502071837.52: *6* scanOption
def scanOption (self,p,s):

    '''Return { name:val } if s is a line of the form name=val.
    Otherwise return {}'''

    if not s.strip() or s.strip().startswith('..'): return {}

    data = self.parseOptionLine(s)

    if data:
        name,val = data
        if self.munge(name) in list(self.defaultOptionsDict.keys()):
            if   val.lower() == 'true': val = True
            elif val.lower() == 'false': val = False
            # g.trace('%24s %8s %s' % (self.munge(name),val,p.h))
            return { self.munge(name): val }
        else:
            g.es_print('ignoring unknown option: %s' % (name),color='red')
            return {}
    else:
        g.trace(repr(s))
        s2 = 'bad rst3 option in %s: %s' % (p.h,s)
        g.es_print(s2,color='red')
        return {}
#@+node:ekr.20090502071837.53: *6* scanOptions
def scanOptions (self,p,s):

    '''Return a dictionary containing all the options in s.'''

    d = {}

    for line in g.splitLines(s):
        d2 = self.scanOption(p,line)
        if d2: d.update(d2)

    return d
#@+node:ekr.20090502071837.54: *5* scanAllOptions & helpers
# Once an option is seen, no other related options in ancestor nodes have any effect.

def scanAllOptions(self,p):

    '''Scan position p and p's ancestors looking for options,
    setting corresponding ivars.
    '''

    self.initOptionsFromSettings() # Must be done on every node.
    self.handleSingleNodeOptions(p)
    seen = self.singleNodeOptions[:] # Suppress inheritance of single-node options.

    # g.trace('-'*20)
    for p in p.self_and_parents():
        d = self.nodeOptionDict.get(p.v,{})
        # g.trace(p.h,d)
        for key in d.keys():
            ivar = self.munge(key)
            if not ivar in seen:
                seen.append(ivar)
                val = d.get(key)
                self.setOption(key,val,p.h)

    if self.rst3_all:
        self.setOption("generate_rst", True, "rst3_all")
        self.setOption("generate_rst_header_comment",True, "rst3_all")
        self.setOption("http_server_support", True, "rst3_all")
        self.setOption("write_intermediate_file", True, "rst3_all")
#@+node:ekr.20090502071837.55: *6* initOptionsFromSettings
def initOptionsFromSettings (self):

    c = self.c

    d = self.defaultOptionsDict
    keys = sorted(d)

    for key in keys:
        for getter,kind in (
            (c.config.getBool,'@bool'),
            (c.config.getString,'@string'),
            (d.get,'default'),
        ):
            val = getter(key)
            if kind == 'default' or val is not None:
                self.setOption(key,val,'initOptionsFromSettings')
                break

    # 2010/08/12: Script settings override everything else.
    d2 = self.scriptSettingsDict or {}
    for key in d2.keys():
        val = d2.get(key)
        # g.trace(key,val)
        self.setOption(key,val,'initOptionsFromSettings')

    # Special case.
    if self.getOption('http_server_support') and not mod_http:
        g.es('No http_server_support: can not import mod_http plugin',color='red')
        self.setOption('http_server_support',False)
#@+node:ekr.20090502071837.56: *6* handleSingleNodeOptions
def handleSingleNodeOptions (self,p):

    '''Init the settings of single-node options from the tnodeOptionsDict.

    All such options default to False.'''

    d = self.nodeOptionDict.get(p.v, {} )

    for ivar in self.singleNodeOptions:
        val = d.get(ivar,False)
        #g.trace('%24s %8s %s' % (ivar,val,p.h))
        self.setOption(ivar,val,p.h)

#@+node:ekr.20090502071837.42: *4* createDefaultOptionsDict
def createDefaultOptionsDict(self):

    # Important: these must be munged names.
    self.defaultOptionsDict = {
        # Http options...
        'clear_http_attributes':   False,
        'http_server_support':     False,
        'http_attributename':      'rst_http_attribute',
        'node_begin_marker':       'http-node-marker-',
        # Path options...
        'default_path': None, # New in Leo 4.4a4 # Bug fix: must be None, not ''.
        'stylesheet_name': 'default.css',
        'stylesheet_path': None, # Bug fix: must be None, not ''.
        'stylesheet_embed': True,
        'publish_argv_for_missing_stylesheets': None,
        # Global options...
        'call_docutils': True, # 2010/08/05
        'code_block_string': '',
        'number_code_lines': True,
        'underline_characters': '''#=+*^~"'`-:><_''',
        'verbose':True,
        'write_intermediate_file': False, # Used only if generate_rst is True.
        'write_intermediate_extension': '.txt',
        # Mode options...
        'code_mode': False, # True: generate rst markup from @code and @doc parts.
        'doc_only_mode': False, # True: generate only from @doc parts.
        'generate_rst': True, # True: generate rst markup.  False: generate plain text.
        'generate_rst_header_comment': True,
            # True generate header comment (requires generate_rst option)
        # Formatting options that apply to both code and rst modes....
        'expand_noweb_references': False,
        'ignore_noweb_definitions': False,
        'expand_noweb_recursively': True,
        'show_headlines': True,  # Can be set by @rst-no-head headlines.
        'show_organizer_nodes': True,
        'show_options_nodes': False,
        'show_sections': True,
        'strip_at_file_prefixes': True,
        'show_doc_parts_in_rst_mode': True,
        # Formatting options that apply only to code mode.
        'show_doc_parts_as_paragraphs': False,
        'show_leo_directives': True,
        'show_markup_doc_parts': False,
        'show_options_doc_parts': False,
    }
#@+node:ekr.20090502071837.71: *4* writeBody & helpers
def writeBody (self,p):

    trace = False and not g.unitTesting
   
    if self.getOption('ignore_noweb_definitions'):
        # 2011/06/10: Ignore section definition nodes.
        name = self.isSectionDef(p)
        if name:
            if trace: g.trace('section def: %s' % (repr(name)))
            return

    # remove trailing cruft and split into lines.
    lines = g.splitLines(p.b)

    if self.getOption('code_mode'):
        # Important: code mode is no longer documented!
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('expand_noweb_references'):
            # 2011/06/10.
            lines = self.expandSectionRefs(lines,p,seen=[])
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    # Write the lines.
    s = ''.join(lines)

    # We no longer add newlines to the start of nodes because
    # we write a blank line after all sections.
    # s = g.ensureLeadingNewlines(s,1)
    s = g.ensureTrailingNewlines(s,2)
    self.write(s)
#@+node:ekr.20110610144305.6749: *5* isSectionDef/Ref
def isSectionDef (self,p):
    
    return self.isSectionRef(p.h)
    
def isSectionRef (self,s):

    n1 = s.find("<<",0)
    n2 = s.find(">>",0)
    return -1 < n1 < n2 and s[n1+2:n2].strip()
#@+node:ekr.20110610144305.6750: *5* expandSectionRefs
def expandSectionRefs (self,lines,p,seen):
    
    trace = False and not g.unitTesting
    
    if trace: g.trace(p.h,g.callers())

    result = []
    for s in lines:
        name = self.isSectionRef(s)
        if name:
            p2 = self.findSectionDef(name,p)
            if p2:
                g.trace('expanding: %s from %s' % (name,p2.h))
                result.append(s) # Append the section reference line.
                lines2 = g.splitLines(p2.b)
                if self.getOption('expand_noweb_recursively'):
                    if name in seen:
                        pass # Prevent unbounded recursion
                    else:
                        seen.append(name)
                        result.extend(self.expandSectionRefs(lines2,p,seen))
                else:
                    result.extend(lines2)
            else:
                # Undefined reference.
                result.append(s)
        else:
            result.append(s)

    return result
#@+node:ekr.20110610144305.6751: *5* findSectionDef
def findSectionDef (self,name,p):
    
    for p2 in p.subtree():
        name2 = self.isSectionDef(p2)
        if name2:
            return p2
    
    return None
#@+node:ekr.20090502071837.72: *5* handleCodeMode & helper
def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    trace = False and not g.unitTesting
    result = [] ; n = 0 ; code = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or (
                self.getOption('show_doc_parts_as_paragraphs') and
                self.isSpecialDocPart(s,None)
            )
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            # A fix, perhaps dubious, to a bug discussed at
            # http://groups.google.com/group/leo-editor/browse_thread/thread/c212814815c92aac
            # lines2 = [z.lstrip() for z in lines2]
            # g.trace('lines2',lines2)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        else:
            if not code: # Start the code block.
                result.append('')
                result.append(self.code_block_string)

            if trace: g.trace('code line: %s' % repr(s))
            code.append(s)
       
        # elif not code: # Start the code block.
            # result.append('')
            # result.append(self.code_block_string)
            # if trace: g.trace('code line: %s' % repr(s))
            # code.append(s)
        # else: # Continue the code block.
            # if trace: g.trace('code line: %s' % repr(s))
            # code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []

    # Munge the result so as to keep docutils happy.
    # Don't use self.rstripList: it's not the same.
    # g.trace(result)
    result2 = []
    for z in result:
        if z == '': result2.append('\n\n')
        # 2010/08/27: Fix bug 618482.
        # elif not z.rstrip(): pass
        elif z.endswith('\n\n'): result2.append(z) # Leave alone.
        else: result2.append('%s\n' % z.rstrip())

    return result2
#@+node:ekr.20090502071837.73: *6* formatCodeModeLine
def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
#@+node:ekr.20090502071837.74: *6* rstripList
def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    # 2010/08/27: fix bug 618482.
    s = ''.join(theList).rstrip()
    return s.split('\n')
#@+node:ekr.20090502071837.75: *6* finishCodePart
def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
#@+node:ekr.20090502071837.76: *5* handleDocOnlyMode
def handleDocOnlyMode (self,p,lines):

    '''Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.'''

    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.h)
            self.writeHeadlineHelper(p)
    return result
#@-all

# Put this @language after the @all as a kind of permanent unit test.

#@@language python # Override the default .txt coloring.

#@@pagewidth 60
#@-leo
