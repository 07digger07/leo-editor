<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070610174018"><vh>Startup</vh>
<v t="ekr.20050407144417"><vh>@settings</vh>
<v t="ekr.20111108052738.5507"><vh>@shortcuts</vh></v>
<v t="ekr.20100907092300.4440"><vh>Inkscape options</vh>
<v t="ekr.20100907092300.4441"><vh>@string inkscape-template = ../docs/inkscape-template.svg</vh></v>
<v t="ekr.20100907092300.4442"><vh>@string inkscape-bin = "c:\Program Files (x86)\Inkscape\inkscape.exe"</vh></v>
</v>
<v t="ekr.20101009114830.4724"><vh>File options</vh>
<v t="ekr.20080923182326.1"><vh>@@bool create_nonexistent_directories = True</vh></v>
<v t="ekr.20080412124815.1"><vh>@bool fixedWindow = False</vh></v>
<v t="ekr.20101009114830.4723"><vh>@bool put_expansion_bits_in_leo_files = False</vh></v>
</v>
<v t="ekr.20101009114830.4725"><vh>Plugins options</vh>
<v t="ekr.20050407144342"><vh>@page http plugin</vh>
<v t="ekr.20050407144342.1"><vh>@bool http_active = False</vh></v>
<v t="ekr.20050407144342.2"><vh>@int  port = 8080</vh></v>
<v t="ekr.20050407144342.3"><vh>@string rst_http_attributename = rst_http_attribute</vh></v>
</v>
<v t="ekr.20050812123002"><vh>@page rst3 options</vh>
<v t="ekr.20050812123002.1"><vh>Http options...</vh>
<v t="ekr.20050812123002.2"><vh>@bool rst3_clear_http_attributes = False</vh></v>
<v t="ekr.20050812123002.3"><vh>@string rst3_http_attributename = 'rst_http_attribute'</vh></v>
<v t="ekr.20050812123002.4"><vh>@bool rst3_http_server_support = False</vh></v>
<v t="ekr.20050812123002.5"><vh>@string rst3_node_begin_marker = 'http-node-marker-'</vh></v>
</v>
<v t="ekr.20050812123002.6"><vh>@bool rst3_massage_body = False</vh></v>
<v t="ekr.20050812123002.7"><vh>@bool rst3_format_headlines = True</vh></v>
<v t="ekr.20050812123002.8"><vh>@bool rst3_write_intermediate_file = True</vh></v>
<v t="sps.20100708213227.44914"><vh>@string rst3_write_intermediate_extension = .html.txt</vh></v>
<v t="ekr.20051202072010"><vh>@string rst3_default_path =</vh></v>
</v>
</v>
</v>
<v t="ekr.20101028112631.4959" descendentVnodeUnknownAttributes="7d7100580b000000302e312e302e302e302e3171017d7102580b0000007374725f6c656f5f706f7371035800000000710473732e"><vh>@file doc-startup.txt</vh></v>
</v>
<v t="ekr.20050831195449"><vh>Read me first</vh></v>
<v t="ekr.20100805171546.4412"><vh>Files, including home page</vh>
<v t="ville.20090609182215.5676"><vh>@auto-rst treecaching.txt</vh></v>
<v t="ekr.20090428133936.2"><vh>@edit html\conf.py</vh></v>
<v t="ekr.20090428102353.1"><vh>@edit html\leo_toc.html.txt</vh></v>
<v t="ekr.20101025080245.5800"><vh>@edit leo_toc.html</vh></v>
<v t="ekr.20101112045055.5064"><vh>@file plugin_catalog.py</vh></v>
<v t="ekr.20100808060203.4273"><vh>@file html/front.html</vh></v>
<v t="ekr.20101025080245.5801"><vh>@url modified toc</vh></v>
<v t="ekr.20101026081737.5531"><vh>Links that replace those in actual built page</vh></v>
<v t="ekr.20101112045055.5065"><vh>@url docs generated from plugin_catalog.py</vh></v>
</v>
<v t="ekr.20040414161647"><vh>Users Guide</vh>
<v t="ekr.20101104024804.4898"><vh> Generating the Users Guide</vh>
<v t="sps.20100708203040.19008"><vh>@@button generate-full-userguide</vh>
<v t="sps.20100708203040.19009"><vh>&lt;&lt; html manual &gt;&gt;</vh></v>
<v t="sps.20100708203040.19010"><vh>&lt;&lt; pdf manual &gt;&gt;</vh></v>
</v>
<v t="ville.20090705224948.5734"><vh>@@button generate-userguide</vh>
<v t="ville.20090705225609.5736"><vh>&lt;&lt; html manual &gt;&gt;</vh></v>
<v t="ville.20090705225609.5738"><vh>&lt;&lt; pdf manual &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20101025080245.5794"><vh>Preliminaries</vh>
<v t="ekr.20050831184021.3"><vh>Front matter</vh>
<v t="ekr.20100805165051.7148"><vh>@file frontMatter.txt</vh></v>
</v>
<v t="ekr.20070701101808"><vh>Preface</vh>
<v t="ekr.20100805165051.7149"><vh>@file preface.txt</vh></v>
</v>
<v t="ekr.20050831184021.4"><vh>What people are saying about Leo</vh>
<v t="ekr.20100805165051.7150"><vh>@file testimonials.txt</vh></v>
</v>
</v>
<v t="ekr.20101025080245.5795"><vh>Basics</vh>
<v t="ekr.20050831195331.1"><vh>FAQ</vh>
<v t="ekr.20100805165051.7151"><vh>@file FAQ.txt</vh></v>
</v>
<v t="ekr.20101007100904.4372"><vh>Slideshows page</vh>
<v t="ekr.20100821182153.4344"><vh>@file screen-shots.txt</vh></v>
</v>
<v t="ekr.20100731112744.7267"><vh>Installing Leo</vh>
<v t="ekr.20100805165051.7152" descendentVnodeUnknownAttributes="7d71005807000000302e302e342e3171017d710258120000007273745f687474705f61747472696275746571035d71042858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333722206e616d653d22687474702d6e6f64652d6d61726b65722d3337223e710558040000003c2f613e71065d71072858260000003c64697620636c6173733d2273656374696f6e222069643d22672d726566696e64616c6c223e710858060000003c2f6469763e71095d710a28584f0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e710b58060000003c2f6469763e710c5d710d28583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710e58060000003c2f6469763e710f5d71102858060000003c626f64793e711158070000003c2f626f64793e71125d71132858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711458070000003c2f68746d6c3e71154e656565656558070000003c2f6469763e0a711658070000003c2f6469763e0a711758350000003c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e0a7118586c0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313922206e616d653d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e52756e6e696e67204c656f20696e206261746368206d6f64653c2f613e3c2f68313e0a71196573732e"><vh>@file installing.txt</vh></v>
</v>
<v t="ekr.20091130111843.6787"><vh>The Leo Tutorial</vh>
<v t="ekr.20100805165051.7146"><vh>@file intro.txt</vh></v>
<v t="ekr.20100808120531.4280"><vh>@file outline-commands.txt</vh></v>
<v t="ekr.20100808120531.4283"><vh>@file nutshell.txt</vh></v>
</v>
<v t="EKR.20040524104904.26"><vh>Using Outlines</vh>
<v t="ekr.20100805165051.7153"><vh>@file outlines.txt</vh></v>
</v>
<v t="EKR.20040524104904.99"><vh>Using Leo's Commands</vh>
<v t="ekr.20100805165051.7155"><vh>@file commands.txt</vh></v>
</v>
<v t="EKR.20040524104904.211"><vh>Customizing Leo</vh>
<v t="ekr.20100805165051.7158"><vh>@file customizing.txt</vh></v>
</v>
</v>
<v t="ekr.20101025080245.5799"><vh>Intermediate Topics</vh>
<v t="ekr.20060430221745"><vh>Controlling syntax coloring</vh>
<v t="ekr.20100805165051.7165"><vh>@file coloring.txt</vh></v>
</v>
<v t="ekr.20050831184021.1"><vh>Creating documents with Leo</vh>
<v t="ekr.20100805165051.7164"><vh>@file rstplugin3.txt</vh></v>
</v>
<v t="ekr.20050831195331.4"><vh>Scripting Leo with Python</vh>
<v t="ekr.20100805165051.7157" descendentVnodeUnknownAttributes="7d7100285808000000302e302e332e313671017d710258120000007273745f687474705f61747472696275746571035d71042858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333722206e616d653d22687474702d6e6f64652d6d61726b65722d3337223e710558040000003c2f613e71065d71072858260000003c64697620636c6173733d2273656374696f6e222069643d22672d726566696e64616c6c223e710858060000003c2f6469763e71095d710a28584f0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e710b58060000003c2f6469763e710c5d710d28583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710e58060000003c2f6469763e710f5d71102858060000003c626f64793e711158070000003c2f626f64793e71125d71132858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711458070000003c2f68746d6c3e71154e656565656558070000003c2f6469763e0a711658070000003c2f6469763e0a711758350000003c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e0a7118586c0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313922206e616d653d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e52756e6e696e67204c656f20696e206261746368206d6f64653c2f613e3c2f68313e0a711965735807000000302e302e332e30711a7d711b58120000007273745f687474705f617474726962757465711c5d711d2858440000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3722206e616d653d22687474702d6e6f64652d6d61726b65722d37223e711e58040000003c2f613e711f5d71202858350000003c64697620636c6173733d2273656374696f6e222069643d22672d65732d77726974652d746f2d7468652d6c6f672d70616e65223e712158060000003c2f6469763e71225d712328583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e712458060000003c2f6469763e71255d71262858060000003c626f64793e712758070000003c2f626f64793e71285d71292858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e712a58070000003c2f68746d6c3e712b4e6565656558070000003c2f6469763e0a712c58460000003c64697620636c6173733d2273656374696f6e222069643d226170702d77696e646f776c6973742d7468652d6c6973742d6f662d616c6c2d6f70656e2d6672616d6573223e0a712d588e0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643422206e616d653d226170702d77696e646f776c6973742d7468652d6c6973742d6f662d616c6c2d6f70656e2d6672616d6573223e6170702e77696e646f774c6973743a20746865206c697374206f6620616c6c206f70656e206672616d65733c2f613e3c2f68313e0a712e65735807000000302e302e332e37712f7d713058120000007273745f687474705f61747472696275746571315d71322858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323922206e616d653d22687474702d6e6f64652d6d61726b65722d3239223e713358040000003c2f613e71345d71352858390000003c64697620636c6173733d2273656374696f6e222069643d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e713658060000003c2f6469763e71375d713828583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e713958060000003c2f6469763e713a5d713b2858060000003c626f64793e713c58070000003c2f626f64793e713d5d713e2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e713f58070000003c2f68746d6c3e71404e6565656558070000003c2f6469763e0a7141583b0000003c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d707265666572656e636573223e0a714258780000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313522206e616d653d2267657474696e672d616e642d73657474696e672d707265666572656e636573223e47657474696e6720616e642073657474696e6720707265666572656e6365733c2f613e3c2f68313e0a714365735807000000302e302e332e3571447d714558120000007273745f687474705f61747472696275746571465d71472858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323722206e616d653d22687474702d6e6f64652d6d61726b65722d3237223e714858040000003c2f613e71495d714a28582e0000003c64697620636c6173733d2273656374696f6e222069643d227570646174696e672d7468652d73637265656e223e714b58060000003c2f6469763e714c5d714d28583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e714e58060000003c2f6469763e714f5d71502858060000003c626f64793e715158070000003c2f626f64793e71525d71532858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e715458070000003c2f68746d6c3e71554e6565656558070000003c2f6469763e0a7156583a0000003c64697620636c6173733d2273656374696f6e222069643d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e0a715758760000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313422206e616d653d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e496e766f6b696e6720636f6d6d616e64732066726f6d20736372697074733c2f613e3c2f68313e0a715865735809000000302e302e312e362e3471597d715a58120000007273745f687474705f617474726962757465715b5d715c2858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323122206e616d653d22687474702d6e6f64652d6d61726b65722d3231223e715d58040000003c2f613e715e5d715f2858480000003c64697620636c6173733d2273656374696f6e222069643d22702d7369626c696e67732d697465722d616e642d702d666f6c6c6f77696e672d7369626c696e67732d69746572223e716058060000003c2f6469763e71615d716228582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e716358060000003c2f6469763e71645d716528583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e716658060000003c2f6469763e71675d71682858060000003c626f64793e716958070000003c2f626f64793e716a5d716b2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e716c58070000003c2f68746d6c3e716d4e656565656558070000003c2f6469763e0a716e58460000003c64697620636c6173733d2273656374696f6e222069643d22702d737562747265652d697465722d616e642d702d73656c662d616e642d737562747265652d69746572223e0a716f588e0000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313122206e616d653d22702d737562747265652d697465722d616e642d702d73656c662d616e642d737562747265652d69746572223e702e737562747265655f6974657220616e6420702e73656c665f616e645f737562747265655f697465723c2f613e3c2f68323e0a717065735809000000302e302e312e362e3271717d717258120000007273745f687474705f61747472696275746571735d71742858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313722206e616d653d22687474702d6e6f64652d6d61726b65722d3137223e717558040000003c2f613e71765d717728582a0000003c64697620636c6173733d2273656374696f6e222069643d22702d6368696c6472656e2d69746572223e717858060000003c2f6469763e71795d717a28582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e717b58060000003c2f6469763e717c5d717d28583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e717e58060000003c2f6469763e717f5d71802858060000003c626f64793e718158070000003c2f626f64793e71825d71832858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e718458070000003c2f68746d6c3e71854e656565656558070000003c2f6469763e0a718658460000003c64697620636c6173733d2273656374696f6e222069643d22702d706172656e74732d697465722d616e642d702d73656c662d616e642d706172656e74732d69746572223e0a7187588d0000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643922206e616d653d22702d706172656e74732d697465722d616e642d702d73656c662d616e642d706172656e74732d69746572223e702e706172656e74735f6974657220616e6420702e73656c665f616e645f706172656e74735f697465723c2f613e3c2f68323e0a718865735809000000302e302e312e362e3371897d718a58120000007273745f687474705f617474726962757465718b5d718c2858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313922206e616d653d22687474702d6e6f64652d6d61726b65722d3139223e718d58040000003c2f613e718e5d718f2858450000003c64697620636c6173733d2273656374696f6e222069643d22702d706172656e74732d697465722d616e642d702d73656c662d616e642d706172656e74732d69746572223e719058060000003c2f6469763e71915d719228582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e719358060000003c2f6469763e71945d719528583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e719658060000003c2f6469763e71975d71982858060000003c626f64793e719958070000003c2f626f64793e719a5d719b2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e719c58070000003c2f68746d6c3e719d4e656565656558070000003c2f6469763e0a719e58490000003c64697620636c6173733d2273656374696f6e222069643d22702d7369626c696e67732d697465722d616e642d702d666f6c6c6f77696e672d7369626c696e67732d69746572223e0a719f58940000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313022206e616d653d22702d7369626c696e67732d697465722d616e642d702d666f6c6c6f77696e672d7369626c696e67732d69746572223e702e7369626c696e67735f6974657220616e6420702e666f6c6c6f77696e675f7369626c696e67735f697465723c2f613e3c2f68323e0a71a065735809000000302e302e312e362e3071a17d71a258120000007273745f687474705f61747472696275746571a35d71a42858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313322206e616d653d22687474702d6e6f64652d6d61726b65722d3133223e71a558040000003c2f613e71a65d71a728582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e71a858060000003c2f6469763e71a95d71aa28583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e71ab58060000003c2f6469763e71ac5d71ad2858060000003c626f64793e71ae58070000003c2f626f64793e71af5d71b02858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e71b158070000003c2f68746d6c3e71b24e65656565582b0000003c64697620636c6173733d2273656374696f6e222069643d22632d616c6c6e6f6465732d69746572223e0a71b358570000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643722206e616d653d22632d616c6c6e6f6465732d69746572223e632e616c6c4e6f6465735f697465723c2f613e3c2f68323e0a71b465735809000000302e302e312e362e3171b57d71b658120000007273745f687474705f61747472696275746571b75d71b82858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313522206e616d653d22687474702d6e6f64652d6d61726b65722d3135223e71b958040000003c2f613e71ba5d71bb28582a0000003c64697620636c6173733d2273656374696f6e222069643d22632d616c6c6e6f6465732d69746572223e71bc58060000003c2f6469763e71bd5d71be28582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e71bf58060000003c2f6469763e71c05d71c128583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e71c258060000003c2f6469763e71c35d71c42858060000003c626f64793e71c558070000003c2f626f64793e71c65d71c72858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e71c858070000003c2f68746d6c3e71c94e656565656558070000003c2f6469763e0a71ca582b0000003c64697620636c6173733d2273656374696f6e222069643d22702d6368696c6472656e2d69746572223e0a71cb58570000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643822206e616d653d22702d6368696c6472656e2d69746572223e702e6368696c6472656e5f697465723c2f613e3c2f68323e0a71cc65735807000000302e302e312e3171cd7d71ce58120000007273745f687474705f61747472696275746571cf5d71d02858440000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3122206e616d653d22687474702d6e6f64652d6d61726b65722d31223e71d158040000003c2f613e71d25d71d328583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e71d458060000003c2f6469763e71d55d71d62858060000003c626f64793e71d758070000003c2f626f64793e71d85d71d92858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e71da58070000003c2f68746d6c3e71db4e65656558240000003c64697620636c6173733d2273656374696f6e222069643d226f76657276696577223e0a71dc58490000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643122206e616d653d226f76657276696577223e4f766572766965773c2f613e3c2f68313e0a71dd65735807000000302e302e312e3271de7d71df58120000007273745f687474705f61747472696275746571e05d71e12858440000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3522206e616d653d22687474702d6e6f64652d6d61726b65722d35223e71e258040000003c2f613e71e35d71e42858400000003c64697620636c6173733d2273656374696f6e222069643d22672d746f702d7468652d636f6d6d616e6465722d6f662d7468652d746f702d77696e646f77223e71e558060000003c2f6469763e71e65d71e728583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e71e858060000003c2f6469763e71e95d71ea2858060000003c626f64793e71eb58070000003c2f626f64793e71ec5d71ed2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e71ee58070000003c2f68746d6c3e71ef4e6565656558070000003c2f6469763e0a71f058360000003c64697620636c6173733d2273656374696f6e222069643d22672d65732d77726974652d746f2d7468652d6c6f672d70616e65223e0a71f158700000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643322206e616d653d22672d65732d77726974652d746f2d7468652d6c6f672d70616e65223e672e657328293a20777269746520746f20746865206c6f672070616e653c2f613e3c2f68313e0a71f265735807000000302e302e312e3371f37d71f458120000007273745f687474705f61747472696275746571f55d71f62858440000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3922206e616d653d22687474702d6e6f64652d6d61726b65722d39223e71f758040000003c2f613e71f85d71f92858450000003c64697620636c6173733d2273656374696f6e222069643d226170702d77696e646f776c6973742d7468652d6c6973742d6f662d616c6c2d6f70656e2d6672616d6573223e71fa58060000003c2f6469763e71fb5d71fc28583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e71fd58060000003c2f6469763e71fe5d71ff2858060000003c626f64793e720001000058070000003c2f626f64793e72010100005d72020100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e720301000058070000003c2f68746d6c3e72040100004e6565656558070000003c2f6469763e0a720501000058460000003c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d686561646c696e652d616e642d626f64792d74657874223e0a7206010000588d0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643522206e616d653d2267657474696e672d616e642d73657474696e672d686561646c696e652d616e642d626f64792d74657874223e47657474696e6720616e642073657474696e6720686561646c696e6520616e6420626f647920746578743c2f613e3c2f68313e0a720701000065735807000000302e302e312e3472080100007d720901000058120000007273745f687474705f617474726962757465720a0100005d720b0100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323522206e616d653d22687474702d6e6f64652d6d61726b65722d3235223e720c01000058040000003c2f613e720d0100005d720e01000028583e0000003c64697620636c6173733d2273656374696f6e222069643d2274657374696e672d776865746865722d612d706f736974696f6e2d69732d76616c6964223e720f01000058060000003c2f6469763e72100100005d721101000028582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e721201000058060000003c2f6469763e72130100005d721401000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e721501000058060000003c2f6469763e72160100005d72170100002858060000003c626f64793e721801000058070000003c2f626f64793e72190100005d721a0100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e721b01000058070000003c2f68746d6c3e721c0100004e656565656558070000003c2f6469763e0a721d01000058070000003c2f6469763e0a721e010000582f0000003c64697620636c6173733d2273656374696f6e222069643d227570646174696e672d7468652d73637265656e223e0a721f01000058600000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313322206e616d653d227570646174696e672d7468652d73637265656e223e5570646174696e67207468652073637265656e3c2f613e3c2f68313e0a722001000065735807000000302e302e312e3672210100007d722201000058120000007273745f687474705f61747472696275746572230100005d72240100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313122206e616d653d22687474702d6e6f64652d6d61726b65722d3131223e722501000058040000003c2f613e72260100005d72270100002858450000003c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d686561646c696e652d616e642d626f64792d74657874223e722801000058060000003c2f6469763e72290100005d722a01000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e722b01000058060000003c2f6469763e722c0100005d722d0100002858060000003c626f64793e722e01000058070000003c2f626f64793e722f0100005d72300100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e723101000058070000003c2f68746d6c3e72320100004e6565656558070000003c2f6469763e0a7233010000582f0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e0a7234010000585f0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643622206e616d653d2274726176657273696e672d6f75746c696e6573223e54726176657273696e67206f75746c696e65733c2f613e3c2f68313e0a723501000065735807000000302e302e312e3772360100007d723701000058120000007273745f687474705f61747472696275746572380100005d72390100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323322206e616d653d22687474702d6e6f64652d6d61726b65722d3233223e723a01000058040000003c2f613e723b0100005d723c0100002858450000003c64697620636c6173733d2273656374696f6e222069643d22702d737562747265652d697465722d616e642d702d73656c662d616e642d737562747265652d69746572223e723d01000058060000003c2f6469763e723e0100005d723f01000028582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e724001000058060000003c2f6469763e72410100005d724201000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e724301000058060000003c2f6469763e72440100005d72450100002858060000003c626f64793e724601000058070000003c2f626f64793e72470100005d72480100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e724901000058070000003c2f68746d6c3e724a0100004e656565656558070000003c2f6469763e0a724b010000583f0000003c64697620636c6173733d2273656374696f6e222069643d2274657374696e672d776865746865722d612d706f736974696f6e2d69732d76616c6964223e0a724c01000058800000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313222206e616d653d2274657374696e672d776865746865722d612d706f736974696f6e2d69732d76616c6964223e54657374696e672077686574686572206120706f736974696f6e2069732076616c69643c2f613e3c2f68323e0a724d01000065735807000000302e302e332e38724e0100007d724f01000058120000007273745f687474705f61747472696275746572500100005d72510100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333922206e616d653d22687474702d6e6f64652d6d61726b65722d3339223e725201000058040000003c2f613e72530100005d72540100002858340000003c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e725501000058060000003c2f6469763e72560100005d725701000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e725801000058060000003c2f6469763e72590100005d725a0100002858060000003c626f64793e725b01000058070000003c2f626f64793e725c0100005d725d0100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e725e01000058070000003c2f68746d6c3e725f0100004e6565656558070000003c2f6469763e0a7260010000583e0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e0a7261010000587e0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323022206e616d653d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e46756e6374696f6e7320646566696e656420696e206c656f476c6f62616c732e70793c2f613e3c2f68313e0a726201000065735808000000302e302e312e313172630100007d726401000058120000007273745f687474705f61747472696275746572650100005d72660100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343322206e616d653d22687474702d6e6f64652d6d61726b65722d3433223e726701000058040000003c2f613e72680100005d726901000028583a0000003c64697620636c6173733d2273656374696f6e222069643d227265646972656374696e672d6f75747075742d66726f6d2d73637269707473223e726a01000058060000003c2f6469763e726b0100005d726c01000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e726d01000058060000003c2f6469763e726e0100005d726f0100002858060000003c626f64793e727001000058070000003c2f626f64793e72710100005d72720100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e727301000058070000003c2f68746d6c3e72740100004e6565656558070000003c2f6469763e0a727501000058450000003c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e0a7276010000588c0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323222206e616d653d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e53756d6d617279206f662074686520766e6f646520616e6420706f736974696f6e20636c61737365733c2f613e3c2f68313e0a727701000065735808000000302e302e332e313072780100007d727901000058120000007273745f687474705f617474726962757465727a0100005d727b0100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343122206e616d653d22687474702d6e6f64652d6d61726b65722d3431223e727c01000058040000003c2f613e727d0100005d727e01000028583d0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e727f01000058060000003c2f6469763e72800100005d728101000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e728201000058060000003c2f6469763e72830100005d72840100002858060000003c626f64793e728501000058070000003c2f626f64793e72860100005d72870100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e728801000058070000003c2f68746d6c3e72890100004e6565656558070000003c2f6469763e0a728a010000583b0000003c64697620636c6173733d2273656374696f6e222069643d227265646972656374696e672d6f75747075742d66726f6d2d73637269707473223e0a728b01000058780000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323122206e616d653d227265646972656374696e672d6f75747075742d66726f6d2d73637269707473223e5265646972656374696e67206f75747075742066726f6d20736372697074733c2f613e3c2f68313e0a728c0100006573580a000000302e302e312e31312e32728d0100007d728e01000058120000007273745f687474705f617474726962757465728f0100005d72900100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343922206e616d653d22687474702d6e6f64652d6d61726b65722d3439223e729101000058040000003c2f613e72920100005d72930100002858220000003c64697620636c6173733d2273656374696f6e222069643d2267657474657273223e729401000058060000003c2f6469763e72950100005d72960100002858440000003c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e729701000058060000003c2f6469763e72980100005d729901000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e729a01000058060000003c2f6469763e729b0100005d729c0100002858060000003c626f64793e729d01000058070000003c2f626f64793e729e0100005d729f0100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e72a001000058070000003c2f68746d6c3e72a10100004e656565656558070000003c2f6469763e0a72a201000058230000003c64697620636c6173733d2273656374696f6e222069643d2273657474657273223e0a72a301000058480000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323522206e616d653d2273657474657273223e536574746572733c2f613e3c2f68323e0a72a40100006573580a000000302e302e312e31312e3172a50100007d72a601000058120000007273745f687474705f61747472696275746572a70100005d72a80100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343722206e616d653d22687474702d6e6f64652d6d61726b65722d3437223e72a901000058040000003c2f613e72aa0100005d72ab0100002858240000003c64697620636c6173733d2273656374696f6e222069643d226974657261746f7273223e72ac01000058060000003c2f6469763e72ad0100005d72ae0100002858440000003c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e72af01000058060000003c2f6469763e72b00100005d72b101000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e72b201000058060000003c2f6469763e72b30100005d72b40100002858060000003c626f64793e72b501000058070000003c2f626f64793e72b60100005d72b70100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e72b801000058070000003c2f68746d6c3e72b90100004e656565656558070000003c2f6469763e0a72ba01000058230000003c64697620636c6173733d2273656374696f6e222069643d2267657474657273223e0a72bb01000058480000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323422206e616d653d2267657474657273223e476574746572733c2f613e3c2f68323e0a72bc0100006573580a000000302e302e312e31312e3072bd0100007d72be01000058120000007273745f687474705f61747472696275746572bf0100005d72c00100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343522206e616d653d22687474702d6e6f64652d6d61726b65722d3435223e72c101000058040000003c2f613e72c20100005d72c30100002858440000003c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e72c401000058060000003c2f6469763e72c50100005d72c601000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e72c701000058060000003c2f6469763e72c80100005d72c90100002858060000003c626f64793e72ca01000058070000003c2f626f64793e72cb0100005d72cc0100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e72cd01000058070000003c2f68746d6c3e72ce0100004e6565656558250000003c64697620636c6173733d2273656374696f6e222069643d226974657261746f7273223e0a72cf010000584c0000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323322206e616d653d226974657261746f7273223e4974657261746f72733c2f613e3c2f68323e0a72d00100006573752e"><vh>@file scripting.txt</vh></v>
</v>
<v t="ekr.20050912125144"><vh>Plugins</vh>
<v t="ekr.20100805165051.7162"><vh>@file plugins.txt</vh></v>
</v>
<v t="ekr.20060612102055"><vh>Writing Plugins</vh>
<v t="ekr.20100805165051.7163"><vh>@file writingPlugins.txt</vh></v>
</v>
<v t="ekr.20070628083442"><vh>Unit testing with Leo</vh>
<v t="ekr.20100805165051.7170"><vh>@file unitTesting.txt</vh></v>
</v>
<v t="ekr.20060527105211"><vh>Debugging with Leo</vh>
<v t="ekr.20100805165051.7166"><vh>@file debuggers.txt</vh></v>
</v>
<v t="ekr.20080730212711.14"><vh>Using @shadow</vh>
<v t="ekr.20100805165051.7173"><vh>@file atShadow.txt</vh></v>
</v>
</v>
<v t="ekr.20101025080245.5798"><vh>Leo and Other Programs</vh>
<v t="ekr.20061025065357"><vh>Leo and Emacs</vh>
<v t="ekr.20100805165051.7168"><vh>@file emacs.txt</vh></v>
</v>
<v t="ekr.20080203101507"><vh>ILeo - the IPython bridge</vh>
<v t="ekr.20100805165051.7171"><vh>@file IpythonBridge.txt</vh></v>
</v>
<v t="ekr.20070317033759"><vh>Embedding Leo with the leoBridge module</vh>
<v t="ekr.20100805165051.7169"><vh>@file leoBridge.txt</vh></v>
</v>
<v t="TL.20080804095315.1"><vh>Using Vim with Leo</vh>
<v t="ekr.20100805165051.7172"><vh>@file vimBindings.txt</vh></v>
</v>
<v t="ekr.20060913164304"><vh>Using ZODB with Leo</vh>
<v t="ekr.20100805165051.7167"><vh>@file zodb.txt</vh></v>
</v>
</v>
<v t="ekr.20101025080245.5796"><vh>Reference</vh>
<v t="ekr.20050831184021.5"><vh>Leo's Reference</vh>
<v t="ekr.20100805001344.7253"><vh>@file directives.txt</vh></v>
</v>
<v t="EKR.20040524104904.161"><vh>Designing with Leo</vh>
<v t="ekr.20100805165051.7156"><vh>@file design.txt</vh></v>
</v>
<v t="EKR.20040524104904.245"><vh>History of Leo</vh>
<v t="ekr.20100805165051.7159"><vh>@file history.txt</vh></v>
</v>
<v t="EKR.20040524104904.261"><vh>Theory of Operation</vh>
<v t="ekr.20100805165051.7160"><vh>@file theory.txt</vh></v>
</v>
<v t="ekr.20050901084134"><vh>White papers</vh>
<v t="ekr.20100805165051.7161"><vh>@file whitepapers.txt</vh></v>
</v>
<v t="EKR.20040524104904.274"><vh>Appendices</vh>
<v t="ekr.20100805165051.7174"><vh>@file appendices.txt</vh></v>
</v>
<v t="ekr.20091111112709.6671"><vh>Glossary</vh>
<v t="ekr.20100805165051.7147"><vh>@file glossary.txt</vh></v>
</v>
</v>
<v t="ekr.20060620094033"><vh>What's New...</vh>
<v t="ekr.20100805165051.7175"><vh>@file whatsnew.txt</vh></v>
</v>
<v t="ekr.20111127144911.5545"><vh>Other pages</vh>
<v t="ekr.20111127144911.5546"><vh>@file download.txt</vh></v>
</v>
</v>
<v t="ekr.20090717084250.10702"><vh>Other docs</vh>
<v t="ekr.20100805165051.7176"><vh>@file other_docs.txt</vh></v>
</v>
<v t="ekr.20100821182153.4341"><vh>Slideshows</vh>
<v t="ekr.20101028110015.8271" descendentVnodeUnknownAttributes="7d710028580b000000302e312e312e382e342e3171017d7102580b0000007374725f6c656f5f706f7371035800000000710473580b000000302e312e312e382e332e3171057d7106580b0000007374725f6c656f5f706f737107680473580b000000302e312e312e382e352e3171087d7109580b0000007374725f6c656f5f706f73710a680473580b000000302e312e312e382e322e31710b7d710c580b0000007374725f6c656f5f706f73710d680473752e"><vh>@file slideshows.txt</vh></v>
</v>
<v t="ekr.20101026082911.5536"><vh>Release notes</vh>
<v t="ekr.20100805165051.7177"><vh>@file release_notes.txt</vh></v>
</v>
<v t="ekr.20111108053709.5534"><vh>@mark-for-unit-tests</vh>
<v t="ekr.20111107180918.5553"><vh>@rst intro-pdf.pdf</vh>
<v t="ekr.20111107180918.5554"><vh>@rst html\intro.html</vh>
<v t="ekr.20111107180918.5555"><vh>@rst-no-head links</vh></v>
<v t="ekr.20111107180918.5556"><vh>Leo's main window</vh></v>
<v t="ekr.20111107180918.5557"><vh>External files and @file nodes</vh></v>
<v t="ekr.20111107180918.5558"><vh>Creating external files from outlines</vh>
<v t="ekr.20111107180918.5559"><vh>Section references</vh></v>
<v t="ekr.20111107180918.5560"><vh>The @others directive</vh></v>
<v t="ekr.20111107180918.5561"><vh>The @all directive</vh></v>
<v t="ekr.20111107180918.5562"><vh>Choosing between @others and sections</vh></v>
<v t="ekr.20111107180918.5563"><vh>Organizing programs as outlines</vh></v>
</v>
<v t="ekr.20111107180918.5564"><vh>Clones &amp; views</vh></v>
<v t="ekr.20111107180918.5565"><vh>More about directives</vh></v>
<v t="ekr.20111107180918.5566"><vh>Scripting, extending and customizing Leo</vh></v>
<v t="ekr.20111107180918.5567"><vh>Summary</vh></v>
<v t="ekr.20111107180918.5568"><vh>Further study</vh></v>
</v>
</v>
</v>
<v t="ekr.20111107194933.5505"><vh>@test rst intro</vh></v>
<v t="ekr.20120229094652.14053"><vh>Leo 4.10 Release notes</vh>
<v t="ekr.20120229094652.14757"><vh>Bugs</vh>
<v t="ekr.20120229094652.14758"><vh>Fixed ancient hanger in paste-retaining-clones</vh></v>
<v t="ekr.20120229094652.14759"><vh>Fixed bug in p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20120229094652.14760"><vh>Removed timer hack from double-click code</vh></v>
<v t="ekr.20120229094652.14761"><vh>Fixed double-click problem</vh></v>
<v t="ekr.20120229094652.14762"><vh>Fixed url focus issues</vh></v>
<v t="ekr.20120229094652.14763"><vh>Fixed p1 &gt; p2</vh></v>
<v t="ekr.20120229094652.14764"><vh>Fixed cacher problem</vh></v>
<v t="ekr.20120229094652.14765"><vh>Fixed encoding problem with @shadow</vh></v>
<v t="ekr.20120229094652.14766"><vh>Fixed a w.see botch.</vh></v>
<v t="ekr.20120229094652.14767"><vh>Fixed a major DnD bug</vh></v>
<v t="ekr.20120229094652.14768"><vh>Fixed macro crash</vh></v>
<v t="ekr.20120229094652.14769"><vh>Regularized slashes in @edit/@file</vh></v>
<v t="ekr.20120229094652.14770"><vh>Made sure Leo's write code auto-detects file extension</vh></v>
<v t="ekr.20120229094652.14771"><vh>Fixed k.setLabelRed</vh></v>
<v t="ekr.20120229094652.14772"><vh>Fixed cycle-editor-focus bug</vh></v>
<v t="ekr.20120229094652.14774"><vh>Fixed recent createFrame crash</vh></v>
<v t="ekr.20120229094652.14775"><vh>Fixed Py3k crash in quicksearch.py</vh></v>
<v t="ekr.20120229094652.14776"><vh>Removed all references to scrolledmessage plugin</vh></v>
<v t="ekr.20120229094652.14777"><vh>Support @ignore when installing @command/@button nodes</vh></v>
<v t="ekr.20120229094652.14778"><vh>Fixed crasher in runScrolledMessageDialog</vh></v>
<v t="ekr.20120229094652.14779"><vh>Macro expansion now forces a full recolor</vh></v>
<v t="ekr.20120229094652.14780"><vh>Fixed serious atFile read bug</vh></v>
<v t="ekr.20120229094652.14781"><vh>Fixed unicode bugs with @shadow</vh></v>
<v t="ekr.20120229094652.14782"><vh>Recompute width of hard tabs depending on @tabwidth</vh></v>
<v t="ekr.20120229094652.14783"><vh>Applied patch for Bug 800311: Undo: Word granularity should recognize cursor movements</vh></v>
<v t="ekr.20120229094652.14784"><vh>Applied patch for Bug 800312: Collapsing node moves should be optional</vh></v>
<v t="ekr.20120229094652.14785"><vh>Fixed Bug 880975: Binding Meta and print-bindings</vh></v>
<v t="ekr.20120229094652.14786"><vh>Fixed bug 823601: cascade-windows fails</vh></v>
<v t="ekr.20120229094652.14787"><vh>Generalized stylesheet handling</vh>
<v t="ekr.20120229094652.14788"><vh>Notes</vh></v>
</v>
<v t="ekr.20120229094652.14789"><vh>Scrolling bug</vh>
<v t="ekr.20120229094652.14975"><vh>Notes</vh></v>
<v t="ekr.20120229094652.14976"><vh>First attempt</vh></v>
<v t="ekr.20120229094652.14792"><vh>Second attempt</vh></v>
</v>
<v t="ekr.20120229094652.14817"><vh>Fixed html colorizing by fixing a bad bug in g.importFromPath</vh></v>
<v t="ekr.20120229094652.14818"><vh>Allow lower case keywords in colorizer</vh></v>
<v t="ekr.20120229094652.14819"><vh>Fixed recent problem in createMenuEntries</vh></v>
<v t="ekr.20120229094652.14820"><vh>Fixed rst3 pdf problem</vh></v>
<v t="ekr.20120229094652.14821"><vh>Added unit test that all plugins have an init method</vh></v>
<v t="ekr.20120229094652.14822"><vh>Removed traceback when cancelling a write</vh></v>
<v t="ekr.20120229094652.14823"><vh>Fixed removeBlankLinesTokens</vh></v>
<v t="ekr.20120229094652.14824"><vh>Fixed crasher in config.set</vh></v>
<v t="ekr.20120229094652.14825"><vh>Fixed resize-to-screen and minimize-all</vh></v>
<v t="ekr.20120229094652.14826"><vh>Fixed html import problems</vh></v>
<v t="ekr.20120229094652.14827"><vh>Removed extra newlines in g.trace</vh></v>
<v t="ekr.20120229094652.14828"><vh>Fixed crash in compareTokens</vh></v>
<v t="ekr.20120229094652.14829"><vh>Finished import work</vh></v>
<v t="ekr.20120229094652.14831"><vh>Fixed hard crash when deleting body editor 3 times</vh></v>
<v t="ekr.20120229094652.14832"><vh>Fixed add/delete html comments</vh></v>
<v t="ekr.20120229094652.14833"><vh>Fixed bug that prevented text bindings from working in log tabs</vh></v>
<v t="ekr.20120229094652.14834"><vh>Fixed cycle-all-focus command</vh></v>
<v t="ekr.20120229094652.14835"><vh>Fixed crashers involving calls to w.setSelectionRange</vh></v>
<v t="ekr.20120229094652.14836"><vh>Fixed hang in cycleAllFocus</vh></v>
<v t="ekr.20120229094652.14837"><vh>Fixed crasher in k.handleDefaultChar</vh></v>
<v t="ekr.20120229094652.14838"><vh>Fixed bug: Focus lost after opening or closing tab</vh></v>
<v t="ekr.20120229094652.14839"><vh>Ignore unbound Alt/Ctrl keys, especially Alt/Ctrl-N</vh></v>
<v t="ekr.20120229094652.14840"><vh>Fixed bug: ensure global @buttons work</vh></v>
<v t="ekr.20120229094652.14841"><vh>Fixed bug in p.moveToFirstChild</vh></v>
<v t="ekr.20120229094652.14842"><vh>Fixed bug 804960: Refreshing unlinks clones, just reopening connects them again</vh></v>
<v t="ekr.20120229094652.14848"><vh>Fixed crasher in reportMismatch</vh></v>
<v t="ekr.20120229094652.14849"><vh>Disabled section-reference handling in @auto files</vh></v>
<v t="ekr.20120229094652.14850"><vh>Fix bug: Allow @all only in top-level @&lt;file&gt; nodes (test2.leo)</vh></v>
<v t="ekr.20120229094652.14855"><vh>Fixed erroneous "file changed" message</vh></v>
<v t="ekr.20120229094652.14856"><vh>Fixed bug 889175: Changing @auto paths overwrites files without warning</vh></v>
<v t="ekr.20120229094652.14891"><vh>Fixed bug in DynamicWindow.setGeometry</vh></v>
<v t="ekr.20120229094652.14892"><vh>Fixed bug 87933: Redefining a key binding breaks menu items with same binding</vh>
<v t="ekr.20120229094652.14893"><vh> Report</vh></v>
<v t="ekr.20120229094652.14894"><vh>Bug 815564: Plugin Menu-Keystroke binding can prevent plugin help display</vh></v>
<v t="ekr.20120229094652.14925"><vh>Updating dependent dicts</vh></v>
</v>
<v t="ekr.20120229094652.14934"><vh>Fixed bug: @button @key=x does not override x</vh></v>
<v t="ekr.20120229094652.14941"><vh>Fixed Bug: @mark-for-unit-tests nodes</vh></v>
<v t="ekr.20120229094652.14942"><vh>The clean,clear&amp; sort recent files commands now work</vh></v>
<v t="ekr.20120229094652.14973"><vh>Fixed the wretched scrolling bug</vh></v>
<v t="ekr.20120229094652.15012"><vh>Fixed bug: @int pagewidth now set c.page_width</vh></v>
<v t="ekr.20120229094652.15013"><vh>Fixed bug: goto end line handler is broken</vh></v>
<v t="ekr.20120229094652.14520"><vh>Removed unused color tags</vh></v>
<v t="ekr.20120229094652.15147"><vh>Fixed bug: End only goes to physical line</vh></v>
<v t="ekr.20120229094652.15146"><vh>rev 4952 fixes bug 87933 with major key reorg</vh></v>
</v>
<v t="ekr.20120229094652.14518"><vh>Code improvements</vh>
<v t="ekr.20120229094652.15175"><vh>Major</vh>
<v t="ekr.20120229094652.15142"><vh>Leo's new classes</vh></v>
</v>
<v t="ekr.20120229094652.15176"><vh>Minor</vh>
<v t="ekr.20120229094652.14522"><vh>Eliminated the low-level interface</vh></v>
<v t="ekr.20120229094652.14523"><vh>Removed unused cruft from high-level interface</vh></v>
<v t="ekr.20120229094652.14524"><vh>All unit tests may now be run externally</vh></v>
<v t="ekr.20120229094652.14525"><vh>Unified the high-level interface</vh></v>
<v t="ekr.20120229094652.14526"><vh>Create properties for logCtrl &amp; bodyCtrl</vh></v>
<v t="ekr.20120229094652.14527"><vh>Added eventFilters to top-level frames</vh></v>
<v t="ekr.20120229094652.14528"><vh>added log.orderedTabNames</vh></v>
<v t="ekr.20120229094652.14531"><vh>Removed many module-level imports</vh></v>
<v t="ekr.20120229094652.14532"><vh>Created the TestManager class</vh></v>
<v t="ekr.20120229094652.14533"><vh>Created the LoadManager class (docs)</vh></v>
<v t="ekr.20120229094652.14534"><vh>Removed c argument from g.app.config getters</vh></v>
<v t="ekr.20120229094652.14535"><vh>Delay "reading settings" message until after signon</vh>
<v t="ekr.20120229094652.14536"><vh>pr (codewise)</vh></v>
<v t="ekr.20120229094652.14537"><vh>g.pr</vh></v>
</v>
<v t="ekr.20120229094652.14538"><vh>Use at.readOneAtAutoNode instead of ic.readOneAtAutoNode</vh></v>
<v t="ekr.20120229094652.14578"><vh>Added p.positionAfterDeletedTree</vh></v>
<v t="ekr.20120229094652.14577"><vh>Removed Leo's old syntax coloring code</vh></v>
<v t="ekr.20120229094652.14583"><vh>Rewrote shell-command commands</vh></v>
<v t="ekr.20120229094652.14608"><vh>Added g.app.isExternalUnitTest</vh></v>
<v t="ekr.20120229094652.14611"><vh>Added c.config.set</vh></v>
</v>
<v t="ekr.20120229094652.15157"><vh>Investigations</vh>
<v t="ekr.20120229094652.15158"><vh>Investigated unicode problems with print</vh></v>
<v t="ekr.20120229094652.15159"><vh>Investigated autocomplete popup bug</vh></v>
</v>
<v t="ekr.20120229094652.15138"><vh>version.py now uses bzr_version.py</vh></v>
<v t="ekr.20120229094652.15139"><vh>Changed calling signatures of g.openWithFileName and g.app.newCommander</vh></v>
<v t="ekr.20120229094652.19777"><vh>The open-with event now has a new format</vh></v>
<v t="ekr.20120229173025.20636"><vh>Theory of operation: key handling</vh></v>
</v>
<v t="ekr.20120229094652.15170"><vh>Commands: improved</vh>
<v t="ekr.20120229094652.14612"><vh>Alt-left-arrow collapses all children when selecting the parent</vh></v>
<v t="ekr.20120229094652.15169"><vh>Improved page-up &amp; page-down commands</vh></v>
<v t="ekr.20120229094652.14622"><vh>Improved presentation of bindings</vh></v>
<v t="ekr.20120229094652.14618"><vh>Improved print-bindings &amp; print-commands</vh></v>
<v t="ekr.20120229094652.14580"><vh>Open now shows all files</vh></v>
<v t="ekr.20120229094652.14617"><vh>Selected @test node always run</vh></v>
</v>
<v t="ekr.20120229094652.15164"><vh>Commands: new</vh>
<v t="ekr.20120229094652.14590"><vh>Added @button split-defs</vh></v>
<v t="ekr.20120229094652.14544"><vh>Added beautify-c command</vh></v>
<v t="ekr.20120229094652.14545"><vh>Added c-to-python command</vh></v>
<v t="ekr.20120229094652.14625"><vh>Added clone-find-all-flattened command</vh>
<v t="ekr.20120229094652.14626"><vh>cloneFindAll (minibufferFind)</vh></v>
<v t="ekr.20120229094652.14627"><vh>cloneFindAllCommand &amp; cloneFindAllFlattenedCommand</vh></v>
<v t="ekr.20120229094652.14628"><vh>cloneFindAllFlattened (minibufferFind)</vh></v>
<v t="ekr.20120229094652.14629"><vh>Find wrappers</vh></v>
<v t="ekr.20120229094652.14630"><vh>generalSearchHelper (minibufferFind)</vh></v>
<v t="ekr.20120229094652.14631"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20120229094652.14632"><vh>findAll &amp; helper (leoFind)</vh>
<v t="ekr.20120229094652.14633"><vh>createCloneFindAllNode</vh></v>
</v>
</v>
<v t="ekr.20120229094652.15090"><vh>Added clone/move/delete-marked commands</vh></v>
<v t="ekr.20120229094652.14579"><vh>Added delete-marked-nodes and move-marked-nodes commands</vh></v>
<v t="ekr.20120229094652.14584"><vh>Added shell commands to Cmds menu</vh></v>
<v t="ekr.20120229094652.14602"><vh>Support run-marked-unit-tests-locally/externally</vh></v>
</v>
<v t="ekr.20120229094652.19778"><vh>Events</vh></v>
<v t="ekr.20120229094652.15162"><vh>Features: major</vh>
<v t="ekr.20120229094652.14585"><vh>Added quick edit/save mode</vh>
<v t="ekr.20120229094652.14586"><vh>Request</vh></v>
<v t="ekr.20120229094652.14587"><vh>Checkin log</vh></v>
<v t="ekr.20120229094652.14588"><vh>Changed</vh></v>
</v>
<v t="ekr.20120229094652.14597"><vh>Added support for solarized colors</vh></v>
<v t="ekr.20120229094652.15153"><vh>Detached windows</vh></v>
<v t="ekr.20120229094652.15151"><vh>Leo now raises a dialog on @ignore @&lt;file&gt; nodes</vh></v>
<v t="ekr.20120229094652.15135"><vh>The leoInspect module</vh></v>
</v>
<v t="ekr.20120229094652.15163"><vh>Features: minor</vh>
<v t="ekr.20120229094652.14540"><vh>Supported auto-hide in viewrendered plugin</vh></v>
<v t="ekr.20120229094652.14541"><vh>set g.app.execute_script during script execution</vh></v>
<v t="ekr.20120229094652.14542"><vh>Added select-to-matching-bracket command</vh></v>
<v t="ekr.20120229094652.14576"><vh>The Find tab now scrolls</vh></v>
<v t="ekr.20120229094652.14581"><vh>Made open smarter</vh></v>
<v t="ekr.20120229094652.14592"><vh>Added support for tags in @button nodes</vh></v>
<v t="ekr.20120229094652.14593"><vh>Reorganized @button &amp; @command nodes.</vh></v>
<v t="ekr.20120229094652.14594"><vh>DingDing: big Aha's</vh></v>
<v t="ekr.20120229094652.14595"><vh>help-for-command now uses g.getDocStringFromFunction</vh></v>
<v t="ekr.20120229094652.14596"><vh>@ignore now prevents local @button/@command node definitions</vh></v>
<v t="ekr.20120229094652.14599"><vh>Applied patch for bug 800399: Leo should have smart word jumps/deletes</vh></v>
<v t="ekr.20120229094652.14600"><vh>Support single-line nodes like &lt;node/&gt; xml import code</vh></v>
<v t="ekr.20120229094652.14603"><vh>Disabled messages on external unit tests</vh></v>
<v t="ekr.20120229094652.14604"><vh>Unit tests now always have the sources available</vh></v>
<v t="ekr.20120229094652.14605"><vh>Support marking an entire tree</vh></v>
<v t="ekr.20120229094652.14607"><vh>Call unselect1 hook only once</vh></v>
<v t="ekr.20120229094652.14610"><vh>bridgeController.initLeo now kills events if plugins not loaded</vh></v>
<v t="ekr.20120229094652.14613"><vh>Improved scannerUnitTest</vh></v>
<v t="ekr.20120229094652.14614"><vh>External unit tests now always read config settings</vh></v>
<v t="ekr.20120229094652.14616"><vh>Improved add/delete-comments</vh></v>
<v t="ekr.20120229094652.14619"><vh>Added show-decoration-selected: 1 to</vh></v>
<v t="ekr.20120229094652.14621"><vh>Warn when importing/reading/writing @ignored nodes</vh></v>
</v>
<v t="ekr.20120229094652.15167"><vh>Leo's web site</vh>
<v t="ekr.20120229094652.14589"><vh>Searches from Leo's web pages now work</vh></v>
<v t="ekr.20120229094652.14601"><vh>Leo's home page now shows the latest postings from leo-editor.</vh></v>
</v>
<v t="ekr.20120229094652.15174"><vh>MacOS</vh>
<v t="ekr.20120229094652.15128"><vh>Leo on Mac OSX: new installation instructions</vh></v>
<v t="ekr.20120229094652.14591"><vh>MacOS is no longer fully supported???</vh></v>
</v>
<v t="ekr.20120229094652.15165"><vh>Plugins</vh>
<v t="ekr.20120229094652.14582"><vh>Improved create @auto nodes script</vh></v>
<v t="ekr.20120229094652.14566"><vh>removed scrolledmessage plugin</vh></v>
<v t="ekr.20120229094652.15091"><vh>Improved quicksearch plugin</vh></v>
</v>
<v t="ekr.20120229094652.15166"><vh>Scripts</vh>
<v t="ekr.20120229094652.14567"><vh>Added import-org-mode script</vh>
<v t="ekr.20120229094652.14568"><vh>import-org-mode (command, not used)</vh>
<v t="ekr.20120229094652.14569"><vh>ctor</vh></v>
<v t="ekr.20120229094652.14570"><vh>go</vh></v>
<v t="ekr.20120229094652.14571"><vh>scan</vh></v>
<v t="ekr.20120229094652.14572"><vh>test</vh></v>
</v>
<v t="ekr.20120229094652.14573"><vh>@@button import-org-mode</vh>
<v t="ekr.20120229094652.14574"><vh>scan</vh></v>
</v>
<v t="ekr.20120229094652.14575"><vh>test-import-org-mode</vh></v>
</v>
<v t="ekr.20120229094652.15131"><vh>Code for displaying a function call hierarchy in Leo</vh>
<v t="ekr.20120229094652.15132"><vh>call tree</vh>
<v t="ekr.20120229094652.15133"><vh>displayCalltree</vh></v>
<v t="ekr.20120229094652.15134"><vh>trace session</vh></v>
</v>
</v>
<v t="ekr.20120229094652.14543"><vh>Improved recursive import script</vh></v>
<v t="ekr.20120229094652.15149"><vh>Replacing Qt stylesheets on the fly</vh></v>
<v t="ekr.20120229094652.15089"><vh>Terry added bookmark scripts</vh></v>
<v t="ekr.20120229173025.20633"><vh>Document Terry's magic refactor button</vh>
<v t="ekr.20120229173025.20635"><vh>@button fac</vh></v>
</v>
</v>
<v t="ekr.20120229094652.15168"><vh>Settings</vh>
<v t="ekr.20120229094652.14606"><vh>Added @bool use_body_focus_border</vh></v>
<v t="ekr.20120229094652.14598"><vh>Added border around selected pane</vh></v>
<v t="ekr.20120229094652.14620"><vh>Added stylesheets for Log &amp; Find tabs</vh></v>
<v t="ekr.20120229094652.14615"><vh>Added @bool indent_added_comments setting</vh></v>
<v t="ekr.20120229094652.15143"><vh>Eliminated the -c option</vh></v>
<v t="ekr.20120229094652.15140"><vh>New format for @openwith settings nodes</vh></v>
<v t="ekr.20120229094652.15144"><vh>New search order for leoSettings.leo &amp; myLeoSettings.leo</vh></v>
</v>
<v t="ekr.20120229094652.15172"><vh>Unit testing</vh>
<v t="ekr.20120229094652.15092"><vh>Use Alt-4 for all unit tests</vh></v>
<v t="ekr.20120229094652.15093"><vh>Weightless unit testsing</vh></v>
</v>
<v t="ekr.20120229094652.15173"><vh>Update docs</vh>
<v t="ekr.20120229094652.15087"><vh>Add short intro to scripting</vh>
<v t="ekr.20120229094652.15088"><vh>Easier scripting</vh></v>
</v>
<v t="ekr.20120229094652.15130"><vh>Add to scripting chapter</vh></v>
<v t="ekr.20120229094652.15095"><vh>Review bzr instructions</vh></v>
<v t="ekr.20120229094652.15096"><vh>Document new organization for @command and @button nodes</vh></v>
<v t="ekr.20120229094652.15097"><vh>Document @mark-for-unit-test trees!</vh></v>
<v t="ekr.20120229094652.15098"><vh>Rewrite MacOs instructions using Ludvig's homebrew instructions</vh></v>
<v t="ekr.20120229094652.15099"><vh>FAQ entry: @commands Aha</vh></v>
<v t="ekr.20120229094652.15100"><vh>revise autocompletion docs based on recent posts</vh>
<v t="ekr.20120229094652.15101"><vh>Autocompleter post</vh>
<v t="ekr.20120229094652.15102"><vh>Creating ctags data</vh></v>
<v t="ekr.20120229094652.15103"><vh>Using Leo's autocompleter (outline form)</vh>
<v t="ekr.20120229094652.15104"><vh>Starting autocompletions</vh></v>
<v t="ekr.20120229094652.15105"><vh>Displaying autocompletions</vh></v>
<v t="ekr.20120229094652.15106"><vh>Using the QCompleter</vh></v>
<v t="ekr.20120229094652.15107"><vh>Using the Log pane completer</vh></v>
<v t="ekr.20120229094652.15108"><vh>Showing docstrings</vh></v>
</v>
<v t="ekr.20120229094652.15109"><vh>Using Leo's autocompleter (COPY)</vh>
<v t="ekr.20120229094652.15110"><vh>Starting autocompletions</vh></v>
<v t="ekr.20120229094652.15111"><vh>Displaying autocompletions</vh></v>
<v t="ekr.20120229094652.15112"><vh>Using the QCompleter</vh></v>
<v t="ekr.20120229094652.15113"><vh>Using the Log pane completer</vh></v>
<v t="ekr.20120229094652.15114"><vh>Showing docstrings</vh></v>
</v>
<v t="ekr.20120229094652.15115"><vh>Code notes</vh></v>
<v t="ekr.20120229094652.15116"><vh>Minor settings</vh></v>
<v t="ekr.20120229094652.15117"><vh>Appearance</vh></v>
<v t="ekr.20120229094652.15118"><vh>Codewise notes</vh></v>
<v t="ekr.20120229094652.15119"><vh>Performance</vh></v>
<v t="ekr.20120229094652.15120"><vh>Completions</vh>
<v t="ekr.20120229094652.15121"><vh>Docs</vh>
<v t="ekr.20120229094652.15122"><vh>Additional options</vh></v>
</v>
<v t="ekr.20120229094652.15123"><vh>Existing docs</vh></v>
</v>
</v>
</v>
<v t="ekr.20120229094652.15124"><vh>Add tip: How to restore focus without the mouse</vh></v>
<v t="ekr.20120229094652.15125"><vh>Document loading plugins when running unit tests externally</vh></v>
<v t="ekr.20120229094652.15126"><vh>Move UNL.py plugins docs somewhere else: it's no longer a plugin.</vh></v>
<v t="ekr.20120229094652.15127"><vh>Revise Leo's docs re import commands</vh></v>
<v t="ekr.20120229094652.15137"><vh>How to upgrade properly</vh></v>
<v t="ekr.20120229094652.15152"><vh>All about clone conflicts</vh></v>
<v t="ekr.20120229094652.15148"><vh>BibTeX citations from Leo</vh></v>
<v t="ekr.20120229094652.15141"><vh>Theory of operations: Understanding Leo's load process</vh></v>
<v t="ekr.20120229094652.15145"><vh>Theory of operation: About key handling</vh></v>
<v t="ekr.20120229094652.19496"><vh>Bug 905276: explain how to clone multiple nodes at once</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040524104904.161"></t>
<t tx="EKR.20040524104904.211"></t>
<t tx="EKR.20040524104904.245"></t>
<t tx="EKR.20040524104904.26"></t>
<t tx="EKR.20040524104904.261"></t>
<t tx="EKR.20040524104904.274"></t>
<t tx="EKR.20040524104904.99"></t>
<t tx="TL.20080804095315.1"></t>
<t tx="ekr.20040414161647">@nocolor-node

These are the sources for Leo's users guide.

They contain sphinx markup. See::
    
    http://sphinx.pocoo.org/
    http://docutils.sourceforge.net/docs/user/rst/quickstart.html
    
To generate these docs, see the next node: "Generating the Users Guide"
    
Important files:

- doc\html\conf.py contains settings, including the name of the master toctree
  document, leo_toc.html.txt.

- leo_toc.html.txt contains a list of all file to be included.
</t>
<t tx="ekr.20050407144342">



</t>
<t tx="ekr.20050407144342.1"></t>
<t tx="ekr.20050407144342.2"></t>
<t tx="ekr.20050407144342.3"></t>
<t tx="ekr.20050407144417"></t>
<t tx="ekr.20050812123002"></t>
<t tx="ekr.20050812123002.1"></t>
<t tx="ekr.20050812123002.2">Deletes p.v.rst2_http_attributename from all nodes after writing.

Deletes p.v.unknownAttributes if it then becomes empty.
</t>
<t tx="ekr.20050812123002.3"></t>
<t tx="ekr.20050812123002.4">@nocolor

If False, add_node_marker and http_support_main  do nothing.  Otherwise add_node_marker does the following:

1. add_node_marker writes a string using generate_node_marker.

Generates 'http-node-marker-'+str(number), where number is config.node_counter
(incremented each time add_node_marker is called.

2. Enables the following code in :
@color

    if config.tag == 'open2':
        http_map = self.http_map
    else:
        http_map = {}
        config.anchormap = {}
        # maps v nodes to markers.
        config.node_counter = 0
    # [snip] code to write the tree
    if config.rst2_http_server_support:
        self.http_map = http_map
</t>
<t tx="ekr.20050812123002.5"></t>
<t tx="ekr.20050812123002.6">True: call body_filter to massage text.

Removes @ignore, @nocolor, @wrap directives.
</t>
<t tx="ekr.20050812123002.7">Used differently.  See rst2_pure_document.
</t>
<t tx="ekr.20050812123002.8"></t>
<t tx="ekr.20050831184021.1"></t>
<t tx="ekr.20050831184021.3"></t>
<t tx="ekr.20050831184021.4"></t>
<t tx="ekr.20050831184021.5"></t>
<t tx="ekr.20050831195331.1"></t>
<t tx="ekr.20050831195331.4"></t>
<t tx="ekr.20050831195449">@nocolor

For instruction about installing Leo see:
http://webpages.charter.net/edreamleo/installing.html

For everything a beginner needs to know about Leo see:
http://webpages.charter.net/edreamleo/intro.html

For help, please ask questions at:
http://groups.google.com/group/leo-editor</t>
<t tx="ekr.20050901084134"></t>
<t tx="ekr.20050912125144"></t>
<t tx="ekr.20051202072010"></t>
<t tx="ekr.20060430221745"></t>
<t tx="ekr.20060527105211"></t>
<t tx="ekr.20060612102055"></t>
<t tx="ekr.20060620094033"></t>
<t tx="ekr.20060913164304"></t>
<t tx="ekr.20061025065357"></t>
<t tx="ekr.20070317033759"></t>
<t tx="ekr.20070610174018"></t>
<t tx="ekr.20070628083442"></t>
<t tx="ekr.20070701101808"></t>
<t tx="ekr.20080203101507"></t>
<t tx="ekr.20080412124815.1"></t>
<t tx="ekr.20080730212711.14"></t>
<t tx="ekr.20080923182326.1">This option applies to directories specified in filenames in all kinds of @file trees, and to filenames specified in the @path directive.

True:  Leo attempts to create directories if they do not exist.
False: Leo never attempts to create directories.
</t>
<t tx="ekr.20090717084250.10702"></t>
<t tx="ekr.20091111112709.6671"></t>
<t tx="ekr.20091130111843.6787"></t>
<t tx="ekr.20100731112744.7267"></t>
<t tx="ekr.20100805171546.4412"># This section contains important files used to generate Leo's web site.</t>
<t tx="ekr.20100821182153.4341"></t>
<t tx="ekr.20100907092300.4440"></t>
<t tx="ekr.20100907092300.4441">Path to inkscape template file
</t>
<t tx="ekr.20100907092300.4442">Path to Inkscape executable
</t>
<t tx="ekr.20101007100904.4372"></t>
<t tx="ekr.20101009114830.4723">@nocolor-node

Formerly, this had to be on because the expansion bits
of @screenshot trees were significant.

Happily, this is no longer true.

True (recommended):
    Write "E" attribute bits in &lt;v&gt; elements.
    Leo outlines will record the expansion state of all nodes.

False:
    (Good for files like unitTest.leo)
    Suppress "E" attribute bits in &lt;v&gt; elements.
    Only the ancestors of the presently selected node will
    be expanded when Leo opens an outline.
</t>
<t tx="ekr.20101009114830.4724"></t>
<t tx="ekr.20101009114830.4725"></t>
<t tx="ekr.20101025080245.5794"></t>
<t tx="ekr.20101025080245.5795"></t>
<t tx="ekr.20101025080245.5796"></t>
<t tx="ekr.20101025080245.5798"></t>
<t tx="ekr.20101025080245.5799"></t>
<t tx="ekr.20101025080245.5801">c:/leo.repo/trunk/leo/doc/leo_toc.html</t>
<t tx="ekr.20101026081737.5531">@language html

&lt;!-- EKR: changed these by hand to give the toc some structure --&gt;

&lt;p&gt;Preliminaries&lt;/p&gt;

&lt;ul&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="frontMatter.html"&gt;Front Matter&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="preface.html"&gt;Preface&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="testimonials.html"&gt;What People Are Saying About Leo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basics&lt;/p&gt;

&lt;ul&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="FAQ.html"&gt;FAQ&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="slides.html"&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="installing.html"&gt;Installing Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="intro.html"&gt;The Leo Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="outlines.html"&gt;Using Outlines&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Intermediate Topics&lt;/p&gt;

&lt;ul&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="commands.html"&gt;Using Leo&amp;#8217;s Commands&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="customizing.html"&gt;Customizing Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="coloring.html"&gt;Controlling Syntax Coloring&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="rstplugin3.html"&gt;Creating Documents with Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="scripting.html"&gt;Scripting Leo with Python&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="plugins.html"&gt;Plugins&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="writingPlugins.html"&gt;Writing Plugins&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="unitTesting.html"&gt;Unit testing with Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="debuggers.html"&gt;Debugging with Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="atShadow.html"&gt;Using &amp;#64;shadow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Leo and Other Programs&lt;/p&gt;

&lt;ul&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="emacs.html"&gt;Leo and Emacs&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="IPythonBridge.html"&gt;IPython and Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="leoBridge.html"&gt;Embedding Leo with the leoBridge module&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="vimBindings.html"&gt;Using Vim Bindings with Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="zodb.html"&gt;Using ZODB with Leo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Reference&lt;/p&gt;

&lt;ul&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="directives.html"&gt;Leo&amp;#8217;s Reference&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="design.html"&gt;Designing with Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="history.html"&gt;History of Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="theory.html"&gt;Theory of Operation&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="whitepapers.html"&gt;White Papers&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="appendices.html"&gt;Appendices&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="glossary.html"&gt;Glossary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

Release Notes

&lt;ul&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="what-is-new.html"&gt;What&amp;#8217;s New in Leo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</t>
<t tx="ekr.20101026082911.5536"></t>
<t tx="ekr.20101104024804.4898">@nocolor-node

The children of this node contain two @button scripts. These are disabled, but
you can execute them by selecting them and hitting Ctrl-B (execute-script).

To generate these docs by hand:

    - From this file, run rst3 on desired tree.
    - cd leo\doc\html
    - make html

To create pdf (probably easiest on Linux, with necessary latex packages installed):

    - make latex
    - cd _build/latex
    - make all-pdf
    
Important files:

- doc\html\conf.py contains settings, including the name of the master toctree
  document, leo_toc.html.txt.

- leo_toc.html.txt contains a list of all file to be included.
</t>
<t tx="ekr.20101112045055.5065">http://www.greygreen.org/tmp/plugins.html</t>
<t tx="ekr.20111107180918.5553">@language rest
@tabwidth -4

@ @rst-options
call_docutils=True
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = True
verbose=True
@c

@all
</t>
<t tx="ekr.20111107180918.5554">################
The Leo Tutorial
################

.. .. index:: Leo's tutorial

Leo is a power tool for people who want to organize, study and work with data,
especially complex data like computer programs, books, web sites and data bases.
Superficially, Leo may look like other outlining programs, code folding editors
or class browsers, but it most certainly is not.

.. .. index::
..      pair: Leonine; Tutorial

.. _`Leo in a nutshell`: nutshell.html

People say Leo is a revolutionary tool, and that Leo is fun to use, even
addictive. There is a unique "Leo way" of managing data; the term **Leonine**
describes how people treat data in "the world according to Leo". Leo definitely
takes a bit of work to understand. Leo's users speak of an "Aha" moment, when
they see how these pieces fit together: outline structure is significant
everywhere.  For a more detailed introduction to Leo, see `Leo in a nutshell`_.

Leo is freely available in source or binary form for all major platforms. You
may download Leo from http://sourceforge.net/projects/leo/files/Leo/ Leo is Open
Software and may be freely distributed.

`Leo's home page`_ contains additional documentation and links to other
resources. For another introduction to Leo, open the file quickstart.leo in the
leo/doc folder.

This tutorial introduces the reader to the basic concepts and features of Leo.
It helps to have Leo running for hands-on experience, but all examples here are
self-contained, so the tutorial can be read off-line as well.
See `Leo's Installation Guide`_. for detailed installation instructions. If you
have problems installing Leo, please ask for help on `Leo's forum`_. 

This tutorial does not attempt to be comprehensive and cover every single
feature of Leo, or even every commonly used feature. Instead, it introduces many
of Leo's most noteworthy features, and will give you a good idea of Leo's flavor
and style. After reading it, you will be able to use Leo in basic ways to create
external files, organize data and run simple scripts. You will then be ready to
learn more about Leo's many advanced features.

The `Glossary`_ is also worth reading.

.. contents::
    :depth: 3

</t>
<t tx="ekr.20111107180918.5555">.. Links used in this document...

.. _`Leo's forum`:      http://groups.google.com/group/leo-editor
.. _`Leo's home page`:  http://webpages.charter.net/edreamleo/front.html
.. _`Python`:           http://www.python.org/
.. _`XML`:              http://en.wikipedia.org/wiki/XML

.. _`Leo's Installation Guide`:     installing.html
.. _`Using Leos Commands`:         commands.html
.. _`Scripting Leo with Python`:    scripting.html
.. _`Customizing Leo`:              customizing.html
.. _`Glossary`:                     genindex.html

.. This image must appear in the _images folder on the web site.
.. |leoMainWindow| image:: screen-shots/leo-qt-main-window.JPG
</t>
<t tx="ekr.20111107180918.5556">..  .. index::
..      pair: Outline pane; Tutorial
..      pair: Body pane; Tutorial

Let's start looking at Leo in detail. We'll start with what you see when you
first open Leo, Leo's main window. Leo's main window, shown below, represents an
entire project. As you can see, the main window contains three panes: the
**outline pane** at the top left, the **log pane** at the top right, and the
**body pane** at the bottom. The window also contains an **icon area** at the
very top, a **status area** and a **mini-buffer** at the very bottom.

..  .. index::
..      pair: Main Window; Tutorial

|leoMainWindow|

..  .. index::
..      pair: Outline pane; Tutorial
..      pair: Icon box; Tutorial
..      pair: Expansion box; Tutorial

Outline pane

    The outline pane shows your project as an outline. The outline
    contains all your project's data. An outline consists of **nodes**. The
    **icon box** is a small icon directly to the left of the headline text.
    The border of the icon box is black if the node has been changed.
    Smaller icons within the icon box indicate the status of the node::

        A small blue box:   the node has body text.
        A red vertical bar: the node is marked.
        A circular arrow:   the node is cloned.

    If a node contains children, a smaller icon appears to the left of the icon
    box. This icon contains a '+' or '-' symbol. Clicking this **expansion box**
    expands or contracts the node.

..  .. index::
..      pair: Node; Tutorial
..      pair: Headline; Tutorial
..      pair: Body text; Tutorial
..      pair: Parent; Tutorial
..      pair: Child; Tutorial
..      pair: Ancestor; Tutorial
..      pair: Descendant; Tutorial

Node

    Each outline node has two two parts, a **headline** and **body text**. The outline pane
    shows headlines. Selecting a headline selects the entire node; the node's
    body text appears in the body pane. Leo uses standard terminology to
    describe the relationships of nodes in an outline. We speak of **parent**
    nodes, **child** nodes, **ancestor** nodes and **descendant** nodes.

..  .. index::
..      pair: Body pane; Tutorial

Body pane

    The body pane contains the body text of the node selected in the
    outline pane.

..  .. index::
..      pair: Log pane; Tutorial

Log pane

    The log pane contains informational messages from Leo or your scripts.

..  .. index::
..      pair: Icon area; Tutorial

Icon area

    Depending on what plugins are enabled, the icon area may contain
    buttons and other widgets that extend what Leo can do. The scripting plugin
    makes it easy to add buttons to the icon area.

..  .. index::
..      pair: Status area; Tutorial

Status area

    The status area shows the line and column containing the body text's cursor,
    and the **UNL** (Uniform Node Location), the path from the top of the outline
    to the selected node.  This path will change as you change outline nodes.

..  .. index::
..      pair: Minibuffer; Tutorial

Minibuffer

    You can type command and search strings in the minibuffer. It works much
    like the Emacs mini-buffer. To enter a command, type &lt;Alt-x&gt; followed by the
    command name and then &lt;return&gt;.  To type a search string, type &lt;ctrl-f&gt;
    followed by the search string and then &lt;return&gt;.
    For full details, see `Using Leos Commands`_.
    

.. pdf: must have a trailing line above.
</t>
<t tx="ekr.20111107180918.5557">..  .. index::
..      pair: External file; Tutorial
..      pair: .leo file; Tutorial
..      pair: XML; Tutorial

Leo stores outline data on your file system in **.leo files**. The format of
these files is `XML`_. You don't have to store all your data in .leo files: Leo
allows you to store parts of your outline data **external files**, that is,
other files on your file system.

..  .. index::
..      pair: @file; Tutorial

**@file nodes** create external files. \@file nodes have headlines starting with
\@file followed by a file name. Some examples::

    @file leoNodes.py
    @file ../../notes.text

..  .. index::
..      pair: Load directory; Tutorial

The file name can be an absolute path or a relative path to the file that starts
at Leo's **load directory**, the directory containing the .leo file.

Leo reads and writes external files automatically when you open or save your Leo
outline:

- When you open an outline (.leo file) Leo reads all the external files created
  by the \@file nodes in the outline. If you have changed an external file
  outside of Leo, Leo will update the corresponding \@file tree to reflect those
  changes when Leo next opens the outline.

..  .. index::
..      pair: Dirty node; Tutorial

- When you save your outline, Leo writes all **dirty** \@file nodes. An \@file
  is dirty if the node or any of its descendant nodes has changed.
  **Important**: When Leo writes an external file, Leo writes all the essential
  information in the \@file tree to the external file, *not* to the .leo file.
  The only nodes that gets written to the .leo file are nodes that are not
  contained in any \@file tree.
</t>
<t tx="ekr.20111107180918.5558">
.. .. index::
..     pair: Leo markup; Tutorial

.. pdf change: **outline-based markup must be on same line.

We come now to one of Leo's most important and unusual features. When Leo writes
an external file, it does so in a flexible manner, directed by **outline-based markup**.
xxxThis markup tells Leo exactly how to create the external file from an \@file node.

..  .. index::
..      pair: Outline order; Tutorial

The **obvious** way to write an external file would be to write the @file node
itself followed by all the descendant nodes in **outline order** (the order in
which nodes appear in the outline). But Leo does *not* write external files
exactly this way.

..  .. index::
..      pair: @all; Tutorial
..      pair: @others; Tutorial

Yes, Leo does indeed start by writing the \@file node itself. But Leo writes the
\@file node's descendants only when it sees one of three kinds of Leo
markup: section references, the \@others directive and the @all directive.
We'll discuss these three kinds of markup in the next section.

Section references and the \@others and \@all directives tell Leo to write the
**expansion** of one or more descendant nodes to the external file. Programmers
will recognize this process as akin to macro expansion. The following sections
will explain this process in detail.

</t>
<t tx="ekr.20111107180918.5559">..  .. index::
..      pair: Section reference; Tutorial

A **section reference** is a line of body text of the form::

    &lt;&lt; a section name &gt;&gt;

..  .. index::
..      pair: Section name; Tutorial

Here, "a section name" can be any descriptive text not containing "&gt;&gt;". When Leo
encounters a section reference, Leo searches all the descendants of the node
containing the reference looking for a node whose headline matches the section
reference. That is, Leo looks for a descendant node whose headline starts with::

     &lt;&lt; a section name &gt;&gt;

..  .. index::
..      pair: Named node; Tutorial

We call such nodes **named nodes**. Leo doesn't require an exact match. Leo
ignores whitespace and the case of letters when comparing headlines to section
reference. Also, Leo ignores anything that may follow the section name in a
named node. For example, the following headline will match the section reference
above::

    &lt;&lt; A Section Name &gt;&gt; (to do)

.. pdf change: section names in plain paragraphs don't work.
If Leo does find a match, Leo *replaces* the section reference
("&lt;&lt; a section name &gt;&gt;") by the *expansion* of the body text of the matched node.
That is, Leo
replaces the section reference by the body text of the matched node, but Leo
**expands all markup** in the matched node *before* making the replacement. The
entire expansion of the matched node replaces the original section reference.
Programmers will recognize this process as recursive macro expansion.

We have just discussed what happens if Leo does find a descendant named node
that matches the section reference. If no such match is found the section
reference is said to be **undefined** and Leo does not write any data to the
external file. This is *not* a serious error: Leo will will save the erroneous
\@&amp;lt;file&amp;gt; tree in the .leo file instead of the external file. No information is
lost. By the way, Leo's syntax coloring will indicate undefined section
reference by underlining the section name.

**Important**: the indentation of section references matters. When expanding a
section reference, Leo indents every line of the expansion by the leading
whitespace that occurs before the section reference. Note also that you can't
write something after a section reference and expect it to end up on the same
line after expansion--Leo always writes a newline after the expansion.
</t>
<t tx="ekr.20111107180918.5560">..  .. index::
..      pair: @others; Tutorial

The **@others directive** is the second (and most common) way of including
descendant nodes in an external files. When Leo encounters the \@others
directive it replaces the \@others directive by the *expansion* of all
**unnamed** descendant nodes. As with section references, Leo replaces all
markup in the descendant nodes, and the entire expansion replaces the \@others
directive.

In short, section references write *named* nodes; \@others directives write all
*unnamed* nodes. By the way, no node may contain more than one \@others
directive because there would be no way to "apportion" descendant nodes to more
than one \@others directive. However, nodes may contain as many section
references as you like.

As with section references, the indentation of the \@others directive matters.
This allows Leo to handle Python source code properly. For example, the following
is a common way of representing a Python class::

    class myClass:
        '''a docstring'''
        @others

When Leo writes this node to an external file, Leo will write the first two
lines to the external file, with the indentation in effect for the node. Leo
will then write all descendant nodes to the external files, with *additional*
indentation equal to the leading whitespace appearing before the \@others
directive.
</t>
<t tx="ekr.20111107180918.5561">..  .. index::
..      pair: @all; Tutorial

The \@all directive is the third, simplest (and least common) way of including
descendant nodes. This directive causes Leo to write all descendant nodes in
outline order, regardless of whether they are named or not. Furthermore, the
\@all directive does not expand any markup in descendant nodes. This results in
Leo writing the external file in the "obvious" way. That is, Leo writes all
descendant nodes in outline order.

Use the all directive if your external file contains unrelated nodes. For
example, I use an external file to store programming notes. These notes
typically contain snippets of programming source code, but there is no real
relationships between the snippets--the file is simply a grab bag of
information. The \@all directive is designed for this situation.
</t>
<t tx="ekr.20111107180918.5562">..  .. index::
..      pair: Style; Tutorial

Newcomers to Leo frequently ask when to use the \@others directive and when to
use sections. It is good style to use section references only when the order of
text within a external file matters. For example, Python programmers put
docstrings and imports at the start of files. So the body text of
\@file nodes typically look something like this::

    &lt;&lt; docstring &gt;&gt;
    @language python
    @tabwidth -4
    &lt;&lt; imports &gt;&gt;
    @others

This ensures that the docstring is first in the file, followed by imports,
followed by everything else. Note that the order in which functions are defined
in a file, or methods defined within a class, typically does *not* matter. Thus,
it is good style to define classes like this::

  class myClass:
        &lt;&lt; class attributes &gt;&gt;
        @others

It would be bad style to define a class like this::

  class myClass:
        &lt;&lt; class attributes &gt;&gt;
        &lt;&lt; method 1 &gt;&gt;
        &lt;&lt; method 2 &gt;&gt;
        ...

Not only does this over-specify the order in which methods are defined, but it
requires lots of extra typing. Not only must you add a line for each method, but
headlines must contain section names such as &lt;&lt; method 1 &gt;&gt;, &lt;&lt;method 2&gt;&gt;, etc.
When using \@others it is good style simply to put the name of each method in the
headline.
</t>
<t tx="ekr.20111107180918.5563">A few more words about style:

- It is good style to put each class, function or method in its own node. This
  makes it easy to see the shape of your code.

- It is good style to use organizer nodes to group related functions or methods.
  An organizer node has no content except maybe for comments. Like this::

    + myClass
        + birth and death
            + __init__
            etc.
        + getters
            etc.
        + setters
            etc.
        + misc methods
            etc.

  (In this notation, '+' denotes a headline.) This organization is far superior
  to using hideous comments like::

    ###########
    # Getters #
    ###########

- It is bad style to use \@others in organizer nodes. There is no need to do so.

- It is bad style to use \@others when order does matter. The reason is that it
  is very easy to move nodes in a tree by mistake, say by alphabetizing nodes.
  One wants to make the meaning of a external file immune from such movements.

One last word about style. The world won't end if you happen to use bad style by
mistake: you just might cause a bit more work for yourself than was strictly
necessary. Feel free to invent your own style of using Leo. Still, it would be
wise to "know the rules before you break them."
</t>
<t tx="ekr.20111107180918.5564">..  .. index::
..      pair: Clone; Tutorial

A **clone** is a node that appears in more than one place in a Leo outline.
Clones are marked with a small red arrow in the icon box. All clones of a node
are actually *the same node*, so any change to one clone affects all clones. For
example, inserting, moving or deleting any child of a clone will change all
other clones on the screen.

Please take a few moments to experiment with clones. Create a node whose
headline is A. Clone node A using the Clone Node command in Leo's Outline menu.
Type some text into the body of either clone of A. The same text appears in the
bodies of all other clones of A. Now insert a node, say B, as a child of any of
the A nodes. All the A nodes now have a B child. See what happens if you clone
B. See what happens if you insert, delete or move nodes that are children of A.
Verify that when you delete the penultimate clone, the last clone becomes a
regular node again.

Clones are much more than a cute feature. Clones allow multiple views of data to
exist **within a single outline**. With Leo, there is no such thing as a single,
"correct" view of data. You can have as many views of data as you like.

To create a new view of the data in your outline, just do the following:

..  .. index::
..      pair: View node; Tutorial

1. Create an *ordinary* node, that will represent the view. We call these nodes
   **view nodes** merely to indicate they represent a view.

2. Clone all the nodes from the outline that you want the view to contain. Move
   these clones so they become children of the view node.

3. (Optional) You can add regular nodes as children of the view node too.

..  .. index::
..      pair: Bug node; Tutorial

For example, when I fix a bug in Leo, I create an ordinary node to represent the
bug. This **bug node** is my view of all the data in Leo's source code that
relates to the bug. As I discover code related to the bug, I clone their nodes
and move them under the bug node. I'll also add ordinary nodes as children of
the bug node. These nodes contain the original bug report, descriptions of how I
fixed the bug, test data, or any other notes I might want to keep.

Once I have created the bug node, I concentrate *only* on that node and its
children. I can examine the bug node and its children without having to jump
around the outline. Everything I need is in one place. When I get around to
actually fixing the bug I can do so by changing the clones. Again, I do not have
to jump around the outline. It doesn't matter how big or complex the entire
outline is: I am only dealing with the bug node and its children. This extremely
narrow focus makes it *much* easier to fix bugs.

By the way, I never have to remember to save external files. When I change any
clone, Leo marks all instances of that clone throughout the entire outline as
dirty (changed). When I save the Leo outline, Leo automatically writes all the
external files that contain dirty nodes.

Views have an unlimited number of uses. Use them whenever you want to focus your
attention on some smaller set of nodes. For example, I often create view nodes
when studying other people's code. The view node helps me concentrate on just
the part of the code that interests me at the moment.
</t>
<t tx="ekr.20111107180918.5565">..  .. index::
..      pair: Directive; Tutorial

Leo's **directives** control such things as syntax coloring, line wrapping
within the body pane and the width of tabs. Leo directives may appear in
headlines or body text. Leo directives start with '@', followed by the name of
the directive.

**Note**: Leo handles Python decorators properly, providing they don't conflict
with Leo's directives.  

Here are some of Leo's directives::

    @language python
    @tabwidth -4
    @wrap
    @nowrap
    @color
    @nocolor
    @killcolor

Most directives must start with the '@' in the leftmost column, but whitespace
may appear before the '@others' and '@all' directives. As we have seen, such
whitespace is significant.

Directives apply until overridden in a subtree. All of these directives apply to
the node they are contained in, and also to the entire tree of descendant nodes,
unless **over-ridden** by a similar directive in a descendant node. For example,
the directive::

    @language python

tells Leo to syntax color the node and all descendant nodes as Python code.
However, some descendant node might contain::

    @language rest

which tells Leo to color that node and all of *its* descendants as
reStructureText. This principle applies to almost all of Leo's directives: the
directive is in effect throughout a tree, unless overridden in some subtree.

..  .. index::
..      pair: @color; Tutorial
..      pair: @nocolor; Tutorial
..      pair: @killcolor; Tutorial
..      pair: Ambiguous Node; Tutorial

..  .. glossary::

\@color, \@nocolor and \@killcolor

    These directives control how Leo colors body text. You can mix \@nocolor and
    \@color directives in a single node. This directives affect descendant
    nodes unless a node contains both \@color and \@color.  Such **ambiguous**
    nodes do not affect the coloring of descendant nodes.

..  .. index::
..      pair: @first; Tutorial

\@first

    This directive forces a lines to appear before the first sentinel of a
    external file. Here is a common way to start a Python file::

        @first #! /usr/bin/env python
        @first # -*- coding: utf-8 -*-

..  .. index::
..      pair: @language; Tutorial

\@language

    Sets the language in effect for a tree. This affects how Leo colors body
    text. It also sets the comment delimiters used in external files. Leo
    supports dozens of languages. See `Leo's reference` for a complete list.
    Here are a few::

        @language python
        @language c
        @language rest # restructured text
        @language plain # plain text: no syntax coloring.

..  .. index::
..      pair: @pagewidth; Tutorial

\@pagewidth &lt;n&gt;

    Sets the page width used to format break doc::

        @pagewidth 100

..  .. index::
..      pair: @path; Tutorial

\@path &lt;path&gt;

    This directive is a convenience.  Rather than specifying long paths
    in @file nodes, you can specify a path in an ancestor @path node.
    For example, suppose three nodes have the following headlines::

        @path a
            @path b
                @file c/d.py

    Because of the ancestor @path nodes, the @file node creates the file
    a/b/c/d.py

    Within @path and @&lt;file&gt; paths, {{exp}} gets evaluated with the following
    symbols known: c, g, p, os and sys.  For example::

        @file {{os.path.abspath(os.curdir)}}/abc.py

    refers to the file abc.py in (absolute path of) the current directory.

..  .. index::
..      pair: @tabwidth; Tutorial
..      pair: Negative tab width; Tutorial

\@tabwidth

    Sets the width of tabs. Negative tab widths cause Leo to convert tabs to
    spaces and are highly recommended for Python programming.

..  .. index::
..      pair: @wrap; Tutorial
..      pair: @nowrap; Tutorial

\@wrap and \@nowrap.

    These enable or disable line wrapping the Leo's body pane.
</t>
<t tx="ekr.20111107180918.5566">..  .. index::
..      pair: Scripting Leo; Tutorial

Leo is fully scriptable using the Python language. Leo can execute any body text
as a Python script. To run the entire body text as a script, simply choose the
node and execute the Execute Script command (Ctrl+B). If text is selected, the
Execute Script command will run just the selected text as the script.

The Execute Script command **preprocesses** the script before executing it, in
exactly the same way that Leo writes external files. Leo expands section
references and processes \@others directives before executing the script. This
allows you to use all of Leo's outlining capabilities to organize your scripts.

Your Python scripts can easily access data in an outline. Leo's execute-script
(Ctrl-B) command predefines three variables, c, g and p, that scripts can use to
easily access any part of any Leo outline, and Leo's own source code. For
example, the following script will print all the headlines in an outline::

    for p in c.all_positions():
        print(' '*p.level(),p.h)

The example above is only the beginning of what scripts can do.
See `Scripting Leo with Python`_ for a complete discussion of scripting Leo.

..  .. index::
..      pair: Extending Leo; Tutorial

**Plugins** are Python modules that change how Leo works. Leo's user have
contributed dozens of plugins that have extended Leo's capabilities in many new
directions. The file leoPlugins.leo contains all plugins that are included in
Leo distributions.

..  .. index::
..      pair: @asis; Tutorial

Plugins and other parts of Leo can get options from **@settings** trees.
\@settings trees allow plugins to get options without any further support from
Leo's core code. For a full discussion of \@settings trees,
see `Customizing Leo`_.
</t>
<t tx="ekr.20111107180918.5567">Using Leo quickly becomes second nature:

- You can use Leo like any ordinary outliner, as a filing cabinet, but Leo's
  clones makes this filing cabinet much more flexible and useful than usual.

- You create external files using \@file trees. Within \@file trees, you use
  section references and the \@others directive to tell Leo how to write nodes
  to the external file. Directives such as \@tabwidth and \@language provide other
  information to Leo. Leo's \@file trees allow you to organize your scripts
  and programs with Leo's outline structure.

- You can execute Python scripts from any node in a Leo outline. Leo scripts
  have full, easy, access to all the information in the outline. Using scripts
  and plugins, you can easily add new features to Leo.
</t>
<t tx="ekr.20111107180918.5568">LeoPyRef.leo (in the core subdirectory of the leo folder) contains almost all of
Leo's source code. It provides hundreds of examples of everything discussed
here. This file will repay close study. For full details on all aspects of Leo
see LeoDocs.leo.
</t>
<t tx="ekr.20111107194933.5505"># Warning: the output goes to the test folder, not the doc folder.

assert not g.isPython3
    # reportlab only works with Python 2.x.

h = '@rst intro-pdf.pdf'
p = g.findNodeAnywhere(c,h)
assert p,'not found: %s' % (h)
c.selectPosition(p)
c.rstCommands.rst3()
</t>
<t tx="ekr.20111108052738.5507">run-marked-unit-tests-externally = Alt-4
run-all-unit-tests-externally = Alt-5
</t>
<t tx="ekr.20111108053709.5534"></t>
<t tx="ekr.20111127144911.5545"></t>
<t tx="ekr.20120229094652.14053">@language rest

Leo 4.10 b1              March 7, 2012

Leo 4.10 b1 is now available at:
http://sourceforge.net/projects/leo/files/

Leo is a text editor, data organizer, project manager and much more.
See: http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.10:
--------------------------


- *Many* small improvements and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/projects/leo/files/
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html
</t>
<t tx="ekr.20120229094652.14518"></t>
<t tx="ekr.20120229094652.14520">Leo-specific, not jEdit specific.
blank
docpart
leokeyword
link
name
nameBrackets
tab
url
</t>
<t tx="ekr.20120229094652.14522">Only the high-level interface (baseTextWidget) used the low-level interface.
</t>
<t tx="ekr.20120229094652.14523">Removed the following unused methods::
    
    bind                c.bind also removed.
    configure
    cget
    event_generate      g.app.gui.event_generate does exist.
    getWidth
    indexIsVisible      Also removed for leoEditCommands: scrollHelper and measure.
    mark_set
    onChar              Fortunately, never used anywhere
    pack                Used only in Tk code
    scrollLines
    set_width           Removed do-nothing calls in Leo's core.
    tag_add             Removed do-nothing calls in qt colorizer.
    tag_bind            Removed do-nothing calls in qt colorizer.
    tag_delete          Removed do-nothing calls in qt colorizer.
    tag_names
    tag_ranges
    tag_remove
    update
    update_idletasks
    xyToPythonIndex
    yview
</t>
<t tx="ekr.20120229094652.14524">- The nullGui now uses a fully capable string-based body widget.
- The nullGui now uses the regular undoer.
</t>
<t tx="ekr.20120229094652.14525">leoQTextEditWidget overrides base toPythonIndex toPythonIndexRowCol.

The versions that call g.toPythonIndex are much slower than
leoQTextEditWidget.toPythonIndex.

The following classes have a toPythonIndex method:

leoQTextEditWidget (fast)

HighLevelInterface: calls g.toPythonIndex.
baseTextWidget: calls g.toPythonIndex.
leoFind: calls g.toPytonIndex.
leoQtBaseTextWidget: calls g.toPythonIndex.
</t>
<t tx="ekr.20120229094652.14526">This is an important addition to reliability.

It ensures that body/log.widget and body.bodyCtrl/log.logCtrl are always in synch.
</t>
<t tx="ekr.20120229094652.14527">Added eventFilter in createFrame in SDI/TabbedFrameFactory classes
</t>
<t tx="ekr.20120229094652.14528"></t>
<t tx="ekr.20120229094652.14531">This is something that I've wanted to do for a long time.  

Now, most modules import only leo.core.leoGlobals. However,
Leo's core still imports leo.core.leoNodes in order to create
positions, vnodes, etc. It would be straightforward to
eliminate these by creating g.app factory methods, but there
is no urgent reason to do so.
</t>
<t tx="ekr.20120229094652.14532">All top-level code in leoTest.py now resides in the
TestManager class.

The c.testManager object eliminates the need for imports of
leo.core.leoTest within unitTest.leo, an excellent
simplification.

Furthermore, there is no need to access the testUtils class:
everything is in c.testManager.

The TestManager class substantially clarifies *all* the code
in leoTest.leo. This is surprisingly important because the
testing code is hardly straightforward.
</t>
<t tx="ekr.20120229094652.14533">This is a major restructuring of Leo's code:
    
Initing settings files and local files is now as simple as possible.

g.openWithFileName now simply calls lm.loadLocalFile.

Commands.__init__ now calls c.finshCreate.

g.app.newCommander now simply calls Commands.__init__,
a *huge* collapse in complexity.

===== Details

The g.app.config class is now substantially simpler:
complex methods have moved to the LoadManager.

The new LoadManager class handles all aspects of Leo's
complex startup process, including most importantly the very
complex process by which Leo reads user settings.

As a side effect, c.config.get is now *much* simpler than
before: it search one, and *only* one dictionary to discover
settings.

Reading local files must be done *twice*. The first read
discovers settings, the second read uses those settings to
open the file. The first read always uses a null gui; the
second read uses g.app.gui, whatever that happens to be.

LM.openLocalFile embodies all aspects of the complex
strategy necessary for opening a local file twice. The first
read creates a PreviousSetting object, which is then passed
to LM.openFileByName, which in turn passes the
PreviousSetting object to the ctor for the Commander.
Finally, the PreviousSetting object inits c.config.

Because of the previousSettings object, the call to
LM.openFileByName does *not* need to "synthesize" a link to
c1 using c.hash. This stamps out bug 568452 at its source.

The crucial point is the previous settings get passed along
to the Commander ctor, *before* LM.openFileByName calls
c.fileCommands.openLeoFile to create the outline.

</t>
<t tx="ekr.20120229094652.14534">- Moved findSettingsPosition to LocalConfigManager.

- Moved printSettings to LocalConfigManager.
</t>
<t tx="ekr.20120229094652.14535"></t>
<t tx="ekr.20120229094652.14536"># see: http://www.diveintopython.org/xml_processing/unicode.html

pr_warning_given = False

def pr(*args,**keys): # (codewise!)

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    if hasattr(sys.stdout,'encoding') and sys.stdout.encoding:
        # sys.stdout is a TextIOWrapper with a particular encoding.
        encoding = sys.stdout.encoding
    else:
        encoding = 'utf-8'

    # Important:  Python's print statement *can* handle unicode.
    # However, the following must appear in Python\Lib\sitecustomize.py:
    #    sys.setdefaultencoding('utf-8')
    s = g.translateArgs(args,d) # Translates everything to unicode.
    if newline:
        s = s + '\n'

    if g.isPython3:
        if encoding.lower() in ('utf-8','utf-16'):
            s2 = s # There can be no problem.
        else:
            # 2010/10/21: Carefully convert s to the encoding.
            s3 = g.toEncodedString(s,encoding=encoding,reportErrors=False)
            s2 = g.toUnicode(s3,encoding=encoding,reportErrors=False)
    else:
        s2 = g.toEncodedString(s,encoding,reportErrors=False)

    if 1: # Good for production: queues 'reading settings' until after signon.
        if app.logInited:
            sys.stdout.write(s2)
        else:
            app.printWaiting.append(s2)
    else:
        # Good for debugging: prints messages immediately.
        print(s2)
</t>
<t tx="ekr.20120229094652.14537"># see: http://www.diveintopython.org/xml_processing/unicode.html

pr_warning_given = False

def pr(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''
    
    print_immediately = False # True: good for debugging.

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')

    if sys.platform.lower().startswith('win'):
        encoding = 'ascii' # 2011/11/9.
    elif hasattr(sys.stdout,'encoding') and sys.stdout.encoding:
        # sys.stdout is a TextIOWrapper with a particular encoding.
        encoding = sys.stdout.encoding
    else:
        encoding = 'utf-8'

    s = g.translateArgs(args,d) # Translates everything to unicode.
    
    # Add a newline unless we are going to queue the message.
    if app.logInited and not print_immediately:
        if newline:
            s = s + '\n'

    if g.isPython3:
        if encoding.lower() in ('utf-8','utf-16'):
            s2 = s # There can be no problem.
        else:
            # Carefully convert s to the encoding.
            s3 = g.toEncodedString(s,encoding=encoding,reportErrors=False)
            s2 = g.toUnicode(s3,encoding=encoding,reportErrors=False)
    else:
        s2 = g.toEncodedString(s,encoding,reportErrors=False)
      
    if print_immediately:
        # Good for debugging: prints messages immediately.
        sys.stdout.write(s2)
    else:
        # Good for production: queues 'reading settings' until after signon.
        if app.logInited:
            sys.stdout.write(s2)
        else:
            app.printWaiting.append(s2)
</t>
<t tx="ekr.20120229094652.14538"># It's important to use only one version of the code.
</t>
<t tx="ekr.20120229094652.14540"></t>
<t tx="ekr.20120229094652.14541">This allows the following pattern to appear in Leo source files::

    class myClass:
        @others
        
    if g.app.testing:
        myClass(c).test()
        
This is better than enabling the test with "if 1:" because
c is not defined while importing the module, so the import
will fail if I forget to change "if 1:" to "if 0" when saving
the .leo file.
</t>
<t tx="ekr.20120229094652.14542"></t>
<t tx="ekr.20120229094652.14543">- Generates only @auto, does not do an actual import.

- Creates @path nodes so actual @auto nodes are short.
</t>
<t tx="ekr.20120229094652.14544">Added class CPrettyPrinter &amp; beatifyCCode
</t>
<t tx="ekr.20120229094652.14545">- Wrapped the code in a class.

- Replaced all globals with ivars.

- Replaced listToString with ''.join(aList)
    
- Eliminated stringToList.
    The code never passes None where a sequence is expected.
    
- Get tab_width from @tabwidth directives.

- Get user data from::
    
    @data c-to-python-class-list
    @data c-to-python-type-list
    @data c-to-python-ivars-dict
        keys end in a colon
        all other lines contain comma-delimited values for the current key.
        
- Add extra parens for 'if' that span several lines.
- Fixed extra indentation.
- Changed ! to not except before =.
- Dedented C blocks, such as::
    
    {
        statement;
        statement;
    }
    
- Improved formatting of block comments.
</t>
<t tx="ekr.20120229094652.14566">The viewrendered plugin does more.
</t>
<t tx="ekr.20120229094652.14567"></t>
<t tx="ekr.20120229094652.14568">class ImportOrgMode:
    @others

def importOrgMode (self,event):
    c = self.c
    self.ImportOrgMode(c).go(c.p)
    c.bodyWantsFocus()

if False and g.app.inScript:
    print('='*40)
    ImportOrgMode(c).test()
    print('done')
</t>
<t tx="ekr.20120229094652.14569">def __init__ (self,c):
    
    self.c = c
</t>
<t tx="ekr.20120229094652.14570">def go (self,p):
    
    '''Prompt for a file and pass the contents to scan().'''
</t>
<t tx="ekr.20120229094652.14571">def scan (self,fn,p,s):

    self.c = c
    root = p.insertAsLastChild()
    root.h = fn
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        g.trace(repr(s))
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1
                level += 1
            if level &gt; len(stack):
                g.trace('bad level',repr(s))
                last = None
            elif level == len(stack):
                last = stack[-1]
                last.b = ''.join(body)
            else:
                last = stack[-1]
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            p = parent.insertAsLastChild()
            p.h = s.strip()
            stack.append(p)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        parent = stack[-1]
        parent.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
</t>
<t tx="ekr.20120229094652.14572">def test (self):
    
    s = '''
* A1
    a1.1
    a1.2
** B11
** B12
b12.1
*** C121
c121.1
    c121.2
c121.3
* A2
a2.1
** B21
*** C211
c211.1
*** C212
** B22
    b22.1
b22.1
* A3
* A4
a4.1
* A5
** B51
*** C511
**** D5111
***** E51111
** B52
*** C521
c521.1
'''

    tag = 'test-import-org-mode'
    p = g.findNodeAnywhere(c,tag)
    s = g.adjustTripleString(s,-4)
    if p:
        try:
            self.scan('test-file',p,s)
        except Exception:
            c.redraw(p)
    else:
        print('not found: %s' % tag)
</t>
<t tx="ekr.20120229094652.14573">'''Import each file in the files list after the presently selected node.'''


files = (
    r'c:\Users\edreamleo\test\import-org-mode.txt',
    r'c:\Users\edreamleo\test\import-org-mode.txt',
)

@others

for fn in files:
    try:
        root = c.p.copy()
        f = open(fn)
        s = f.read()
        scan(c,fn,s)
        c.selectPosition(root)
    except IOError:
        print('can not open %s' % fn)
</t>
<t tx="ekr.20120229094652.14574">def scan (c,fn,s):

    last = root = c.p.insertAsLastChild()
    last.h = g.shortFileName(fn)
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1 ; level += 1
            if level &gt; len(stack):
                g.trace('bad level',repr(s))
            elif level == len(stack):
                last.b = ''.join(body)
            else:
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            last = parent.insertAsLastChild()
            last.h = s.strip()
            stack.append(last)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        last.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
</t>
<t tx="ekr.20120229094652.14575"></t>
<t tx="ekr.20120229094652.14576">The change was to DynamicWindow.createLogPane.
</t>
<t tx="ekr.20120229094652.14577">This was Tk code, and so can not possibly be useful now.

Also removed the settings specific to the Tk colorizer.
</t>
<t tx="ekr.20120229094652.14578">This important new method allows scripts to traverse an outline, deleting nodes
during the traversal. The pattern is::

    p = c.rootPosition()
    while p:
    if &lt;delete p?&gt;:
        next = p.positionAfterDeletedTree()
        p.doDelete()
        p = next
    else:
        p.moveToThreadNext()
        
This method also allows scripts to *move* nodes during a traversal, **provided**
that nodes are moved to a "safe" spot so that moving a node does not change the
position of any other nodes.

For example, the move-marked-nodes command first creates a **move node**, called
'Clones of marked nodes'. All moved nodes become children of this node.
**Inserting** these nodes as children of the "move node" does not change the
positions of other nodes. **Deleting** these nodes *may* change the position of
nodes, but the pattern above handles this complication cleanly.
</t>
<t tx="ekr.20120229094652.14579"># And rewrote clone-marked-nodes.
</t>
<t tx="ekr.20120229094652.14580">Surprisingly important: it is a not-so-subtle clue that *any* file may be
opened: non-Leo files are opened in @edit nodes. Soon: external files containing
Leo sentinels will be opened as @file nodes.
</t>
<t tx="ekr.20120229094652.14581">Create @file nodes (not @thin nodes) when opening an external file.

Changed g.openWrapperLeoFile to create @file instead of @edit when possible.

Changed c.open; minor changes to importDerivedFiles.
</t>
<t tx="ekr.20120229094652.14582"></t>
<t tx="ekr.20120229094652.14583">Rewrote the shellCommand, shellCommandOnRegion and executeSubprocess methods.
</t>
<t tx="ekr.20120229094652.14584"></t>
<t tx="ekr.20120229094652.14585">The idea is to allow Leo to be a drop-in replacement for SciTe.

Suppose you do::
    
    leo x.y
    
where y is not "leo".

1. If x.y exists, Leo should:
    
- Open an unnamed .leo file consisting of @edit x.y.

- If you execute the save command, or close the Leo window,
  Leo should save x.y if it has been changed, but *not* prompt
  you to save the "temporary" .leo file.
  
2. If x.y does *not* exist, leo should do exactly the same
   thing, except that @edit x.y will be empty.
   
However, there are two problems with using Leo as a replacement for SciTe:

1. Load time.  SciTe loads instantly, Leo does not.

2. Screen real estate: Leo is not at its best when presenting only a single
   @edit node: everything but the body pane is wasted space.
</t>
<t tx="ekr.20120229094652.14586">https://bugs.launchpad.net/leo-editor/+bug/381527

Opens a new nameless leo file and adds somefile.foo as an @edit node.

This is good but...

Saving is a pain, because you have to give a name / location for the .leo file,
and in the quick edit use case you want to be able to just hit ctrl-S to save
somefile.foo.

=====

Ah, at last I see the problem. Saving the **.leo** file is too "heavy". This is
an interesting design problem. You could say that Leo could "throw away" the
temporary .leo file, provided it contains only the @edit node.

True, "quick" editing of a non-Leo file could be done in the workbook, but such
an approach would litter the workbook, and would make opening the workbook
slower and slower. That is, the workbook would get heavier and heavier.
</t>
<t tx="ekr.20120229094652.14587">Rev 4577 adds an important new feature: "quick edit/save mode"

This fixes bug 381527 quick edit and save use of leo, and makes Leo considerably lighter.

**Important**: As you will see below, quite a few hacks were needed to make this work.  That doesn't bother me at all, because they are all hidden.  The *effect* of those hacks is easily understandable.

**However**, I may have missed something: I almost missed that I had to change the code that prompts for a save when closing an unsaved headline.  So please be on the lookout for any use cases that I missed.

From the checkin log:

QQQQQ

"leo somefile.foo" opens a nameless .leo file containing a single @edit node.

In quick edit/save mode, the user can change somefile.foo without saving the .leo file at all.

Leo *does* properly prompt for saves so that changes to somefile.foo will not be lost.

Quick edit/save mode changes Leo as follows:

1. The save command, and *only* the save command (not save-as or save-to), looks for an unsaved .leo file containing a single @edit node. This is the "quick save" case.

In this case, Leo does *not* prompt for a filename and does *not*, therefore, save the .leo file. However, Leo does save the @edit node if it is dirty.

2. In the quick edit/save case, atFile.writeOneAtEdit node does *not* prompt for so-called dangerous writes, because, in fact, the write is not dangerous :-)

3. In the quick edit/save case, leoFrame.promptForSave prompts for saving the @edit file, *not* the .leo file.

QQQQQ

I forgot to mention one detail.  There is no way to save the .leo file itself in quick edit/save mode.  If you want to do that, simply add any other node at the top level of the outline.  This ends quick edit/save mode.  When you save or close the outline, Leo will prompt you for the name of the .leo file as usual.

Edward
</t>
<t tx="ekr.20120229094652.14588">The following were changed:

c.save,
at.writeOneAtEditNode,
at.openFileForWriting
leoFrame.promptForSave
</t>
<t tx="ekr.20120229094652.14589">Updating Sphinx and using new .js files did the trick.
</t>
<t tx="ekr.20120229094652.14590"></t>
<t tx="ekr.20120229094652.14591">Leo's home page no longer mentions MacOS and LeoDocs.leo and install.txt now
warn people that MacOS is difficult to install.
</t>
<t tx="ekr.20120229094652.14592">The mod_scripting plugin so that the name of the command created by an @button
nodes does not include any [&lt;tag&gt;] that immediately follows @button. Examples::

    @button [ekr] x
    @button [edit] y
    @button [important] z

These buttons create commands named x, y and z, and the name of the buttons are
x, y and z.

Note that the '[' must be the first non-blank after @button to be recognized and
removed.

The code is a straightforward addition to cleanButtonText in mod_scripting.py:
it is unlikely to have any impact whatsoever to existing @button nodes.

The intended use is for searches of the form @button [some tag].
</t>
<t tx="ekr.20120229094652.14593">http://groups.google.com/group/leo-editor/browse_thread/thread/bd6ed96c88fabb4e

The prefix "DingDing" signifies that this post is an answer to the
lament:

    "Wouldn't it be great if we all could remember what we,
    and others, have already done :-)"

Last night I had a forehead-slapping moment: the place to put @button
nodes is in myLeoSettings.leo.

This morning, I realized that using @command rather than @button
completes the Aha.

This organization has all benefits, and no drawbacks:

- I always know here scripts are.

- No need for duplicates.

- I can organize the scripts within myLeoSettings.leo as usual using
organizer nodes.  This organization can change as needed.

- Using @command rather than @button means that I never have to
disable scripts.  No more @@button.

- Using @command saves screen real estate.  In my experience, having
buttons be visible doesn't prevent them from being hidden in full
view.

- If I use common prefixes, like c_ (for command) or edit_ (for edit-
related scripts) or ekr_ (for personal scripts), the *typing
completion* will let me zero in on the script I want to use:

    &lt;alt-x&gt; c_&lt;tab&gt;
    &lt;alt-x&gt; c_import&lt;tab&gt;

etc.  Furthermore, Ctrl-P (repeat-complex-command) will allow me to
rerun the last script run.  This is a quite common case.

Summary
=======

This Aha substitutes an *already-existing* usage (typing completion)
for a whole set of memory-intensive retrieval problems.  I'm not
likely ever to forget typing completion, although I might forget the
specif prefixes used in @command nodes.  If that happens, I'll know
where to look.

This Aha takes full advantage of Leo's organization strengths and
*concentrates* those strengths by putting all the to-be-organized
material in one place.  This allows for easy reorganization:  changing
command-name prefixes, for instance, would be straightforward. 
</t>
<t tx="ekr.20120229094652.14594">http://groups.google.com/group/leo-editor/browse_thread/thread/9ebd0dd748f3011f

1. Today's work promises to *end* my confusion about scripts:

Scripts will typically be found in myLeoSettings.leo, or, for
"official" scripts, in other places, particularly leoSettings.leo.

The print-buttons command (maybe better called print-scripts) will
show the location of @button or @command nodes.

2. This is a huge breakthrough, because it makes hundreds of scripts
easily available.  This in turn makes *all* scripts more valuable.

3. As I was thinking about these happy developments, I realized that a
big new horizon is about to open up.

I shall not describe here my thought processes, but they were related
to what I have been thinking of as @link nodes. The idea behind @link
nodes was that they would be a link to a given node, specified by a
commander and a gnx.

However, scripts moot the need for @link nodes!  The phrase that
popped into my head was::

    Don't *link* to nodes, *search* for nodes!

That is, links, no matter how "good" they are, are breakable and
fragile; searches are more robust and more dynamic.  Bye bye link
nodes!

4.  Do you see what has just happened?  A search, in other words **a
script**, has eliminated the need for a major new core feature, that
is, link nodes.

This is a *huge* change in point of view!

5.  Here are some implications:

A.  Leo must have a check-doc-strings script that will verify that all
commands have non-trivial doc strings.

B. Leo must have a create-command-docs script that will create large
parts of Leo's documentation for individual commands by searching for
commands in all the proper places, including functions specified by
@g.command(name) and Leo's various commands dictionaries.

C. Leo must have a create-plugins-doc script that does the same for
plugins.  A prototype of this script exists somewhere.  Making it an
@command node will make it much more visible.

Conclusions
==========

1. "Smallish" changes (making scripts more visible via typing
completion) has greatly increased the convenience, and thus
application, of scripts.

Part of the Leo Aha is that Leo outlines are *much* easier to script
than flat files.  We are about to see an explosion in applicability of
scripts in Leo.

2. Searches, that is, scripts, are a *much* more powerful mechanism
than breakable links.  My throwaway response to many feature requests
has always been, "well, you can always write a script to do what you
want."

Now we can see the sense in which this is a proper, universal,
response.  In Leo's case, it has recently become clear that docstrings
are the natural *primary* location for data.  This makes the data
available for online help, such as the help-for-command command.

Now we can see that the *proper* way of creating large parts of Leo's
documentation tree (nodes for the rst3 command) will be via one or
more scripts that dynamically search Leo's source files looking for
data!

A great day for Leo.
</t>
<t tx="ekr.20120229094652.14595"></t>
<t tx="ekr.20120229094652.14596">A big improvement.  There is no longer any need for @@buton, etc.: just put under an @ignore node.

test.leo illustrates the new organization.
</t>
<t tx="ekr.20120229094652.14597">http://ethanschoonover.com/solarized


- 

</t>
<t tx="ekr.20120229094652.14598">Made this optional, and configurable.

c.focus_border_color    = c.config.getColor('focus_border_color') or 'red'
c.focus_border_width    = c.config.getInt('focus_border_width') or 1 # pixels
c.use_body_focus_border = c.config.getBool('use_body_focus_border',default=True)
c.use_focus_border      = c.config.getBool('use_focus_border',default=True)
</t>
<t tx="ekr.20120229094652.14599">Some editors, such as Eclipse, vim, this Webkit form I type in, and even Word,
allow to jump over, select and delete words, especially those containing or
surrounded by special characters, in a smarter way than just "going to the
beginning of the word before" (back-word) or "going to the end of the next word"
(forward-word).

E.g. in a line containing "i = ass" (note: multiple spaces) with the cursor at
the end, Ctrl-BackSpace would delete everything up to the "=", leaving "i =",
and if the cursor was right behind the "i", Ctrl-Right would position the cursor
right before the "=", instead of before the "ass", as Leo does now.

They also make deleting easy. Given a python method:

def fun():
    line1
    line2

Eclipse's and Webkit's Ctrl-BackSpace, beginning with the cursor behind "line2",
used multiple times, yield (turn by turn):

def fun():
    line1
    [4 spaces left of here]

def fun():
    line1
[emtpy line]

def fun():
    line1

def fun():
    [4 spaces left of here]

def fun():
[empty line]

def fun():

def fun

def [1 space left of here]

[empty line]

while Leo's backward-delete-word yields:

def fun():
    line1
   [3 spaces left of here ?!]

def fun():
   [3 spaces left of here ?!]

def

[empty line]

So to say, Leo's word-based commands jump, select and delete more than is useful
for possibly many users coming from other editors, leaving them only with
character-based commands.

I have attached two patches that add "-smart" equivalents of the jump, select
and delete commands.

Users wanting to use these commands can set in their myLeoSettings.leo:

  back-word-smart = Ctrl-LtArrow
  back-word-smart-extend-selection = Ctrl-Shift-LtArrow

  forward-word-smart = Ctrl-RtArrow
  forward-word-smart-extend-selection = Ctrl-Shift-RtArrow

  delete-word-smart = Ctrl-Delete
  backward-delete-word-smart = Ctrl-BackSpace

which overrides the default bindings.
</t>
<t tx="ekr.20120229094652.14600">The single-line nodes should end in a newline. Otherwise the created node will
add a newline, and the checkers will complain.

The new class is xmlScanner and htmlScanner in leoImport.py.
</t>
<t tx="ekr.20120229094652.14601">Leo's home page now shows the latest postings on the leo-editor group.
</t>
<t tx="ekr.20120229094652.14602">The new command names and default bindings are::
    
    run-all-unit-tests-externally       = None
    run-all-unit-tests-locally          = None
    run-marked-unit-tests-externally    = None
    run-marked-unit-tests-locally       = None
    run-selected-unit-tests-externally  = None
    run-selected-unit-tests-locally     = Alt-4
</t>
<t tx="ekr.20120229094652.14603">1. Removing the signon message:

    This was nasty to find. They were created by the call to
    c.new (the non-testc!) in runTests.

    The trace in g.es was the key to discovering what was happening.
    
2. Moved the print statements from leoGlobals.py to writeWaitingLog.

    This allows g.app.silentMode to have effect.
    
3. fc.save now takes a 'silent' argument, set only by createFileFromOutline.

</t>
<t tx="ekr.20120229094652.14604">The following code were changed:

g.executeScript,
c.executeScript,
c.writeScriptFile,
TM.doTests
runTest (generalTestCase)
TM.makeTestSuite.
</t>
<t tx="ekr.20120229094652.14605">If a marked node is neither an @test node nor an @suite node,
all nodes in the tree are considered to be marked.
</t>
<t tx="ekr.20120229094652.14606"></t>
<t tx="ekr.20120229094652.14607">http://groups.google.com/group/leo-editor/browse_thread/thread/e2980a2b86af913e

Isee the following
- when a file is opened
  - one message listing the root node
  - 7 repeats of the message for the current node

- when the file is saved in a session with several tabs
  - a message is generated for each current node in each tab

- shifting focus from body to headline doesn't generate the message,
  shifting focus with &lt;ctl-h&gt; does

- switching from one tab to another doesn't generate the message 
</t>
<t tx="ekr.20120229094652.14608">Unit tests can test this ivar.
</t>
<t tx="ekr.20120229094652.14610">The new code monkey-patches g.doHook to a do-nothing::
    
    if not self.loadPlugins:
        def dummyDoHook(tag,*args,**keys):
            pass
        g.doHook = dummyDoHook
</t>
<t tx="ekr.20120229094652.14611">An useful convenience method now that external unit tests can use config settings.
</t>
<t tx="ekr.20120229094652.14612">Under control of @bool collapse_on_lt_arrow option, default *True*.
</t>
<t tx="ekr.20120229094652.14613">The error message is now part of the failed assert.  Very helpful.
</t>
<t tx="ekr.20120229094652.14614">The change was simply to set readSettings = True in
leoDynamicTest.py.main.

Experience show the extra time (0.3 sec) is very important
for some unit tests.
</t>
<t tx="ekr.20120229094652.14615">The default, True, is the legacy operation, which I recommend.

</t>
<t tx="ekr.20120229094652.14616">add-comments preserves trailing whitespace.
delete-comments now works whether or not blanks surround comments delims.
</t>
<t tx="ekr.20120229094652.14617">This is true regardless of command, marked status of the node, or @ignore nodes.  Doh!

Added special-case code to findAllUnitTestNodes.
</t>
<t tx="ekr.20120229094652.14618">print-bindings: Alt/Ctrl+Key+N now printed with plain Alt/Ctrl keys and shown as Alt/Ctrl+N.
print-commands: Alt/Ctrl+Key+N now printed as Alt/Ctrl+N.
</t>
<t tx="ekr.20120229094652.14619">Added show-decoration-selected: 1 to QTreeWidget stylesheet.

This causes the entire headline row to be shown when select, a big improvement, imo.
</t>
<t tx="ekr.20120229094652.14620"></t>
<t tx="ekr.20120229094652.14621">What I did:
    
1. Created c.init_error_dialogs &amp; c.raise_error_dialogs.

These are called from the following methods:
    
c.importAnyFile
c.open
c.readAtAutoNodes
c.readAtFileNodes
at.readAll
c.save
c.saveAs
c.saveTo
fc.writeAtFileNodes
fc.writeAtShadowNodes
fc.writeDirtyAtFileNodes

2. Disabled log messages in several of the above methods during unit testing.

3. Disabled runOpenFileDialog and runSaveFileDialog during unit testing.
</t>
<t tx="ekr.20120229094652.14622">- Improved autocompletion list:
    don't print 'all' in bindings.
    print bindings first
    pad bindings properly, as is done in print-commands/bindings.
    
- Improved print-commands &amp; print-bindings: don't print 'all'

- Simplfied the code in various ways.
</t>
<t tx="ekr.20120229094652.14625">The clone-find-all command includes nodes only once: if a
node's ancestor appears in the list, the node is not include
again in the top-level list.

The new clone-find-all-flattened command includes every found node
in the top-level list of nodes. I find this less confusing.
</t>
<t tx="ekr.20120229094652.14626">def cloneFindAll (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=None,regexp=None,word=None)
        # Init the pattern from the search pattern.
        self.stateZeroHelper(
            event,tag,'Clone Find All: ',self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
        c.treeWantsFocus()
        
</t>
<t tx="ekr.20120229094652.14627">def cloneFindAllCommand (self,event=None):

    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
    
def cloneFindAllFlattenedCommand (self,event=None):

    self.setup_command()
    self.clone_find_all = True
    self.clone_find_all_flattened = True
    self.findAll()
    self.clone_find_all = False
    self.clone_find_all_flattened = False
</t>
<t tx="ekr.20120229094652.14628">def cloneFindAllFlattened (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all-flattened'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=None,regexp=None,word=None)
        # Init the pattern from the search pattern.
        self.stateZeroHelper(
            event,tag,'Clone Find All Flattened: ',self.cloneFindAllFlattened)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAllFlattened=True)
        c.treeWantsFocus()
</t>
<t tx="ekr.20120229094652.14629">def changeAll(self,event=None):
    '''Execute the 'Change All' command with the settings shown in the Find tab.'''
    self.getHandler().changeAll(event)

def cloneFindAll (self,event):
    '''Do search-with-present-options and print all matches in the log pane. It
    also creates a node at the beginning of the outline containing clones of all
    nodes containing the 'find' string. Only one clone is made of each node,
    regardless of how many clones the node has, or of how many matches are found
    in each node.'''
    self.getHandler().cloneFindAll(event)
    
def cloneFindAllFlattened (self,event):
    self.getHandler().cloneFindAllFlattened(event)

def findAll            (self,event):
    '''Do search-with-present-options and print all matches in the log pane.'''
    self.getHandler().findAll(event)

def replaceString      (self,event):
    '''Prompts for a search string. Type &lt;Return&gt; to end the search string. The
    command will then prompt for the replacement string. Typing a second
    &lt;Return&gt; key will place both strings in the Find tab and executes a **find**
    command, that is, the search-with-present-options command.'''
    self.getHandler().replaceString(event)

def reSearchBackward   (self,event):
    '''Do a reverse regex search.'''
    self.getHandler().reSearchBackward(event)

def reSearchForward    (self,event):
    '''Do a forward regex search.'''
    self.getHandler().reSearchForward(event)

def searchBackward     (self,event):
    '''Do a backward plain search.'''
    self.getHandler().searchBackward(event)

def searchForward      (self,event):
    '''Do a forward plain search.'''
    self.getHandler().searchForward(event)

def wordSearchBackward (self,event):
    '''Do a backward word-only search.'''
    self.getHandler().wordSearchBackward(event)

def wordSearchForward  (self,event):
    '''Do a forward word-only search.'''
    self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    '''Prompts for a search string. Typing the &lt;Return&gt; key puts the search
    string in the Find tab and executes a search based on all the settings in
    the Find tab. Recommended as the default search command.'''
    self.getHandler().searchWithPresentOptions(event)
</t>
<t tx="ekr.20120229094652.14630">def generalSearchHelper (self,pattern,cloneFindAll=False,cloneFindAllFlattened=False,findAll=False):

    c = self.c

    self.setupSearchPattern(pattern)

    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.p
    self.finder.v = self.finder.p.v

    if findAll:
        self.finder.findAllCommand()
    elif cloneFindAll:
        self.finder.cloneFindAllCommand()
    elif cloneFindAllFlattened:
        self.finder.cloneFindAllFlattenedCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
</t>
<t tx="ekr.20120229094652.14631">def getPublicCommands (self):

    return {
        'clone-find-all':                       self.cloneFindAll,
        'clone-find-all-flattened':             self.cloneFindAllFlattened,
        
        'change':                               self.findTabChange,
        'change-all':                           self.changeAll,
        'change-then-find':                     self.findTabChangeThenFind,
        
        'find-all':                             self.findAll,
        'find-clone-all':                       self.cloneFindAll, # Synonym.
        'find-clone-all-flattened':             self.cloneFindAllFlattened, # Synonym.
        'find-next':                            self.findTabFindNext,
        'find-prev':                            self.findTabFindPrev,

        'find-tab-hide':                        self.hideFindTab, # new name
        'find-tab-open':                        self.openFindTab, # new name

        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
        'isearch-with-present-options':         self.isearchWithPresentOptions,

        'replace-string':                       self.replaceString,

        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,

        'show-find-options':                    self.showFindOptions,

        'toggle-find-collapses-nodes':          self.toggleFindCollapesNodes,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        # 'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,

        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }
</t>
<t tx="ekr.20120229094652.14632">def findAll(self):

    trace = False and not g.unitTesting
    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All Flattened' if self.clone_find_all_flattened else 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if self.clone_find_all:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    skip = {} # Nodes that should be skipped.
        # Keys are vnodes, values not important.
    count,found = 0,None
    if trace: g.trace(self.clone_find_all_flattened,self.p)
    while 1:
        pos, newpos = self.findNextMatch() # sets self.p.
        if pos is None: break
        if self.clone_find_all and self.p.v in skip:
            continue
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if self.clone_find_all:
            if not skip:
                undoData = u.beforeInsertNode(c.p)
                found = self.createCloneFindAllNode()
            if self.clone_find_all_flattened:
                skip[self.p.v] = True
            else:
                # Don't look at the node or it's descendants.
                for p2 in self.p.self_and_subtree():
                    skip[p2.v] = True
            # Create a clone of self.p under the find node.
            p2 = self.p.clone()
            p2.moveToLastChildOf(found)
        else:
            self.printLine(line,allFlag=True)

    if self.clone_find_all and skip:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        c.selectPosition(found)
        c.setChanged(True)

    self.restore(data)
    c.redraw()
    g.es("found",count,"matches")
</t>
<t tx="ekr.20120229094652.14633">def createCloneFindAllNode(self):
    
    c = self.c
    oldRoot = c.rootPosition()
    found = oldRoot.insertAfter()
    found.moveToRoot(oldRoot)
    c.setHeadString(found,'Found: ' + self.find_text)
    return found
</t>
<t tx="ekr.20120229094652.14757"></t>
<t tx="ekr.20120229094652.14758">https://bugs.launchpad.net/leo-editor/+bug/800157

In a new file containing only a "NewHeadline" and that being selected, execute:

copy-node
insert-child
&lt;&lt;enter&gt;&gt;
undo
paste-retaining-clones

Leo's UI freezes and loops forever with 100% CPU.

Note: If one does not undo, Leo prints "Invalid paste: nodes may not descend
from themselves". I guess the undo circumvents such a check. However, that
should not be the case, as paste-retaining-clones inserts the clones _after_ and
not as children of the selected node "NewHeadline".

I guess that the undo forgets to set the selection back to "NewHeadline", so
that Leo tries to insert the clones after the undone child node - therefore as
child of "NewHeadline".

====================

EKR: only getLeoOutlineFromClipboar calls checkPaste.
</t>
<t tx="ekr.20120229094652.14759">The code that marks descendant @&lt;file&gt; nodes dirty now tests
p2.isAnyAtFileNode().  The old code tested p2.isAtThinFileNode().
</t>
<t tx="ekr.20120229094652.14760"></t>
<t tx="ekr.20120229094652.14761">CAUTION: new double click handling code

http://groups.google.com/group/leo-editor/browse_thread/thread/dbd63b9b38911906

The problem isn't single/double, but double click not stopping the
event processing.  It has the correct form:

if g.doHook('doubleClick1') is None:
   do-normal-double-click-stuff
g.doHook('doubleClick2')

but I think some other route through the code, or additional processing
of the event means that even thought the handler registered on
doubleClick1 returns non-None, the node goes into headline edit mode,
with focus.

This is bad, because the doubleClick1 on an @url node attempts to
select and raise a different commander (tab), so now you're looking at
one commander but focus is in another, so what you type trashes the
headline in the original commander.

The timer shouldn't be needed - a 'doubleClick1' hook which returns
non-None should stop the headline going into edit mode.  If you can
make that be the case, all is well.
</t>
<t tx="ekr.20120229094652.14762"></t>
<t tx="ekr.20120229094652.14763"></t>
<t tx="ekr.20120229094652.14764">- leoCommands.__init__ now sets self.db = {}
- initGlobalDB now returns {} instead of None if there is no cacher.
</t>
<t tx="ekr.20120229094652.14765">Important notes:
    
readOpenFile reads the private shadow file, detecting the encoding.
</t>
<t tx="ekr.20120229094652.14766">The call to w.see(ins+5) in rp_reformat created a big problem.

Replacing this with w.see(ins) is much better.
</t>
<t tx="ekr.20120229094652.14767"></t>
<t tx="ekr.20120229094652.14768"># A misspelling:
    
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 409, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 1967, in fullCommand
    c.macroCommands.startrecordingMacro(event)
AttributeError: macroCommandsClass instance has no attribute 'startrecordingMacro'
</t>
<t tx="ekr.20120229094652.14769">Examples:
    
    @edit C:/leo.repo/ipython-0.12/IPython/frontend/qt/console/pygments_highlighter.py
        # The filename comes from g.app.gui.runOpenFileDialog
    
    @file C:\leo.repo\ipython-0.12\IPython\frontend\qt\console\pygments_highlighter.py
        # Created by import.
        
The problem was the call to g.os_path_normpath in importDerived files:
    it converts slashes to backslashes on windows (!!)
</t>
<t tx="ekr.20120229094652.14770">- Added getLanguageFromAncestorAtFileNode.

- Revised code in at.scanAllDirectives &amp; leoQtColorizer.scanColorDirectives.
</t>
<t tx="ekr.20120229094652.14771"></t>
<t tx="ekr.20120229094652.14772">qtBody can use the leoBody code.
</t>
<t tx="ekr.20120229094652.14774"></t>
<t tx="ekr.20120229094652.14775">Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\plugins\quicksearch.py", line 187, in returnPressed
    self.scon.doSearch(t)
  File "c:\leo.repo\trunk\leo\plugins\quicksearch.py", line 289, in doSearch
    self.addBodyMatches(bm)
  File "c:\leo.repo\trunk\leo\plugins\quicksearch.py", line 257, in addBodyMatches
    self.its[it] = (p, None)
TypeError: unhashable type: 'QListWidgetItem'
</t>
<t tx="ekr.20120229094652.14776">The scrolledmessage plugin no longer exists.

The runScrolledMessageDialog *does* still exist, but it now uses the
viewrendered plugin.
</t>
<t tx="ekr.20120229094652.14777">Changed doButtons and doCommands kind handlers.

This allows us to put example nodes in leoSettings.leo.
</t>
<t tx="ekr.20120229094652.14778"></t>
<t tx="ekr.20120229094652.14779">Could this be done as part of abbreviation expansion?
</t>
<t tx="ekr.20120229094652.14780">Changed at.readEndOthers and at.readEndRef so that they
always set at.inCode = True
</t>
<t tx="ekr.20120229094652.14781">Fixed several encoding problems related to this thread: @shadow - @encoding windows-1250 - problem
http://groups.google.com/group/leo-editor/browse_thread/thread/a4ba80559447218a/9a37a4ed6c44d452

There were several real problems fixed.  The summary: @encoding directives were always required.

In detail:

1. at.initWriteIvars now checks for a Python # -*- coding: line.
   If present, it must be the very first line.
   If present, it will override any @encoding directives.

2. g.getPythonEncodingFromString now can deal with either of the following lines:

    @first # -*- coding: utf-8 -*-
    # -*- coding: utf-8 -*-

That is, g.getPythonEncodingFromString can strip the leading @first.

3. g.readlineForceUnixNewline and x.propagate_changes now catch UnicodeDecodeError.
   This is very important: previously decoding errors crashed Leo!.

All unit tests pass with both Python 2.x and 3.x.

</t>
<t tx="ekr.20120229094652.14782">Added configure_hard_tab_width method.
</t>
<t tx="ekr.20120229094652.14783">https://bugs.launchpad.net/leo-editor/+bug/800311

Having set undo to word granularity, I often change something, move to a
different line and continue editing there. When I want to undo my last change,
Leo also undoes the change in the other place, as word granularity currently
only recognises a new undo step when a new word is started, no matter if we
moved to a completely different position first.

The attached patch fixes the issue by remembering the previous cursor position.

Something else about the undo code:

- oldSel and newSel are never set to None in the constructor -&gt; it's quite hard
  to know they are there without reading the whole code

- It would be cool if there could be some more comments in that section; e.g. to
  tell that oldSel and newSel from which old_row, old_col, new_row and new_col
  actually mean: old = "the position right before doing the change" and new =
  "the position right after doing the change" and that old != "the position
  after the change before" (which I added as prevSel) - it took me ages to
  discover this

- There are duplicate "The new and old characters are not contiguous." checks.
  Are they different/necessary?

- The "We have just inserted a line." section is not only entered on a new line
  (see other attached patch)
</t>
<t tx="ekr.20120229094652.14784">https://bugs.launchpad.net/leo-editor/+bug/800312
</t>
<t tx="ekr.20120229094652.14785">https://bugs.launchpad.net/leo-editor/+bug/880975

Bug: The Meta+Ctrl section [of print-bindings] is always empty and this makes it
misleading.

Fix: the prefix list in k.printBindings must be sure that if two prefixes have a
common leading part the longer prefix appears first in the lists.
</t>
<t tx="ekr.20120229094652.14786">exception executing command
Traceback (most recent call last):
  File "/home/bob/bzrWork/pluginPath/leo/core/leoCommands.py", line 408, in doCommand
    val = command(event)
  File "/home/bob/bzrWork/pluginPath/leo/plugins/qtGui.py", line 4965, in cascade
    w.setGeometry(x,y,r.width(),r.height())
TypeError: setGeometry() takes exactly 2 arguments (5 given)
</t>
<t tx="ekr.20120229094652.14787"># A temporary fix while waiting for Terry's css work.
</t>
<t tx="ekr.20120229094652.14788">Here's how it works:  code that wants to set a particular part of a
widget's style sheet calls::

   g.app.gui.update_style_sheet(w,key,value)

where w is the widget whose stylesheet is to be changed, key is unique
to the method (or group of methods), and value is the new version of
the stylesheet **for the particular key** to be added.  Examples::

   # In setEditorColors.
   sheet = 'background-color: %s; color: %s' % (bg,fg)
   g.app.gui.update_style_sheet(obj,'colors',sheet)

   # In add_border.
   sheet = "border: %spx solid %s" % (
       c.focus_border_width,c.focus_border_color)
   self.update_style_sheet(w,'border',sheet)

   # In remove_border.
   sheet = "border: %spx solid white" % (c.focus_border_width)
   self.update_style_sheet(w,'border',sheet)

So add_border and remove_border work together because they use the
same 'border' key.

g.app.gui.update_style_sheet is straightforward: it injects a Python
dict called leo_stylesheet_dict into the widget, and computes the
total stylesheet as follows::

   # Step one: update the dict.
   d = hasattr(w,'leo_styles_dict') and w.leo_styles_dict or {}
   d[key] = value
   w.leo_styles_dict = d

   # Step two: update the stylesheet.
   aList = [d.get(key) for key in list(d.keys())]
   s = ';'.join(aList)
   w.setStyleSheet(s)
</t>
<t tx="ekr.20120229094652.14789">An attempt at fixing the scrolling bug
http://groups.google.com/group/leo-editor/browse_thread/thread/de76f22b16ebc8f/7f6aa691002f1fca

Private email from Viktor
test-leo-rev-4506.leo

It looks like I can reproduce the scrolling problem with your file as follows:

- Select the last node: AM-Session
- Manually scroll down to the last line.
- Click at the end of text: the body pane scrolls.  Bug!


Downloaded leo-editor-snapshot-201110240253.zip and tried it out. Noticed that
when I added a dozen or so blank lines at the end of a body pane and moved the
mouse cursor to the last line and left-clicked the body pane jumped backwards
about 10 lines or so as though I had scrolled up. When I dragged the scroll
button to the end of the pane, the insertion point was still at the end of the
pane. This does not happen for all panes.
</t>
<t tx="ekr.20120229094652.14792">The last time it happened:
    
- Search for something.
- Manually scroll the pane.
- Click scrolls the pane again.
</t>
<t tx="ekr.20120229094652.14817">
g.importFromPath ('html','C:/leo.repo/trunk/leo/modes/html.py')
returned the standard Python html module!

</t>
<t tx="ekr.20120229094652.14818"># The fix was to use lowercase versions of docPart,leoKeyword,nameBrackets.
</t>
<t tx="ekr.20120229094652.14819"></t>
<t tx="ekr.20120229094652.14820">Worked around docutils problem in writeToDocutils.
</t>
<t tx="ekr.20120229094652.14821">- The tests should not register the plugin.

- There should be a test that top-level code does not register the plugin.

Top-level calls to registerHandler:
    
    Fixed:
        examples/__overrideClasses.py
        examples/override_commands.py
        examples/redefine_put.py  (Tk)
        examples/chinese_menu.py
        examples/french_fm.py
    
        at_view.py
        test/failed_import.py
        scripts_menu.py
</t>
<t tx="ekr.20120229094652.14822">not written: c:\recent\data3.html
exception removing: 
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 5280, in remove
    os.remove(fileName)
WindowsError: [Error 3] The system cannot find the path specified: ''
</t>
<t tx="ekr.20120229094652.14823">There were two bugs:
    
- baseScannerClass.skipWsToken must not skip newlines!
- tokenize must add any remaining whitespace at the end of the loop.
</t>
<t tx="ekr.20120229094652.14824"># The code didn't work for c == None.
</t>
<t tx="ekr.20120229094652.14825"></t>
<t tx="ekr.20120229094652.14826">http://groups.google.com/group/leo-editor/browse_thread/thread/3c319daba37cd0ef

- Created a separate html importer, a very simple subclass of the xml scanner
  whose only difference is that it uses @data import_html_tags instead of @data
  import_xml_tags.

- The case of tags in @data import_html_tags and @data import_xml_tags no longer matters.

- checkTrialWrite now writes a file *with* sentinels, to handle @others correctly.
  It then removes the sentinels.
  
  This means that the import tests must use the correct @language directives.
  
- The import check now uses a token-based comparison.  
</t>
<t tx="ekr.20120229094652.14827">The fix was in g.pr:
    
Restored the call to sys.stdout.write(s2) (instead of print)

sys.stdout.write(s2) writes no additional newline at the end of s2.

Aha!  At last I know how to unit test g.pr, g.trace, etc.: redirect stdout!  Doh!
</t>
<t tx="ekr.20120229094652.14828"> File "/usr/fetching/leo-editor/leo/core/leoImport.py", line 2074, in
scanAndCompare
   n1,n2,ok = self.compareTokens(tokens1,tokens2)
 File "/usr/fetching/leo-editor/leo/core/leoImport.py", line 2094, in
compareTokens
   else:      kind1,val1 = 'eof','',n1
ValueError: too many values to unpack
</t>
<t tx="ekr.20120229094652.14829">- Created stand-alone unit tests from @test import dataN.html.
- All leoImport unit tests may now be run externally.
    The Python unit tests were failing because of intermixed tabs and blanks.
    This was fixed by putting @tabwidth -4 in all @test nodes for Python.
- Made sure lines are printed when unit tests fail unexpectedly.
- Added .js &amp; javascript entries to global data structures for javascript unit tests.
- Completed xmlScanner.filterTokens.
- Don't create declaration nodes for html.
- Make sure html tags are as expected.
- Ignore case of html/xml tags.

Rev 4774.1.1:
=============

Fixed all known html-import problems in a clean way. Unit tests exists, but they
use external files. They will be converted soon.

Important changes:

1. Added hasNestedClasses ivar in the baseScannerClass, True only for xml/html scanners.

When True, scanHelper and skipDecls allocate a substring to be used for all further scanning.
This is the *only* way to limit Leo's scanners properly.

This was, in essence, the fix for duplicate code generation arising from unbalanced tags:
skipToEndOfTag and skipToMatchingTag can't match outside the present tag because
the 's' argument passed to those methods has already been truncated.

This is a simple, elegant solution, and in essence the *only* proper solution.
For example, it would not work to past an 'end' argument to skipToEndOfTag and skipToMatchingTag
because the scanners inside those methods do not understand an 'end' argument.

Thus, the simplest, most efficient solution is for scanHelper and skipDecls to truncate the
string to be scanned. That way, the truncation happens at most once per "class".

2. Added hasDecls in the baseScannerClass, False only for xml/html scanners.

Various methods call skipDecls only if this ivar is True.

Rev 4773:
=========

Fixed recent botch: both single and double quotes are allowed in html. 

Rev 4772:
=========

Solved "between element" problem by extending classes up to the next class.
data.html imports "correctly", but not perfectly due to tag mismatches in
skipToMatchingTag.
</t>
<t tx="ekr.20120229094652.14831">http://groups.google.com/group/leo-editor/browse_thread/thread/421ebf4c3f2d5f59

Adding/deleting body editor 3 times hard-crashed Python

The changes were straightforward:
    
- set w.leo_label to None when calling unpackWidget.

- Test for w.leo_label before using it.

Added a minitest.  To test by hand, add the following @button nodes:
    
    @button add-ed
    w = c.frame.body.addEditor()
    
    @button del-ed
    w = c.frame.body.deleteEditor()
    
Click away in any order...

</t>
<t tx="ekr.20120229094652.14832">The new add-comments command adds the comment character at the leftmost column.

The new delete-comments command will remove the comment characters inserted by
either the old or new version of the add-comments command.
</t>
<t tx="ekr.20120229094652.14833">Example: ctrl-shift-home.

The fix was to set self.widget = contents in leoQtLog.selectTab.
</t>
<t tx="ekr.20120229094652.14834">- Added disabled code to inject event filter in TabbedFrameFactory.createFrame.

- Added cycle-tab-focus command.

- cycle-all-focus command uses cycleTabFocus as a helper: this greatly simplifies the code.
    
- Added binding for "Find" tab in leoQtLog.createTab.

- DynamicWindow.createFindTab injects leo_find_widget ivar for leoQtLog.createTab.

- Added isLogWidget to leoQtLog and nullLog classes.  They are helpers for cycleAllFocus.

- Revised leoQtLog.selectHelper: selecting a new tab does *not* change logCtrl (log.widget).

- Added bindings to Find tab
</t>
<t tx="ekr.20120229094652.14835"></t>
<t tx="ekr.20120229094652.14836">The safe default pane is the body pane.  It's also the simplest code.
</t>
<t tx="ekr.20120229094652.14837">The code must be careful that the log widget supports the HighLevelInterface.
</t>
<t tx="ekr.20120229094652.14838"></t>
<t tx="ekr.20120229094652.14839">The bug was in k.handleDefaultChar.  No substantial change made to eventFilter.
</t>
<t tx="ekr.20120229094652.14840">What I did:
    
1. Fixed major bug in settingsTreeParser.visitNode.
   It now does p.copy() to protect the callers traverals.
   This could have significant impacts on people's settings.
   
2. Added g.app.unitTestDict for unit testing.

3. Leo now extends the list of @buttons and @commands, rather than replacing them.
   This is reasonable only because leoSettings.leo should never define *active*
   buttons or commands.
</t>
<t tx="ekr.20120229094652.14841"></t>
<t tx="ekr.20120229094652.14842">https://bugs.launchpad.net/leo-editor/+bug/804960

When we clone a node inside an @shadow (containing @others) node and then
refresh the @shadow node from file, the clone is unlinked and marked as changed.
If we now save, close the .leo file and open it again, the nodes are linked
again! (showing "cloned" symbol) User's thought: "How the heck can the file
change _between save and re-open_ when I changed nothing?"

I think what should be done about this is the check that Leo does when it opens
the file again, and that check should be done immediately after the "refresh
node from file" operation. Also, at this point, the "Recovered nodes" node
should appear (if file and node have both changed), not only after the next .leo
file close/reopen (as that happens quite infrequently, I guess, e.g. once a day
for me). Otherwise, the user can easily lose data.
</t>
<t tx="ekr.20120229094652.14848">&gt;  File "/path/to/leo/core/leoImport.py", line 2070, in reportMismatch
&gt;    line = repr(lines2[i])
&gt; IndexError: list index out of range
</t>
<t tx="ekr.20120229094652.14849"></t>
<t tx="ekr.20120229094652.14850">The fix was to at.putBody.
</t>
<t tx="ekr.20120229094652.14855">has been modified outside of Leo. Overwrite this file?
http://groups.google.com/group/leo-editor/browse_thread/thread/daf581ace0de871e

Steps to reproduce:

- Create a node "@edit ~/aaa.txt" assuming aaa.txt does not exist
- Ctrl-S save outline, log reports creating ~/aaa.txt
- Edit text in body
- Ctrl-S save outline, pop-up pops-up erroneously.

The problem was that replaceTargetFileIfDifferent should set root.v.at_read.
Now it does.

Note: both replaceFileWithString methods are part of the @shadow logic,
so there is no need to set any at_read bit in those methods.
</t>
<t tx="ekr.20120229094652.14856">I loaded an outline with @auto nodes pointing to an out of date path. So body
texts were empty. I updated the paths in the node headlines and saved the file,
expecting to be prompted for overwriting the existing files (now the paths were
correct again), but they were over-written with the blank content without
warning. Damn.

Steps to reproduce in a simpler way below, but don't write the
below of as contrived, because the above is the real problem.

Create @auto /home/tbrown/text.txt

enter text, save file

Edit headline to @auto /home/tbrown/Desktop/text.txt

enter text, save file

Edit headline back to /home/tbrown/text.txt

-----

I now see this happens also if the path change is in a @path node ancestor of the @auto node.
</t>
<t tx="ekr.20120229094652.14891">DynamicWindow.setGeometry now does *not* change the window size when using the qttabs gui.

Added a comment to this effect in leoSettings.leo.
</t>
<t tx="ekr.20120229094652.14892">What I did:
    
- Fixed the Shift-Tab buglet by adding lower-case entries in app.tkNamesList
    This matches what is done in k.settingsNameDict.
- Created &lt;&lt; define global key dicts &gt;&gt; in leoApp.py.
- Changed si.val to si.stroke.
- Replaced g.bunch by GeneralSetting &amp; ShortcutInfo.
- Replaced bunchList by aList.
- Removed dynamic_menus "compile-time" constant.
- onAboutToShow now recomputes the contents of menus whenever menus are invoked.
- leo_update_shortcut now shows all shortcuts for a command.
- Wrote and tested merge_settings_dict.
</t>
<t tx="ekr.20120229094652.14893">Bug 879331: Redefining a key binding breaks menu items with same binding

https://bugs.launchpad.net/leo-editor/+bug/879331

&gt; Now I understand.  If I override the shortcut associated with the menu
&gt; item, in this case Alt-A, the menu breaks.

This is a serious bug!  The menu item now executes the command bound
to Alt-A!  Very bad.

=========

http://groups.google.com/group/leo-editor/browse_thread/thread/762e832909c3c530/d99d48eed45d1061

http://mail.google.com/mail/#inbox/1331909dd653f3c9

Redefining a binding, say for Alt-a, in x.leo will cause the sort-siblings menu
(bound to alt-a) to execute the command specified by the command bound to Alt-a!

https://bugs.launchpad.net/leo-editor/+bug/815564

This anomaly only occurs when all of the following conditions are true:

1) There is a global command name X that is the "same" as the root name of the
file containing a plugin Y. Here, "same" means equal after the command name is
converted to lower case and all underlines in the root name are replaced by
dashes.

2) A shortcut (a.k.a. keystroke) is bound to command name X.

When these conditions are true, then the Plugins dropdown menu shows the key
binding next to the plugin name and left-clicking the plugin name executes the
global command--and, there is no way to display the plugin's help.

Plugin Help Rendering: Plugin help is rendered by the viewrendered plugin, not
by the old scrolledmessage.py plugin.

Leo-editor revision: 4433
OS: Ubuntu 11.04 (natty)

Startup log pane:
Leo Log Window
Leo 4.9 final, build 4411, June 21, 2011
Python 2.7.1, qt version 4.7.2
linux2
</t>
<t tx="ekr.20120229094652.14894">https://bugs.launchpad.net/leo-editor/+bug/815564

===== Probably the same as bug 879331 =====

This anomaly only occurs when all of the following conditions are true:

1) There is a global command name X that is the "same" as the root name of the
file containing a plugin Y. Here, "same" means equal after the command name is
converted to lower case and all underlines in the root name are replaced by
dashes.

2) A shortcut (a.k.a. keystroke) is bound to command name X.

When these conditions are true, then the Plugins dropdown menu shows the key
binding next to the plugin name and left-clicking the plugin name executes the
global command--and, there is no way to display the plugin's help.

Plugin Help Rendering: Plugin help is rendered by the viewrendered plugin, not
by the old scrolledmessage.py plugin.

Leo-editor revision: 4433
OS: Ubuntu 11.04 (natty)

Startup log pane:
Leo Log Window
Leo 4.9 final, build 4411, June 21, 2011
Python 2.7.1, qt version 4.7.2
linux2
</t>
<t tx="ekr.20120229094652.14925">k.computeInversBinding() called by print-commands and for auto-completion.

k.bindKey sets k.bindingsDict.

k.bindKeyToDict sets k.masterBindingDict.
</t>
<t tx="ekr.20120229094652.14934">Created k.kill_one_shortcut, called from k.remove_conflicting_definitions.
</t>
<t tx="ekr.20120229094652.14941">The new TM.findMarkForUnitTestNodes allows both
TM.FindAllUnitTestsNodes and createOutline to be much simpler.
</t>
<t tx="ekr.20120229094652.14942"></t>
<t tx="ekr.20120229094652.14973">1. Enabled see, seeInsertPoint, get/setYScrollPosition.

2. (The fix): save/restore YScroll position in body.setSelectionAreas.

3. Added g.trace_see: g.trace_scroll already existed.

Failure case 1:
    - Search for something.
    - Manually scroll the pane.
    - Click scrolls the pane again.
    
Failure case 2:
    - reformat-paragraph.
</t>
<t tx="ekr.20120229094652.14975">Methods relating to this problem:

g.trace_scroll
w.see
w.seeInsertPoint
w.get/setYScrollPosition
p.restoreCursorAndScroll
v.restoreCursorAndScroll

leoKeyHandler:
    k.keykBoardQuit
    k.showStateAndMode
    k.setLabel
        ***** calls w.widget.ensureCursorVisible

leoQtBody:
    onFocusColorHelper
        ***** calls w.widget.ensureCursorVisible
        
leoQtBaseTextWidget:
    mouseReleaseEvent
        Added code that didn't work: now commented out.
        
leoEditCommands:
    updateAutoIndent
        ***** calls w.seeInsertPoint
</t>
<t tx="ekr.20120229094652.14976">http://groups.google.com/group/leo-editor/browse_thread/thread/de76f22b16ebc8f

As explained in detail in the thread, "dangerous" code is no longer executed immediately,
but instead executed at idle time using g.app.gui.runAtIdle.
</t>
<t tx="ekr.20120229094652.15012">Fixing this bug is important: it allows you to set a default
page width in myLeoSettings.leo for use, for example, in the
reformat-paragraph command.

Without a proper default c.page_width setting, you would have
to use @page_width instead, which is much less convenient.

The fix was the following lines in c.initConfigSettings:
    
    c.page_width = getInt('page_width') or 132
        # 2012/02/27: this appears to be a fix of an *ancient* bug.
</t>
<t tx="ekr.20120229094652.15013">The fix was easy: moveWithinLineHelper does *not* call
leoMoveCursorHelper for the case spot == 'end-line'
</t>
<t tx="ekr.20120229094652.15087">http://mail.google.com/mail/#inbox/1330f306b947656c

&gt; Maybe I'm missing something here, probably because I've always
&gt; dismissed scripting because I don't have the foggiest notion of how to
&gt; write one.

As you have just discovered, Leo does have scripting docs.

However, let me say a few words about scripting in *this* context.

What makes Leo scripting so important is that the predefined c, g and
p variables give *full* and *easy* access to all the data in your
outlines, as well as hundreds, if not thousands, of useful Python
functions in Leo's core.

You could say that these variables, especially c, define a *very*
easy-to-use DOM (Document Object Model) through which you can get o
set any data in *your** outlines.

The hello world example is::

   for p in c.all_positions():
       indent = '.' * p.level()
       print('%s%s' % (indent,p.h))

Here, c.all_positions() delivers a list of positions, and p.level()
and p.h deliver the indentation level and head string of position p.

Another crucial part of Leo scripting is that you can put Leo script
*anywhere* in a Leo outline.  You can do this in three ways:

1. You can just put the script above in the body of any node and run
it with Ctrl-B (execute-script).

2. You can make a script button by putting the script in an @button node.

3. You can make a new Leo command by putting the script in an @command node.

</t>
<t tx="ekr.20120229094652.15088"># aList = [z for z in dir(c) if 'hild' in z]
# aList.sort()
# for z in aList:
    # print(z)

c.insertHeadline(event=None, op_name='Insert Node', as_child=False)

x = g.BasicLeoScript()

x.insert()
x.delete()
x.node()
n.h, n.d

</t>
<t tx="ekr.20120229094652.15089">http://groups.google.com/group/leo-editor/browse_thread/thread/b17d140b7ceb8fc9

I've added web page bookmarking from your browser to Leo.

Docs., appended to the mod_http plugin, where this functionality lives,
are pasted below.

Screen shot of the form which pops up when you click the Bookmark
button in your browser attached.  The body text of the corresponding
bookmark node created in Leo is:

    Leo's Home Page
        http://webpages.charter.net/edreamleo/front.html

        Tags: leo, python

        Leo's Home Page

        Collected: Sun 02 Oct 2011 02:52:51 PM CDT

        Keep this under your pillow.

If you had some text selected on the page in your browser that would
also appear in the above, and repeatedly bookmarking the same page with
different selections incrementally adds such quotes to the bookmark
node.

Here are the docs.:

Can also be used for bookmarking directly from the browser to Leo.  To
do this, add a bookmark to the browser with the following URL / Location:

    javascript:w=window;if(w.content){w=w.content}; d=w.document; w.open('http://localhost:8130/_/add/bkmk/?&amp;name=' + escape(d.title) + '&amp;selection=' + escape(window.getSelection()) + '&amp;url=' + escape(w.location.href),%22_blank%22,%22toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no, width=800, height=300, status=no%22);void(0)

and edit the port (8130 in the example above) to match the port you're using
for mod_http.

Bookmarks are created as the first node in the outline which has been opened longest.
You can set the ``@string`` ``http_bookmark_unl`` to specify an alternative location,
e.g.::

    @string http_bookmark_unl = /home/tbrown/.bookmarks.leo#@bookmarks--&gt;Incoming

to place them in the `Incoming` node in the `@bookmarks` node in the `.bookmarks.leo` outline.

The headline is preceeded with '@url ' *unless* the ``bookmarks`` plugin is loaded.
If the ``bookmarks`` plugin is loaded the bookmark will have to be moved to a ``@bookmarks`` tree to be useful.

The browser may or may not be able to close the bookmark form window for you, depending on settings - set ``dom.allow_scripts_to_close_windows`` to true
in ``about:config`` in Firefox. 
</t>
<t tx="ekr.20120229094652.15090">http://groups.google.com/group/leo-editor/browse_thread/thread/4686ebad81bb1ea1
</t>
<t tx="ekr.20120229094652.15091">- Selecting any node using arrow keys shows the node in the outline immediately.

- Clicking a node or hitting &lt;return&gt; puts focus in body pane.

- Still to do: support Ctrl-G in Nav Tab.

groups.google.com/group/leo-editor/browse_thread/thread/e0ad60ae319359df/e932052a1ef6e9f5
NEW: find-quick-timeline

There are some Alt-X commands which put interesting lists of things
into the Nav pane.  I've just added a new one, find-quick-timeline.

Here's the complete list:

- find-quick-test-failures:
  Lists nodes in c.db.get('unittest/cur/fail')

- find-quick-timeline:
  Lists all nodes in reversed gnx order, basically newest to oldest, creation wise,
  not modification wise.

- history:
  Lists nodes from c.nodeHistory.
   
- marked-list:
  List all marked nodes.
  
=====

Kent: Really nice.

If all commands which put things in the nav pane were named nav_xxx:
that, and tab completion would obviate memorization ...
</t>
<t tx="ekr.20120229094652.15092">There is a collapse in complexity here that I just discovered: use
Alt-4 for all tests.

    unitTest.leo: bind Alt-4 to run-selected-unit-tests-externally
    leoPy.leo:    bind Alt-4 to run-marked-unit-tests-locally 

run-marked-unit-tests-externally is the simplest thing that could possibly work.
Bind Alt-4 to this command, marked just the desired tests and then run them with
one keystroke. Brilliantly simple.

Experience shows that being able to run the desired unit tests
*without* selecting any particular node makes an amazingly large
difference.  Being able to run all and only marked unit tests is a big
step forward.
</t>
<t tx="ekr.20120229094652.15093">As of rev 4725, unit testing in leoPy.leo feels *completely*
weightless.  The last change: running any unit test externally saves
the .leo file automatically first.

Thus, Alt-4 runs all desired unit tests immediately.  To select/
deselect unit tests, just mark/unmark @test nodes.

The difference in workflow is *huge*.  There is no need to select
@test nodes in any way, except for marking them.

So I create an @test node, make changes to that node, or to the code
being tested, and hit Alt-4.  Done.

When I am satisfied with the @test node, I can leave it where it is
(unmarked) or move it to unitTest.leo.

The energy difference between weightless and heavy is astounding.  Try
the new way: you will surely like it. 
</t>
<t tx="ekr.20120229094652.15095"></t>
<t tx="ekr.20120229094652.15096">Recent revs to to the trunk complete, with perhaps one or two small
additions to come, a grand redesign of all of Leo's @command/@button
nodes:

- Significant @command nodes now appear in:

   leoSettings.leo#@settings--&gt;Common @command nodes
   --&gt;@commands--&gt;@ignore

That is, they are define in as common global @command nodes, but they
are ignored.  Move them to myLeoSettings.leo as needed.

- @buttons appear only local to specific files.  See leoSettings.leo
for check buttons and LeoDocs.leo for various preview buttons.

In other words, the new org uses @command for global scripts and
@button for local scripts.  This makes sense for two reasons.  First,
we can't use @button for global scripts because that would overwhelm
the icon area.  Second, using @button for local scripts draws
attention to scripts that only make sense in a local context.  It's
very effect.

Edward

P.S. Except for the relatively minor tweaks, Leo already had
everything needed to support this scheme.  In particular, Leo already
supported the distinction between local and global @command and
@button nodes.

P.P.S. Earlier today I correct an oversight:  Leo now properly
supports @ignore nodes in @commands and @buttons nodes.  This is very
useful: no need for @@button or @@command.
</t>
<t tx="ekr.20120229094652.15097">I would prefer if it would be possible to launch tests externally without loading plug-ins.

As I see in Code--&gt;Testing--&gt;@file leoTest.py--&gt;runUnitTestLeoFile
and in Code--&gt;Testing--&gt;@file leoTest.py--&gt;class runTestExternallyHelperClass--&gt;runTests

there is an option to set gui for testing (g.app.unitTestGui) and default is 'nullGui'.

Maybe there could be an option to disable loading of plug-ins also ?

For the tests that I mostly write and run, loading plug-ins is just wasting time.
Vitalije.

===========================

&gt; I am not sure what happens at present, and I'm not sure whether any settings apply to these commands.

Good news (mostly): you can set up dynamic unit tests exactly the way you want.

I was going to point you at the documentation but (how can this
possibly be?) the documentation doesn't exist!  I really could have
sworn that everyone knew about what I am about to tell you ;-)  To
quote Alan Greenspan, "I'm shocked.  Shocked."

So here goes...

Let p be the presently selected node when you hit Alt-5
(run-unit-tests).  Leo, that is, the code in
runTestExternallyHelperClass, creates dynamicUnitTest.leo by
assembling all of the following nodes from p's descendants.

- All @test nodes,
- All @suite nodes, and, **most importantly**,
- All children of all @mark-for-unit-tests nodes.

You can use @mark-for-unit-test nodes to include any "supporting data"
you want, including, say, "@common test code" to be imported as
follows::

    exec(g.findTestScript(c,'@common test code'))

Hmm.  I doubt this is really written up properly, although I know for
sure at the time I did write it up on leo-editor.  It's a very cool
pattern.

Now here is the new trick.  It *should* work, but actually does *not*
work yet.  Boo hoo. Are you ready?

- @mark-for-unit-tests
  - @settings
    - @enabled-plugins

Alas, this doesn't work because the test code runs dynamicUnitTest.py,
which runs dynamicUnitTest.leo **using the leoBridge module**.  And,
as I have just verified, the leoBridge module doesn't load *any*
plugins.  Nor does it init any other settings.

So, no matter *what* @enabled-plugins contains, your code will start
off with no plugins at all.  Thus, the following unit test will always
pass when run with Alt-5::

    @test loaded-plugins

    pc = g.app.pluginsController
    aList = pc.getLoadedPlugins()
    assert not aList,aList

However, your tests *can* load plugins if they like, provided they
don't through an exception when loaded with nullGui.  For example, the
following test passes::

    @test load backlink plugin

    pc = g.app.pluginsController
    pc.loadOnePlugin('backlink.py')
    aList = pc.getLoadedPlugins()
    assert 'leo.plugins.backlink' in aList

A similar trick could probably be used to set c.config settings from
the @settings tree, but at present your code would have to do all the
work itself: the leoBridge module does **not** initialize settings.
That is, c.config.getBool(x) returns None for all (strings) x.

I hope this gives you a sense of what is going on.  For full details,
consult leoTest.py.

It has been fun tracking this down.  I'll fix the documentation immediately. 
</t>
<t tx="ekr.20120229094652.15098">http://groups.google.com/group/leo-editor/browse_thread/thread/92ae059cc5213ad3

I bear good tidings of great joy!

I recently received a new MacBook Pro and did a fresh upgrade to Mac
OS 10.7 (Lion). I then used the opportunity to test out installation
procedures of various software on a clean system. My main finding is
that the excellent Homebrew (mxcl.github.com/homebrew/) makes things
much easier these days.

Why Homebrew? It does not try to replace every single bit of
functionality on your Mac with their own version, like Macports or
fink. It reuses the existing libraries as far as possible. No need to
reinstall Python, for example (one of my pet gripes when people try to
install new software on their Macs, and the source of much confusion
and pain). It installs to /usr/local, the standard place to find
third-party libraries and headers, instead of the obscure /opt or /sw.
It's simple to use and to extend.

I last installed Leo on Mac OS 10.4 (Tiger) back in the Tk days, and
wondered what it looked like in Qt. All the horror stories of PyQT on
Mac discouraged me from trying this before, so I was keen to see if
Homebrew helps. Here is my installation write-up:

- Make sure you have Xcode installed
  (test it by confirming that "gcc" runs in the Terminal)

- In preparation for homebrew, the best option in my opinion is
  to delete /usr/local via::

  sudo rm -rf /usr/local

  and install any software in it via homebrew instead. If this step
  fills you with dread and you do not want to lose your beloved
  third-party software, the second-best option is to make sure you
  have write permission for the directory via::

  sudo chown -R &lt;your user name&gt;:admin /usr/local

  If you don't know your username, run "whoami". :-) This is
  useful because homebrew actually discourages you from
  installing third-party software as the superuser (the usual Mac
  apps in /Applications are also installed as the normal user,
  for that matter).

- Install Homebrew (http://mxcl.github.com/homebrew/) by running
  the following command in the Terminal::

  /usr/bin/ruby -e "$(curl -fsSL https://raw.github.com/gist/323731)"

- Run "brew update" to get the latest formulas

- Now install PyQT (yes, that's it!)::

  brew install pyqt

- Run "brew doctor" and check any further suggestions to improve
  your system.

- Add the following lines to your ~/.bash_profile
  (or ~/.profile on Leopard)::

  export PATH=/usr/local/bin:$PATH
  # This is for SIP (and PyQT) as suggested by Homebrew
  export PYTHONPATH=/usr/local/lib/python:$PYTHONPATH

- Open a new Terminal tab / window so that the above settings
  take effect, and install Leo. I downloaded the Leo-4.9-final-a.zip,
  unzipped it, and ran "python launchLeo.py" inside the Leo
  directory.

We should consider adding a Homebrew formula for Leo. This will
simplify the process even further, to simply "brew install leo". I
started on this, but wasn't sure where to put the various Leo files in
the system hierarchy. The Debian package can give some clues here, but
I haven't looked at it yet.

Ludwig
</t>
<t tx="ekr.20120229094652.15099">The prefix "DingDing" signifies that this post is an answer to the
lament:

    "Wouldn't it be great if we all could remember what we,
    and others, have already done :-)"

Last night I had a forehead-slapping moment: the place to put @button
nodes is in myLeoSettings.leo.

This morning, I realized that using @command rather than @button
completes the Aha.

This organization has all benefits, and no drawbacks:

- I always know here scripts are.

- No need for duplicates.

- I can organize the scripts within myLeoSettings.leo as usual using
organizer nodes.  This organization can change as needed.

- Using @command rather than @button means that I never have to
disable scripts.  No more @@button.

- Using @command saves screen real estate.  In my experience, having
buttons be visible doesn't prevent them from being hidden in full
view.

- If I use common prefixes, like c_ (for command) or edit_ (for edit-
related scripts) or ekr_ (for personal scripts), the *typing
completion* will let me zero in on the script I want to use:

    &lt;alt-x&gt; c_&lt;tab&gt;
    &lt;alt-x&gt; c_import&lt;tab&gt;

etc.  Furthermore, Ctrl-P (repeat-complex-command) will allow me to
rerun the last script run.  This is a quite common case.

Summary
=======

This Aha substitutes an *already-existing* usage (typing completion)
for a whole set of memory-intensive retrieval problems.  I'm not
likely ever to forget typing completion, although I might forget the
specif prefixes used in @command nodes.  If that happens, I'll know
where to look.

This Aha takes full advantage of Leo's organization strengths and
*concentrates* those strengths by putting all the to-be-organized
material in one place.  This allows for easy reorganization:  changing
command-name prefixes, for instance, would be straightforward.

This is another example of the assertion that Leo already has most of
what is required to handle any task. 
</t>
<t tx="ekr.20120229094652.15100"></t>
<t tx="ekr.20120229094652.15101">Overview of the code
====================

All notes refer to methods in class AutoCompleterClass unless otherwise noted.

- The autoComplete method is the entry point. It will be called
  when autocompletion is enabled and the user types either a period
  or ctrl-space (


The legacy autocompleter is eval based.

 uses Leo-specific code to when editing specific .leo files: leoDocs.leo, leoPlugins.leo, etc.
       
</t>
<t tx="ekr.20120229094652.15102">On Sep 10, 8:36 am, "Edward K. Ream" &lt;edream...@gmail.com&gt; wrote:

&gt; Later posts will discuss the following:
&gt; 
&gt; - Setting up to use ctags/codewise completion.

This section describes how to use Ville's codewise.py
module in leo\external folder.

**Note**: I've recently made a few changes to codewise.py. The
following discussion reflects the following changes:

- Changed docstring.

- The setup command does not crash if the ~/.ctags file already
  exist.
  
- The setup command does not call the init command, and thus does
  not delete ~/.codewise.db.
  
- Revised various print statements so they look better with Python 3.x.

**Important**: Leo's core contains all necessary autocompletion
code. In particular, enable *neither* the ctagscompleter.py
plugin *nor* the codewisecompleter.py plugin. I plan to remove
these plugins immediately, unless someone gives a good reason not
to do so.

**Important**: I've taken care to with the following
instructions, but there could be oversights or misunderstandings.
I would appreciate any corrections or additions.

Creating codewise/ctags data
============================

1. Make sure you have exuberant ctags (not just regular ctags)
   installed. It's an Ubuntu package, so its easy to install if
   you're using Ubuntu.
   
2. Execute the following commands from Leo's external/codewise.py
   module. **Note**: On Windows, you can use codewise.bat to
   execute these commands. For example::

        python &lt;path to leo&gt;\external\codewise.py %*
    
A. [Optional] Create a custom ~/.ctags file containing default
   configuration settings for ctags::
    
        codewise setup
        
    This command will leave the ~/.ctags file unchanged if it
    exists.  Othewise, the ``codewise setup`` command will
    create a ~/.ctags file containing the following defaults::
    
        --exclude=*.html
        --exclude=*.css
    
    See: http://ctags.sourceforge.net/ctags.html#FILES for more
    details about the .ctags file.
    
B. [Optional] Delete the existing ctags database in ~/.codewise.db::
   
        codewise init
        
C. Add ctags data to the existing ctags database::

        codewise parse &lt;path to directory&gt;
        
   You can add data from multiple sources by running
   the ``codewise parse`` command on multiple directories.
   
</t>
<t tx="ekr.20120229094652.15103">Leo's autocompletion suggests **completions**, text may be valid in a given
point, or **context** in source code. For example, suppose the context is::

    os.path.s
    
That is, suppose the cursor follows ``os.path.s`` in the body pane. The valid
completions are all the members of Python's os.path module whose names start with 's',
namely::

    samefile
    sameopenfile
    sep
    split
    splitdrive
    splitext
    splitunc
    stat
    supports_unicode_filenames
    sys
    
</t>
<t tx="ekr.20120229094652.15104">There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autocompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.
</t>
<t tx="ekr.20120229094652.15105">How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.
    


</t>
<t tx="ekr.20120229094652.15106">When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.
</t>
<t tx="ekr.20120229094652.15107">When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.
</t>
<t tx="ekr.20120229094652.15108">Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
</t>
<t tx="ekr.20120229094652.15109">Leo's autocompletion suggests **completions**, text may be valid in a given
point, or **context** in source code. For example, suppose the context is::

    os.path.s
    
That is, suppose the cursor follows ``os.path.s`` in the body pane. The valid
completions are all the members of Python's os.path module whose names start with 's',
namely::

    samefile
    sameopenfile
    sep
    split
    splitdrive
    splitext
    splitunc
    stat
    supports_unicode_filenames
    sys
    
Starting autocompletions
========================

There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autcompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.

Displaying autocompletions
==========================

How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.

Using the QCompleter
====================

When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.

Using the Log pane completer
============================

When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.

Showing docstrings
==================

Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
</t>
<t tx="ekr.20120229094652.15110">There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autocompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.
</t>
<t tx="ekr.20120229094652.15111">How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.
    


</t>
<t tx="ekr.20120229094652.15112">When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.
</t>
<t tx="ekr.20120229094652.15113">When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.
</t>
<t tx="ekr.20120229094652.15114">Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
</t>
<t tx="ekr.20120229094652.15115">Function and design
===================

Both the legacy and new completer now work *exactly* the
same way, because they both use the AutoCompleterClass to
compute the list of completions.

The strict "stateless" requirement means that the
"intermediate" completions must be entered into the body
pane while completion is active. It works well as a visual
cue when using the tabbed completer: indeed, the tabbed
completer would be difficult to use without this cue.

The situation is slightly different with the qcompleter.
Adding code before the user accepts the completion might be
considered an "advanced" feature. However, it does have two
important advantages, especially when "chaining" across
periods: it indicates the status of the chaining and it
limits what must appear in the qcompleter window.



</t>
<t tx="ekr.20120229094652.15116">Minor Autocompletion settings
=============================

These are found in leoSettings.leo: @settings--&gt;Autocompleter

- @bool use_codewise = False

True: use codewise completions.
False: use Leo-specific completions.

- @bool use_qcompleter = True

True:  show completions in a QCompleter popup.
False: show completions in Leo's Completions tab.
This option has effect only when using the qt or qttabs gui's.

The following options specify minor user preferences: they have little or no effect on the design or code of the autocompleter:

- @bool auto_tab_complete = False

True: Automatically extend the completed text to the longest common prefix of all completions.

- @bool autocomplete-brackets = False

True: When typing an opening bracket '(','[' or '{', immediately type the corresponding closing bracket.  To move past the closing bracket, just type it.

- @bool enable_calltips_initially = False

- @bool forbid_invalid_completions = False

True: Don't add characters during autocompletion that are not part of any computed completion.
</t>
<t tx="ekr.20120229094652.15117">Appearance
==========

There is little change to the legacy completer, except that
no text is highlighted in the body pane during completion.
This is calmer than before. Furthermore, there is no longer
any need for highlighting, because when the user types a
backspace the legacy completer now simply deletes a single
character instead of the highlighted text.

One minor change: the legacy completer now *does* insert
characters that do not match the start of any possible
completion. This is an experimental feature, but it might
play well with using codewise completions as a fallback to
Leo-related completions.

</t>
<t tx="ekr.20120229094652.15118">Why the codewise module
=======================

- This module supports modern code completion for the Leo editor.

- Exuberant ctags is an excellent code scanner, but TAGS file
  lookup sucks for "find methods of this class".
  
- This module puts all data in a single file, ~/.codewise.db by
  default. In contrast, TAGS files can exist all over the file
  system.

- The code in codewise.py is usable as a python module, or a
  command line tool.


Codewise completions
====================

The codewise-oriented completions appear to work well. In
large part, this is due to adding the global "self."
completions to all class-related completions (kind ==
'class' in ac.get_codewise_completions). This looks like a
really good hack, and it eliminates the need for the
ContextSniffer class.
</t>
<t tx="ekr.20120229094652.15119">Performance
===========

Performance of Leo-related completions is *much* better than
before. The old code used Python's inspect module and was
horribly complex. The new code uses eval and is perfectly
straightforward.

The present codewise-related code caches completions for all
previously-seen prefixes. This dramatically speeds up
backspacing. Global caching is possible because completions
depend *only* on the present prefix, *not* on the presently
selected node. If ContextSniffer were used, completions
would depend on the selected node and caching would likely
be impractical. Despite these improvements, the performance
of codewise-oriented completions is noticeably slower than
Leo-related completions.

Performance notes
=================

The ac.get_cached_options cuts back the prefix until it
finds a cached prefix. ac.compute_completion_list then uses
this (perhaps-way-too-long-list) as a starting point, and
computes the final completion list by calling
g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much
simpler and more robust than attempting to do "prefix AI"
based on comparing old and new prefixes. Furthermore, this
scheme is completely independent of the how completions are
actually computed. The autocompleter now caches options
lists, regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to
get_completions replace calls to
g.itemsMatchingPrefixInList. However, for short prefixes,
the list that g.g.itemsMatchingPrefixInList scans can have
thousands of items. Scanning large lists can't be helped in
any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the
completionDict does *not* define state (it is valid
everywhere) and no state variables had to be added. In
short, the new caching scheme is much better than before,
and it probably is close to optimal in most situations.

</t>
<t tx="ekr.20120229094652.15120">os.path.splitdrive.d_rule
os.path.join
</t>
<t tx="ekr.20120229094652.15121">Creating codewise/ctags data
============================

This is adapted from the thread:
http://groups.google.com/group/leo-editor/browse_thread/thread/ac3f8789010c882e/ca01e7a803d2b546
"HOWTO: make Ville's autocompleter work.

1. Make sure you have exuberant ctags (not just regular ctags) installed.  It's an Ubuntu package, so it's easy to install if you're using Ubuntu.

2. All recent versions of Leo contain Ville's codewise module: leo/external/codewise.py

@pagewidth 60

Overview of the code
====================

All notes refer to methods in class AutoCompleterClass
unless otherwise noted.

- The autoComplete method is the entry point.  It will be called when autocompletion is enabled and the user types either a period or ctrl-space (


The legacy autocompleter is eval based.

 uses Leo-specific code to when editing specific .leo files: leoDocs.leo, leoPlugins.leo, etc.
       


Here are the contents of the discussion of autocompletion from the 4.9 release notes in LeoDocs.leo.  These should be folded into Leo's Users Guide: I'll do that today.

QQQQQ
 
Appearance
==========

There is little change to the legacy completer, except that
no text is highlighted in the body pane during completion.
This is calmer than before. Furthermore, there is no longer
any need for highlighting, because when the user types a
backspace the legacy completer now simply deletes a single
character instead of the highlighted text.

One minor change: the legacy completer now *does* insert
characters that do not match the start of any possible
completion. This is an experimental feature, but it might
play well with using codewise completions as a fallback to
Leo-related completions.

Function and design
===================

Both the legacy and new completer now work *exactly* the
same way, because they both use the AutoCompleterClass to
compute the list of completions.

The strict "stateless" requirement means that the
"intermediate" completions must be entered into the body
pane while completion is active. It works well as a visual
cue when using the tabbed completer: indeed, the tabbed
completer would be difficult to use without this cue.

The situation is slightly different with the qcompleter.
Adding code before the user accepts the completion might be
considered an "advanced" feature. However, it does have two
important advantages, especially when "chaining" across
periods: it indicates the status of the chaining and it
limits what must appear in the qcompleter window.

Codewise completions
====================

The codewise-oriented completions appear to work well. In
large part, this is due to adding the global "self."
completions to all class-related completions (kind ==
'class' in ac.get_codewise_completions). This looks like a
really good hack, and it eliminates the need for the
ContextSniffer class.

Performance
===========

Performance of Leo-related completions is *much* better than
before. The old code used Python's inspect module and was
horribly complex. The new code uses eval and is perfectly
straightforward.

The present codewise-related code caches completions for all
previously-seen prefixes. This dramatically speeds up
backspacing. Global caching is possible because completions
depend *only* on the present prefix, *not* on the presently
selected node. If ContextSniffer were used, completions
would depend on the selected node and caching would likely
be impractical. Despite these improvements, the performance
of codewise-oriented completions is noticeably slower than
Leo-related completions.

Performance notes
=================

The ac.get_cached_options cuts back the prefix until it
finds a cached prefix. ac.compute_completion_list then uses
this (perhaps-way-too-long-list) as a starting point, and
computes the final completion list by calling
g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much
simpler and more robust than attempting to do "prefix AI"
based on comparing old and new prefixes. Furthermore, this
scheme is completely independent of the how completions are
actually computed. The autocompleter now caches options
lists, regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to
get_completions replace calls to
g.itemsMatchingPrefixInList. However, for short prefixes,
the list that g.g.itemsMatchingPrefixInList scans can have
thousands of items. Scanning large lists can't be helped in
any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the
completionDict does *not* define state (it is valid
everywhere) and no state variables had to be added. In
short, the new caching scheme is much better than before,
and it probably is close to optimal in most situations.

QQQQQ

Part 2: New documentation

As I reread the release notes, I see that they are too code-oriented for the general reader.  What is needed are the following:

1. A discussion of Autocompletion settings in 
</t>
<t tx="ekr.20120229094652.15122">The following options specify minor user preferences: they have little or no
effect on the design or code of the autocompleter:

- @bool auto_tab_complete = False

True: Automatically extend the completed text to the longest common prefix of all completions.

- @bool autocomplete-brackets = False

True: When typing an opening bracket '(','[' or '{', immediately type the corresponding closing bracket.  To move past the closing bracket, just type it.

- @bool enable_calltips_initially = False

- @bool forbid_invalid_completions = False

True: Don't add characters during autocompletion that are not part of any computed completion.
</t>
<t tx="ekr.20120229094652.15123">Typing a period when @language python is in effect starts
autocompletion. Typing Return or Control-g (keyboard-quit) exits
autocompletion.

Autocompletion shows what may follow a period in code. (Actually
you can specify any character using the auto-complete shortcut
setting.) For example, after typing g. Leo will show a list of
all the global functions in leoGlobals.py. Autocompletion works
much like tab completion in the minibuffer. Unlike the
minibuffer, the presently selected completion appears directly in
the body pane.

A leading period brings up ‘Autocomplete Modules’. (The period
goes away.) You can also get any module by typing its name. If
more than 25 items would appear in the Autocompleter tab, Leo
shows only the valid starting characters. At this point, typing
an exclamation mark shows the complete list. Thereafter, typing
further exclamation marks toggles between full and abbreviated
modes.

If x is a list ‘x.!’ shows all its elements, and if x is a Python
dictionary, ‘x.!’ shows x.keys(). For example, ‘sys.modules.!’
Again, further exclamation marks toggles between full and
abbreviated modes.

During autocompletion, typing a question mark shows the docstring
for the object. For example: ‘g.app?’ shows the docstring for
g.app. This doesn’t work (yet) directly for Python globals, but
‘__builtin__.f?’ does. Example: ‘__builtin__.pow?’ shows the
docstring for pow.

Autocompletion works in the Find tab; you can use &lt;Tab&gt; to cycle
through the choices. The ‘Completion’ tab appears while you are
doing this; the Find tab reappears once the completion is
finished. Calltips

Calltips appear after you type an open parenthesis in code.
Calltips shows the expected arguments to a function or method.
Calltips work for any Python function or method, including
Python’s global functions. Typing Return or Control-g
(keyboard-quit) exits calltips.

Examples:

    ‘g.toUnicode(‘ gives ‘g.toUnicode(s, encoding, reportErrors=False’
    ‘c.widgetWantsFocusNow’ gives ‘c.widgetWantsFocusNow(w’
    ‘reduce(‘ gives ‘reduce(function, sequence[, initial]) -&gt; value’

The calltips appear directly in the text and the argument list is highlighted so you can just type to replace it. The calltips appear also in the status line for reference after you have started to replace the args.

Options

Both autocompletion and calltips are initially enabled or disabled by the enable_autocompleter and enable_calltips settings in leoSettings.leo. You may enable or disable these features at any time with these commands: enable-auto-completer-command, enable-calltips-command, disable-auto-completer-command and disable-calltips-command.
The minibuffer

The mini-buffer is a text area at the bottom of the body pane. You use it like the Emacs mini-buffer to invoke commands by their so-called long name. The following commands affect the minibuffer:

    full-command: (default shortcut: Alt-x) Puts the focus in the minibuffer. Type a full command name, then hit &lt;Return&gt; to execute the command. Tab completion works, but not yet for file names.

    universal-argument: (default shortcut: Alt-u) Like Emacs Ctrl-u. Adds a repeat count for later command. Ctrl-u 999 a adds 999 a’s.
    keyboard-quit: (default shortcut: Ctrl-g) Exits any minibuffer mode and puts the focus in the body pane.

For example, to print a list of all commands type Alt-X print-commands &lt;Return&gt;.

The following sections list the various commands that you can invoke from the minibuffer. Important: you may bind keystrokes to any of these commands. See Customizing Leo for full details.
</t>
<t tx="ekr.20120229094652.15124">It sometimes happens that the focus gets left in a Leo in a widget
that doesn't support Leo's key bindings.  You would think that you
would have to use the mouse to click in, say, the body pane so that
you can use Leo's key bindings again.

But you don't have to do that.  Instead, use Alt-tab once to change
away from Leo, and then use Alt-tab again to change back to Leo.  When
you do this, Leo puts focus in the body pane and you are all set. This
will work either on Windows or Ubuntu.  A similar trick works on
MacOS.

Edward

P.S. One of the requirements of the recent bug fix was that doing Alt-
tab twice would put the focus in the body pane.  If you think that was
easy, you are sadly mistaken :-) 
</t>
<t tx="ekr.20120229094652.15125">http://groups.google.com/group/leo-editor/browse_thread/thread/b560a3b84e7ec7a8

Good news (mostly): you can set up dynamic unit tests exactly the way you want.

I was going to point you at the documentation but (how can this
possibly be?) the documentation doesn't exist!  I really could have
sworn that everyone knew about what I am about to tell you ;-)  To
quote Alan Greenspan, "I'm shocked.  Shocked."

So here goes...

Let p be the presently selected node when you hit Alt-5
(run-unit-tests).  Leo, that is, the code in
runTestExternallyHelperClass, creates dynamicUnitTest.leo by
assembling all of the following nodes from p's descendants.

- All @test nodes,
- All @suite nodes, and, **most importantly**,
- All children of all @mark-for-unit-tests nodes.

You can use @mark-for-unit-test nodes to include any "supporting data"
you want, including, say, "@common test code" to be imported as
follows::

    exec(g.findTestScript(c,'@common test code'))

Hmm.  I doubt this is really written up properly, although I know for
sure at the time I did write it up on leo-editor.  It's a very cool
pattern.

Now here is the new trick.  It *should* work, but actually does *not*
work yet.  Boo hoo. Are you ready?

- @mark-for-unit-tests
  - @settings
    - @enabled-plugins

Alas, this doesn't work because the test code runs dynamicUnitTest.py,
which runs dynamicUnitTest.leo **using the leoBridge module**.  And,
as I have just verified, the leoBridge module doesn't load *any*
plugins.  Nor does it init any other settings.

So, no matter *what* @enabled-plugins contains, your code will start
off with no plugins at all.  Thus, the following unit test will always
pass when run with Alt-5::

    @test loaded-plugins

    pc = g.app.pluginsController
    aList = pc.getLoadedPlugins()
    assert not aList,aList

However, your tests *can* load plugins if they like, provided they
don't through an exception when loaded with nullGui.  For example, the
following test passes::

    @test load backlink plugin

    pc = g.app.pluginsController
    pc.loadOnePlugin('backlink.py')
    aList = pc.getLoadedPlugins()
    assert 'leo.plugins.backlink' in aList

A similar trick could probably be used to set c.config settings from
the @settings tree, but at present your code would have to do all the
work itself: the leoBridge module does **not** initialize settings.
That is, c.config.getBool(x) returns None for all (strings) x.

I hope this gives you a sense of what is going on.  For full details,
consult leoTest.py.

It has been fun tracking this down.  I'll fix the documentation immediately. 
</t>
<t tx="ekr.20120229094652.15126"></t>
<t tx="ekr.20120229094652.15127">Terry:

I don't think the OP was trying to import MORE data, I think Leo is
incorrectly trying to apply MORE rules on loading a .txt file.

The File-&gt;Import command gives no indication it expects MORE data.

OTOH, the simple workaround is to use File-&gt;Open.

So perhaps it's a documentation / ui bug to clarify what File-&gt;Import
is for.


==============

Rob:
    
I would agree the documentation could be updated to reflect current
practice. The online docs (under the heading 'Importing Files Into Leo
Outlines':

The Import commands do not attempt to do perfect translations; they
merely automate the bulk of the drudgery:

   The Import to @file command creates an @file node from a file.
   The Import CWEB Files command creates an @file node from a CWEB file.
   The Import noweb Files command creates an @file node from a noweb file.
   The Import External File command imports all the nodes in a external file into the outline. Unlike the read commands, the command preserves no outline structure.
   The Import Flattened Outline command converts plain text written in MORE format to an outline.

The Import Flattened Outline command brings up a
dialog.................(more info about MORE spec)

I would say most/all of this has been deprecated as there's only one
Import command.
</t>
<t tx="ekr.20120229094652.15128">http://groups.google.com/group/leo-editor/browse_thread/thread/92ae059cc5213ad3

I bear good tidings of great joy! 

I recently received a new MacBook Pro and did a fresh upgrade to Mac
OS 10.7 (Lion). I then used the opportunity to test out installation
procedures of various software on a clean system. My main finding is
that the excellent Homebrew (mxcl.github.com/homebrew/) makes things
much easier these days.

Why Homebrew? It does not try to replace every single bit of
functionality on your Mac with their own version, like Macports or
fink. It reuses the existing libraries as far as possible. No need to
reinstall Python, for example (one of my pet gripes when people try to
install new software on their Macs, and the source of much confusion
and pain). It installs to /usr/local, the standard place to find
third-party libraries and headers, instead of the obscure /opt or /sw.
It's simple to use and to extend.

I last installed Leo on Mac OS 10.4 (Tiger) back in the Tk days, and
wondered what it looked like in Qt. All the horror stories of PyQT on
Mac discouraged me from trying this before, so I was keen to see if
Homebrew helps. Here is my installation write-up:

- Make sure you have Xcode installed
  (test it by confirming that "gcc" runs in the Terminal)

- In preparation for homebrew, the best option in my opinion is
  to delete /usr/local via::

  sudo rm -rf /usr/local

  and install any software in it via homebrew instead. If this step
  fills you with dread and you do not want to lose your beloved
  third-party software, the second-best option is to make sure you
  have write permission for the directory via::

  sudo chown -R &lt;your user name&gt;:admin /usr/local

  If you don't know your username, run "whoami". :-) This is
  useful because homebrew actually discourages you from
  installing third-party software as the superuser (the usual Mac
  apps in /Applications are also installed as the normal user,
  for that matter).

- Install Homebrew (http://mxcl.github.com/homebrew/) by running
  the following command in the Terminal::

  /usr/bin/ruby -e "$(curl -fsSL https://raw.github.com/gist/323731)"

- Run "brew update" to get the latest formulas

- Now install PyQT (yes, that's it!)::

  brew install pyqt

- Run "brew doctor" and check any further suggestions to improve
  your system.

- Add the following lines to your ~/.bash_profile
  (or ~/.profile on Leopard)::

  export PATH=/usr/local/bin:$PATH
  # This is for SIP (and PyQT) as suggested by Homebrew
  export PYTHONPATH=/usr/local/lib/python:$PYTHONPATH

- Open a new Terminal tab / window so that the above settings
  take effect, and install Leo. I downloaded the Leo-4.9-final-a.zip,
  unzipped it, and ran "python launchLeo.py" inside the Leo
  directory.

We should consider adding a Homebrew formula for Leo. This will
simplify the process even further, to simply "brew install leo". I
started on this, but wasn't sure where to put the various Leo files in
the system hierarchy. The Debian package can give some clues here, but
I haven't looked at it yet.

Now I just have to start using Leo after all these years of checking
it out... :-)

</t>
<t tx="ekr.20120229094652.15130">I want to learn about PyQt and leo's qtGui. As a first step,
I'm trying to execute a script from within a leo body::

    from PyQt4 import QtGui
    w = QtGui.QWidget()
    w.resize(250, 150)
    w.move(300, 300)
    w.setWindowTitle('Simple test')
    w.show()

Q. When I try the above, I see a window appear and then
immediately disappear. How can I keep the window visible?

A. When the script exits the sole reference to the window,
w, ceases to exist, so the window is destroyed (garbage
collected). To keep the window open, add the following code
as the last line to keep the reference alive::

    g.app.scriptsDict['my-script_w'] = w

Note that this reference will persist until the next time
the execute-script command is run.  If you want something even
more permanent, you can do something like::

    g.app.my_script_w = w
</t>
<t tx="ekr.20120229094652.15131">From Brian Theado

The other day I stumbled across Ville's code in scripts.leo which displays the
output of python's trace module in a leo outline. The output of the trace module
is not very friendly and I didn't find the result very usable. I was inspired to
write some code to translate the output so the tree of function calls is
displayed via Leo headlines. Thanks to Ville for sharing that code. I never
would have figure this out without that starting point.

Just copy (Ctrl-Shift-V) the child outline into a leo outline and hit ctrl-b on
the "call tree" node. The execution tree of the 'scroll-outline-up-line'
minibuffer command will be displayed to stdout and also as a tree of leo
headlines.
</t>
<t tx="ekr.20120229094652.15132">import trace

@language python
@others

# see http://docs.python.org/library/trace.html for documentation
# on the trace module
tracer = trace.Trace(countcallers=1)

# Trace a minibuffer command.

# Any function call will work. Leo's minibuffer commands are easily discoverable
# via tab completion and the 'print-commands' command.

#tracer.runfunc(c.executeMinibufferCommand, 'goto-prev-node')
tracer.runfunc(c.executeMinibufferCommand, 'scroll-outline-up-line')

top = p.insertAsLastChild().copy()
top.h = 'trace session'
displayCalltree(top, tracer.results().callers.keys())
c.redraw()
</t>
<t tx="ekr.20120229094652.15133">def displayCalltree(p, callinfo):
   '''
   Converts the function call hierarchy in 'callinfo' into a tree of function
   calls.  The function call tree is displayed to stdout as indented text
   and is inserted as a tree of leo nodes rooted at the given position 'p'
   '''
   callers = [k[0] for k in callinfo]
   callees = [k[1] for k in callinfo]

   # The first set of children will be those that don't have any callers
   # listed in callinfo
   toplevels = list(set(callers) - set(callees))
   positions = {}
   path = []

   # Depth-first traversal of the call hierarchy represented by 'callinfo'
   # 'levels' is a stack which grows during descend and shrinks
   # during ascend.  Each element of 'levels' is a list of unprocessed
   # siblings of each other
   levels = [toplevels]
   while len(levels) &gt; 0:
       while len(levels[-1]) &gt; 0:
           # Process the first element in the 'deepest' (i.e. last) list of siblings
           cur = levels[-1][0]
           levels[-1] = levels[-1][1:]
           indent = " " * 4 * (len(levels)-1)
           if cur not in path:
               if cur in positions.keys():
                   # Function already seen, so make a clone
                   clone = positions[cur].clone()
                   clone.moveToLastChildOf(p)
                   print (indent + "%s %s ..." % cur[1:])
               else:
                   # Haven't seen this function, so insert a new headline
                   p = p.insertAsLastChild().copy()
                   p.h = "%s %s" % cur[1:]
                   print (indent + p.h)

                   # Remember the position so it can be cloned if seen again
                   positions[cur] = p

                   # Find all callees of this function and descend
                   levels.append([c[1] for c in callinfo if c[0] == cur])
                   path.append(cur)
           else:
               r = p.insertAsLastChild().copy()
               r.h = "(recursive call) %s %s" % (cur[1], cur[2])
               print(indent + r.h + "...")

       # Ascend back up one level
       path = path[0:-1]
       p = p.parent()
       levels = levels[0:-1]
</t>
<t tx="ekr.20120229094652.15134"></t>
<t tx="ekr.20120229094652.15135">http://groups.google.com/group/leo-editor/browse_thread/thread/f13fadac68eec41b/9124ba6d733ecbad
leoInspect: a hobby with a future?

http://groups.google.com/group/leo-editor/browse_thread/thread/62f0e7b84a25e0d0/39f848ad8a96bcbc
leoInspect: remarkable collapse in complexity and attempted assessment

</t>
<t tx="ekr.20120229094652.15137">http://groups.google.com/group/leo-editor/browse_thread/thread/61019e45d75a6f18/71ee770ee4421222


Once you have the 4.9 "official release" working, then further updates are simply:

(ongoing practice - keep your folder containing your leo
code - separate from your .mySettings.leo and any data
files, .leo and otherwise.)

1. archive and remove that app folder
2. download the nightly snapshot zip file
3. unzip it into the same place
4. enjoy your up-to-date Leo code. . .
</t>
<t tx="ekr.20120229094652.15138">http://groups.google.com/group/leo-editor/browse_thread/thread/5fdadfba113e12d9/fa329534654ecfec

Leo now reports bzr version numbers and dates more accurately.
</t>
<t tx="ekr.20120229094652.15139">

Note: in rev 4990, the g.app.newCommander method (formerly called
g.app.newLeoCommanderAndFrame) also returns a single value (a
Commander) rather than the tuple (c,c.frame). 
</t>
<t tx="ekr.20120229094652.15140">http://groups.google.com/group/leo-editor/browse_thread/thread/dd5907529208ee98

Revs 5037/8 contain fixes that allow the open-with command to start to
work, at least in 'subprocess.Popen' mode.

However, I think it is time for a complete rethink of how users
specify open-with settings.

===== The problems

1. The format of settings in @openwith nodes is way too wonky.  At
present, the body text of such nodes consists of a single line, which
contains a 3-tuple of elements. Let us call this line the **open-with
line**.

The entire open-with line must be a valid Python tuple.  This causes
problems for both user and implementation, as discussed more fully
below.

2. openTempFileInExternalEditor is the method that translates the
settings in @openwith nodes into code that actually open the temp file
with the desired editor.  At present, this method has to do an
**eval** of the single @openwith line, which has lots bad
consequences:

- eval is a slight security problem, although there are a gazillion
worse problems.

- The user has to quote strings, and those quotes are removed by eval,
so there is no easy way to specify quoted strings (the user has to
*doubly* quote strings.)

- There is no indication of what the parts of the open-with line mean.

3. At present, openTempFileInExternalEditor does some ridiculously-
complicated munging of the *eval'd* open-with line in order to get
produce the correct call to subprocess.Popen.  It's possible that
there is an easier way, but I haven't found it yet.

===== A proposed solution

1. We need a much more user-friendly format for @openwith nodes.  Let
us suppose that the body of @openwith nodes contains one or more lines
of the following form::

   tag: value

The possible tags will be::

- kind: &lt;a string&gt;

The value specifies the **opener logic**, that is, the method used to
launch the external editor, one of
('subprocess.Popen','os.system','os.startfile','os.spawnl','os.spawnv',
'exec')

- arg: &lt;a string&gt;

There may be many such arg lines. Each line will be a string to be
passed as an argument to the opener logic, in a format that is
compatible with the specified opener logic.

**Important**: quotes in &lt;a string&gt; will be *retained* (not eval'd),
allowing the user to specify exactly the arguments to be passed to
opener logic.

- custom: &lt;a string&gt;

Here, &lt;a string&gt; *will* be eval'd, yielding an object to be used as
the opener logic.

It's likely that either the "custom" tag or the "exec" opener value is
redundant.

===== Summary

The present scheme is wonky, confusing, inflexible and extremely
difficult to implement. It should be replaced immediately.
</t>
<t tx="ekr.20120229094652.15141">http://groups.google.com/group/leo-editor/browse_thread/thread/28e544d052aeac2b

The original beautiful plan to read each local .leo file once has
fallen prey to an ugly fact :-)  Indeed, it doesn't seem possible to
call event handlers like open0, open1 and open2 without having inited
settings.  As a result, the 5-Phase load process in g.openWithFileName
is dead.  I won't morn it's loss.

Today's work has been valuable.  I've refactored the code in ways that
will survive the failure of the first plan.

The second plan will simplify code using another strategy, as
follows::

1. Leo will, as at present, read local files twice.  The first load
will discover the settings to be used in the second load.  This will
ensure that proper settings are *available* during the second load.

2. Instead of initing settings "late" in the finishCreate methods, all
ctors will init settings "early", before calling the ctors for
subsidiary objects.  This will ensure that proper settings are *in
effect* for the subsidiary ctors.

3. There is a clever way of using the fact that c.__init__ creates
*all* subsidiary objects (directly or indirectly).  After creating all
such objects, c.__init__ can simply call c.finishCreate!  It's
beautiful, and it should work. "Internalizing" the call to
c.finishCreate will help eliminate newLeoCommanderAndFrame, something
that I very much want to do.

At least one difficult puzzle remains, namely how to communicate the
settings discovered in the first load to the c.config object created
in the second load. Trust me, this is much harder than you might
expect.  But such problems *can* be solved cleanly.  It just takes
lots of work. 

=====

Hurray! The new plan is a *spectacular* success!

===== The unification of Leo's startup code

Creating Commands objects is now completely self-contained.  In
particular, c.__init__ now creates the fully-inited gui frame.  This
is a revolution in Leo's startup code!

Indeed, the old code inited Leo windows in several places, and in
several phases:

Places: c.__init__, the end of g.app.newLeoCommanderAndFrame and the
end of g.openWithFileName.

Phases: g.app.newCommanderAndFrame, g.openWithFileName and
c.finishCreate.

The new code has c.__init__ do *all* the work, in one place, and in
one phase.

This will be supremely important for future maintainers.  The old code
was difficult for me to understand yesterday, even after a full week
of study.  The new code is a simple as could possibly be imagined.
This is a gigantic step forward for Leo.

This spectacular collapse in complexity will have all sorts of
excellent consequences...

===== More cleanups

A number of possibilities for cleaner code now present themselves:

- c.__init__ no longer needs a frame argument, a surprisingly
important conceptual simplification.

- All calls to g.app.openWithFileName will be replaced by a call to
Commands(...), that is, c.__init__.  Because this code happens at
startup, it may still be useful to wrap this in a method that imports
the leo.core.leoCommands module, but this is a nit.  It will now be
perfectly clear that c.__init__ does all the work.

- I now see that having g.openWithFileName "fail" causes needless
complications.  It should simply create a new Leo window if it is
given no fileName argument, or if the file does not exist.  This will
eliminate a lot of "if" statements ;-)

Note: I have already removed the switches that enabled the new code.
This makes the code much easier to read.

I'll be upping these simplification later today.

===== The final phases

Once the code base has been cleaned, I'll turn my attention to the
"new_load" and "new_config" schemes.

new_load: simplifies the infamous readSettingsFiles methods into
several cleaner methods.

new_config: uses a much simpler per-commander c.config.get method
instead of delegating to the horribly complex g.app.config.get method.

There is significant coordination between these two schemes.  In fact,
they are really two aspects of the same problem.  I'll probably merge
these two switches into one.

Developmental unit testing has already proven both schemes.  It should
be relatively straightforward to fold the new code into the new code
base, but that is not guaranteed--there are still hidden complexities
to be dealt with.  Still, I expect the code to be fully tested in a
day or three.

Once all the new code is complete, it will be time to repackage all
the recent work as methods of the LoadManager class.  This promises to
eliminate significant code duplication in the leoBridge module.  We'll
see about that...

Finally, g.openWithFileName will do nothing but call a corresponding
LoadManager method. The details of loading do not belong in
leoGlobals.py! 
</t>
<t tx="ekr.20120229094652.15142">http://groups.google.com/group/leo-editor/browse_thread/thread/808ba29fec64e590

For almost 15 years Leo has been written using a limited set of
classes.  These were "big" classes, implementing major modules of
Leo.  There is nothing wrong with these classes, and they will remain
unchanged, except insofar as they will be simplified by the classes I
am about to discuss.

Recently, I have become aware that Leo's code could be considerably
simplified by adding "smallish" classes.  Indeed, I now think the
distinction between big and small classes is unhelpful.  The most
important part of the design of a class is simply whether a class
implements an understandable concept.

With this introduction, here is a short summary of Leo's new classes.
Some have not been fully implemented.  Getting them all to work is a
big part of the rewrite of Leo's config, loading and key-handling
code.

===== LoadManager

This class handles all the messy details of loading .leo files at
startup.  That's its *purpose*.

At the code level, it encapsulates almost all the code in runLeo.py,
as well as some methods in leoGlobals.py that really belong somewhere
else.  Creating a class simplifies the code to a surprising degree: 5
or 6 ivars of the class represent command-line options.  These ivars
are always available: there is no need to pass them around as
arguments.

Defining a new class means that it might be possible to reuse this
code in the leoBridge module, which would eliminate a lot of duplicate
code.

===== ModeController and ModeInfo

The ModeController class represents a collection of modes.  The
ModeInfo class represents a single mode.

Without these classes, the code in leoKeys.py is extremely hard to
understand.  In fact, the present code is a perfect example of the
problems with procedural programming: client code is burdened with
knowing way too many details about matters that it shouldn't have to
know about.  Furthermore, that data itself is hard to understand:
it's too "raw".  These classes provide "identity" for data.  The value
of repr(aModeInfo) is surprisingly large.

===== LogManager

This class represents the global log.  It hides the details of the log
from the g.app class and several other pieces of code.

At present, the interface to this class is procedural.  That is, the
present g.app methods that will be moved into this class have a
procedural rather than descriptive nature.  I'm not sure how much this
will change, but creating this class may create opportunities that
were not apparently previously.

===== KeyStroke and ShortcutInfo

I've discussed these previously.  The KeyStroke class is a wrapper for
plain strings.  It's most important attribute is its *identity*.  It
announces that its contents is a canonicalized value, not a raw user
settings string or any other kind of data associated with key
handling.

Similar remarks apply to ShortcutInfo objects.  Their identity
clarifies the code.  The former code used g.bunches.  In complex code
such as leoKeys.py, such anonymous objects really obfuscate matters.

===== EditCommandsManager

I wrote and tested this class last night.  It solves a problem that
has been annoying me ever since I created leoEditCommands.py.  The
problem is this:  without this class the classesList has to be defined
at the end of the module, after all classes have been imported.
Worse, several module-level methods were needed to manage the
classesList.

In the new scheme, each Commander creates an EditCommandsManager, and
the code that previously had to call the module-level method
leoEditCommands.x(c) now simply calls c.editCommandManager.x().  This
is much cleaner and avoids several very ugly imports.  Which brings me
to...

===== Avoiding imports of Leo files

I would like to avoid having Leo's modules import each other wherever
possible.  This would simplify Leo's startup process considerably.

At present, the ctor for the Commands class imports many modules.
This is essential to break what would otherwise be circular
dependencies among Python imports.  We can extend this pattern by
creating more classes, as was done with the EditCommandsManager class.

I'm not sure exactly how this will play out, but removing circular
imports between Leo's module seems like a worthy goal.  The leoGlobals
module is an important exception.  All of Leo's modules do::

   import leo.core.leoGlobals as g

To make this work, it is *essential* that leoGlobals.py import *no*
other Leo modules.

===== A new (limited!) use for section references

I am going to create a new section in leoGlobals.py called &lt;&lt; global
switches &gt;&gt;  It will contain code such as:

   new_load = False # True: .leo files are loaded at most once.
   if new_load: print('***** new_load')

   new_modes = False # True: use ModeController and ModeInfo classes.
   if new_modes: print('***** new_modes')

This section is useful because I can clone it.  I can then enable and
disable switches in the clone, without having to keep "@file
leoGlobals.py" visible.  Very handy.
</t>
<t tx="ekr.20120229094652.15143"></t>
<t tx="ekr.20120229094652.15144">leoSettings.leo:

table = (
        # First, leoSettings.leo in the home directories.
        join(g.app.homeDir,     settings_fn),
        join(g.app.homeLeoDir,  settings_fn),

        # Next, &lt;machine-name&gt;leoSettings.leo in the home directories.
        # join(g.app.homeDir,     machine_fn),
        # join(g.app.homeLeoDir,  machine_fn),

        # Last, leoSettings.leo in leo/config directory.
        join(g.app.globalConfigDir, settings_fn)
    )

myLeoSettings.leo:

    table = (
        # First, myLeoSettings.leo in the local directory
        join(localDir,          settings_fn),

        # Next, myLeoSettings.leo in the home directories.
        join(g.app.homeDir,     settings_fn),
        join(g.app.homeLeoDir,  settings_fn),
    
        # Next, &lt;machine-name&gt;myLeoSettings.leo in the home directories.
        join(g.app.homeDir,     machine_fn),
        join(g.app.homeLeoDir,  machine_fn),

        # Last, leoSettings.leo in leo/config directory.
        join(g.app.globalConfigDir, settings_fn),
    )
</t>
<t tx="ekr.20120229094652.15145">http://groups.google.com/group/leo-editor/browse_thread/thread/86593fb9543afb66

Rev 4972 demonstrates that the KeyStroke class can indeed distinguish
between "raw" user settings and the "canonicalized" form used
throughout Leo.  Indeed, the ability to explicitly distinguish between
the two, using type checking, has already substantially clarified and
simplified the code.

BTW, this is in no way a violation of OO principles.  The code is not
dispatching on the type of objects, it is merely enforcing vital
consistency checks.  This code is complex: confusion about the types
of objects is intolerable.  Happily, the resulting clarity allows the
code to be substantially simpler than it would otherwise be, which in
turn clarifies the code further, and so on...

Part 1: This work is vital

As described below, the forthcoming work will lead to a cascade of
other simplification.  These simplifications are important for at
least three, reasons:

1. The code must be simplified so that future maintainers (including
me) will have an easier time of it.

2. The present code provides no real help in creating unit tests that
test how Leo handles keystrokes.

3. Simplifying the code will provide a more solid foundation for vim-
related bindings.

Part 2: Notes about the KeyStroke class

Objects of the KeyStroke class can be used *exactly* as a strings may
be used:

A.  KeyStroke objects may be used as dictionary keys, because they
have __hash__ methods and all the so-called rich comparison methods:
__eq__, __ne__, __ge__, __gt__, __le__ and __lt__.  Note that
KeyStroke objects may be compared with other KeyStroke objects,
strings and None.

B. At present, KeyStroke objects supports the find, lower and
startswith methods.  This simplifies the code substantially: we can
apply these methods to either strings or KeyStroke objects, so there
is no need to create different versions of the code depending on the
value of g.new_strokes.

However, having the KeyStroke class support string methods is bad
design.  Indeed, it is a symptom that the client code that uses
KeyStroke objects knows too much about the internals of KeyStroke
objects.  Instead, the KeyStroke class should have higher-level
methods that use s.find, s.lower and s.startswith internally.

You could say that the fact that code in leoKeys.py calls s.find,
s.lower and s.startswith is a symptom of non OO programming.  The
internal details of settings and strokes "pollutes" the code.  This
must be fixed.  This will likely create opportunities for further
simplifications.

Part 3: Other design changes

The present work, enabled and disabled with g.new_strokes, has been a
resounding success.  The next steps will be as follows:

Better packaging.

g.new_strokes, g.isStroke and g.isStrokeOrNone should be defined in
leoKeys.py, not leoGlobals.py.
I knew from the start that such global names were only a temporary
expedient.

Now I know where they should go. leoKeys.py, not leoConfig.py, is the
proper place to handle all the details about key bindings.  Indeed the
code in leoConfig.py simply parses user key settings into *strings*.
These raw strings must be converted to KeyStroke objects by
leoKeys.py.

As a result, the KeyStroke class (and the ShortcutInfo class?) should
be defined in leoKeys.py, not leoConfig.py.  To make this work, we'll
want to create several factory methods: k.makeKeyStroke and
k.makeShortcutInfo.

Better separation of concerns.

The Qt key input code can be hugely simplified by calling a new
k.makeKeyStrokeFromData factory method.  At present, the Qt key input
code knows *all* the details of  the format of *canonicalized*
settings. This is absolutely wretched design.

Instead, the Qt input key code should simply pass the key modifiers
and other key information to k.makeKeyStrokeFromData, in a some kind
of "easy" format.  For example, the Qt input key code would represent
the internal Qt modifiers as lists of strings like "alt", "ctrl",
"meta", "shift".  k.makeKeyStrokeFromData would then create a *user*
setting from the components, and then call k.strokeFromSetting to
complete the transformation.

As I said in another thread, the present Qt input key code is
entangled with other code.  I'll have to disentangle the code before
putting this scheme into effect.

Other classes

The easiest next step will be to integrate the presently unused
ShortcutsDict class into the code. This will eliminate the wretched
special cases for the _hash key.

Part 4: Conclusions

I have high hopes that we will see wave after wave of
simplifications.  Much of the difficult work presently scattered in a
non-OO fashion throughout leoKeys.py, leoConfig.py and leoQtGui.py
will migrate to become KeyStroke methods (or methods of other
classes).

The KeyStroke class has already made possible vital type-related
assertions.  Knowing *for sure* exactly what crucial data is and what
it means is a huge step forward.   More steps are coming. 

=====

&gt; &gt; Why not just have .s attribute in KeyStroke, that contains the string
&gt; &gt; version?

&gt; A good question.  Indeed, all Keystroke objects ks do have an s ivar.

I forgot the most important reason in my reply.  The reasons I gave
all were code-level responses, but the most important reason is that
is truly impossible to understand the key code without knowing whether
an object is a string representing a user setting or the canonicalized
version used in Leo's core, that is, a KeyStroke object.  Using ks.s
instead of ks destroys precisely the information needed to understand
the code.

Again, this is not a theoretical concern.  The key code now contains
assertions of the form::

    assert g.isStroke(stroke)
or
    assert g.isStrokeOrNone(stroke)

Getting these assertions to pass in *all* situations required several
important revisions of the code.  The code that makes the assertions
pass is "innocuous", that is, almost invisible in the mass of code,
but obviously, these small pieces of code are vital.

The present code highlights these changes: look for g.new_strokes,
especially lines marked with ####.  These markers will be cleaned away
eventually, but the asserts will remain forever.

Furthermore, the asserts suggested further simplifications.  It was a
tricky process, and it will be ongoing as I simplify the code further. 

=====

&gt; I am about to convert many of Leo's key-handling dictionaries to
&gt; g.TypedDict objects.  Using TypedDicts will make it impossible to make
&gt; invalid assignments to Leo's crucial key dictionaries.

This has been a great success.  I also defined the g.TypedDictOfLists
class, where the values are lists of a known type.  These classes are
useful for more than type checking:  they have unique names and a dump
method that dumps the dict in an easy-to-read format that includes the
name, and valid types for keys and values.

At present, these dicts are *not* subclasses of {}, which has its
pluses and minuses.  These are quite simple classes, so at present
only the "for key in d.keys()" idiom is supported, the "for key in d"
idiom is not supported.

Plain dicts do have their uses, but for "long-lived" dicts, and dicts
passed around between methods, I am beginning to regard plain dicts as
being as ill-advised as g.Bunches.

Leo's key dictionaries will always be complex, but basing them on the
TypedDict class is a major improvement. 
</t>
<t tx="ekr.20120229094652.15146">http://groups.google.com/group/leo-editor/browse_thread/thread/c933b28c27d3b9a7

Ref 4952 of the trunk fixes bug 87933:
"Redefining a key binding breaks menu items with same binding"

This was a difficult bug to fix--I rewrote significant parts of Leo's
code that deals with settings for key binding.

All unit tests pass, and I have been using this code happily for a few
days, but significant problems could be lurking.  Please use caution
and please report any problems immediately, especially settings-
related problems.

Besides fixing the bug, Leo computes accelerators, in menu items
dynamically when the user activates a menu.  The accelerator shows
*all* keys bound to the command associated with the menu item.

In the next few days I'll be simplifying the new code further, so if
you want more stable code please stay away from the trunk and the
nightly builds for the next several days.

Here is the checkin log:

A major reorganization of the configuration code that fixes bug 87933
Redefining a key binding breaks menu items with same binding

- Replaced g.bunches with ShortcutInfo objects, and bunchList name by
aList followed by
  assert isinstance(si,ShortcutInfo),si

  Using ShortcutInfo objects rather than g.bunch was a big win.

- Wrote and tested make_settings_dict and its helpers,
merge_settings_dicts, invert and uninvert.

- Leo computes menu texts dynamically in onAboutToShow.

- leo_update_shortcut now shows all shortcuts for a command.

- leoMenu.define_enable_dict encapsulates data used to enable/disable
commands regardless
  of where those commands appear in Leo's menu. The old code assumed
that a fixed menu
  location for all commands that could be enabled or disabled.

- Removed dynamic_menus "compile-time" constant.

- Created &lt;&lt; define global key dicts &gt;&gt; in leoApp.py.

  This is a duplicate of dicts in leoKeys.py: they will be merged
later today
  in a location to be determined.

- Added unused ShortcutName and ShortcutsDict classes.

  The ShortcutName class will go away: it's methods may become methods
of the ShortcutInfo class.
  Alternatively, the methods might stay where they are.

  The ShortcutsDict class *will* become functional: it's the only way
to eliminate the wretched
  _hash hack used in the present raw key dictionaries. Furthermore,
the ShortcutsDict class
  will probably encapsulate inverted dicts. 
  
=====

&gt; Ref 4952 of the trunk fixes bug 87933:
&gt; "Redefining a key binding breaks menu items with same binding"

&gt; This was a difficult bug to fix--I rewrote significant parts of Leo's
&gt; code that deals with settings for key binding.

I am now in the midst of some long-overdue simplification that has
been made possible with the new code:

1. Leo now (provably) no longer uses the very complex g.app.config.get/
set code for shortcuts.

2. The new k.kill_one_shortcut allows k.registerCommand to properly
override settings.  For example, File:New is no longer bound to Ctrl-N
when the following becomes active::

    @button test @key=Ctrl-N

k.kill_one_shortcut uses the invert/uninvert trick used in
merge_settings_dict.  Only this kind of elegant code has a chance of
working reliably.

3. As mentioned in another thread, k.tkbindingFromStroke is about to
make its exit.

4. I'll be making several other simplifications to the config code in
the next several days.  It is important to do it now while all the
complexities are fresh in my mind. 
</t>
<t tx="ekr.20120229094652.15147">End going to only physical line and not to the logical (wrapped) one)... 
</t>
<t tx="ekr.20120229094652.15148">http://groups.google.com/group/leo-editor/browse_thread/thread/d36d76174dcd6786

Currently I am using Leo as an outliner for the elaboration of
documents with LaTeX. For this, I work with @rst nodes and Sphinx. It
works really wonderful.

When using citations, Sphinx and RsT offer a certain syntax that, as
far as I have understood, does allow only for the generation of
"simple", Leo-self-contained citation references (inside of say a "Leo
References Section" node).

So I use a citation of the form   [CITBook001]_ inline in the text.
Somewhere else in the same Leo outline I have the corresponding
description as:

.. [CITBook001] A citation as well-known

When using LaTeX and BibTeX, I would like to use inside of Leo a kind
of LaTeX-inline-markup, that after generation of the RsT file through
Sphinx as well as after  running of "make latex", it generates a LaTeX
file containing the citation call of the form \cite{CITBook001} as
described in a file *.bib.  The only way I follow today is the later
editing by hand of the LaTeX file. This is of course not the best way.
How to convince Leo/Sphinx/RsT to generate the inline raw latex
syntax? It could be very simple, but ... I haven not been able to see
it.

Any hints? 

=====

&gt; How to convince Leo/Sphinx/RsT to generate the inline raw latex
&gt; syntax?

http://docutils.sourceforge.net/docs/ref/rst/directives.html#raw-data...

?

Cheers -Terry 

=====

I followed the recommendations of Terry. It was much easier
as I thought! Here a summary of the use of custom roles in
Leo to generate LaTeX "inline markup" from Leo:

+ @ rst-no head Defining the custom role, here applicable to html and
latex syntax
   .. role:: raw-role(raw)
      :format: html latex

+ @A document section
   This is my text including an example of inline markup for
generating :raw-role:`\LaTeX\` from Leo. For more details see
:raw-role:`\cite{rstDocumentation}`. Of course, my bib database below will
describe this citation with plenty of details.

+ @rst-no-head Including the bib database
   .. raw:: latex

      \bibliographystyle{acm}
      \bibliography{myBibliography}

It worked really fine! 
</t>
<t tx="ekr.20120229094652.15149">http://groups.google.com/group/leo-editor/browse_thread/thread/ba9eb63337467d42/a3f3750d0ce6e847

&gt; Here's a one line @button node you can add to myLeoSettings.leo
&gt;
&gt; @button set-style
&gt;    c.frame.top.leo_ui.setStyleSheet(p.b)

Cool.  I've added this to my "pre-writing" pile of things to be
included in the next set of docs.

Important:  setStyleSheet *replaces* the previous stylesheet with the
new stylesheet, so you had best set all the attributes of Leo's
default stylesheet.

As an alternative, if w is any Qt widget, w.setStyleSheet(p.b) will
set the stylesheet for that widget only: the top-level stylesheet (the
stylesheet for c.frame.top.leo_ui) remains unchanged.
</t>
<t tx="ekr.20120229094652.15151">http://groups.google.com/group/leo-editor/browse_thread/thread/b49d23010703aa61/32e1271d25ba2cfb

&gt; In short, I am now willing, on an experimental basis, to have Leo put
&gt; up a dialog when inserting an @ignore, and also when writing an
&gt; @&lt;file&gt; node containing @ignore.

&gt; In the past, I have always found read/write dialogs to be a) intrusive
&gt; and b) panic-inducing, but this may be a tolerable exception.  We
&gt; shall see.
</t>
<t tx="ekr.20120229094652.15152">groups.google.com/group/leo-editor/browse_thread/thread/5da0de4502154b2c/1b077a8bb8e65811

Some people seem to think that it is difficult to understand how Leo
handles "clone wars":  differing values for a cloned nodes that appear
in several external files.  That's not true.  The rule is::

    **The last clone that Leo reads wins.**

That is, for any cloned node C, Leo takes the value of C.h and C.b to
be the values specified by the last copy that Leo reads.

There is only one complication::

    **Leo reads the entire outline before reading any external
files.**

Thus, if C appears in x.leo, y.py and z.py, Leo will choose the value
for C in x.py or y.py, depending on which @&lt;file&gt; node appears later
in the outline.

Notes:

1. Whenever Leo detects multiple values for C when opening an outline,
Leo creates a "Recovered nodes" tree.  This tree contains all the
various values for C, nicely formatted so that it is easy to determine
where the differences are.

2. I've just refreshed my memory by looking at the code.  The relevant
methods are:

    fc.getLeoFile # Reads the outline, then calls at.readAll to read
all external files.
    at.indicateNodeChanged # Adds data to c.nodeConflictList
    cacher.reportChangedClone # Adds data to c.nodeConflictList
    fc.handleNodeConflicts # Creates "Recovered Nodes" node and its
children.

3. The present code is the simplest code that could possibly work.
There is no way Leo is going to do AI in order to implement complex
rules for which clones are "more important" than others.  Thus, if you
use cross-file clones, it is up to *you* to know these rules and
handle any resulting conflicts.  Imo, the "Recovered Nodes" feature is
a big step forward for Leo, and makes it impossible to lose data
unless you willfully refuse to examine the data. 
</t>
<t tx="ekr.20120229094652.15153">groups.google.com/group/leo-editor/browse_thread/thread/3666397da2a0d05f/758071d6d9516ab9

The right-click context menu on the tabs in the tabbed window mode (the
default) has a 'Detach' option, if there's more than one outline / tab,
and a Re-attach all option, if there's a detached outline window
out there.

Now there's also 'Horizontal tile', and 'Vertical tile', which detach
the tab and then tile its window with the window from which it was
detached.

This is very helpful for moving nodes between outlines, I was
rearranging the windows by hand and setting one to 'always on top' with
the window manager before.  Note: there's a @setting to determine
whether dragging nodes between outlines copies or moves them.

Depending on your OS / window manager, tiling / placement may be
somewhat off, and may work better with or without the window being
maximized before tiling, you'll have to experiment.

You'd think it would be straight forward for Qt to ask the
window-manager where the window is now, and then tell it to put it
somewhere specific, but apparently a lot of window-managers regard this
as none of Qt's business.

=====

&gt; Now there's also 'Horizontal tile', and 'Vertical tile', which detach
&gt; the tab and then tile its window with the window from which it was
&gt; detached.

BEHAVIOR CHANGE: to make the above new feature more useful, I've
changed what happens when you close an outline window created by
detaching a tab.  Before the outline was closed (with prompt for save
in necessary).  Now the outline's just re-attached as a tab.  This
means it's now possible to reattach just one outline, rather than
having to use the 'reattach all' option. 
</t>
<t tx="ekr.20120229094652.15157"></t>
<t tx="ekr.20120229094652.15158">@nocolor-node

After so many years of confusion the problem is now apparent:
the Windows console uses code page 437: which is just extended ascii.

chcp 65001 is equivalent to utf-8, and it would be good to use,
but at present bzr goes nuts and changes to another code page!

So for the moment I'll have to live with what is, in effect, plain ascii.
</t>
<t tx="ekr.20120229094652.15159">@nocolor-node

On Ubuntu only, the auto complete popup is system-wide modal, it should only be modal over Leo windows.

However, there does not seem to be any fix:
http://groups.google.com/group/leo-editor/browse_thread/thread/171aaf79e0bea256

All works well on Windows 7.  I do see the "system-wide" model
behavior on Ubuntu.

This appears to be a Ubuntu-specific bug.  Indeed, the popup is a
QListWidget.  Such widgets have a setWindowModality method::

    setWindowModality ( Qt::WindowModality windowModality )

The valid modalities are at: http://doc.qt.nokia.com/4.7-snapshot/qt.html#WindowModality-enum

NonModal: The window is not modal and does not block input to other
windows.

WindowModal: The window is modal to a single window hierarchy and
blocks input to its parent window, all grandparent windows, and all
siblings of its parent and grandparent windows.

ApplicationModal: The window is modal to the application and blocks
input to all windows.

None of these would appear to be a system-wide modality, and
furthermore, the default is supposed to be NonModal.

Anyway, calling setWindowModality(QtCore.Qt.NonModal) does not seem to
have much effect on Ubuntu, so I think I can safely say there is
nothing more I can do. 
</t>
<t tx="ekr.20120229094652.15162"></t>
<t tx="ekr.20120229094652.15163"></t>
<t tx="ekr.20120229094652.15164"></t>
<t tx="ekr.20120229094652.15165"></t>
<t tx="ekr.20120229094652.15166"></t>
<t tx="ekr.20120229094652.15167"></t>
<t tx="ekr.20120229094652.15168"></t>
<t tx="ekr.20120229094652.15169"></t>
<t tx="ekr.20120229094652.15170"></t>
<t tx="ekr.20120229094652.15172"></t>
<t tx="ekr.20120229094652.15173"></t>
<t tx="ekr.20120229094652.15174"></t>
<t tx="ekr.20120229094652.15175"></t>
<t tx="ekr.20120229094652.15176"></t>
<t tx="ekr.20120229094652.19496">https://bugs.launchpad.net/leo-editor/+bug/905276

The documentation should explain how to clone multiple nodes at once.

The documentation should explain how to clone multiple nodes at once.

Past docs-related suggestions
====================
I would suggest that right up at the top of that page be a statement

somewhat along these lines (Edward do get rid of the blah blah! 8-) :

----
The core Leo code is always being improved and developed, using a rigorous unit-testing blah-blah that ensures that the daily commits are as bug-free as possible. In fact (insert #% or qualifier) of the time, downloading the most recent "nightly snapshot" of the development code from our version control system Bazaar (link to here http://www.greygreen.org/leo/) is going to give you code that is just as stable and much more up-to-date than the most recent "release" available here (link to http://sourceforge.net/projects/leo/files/OldFiles/), which most Leonistas would at this point consider already outdated. If you are just checking Leo out, feel free to download and use the release version if it makes you feel more secure, but once you've decided to work with Leo on a regular basis, we highly recommend regularly keeping your installation up to date with the most recent snapshot:

(assuming you keep the folder containing your leo code separate from your .mySettings.leo and any data files, including of course your .leo files)

  1. archive and remove that app folder
  2. download the nightly snapshot zip file
  3. unzip it into the same place
  4. enjoy your up-to-date Leo code. . .

----
the main "how to install" text should be targeted at the lowest common denominator "man on the street" stopping by to check out Leo.

IMO there shouldn't be any mention of Bazaar in the mainstream "getting started with Leo", unless presented as "keeping up to date" or "for people looking to contributed". And until the Bazaar memory issues are resolved I think only the latter.

Someone who's never heard of a version control system should be much less intimidated by "unzip this here and create a batch file" than figuring out Bazaar.

Other notes:

Since for Linux and Windows the initial hurdle for many is getting the prerequisites going, I would make that part OS-specific, but then have the "within-Python" stuff marked platform-independent, leaving only the more problematic Mac discussion as a completely separate section - in fact I'd suggest putting a link to a completely separate page somewhere near the top, to leave the main page with a more positive overall tone.

Only after you've addressed the needs of "mere users" should there be a section, or again a link to a separate page for programmers who may be interested in helping to develop Leo, and make it clear that Bazaar is the way to go for them (and currently only them), and only then add a note about Bazaar's current problems with memory usage and any Leo-specific suggestions and workarounds, again clearly targeted to that particular audience.

From Terry B: bzr should be recommended only for people who want to modify the code (or are simply familiar with bzr), and the nightly .zips should be pointed to as the way to run from the trunk.

In that vein, we should (a) get a proper URL for Leo, and (b) make the official nightly .zip url http://www.leo-editor.org/nightly or whatever, just so it doesn't break if http://www.greygreen.org/leo/ ever went away, even though I can see no reason that it should.

====================
The docs on @ &lt;file&gt; varieties somewhat deprecate @nosent - it would be useful IMO to point out that they are the only way to write out non-sentinel files "one way" AND be able to use outlining, clones etc.

Possibly a useful way to **output** cloned nodes safely to multiple files, as long as **at most only one** location is reading any given node into the .leo file. Supplement to the "@all" method having lower priority method for avoiding "clone wars" data loss - all this paragraph needing more thorough thinking / testing etc before being written up.

But in the meantime at least don't imply that @nosent doesn't have its uses. . .

--------------------

keyboard shortcuts docs in leoSettings have a lot of references to Tk

--------------------

I'll post new ones as I find them, but here's a summary of
https://bugs.launchpad.net/leo-editor/+bug/896809

so that can get closed, as it got sidetracked with the bzr memory problem

--------------------
The link cited here:
http://webpages.charter.net/edreamleo/FAQ.html#how-can-i-display-graphics-in-leo

is broken I would suggest embedding a short summary howto on the procedure rather than relying on links to forum/maillist postings.

--------------------
http://webpages.charter.net/edreamleo/installing.html#required-and-optional-packages
"Leo also requires --either-- the Qt widget set."

I have since figured out that this probably used to say "or TK" - " --either--" needs removing</t>
<t tx="ekr.20120229094652.19777">- open-with hook has changed: it now uses a "d" arg.</t>
<t tx="ekr.20120229094652.19778">The d argument to the open-with event handlers is a python
dictionary whose keys are all the tags specified by the user
in the body of the @open-with node.
</t>
<t tx="ekr.20120229173025.20633">http://groups.google.com/group/leo-editor/browse_thread/thread/d21349c52dabd066

Ever find that you have a whole lot of:

.. sourcecode:: py

  rec[f['analyte']] ... rec[f['sample_type']] ...

expressions in your code, and now things have changed and you want them
all to be:

.. sourcecode:: py

  row.Analyte ... row.Sample_Type ...

basically if str variable s was::

  rec[f['analyte']]

then you want to perform:

.. sourcecode:: py

  s = "row."+s.split("'")[1].title()

on each one.  In general it would be nice to be able to use a python
expression when search and replace doesn't cut it.

The button code below creates a button, ``fac``, which, when pressed,
creates another button, with some name you choose, which, when pressed,
executes some python code to fix the selected text in the body.

You can define the code to be executed in two ways, either in its own
node:

 - insert a new node with a headline which describes the refactor
 - enter code in the node which modifies the string variable ``s``,
   which is initially set to the selected text in the body
 - press the ``fac`` button, which creates a new button named
   after this code node
 - select each offending piece of text and press the button created
   in the previous step to fix

or

 - type some code modifying ``s`` right in the body you're working on
 - press the ``fac`` button, which creates a new button named "fix"
 - select each offending piece of text and press the button created
   in the previous step to fix

Note:

 - unlike regular button nodes, changing the code after the
   button's created (first option above) doesn't change the code
   executed by the button
 - replacing selection text makes Leo reposition the insert point at
   the top of the window, this is annoying but unrelated to this code

Here's the button code:

.. sourcecode:: py

  @button fac
    from leo.plugins.mod_scripting import scriptingController

    sc = scriptingController(c)

    if c.frame.body.hasSelection():
        code = c.frame.body.getSelectedText()
        heading = 'fix'
    else:
        code = p.b
        heading = p.h

    def transform(c=c, code=code):
        s = c.frame.body.getSelectedText()
        g.es(s)
        exec code
        g.es(s)
        c.frame.body.deleteTextSelection()
        i = c.frame.body.getInsertPoint()
        c.frame.body.insert(i, s)
        p.b = c.frame.body.getAllText()
        c.frame.body.setInsertPoint(i)

    b = sc.createIconButton(
        heading,
        command = transform,
        shortcut = None,
        statusLine = 'Make filter button',
        bg = "LightBlue"
    ) </t>
<t tx="ekr.20120229173025.20635">@language python

from leo.plugins.mod_scripting import scriptingController

sc = scriptingController(c)

if c.frame.body.hasSelection():
    code = c.frame.body.getSelectedText()
    heading = 'fix'
else:
    code,heading = p.b,p.h

def transform(c=c,code=code):
    w = c.frame.body
    s = w.getSelectedText()
    g.es(s)
    exec(code)
    g.es(s)
    w.deleteTextSelection()
    i = w.getInsertPoint()
    w.insert(i,s)
    p.b = w.getAllText()
    w.setInsertPoint(i)

sc.createIconButton(
    heading,
    command = transform,
    shortcut = None,
    statusLine = 'Make filter button',
    bg = "LightBlue"
)</t>
<t tx="ekr.20120229173025.20636">http://groups.google.com/group/leo-editor/browse_thread/thread/86593fb9543afb66/b888d149d75a9c77

The following are mostly notes to myself (and to future maintainers).
Feel free to ignore.

Rev 4972 demonstrates that the KeyStroke class can indeed distinguish
between "raw" user settings and the "canonicalized" form used
throughout Leo.  Indeed, the ability to explicitly distinguish between
the two, using type checking, has already substantially clarified and
simplified the code.

BTW, this is in no way a violation of OO principles.  The code is not
dispatching on the type of objects, it is merely enforcing vital
consistency checks.  This code is complex: confusion about the types
of objects is intolerable.  Happily, the resulting clarity allows the
code to be substantially simpler than it would otherwise be, which in
turn clarifies the code further, and so on...

Part 1: This work is vital

As described below, the forthcoming work will lead to a cascade of
other simplification.  These simplifications are important for at
least three, reasons:

1. The code must be simplified so that future maintainers (including
me) will have an easier time of it.

2. The present code provides no real help in creating unit tests that
test how Leo handles keystrokes.

3. Simplifying the code will provide a more solid foundation for vim-
related bindings.

Part 2: Notes about the KeyStroke class

Objects of the KeyStroke class can be used *exactly* as a strings may
be used:

A.  KeyStroke objects may be used as dictionary keys, because they
have __hash__ methods and all the so-called rich comparison methods:
__eq__, __ne__, __ge__, __gt__, __le__ and __lt__.  Note that
KeyStroke objects may be compared with other KeyStroke objects,
strings and None.

B. At present, KeyStroke objects supports the find, lower and
startswith methods.  This simplifies the code substantially: we can
apply these methods to either strings or KeyStroke objects, so there
is no need to create different versions of the code depending on the
value of g.new_strokes.

However, having the KeyStroke class support string methods is bad
design.  Indeed, it is a symptom that the client code that uses
KeyStroke objects knows too much about the internals of KeyStroke
objects.  Instead, the KeyStroke class should have higher-level
methods that use s.find, s.lower and s.startswith internally.

You could say that the fact that code in leoKeys.py calls s.find,
s.lower and s.startswith is a symptom of non OO programming.  The
internal details of settings and strokes "pollutes" the code.  This
must be fixed.  This will likely create opportunities for further
simplifications.

Part 3: Other design changes

The present work, enabled and disabled with g.new_strokes, has been a
resounding success.  The next steps will be as follows:

Better packaging.

g.new_strokes, g.isStroke and g.isStrokeOrNone should be defined in
leoKeys.py, not leoGlobals.py.
I knew from the start that such global names were only a temporary
expedient.

Now I know where they should go. leoKeys.py, not leoConfig.py, is the
proper place to handle all the details about key bindings.  Indeed the
code in leoConfig.py simply parses user key settings into *strings*.
These raw strings must be converted to KeyStroke objects by
leoKeys.py.

As a result, the KeyStroke class (and the ShortcutInfo class?) should
be defined in leoKeys.py, not leoConfig.py.  To make this work, we'll
want to create several factory methods: k.makeKeyStroke and
k.makeShortcutInfo.

Better separation of concerns.

The Qt key input code can be hugely simplified by calling a new
k.makeKeyStrokeFromData factory method.  At present, the Qt key input
code knows *all* the details of  the format of *canonicalized*
settings. This is absolutely wretched design.

Instead, the Qt input key code should simply pass the key modifiers
and other key information to k.makeKeyStrokeFromData, in a some kind
of "easy" format.  For example, the Qt input key code would represent
the internal Qt modifiers as lists of strings like "alt", "ctrl",
"meta", "shift".  k.makeKeyStrokeFromData would then create a *user*
setting from the components, and then call k.strokeFromSetting to
complete the transformation.

As I said in another thread, the present Qt input key code is
entangled with other code.  I'll have to disentangle the code before
putting this scheme into effect.

Other classes

The easiest next step will be to integrate the presently unused
ShortcutsDict class into the code. This will eliminate the wretched
special cases for the _hash key.

Part 4: Conclusions

I have high hopes that we will see wave after wave of
simplifications.  Much of the difficult work presently scattered in a
non-OO fashion throughout leoKeys.py, leoConfig.py and leoQtGui.py
will migrate to become KeyStroke methods (or methods of other
classes).

The KeyStroke class has already made possible vital type-related
assertions.  Knowing *for sure* exactly what crucial data is and what
it means is a huge step forward.   More steps are coming.

Edward 

=====

&gt; Why not just have .s attribute in KeyStroke, that contains the string
&gt; version?

A good question.  Indeed, all Keystroke objects ks do have an s ivar.

Experience (that is, ugly code) has shown that *during* the transition
we don't want to have two versions of the code, one using stroke (a
string) and the other using ks.s.

*After* the transition, that is, once the new_strokes switch goes
away, we could, in fact, use ks.s instead of ks.  However, it's
cleaner just to use ks and not have client code know about ks.s.

More importantly, too much code manipulates stroke (or ks.s) objects.
This is a symptom that the details key handling (whether represented
as a string or as a KeyStroke) have "bled" into the areas of the
leoKeys code where they do not belong.

This is far from a theoretical problem.  A lot of code in leoKeys.py
deals with the picky details of the representation of key strokes.
This is a great violation of the Don't Repeat Yourself principle and
makes the code "sclerotic": rigid and inflexible.

I am convinced that the present work will greatly simplify what is, at
present, by far the most difficult and poorly designed part of Leo.  A
capable KeyStroke class is a very important first step.  I'll say more
about this class in another thread. 

=====

&gt; A good question.  Indeed, all Keystroke objects ks do have an s ivar.

I forgot the most important reason in my reply.  The reasons I gave
all were code-level responses, but the most important reason is that
is truly impossible to understand the key code without knowing whether
an object is a string representing a user setting or the canonicalized
version used in Leo's core, that is, a KeyStroke object.  Using ks.s
instead of ks destroys precisely the information needed to understand
the code.

Again, this is not a theoretical concern.  The key code now contains
assertions of the form::

    assert g.isStroke(stroke)
or
    assert g.isStrokeOrNone(stroke)

Getting these assertions to pass in *all* situations required several
important revisions of the code.  The code that makes the assertions
pass is "innocuous", that is, almost invisible in the mass of code,
but obviously, these small pieces of code are vital.

The present code highlights these changes: look for g.new_strokes,
especially lines marked with ####.  These markers will be cleaned away
eventually, but the asserts will remain forever.

Furthermore, the asserts suggested further simplifications.  It was a
tricky process, and it will be ongoing as I simplify the code further.

Edward 

=====

&gt; it is truly impossible to understand the key code without knowing whether an object is a string representing a user setting or the canonicalized version used in Leo's core, that is, a KeyStroke object.

There is another set of strings floating around the key-handling code,
namely Leo's emacs-like command names. I am considering defining a new
class, say k.CommandName, to wrap such names.  If I do that, I'll base
the k.KeyStroke and k.CommandName classes on a common g.TypedString
class.

I am about to convert many of Leo's key-handling dictionaries to
g.TypedDict objects.  Using TypedDicts will make it impossible to make
invalid assignments to Leo's crucial key dictionaries, especially if I
create the CommandName class.  In effect, g.TypedDict objects will
enforce the constraints given in the comments in &lt;&lt; about key dicts &gt;&gt;
in leoKeys.py.

This machinery will allow further type-related assertions.  Details
omitted, but they will be quite useful, both as sanity checks and as
documentation.  The TypedDict class enforces its own type constrains
automatically, so the crucial type checks will not unduly clutter the
code.

Edward 

=====

&gt; I am about to convert many of Leo's key-handling dictionaries to
&gt; g.TypedDict objects.  Using TypedDicts will make it impossible to make
&gt; invalid assignments to Leo's crucial key dictionaries.

This has been a great success.  I also defined the g.TypedDictOfLists
class, where the values are lists of a known type.  These classes are
useful for more than type checking:  they have unique names and a dump
method that dumps the dict in an easy-to-read format that includes the
name, and valid types for keys and values.

At present, these dicts are *not* subclasses of {}, which has its
pluses and minuses.  These are quite simple classes, so at present
only the "for key in d.keys()" idiom is supported, the "for key in d"
idiom is not supported.

Plain dicts do have their uses, but for "long-lived" dicts, and dicts
passed around between methods, I am beginning to regard plain dicts as
being as ill-advised as g.Bunches.

Leo's key dictionaries will always be complex, but basing them on the
TypedDict class is a major improvement. </t>
<t tx="sps.20100708203040.19008">@language python
import os
pos = c.find_h("Users Guide")[0]
c.selectPosition(pos)
c.k.simulateCommand('rst3')
&lt;&lt; html manual &gt;&gt;
&lt;&lt; pdf manual &gt;&gt;
</t>
<t tx="sps.20100708203040.19009">d = c.scanAllDirectives(p)
mandir = d.get('path') + "/html"
g.es(mandir)
os.chdir(mandir)
os.system('make html')
</t>
<t tx="sps.20100708203040.19010"># you probably need to install several packages 
# to create pdf (e.g. jadetex)
mandir = d.get('path') + "/html"
g.es(mandir)
os.chdir(mandir)
os.system('make latex')
os.chdir('_build/latex')
os.system('../../fixup.pl &lt; Leodocumentation.tex &gt; LeoDoc.tex')
os.system('make LeoDoc.pdf')
</t>
<t tx="sps.20100708213227.44914"></t>
<t tx="ville.20090705224948.5734">import os
pos = c.find_h("Users Guide")[0]
c.selectPosition(pos)
c.k.simulateCommand('rst3')
&lt;&lt; html manual &gt;&gt;
# no pdf manual creation, perhaps too "involved" for many
</t>
<t tx="ville.20090705225609.5736">mandir = g.app.leoDir + "/doc/html"
g.es(mandir)
os.chdir(mandir)
os.system('make html')
</t>
<t tx="ville.20090705225609.5738"># you probably need to install several packages 
# to create pdf (e.g. jadetex)
mandir = g.app.leoDir + "/doc/html"
g.es(mandir)
os.chdir(mandir)
os.system('make latex')
os.chdir('_build/latex')
os.system('make all-pdf')
</t>
</tnodes>
</leo_file>
