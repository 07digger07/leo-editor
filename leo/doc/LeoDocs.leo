<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070610174018"><vh>Startup</vh>
<v t="ekr.20050407144417"><vh>@settings</vh>
<v t="ekr.20111108052738.5507"><vh>@shortcuts</vh></v>
<v t="ekr.20100907092300.4440"><vh>Inkscape options</vh>
<v t="ekr.20100907092300.4441"><vh>@string inkscape-template = ../docs/inkscape-template.svg</vh></v>
<v t="ekr.20100907092300.4442"><vh>@string inkscape-bin = "c:\Program Files (x86)\Inkscape\inkscape.exe"</vh></v>
</v>
<v t="ekr.20101009114830.4724"><vh>File options</vh>
<v t="ekr.20080923182326.1"><vh>@@bool create_nonexistent_directories = True</vh></v>
<v t="ekr.20080412124815.1"><vh>@bool fixedWindow = False</vh></v>
<v t="ekr.20101009114830.4723"><vh>@bool put_expansion_bits_in_leo_files = False</vh></v>
</v>
<v t="ekr.20101009114830.4725"><vh>Plugins options</vh>
<v t="ekr.20050407144342"><vh>@page http plugin</vh>
<v t="ekr.20050407144342.1"><vh>@bool http_active = False</vh></v>
<v t="ekr.20050407144342.2"><vh>@int  port = 8080</vh></v>
<v t="ekr.20050407144342.3"><vh>@string rst_http_attributename = rst_http_attribute</vh></v>
</v>
<v t="ekr.20050812123002"><vh>@page rst3 options</vh>
<v t="ekr.20050812123002.1"><vh>Http options...</vh>
<v t="ekr.20050812123002.2"><vh>@bool rst3_clear_http_attributes = False</vh></v>
<v t="ekr.20050812123002.3"><vh>@string rst3_http_attributename = 'rst_http_attribute'</vh></v>
<v t="ekr.20050812123002.4"><vh>@bool rst3_http_server_support = False</vh></v>
<v t="ekr.20050812123002.5"><vh>@string rst3_node_begin_marker = 'http-node-marker-'</vh></v>
</v>
<v t="ekr.20050812123002.6"><vh>@bool rst3_massage_body = False</vh></v>
<v t="ekr.20050812123002.7"><vh>@bool rst3_format_headlines = True</vh></v>
<v t="ekr.20050812123002.8"><vh>@bool rst3_write_intermediate_file = True</vh></v>
<v t="sps.20100708213227.44914"><vh>@string rst3_write_intermediate_extension = .html.txt</vh></v>
<v t="ekr.20051202072010"><vh>@string rst3_default_path =</vh></v>
</v>
</v>
</v>
<v t="ekr.20101028112631.4959" descendentVnodeUnknownAttributes="7d7100580b000000302e312e302e302e302e3171017d7102580b0000007374725f6c656f5f706f7371035800000000710473732e"><vh>@file doc-startup.txt</vh></v>
</v>
<v t="ekr.20050831195449"><vh>Read me first</vh></v>
<v t="ekr.20100805171546.4412"><vh>Files, including home page</vh>
<v t="ville.20090609182215.5676"><vh>@auto-rst treecaching.txt</vh></v>
<v t="ekr.20090428133936.2"><vh>@edit html\conf.py</vh></v>
<v t="ekr.20090428102353.1"><vh>@edit html\leo_toc.html.txt</vh></v>
<v t="ekr.20101025080245.5800"><vh>@edit leo_toc.html</vh></v>
<v t="ekr.20101112045055.5064"><vh>@file plugin_catalog.py</vh></v>
<v t="ekr.20100808060203.4273"><vh>@file html/front.html</vh></v>
<v t="ekr.20101025080245.5801"><vh>@url modified toc</vh></v>
<v t="ekr.20101026081737.5531"><vh>Links that replace those in actual built page</vh></v>
<v t="ekr.20101112045055.5065"><vh>@url docs generated from plugin_catalog.py</vh></v>
</v>
<v t="ekr.20040414161647"><vh>Users Guide</vh>
<v t="ekr.20101104024804.4898"><vh> Generating the Users Guide</vh>
<v t="sps.20100708203040.19008"><vh>@@button generate-full-userguide</vh>
<v t="sps.20100708203040.19009"><vh>&lt;&lt; html manual &gt;&gt;</vh></v>
<v t="sps.20100708203040.19010"><vh>&lt;&lt; pdf manual &gt;&gt;</vh></v>
</v>
<v t="ville.20090705224948.5734"><vh>@@button generate-userguide</vh>
<v t="ville.20090705225609.5736"><vh>&lt;&lt; html manual &gt;&gt;</vh></v>
<v t="ville.20090705225609.5738"><vh>&lt;&lt; pdf manual &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20101025080245.5794"><vh>Preliminaries</vh>
<v t="ekr.20050831184021.3"><vh>Front matter</vh>
<v t="ekr.20100805165051.7148"><vh>@file frontMatter.txt</vh></v>
</v>
<v t="ekr.20070701101808"><vh>Preface</vh>
<v t="ekr.20100805165051.7149"><vh>@file preface.txt</vh></v>
</v>
<v t="ekr.20050831184021.4"><vh>What people are saying about Leo</vh>
<v t="ekr.20100805165051.7150"><vh>@file testimonials.txt</vh></v>
</v>
</v>
<v t="ekr.20101025080245.5795"><vh>Basics</vh>
<v t="ekr.20050831195331.1"><vh>FAQ</vh>
<v t="ekr.20100805165051.7151"><vh>@file FAQ.txt</vh></v>
</v>
<v t="ekr.20101007100904.4372"><vh>Slideshows page</vh>
<v t="ekr.20100821182153.4344"><vh>@file screen-shots.txt</vh></v>
</v>
<v t="ekr.20100731112744.7267"><vh>Installing Leo</vh>
<v t="ekr.20100805165051.7152" descendentVnodeUnknownAttributes="7d71005807000000302e302e342e3171017d710258120000007273745f687474705f61747472696275746571035d71042858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333722206e616d653d22687474702d6e6f64652d6d61726b65722d3337223e710558040000003c2f613e71065d71072858260000003c64697620636c6173733d2273656374696f6e222069643d22672d726566696e64616c6c223e710858060000003c2f6469763e71095d710a28584f0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e710b58060000003c2f6469763e710c5d710d28583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710e58060000003c2f6469763e710f5d71102858060000003c626f64793e711158070000003c2f626f64793e71125d71132858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711458070000003c2f68746d6c3e71154e656565656558070000003c2f6469763e0a711658070000003c2f6469763e0a711758350000003c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e0a7118586c0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313922206e616d653d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e52756e6e696e67204c656f20696e206261746368206d6f64653c2f613e3c2f68313e0a71196573732e"><vh>@file installing.txt</vh></v>
</v>
<v t="ekr.20091130111843.6787"><vh>The Leo Tutorial</vh>
<v t="ekr.20100805165051.7146"><vh>@file intro.txt</vh></v>
<v t="ekr.20100808120531.4280"><vh>@file outline-commands.txt</vh></v>
<v t="ekr.20100808120531.4283"><vh>@file nutshell.txt</vh></v>
</v>
<v t="EKR.20040524104904.26"><vh>Using Outlines</vh>
<v t="ekr.20100805165051.7153"><vh>@file outlines.txt</vh></v>
</v>
<v t="EKR.20040524104904.99"><vh>Using Leo's Commands</vh>
<v t="ekr.20100805165051.7155"><vh>@file commands.txt</vh></v>
</v>
<v t="EKR.20040524104904.211"><vh>Customizing Leo</vh>
<v t="ekr.20100805165051.7158"><vh>@file customizing.txt</vh></v>
</v>
</v>
<v t="ekr.20101025080245.5799"><vh>Intermediate Topics</vh>
<v t="ekr.20060430221745"><vh>Controlling syntax coloring</vh>
<v t="ekr.20100805165051.7165"><vh>@file coloring.txt</vh></v>
</v>
<v t="ekr.20050831184021.1"><vh>Creating documents with Leo</vh>
<v t="ekr.20100805165051.7164"><vh>@file rstplugin3.txt</vh></v>
</v>
<v t="ekr.20050831195331.4"><vh>Scripting Leo with Python</vh>
<v t="ekr.20100805165051.7157" descendentVnodeUnknownAttributes="7d7100285808000000302e302e332e313671017d710258120000007273745f687474705f61747472696275746571035d71042858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333722206e616d653d22687474702d6e6f64652d6d61726b65722d3337223e710558040000003c2f613e71065d71072858260000003c64697620636c6173733d2273656374696f6e222069643d22672d726566696e64616c6c223e710858060000003c2f6469763e71095d710a28584f0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e710b58060000003c2f6469763e710c5d710d28583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710e58060000003c2f6469763e710f5d71102858060000003c626f64793e711158070000003c2f626f64793e71125d71132858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711458070000003c2f68746d6c3e71154e656565656558070000003c2f6469763e0a711658070000003c2f6469763e0a711758350000003c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e0a7118586c0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313922206e616d653d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e52756e6e696e67204c656f20696e206261746368206d6f64653c2f613e3c2f68313e0a711965735807000000302e302e332e30711a7d711b58120000007273745f687474705f617474726962757465711c5d711d2858440000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3722206e616d653d22687474702d6e6f64652d6d61726b65722d37223e711e58040000003c2f613e711f5d71202858350000003c64697620636c6173733d2273656374696f6e222069643d22672d65732d77726974652d746f2d7468652d6c6f672d70616e65223e712158060000003c2f6469763e71225d712328583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e712458060000003c2f6469763e71255d71262858060000003c626f64793e712758070000003c2f626f64793e71285d71292858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e712a58070000003c2f68746d6c3e712b4e6565656558070000003c2f6469763e0a712c58460000003c64697620636c6173733d2273656374696f6e222069643d226170702d77696e646f776c6973742d7468652d6c6973742d6f662d616c6c2d6f70656e2d6672616d6573223e0a712d588e0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643422206e616d653d226170702d77696e646f776c6973742d7468652d6c6973742d6f662d616c6c2d6f70656e2d6672616d6573223e6170702e77696e646f774c6973743a20746865206c697374206f6620616c6c206f70656e206672616d65733c2f613e3c2f68313e0a712e65735807000000302e302e332e37712f7d713058120000007273745f687474705f61747472696275746571315d71322858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323922206e616d653d22687474702d6e6f64652d6d61726b65722d3239223e713358040000003c2f613e71345d71352858390000003c64697620636c6173733d2273656374696f6e222069643d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e713658060000003c2f6469763e71375d713828583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e713958060000003c2f6469763e713a5d713b2858060000003c626f64793e713c58070000003c2f626f64793e713d5d713e2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e713f58070000003c2f68746d6c3e71404e6565656558070000003c2f6469763e0a7141583b0000003c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d707265666572656e636573223e0a714258780000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313522206e616d653d2267657474696e672d616e642d73657474696e672d707265666572656e636573223e47657474696e6720616e642073657474696e6720707265666572656e6365733c2f613e3c2f68313e0a714365735807000000302e302e332e3571447d714558120000007273745f687474705f61747472696275746571465d71472858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323722206e616d653d22687474702d6e6f64652d6d61726b65722d3237223e714858040000003c2f613e71495d714a28582e0000003c64697620636c6173733d2273656374696f6e222069643d227570646174696e672d7468652d73637265656e223e714b58060000003c2f6469763e714c5d714d28583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e714e58060000003c2f6469763e714f5d71502858060000003c626f64793e715158070000003c2f626f64793e71525d71532858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e715458070000003c2f68746d6c3e71554e6565656558070000003c2f6469763e0a7156583a0000003c64697620636c6173733d2273656374696f6e222069643d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e0a715758760000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313422206e616d653d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e496e766f6b696e6720636f6d6d616e64732066726f6d20736372697074733c2f613e3c2f68313e0a715865735809000000302e302e312e362e3471597d715a58120000007273745f687474705f617474726962757465715b5d715c2858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323122206e616d653d22687474702d6e6f64652d6d61726b65722d3231223e715d58040000003c2f613e715e5d715f2858480000003c64697620636c6173733d2273656374696f6e222069643d22702d7369626c696e67732d697465722d616e642d702d666f6c6c6f77696e672d7369626c696e67732d69746572223e716058060000003c2f6469763e71615d716228582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e716358060000003c2f6469763e71645d716528583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e716658060000003c2f6469763e71675d71682858060000003c626f64793e716958070000003c2f626f64793e716a5d716b2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e716c58070000003c2f68746d6c3e716d4e656565656558070000003c2f6469763e0a716e58460000003c64697620636c6173733d2273656374696f6e222069643d22702d737562747265652d697465722d616e642d702d73656c662d616e642d737562747265652d69746572223e0a716f588e0000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313122206e616d653d22702d737562747265652d697465722d616e642d702d73656c662d616e642d737562747265652d69746572223e702e737562747265655f6974657220616e6420702e73656c665f616e645f737562747265655f697465723c2f613e3c2f68323e0a717065735809000000302e302e312e362e3271717d717258120000007273745f687474705f61747472696275746571735d71742858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313722206e616d653d22687474702d6e6f64652d6d61726b65722d3137223e717558040000003c2f613e71765d717728582a0000003c64697620636c6173733d2273656374696f6e222069643d22702d6368696c6472656e2d69746572223e717858060000003c2f6469763e71795d717a28582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e717b58060000003c2f6469763e717c5d717d28583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e717e58060000003c2f6469763e717f5d71802858060000003c626f64793e718158070000003c2f626f64793e71825d71832858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e718458070000003c2f68746d6c3e71854e656565656558070000003c2f6469763e0a718658460000003c64697620636c6173733d2273656374696f6e222069643d22702d706172656e74732d697465722d616e642d702d73656c662d616e642d706172656e74732d69746572223e0a7187588d0000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643922206e616d653d22702d706172656e74732d697465722d616e642d702d73656c662d616e642d706172656e74732d69746572223e702e706172656e74735f6974657220616e6420702e73656c665f616e645f706172656e74735f697465723c2f613e3c2f68323e0a718865735809000000302e302e312e362e3371897d718a58120000007273745f687474705f617474726962757465718b5d718c2858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313922206e616d653d22687474702d6e6f64652d6d61726b65722d3139223e718d58040000003c2f613e718e5d718f2858450000003c64697620636c6173733d2273656374696f6e222069643d22702d706172656e74732d697465722d616e642d702d73656c662d616e642d706172656e74732d69746572223e719058060000003c2f6469763e71915d719228582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e719358060000003c2f6469763e71945d719528583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e719658060000003c2f6469763e71975d71982858060000003c626f64793e719958070000003c2f626f64793e719a5d719b2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e719c58070000003c2f68746d6c3e719d4e656565656558070000003c2f6469763e0a719e58490000003c64697620636c6173733d2273656374696f6e222069643d22702d7369626c696e67732d697465722d616e642d702d666f6c6c6f77696e672d7369626c696e67732d69746572223e0a719f58940000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313022206e616d653d22702d7369626c696e67732d697465722d616e642d702d666f6c6c6f77696e672d7369626c696e67732d69746572223e702e7369626c696e67735f6974657220616e6420702e666f6c6c6f77696e675f7369626c696e67735f697465723c2f613e3c2f68323e0a71a065735809000000302e302e312e362e3071a17d71a258120000007273745f687474705f61747472696275746571a35d71a42858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313322206e616d653d22687474702d6e6f64652d6d61726b65722d3133223e71a558040000003c2f613e71a65d71a728582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e71a858060000003c2f6469763e71a95d71aa28583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e71ab58060000003c2f6469763e71ac5d71ad2858060000003c626f64793e71ae58070000003c2f626f64793e71af5d71b02858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e71b158070000003c2f68746d6c3e71b24e65656565582b0000003c64697620636c6173733d2273656374696f6e222069643d22632d616c6c6e6f6465732d69746572223e0a71b358570000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643722206e616d653d22632d616c6c6e6f6465732d69746572223e632e616c6c4e6f6465735f697465723c2f613e3c2f68323e0a71b465735809000000302e302e312e362e3171b57d71b658120000007273745f687474705f61747472696275746571b75d71b82858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313522206e616d653d22687474702d6e6f64652d6d61726b65722d3135223e71b958040000003c2f613e71ba5d71bb28582a0000003c64697620636c6173733d2273656374696f6e222069643d22632d616c6c6e6f6465732d69746572223e71bc58060000003c2f6469763e71bd5d71be28582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e71bf58060000003c2f6469763e71c05d71c128583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e71c258060000003c2f6469763e71c35d71c42858060000003c626f64793e71c558070000003c2f626f64793e71c65d71c72858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e71c858070000003c2f68746d6c3e71c94e656565656558070000003c2f6469763e0a71ca582b0000003c64697620636c6173733d2273656374696f6e222069643d22702d6368696c6472656e2d69746572223e0a71cb58570000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643822206e616d653d22702d6368696c6472656e2d69746572223e702e6368696c6472656e5f697465723c2f613e3c2f68323e0a71cc65735807000000302e302e312e3171cd7d71ce58120000007273745f687474705f61747472696275746571cf5d71d02858440000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3122206e616d653d22687474702d6e6f64652d6d61726b65722d31223e71d158040000003c2f613e71d25d71d328583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e71d458060000003c2f6469763e71d55d71d62858060000003c626f64793e71d758070000003c2f626f64793e71d85d71d92858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e71da58070000003c2f68746d6c3e71db4e65656558240000003c64697620636c6173733d2273656374696f6e222069643d226f76657276696577223e0a71dc58490000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643122206e616d653d226f76657276696577223e4f766572766965773c2f613e3c2f68313e0a71dd65735807000000302e302e312e3271de7d71df58120000007273745f687474705f61747472696275746571e05d71e12858440000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3522206e616d653d22687474702d6e6f64652d6d61726b65722d35223e71e258040000003c2f613e71e35d71e42858400000003c64697620636c6173733d2273656374696f6e222069643d22672d746f702d7468652d636f6d6d616e6465722d6f662d7468652d746f702d77696e646f77223e71e558060000003c2f6469763e71e65d71e728583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e71e858060000003c2f6469763e71e95d71ea2858060000003c626f64793e71eb58070000003c2f626f64793e71ec5d71ed2858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e71ee58070000003c2f68746d6c3e71ef4e6565656558070000003c2f6469763e0a71f058360000003c64697620636c6173733d2273656374696f6e222069643d22672d65732d77726974652d746f2d7468652d6c6f672d70616e65223e0a71f158700000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643322206e616d653d22672d65732d77726974652d746f2d7468652d6c6f672d70616e65223e672e657328293a20777269746520746f20746865206c6f672070616e653c2f613e3c2f68313e0a71f265735807000000302e302e312e3371f37d71f458120000007273745f687474705f61747472696275746571f55d71f62858440000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3922206e616d653d22687474702d6e6f64652d6d61726b65722d39223e71f758040000003c2f613e71f85d71f92858450000003c64697620636c6173733d2273656374696f6e222069643d226170702d77696e646f776c6973742d7468652d6c6973742d6f662d616c6c2d6f70656e2d6672616d6573223e71fa58060000003c2f6469763e71fb5d71fc28583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e71fd58060000003c2f6469763e71fe5d71ff2858060000003c626f64793e720001000058070000003c2f626f64793e72010100005d72020100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e720301000058070000003c2f68746d6c3e72040100004e6565656558070000003c2f6469763e0a720501000058460000003c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d686561646c696e652d616e642d626f64792d74657874223e0a7206010000588d0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643522206e616d653d2267657474696e672d616e642d73657474696e672d686561646c696e652d616e642d626f64792d74657874223e47657474696e6720616e642073657474696e6720686561646c696e6520616e6420626f647920746578743c2f613e3c2f68313e0a720701000065735807000000302e302e312e3472080100007d720901000058120000007273745f687474705f617474726962757465720a0100005d720b0100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323522206e616d653d22687474702d6e6f64652d6d61726b65722d3235223e720c01000058040000003c2f613e720d0100005d720e01000028583e0000003c64697620636c6173733d2273656374696f6e222069643d2274657374696e672d776865746865722d612d706f736974696f6e2d69732d76616c6964223e720f01000058060000003c2f6469763e72100100005d721101000028582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e721201000058060000003c2f6469763e72130100005d721401000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e721501000058060000003c2f6469763e72160100005d72170100002858060000003c626f64793e721801000058070000003c2f626f64793e72190100005d721a0100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e721b01000058070000003c2f68746d6c3e721c0100004e656565656558070000003c2f6469763e0a721d01000058070000003c2f6469763e0a721e010000582f0000003c64697620636c6173733d2273656374696f6e222069643d227570646174696e672d7468652d73637265656e223e0a721f01000058600000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313322206e616d653d227570646174696e672d7468652d73637265656e223e5570646174696e67207468652073637265656e3c2f613e3c2f68313e0a722001000065735807000000302e302e312e3672210100007d722201000058120000007273745f687474705f61747472696275746572230100005d72240100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313122206e616d653d22687474702d6e6f64652d6d61726b65722d3131223e722501000058040000003c2f613e72260100005d72270100002858450000003c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d686561646c696e652d616e642d626f64792d74657874223e722801000058060000003c2f6469763e72290100005d722a01000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e722b01000058060000003c2f6469763e722c0100005d722d0100002858060000003c626f64793e722e01000058070000003c2f626f64793e722f0100005d72300100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e723101000058070000003c2f68746d6c3e72320100004e6565656558070000003c2f6469763e0a7233010000582f0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e0a7234010000585f0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643622206e616d653d2274726176657273696e672d6f75746c696e6573223e54726176657273696e67206f75746c696e65733c2f613e3c2f68313e0a723501000065735807000000302e302e312e3772360100007d723701000058120000007273745f687474705f61747472696275746572380100005d72390100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323322206e616d653d22687474702d6e6f64652d6d61726b65722d3233223e723a01000058040000003c2f613e723b0100005d723c0100002858450000003c64697620636c6173733d2273656374696f6e222069643d22702d737562747265652d697465722d616e642d702d73656c662d616e642d737562747265652d69746572223e723d01000058060000003c2f6469763e723e0100005d723f01000028582e0000003c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e724001000058060000003c2f6469763e72410100005d724201000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e724301000058060000003c2f6469763e72440100005d72450100002858060000003c626f64793e724601000058070000003c2f626f64793e72470100005d72480100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e724901000058070000003c2f68746d6c3e724a0100004e656565656558070000003c2f6469763e0a724b010000583f0000003c64697620636c6173733d2273656374696f6e222069643d2274657374696e672d776865746865722d612d706f736974696f6e2d69732d76616c6964223e0a724c01000058800000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313222206e616d653d2274657374696e672d776865746865722d612d706f736974696f6e2d69732d76616c6964223e54657374696e672077686574686572206120706f736974696f6e2069732076616c69643c2f613e3c2f68323e0a724d01000065735807000000302e302e332e38724e0100007d724f01000058120000007273745f687474705f61747472696275746572500100005d72510100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333922206e616d653d22687474702d6e6f64652d6d61726b65722d3339223e725201000058040000003c2f613e72530100005d72540100002858340000003c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e725501000058060000003c2f6469763e72560100005d725701000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e725801000058060000003c2f6469763e72590100005d725a0100002858060000003c626f64793e725b01000058070000003c2f626f64793e725c0100005d725d0100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e725e01000058070000003c2f68746d6c3e725f0100004e6565656558070000003c2f6469763e0a7260010000583e0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e0a7261010000587e0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323022206e616d653d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e46756e6374696f6e7320646566696e656420696e206c656f476c6f62616c732e70793c2f613e3c2f68313e0a726201000065735808000000302e302e312e313172630100007d726401000058120000007273745f687474705f61747472696275746572650100005d72660100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343322206e616d653d22687474702d6e6f64652d6d61726b65722d3433223e726701000058040000003c2f613e72680100005d726901000028583a0000003c64697620636c6173733d2273656374696f6e222069643d227265646972656374696e672d6f75747075742d66726f6d2d73637269707473223e726a01000058060000003c2f6469763e726b0100005d726c01000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e726d01000058060000003c2f6469763e726e0100005d726f0100002858060000003c626f64793e727001000058070000003c2f626f64793e72710100005d72720100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e727301000058070000003c2f68746d6c3e72740100004e6565656558070000003c2f6469763e0a727501000058450000003c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e0a7276010000588c0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323222206e616d653d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e53756d6d617279206f662074686520766e6f646520616e6420706f736974696f6e20636c61737365733c2f613e3c2f68313e0a727701000065735808000000302e302e332e313072780100007d727901000058120000007273745f687474705f617474726962757465727a0100005d727b0100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343122206e616d653d22687474702d6e6f64652d6d61726b65722d3431223e727c01000058040000003c2f613e727d0100005d727e01000028583d0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e727f01000058060000003c2f6469763e72800100005d728101000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e728201000058060000003c2f6469763e72830100005d72840100002858060000003c626f64793e728501000058070000003c2f626f64793e72860100005d72870100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e728801000058070000003c2f68746d6c3e72890100004e6565656558070000003c2f6469763e0a728a010000583b0000003c64697620636c6173733d2273656374696f6e222069643d227265646972656374696e672d6f75747075742d66726f6d2d73637269707473223e0a728b01000058780000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323122206e616d653d227265646972656374696e672d6f75747075742d66726f6d2d73637269707473223e5265646972656374696e67206f75747075742066726f6d20736372697074733c2f613e3c2f68313e0a728c0100006573580a000000302e302e312e31312e32728d0100007d728e01000058120000007273745f687474705f617474726962757465728f0100005d72900100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343922206e616d653d22687474702d6e6f64652d6d61726b65722d3439223e729101000058040000003c2f613e72920100005d72930100002858220000003c64697620636c6173733d2273656374696f6e222069643d2267657474657273223e729401000058060000003c2f6469763e72950100005d72960100002858440000003c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e729701000058060000003c2f6469763e72980100005d729901000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e729a01000058060000003c2f6469763e729b0100005d729c0100002858060000003c626f64793e729d01000058070000003c2f626f64793e729e0100005d729f0100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e72a001000058070000003c2f68746d6c3e72a10100004e656565656558070000003c2f6469763e0a72a201000058230000003c64697620636c6173733d2273656374696f6e222069643d2273657474657273223e0a72a301000058480000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323522206e616d653d2273657474657273223e536574746572733c2f613e3c2f68323e0a72a40100006573580a000000302e302e312e31312e3172a50100007d72a601000058120000007273745f687474705f61747472696275746572a70100005d72a80100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343722206e616d653d22687474702d6e6f64652d6d61726b65722d3437223e72a901000058040000003c2f613e72aa0100005d72ab0100002858240000003c64697620636c6173733d2273656374696f6e222069643d226974657261746f7273223e72ac01000058060000003c2f6469763e72ad0100005d72ae0100002858440000003c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e72af01000058060000003c2f6469763e72b00100005d72b101000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e72b201000058060000003c2f6469763e72b30100005d72b40100002858060000003c626f64793e72b501000058070000003c2f626f64793e72b60100005d72b70100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e72b801000058070000003c2f68746d6c3e72b90100004e656565656558070000003c2f6469763e0a72ba01000058230000003c64697620636c6173733d2273656374696f6e222069643d2267657474657273223e0a72bb01000058480000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323422206e616d653d2267657474657273223e476574746572733c2f613e3c2f68323e0a72bc0100006573580a000000302e302e312e31312e3072bd0100007d72be01000058120000007273745f687474705f61747472696275746572bf0100005d72c00100002858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343522206e616d653d22687474702d6e6f64652d6d61726b65722d3435223e72c101000058040000003c2f613e72c20100005d72c30100002858440000003c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e72c401000058060000003c2f6469763e72c50100005d72c601000028583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e72c701000058060000003c2f6469763e72c80100005d72c90100002858060000003c626f64793e72ca01000058070000003c2f626f64793e72cb0100005d72cc0100002858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e72cd01000058070000003c2f68746d6c3e72ce0100004e6565656558250000003c64697620636c6173733d2273656374696f6e222069643d226974657261746f7273223e0a72cf010000584c0000003c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323322206e616d653d226974657261746f7273223e4974657261746f72733c2f613e3c2f68323e0a72d00100006573752e"><vh>@file scripting.txt</vh></v>
</v>
<v t="ekr.20050912125144"><vh>Plugins</vh>
<v t="ekr.20100805165051.7162"><vh>@file plugins.txt</vh></v>
</v>
<v t="ekr.20060612102055"><vh>Writing Plugins</vh>
<v t="ekr.20100805165051.7163"><vh>@file writingPlugins.txt</vh></v>
</v>
<v t="ekr.20070628083442"><vh>Unit testing with Leo</vh>
<v t="ekr.20100805165051.7170"><vh>@file unitTesting.txt</vh></v>
</v>
<v t="ekr.20060527105211"><vh>Debugging with Leo</vh>
<v t="ekr.20100805165051.7166"><vh>@file debuggers.txt</vh></v>
</v>
<v t="ekr.20080730212711.14"><vh>Using @shadow</vh>
<v t="ekr.20100805165051.7173"><vh>@file atShadow.txt</vh></v>
</v>
</v>
<v t="ekr.20101025080245.5798"><vh>Leo and Other Programs</vh>
<v t="ekr.20061025065357"><vh>Leo and Emacs</vh>
<v t="ekr.20100805165051.7168"><vh>@file emacs.txt</vh></v>
</v>
<v t="ekr.20080203101507"><vh>ILeo - the IPython bridge</vh>
<v t="ekr.20100805165051.7171"><vh>@file IpythonBridge.txt</vh></v>
</v>
<v t="ekr.20070317033759"><vh>Embedding Leo with the leoBridge module</vh>
<v t="ekr.20100805165051.7169"><vh>@file leoBridge.txt</vh></v>
</v>
<v t="TL.20080804095315.1"><vh>Using Vim with Leo</vh>
<v t="ekr.20100805165051.7172"><vh>@file vimBindings.txt</vh></v>
</v>
<v t="ekr.20060913164304"><vh>Using ZODB with Leo</vh>
<v t="ekr.20100805165051.7167"><vh>@file zodb.txt</vh></v>
</v>
</v>
<v t="ekr.20101025080245.5796"><vh>Reference</vh>
<v t="ekr.20050831184021.5"><vh>Leo's Reference</vh>
<v t="ekr.20100805001344.7253"><vh>@file directives.txt</vh></v>
</v>
<v t="EKR.20040524104904.161"><vh>Designing with Leo</vh>
<v t="ekr.20100805165051.7156"><vh>@file design.txt</vh></v>
</v>
<v t="EKR.20040524104904.245"><vh>History of Leo</vh>
<v t="ekr.20100805165051.7159"><vh>@file history.txt</vh></v>
</v>
<v t="EKR.20040524104904.261"><vh>Theory of Operation</vh>
<v t="ekr.20100805165051.7160"><vh>@file theory.txt</vh></v>
</v>
<v t="ekr.20050901084134"><vh>White papers</vh>
<v t="ekr.20100805165051.7161"><vh>@file whitepapers.txt</vh></v>
</v>
<v t="EKR.20040524104904.274"><vh>Appendices</vh>
<v t="ekr.20100805165051.7174"><vh>@file appendices.txt</vh></v>
</v>
<v t="ekr.20091111112709.6671"><vh>Glossary</vh>
<v t="ekr.20100805165051.7147"><vh>@file glossary.txt</vh></v>
</v>
</v>
<v t="ekr.20060620094033"><vh>What's New...</vh>
<v t="ekr.20100805165051.7175"><vh>@file whatsnew.txt</vh></v>
</v>
<v t="ekr.20111127144911.5545"><vh>Other pages</vh>
<v t="ekr.20111127144911.5546"><vh>@file download.txt</vh></v>
</v>
</v>
<v t="ekr.20090717084250.10702"><vh>Other docs</vh>
<v t="ekr.20100805165051.7176"><vh>@file other_docs.txt</vh></v>
</v>
<v t="ekr.20100821182153.4341"><vh>Slideshows</vh>
<v t="ekr.20101028110015.8271" descendentVnodeUnknownAttributes="7d710028580b000000302e312e312e382e342e3171017d7102580b0000007374725f6c656f5f706f7371035800000000710473580b000000302e312e312e382e332e3171057d7106580b0000007374725f6c656f5f706f737107680473580b000000302e312e312e382e352e3171087d7109580b0000007374725f6c656f5f706f73710a680473580b000000302e312e312e382e322e31710b7d710c580b0000007374725f6c656f5f706f73710d680473752e"><vh>@file slideshows.txt</vh></v>
</v>
<v t="ekr.20101026082911.5536"><vh>Release notes</vh>
<v t="ekr.20100805165051.7177"><vh>@file release_notes.txt</vh></v>
</v>
<v t="ekr.20120229094652.14053"><vh>Leo 4.10 Release notes</vh>
<v t="ekr.20120229094652.14757"><vh>Bugs</vh>
<v t="ekr.20120229094652.14758"><vh>Fixed ancient hanger in paste-retaining-clones</vh></v>
<v t="ekr.20120229094652.14759"><vh>Fixed bug in p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20120229094652.14760"><vh>Removed timer hack from double-click code</vh></v>
<v t="ekr.20120229094652.14761"><vh>Fixed double-click problem</vh></v>
<v t="ekr.20120229094652.14762"><vh>Fixed url focus issues</vh></v>
<v t="ekr.20120229094652.14763"><vh>Fixed p1 &gt; p2</vh></v>
<v t="ekr.20120229094652.14764"><vh>Fixed cacher problem</vh></v>
<v t="ekr.20120229094652.14765"><vh>Fixed encoding problem with @shadow</vh></v>
<v t="ekr.20120229094652.14766"><vh>Fixed a w.see botch.</vh></v>
<v t="ekr.20120229094652.14767"><vh>Fixed a major DnD bug</vh></v>
<v t="ekr.20120229094652.14768"><vh>Fixed macro crash</vh></v>
<v t="ekr.20120229094652.14769"><vh>Regularized slashes in @edit/@file</vh></v>
<v t="ekr.20120229094652.14770"><vh>Made sure Leo's write code auto-detects file extension</vh></v>
<v t="ekr.20120229094652.14771"><vh>Fixed k.setLabelRed</vh></v>
<v t="ekr.20120229094652.14772"><vh>Fixed cycle-editor-focus bug</vh></v>
<v t="ekr.20120229094652.14774"><vh>Fixed recent createFrame crash</vh></v>
<v t="ekr.20120229094652.14775"><vh>Fixed Py3k crash in quicksearch.py</vh></v>
<v t="ekr.20120229094652.14776"><vh>Removed all references to scrolledmessage plugin</vh></v>
<v t="ekr.20120229094652.14777"><vh>Support @ignore when installing @command/@button nodes</vh></v>
<v t="ekr.20120229094652.14778"><vh>Fixed crasher in runScrolledMessageDialog</vh></v>
<v t="ekr.20120229094652.14779"><vh>Macro expansion now forces a full recolor</vh></v>
<v t="ekr.20120229094652.14780"><vh>Fixed serious atFile read bug</vh></v>
<v t="ekr.20120229094652.14781"><vh>Fixed unicode bugs with @shadow</vh></v>
<v t="ekr.20120229094652.14782"><vh>Recompute width of hard tabs depending on @tabwidth</vh></v>
<v t="ekr.20120229094652.14783"><vh>Applied patch for Bug 800311: Undo: Word granularity should recognize cursor movements</vh></v>
<v t="ekr.20120229094652.14784"><vh>Applied patch for Bug 800312: Collapsing node moves should be optional</vh></v>
<v t="ekr.20120229094652.14785"><vh>Fixed Bug 880975: Binding Meta and print-bindings</vh></v>
<v t="ekr.20120229094652.14786"><vh>Fixed bug 823601: cascade-windows fails</vh></v>
<v t="ekr.20120229094652.14787"><vh>Generalized stylesheet handling</vh>
<v t="ekr.20120229094652.14788"><vh>Notes</vh></v>
</v>
<v t="ekr.20120229094652.14789"><vh>Scrolling bug</vh>
<v t="ekr.20120229094652.14975"><vh>Notes</vh></v>
<v t="ekr.20120229094652.14976"><vh>First attempt</vh></v>
<v t="ekr.20120229094652.14792"><vh>Second attempt</vh></v>
</v>
<v t="ekr.20120229094652.14817"><vh>Fixed html colorizing by fixing a bad bug in g.importFromPath</vh></v>
<v t="ekr.20120229094652.14818"><vh>Allow lower case keywords in colorizer</vh></v>
<v t="ekr.20120229094652.14819"><vh>Fixed recent problem in createMenuEntries</vh></v>
<v t="ekr.20120229094652.14820"><vh>Fixed rst3 pdf problem</vh></v>
<v t="ekr.20120229094652.14821"><vh>Added unit test that all plugins have an init method</vh></v>
<v t="ekr.20120229094652.14822"><vh>Removed traceback when cancelling a write</vh></v>
<v t="ekr.20120229094652.14823"><vh>Fixed removeBlankLinesTokens</vh></v>
<v t="ekr.20120229094652.14824"><vh>Fixed crasher in config.set</vh></v>
<v t="ekr.20120229094652.14825"><vh>Fixed resize-to-screen and minimize-all</vh></v>
<v t="ekr.20120229094652.14826"><vh>Fixed html import problems</vh></v>
<v t="ekr.20120229094652.14827"><vh>Removed extra newlines in g.trace</vh></v>
<v t="ekr.20120229094652.14828"><vh>Fixed crash in compareTokens</vh></v>
<v t="ekr.20120229094652.14829"><vh>Finished import work</vh></v>
<v t="ekr.20120229094652.14831"><vh>Fixed hard crash when deleting body editor 3 times</vh></v>
<v t="ekr.20120229094652.14832"><vh>Fixed add/delete html comments</vh></v>
<v t="ekr.20120229094652.14833"><vh>Fixed bug that prevented text bindings from working in log tabs</vh></v>
<v t="ekr.20120229094652.14834"><vh>Fixed cycle-all-focus command</vh></v>
<v t="ekr.20120229094652.14835"><vh>Fixed crashers involving calls to w.setSelectionRange</vh></v>
<v t="ekr.20120229094652.14836"><vh>Fixed hang in cycleAllFocus</vh></v>
<v t="ekr.20120229094652.14837"><vh>Fixed crasher in k.handleDefaultChar</vh></v>
<v t="ekr.20120229094652.14838"><vh>Fixed bug: Focus lost after opening or closing tab</vh></v>
<v t="ekr.20120229094652.14839"><vh>Ignore unbound Alt/Ctrl keys, especially Alt/Ctrl-N</vh></v>
<v t="ekr.20120229094652.14840"><vh>Fixed bug: ensure global @buttons work</vh></v>
<v t="ekr.20120229094652.14841"><vh>Fixed bug in p.moveToFirstChild</vh></v>
<v t="ekr.20120229094652.14842"><vh>Fixed bug 804960: Refreshing unlinks clones, just reopening connects them again</vh></v>
<v t="ekr.20120229094652.14848"><vh>Fixed crasher in reportMismatch</vh></v>
<v t="ekr.20120229094652.14849"><vh>Disabled section-reference handling in @auto files</vh></v>
<v t="ekr.20120229094652.14850"><vh>Fix bug: Allow @all only in top-level @&lt;file&gt; nodes (test2.leo)</vh></v>
<v t="ekr.20120229094652.14855"><vh>Fixed erroneous "file changed" message</vh></v>
<v t="ekr.20120229094652.14856"><vh>Fixed bug 889175: Changing @auto paths overwrites files without warning</vh></v>
<v t="ekr.20120229094652.14891"><vh>Fixed bug in DynamicWindow.setGeometry</vh></v>
<v t="ekr.20120229094652.14892"><vh>Fixed bug 87933: Redefining a key binding breaks menu items with same binding</vh>
<v t="ekr.20120229094652.14893"><vh> Report</vh></v>
<v t="ekr.20120229094652.14894"><vh>Bug 815564: Plugin Menu-Keystroke binding can prevent plugin help display</vh></v>
<v t="ekr.20120229094652.14925"><vh>Updating dependent dicts</vh></v>
</v>
<v t="ekr.20120229094652.14934"><vh>Fixed bug: @button @key=x does not override x</vh></v>
<v t="ekr.20120229094652.14941"><vh>Fixed Bug: @mark-for-unit-tests nodes</vh></v>
<v t="ekr.20120229094652.14942"><vh>The clean,clear&amp; sort recent files commands now work</vh></v>
<v t="ekr.20120229094652.14973"><vh>Fixed the wretched scrolling bug</vh></v>
<v t="ekr.20120229094652.15012"><vh>Fixed bug: @int pagewidth now set c.page_width</vh></v>
<v t="ekr.20120229094652.15013"><vh>Fixed bug: goto end line handler is broken</vh></v>
<v t="ekr.20120229094652.14520"><vh>Removed unused color tags</vh></v>
<v t="ekr.20120229094652.15147"><vh>Fixed bug: End only goes to physical line</vh></v>
<v t="ekr.20120229094652.15146"><vh>rev 4952 fixes bug 87933 with major key reorg</vh></v>
<v t="ekr.20120313074006.14648"><vh>Fixed Bug 930726:expandNodeAndGoToFirstChild only expands or only goes to first child</vh></v>
<v t="ekr.20120313074006.14650"><vh>Fixed Bug 869429 (undo &amp; redo when deleting nodes from contextmenu)</vh></v>
<v t="ekr.20120313074006.14655"><vh>vim and xemacs plugins now work smoothly with contextmenu plugin.</vh></v>
<v t="ekr.20120313074006.14657"><vh>Fixed bug 823267:when a tab is closed focus may go to a tab other than the visible one</vh></v>
<v t="ekr.20120313074006.14663"><vh>Fixed bug 917814: Switching Log Pane tabs is done incompletely</vh></v>
<v t="ekr.20120313074006.14697"><vh>Fixed bug 924123: Some SyntaxError's thrown when compiling the whole source with Python 3</vh></v>
<v t="ekr.20120313074006.14698"><vh>Tried, and failed, to fix bug 844953: copy-clone-pasted node appears in other tab</vh></v>
<v t="ekr.20120313074006.14702"><vh>Fixed bug 501636: Leo's import code should support non-ascii xml tags</vh></v>
<v t="ekr.20120313074006.14713"><vh>Fixed bug 799695: colorizer bug after move-lines-up into a docstring</vh></v>
<v t="ekr.20120313074006.14714"><vh>Fixed bug 824087: Alt+F4 is not the same as Alt+F, c</vh></v>
<v t="ekr.20120313074006.14715"><vh>Fixed bug 923301: Unicode error when executing 'rst3' command</vh></v>
<v t="ekr.20120313074006.14722"><vh>Fixed bug 893230: URL coloring does not work for many Internet protocols</vh></v>
<v t="ekr.20120313074006.14725"><vh>Fixed bug 944551: @url URL Open Hangs Leo...</vh></v>
<v t="ekr.20120313074006.14738"><vh>Fixed g.os_startfile on Linux</vh></v>
<v t="ekr.20120313074006.14740"><vh>Fixed bug 875323: Hoist an @chapter node leaves a non-visible node selected</vh></v>
<v t="ekr.20120313074006.14765"><vh>Fixed bug 831658: @url doesn't leave Chapter</vh></v>
<v t="ekr.20120313074006.14771"><vh>Fixed bug 875327: Positioning outside of hoisted outline" usually causes problems</vh></v>
<v t="ekr.20120313074006.14772"><vh>Fixed bug 807561: dragging a binary to Leo should create @url, not @edit</vh></v>
<v t="ekr.20120313074006.14800"><vh>Fixed Bug: multiple @language directive not colored correctly</vh></v>
<v t="ekr.20120313074006.14906"><vh>Fixed Bug: multiple @language directives mess up add-comments command</vh></v>
<v t="ekr.20120313074006.14916"><vh>Fixed second bug re bug #875327: Positioning outside of hoisted outline usually causes problems</vh></v>
<v t="ekr.20120313074006.15120"><vh>Fixed bug 952365: Leo-Editor can't write a file created from the command line</vh></v>
<v t="ekr.20120313074006.15125"><vh>Fixed bug 951921: Opening myLeoSettings.leo can clutter the console unworthwhile messages</vh></v>
<v t="ekr.20120313074006.15135"><vh>Fixed bug 951739: xdg-open of a file-scheme URL containing blanks</vh></v>
<v t="ekr.20120313074006.15138"><vh>Fixed bug 951721: @url with URL in headline</vh></v>
<v t="ekr.20120313074006.15144"><vh>Fixed bug 944555: Ctrl-left-click URL handling not as sophisticated as @url URL handling</vh></v>
<v t="ekr.20120313074006.15151"><vh>Improved g.handleUrl and eliminated g.handleUrlInUrlNode</vh></v>
</v>
<v t="ekr.20120229094652.14518"><vh>Code improvements</vh>
<v t="ekr.20120229094652.15175"><vh>Major</vh>
<v t="ekr.20120229094652.15142"><vh>Leo's new classes</vh></v>
</v>
<v t="ekr.20120229094652.15176"><vh>Minor</vh>
<v t="ekr.20120229094652.14522"><vh>Eliminated the low-level interface</vh></v>
<v t="ekr.20120229094652.14523"><vh>Removed unused cruft from high-level interface</vh></v>
<v t="ekr.20120229094652.14524"><vh>All unit tests may now be run externally</vh></v>
<v t="ekr.20120229094652.14525"><vh>Unified the high-level interface</vh></v>
<v t="ekr.20120229094652.14526"><vh>Create properties for logCtrl &amp; bodyCtrl</vh></v>
<v t="ekr.20120229094652.14527"><vh>Added eventFilters to top-level frames</vh></v>
<v t="ekr.20120229094652.14528"><vh>added log.orderedTabNames</vh></v>
<v t="ekr.20120229094652.14531"><vh>Removed many module-level imports</vh></v>
<v t="ekr.20120229094652.14532"><vh>Created the TestManager class</vh></v>
<v t="ekr.20120229094652.14533"><vh>Created the LoadManager class (docs)</vh></v>
<v t="ekr.20120229094652.14534"><vh>Removed c argument from g.app.config getters</vh></v>
<v t="ekr.20120229094652.14535"><vh>Delay "reading settings" message until after signon</vh>
<v t="ekr.20120229094652.14536"><vh>pr (codewise)</vh></v>
<v t="ekr.20120229094652.14537"><vh>g.pr</vh></v>
</v>
<v t="ekr.20120229094652.14538"><vh>Use at.readOneAtAutoNode instead of ic.readOneAtAutoNode</vh></v>
<v t="ekr.20120229094652.14578"><vh>Added p.positionAfterDeletedTree</vh></v>
<v t="ekr.20120229094652.14577"><vh>Removed Leo's old syntax coloring code</vh></v>
<v t="ekr.20120229094652.14583"><vh>Rewrote shell-command commands</vh></v>
<v t="ekr.20120229094652.14608"><vh>Added g.app.isExternalUnitTest</vh></v>
<v t="ekr.20120229094652.14611"><vh>Added c.config.set</vh></v>
</v>
<v t="ekr.20120229094652.15157"><vh>Investigations</vh>
<v t="ekr.20120229094652.15158"><vh>Investigated unicode problems with print</vh></v>
<v t="ekr.20120229094652.15159"><vh>Investigated autocomplete popup bug</vh></v>
</v>
<v t="ekr.20120229094652.15138"><vh>version.py now uses bzr_version.py</vh></v>
<v t="ekr.20120229094652.15139"><vh>Changed calling signatures of g.openWithFileName and g.app.newCommander</vh></v>
<v t="ekr.20120229094652.19777"><vh>The open-with event now has a new format</vh></v>
<v t="ekr.20120229173025.20636"><vh>Theory of operation: key handling</vh></v>
</v>
<v t="ekr.20120229094652.15170"><vh>Commands: improved</vh>
<v t="ekr.20120229094652.14612"><vh>Alt-left-arrow collapses all children when selecting the parent</vh></v>
<v t="ekr.20120229094652.15169"><vh>Improved page-up &amp; page-down commands</vh></v>
<v t="ekr.20120229094652.14622"><vh>Improved presentation of bindings</vh></v>
<v t="ekr.20120229094652.14618"><vh>Improved print-bindings &amp; print-commands</vh></v>
<v t="ekr.20120229094652.14580"><vh>Open now shows all files</vh></v>
<v t="ekr.20120229094652.14617"><vh>Selected @test node always run</vh></v>
<v t="ekr.20120313074006.14640"><vh>Instant abbreviations (~a)</vh></v>
<v t="ekr.20120313074006.14643"><vh>Reinstated warnings for conflicting definitions</vh></v>
<v t="ekr.20120313134250.14294"><vh>Allow section references in rst3 command</vh>
<v t="ekr.20120313134250.14295"><vh>Report</vh></v>
<v t="ekr.20120313134250.14296"><vh>Entry points</vh>
<v t="ekr.20120313134250.14297"><vh>code_to_rst_command &amp; helpers</vh>
<v t="ekr.20120313134250.14298"><vh>write_code_body &amp; helpers</vh>
<v t="ekr.20120313134250.14299"><vh>split_parts</vh></v>
<v t="ekr.20120313134250.14300"><vh>write_code_block</vh></v>
</v>
<v t="ekr.20120313134250.14301"><vh>write_code_headline &amp; helper</vh>
<v t="ekr.20120313134250.14302"><vh>write_code_headline_helper</vh></v>
</v>
<v t="ekr.20120313134250.14303"><vh>write_code_node</vh></v>
<v t="ekr.20120313134250.14304"><vh>write_code_tree</vh></v>
</v>
<v t="ekr.20120313134250.14305"><vh>rst3 command &amp; helpers</vh>
<v t="ekr.20120313134250.14306"><vh>processTopTree</vh></v>
<v t="ekr.20120313134250.14307"><vh>processTree</vh></v>
<v t="ekr.20120313134250.14308"><vh>write_rst_tree</vh></v>
<v t="ekr.20120313134250.14309"><vh>write_slides &amp; helper</vh>
<v t="ekr.20120313134250.14310"><vh>writeSlideTitle</vh></v>
</v>
<v t="ekr.20120313134250.14311"><vh>write methods (rst3 command)</vh>
<v t="ekr.20120313134250.14312"><vh>getDocPart</vh>
<v t="ekr.20120313134250.14313"><vh>&lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;</vh></v>
</v>
<v t="ekr.20120313134250.14314"><vh>handleSpecialDocParts</vh></v>
<v t="ekr.20120313134250.14315"><vh>isAnyDocPart</vh></v>
<v t="ekr.20120313134250.14316"><vh>isAnySpecialDocPart</vh></v>
<v t="ekr.20120313134250.14317"><vh>isSpecialDocPart</vh></v>
<v t="ekr.20120313134250.14318"><vh>removeLeoDirectives</vh></v>
<v t="ekr.20120313134250.14319"><vh>replaceCodeBlockDirectives</vh></v>
<v t="ekr.20120313134250.14320"><vh>skip_literal_block</vh></v>
<v t="ekr.20120313134250.14356"><vh>writeBody &amp; helpers</vh>
<v t="ekr.20120313134250.14357"><vh>isSectionDef/Ref</vh></v>
<v t="ekr.20120313134250.14358"><vh>expandSectionRefs</vh></v>
<v t="ekr.20120313134250.14359"><vh>findSectionDef</vh></v>
<v t="ekr.20120313134250.14360"><vh>handleCodeMode &amp; helper</vh>
<v t="ekr.20120313134250.14361"><vh>formatCodeModeLine</vh></v>
<v t="ekr.20120313134250.14362"><vh>rstripList</vh></v>
<v t="ekr.20120313134250.14363"><vh>finishCodePart</vh></v>
</v>
<v t="ekr.20120313134250.14364"><vh>handleDocOnlyMode</vh></v>
</v>
<v t="ekr.20120313134250.14330"><vh>writeHeadline &amp; helper</vh>
<v t="ekr.20120313134250.14331"><vh>writeHeadlineHelper</vh></v>
</v>
<v t="ekr.20120313134250.14332"><vh>writeNode (leoRst)</vh></v>
<v t="ekr.20120313134250.14333"><vh>writePreformat</vh></v>
<v t="ekr.20120313134250.14334"><vh>writeTree</vh></v>
</v>
</v>
<v t="ekr.20120313134250.14335"><vh>writeNodeToString</vh></v>
<v t="ekr.20120313134250.14336"><vh>writeAtAutoFile</vh>
<v t="ekr.20120313134250.14337"><vh>initAtAutoWrite (rstCommands)</vh></v>
<v t="ekr.20120313134250.14338"><vh>isSafeWrite</vh></v>
</v>
</v>
<v t="ekr.20120313134250.14339"><vh>Options</vh>
<v t="ekr.20120313134250.14355"><vh>createDefaultOptionsDict</vh></v>
<v t="ekr.20120313134250.14341"><vh>dumpSettings (debugging)</vh></v>
<v t="ekr.20120313134250.14342"><vh>getOption &amp; setOption</vh></v>
<v t="ekr.20120313134250.14343"><vh>initCodeBlockString</vh></v>
<v t="ekr.20120313134250.14344"><vh>preprocessTree &amp; helpers</vh>
<v t="ekr.20120313134250.14345"><vh>preprocessNode</vh></v>
<v t="ekr.20120313134250.14346"><vh>parseOptionLine</vh></v>
<v t="ekr.20120313134250.14347"><vh>scanForOptionDocParts</vh></v>
<v t="ekr.20120313134250.14348"><vh>scanHeadlineForOptions</vh></v>
<v t="ekr.20120313134250.14349"><vh>scanNodeForOptions</vh></v>
<v t="ekr.20120313134250.14350"><vh>scanOption</vh></v>
<v t="ekr.20120313134250.14351"><vh>scanOptions</vh></v>
</v>
<v t="ekr.20120313134250.14352"><vh>scanAllOptions &amp; helpers</vh>
<v t="ekr.20120313134250.14353"><vh>initOptionsFromSettings</vh></v>
<v t="ekr.20120313134250.14354"><vh>handleSingleNodeOptions</vh></v>
</v>
</v>
<v t="ekr.20120313134250.14355"></v>
<v t="ekr.20120313134250.14356"></v>
</v>
</v>
<v t="ekr.20120229094652.15164"><vh>Commands: new</vh>
<v t="ekr.20120229094652.14590"><vh>Added @button split-defs</vh></v>
<v t="ekr.20120229094652.14544"><vh>Added beautify-c command</vh></v>
<v t="ekr.20120229094652.14545"><vh>Added c-to-python command</vh></v>
<v t="ekr.20120229094652.14625"><vh>Added clone-find-all-flattened command</vh>
<v t="ekr.20120229094652.14626"><vh>cloneFindAll (minibufferFind)</vh></v>
<v t="ekr.20120229094652.14627"><vh>cloneFindAllCommand &amp; cloneFindAllFlattenedCommand</vh></v>
<v t="ekr.20120229094652.14628"><vh>cloneFindAllFlattened (minibufferFind)</vh></v>
<v t="ekr.20120229094652.14629"><vh>Find wrappers</vh></v>
<v t="ekr.20120229094652.14630"><vh>generalSearchHelper (minibufferFind)</vh></v>
<v t="ekr.20120229094652.14631"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20120229094652.14632"><vh>findAll &amp; helper (leoFind)</vh>
<v t="ekr.20120229094652.14633"><vh>createCloneFindAllNode</vh></v>
</v>
</v>
<v t="ekr.20120229094652.15090"><vh>Added clone/move/delete-marked commands</vh></v>
<v t="ekr.20120229094652.14579"><vh>Added delete-marked-nodes and move-marked-nodes commands</vh></v>
<v t="ekr.20120229094652.14584"><vh>Added shell commands to Cmds menu</vh></v>
<v t="ekr.20120229094652.14602"><vh>Support run-marked-unit-tests-locally/externally</vh></v>
</v>
<v t="ekr.20120229094652.19778"><vh>Events</vh></v>
<v t="ekr.20120229094652.15162"><vh>Features: major</vh>
<v t="ekr.20120313134250.14232"><vh>Leo's File:Open With command now works with Qt</vh></v>
<v t="ekr.20120229094652.14585"><vh>Added quick edit/save mode</vh>
<v t="ekr.20120229094652.14586"><vh>Request</vh></v>
<v t="ekr.20120229094652.14587"><vh>Checkin log</vh></v>
<v t="ekr.20120229094652.14588"><vh>Changed</vh></v>
</v>
<v t="ekr.20120229094652.14597"><vh>Added support for solarized colors</vh></v>
<v t="ekr.20120229094652.15153"><vh>Detached windows</vh></v>
<v t="ekr.20120229094652.15151"><vh>Leo now raises a dialog on @ignore @&lt;file&gt; nodes</vh></v>
<v t="ekr.20120229094652.15135"><vh>The leoInspect module</vh></v>
</v>
<v t="ekr.20120229094652.15163"><vh>Features: minor</vh>
<v t="ekr.20120229094652.14596"><vh>@ignore now prevents local @button/@command node definitions</vh></v>
<v t="ekr.20120229094652.14542"><vh>Added select-to-matching-bracket command</vh></v>
<v t="ekr.20120229094652.14619"><vh>Added show-decoration-selected: 1 to</vh></v>
<v t="ekr.20120229094652.14592"><vh>Added support for tags in @button nodes</vh></v>
<v t="ekr.20120229094652.14599"><vh>Applied patch for bug 800399: Leo should have smart word jumps/deletes</vh></v>
<v t="ekr.20120229094652.14610"><vh>bridgeController.initLeo now kills events if plugins not loaded</vh></v>
<v t="ekr.20120229094652.14607"><vh>Call unselect1 hook only once</vh></v>
<v t="ekr.20120229094652.14594"><vh>DingDing: big Aha's</vh></v>
<v t="ekr.20120229094652.14603"><vh>Disabled messages on external unit tests</vh></v>
<v t="ekr.20120229094652.14614"><vh>External unit tests now always read config settings</vh></v>
<v t="ekr.20120229094652.14595"><vh>help-for-command now uses g.getDocStringFromFunction</vh></v>
<v t="ekr.20120229094652.14616"><vh>Improved add/delete-comments</vh></v>
<v t="ekr.20120229094652.14613"><vh>Improved scannerUnitTest</vh></v>
<v t="ekr.20120314095341.14216"><vh>Leo supports @ignore when scanning fro @command and @button nodes.</vh></v>
<v t="ekr.20120229094652.14581"><vh>Made open smarter</vh></v>
<v t="ekr.20120229094652.14593"><vh>Reorganized @button &amp; @command nodes.</vh></v>
<v t="ekr.20120229094652.14541"><vh>set g.app.execute_script during script execution</vh></v>
<v t="ekr.20120229094652.14605"><vh>Support marking an entire tree</vh></v>
<v t="ekr.20120229094652.14600"><vh>Support single-line nodes like &lt;node/&gt; xml import code</vh></v>
<v t="ekr.20120229094652.14540"><vh>Supported auto-hide in viewrendered plugin</vh></v>
<v t="ekr.20120229094652.14576"><vh>The Find tab now scrolls</vh></v>
<v t="ekr.20120229094652.14604"><vh>Unit tests now always have the sources available</vh></v>
<v t="ekr.20120229094652.14621"><vh>Warn when importing/reading/writing @ignored nodes</vh></v>
</v>
<v t="ekr.20120229094652.15167"><vh>Leo's web site</vh>
<v t="ekr.20120229094652.14589"><vh>Searches from Leo's web pages now work</vh></v>
<v t="ekr.20120229094652.14601"><vh>Leo's home page now shows the latest postings from leo-editor.</vh></v>
</v>
<v t="ekr.20120229094652.15174"><vh>MacOS</vh>
<v t="ekr.20120229094652.15128"><vh>Leo on Mac OSX: new installation instructions</vh></v>
<v t="ekr.20120229094652.14591"><vh>MacOS is no longer fully supported???</vh></v>
</v>
<v t="ekr.20120229094652.15165"><vh>Plugins</vh>
<v t="ekr.20120229094652.14582"><vh>Improved create @auto nodes script</vh></v>
<v t="ekr.20120229094652.14566"><vh>removed scrolledmessage plugin</vh></v>
<v t="ekr.20120229094652.15091"><vh>Improved quicksearch plugin</vh></v>
<v t="ekr.20120313074006.16135"><vh>New bigdash plugin</vh></v>
</v>
<v t="ekr.20120229094652.15166"><vh>Scripts</vh>
<v t="ekr.20120229094652.14567"><vh>Added import-org-mode script</vh>
<v t="ekr.20120229094652.14568"><vh>import-org-mode (command, not used)</vh>
<v t="ekr.20120229094652.14569"><vh>ctor</vh></v>
<v t="ekr.20120229094652.14570"><vh>go</vh></v>
<v t="ekr.20120229094652.14571"><vh>scan</vh></v>
<v t="ekr.20120229094652.14572"><vh>test</vh></v>
</v>
<v t="ekr.20120229094652.14573"><vh>@@button import-org-mode</vh>
<v t="ekr.20120229094652.14574"><vh>scan</vh></v>
</v>
<v t="ekr.20120229094652.14575"><vh>test-import-org-mode</vh></v>
</v>
<v t="ekr.20120229094652.15131"><vh>Code for displaying a function call hierarchy in Leo</vh>
<v t="ekr.20120229094652.15132"><vh>call tree</vh>
<v t="ekr.20120229094652.15133"><vh>displayCalltree</vh></v>
<v t="ekr.20120229094652.15134"><vh>trace session</vh></v>
</v>
</v>
<v t="ekr.20120229094652.14543"><vh>Improved recursive import script</vh></v>
<v t="ekr.20120229094652.15149"><vh>Replacing Qt stylesheets on the fly</vh></v>
<v t="ekr.20120229094652.15089"><vh>Terry added bookmark scripts</vh></v>
<v t="ekr.20120229173025.20633"><vh>Document Terry's magic refactor button</vh>
<v t="ekr.20120229173025.20635"><vh>@button fac</vh></v>
</v>
</v>
<v t="ekr.20120229094652.15168"><vh>Settings</vh>
<v t="ekr.20120229094652.14606"><vh>Added @bool use_body_focus_border</vh></v>
<v t="ekr.20120229094652.14598"><vh>Added border around selected pane</vh></v>
<v t="ekr.20120229094652.14620"><vh>Added stylesheets for Log &amp; Find tabs</vh></v>
<v t="ekr.20120229094652.14615"><vh>Added @bool indent_added_comments setting</vh></v>
<v t="ekr.20120229094652.15143"><vh>Eliminated the -c option</vh></v>
<v t="ekr.20120229094652.15140"><vh>New format for @openwith settings nodes</vh></v>
<v t="ekr.20120229094652.15144"><vh>New search order for leoSettings.leo &amp; myLeoSettings.leo</vh></v>
</v>
<v t="ekr.20120229094652.15172"><vh>Unit testing</vh>
<v t="ekr.20120229094652.15092"><vh>Use Alt-4 for all unit tests</vh></v>
<v t="ekr.20120229094652.15093"><vh>Weightless unit testsing</vh></v>
</v>
</v>
<v t="ekr.20120229094652.15173"><vh>Update docs</vh>
<v t="ekr.20120315101404.14221"><vh>New chapter: leoInspect</vh></v>
<v t="ekr.20120314095341.15575"><vh>Features</vh>
<v t="ekr.20120314095341.14215"><vh>Discuss url's, bookmarks and ctrl-clicks</vh></v>
<v t="ekr.20120229094652.15096"><vh>Document new organization for @command and @button nodes</vh></v>
<v t="ekr.20120229094652.15099"><vh>FAQ entry: @commands Aha</vh></v>
<v t="ekr.20120229094652.15100"><vh>revise autocompletion docs based on recent posts</vh>
<v t="ekr.20120229094652.15102"><vh>Creating ctags data</vh></v>
<v t="ekr.20120229094652.15103"><vh>Using Leo's autocompleter (outline form)</vh>
<v t="ekr.20120229094652.15104"><vh>Starting autocompletions</vh></v>
<v t="ekr.20120229094652.15105"><vh>Displaying autocompletions</vh></v>
<v t="ekr.20120229094652.15106"><vh>Using the QCompleter</vh></v>
<v t="ekr.20120229094652.15107"><vh>Using the Log pane completer</vh></v>
<v t="ekr.20120229094652.15108"><vh>Showing docstrings</vh></v>
</v>
<v t="ekr.20120229094652.15109"><vh>Using Leo's autocompleter (COPY)</vh>
<v t="ekr.20120229094652.15110"><vh>Starting autocompletions</vh></v>
<v t="ekr.20120229094652.15111"><vh>Displaying autocompletions</vh></v>
<v t="ekr.20120229094652.15112"><vh>Using the QCompleter</vh></v>
<v t="ekr.20120229094652.15113"><vh>Using the Log pane completer</vh></v>
<v t="ekr.20120229094652.15114"><vh>Showing docstrings</vh></v>
</v>
<v t="ekr.20120229094652.15115"><vh>Code notes</vh></v>
<v t="ekr.20120229094652.15116"><vh>Minor settings</vh></v>
<v t="ekr.20120229094652.15117"><vh>Appearance</vh></v>
<v t="ekr.20120229094652.15118"><vh>Codewise notes</vh></v>
<v t="ekr.20120229094652.15119"><vh>Performance</vh></v>
<v t="ekr.20120229094652.15120"><vh>Completions</vh>
<v t="ekr.20120229094652.15121"><vh>Docs</vh>
<v t="ekr.20120229094652.15122"><vh>Additional options</vh></v>
</v>
<v t="ekr.20120229094652.15123"><vh>Existing docs</vh></v>
</v>
</v>
<v t="ekr.20120229094652.15127"><vh>Revise Leo's docs re import commands</vh></v>
<v t="ekr.20120229094652.15152"><vh>All about clone conflicts</vh></v>
<v t="ekr.20120229094652.15148"><vh>BibTeX citations from Leo</vh></v>
<v t="ekr.20120229094652.19496"><vh>Bug 905276: explain how to clone multiple nodes at once</vh></v>
<v t="ekr.20120313134250.14220"><vh>Improve docs for @nosent</vh></v>
</v>
<v t="ekr.20120314095341.15571"><vh>Installation</vh>
<v t="ekr.20120313134250.14219"><vh>Improve installation notes</vh></v>
<v t="ekr.20120229094652.15137"><vh>How to upgrade properly</vh></v>
<v t="ekr.20120229094652.15095"><vh>Review bzr instructions</vh></v>
<v t="ekr.20120229094652.15098"><vh>Rewrite MacOs instructions using Ludvig's homebrew instructions</vh></v>
</v>
<v t="ekr.20120314095341.15572"><vh>Scripting</vh>
<v t="ekr.20120229094652.15130"><vh>Add to scripting chapter</vh>
<v t="ekr.20120229094652.15087"><vh>Add short intro to scripting</vh>
<v t="ekr.20120229094652.15088"><vh>Easier scripting</vh></v>
</v>
</v>
</v>
<v t="ekr.20120314095341.15573"><vh>Testing</vh>
<v t="ekr.20120229094652.15097"><vh>Document @mark-for-unit-test trees!</vh></v>
<v t="ekr.20120229094652.15125"><vh>Document loading plugins when running unit tests externally</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040524104904.161"></t>
<t tx="EKR.20040524104904.211"></t>
<t tx="EKR.20040524104904.245"></t>
<t tx="EKR.20040524104904.26"></t>
<t tx="EKR.20040524104904.261"></t>
<t tx="EKR.20040524104904.274"></t>
<t tx="EKR.20040524104904.99"></t>
<t tx="TL.20080804095315.1"></t>
<t tx="ekr.20040414161647">@nocolor-node

These are the sources for Leo's users guide.

They contain sphinx markup. See::
    
    http://sphinx.pocoo.org/
    http://docutils.sourceforge.net/docs/user/rst/quickstart.html
    
To generate these docs, see the next node: "Generating the Users Guide"
    
Important files:

- doc\html\conf.py contains settings, including the name of the master toctree
  document, leo_toc.html.txt.

- leo_toc.html.txt contains a list of all file to be included.
</t>
<t tx="ekr.20050407144342">



</t>
<t tx="ekr.20050407144342.1"></t>
<t tx="ekr.20050407144342.2"></t>
<t tx="ekr.20050407144342.3"></t>
<t tx="ekr.20050407144417"></t>
<t tx="ekr.20050812123002"></t>
<t tx="ekr.20050812123002.1"></t>
<t tx="ekr.20050812123002.2">Deletes p.v.rst2_http_attributename from all nodes after writing.

Deletes p.v.unknownAttributes if it then becomes empty.
</t>
<t tx="ekr.20050812123002.3"></t>
<t tx="ekr.20050812123002.4">@nocolor

If False, add_node_marker and http_support_main  do nothing.  Otherwise add_node_marker does the following:

1. add_node_marker writes a string using generate_node_marker.

Generates 'http-node-marker-'+str(number), where number is config.node_counter
(incremented each time add_node_marker is called.

2. Enables the following code in :
@color

    if config.tag == 'open2':
        http_map = self.http_map
    else:
        http_map = {}
        config.anchormap = {}
        # maps v nodes to markers.
        config.node_counter = 0
    # [snip] code to write the tree
    if config.rst2_http_server_support:
        self.http_map = http_map
</t>
<t tx="ekr.20050812123002.5"></t>
<t tx="ekr.20050812123002.6">True: call body_filter to massage text.

Removes @ignore, @nocolor, @wrap directives.
</t>
<t tx="ekr.20050812123002.7">Used differently.  See rst2_pure_document.
</t>
<t tx="ekr.20050812123002.8"></t>
<t tx="ekr.20050831184021.1"></t>
<t tx="ekr.20050831184021.3"></t>
<t tx="ekr.20050831184021.4"></t>
<t tx="ekr.20050831184021.5"></t>
<t tx="ekr.20050831195331.1"></t>
<t tx="ekr.20050831195331.4"></t>
<t tx="ekr.20050831195449">@nocolor

For instruction about installing Leo see:
http://webpages.charter.net/edreamleo/installing.html

For everything a beginner needs to know about Leo see:
http://webpages.charter.net/edreamleo/intro.html

For help, please ask questions at:
http://groups.google.com/group/leo-editor</t>
<t tx="ekr.20050901084134"></t>
<t tx="ekr.20050912125144"></t>
<t tx="ekr.20051202072010"></t>
<t tx="ekr.20060430221745"></t>
<t tx="ekr.20060527105211"></t>
<t tx="ekr.20060612102055"></t>
<t tx="ekr.20060620094033"></t>
<t tx="ekr.20060913164304"></t>
<t tx="ekr.20061025065357"></t>
<t tx="ekr.20070317033759"></t>
<t tx="ekr.20070610174018"></t>
<t tx="ekr.20070628083442"></t>
<t tx="ekr.20070701101808"></t>
<t tx="ekr.20080203101507"></t>
<t tx="ekr.20080412124815.1"></t>
<t tx="ekr.20080730212711.14"></t>
<t tx="ekr.20080923182326.1">This option applies to directories specified in filenames in all kinds of @file trees, and to filenames specified in the @path directive.

True:  Leo attempts to create directories if they do not exist.
False: Leo never attempts to create directories.
</t>
<t tx="ekr.20090717084250.10702"></t>
<t tx="ekr.20091111112709.6671"></t>
<t tx="ekr.20091130111843.6787"></t>
<t tx="ekr.20100731112744.7267"></t>
<t tx="ekr.20100805171546.4412"># This section contains important files used to generate Leo's web site.</t>
<t tx="ekr.20100821182153.4341"></t>
<t tx="ekr.20100907092300.4440"></t>
<t tx="ekr.20100907092300.4441">Path to inkscape template file
</t>
<t tx="ekr.20100907092300.4442">Path to Inkscape executable
</t>
<t tx="ekr.20101007100904.4372"></t>
<t tx="ekr.20101009114830.4723">@nocolor-node

Formerly, this had to be on because the expansion bits
of @screenshot trees were significant.

Happily, this is no longer true.

True (recommended):
    Write "E" attribute bits in &lt;v&gt; elements.
    Leo outlines will record the expansion state of all nodes.

False:
    (Good for files like unitTest.leo)
    Suppress "E" attribute bits in &lt;v&gt; elements.
    Only the ancestors of the presently selected node will
    be expanded when Leo opens an outline.
</t>
<t tx="ekr.20101009114830.4724"></t>
<t tx="ekr.20101009114830.4725"></t>
<t tx="ekr.20101025080245.5794"></t>
<t tx="ekr.20101025080245.5795"></t>
<t tx="ekr.20101025080245.5796"></t>
<t tx="ekr.20101025080245.5798"></t>
<t tx="ekr.20101025080245.5799"></t>
<t tx="ekr.20101025080245.5801">c:/leo.repo/trunk/leo/doc/leo_toc.html</t>
<t tx="ekr.20101026081737.5531">@language html

&lt;!-- EKR: changed these by hand to give the toc some structure --&gt;

&lt;p&gt;Preliminaries&lt;/p&gt;

&lt;ul&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="frontMatter.html"&gt;Front Matter&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="preface.html"&gt;Preface&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="testimonials.html"&gt;What People Are Saying About Leo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basics&lt;/p&gt;

&lt;ul&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="FAQ.html"&gt;FAQ&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="slides.html"&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="installing.html"&gt;Installing Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="intro.html"&gt;The Leo Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="outlines.html"&gt;Using Outlines&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Intermediate Topics&lt;/p&gt;

&lt;ul&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="commands.html"&gt;Using Leo&amp;#8217;s Commands&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="customizing.html"&gt;Customizing Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="coloring.html"&gt;Controlling Syntax Coloring&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="rstplugin3.html"&gt;Creating Documents with Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="scripting.html"&gt;Scripting Leo with Python&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="plugins.html"&gt;Plugins&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="writingPlugins.html"&gt;Writing Plugins&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="unitTesting.html"&gt;Unit testing with Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="debuggers.html"&gt;Debugging with Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="atShadow.html"&gt;Using &amp;#64;shadow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Leo and Other Programs&lt;/p&gt;

&lt;ul&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="emacs.html"&gt;Leo and Emacs&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="IPythonBridge.html"&gt;IPython and Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="leoBridge.html"&gt;Embedding Leo with the leoBridge module&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="vimBindings.html"&gt;Using Vim Bindings with Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="zodb.html"&gt;Using ZODB with Leo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Reference&lt;/p&gt;

&lt;ul&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="directives.html"&gt;Leo&amp;#8217;s Reference&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="design.html"&gt;Designing with Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="history.html"&gt;History of Leo&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="theory.html"&gt;Theory of Operation&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="whitepapers.html"&gt;White Papers&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="appendices.html"&gt;Appendices&lt;/a&gt;&lt;/li&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="glossary.html"&gt;Glossary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

Release Notes

&lt;ul&gt;
&lt;li class="toctree-l1"&gt;&lt;a class="reference external" href="what-is-new.html"&gt;What&amp;#8217;s New in Leo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</t>
<t tx="ekr.20101026082911.5536"></t>
<t tx="ekr.20101104024804.4898">@nocolor-node

The children of this node contain two @button scripts. These are disabled, but
you can execute them by selecting them and hitting Ctrl-B (execute-script).

To generate these docs by hand:

    - From this file, run rst3 on desired tree.
    - cd leo\doc\html
    - make html

To create pdf (probably easiest on Linux, with necessary latex packages installed):

    - make latex
    - cd _build/latex
    - make all-pdf
    
Important files:

- doc\html\conf.py contains settings, including the name of the master toctree
  document, leo_toc.html.txt.

- leo_toc.html.txt contains a list of all file to be included.
</t>
<t tx="ekr.20101112045055.5065">http://www.greygreen.org/tmp/plugins.html</t>
<t tx="ekr.20111108052738.5507">run-marked-unit-tests-externally = Alt-4
run-all-unit-tests-externally = Alt-5
</t>
<t tx="ekr.20111127144911.5545"></t>
<t tx="ekr.20120229094652.14053">@language rest

Leo 4.10 b1              March 7, 2012

Leo 4.10 b1 is now available at: http://sourceforge.net/projects/leo/files/

Leo is a text editor, data organizer, project manager and much more.
http://webpages.charter.net/edreamleo/intro.html

The highlights of Leo 4.10:
--------------------------

- leoInspect


- *Many* small improvements and bug fixes.

Links:
------
Leo:      http://webpages.charter.net/edreamleo/front.html
Forum:    http://groups.google.com/group/leo-editor
Download: http://sourceforge.net/projects/leo/files/
Bzr:      http://code.launchpad.net/leo-editor/
Quotes:   http://webpages.charter.net/edreamleo/testimonials.html
</t>
<t tx="ekr.20120229094652.14518"></t>
<t tx="ekr.20120229094652.14520">Leo-specific, not jEdit specific.
blank
docpart
leokeyword
link
name
nameBrackets
tab
url
</t>
<t tx="ekr.20120229094652.14522">Only the high-level interface (baseTextWidget) used the low-level interface.
</t>
<t tx="ekr.20120229094652.14523">Removed the following unused methods::
    
    bind                c.bind also removed.
    configure
    cget
    event_generate      g.app.gui.event_generate does exist.
    getWidth
    indexIsVisible      Also removed for leoEditCommands: scrollHelper and measure.
    mark_set
    onChar              Fortunately, never used anywhere
    pack                Used only in Tk code
    scrollLines
    set_width           Removed do-nothing calls in Leo's core.
    tag_add             Removed do-nothing calls in qt colorizer.
    tag_bind            Removed do-nothing calls in qt colorizer.
    tag_delete          Removed do-nothing calls in qt colorizer.
    tag_names
    tag_ranges
    tag_remove
    update
    update_idletasks
    xyToPythonIndex
    yview
</t>
<t tx="ekr.20120229094652.14524">- The nullGui now uses a fully capable string-based body widget.
- The nullGui now uses the regular undoer.
</t>
<t tx="ekr.20120229094652.14525">leoQTextEditWidget overrides base toPythonIndex toPythonIndexRowCol.

The versions that call g.toPythonIndex are much slower than
leoQTextEditWidget.toPythonIndex.

The following classes have a toPythonIndex method:

leoQTextEditWidget (fast)

HighLevelInterface: calls g.toPythonIndex.
baseTextWidget: calls g.toPythonIndex.
leoFind: calls g.toPytonIndex.
leoQtBaseTextWidget: calls g.toPythonIndex.
</t>
<t tx="ekr.20120229094652.14526">This is an important addition to reliability.

It ensures that body/log.widget and body.bodyCtrl/log.logCtrl are always in synch.
</t>
<t tx="ekr.20120229094652.14527">Added eventFilter in createFrame in SDI/TabbedFrameFactory classes
</t>
<t tx="ekr.20120229094652.14528"></t>
<t tx="ekr.20120229094652.14531">This is something that I've wanted to do for a long time.  

Now, most modules import only leo.core.leoGlobals. However,
Leo's core still imports leo.core.leoNodes in order to create
positions, vnodes, etc. It would be straightforward to
eliminate these by creating g.app factory methods, but there
is no urgent reason to do so.
</t>
<t tx="ekr.20120229094652.14532">All top-level code in leoTest.py now resides in the
TestManager class.

The c.testManager object eliminates the need for imports of
leo.core.leoTest within unitTest.leo, an excellent
simplification.

Furthermore, there is no need to access the testUtils class:
everything is in c.testManager.

The TestManager class substantially clarifies *all* the code
in leoTest.leo. This is surprisingly important because the
testing code is hardly straightforward.
</t>
<t tx="ekr.20120229094652.14533">This is a major restructuring of Leo's code:
    
Initing settings files and local files is now as simple as possible.

g.openWithFileName now simply calls lm.loadLocalFile.

Commands.__init__ now calls c.finshCreate.

g.app.newCommander now simply calls Commands.__init__,
a *huge* collapse in complexity.

===== Details

The g.app.config class is now substantially simpler:
complex methods have moved to the LoadManager.

The new LoadManager class handles all aspects of Leo's
complex startup process, including most importantly the very
complex process by which Leo reads user settings.

As a side effect, c.config.get is now *much* simpler than
before: it search one, and *only* one dictionary to discover
settings.

Reading local files must be done *twice*. The first read
discovers settings, the second read uses those settings to
open the file. The first read always uses a null gui; the
second read uses g.app.gui, whatever that happens to be.

LM.openLocalFile embodies all aspects of the complex
strategy necessary for opening a local file twice. The first
read creates a PreviousSetting object, which is then passed
to LM.openFileByName, which in turn passes the
PreviousSetting object to the ctor for the Commander.
Finally, the PreviousSetting object inits c.config.

Because of the previousSettings object, the call to
LM.openFileByName does *not* need to "synthesize" a link to
c1 using c.hash. This stamps out bug 568452 at its source.

The crucial point is the previous settings get passed along
to the Commander ctor, *before* LM.openFileByName calls
c.fileCommands.openLeoFile to create the outline.

</t>
<t tx="ekr.20120229094652.14534">- Moved findSettingsPosition to LocalConfigManager.

- Moved printSettings to LocalConfigManager.
</t>
<t tx="ekr.20120229094652.14535"></t>
<t tx="ekr.20120229094652.14536">http://www.diveintopython.org/xml_processing/unicode.html

pr_warning_given = False

def pr(*args,**keys): # (codewise!)

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    if hasattr(sys.stdout,'encoding') and sys.stdout.encoding:
        # sys.stdout is a TextIOWrapper with a particular encoding.
        encoding = sys.stdout.encoding
    else:
        encoding = 'utf-8'

    # Important:  Python's print statement *can* handle unicode.
    # However, the following must appear in Python\Lib\sitecustomize.py:
    #    sys.setdefaultencoding('utf-8')
    s = g.translateArgs(args,d) # Translates everything to unicode.
    if newline:
        s = s + '\n'

    if g.isPython3:
        if encoding.lower() in ('utf-8','utf-16'):
            s2 = s # There can be no problem.
        else:
            # 2010/10/21: Carefully convert s to the encoding.
            s3 = g.toEncodedString(s,encoding=encoding,reportErrors=False)
            s2 = g.toUnicode(s3,encoding=encoding,reportErrors=False)
    else:
        s2 = g.toEncodedString(s,encoding,reportErrors=False)

    if 1: # Good for production: queues 'reading settings' until after signon.
        if app.logInited:
            sys.stdout.write(s2)
        else:
            app.printWaiting.append(s2)
    else:
        # Good for debugging: prints messages immediately.
        print(s2)
</t>
<t tx="ekr.20120229094652.14537">http://www.diveintopython.org/xml_processing/unicode.html

pr_warning_given = False

def pr(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''
    
    print_immediately = False # True: good for debugging.

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')

    if sys.platform.lower().startswith('win'):
        encoding = 'ascii' # 2011/11/9.
    elif hasattr(sys.stdout,'encoding') and sys.stdout.encoding:
        # sys.stdout is a TextIOWrapper with a particular encoding.
        encoding = sys.stdout.encoding
    else:
        encoding = 'utf-8'

    s = g.translateArgs(args,d) # Translates everything to unicode.
    
    # Add a newline unless we are going to queue the message.
    if app.logInited and not print_immediately:
        if newline:
            s = s + '\n'

    if g.isPython3:
        if encoding.lower() in ('utf-8','utf-16'):
            s2 = s # There can be no problem.
        else:
            # Carefully convert s to the encoding.
            s3 = g.toEncodedString(s,encoding=encoding,reportErrors=False)
            s2 = g.toUnicode(s3,encoding=encoding,reportErrors=False)
    else:
        s2 = g.toEncodedString(s,encoding,reportErrors=False)
      
    if print_immediately:
        # Good for debugging: prints messages immediately.
        sys.stdout.write(s2)
    else:
        # Good for production: queues 'reading settings' until after signon.
        if app.logInited:
            sys.stdout.write(s2)
        else:
            app.printWaiting.append(s2)
</t>
<t tx="ekr.20120229094652.14538"># It's important to use only one version of the code.
</t>
<t tx="ekr.20120229094652.14540"></t>
<t tx="ekr.20120229094652.14541">This allows the following pattern to appear in Leo source files::

    class myClass:
        @others
        
    if g.app.testing:
        myClass(c).test()
        
This is better than enabling the test with "if 1:" because
c is not defined while importing the module, so the import
will fail if I forget to change "if 1:" to "if 0" when saving
the .leo file.
</t>
<t tx="ekr.20120229094652.14542"></t>
<t tx="ekr.20120229094652.14543">- Generates only @auto, does not do an actual import.

- Creates @path nodes so actual @auto nodes are short.
</t>
<t tx="ekr.20120229094652.14544">Added class CPrettyPrinter &amp; beatifyCCode
</t>
<t tx="ekr.20120229094652.14545">- Wrapped the code in a class.

- Replaced all globals with ivars.

- Replaced listToString with ''.join(aList)
    
- Eliminated stringToList.
    The code never passes None where a sequence is expected.
    
- Get tab_width from @tabwidth directives.

- Get user data from::
    
    @data c-to-python-class-list
    @data c-to-python-type-list
    @data c-to-python-ivars-dict
        keys end in a colon
        all other lines contain comma-delimited values for the current key.
        
- Add extra parens for 'if' that span several lines.
- Fixed extra indentation.
- Changed ! to not except before =.
- Dedented C blocks, such as::
    
    {
        statement;
        statement;
    }
    
- Improved formatting of block comments.
</t>
<t tx="ekr.20120229094652.14566">The viewrendered plugin does more.
</t>
<t tx="ekr.20120229094652.14567"></t>
<t tx="ekr.20120229094652.14568">class ImportOrgMode:
    @others

def importOrgMode (self,event):
    c = self.c
    self.ImportOrgMode(c).go(c.p)
    c.bodyWantsFocus()

if False and g.app.inScript:
    print('='*40)
    ImportOrgMode(c).test()
    print('done')
</t>
<t tx="ekr.20120229094652.14569">def __init__ (self,c):
    
    self.c = c
</t>
<t tx="ekr.20120229094652.14570">def go (self,p):
    
    '''Prompt for a file and pass the contents to scan().'''
</t>
<t tx="ekr.20120229094652.14571">def scan (self,fn,p,s):

    self.c = c
    root = p.insertAsLastChild()
    root.h = fn
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        g.trace(repr(s))
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1
                level += 1
            if level &gt; len(stack):
                g.trace('bad level',repr(s))
                last = None
            elif level == len(stack):
                last = stack[-1]
                last.b = ''.join(body)
            else:
                last = stack[-1]
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            p = parent.insertAsLastChild()
            p.h = s.strip()
            stack.append(p)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        parent = stack[-1]
        parent.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
</t>
<t tx="ekr.20120229094652.14572">def test (self):
    
    s = '''
* A1
    a1.1
    a1.2
** B11
** B12
b12.1
*** C121
c121.1
    c121.2
c121.3
* A2
a2.1
** B21
*** C211
c211.1
*** C212
** B22
    b22.1
b22.1
* A3
* A4
a4.1
* A5
** B51
*** C511
**** D5111
***** E51111
** B52
*** C521
c521.1
'''

    tag = 'test-import-org-mode'
    p = g.findNodeAnywhere(c,tag)
    s = g.adjustTripleString(s,-4)
    if p:
        try:
            self.scan('test-file',p,s)
        except Exception:
            c.redraw(p)
    else:
        print('not found: %s' % tag)
</t>
<t tx="ekr.20120229094652.14573">'''Import each file in the files list after the presently selected node.'''


files = (
    r'c:\Users\edreamleo\test\import-org-mode.txt',
    r'c:\Users\edreamleo\test\import-org-mode.txt',
)

@others

for fn in files:
    try:
        root = c.p.copy()
        f = open(fn)
        s = f.read()
        scan(c,fn,s)
        c.selectPosition(root)
    except IOError:
        print('can not open %s' % fn)
</t>
<t tx="ekr.20120229094652.14574">def scan (c,fn,s):

    last = root = c.p.insertAsLastChild()
    last.h = g.shortFileName(fn)
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1 ; level += 1
            if level &gt; len(stack):
                g.trace('bad level',repr(s))
            elif level == len(stack):
                last.b = ''.join(body)
            else:
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            last = parent.insertAsLastChild()
            last.h = s.strip()
            stack.append(last)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        last.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
</t>
<t tx="ekr.20120229094652.14575"></t>
<t tx="ekr.20120229094652.14576">The change was to DynamicWindow.createLogPane.
</t>
<t tx="ekr.20120229094652.14577">This was Tk code, and so can not possibly be useful now.

Also removed the settings specific to the Tk colorizer.
</t>
<t tx="ekr.20120229094652.14578">This important new method allows scripts to traverse an outline, deleting nodes
during the traversal. The pattern is::

    p = c.rootPosition()
    while p:
    if &lt;delete p?&gt;:
        next = p.positionAfterDeletedTree()
        p.doDelete()
        p = next
    else:
        p.moveToThreadNext()
        
This method also allows scripts to *move* nodes during a traversal, **provided**
that nodes are moved to a "safe" spot so that moving a node does not change the
position of any other nodes.

For example, the move-marked-nodes command first creates a **move node**, called
'Clones of marked nodes'. All moved nodes become children of this node.
**Inserting** these nodes as children of the "move node" does not change the
positions of other nodes. **Deleting** these nodes *may* change the position of
nodes, but the pattern above handles this complication cleanly.
</t>
<t tx="ekr.20120229094652.14579"># And rewrote clone-marked-nodes.
</t>
<t tx="ekr.20120229094652.14580">Surprisingly important: it is a not-so-subtle clue that *any* file may be
opened: non-Leo files are opened in @edit nodes. Soon: external files containing
Leo sentinels will be opened as @file nodes.
</t>
<t tx="ekr.20120229094652.14581">Create @file nodes (not @thin nodes) when opening an external file.

Changed g.openWrapperLeoFile to create @file instead of @edit when possible.

Changed c.open; minor changes to importDerivedFiles.
</t>
<t tx="ekr.20120229094652.14582"></t>
<t tx="ekr.20120229094652.14583">Rewrote the shellCommand, shellCommandOnRegion and executeSubprocess methods.
</t>
<t tx="ekr.20120229094652.14584"></t>
<t tx="ekr.20120229094652.14585">The idea is to allow Leo to be a drop-in replacement for SciTe.

Suppose you do::
    
    leo x.y
    
where y is not "leo".

1. If x.y exists, Leo should:
    
- Open an unnamed .leo file consisting of @edit x.y.

- If you execute the save command, or close the Leo window,
  Leo should save x.y if it has been changed, but *not* prompt
  you to save the "temporary" .leo file.
  
2. If x.y does *not* exist, leo should do exactly the same
   thing, except that @edit x.y will be empty.
   
However, there are two problems with using Leo as a replacement for SciTe:

1. Load time.  SciTe loads instantly, Leo does not.

2. Screen real estate: Leo is not at its best when presenting only a single
   @edit node: everything but the body pane is wasted space.
</t>
<t tx="ekr.20120229094652.14586">https://bugs.launchpad.net/leo-editor/+bug/381527

Opens a new nameless leo file and adds somefile.foo as an @edit node.

This is good but...

Saving is a pain, because you have to give a name / location for the .leo file,
and in the quick edit use case you want to be able to just hit ctrl-S to save
somefile.foo.

=====

Ah, at last I see the problem. Saving the **.leo** file is too "heavy". This is
an interesting design problem. You could say that Leo could "throw away" the
temporary .leo file, provided it contains only the @edit node.

True, "quick" editing of a non-Leo file could be done in the workbook, but such
an approach would litter the workbook, and would make opening the workbook
slower and slower. That is, the workbook would get heavier and heavier.
</t>
<t tx="ekr.20120229094652.14587">Rev 4577 adds an important new feature: "quick edit/save mode"

This fixes bug 381527 quick edit and save use of leo, and makes Leo considerably lighter.

**Important**: As you will see below, quite a few hacks were needed to make this work.  That doesn't bother me at all, because they are all hidden.  The *effect* of those hacks is easily understandable.

**However**, I may have missed something: I almost missed that I had to change the code that prompts for a save when closing an unsaved headline.  So please be on the lookout for any use cases that I missed.

From the checkin log:

QQQQQ

"leo somefile.foo" opens a nameless .leo file containing a single @edit node.

In quick edit/save mode, the user can change somefile.foo without saving the .leo file at all.

Leo *does* properly prompt for saves so that changes to somefile.foo will not be lost.

Quick edit/save mode changes Leo as follows:

1. The save command, and *only* the save command (not save-as or save-to), looks for an unsaved .leo file containing a single @edit node. This is the "quick save" case.

In this case, Leo does *not* prompt for a filename and does *not*, therefore, save the .leo file. However, Leo does save the @edit node if it is dirty.

2. In the quick edit/save case, atFile.writeOneAtEdit node does *not* prompt for so-called dangerous writes, because, in fact, the write is not dangerous :-)

3. In the quick edit/save case, leoFrame.promptForSave prompts for saving the @edit file, *not* the .leo file.

QQQQQ

I forgot to mention one detail.  There is no way to save the .leo file itself in quick edit/save mode.  If you want to do that, simply add any other node at the top level of the outline.  This ends quick edit/save mode.  When you save or close the outline, Leo will prompt you for the name of the .leo file as usual.

Edward
</t>
<t tx="ekr.20120229094652.14588">The following were changed:

c.save,
at.writeOneAtEditNode,
at.openFileForWriting
leoFrame.promptForSave
</t>
<t tx="ekr.20120229094652.14589">Updating Sphinx and using new .js files did the trick.
</t>
<t tx="ekr.20120229094652.14590"></t>
<t tx="ekr.20120229094652.14591">Leo's home page no longer mentions MacOS and LeoDocs.leo and install.txt now
warn people that MacOS is difficult to install.
</t>
<t tx="ekr.20120229094652.14592">The mod_scripting plugin so that the name of the command created by an @button
nodes does not include any [&lt;tag&gt;] that immediately follows @button. Examples::

    @button [ekr] x
    @button [edit] y
    @button [important] z

These buttons create commands named x, y and z, and the name of the buttons are
x, y and z.

Note that the '[' must be the first non-blank after @button to be recognized and
removed.

The code is a straightforward addition to cleanButtonText in mod_scripting.py:
it is unlikely to have any impact whatsoever to existing @button nodes.

The intended use is for searches of the form @button [some tag].
</t>
<t tx="ekr.20120229094652.14593">http://groups.google.com/group/leo-editor/browse_thread/thread/bd6ed96c88fabb4e

The prefix "DingDing" signifies that this post is an answer to the
lament:

    "Wouldn't it be great if we all could remember what we,
    and others, have already done :-)"

Last night I had a forehead-slapping moment: the place to put @button
nodes is in myLeoSettings.leo.

This morning, I realized that using @command rather than @button
completes the Aha.

This organization has all benefits, and no drawbacks:

- I always know here scripts are.

- No need for duplicates.

- I can organize the scripts within myLeoSettings.leo as usual using
organizer nodes.  This organization can change as needed.

- Using @command rather than @button means that I never have to
disable scripts.  No more @@button.

- Using @command saves screen real estate.  In my experience, having
buttons be visible doesn't prevent them from being hidden in full
view.

- If I use common prefixes, like c_ (for command) or edit_ (for edit-
related scripts) or ekr_ (for personal scripts), the *typing
completion* will let me zero in on the script I want to use:

    &lt;alt-x&gt; c_&lt;tab&gt;
    &lt;alt-x&gt; c_import&lt;tab&gt;

etc.  Furthermore, Ctrl-P (repeat-complex-command) will allow me to
rerun the last script run.  This is a quite common case.

Summary
=======

This Aha substitutes an *already-existing* usage (typing completion)
for a whole set of memory-intensive retrieval problems.  I'm not
likely ever to forget typing completion, although I might forget the
specif prefixes used in @command nodes.  If that happens, I'll know
where to look.

This Aha takes full advantage of Leo's organization strengths and
*concentrates* those strengths by putting all the to-be-organized
material in one place.  This allows for easy reorganization:  changing
command-name prefixes, for instance, would be straightforward. 
</t>
<t tx="ekr.20120229094652.14594">http://groups.google.com/group/leo-editor/browse_thread/thread/9ebd0dd748f3011f

1. Today's work promises to *end* my confusion about scripts:

Scripts will typically be found in myLeoSettings.leo, or, for
"official" scripts, in other places, particularly leoSettings.leo.

The print-buttons command (maybe better called print-scripts) will
show the location of @button or @command nodes.

2. This is a huge breakthrough, because it makes hundreds of scripts
easily available.  This in turn makes *all* scripts more valuable.

3. As I was thinking about these happy developments, I realized that a
big new horizon is about to open up.

I shall not describe here my thought processes, but they were related
to what I have been thinking of as @link nodes. The idea behind @link
nodes was that they would be a link to a given node, specified by a
commander and a gnx.

However, scripts moot the need for @link nodes!  The phrase that
popped into my head was::

    Don't *link* to nodes, *search* for nodes!

That is, links, no matter how "good" they are, are breakable and
fragile; searches are more robust and more dynamic.  Bye bye link
nodes!

4.  Do you see what has just happened?  A search, in other words **a
script**, has eliminated the need for a major new core feature, that
is, link nodes.

This is a *huge* change in point of view!

5.  Here are some implications:

A.  Leo must have a check-doc-strings script that will verify that all
commands have non-trivial doc strings.

B. Leo must have a create-command-docs script that will create large
parts of Leo's documentation for individual commands by searching for
commands in all the proper places, including functions specified by
@g.command(name) and Leo's various commands dictionaries.

C. Leo must have a create-plugins-doc script that does the same for
plugins.  A prototype of this script exists somewhere.  Making it an
@command node will make it much more visible.

Conclusions
==========

1. "Smallish" changes (making scripts more visible via typing
completion) has greatly increased the convenience, and thus
application, of scripts.

Part of the Leo Aha is that Leo outlines are *much* easier to script
than flat files.  We are about to see an explosion in applicability of
scripts in Leo.

2. Searches, that is, scripts, are a *much* more powerful mechanism
than breakable links.  My throwaway response to many feature requests
has always been, "well, you can always write a script to do what you
want."

Now we can see the sense in which this is a proper, universal,
response.  In Leo's case, it has recently become clear that docstrings
are the natural *primary* location for data.  This makes the data
available for online help, such as the help-for-command command.

Now we can see that the *proper* way of creating large parts of Leo's
documentation tree (nodes for the rst3 command) will be via one or
more scripts that dynamically search Leo's source files looking for
data!

A great day for Leo.
</t>
<t tx="ekr.20120229094652.14595"></t>
<t tx="ekr.20120229094652.14596">A big improvement.  There is no longer any need for @@buton, etc.: just put under an @ignore node.

test.leo illustrates the new organization.
</t>
<t tx="ekr.20120229094652.14597">http://ethanschoonover.com/solarized


- 

</t>
<t tx="ekr.20120229094652.14598">Made this optional, and configurable.

c.focus_border_color    = c.config.getColor('focus_border_color') or 'red'
c.focus_border_width    = c.config.getInt('focus_border_width') or 1 # pixels
c.use_body_focus_border = c.config.getBool('use_body_focus_border',default=True)
c.use_focus_border      = c.config.getBool('use_focus_border',default=True)
</t>
<t tx="ekr.20120229094652.14599">Some editors, such as Eclipse, vim, this Webkit form I type in, and even Word,
allow to jump over, select and delete words, especially those containing or
surrounded by special characters, in a smarter way than just "going to the
beginning of the word before" (back-word) or "going to the end of the next word"
(forward-word).

E.g. in a line containing "i = ass" (note: multiple spaces) with the cursor at
the end, Ctrl-BackSpace would delete everything up to the "=", leaving "i =",
and if the cursor was right behind the "i", Ctrl-Right would position the cursor
right before the "=", instead of before the "ass", as Leo does now.

They also make deleting easy. Given a python method:

def fun():
    line1
    line2

Eclipse's and Webkit's Ctrl-BackSpace, beginning with the cursor behind "line2",
used multiple times, yield (turn by turn):

def fun():
    line1
    [4 spaces left of here]

def fun():
    line1
[emtpy line]

def fun():
    line1

def fun():
    [4 spaces left of here]

def fun():
[empty line]

def fun():

def fun

def [1 space left of here]

[empty line]

while Leo's backward-delete-word yields:

def fun():
    line1
   [3 spaces left of here ?!]

def fun():
   [3 spaces left of here ?!]

def

[empty line]

So to say, Leo's word-based commands jump, select and delete more than is useful
for possibly many users coming from other editors, leaving them only with
character-based commands.

I have attached two patches that add "-smart" equivalents of the jump, select
and delete commands.

Users wanting to use these commands can set in their myLeoSettings.leo:

  back-word-smart = Ctrl-LtArrow
  back-word-smart-extend-selection = Ctrl-Shift-LtArrow

  forward-word-smart = Ctrl-RtArrow
  forward-word-smart-extend-selection = Ctrl-Shift-RtArrow

  delete-word-smart = Ctrl-Delete
  backward-delete-word-smart = Ctrl-BackSpace

which overrides the default bindings.
</t>
<t tx="ekr.20120229094652.14600">The single-line nodes should end in a newline. Otherwise the created node will
add a newline, and the checkers will complain.

The new class is xmlScanner and htmlScanner in leoImport.py.
</t>
<t tx="ekr.20120229094652.14601">Leo's home page now shows the latest postings on the leo-editor group.
</t>
<t tx="ekr.20120229094652.14602">The new command names and default bindings are::
    
    run-all-unit-tests-externally       = None
    run-all-unit-tests-locally          = None
    run-marked-unit-tests-externally    = None
    run-marked-unit-tests-locally       = None
    run-selected-unit-tests-externally  = None
    run-selected-unit-tests-locally     = Alt-4
</t>
<t tx="ekr.20120229094652.14603">1. Removing the signon message:

    This was nasty to find. They were created by the call to
    c.new (the non-testc!) in runTests.

    The trace in g.es was the key to discovering what was happening.
    
2. Moved the print statements from leoGlobals.py to writeWaitingLog.

    This allows g.app.silentMode to have effect.
    
3. fc.save now takes a 'silent' argument, set only by createFileFromOutline.

</t>
<t tx="ekr.20120229094652.14604">The following code were changed:

g.executeScript,
c.executeScript,
c.writeScriptFile,
TM.doTests
runTest (generalTestCase)
TM.makeTestSuite.
</t>
<t tx="ekr.20120229094652.14605">If a marked node is neither an @test node nor an @suite node,
all nodes in the tree are considered to be marked.
</t>
<t tx="ekr.20120229094652.14606"></t>
<t tx="ekr.20120229094652.14607">http://groups.google.com/group/leo-editor/browse_thread/thread/e2980a2b86af913e

Isee the following
- when a file is opened
  - one message listing the root node
  - 7 repeats of the message for the current node

- when the file is saved in a session with several tabs
  - a message is generated for each current node in each tab

- shifting focus from body to headline doesn't generate the message,
  shifting focus with &lt;ctl-h&gt; does

- switching from one tab to another doesn't generate the message 
</t>
<t tx="ekr.20120229094652.14608">Unit tests can test this ivar.
</t>
<t tx="ekr.20120229094652.14610">The new code monkey-patches g.doHook to a do-nothing::
    
    if not self.loadPlugins:
        def dummyDoHook(tag,*args,**keys):
            pass
        g.doHook = dummyDoHook
</t>
<t tx="ekr.20120229094652.14611">An useful convenience method now that external unit tests can use config settings.
</t>
<t tx="ekr.20120229094652.14612">Under control of @bool collapse_on_lt_arrow option, default *True*.
</t>
<t tx="ekr.20120229094652.14613">The error message is now part of the failed assert.  Very helpful.
</t>
<t tx="ekr.20120229094652.14614">The change was simply to set readSettings = True in
leoDynamicTest.py.main.

Experience show the extra time (0.3 sec) is very important
for some unit tests.
</t>
<t tx="ekr.20120229094652.14615">The default, True, is the legacy operation, which I recommend.

</t>
<t tx="ekr.20120229094652.14616">add-comments preserves trailing whitespace.
delete-comments now works whether or not blanks surround comments delims.
</t>
<t tx="ekr.20120229094652.14617">This is true regardless of command, marked status of the node, or @ignore nodes.  Doh!

Added special-case code to findAllUnitTestNodes.
</t>
<t tx="ekr.20120229094652.14618">print-bindings: Alt/Ctrl+Key+N now printed with plain Alt/Ctrl keys and shown as Alt/Ctrl+N.
print-commands: Alt/Ctrl+Key+N now printed as Alt/Ctrl+N.
</t>
<t tx="ekr.20120229094652.14619">Added show-decoration-selected: 1 to QTreeWidget stylesheet.

This causes the entire headline row to be shown when select, a big improvement, imo.
</t>
<t tx="ekr.20120229094652.14620"></t>
<t tx="ekr.20120229094652.14621">What I did:
    
1. Created c.init_error_dialogs &amp; c.raise_error_dialogs.

These are called from the following methods:
    
c.importAnyFile
c.open
c.readAtAutoNodes
c.readAtFileNodes
at.readAll
c.save
c.saveAs
c.saveTo
fc.writeAtFileNodes
fc.writeAtShadowNodes
fc.writeDirtyAtFileNodes

2. Disabled log messages in several of the above methods during unit testing.

3. Disabled runOpenFileDialog and runSaveFileDialog during unit testing.
</t>
<t tx="ekr.20120229094652.14622">- Improved autocompletion list:
    don't print 'all' in bindings.
    print bindings first
    pad bindings properly, as is done in print-commands/bindings.
    
- Improved print-commands &amp; print-bindings: don't print 'all'

- Simplfied the code in various ways.
</t>
<t tx="ekr.20120229094652.14625">The clone-find-all command includes nodes only once: if a
node's ancestor appears in the list, the node is not include
again in the top-level list.

The new clone-find-all-flattened command includes every found node
in the top-level list of nodes. I find this less confusing.
</t>
<t tx="ekr.20120229094652.14626">def cloneFindAll (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=None,regexp=None,word=None)
        # Init the pattern from the search pattern.
        self.stateZeroHelper(
            event,tag,'Clone Find All: ',self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
        c.treeWantsFocus()
        
</t>
<t tx="ekr.20120229094652.14627">def cloneFindAllCommand (self,event=None):

    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
    
def cloneFindAllFlattenedCommand (self,event=None):

    self.setup_command()
    self.clone_find_all = True
    self.clone_find_all_flattened = True
    self.findAll()
    self.clone_find_all = False
    self.clone_find_all_flattened = False
</t>
<t tx="ekr.20120229094652.14628">def cloneFindAllFlattened (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all-flattened'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=None,regexp=None,word=None)
        # Init the pattern from the search pattern.
        self.stateZeroHelper(
            event,tag,'Clone Find All Flattened: ',self.cloneFindAllFlattened)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAllFlattened=True)
        c.treeWantsFocus()
</t>
<t tx="ekr.20120229094652.14629">def changeAll(self,event=None):
    '''Execute the 'Change All' command with the settings shown in the Find tab.'''
    self.getHandler().changeAll(event)

def cloneFindAll (self,event):
    '''Do search-with-present-options and print all matches in the log pane. It
    also creates a node at the beginning of the outline containing clones of all
    nodes containing the 'find' string. Only one clone is made of each node,
    regardless of how many clones the node has, or of how many matches are found
    in each node.'''
    self.getHandler().cloneFindAll(event)
    
def cloneFindAllFlattened (self,event):
    self.getHandler().cloneFindAllFlattened(event)

def findAll            (self,event):
    '''Do search-with-present-options and print all matches in the log pane.'''
    self.getHandler().findAll(event)

def replaceString      (self,event):
    '''Prompts for a search string. Type &lt;Return&gt; to end the search string. The
    command will then prompt for the replacement string. Typing a second
    &lt;Return&gt; key will place both strings in the Find tab and executes a **find**
    command, that is, the search-with-present-options command.'''
    self.getHandler().replaceString(event)

def reSearchBackward   (self,event):
    '''Do a reverse regex search.'''
    self.getHandler().reSearchBackward(event)

def reSearchForward    (self,event):
    '''Do a forward regex search.'''
    self.getHandler().reSearchForward(event)

def searchBackward     (self,event):
    '''Do a backward plain search.'''
    self.getHandler().searchBackward(event)

def searchForward      (self,event):
    '''Do a forward plain search.'''
    self.getHandler().searchForward(event)

def wordSearchBackward (self,event):
    '''Do a backward word-only search.'''
    self.getHandler().wordSearchBackward(event)

def wordSearchForward  (self,event):
    '''Do a forward word-only search.'''
    self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    '''Prompts for a search string. Typing the &lt;Return&gt; key puts the search
    string in the Find tab and executes a search based on all the settings in
    the Find tab. Recommended as the default search command.'''
    self.getHandler().searchWithPresentOptions(event)
</t>
<t tx="ekr.20120229094652.14630">def generalSearchHelper (self,pattern,cloneFindAll=False,cloneFindAllFlattened=False,findAll=False):

    c = self.c

    self.setupSearchPattern(pattern)

    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.p
    self.finder.v = self.finder.p.v

    if findAll:
        self.finder.findAllCommand()
    elif cloneFindAll:
        self.finder.cloneFindAllCommand()
    elif cloneFindAllFlattened:
        self.finder.cloneFindAllFlattenedCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
</t>
<t tx="ekr.20120229094652.14631">def getPublicCommands (self):

    return {
        'clone-find-all':                       self.cloneFindAll,
        'clone-find-all-flattened':             self.cloneFindAllFlattened,
        
        'change':                               self.findTabChange,
        'change-all':                           self.changeAll,
        'change-then-find':                     self.findTabChangeThenFind,
        
        'find-all':                             self.findAll,
        'find-clone-all':                       self.cloneFindAll, # Synonym.
        'find-clone-all-flattened':             self.cloneFindAllFlattened, # Synonym.
        'find-next':                            self.findTabFindNext,
        'find-prev':                            self.findTabFindPrev,

        'find-tab-hide':                        self.hideFindTab, # new name
        'find-tab-open':                        self.openFindTab, # new name

        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
        'isearch-with-present-options':         self.isearchWithPresentOptions,

        'replace-string':                       self.replaceString,

        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,

        'show-find-options':                    self.showFindOptions,

        'toggle-find-collapses-nodes':          self.toggleFindCollapesNodes,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        # 'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,

        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }
</t>
<t tx="ekr.20120229094652.14632">def findAll(self):

    trace = False and not g.unitTesting
    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All Flattened' if self.clone_find_all_flattened else 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if self.clone_find_all:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    skip = {} # Nodes that should be skipped.
        # Keys are vnodes, values not important.
    count,found = 0,None
    if trace: g.trace(self.clone_find_all_flattened,self.p)
    while 1:
        pos, newpos = self.findNextMatch() # sets self.p.
        if pos is None: break
        if self.clone_find_all and self.p.v in skip:
            continue
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if self.clone_find_all:
            if not skip:
                undoData = u.beforeInsertNode(c.p)
                found = self.createCloneFindAllNode()
            if self.clone_find_all_flattened:
                skip[self.p.v] = True
            else:
                # Don't look at the node or it's descendants.
                for p2 in self.p.self_and_subtree():
                    skip[p2.v] = True
            # Create a clone of self.p under the find node.
            p2 = self.p.clone()
            p2.moveToLastChildOf(found)
        else:
            self.printLine(line,allFlag=True)

    if self.clone_find_all and skip:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        c.selectPosition(found)
        c.setChanged(True)

    self.restore(data)
    c.redraw()
    g.es("found",count,"matches")
</t>
<t tx="ekr.20120229094652.14633">def createCloneFindAllNode(self):
    
    c = self.c
    oldRoot = c.rootPosition()
    found = oldRoot.insertAfter()
    found.moveToRoot(oldRoot)
    c.setHeadString(found,'Found: ' + self.find_text)
    return found
</t>
<t tx="ekr.20120229094652.14757"></t>
<t tx="ekr.20120229094652.14758">https://bugs.launchpad.net/leo-editor/+bug/800157

In a new file containing only a "NewHeadline" and that being selected, execute:

copy-node
insert-child
&lt;&lt;enter&gt;&gt;
undo
paste-retaining-clones

Leo's UI freezes and loops forever with 100% CPU.

Note: If one does not undo, Leo prints "Invalid paste: nodes may not descend
from themselves". I guess the undo circumvents such a check. However, that
should not be the case, as paste-retaining-clones inserts the clones _after_ and
not as children of the selected node "NewHeadline".

I guess that the undo forgets to set the selection back to "NewHeadline", so
that Leo tries to insert the clones after the undone child node - therefore as
child of "NewHeadline".

====================

EKR: only getLeoOutlineFromClipboar calls checkPaste.
</t>
<t tx="ekr.20120229094652.14759">The code that marks descendant @&lt;file&gt; nodes dirty now tests
p2.isAnyAtFileNode().  The old code tested p2.isAtThinFileNode().
</t>
<t tx="ekr.20120229094652.14760"></t>
<t tx="ekr.20120229094652.14761">CAUTION: new double click handling code

http://groups.google.com/group/leo-editor/browse_thread/thread/dbd63b9b38911906

The problem isn't single/double, but double click not stopping the
event processing.  It has the correct form:

if g.doHook('doubleClick1') is None:
   do-normal-double-click-stuff
g.doHook('doubleClick2')

but I think some other route through the code, or additional processing
of the event means that even thought the handler registered on
doubleClick1 returns non-None, the node goes into headline edit mode,
with focus.

This is bad, because the doubleClick1 on an @url node attempts to
select and raise a different commander (tab), so now you're looking at
one commander but focus is in another, so what you type trashes the
headline in the original commander.

The timer shouldn't be needed - a 'doubleClick1' hook which returns
non-None should stop the headline going into edit mode.  If you can
make that be the case, all is well.
</t>
<t tx="ekr.20120229094652.14762"></t>
<t tx="ekr.20120229094652.14763"></t>
<t tx="ekr.20120229094652.14764">- leoCommands.__init__ now sets self.db = {}
- initGlobalDB now returns {} instead of None if there is no cacher.
</t>
<t tx="ekr.20120229094652.14765">Important notes:
    
readOpenFile reads the private shadow file, detecting the encoding.
</t>
<t tx="ekr.20120229094652.14766">The call to w.see(ins+5) in rp_reformat created a big problem.

Replacing this with w.see(ins) is much better.
</t>
<t tx="ekr.20120229094652.14767"></t>
<t tx="ekr.20120229094652.14768"># A misspelling:
    
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 409, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 1967, in fullCommand
    c.macroCommands.startrecordingMacro(event)
AttributeError: macroCommandsClass instance has no attribute 'startrecordingMacro'
</t>
<t tx="ekr.20120229094652.14769">Examples:
    
    @edit C:/leo.repo/ipython-0.12/IPython/frontend/qt/console/pygments_highlighter.py
        # The filename comes from g.app.gui.runOpenFileDialog
    
    @file C:\leo.repo\ipython-0.12\IPython\frontend\qt\console\pygments_highlighter.py
        # Created by import.
        
The problem was the call to g.os_path_normpath in importDerived files:
    it converts slashes to backslashes on windows (!!)
</t>
<t tx="ekr.20120229094652.14770">- Added getLanguageFromAncestorAtFileNode.

- Revised code in at.scanAllDirectives &amp; leoQtColorizer.scanColorDirectives.
</t>
<t tx="ekr.20120229094652.14771"></t>
<t tx="ekr.20120229094652.14772">qtBody can use the leoBody code.
</t>
<t tx="ekr.20120229094652.14774"></t>
<t tx="ekr.20120229094652.14775">Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\plugins\quicksearch.py", line 187, in returnPressed
    self.scon.doSearch(t)
  File "c:\leo.repo\trunk\leo\plugins\quicksearch.py", line 289, in doSearch
    self.addBodyMatches(bm)
  File "c:\leo.repo\trunk\leo\plugins\quicksearch.py", line 257, in addBodyMatches
    self.its[it] = (p, None)
TypeError: unhashable type: 'QListWidgetItem'
</t>
<t tx="ekr.20120229094652.14776">The scrolledmessage plugin no longer exists.

The runScrolledMessageDialog *does* still exist, but it now uses the
viewrendered plugin.
</t>
<t tx="ekr.20120229094652.14777">Changed doButtons and doCommands kind handlers.

This allows us to put example nodes in leoSettings.leo.
</t>
<t tx="ekr.20120229094652.14778"></t>
<t tx="ekr.20120229094652.14779">Could this be done as part of abbreviation expansion?
</t>
<t tx="ekr.20120229094652.14780">Changed at.readEndOthers and at.readEndRef so that they
always set at.inCode = True
</t>
<t tx="ekr.20120229094652.14781">Fixed several encoding problems related to this thread: @shadow - @encoding windows-1250 - problem
http://groups.google.com/group/leo-editor/browse_thread/thread/a4ba80559447218a/9a37a4ed6c44d452

There were several real problems fixed.  The summary: @encoding directives were always required.

In detail:

1. at.initWriteIvars now checks for a Python # -*- coding: line.
   If present, it must be the very first line.
   If present, it will override any @encoding directives.

2. g.getPythonEncodingFromString now can deal with either of the following lines:

    @first # -*- coding: utf-8 -*-
    # -*- coding: utf-8 -*-

That is, g.getPythonEncodingFromString can strip the leading @first.

3. g.readlineForceUnixNewline and x.propagate_changes now catch UnicodeDecodeError.
   This is very important: previously decoding errors crashed Leo!.

All unit tests pass with both Python 2.x and 3.x.

</t>
<t tx="ekr.20120229094652.14782">Added configure_hard_tab_width method.
</t>
<t tx="ekr.20120229094652.14783">https://bugs.launchpad.net/leo-editor/+bug/800311

Having set undo to word granularity, I often change something, move to a
different line and continue editing there. When I want to undo my last change,
Leo also undoes the change in the other place, as word granularity currently
only recognises a new undo step when a new word is started, no matter if we
moved to a completely different position first.

The attached patch fixes the issue by remembering the previous cursor position.

Something else about the undo code:

- oldSel and newSel are never set to None in the constructor -&gt; it's quite hard
  to know they are there without reading the whole code

- It would be cool if there could be some more comments in that section; e.g. to
  tell that oldSel and newSel from which old_row, old_col, new_row and new_col
  actually mean: old = "the position right before doing the change" and new =
  "the position right after doing the change" and that old != "the position
  after the change before" (which I added as prevSel) - it took me ages to
  discover this

- There are duplicate "The new and old characters are not contiguous." checks.
  Are they different/necessary?

- The "We have just inserted a line." section is not only entered on a new line
  (see other attached patch)
</t>
<t tx="ekr.20120229094652.14784">https://bugs.launchpad.net/leo-editor/+bug/800312
</t>
<t tx="ekr.20120229094652.14785">https://bugs.launchpad.net/leo-editor/+bug/880975

Bug: The Meta+Ctrl section [of print-bindings] is always empty and this makes it
misleading.

Fix: the prefix list in k.printBindings must be sure that if two prefixes have a
common leading part the longer prefix appears first in the lists.
</t>
<t tx="ekr.20120229094652.14786">exception executing command
Traceback (most recent call last):
  File "/home/bob/bzrWork/pluginPath/leo/core/leoCommands.py", line 408, in doCommand
    val = command(event)
  File "/home/bob/bzrWork/pluginPath/leo/plugins/qtGui.py", line 4965, in cascade
    w.setGeometry(x,y,r.width(),r.height())
TypeError: setGeometry() takes exactly 2 arguments (5 given)
</t>
<t tx="ekr.20120229094652.14787"># A temporary fix while waiting for Terry's css work.
</t>
<t tx="ekr.20120229094652.14788">Here's how it works:  code that wants to set a particular part of a
widget's style sheet calls::

   g.app.gui.update_style_sheet(w,key,value)

where w is the widget whose stylesheet is to be changed, key is unique
to the method (or group of methods), and value is the new version of
the stylesheet **for the particular key** to be added.  Examples::

   # In setEditorColors.
   sheet = 'background-color: %s; color: %s' % (bg,fg)
   g.app.gui.update_style_sheet(obj,'colors',sheet)

   # In add_border.
   sheet = "border: %spx solid %s" % (
       c.focus_border_width,c.focus_border_color)
   self.update_style_sheet(w,'border',sheet)

   # In remove_border.
   sheet = "border: %spx solid white" % (c.focus_border_width)
   self.update_style_sheet(w,'border',sheet)

So add_border and remove_border work together because they use the
same 'border' key.

g.app.gui.update_style_sheet is straightforward: it injects a Python
dict called leo_stylesheet_dict into the widget, and computes the
total stylesheet as follows::

   # Step one: update the dict.
   d = hasattr(w,'leo_styles_dict') and w.leo_styles_dict or {}
   d[key] = value
   w.leo_styles_dict = d

   # Step two: update the stylesheet.
   aList = [d.get(key) for key in list(d.keys())]
   s = ';'.join(aList)
   w.setStyleSheet(s)
</t>
<t tx="ekr.20120229094652.14789">An attempt at fixing the scrolling bug
http://groups.google.com/group/leo-editor/browse_thread/thread/de76f22b16ebc8f/7f6aa691002f1fca

Private email from Viktor
test-leo-rev-4506.leo

It looks like I can reproduce the scrolling problem with your file as follows:

- Select the last node: AM-Session
- Manually scroll down to the last line.
- Click at the end of text: the body pane scrolls.  Bug!


Downloaded leo-editor-snapshot-201110240253.zip and tried it out. Noticed that
when I added a dozen or so blank lines at the end of a body pane and moved the
mouse cursor to the last line and left-clicked the body pane jumped backwards
about 10 lines or so as though I had scrolled up. When I dragged the scroll
button to the end of the pane, the insertion point was still at the end of the
pane. This does not happen for all panes.
</t>
<t tx="ekr.20120229094652.14792">The last time it happened:
    
- Search for something.
- Manually scroll the pane.
- Click scrolls the pane again.
</t>
<t tx="ekr.20120229094652.14817">
g.importFromPath ('html','C:/leo.repo/trunk/leo/modes/html.py')
returned the standard Python html module!

</t>
<t tx="ekr.20120229094652.14818"># The fix was to use lowercase versions of docPart,leoKeyword,nameBrackets.
</t>
<t tx="ekr.20120229094652.14819"></t>
<t tx="ekr.20120229094652.14820">Worked around docutils problem in writeToDocutils.
</t>
<t tx="ekr.20120229094652.14821">- The tests should not register the plugin.

- There should be a test that top-level code does not register the plugin.

Top-level calls to registerHandler:
    
    Fixed:
        examples/__overrideClasses.py
        examples/override_commands.py
        examples/redefine_put.py  (Tk)
        examples/chinese_menu.py
        examples/french_fm.py
    
        at_view.py
        test/failed_import.py
        scripts_menu.py
</t>
<t tx="ekr.20120229094652.14822">not written: c:\recent\data3.html
exception removing: 
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 5280, in remove
    os.remove(fileName)
WindowsError: [Error 3] The system cannot find the path specified: ''
</t>
<t tx="ekr.20120229094652.14823">There were two bugs:
    
- baseScannerClass.skipWsToken must not skip newlines!
- tokenize must add any remaining whitespace at the end of the loop.
</t>
<t tx="ekr.20120229094652.14824"># The code didn't work for c == None.
</t>
<t tx="ekr.20120229094652.14825"></t>
<t tx="ekr.20120229094652.14826">http://groups.google.com/group/leo-editor/browse_thread/thread/3c319daba37cd0ef

- Created a separate html importer, a very simple subclass of the xml scanner
  whose only difference is that it uses @data import_html_tags instead of @data
  import_xml_tags.

- The case of tags in @data import_html_tags and @data import_xml_tags no longer matters.

- checkTrialWrite now writes a file *with* sentinels, to handle @others correctly.
  It then removes the sentinels.
  
  This means that the import tests must use the correct @language directives.
  
- The import check now uses a token-based comparison.  
</t>
<t tx="ekr.20120229094652.14827">The fix was in g.pr:
    
Restored the call to sys.stdout.write(s2) (instead of print)

sys.stdout.write(s2) writes no additional newline at the end of s2.

Aha!  At last I know how to unit test g.pr, g.trace, etc.: redirect stdout!  Doh!
</t>
<t tx="ekr.20120229094652.14828"> File "/usr/fetching/leo-editor/leo/core/leoImport.py", line 2074, in
scanAndCompare
   n1,n2,ok = self.compareTokens(tokens1,tokens2)
 File "/usr/fetching/leo-editor/leo/core/leoImport.py", line 2094, in
compareTokens
   else:      kind1,val1 = 'eof','',n1
ValueError: too many values to unpack
</t>
<t tx="ekr.20120229094652.14829">- Created stand-alone unit tests from @test import dataN.html.
- All leoImport unit tests may now be run externally.
    The Python unit tests were failing because of intermixed tabs and blanks.
    This was fixed by putting @tabwidth -4 in all @test nodes for Python.
- Made sure lines are printed when unit tests fail unexpectedly.
- Added .js &amp; javascript entries to global data structures for javascript unit tests.
- Completed xmlScanner.filterTokens.
- Don't create declaration nodes for html.
- Make sure html tags are as expected.
- Ignore case of html/xml tags.

Rev 4774.1.1:
=============

Fixed all known html-import problems in a clean way. Unit tests exists, but they
use external files. They will be converted soon.

Important changes:

1. Added hasNestedClasses ivar in the baseScannerClass, True only for xml/html scanners.

When True, scanHelper and skipDecls allocate a substring to be used for all further scanning.
This is the *only* way to limit Leo's scanners properly.

This was, in essence, the fix for duplicate code generation arising from unbalanced tags:
skipToEndOfTag and skipToMatchingTag can't match outside the present tag because
the 's' argument passed to those methods has already been truncated.

This is a simple, elegant solution, and in essence the *only* proper solution.
For example, it would not work to past an 'end' argument to skipToEndOfTag and skipToMatchingTag
because the scanners inside those methods do not understand an 'end' argument.

Thus, the simplest, most efficient solution is for scanHelper and skipDecls to truncate the
string to be scanned. That way, the truncation happens at most once per "class".

2. Added hasDecls in the baseScannerClass, False only for xml/html scanners.

Various methods call skipDecls only if this ivar is True.

Rev 4773:
=========

Fixed recent botch: both single and double quotes are allowed in html. 

Rev 4772:
=========

Solved "between element" problem by extending classes up to the next class.
data.html imports "correctly", but not perfectly due to tag mismatches in
skipToMatchingTag.
</t>
<t tx="ekr.20120229094652.14831">http://groups.google.com/group/leo-editor/browse_thread/thread/421ebf4c3f2d5f59

Adding/deleting body editor 3 times hard-crashed Python

The changes were straightforward:
    
- set w.leo_label to None when calling unpackWidget.

- Test for w.leo_label before using it.

Added a minitest.  To test by hand, add the following @button nodes:
    
    @button add-ed
    w = c.frame.body.addEditor()
    
    @button del-ed
    w = c.frame.body.deleteEditor()
    
Click away in any order...

</t>
<t tx="ekr.20120229094652.14832">The new add-comments command adds the comment character at the leftmost column.

The new delete-comments command will remove the comment characters inserted by
either the old or new version of the add-comments command.
</t>
<t tx="ekr.20120229094652.14833">Example: ctrl-shift-home.

The fix was to set self.widget = contents in leoQtLog.selectTab.
</t>
<t tx="ekr.20120229094652.14834">- Added disabled code to inject event filter in TabbedFrameFactory.createFrame.

- Added cycle-tab-focus command.

- cycle-all-focus command uses cycleTabFocus as a helper: this greatly simplifies the code.
    
- Added binding for "Find" tab in leoQtLog.createTab.

- DynamicWindow.createFindTab injects leo_find_widget ivar for leoQtLog.createTab.

- Added isLogWidget to leoQtLog and nullLog classes.  They are helpers for cycleAllFocus.

- Revised leoQtLog.selectHelper: selecting a new tab does *not* change logCtrl (log.widget).

- Added bindings to Find tab
</t>
<t tx="ekr.20120229094652.14835"></t>
<t tx="ekr.20120229094652.14836">The safe default pane is the body pane.  It's also the simplest code.
</t>
<t tx="ekr.20120229094652.14837">The code must be careful that the log widget supports the HighLevelInterface.
</t>
<t tx="ekr.20120229094652.14838"></t>
<t tx="ekr.20120229094652.14839">The bug was in k.handleDefaultChar.  No substantial change made to eventFilter.
</t>
<t tx="ekr.20120229094652.14840">What I did:
    
1. Fixed major bug in settingsTreeParser.visitNode.
   It now does p.copy() to protect the callers traverals.
   This could have significant impacts on people's settings.
   
2. Added g.app.unitTestDict for unit testing.

3. Leo now extends the list of @buttons and @commands, rather than replacing them.
   This is reasonable only because leoSettings.leo should never define *active*
   buttons or commands.
</t>
<t tx="ekr.20120229094652.14841"></t>
<t tx="ekr.20120229094652.14842">https://bugs.launchpad.net/leo-editor/+bug/804960

When we clone a node inside an @shadow (containing @others) node and then
refresh the @shadow node from file, the clone is unlinked and marked as changed.
If we now save, close the .leo file and open it again, the nodes are linked
again! (showing "cloned" symbol) User's thought: "How the heck can the file
change _between save and re-open_ when I changed nothing?"

I think what should be done about this is the check that Leo does when it opens
the file again, and that check should be done immediately after the "refresh
node from file" operation. Also, at this point, the "Recovered nodes" node
should appear (if file and node have both changed), not only after the next .leo
file close/reopen (as that happens quite infrequently, I guess, e.g. once a day
for me). Otherwise, the user can easily lose data.
</t>
<t tx="ekr.20120229094652.14848">&gt;  File "/path/to/leo/core/leoImport.py", line 2070, in reportMismatch
&gt;    line = repr(lines2[i])
&gt; IndexError: list index out of range
</t>
<t tx="ekr.20120229094652.14849"></t>
<t tx="ekr.20120229094652.14850">The fix was to at.putBody.
</t>
<t tx="ekr.20120229094652.14855">has been modified outside of Leo. Overwrite this file?
http://groups.google.com/group/leo-editor/browse_thread/thread/daf581ace0de871e

Steps to reproduce:

- Create a node "@edit ~/aaa.txt" assuming aaa.txt does not exist
- Ctrl-S save outline, log reports creating ~/aaa.txt
- Edit text in body
- Ctrl-S save outline, pop-up pops-up erroneously.

The problem was that replaceTargetFileIfDifferent should set root.v.at_read.
Now it does.

Note: both replaceFileWithString methods are part of the @shadow logic,
so there is no need to set any at_read bit in those methods.
</t>
<t tx="ekr.20120229094652.14856">I loaded an outline with @auto nodes pointing to an out of date path. So body
texts were empty. I updated the paths in the node headlines and saved the file,
expecting to be prompted for overwriting the existing files (now the paths were
correct again), but they were over-written with the blank content without
warning. Damn.

Steps to reproduce in a simpler way below, but don't write the
below of as contrived, because the above is the real problem.

Create @auto /home/tbrown/text.txt

enter text, save file

Edit headline to @auto /home/tbrown/Desktop/text.txt

enter text, save file

Edit headline back to /home/tbrown/text.txt

-----

I now see this happens also if the path change is in a @path node ancestor of the @auto node.
</t>
<t tx="ekr.20120229094652.14891">DynamicWindow.setGeometry now does *not* change the window size when using the qttabs gui.

Added a comment to this effect in leoSettings.leo.
</t>
<t tx="ekr.20120229094652.14892">What I did:
    
- Fixed the Shift-Tab buglet by adding lower-case entries in app.tkNamesList
    This matches what is done in k.settingsNameDict.
- Created &lt;&lt; define global key dicts &gt;&gt; in leoApp.py.
- Changed si.val to si.stroke.
- Replaced g.bunch by GeneralSetting &amp; ShortcutInfo.
- Replaced bunchList by aList.
- Removed dynamic_menus "compile-time" constant.
- onAboutToShow now recomputes the contents of menus whenever menus are invoked.
- leo_update_shortcut now shows all shortcuts for a command.
- Wrote and tested merge_settings_dict.
</t>
<t tx="ekr.20120229094652.14893">Bug 879331: Redefining a key binding breaks menu items with same binding

https://bugs.launchpad.net/leo-editor/+bug/879331

&gt; Now I understand.  If I override the shortcut associated with the menu
&gt; item, in this case Alt-A, the menu breaks.

This is a serious bug!  The menu item now executes the command bound
to Alt-A!  Very bad.

=========

http://groups.google.com/group/leo-editor/browse_thread/thread/762e832909c3c530/d99d48eed45d1061

http://mail.google.com/mail/#inbox/1331909dd653f3c9

Redefining a binding, say for Alt-a, in x.leo will cause the sort-siblings menu
(bound to alt-a) to execute the command specified by the command bound to Alt-a!

https://bugs.launchpad.net/leo-editor/+bug/815564

This anomaly only occurs when all of the following conditions are true:

1) There is a global command name X that is the "same" as the root name of the
file containing a plugin Y. Here, "same" means equal after the command name is
converted to lower case and all underlines in the root name are replaced by
dashes.

2) A shortcut (a.k.a. keystroke) is bound to command name X.

When these conditions are true, then the Plugins dropdown menu shows the key
binding next to the plugin name and left-clicking the plugin name executes the
global command--and, there is no way to display the plugin's help.

Plugin Help Rendering: Plugin help is rendered by the viewrendered plugin, not
by the old scrolledmessage.py plugin.

Leo-editor revision: 4433
OS: Ubuntu 11.04 (natty)

Startup log pane:
Leo Log Window
Leo 4.9 final, build 4411, June 21, 2011
Python 2.7.1, qt version 4.7.2
linux2
</t>
<t tx="ekr.20120229094652.14894">https://bugs.launchpad.net/leo-editor/+bug/815564

===== Probably the same as bug 879331 =====

This anomaly only occurs when all of the following conditions are true:

1) There is a global command name X that is the "same" as the root name of the
file containing a plugin Y. Here, "same" means equal after the command name is
converted to lower case and all underlines in the root name are replaced by
dashes.

2) A shortcut (a.k.a. keystroke) is bound to command name X.

When these conditions are true, then the Plugins dropdown menu shows the key
binding next to the plugin name and left-clicking the plugin name executes the
global command--and, there is no way to display the plugin's help.

Plugin Help Rendering: Plugin help is rendered by the viewrendered plugin, not
by the old scrolledmessage.py plugin.

Leo-editor revision: 4433
OS: Ubuntu 11.04 (natty)

Startup log pane:
Leo Log Window
Leo 4.9 final, build 4411, June 21, 2011
Python 2.7.1, qt version 4.7.2
linux2
</t>
<t tx="ekr.20120229094652.14925">k.computeInversBinding() called by print-commands and for auto-completion.

k.bindKey sets k.bindingsDict.

k.bindKeyToDict sets k.masterBindingDict.
</t>
<t tx="ekr.20120229094652.14934">Created k.kill_one_shortcut, called from k.remove_conflicting_definitions.
</t>
<t tx="ekr.20120229094652.14941">The new TM.findMarkForUnitTestNodes allows both
TM.FindAllUnitTestsNodes and createOutline to be much simpler.
</t>
<t tx="ekr.20120229094652.14942"></t>
<t tx="ekr.20120229094652.14973">1. Enabled see, seeInsertPoint, get/setYScrollPosition.

2. (The fix): save/restore YScroll position in body.setSelectionAreas.

3. Added g.trace_see: g.trace_scroll already existed.

Failure case 1:
    - Search for something.
    - Manually scroll the pane.
    - Click scrolls the pane again.
    
Failure case 2:
    - reformat-paragraph.
</t>
<t tx="ekr.20120229094652.14975">Methods relating to this problem:

g.trace_scroll
w.see
w.seeInsertPoint
w.get/setYScrollPosition
p.restoreCursorAndScroll
v.restoreCursorAndScroll

leoKeyHandler:
    k.keykBoardQuit
    k.showStateAndMode
    k.setLabel
        ***** calls w.widget.ensureCursorVisible

leoQtBody:
    onFocusColorHelper
        ***** calls w.widget.ensureCursorVisible
        
leoQtBaseTextWidget:
    mouseReleaseEvent
        Added code that didn't work: now commented out.
        
leoEditCommands:
    updateAutoIndent
        ***** calls w.seeInsertPoint
</t>
<t tx="ekr.20120229094652.14976">http://groups.google.com/group/leo-editor/browse_thread/thread/de76f22b16ebc8f

As explained in detail in the thread, "dangerous" code is no longer executed immediately,
but instead executed at idle time using g.app.gui.runAtIdle.
</t>
<t tx="ekr.20120229094652.15012">Fixing this bug is important: it allows you to set a default
page width in myLeoSettings.leo for use, for example, in the
reformat-paragraph command.

Without a proper default c.page_width setting, you would have
to use @page_width instead, which is much less convenient.

The fix was the following lines in c.initConfigSettings:
    
    c.page_width = getInt('page_width') or 132
        # 2012/02/27: this appears to be a fix of an *ancient* bug.
</t>
<t tx="ekr.20120229094652.15013">The fix was easy: moveWithinLineHelper does *not* call
leoMoveCursorHelper for the case spot == 'end-line'
</t>
<t tx="ekr.20120229094652.15087">http://mail.google.com/mail/#inbox/1330f306b947656c

&gt; Maybe I'm missing something here, probably because I've always
&gt; dismissed scripting because I don't have the foggiest notion of how to
&gt; write one.

As you have just discovered, Leo does have scripting docs.

However, let me say a few words about scripting in *this* context.

What makes Leo scripting so important is that the predefined c, g and
p variables give *full* and *easy* access to all the data in your
outlines, as well as hundreds, if not thousands, of useful Python
functions in Leo's core.

You could say that these variables, especially c, define a *very*
easy-to-use DOM (Document Object Model) through which you can get o
set any data in *your** outlines.

The hello world example is::

   for p in c.all_positions():
       indent = '.' * p.level()
       print('%s%s' % (indent,p.h))

Here, c.all_positions() delivers a list of positions, and p.level()
and p.h deliver the indentation level and head string of position p.

Another crucial part of Leo scripting is that you can put Leo script
*anywhere* in a Leo outline.  You can do this in three ways:

1. You can just put the script above in the body of any node and run
it with Ctrl-B (execute-script).

2. You can make a script button by putting the script in an @button node.

3. You can make a new Leo command by putting the script in an @command node.

</t>
<t tx="ekr.20120229094652.15088"># aList = [z for z in dir(c) if 'hild' in z]
# aList.sort()
# for z in aList:
    # print(z)

c.insertHeadline(event=None, op_name='Insert Node', as_child=False)

x = g.BasicLeoScript()

x.insert()
x.delete()
x.node()
n.h, n.d

</t>
<t tx="ekr.20120229094652.15089">http://groups.google.com/group/leo-editor/browse_thread/thread/b17d140b7ceb8fc9

I've added web page bookmarking from your browser to Leo.

Docs., appended to the mod_http plugin, where this functionality lives,
are pasted below.

Screen shot of the form which pops up when you click the Bookmark
button in your browser attached.  The body text of the corresponding
bookmark node created in Leo is:

    Leo's Home Page
        http://webpages.charter.net/edreamleo/front.html

        Tags: leo, python

        Leo's Home Page

        Collected: Sun 02 Oct 2011 02:52:51 PM CDT

        Keep this under your pillow.

If you had some text selected on the page in your browser that would
also appear in the above, and repeatedly bookmarking the same page with
different selections incrementally adds such quotes to the bookmark
node.

Here are the docs.:

Can also be used for bookmarking directly from the browser to Leo.  To
do this, add a bookmark to the browser with the following URL / Location:

    javascript:w=window;if(w.content){w=w.content}; d=w.document; w.open('http://localhost:8130/_/add/bkmk/?&amp;name=' + escape(d.title) + '&amp;selection=' + escape(window.getSelection()) + '&amp;url=' + escape(w.location.href),%22_blank%22,%22toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no, width=800, height=300, status=no%22);void(0)

and edit the port (8130 in the example above) to match the port you're using
for mod_http.

Bookmarks are created as the first node in the outline which has been opened longest.
You can set the ``@string`` ``http_bookmark_unl`` to specify an alternative location,
e.g.::

    @string http_bookmark_unl = /home/tbrown/.bookmarks.leo#@bookmarks--&gt;Incoming

to place them in the `Incoming` node in the `@bookmarks` node in the `.bookmarks.leo` outline.

The headline is preceeded with '@url ' *unless* the ``bookmarks`` plugin is loaded.
If the ``bookmarks`` plugin is loaded the bookmark will have to be moved to a ``@bookmarks`` tree to be useful.

The browser may or may not be able to close the bookmark form window for you, depending on settings - set ``dom.allow_scripts_to_close_windows`` to true
in ``about:config`` in Firefox. 
</t>
<t tx="ekr.20120229094652.15090">http://groups.google.com/group/leo-editor/browse_thread/thread/4686ebad81bb1ea1
</t>
<t tx="ekr.20120229094652.15091">- Selecting any node using arrow keys shows the node in the outline immediately.

- Clicking a node or hitting &lt;return&gt; puts focus in body pane.

- Still to do: support Ctrl-G in Nav Tab.

groups.google.com/group/leo-editor/browse_thread/thread/e0ad60ae319359df/e932052a1ef6e9f5
NEW: find-quick-timeline

There are some Alt-X commands which put interesting lists of things
into the Nav pane.  I've just added a new one, find-quick-timeline.

Here's the complete list:

- find-quick-test-failures:
  Lists nodes in c.db.get('unittest/cur/fail')

- find-quick-timeline:
  Lists all nodes in reversed gnx order, basically newest to oldest, creation wise,
  not modification wise.

- history:
  Lists nodes from c.nodeHistory.
   
- marked-list:
  List all marked nodes.
  
=====

Kent: Really nice.

If all commands which put things in the nav pane were named nav_xxx:
that, and tab completion would obviate memorization ...
</t>
<t tx="ekr.20120229094652.15092">There is a collapse in complexity here that I just discovered: use
Alt-4 for all tests.

    unitTest.leo: bind Alt-4 to run-selected-unit-tests-externally
    leoPy.leo:    bind Alt-4 to run-marked-unit-tests-locally 

run-marked-unit-tests-externally is the simplest thing that could possibly work.
Bind Alt-4 to this command, marked just the desired tests and then run them with
one keystroke. Brilliantly simple.

Experience shows that being able to run the desired unit tests
*without* selecting any particular node makes an amazingly large
difference.  Being able to run all and only marked unit tests is a big
step forward.
</t>
<t tx="ekr.20120229094652.15093">As of rev 4725, unit testing in leoPy.leo feels *completely*
weightless.  The last change: running any unit test externally saves
the .leo file automatically first.

Thus, Alt-4 runs all desired unit tests immediately.  To select/
deselect unit tests, just mark/unmark @test nodes.

The difference in workflow is *huge*.  There is no need to select
@test nodes in any way, except for marking them.

So I create an @test node, make changes to that node, or to the code
being tested, and hit Alt-4.  Done.

When I am satisfied with the @test node, I can leave it where it is
(unmarked) or move it to unitTest.leo.

The energy difference between weightless and heavy is astounding.  Try
the new way: you will surely like it. 
</t>
<t tx="ekr.20120229094652.15095"></t>
<t tx="ekr.20120229094652.15096">Recent revs to to the trunk complete, with perhaps one or two small
additions to come, a grand redesign of all of Leo's @command/@button
nodes:

- Significant @command nodes now appear in:

   leoSettings.leo#@settings--&gt;Common @command nodes
   --&gt;@commands--&gt;@ignore

That is, they are define as common global @command nodes, but they
are ignored.  Move them to myLeoSettings.leo as needed.

- @buttons appear only local to specific files.  See leoSettings.leo
for check buttons and LeoDocs.leo for various preview buttons.

In other words, the new org uses @command for global scripts and
@button for local scripts.  This makes sense for two reasons.  First,
we can't use @button for global scripts because that would overwhelm
the icon area.  Second, using @button for local scripts draws
attention to scripts that only make sense in a local context.  It's
very effect.

</t>
<t tx="ekr.20120229094652.15097">I would prefer if it would be possible to launch tests externally without loading plug-ins.

As I see in Code--&gt;Testing--&gt;@file leoTest.py--&gt;runUnitTestLeoFile
and in Code--&gt;Testing--&gt;@file leoTest.py--&gt;class runTestExternallyHelperClass--&gt;runTests

there is an option to set gui for testing (g.app.unitTestGui) and default is 'nullGui'.

Maybe there could be an option to disable loading of plug-ins also ?

For the tests that I mostly write and run, loading plug-ins is just wasting time.
Vitalije.

===========================

&gt; I am not sure what happens at present, and I'm not sure whether any settings apply to these commands.

Good news (mostly): you can set up dynamic unit tests exactly the way you want.

I was going to point you at the documentation but (how can this
possibly be?) the documentation doesn't exist!  I really could have
sworn that everyone knew about what I am about to tell you ;-)  To
quote Alan Greenspan, "I'm shocked.  Shocked."

So here goes...

Let p be the presently selected node when you hit Alt-5
(run-unit-tests).  Leo, that is, the code in
runTestExternallyHelperClass, creates dynamicUnitTest.leo by
assembling all of the following nodes from p's descendants.

- All @test nodes,
- All @suite nodes, and, **most importantly**,
- All children of all @mark-for-unit-tests nodes.

You can use @mark-for-unit-test nodes to include any "supporting data"
you want, including, say, "@common test code" to be imported as
follows::

    exec(g.findTestScript(c,'@common test code'))

Hmm.  I doubt this is really written up properly, although I know for
sure at the time I did write it up on leo-editor.  It's a very cool
pattern.

Now here is the new trick.  It *should* work, but actually does *not*
work yet.  Boo hoo. Are you ready?

- @mark-for-unit-tests
  - @settings
    - @enabled-plugins

Alas, this doesn't work because the test code runs dynamicUnitTest.py,
which runs dynamicUnitTest.leo **using the leoBridge module**.  And,
as I have just verified, the leoBridge module doesn't load *any*
plugins.  Nor does it init any other settings.

So, no matter *what* @enabled-plugins contains, your code will start
off with no plugins at all.  Thus, the following unit test will always
pass when run with Alt-5::

    @test loaded-plugins

    pc = g.app.pluginsController
    aList = pc.getLoadedPlugins()
    assert not aList,aList

However, your tests *can* load plugins if they like, provided they
don't through an exception when loaded with nullGui.  For example, the
following test passes::

    @test load backlink plugin

    pc = g.app.pluginsController
    pc.loadOnePlugin('backlink.py')
    aList = pc.getLoadedPlugins()
    assert 'leo.plugins.backlink' in aList

A similar trick could probably be used to set c.config settings from
the @settings tree, but at present your code would have to do all the
work itself: the leoBridge module does **not** initialize settings.
That is, c.config.getBool(x) returns None for all (strings) x.

I hope this gives you a sense of what is going on.  For full details,
consult leoTest.py.

It has been fun tracking this down.  I'll fix the documentation immediately. 
</t>
<t tx="ekr.20120229094652.15098">http://groups.google.com/group/leo-editor/browse_thread/thread/92ae059cc5213ad3

I bear good tidings of great joy!

I recently received a new MacBook Pro and did a fresh upgrade to Mac
OS 10.7 (Lion). I then used the opportunity to test out installation
procedures of various software on a clean system. My main finding is
that the excellent Homebrew (mxcl.github.com/homebrew/) makes things
much easier these days.

Why Homebrew? It does not try to replace every single bit of
functionality on your Mac with their own version, like Macports or
fink. It reuses the existing libraries as far as possible. No need to
reinstall Python, for example (one of my pet gripes when people try to
install new software on their Macs, and the source of much confusion
and pain). It installs to /usr/local, the standard place to find
third-party libraries and headers, instead of the obscure /opt or /sw.
It's simple to use and to extend.

I last installed Leo on Mac OS 10.4 (Tiger) back in the Tk days, and
wondered what it looked like in Qt. All the horror stories of PyQT on
Mac discouraged me from trying this before, so I was keen to see if
Homebrew helps. Here is my installation write-up:

- Make sure you have Xcode installed
  (test it by confirming that "gcc" runs in the Terminal)

- In preparation for homebrew, the best option in my opinion is
  to delete /usr/local via::

  sudo rm -rf /usr/local

  and install any software in it via homebrew instead. If this step
  fills you with dread and you do not want to lose your beloved
  third-party software, the second-best option is to make sure you
  have write permission for the directory via::

  sudo chown -R &lt;your user name&gt;:admin /usr/local

  If you don't know your username, run "whoami". :-) This is
  useful because homebrew actually discourages you from
  installing third-party software as the superuser (the usual Mac
  apps in /Applications are also installed as the normal user,
  for that matter).

- Install Homebrew (http://mxcl.github.com/homebrew/) by running
  the following command in the Terminal::

  /usr/bin/ruby -e "$(curl -fsSL https://raw.github.com/gist/323731)"

- Run "brew update" to get the latest formulas

- Now install PyQT (yes, that's it!)::

  brew install pyqt

- Run "brew doctor" and check any further suggestions to improve
  your system.

- Add the following lines to your ~/.bash_profile
  (or ~/.profile on Leopard)::

  export PATH=/usr/local/bin:$PATH
  # This is for SIP (and PyQT) as suggested by Homebrew
  export PYTHONPATH=/usr/local/lib/python:$PYTHONPATH

- Open a new Terminal tab / window so that the above settings
  take effect, and install Leo. I downloaded the Leo-4.9-final-a.zip,
  unzipped it, and ran "python launchLeo.py" inside the Leo
  directory.

We should consider adding a Homebrew formula for Leo. This will
simplify the process even further, to simply "brew install leo". I
started on this, but wasn't sure where to put the various Leo files in
the system hierarchy. The Debian package can give some clues here, but
I haven't looked at it yet.

Ludwig
</t>
<t tx="ekr.20120229094652.15099">The prefix "DingDing" signifies that this post is an answer to the
lament:

    "Wouldn't it be great if we all could remember what we,
    and others, have already done :-)"

Last night I had a forehead-slapping moment: the place to put @button
nodes is in myLeoSettings.leo.

This morning, I realized that using @command rather than @button
completes the Aha.

This organization has all benefits, and no drawbacks:

- I always know here scripts are.

- No need for duplicates.

- I can organize the scripts within myLeoSettings.leo as usual using
organizer nodes.  This organization can change as needed.

- Using @command rather than @button means that I never have to
disable scripts.  No more @@button.

- Using @command saves screen real estate.  In my experience, having
buttons be visible doesn't prevent them from being hidden in full
view.

- If I use common prefixes, like c_ (for command) or edit_ (for edit-
related scripts) or ekr_ (for personal scripts), the *typing
completion* will let me zero in on the script I want to use:

    &lt;alt-x&gt; c_&lt;tab&gt;
    &lt;alt-x&gt; c_import&lt;tab&gt;

etc.  Furthermore, Ctrl-P (repeat-complex-command) will allow me to
rerun the last script run.  This is a quite common case.

Summary
=======

This Aha substitutes an *already-existing* usage (typing completion)
for a whole set of memory-intensive retrieval problems.  I'm not
likely ever to forget typing completion, although I might forget the
specif prefixes used in @command nodes.  If that happens, I'll know
where to look.

This Aha takes full advantage of Leo's organization strengths and
*concentrates* those strengths by putting all the to-be-organized
material in one place.  This allows for easy reorganization:  changing
command-name prefixes, for instance, would be straightforward.

This is another example of the assertion that Leo already has most of
what is required to handle any task. 
</t>
<t tx="ekr.20120229094652.15100">Overview of the code
====================

All notes refer to methods in class AutoCompleterClass unless otherwise noted.

- The autoComplete method is the entry point. It will be called
  when autocompletion is enabled and the user types either a period
  or ctrl-space (


The legacy autocompleter is eval based.

 uses Leo-specific code to when editing specific .leo files: leoDocs.leo, leoPlugins.leo, etc.
       
</t>
<t tx="ekr.20120229094652.15102">On Sep 10, 8:36 am, "Edward K. Ream" &lt;edream...@gmail.com&gt; wrote:

&gt; Later posts will discuss the following:
&gt; 
&gt; - Setting up to use ctags/codewise completion.

This section describes how to use Ville's codewise.py
module in leo\external folder.

**Note**: I've recently made a few changes to codewise.py. The
following discussion reflects the following changes:

- Changed docstring.

- The setup command does not crash if the ~/.ctags file already
  exist.
  
- The setup command does not call the init command, and thus does
  not delete ~/.codewise.db.
  
- Revised various print statements so they look better with Python 3.x.

**Important**: Leo's core contains all necessary autocompletion
code. In particular, enable *neither* the ctagscompleter.py
plugin *nor* the codewisecompleter.py plugin. I plan to remove
these plugins immediately, unless someone gives a good reason not
to do so.

**Important**: I've taken care to with the following
instructions, but there could be oversights or misunderstandings.
I would appreciate any corrections or additions.

Creating codewise/ctags data
============================

1. Make sure you have exuberant ctags (not just regular ctags)
   installed. It's an Ubuntu package, so its easy to install if
   you're using Ubuntu.
   
2. Execute the following commands from Leo's external/codewise.py
   module. **Note**: On Windows, you can use codewise.bat to
   execute these commands. For example::

        python &lt;path to leo&gt;\external\codewise.py %*
    
A. [Optional] Create a custom ~/.ctags file containing default
   configuration settings for ctags::
    
        codewise setup
        
    This command will leave the ~/.ctags file unchanged if it
    exists.  Othewise, the ``codewise setup`` command will
    create a ~/.ctags file containing the following defaults::
    
        --exclude=*.html
        --exclude=*.css
    
    http://ctags.sourceforge.net/ctags.html#FILES for more
    details about the .ctags file.
    
B. [Optional] Delete the existing ctags database in ~/.codewise.db::
   
        codewise init
        
C. Add ctags data to the existing ctags database::

        codewise parse &lt;path to directory&gt;
        
   You can add data from multiple sources by running
   the ``codewise parse`` command on multiple directories.
   
</t>
<t tx="ekr.20120229094652.15103">Leo's autocompletion suggests **completions**, text may be valid in a given
point, or **context** in source code. For example, suppose the context is::

    os.path.s
    
That is, suppose the cursor follows ``os.path.s`` in the body pane. The valid
completions are all the members of Python's os.path module whose names start with 's',
namely::

    samefile
    sameopenfile
    sep
    split
    splitdrive
    splitext
    splitunc
    stat
    supports_unicode_filenames
    sys
    
</t>
<t tx="ekr.20120229094652.15104">There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autocompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.
</t>
<t tx="ekr.20120229094652.15105">How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.
    


</t>
<t tx="ekr.20120229094652.15106">When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.
</t>
<t tx="ekr.20120229094652.15107">When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.
</t>
<t tx="ekr.20120229094652.15108">Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
</t>
<t tx="ekr.20120229094652.15109">Leo's autocompletion suggests **completions**, text may be valid in a given
point, or **context** in source code. For example, suppose the context is::

    os.path.s
    
That is, suppose the cursor follows ``os.path.s`` in the body pane. The valid
completions are all the members of Python's os.path module whose names start with 's',
namely::

    samefile
    sameopenfile
    sep
    split
    splitdrive
    splitext
    splitunc
    stat
    supports_unicode_filenames
    sys
    
Starting autocompletions
========================

There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autcompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.

Displaying autocompletions
==========================

How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.

Using the QCompleter
====================

When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.

Using the Log pane completer
============================

When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.

Showing docstrings
==================

Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
</t>
<t tx="ekr.20120229094652.15110">There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autocompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.
</t>
<t tx="ekr.20120229094652.15111">How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.
    


</t>
<t tx="ekr.20120229094652.15112">When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.
</t>
<t tx="ekr.20120229094652.15113">When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.
</t>
<t tx="ekr.20120229094652.15114">Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
</t>
<t tx="ekr.20120229094652.15115">Function and design
===================

Both the legacy and new completer now work *exactly* the
same way, because they both use the AutoCompleterClass to
compute the list of completions.

The strict "stateless" requirement means that the
"intermediate" completions must be entered into the body
pane while completion is active. It works well as a visual
cue when using the tabbed completer: indeed, the tabbed
completer would be difficult to use without this cue.

The situation is slightly different with the qcompleter.
Adding code before the user accepts the completion might be
considered an "advanced" feature. However, it does have two
important advantages, especially when "chaining" across
periods: it indicates the status of the chaining and it
limits what must appear in the qcompleter window.



</t>
<t tx="ekr.20120229094652.15116">Minor Autocompletion settings
=============================

These are found in leoSettings.leo: @settings--&gt;Autocompleter

- @bool use_codewise = False

True: use codewise completions.
False: use Leo-specific completions.

- @bool use_qcompleter = True

True:  show completions in a QCompleter popup.
False: show completions in Leo's Completions tab.
This option has effect only when using the qt or qttabs gui's.

The following options specify minor user preferences: they have little or no effect on the design or code of the autocompleter:

- @bool auto_tab_complete = False

True: Automatically extend the completed text to the longest common prefix of all completions.

- @bool autocomplete-brackets = False

True: When typing an opening bracket '(','[' or '{', immediately type the corresponding closing bracket.  To move past the closing bracket, just type it.

- @bool enable_calltips_initially = False

- @bool forbid_invalid_completions = False

True: Don't add characters during autocompletion that are not part of any computed completion.
</t>
<t tx="ekr.20120229094652.15117">Appearance
==========

There is little change to the legacy completer, except that
no text is highlighted in the body pane during completion.
This is calmer than before. Furthermore, there is no longer
any need for highlighting, because when the user types a
backspace the legacy completer now simply deletes a single
character instead of the highlighted text.

One minor change: the legacy completer now *does* insert
characters that do not match the start of any possible
completion. This is an experimental feature, but it might
play well with using codewise completions as a fallback to
Leo-related completions.

</t>
<t tx="ekr.20120229094652.15118">Why the codewise module
=======================

- This module supports modern code completion for the Leo editor.

- Exuberant ctags is an excellent code scanner, but TAGS file
  lookup sucks for "find methods of this class".
  
- This module puts all data in a single file, ~/.codewise.db by
  default. In contrast, TAGS files can exist all over the file
  system.

- The code in codewise.py is usable as a python module, or a
  command line tool.


Codewise completions
====================

The codewise-oriented completions appear to work well. In
large part, this is due to adding the global "self."
completions to all class-related completions (kind ==
'class' in ac.get_codewise_completions). This looks like a
really good hack, and it eliminates the need for the
ContextSniffer class.
</t>
<t tx="ekr.20120229094652.15119">Performance
===========

Performance of Leo-related completions is *much* better than
before. The old code used Python's inspect module and was
horribly complex. The new code uses eval and is perfectly
straightforward.

The present codewise-related code caches completions for all
previously-seen prefixes. This dramatically speeds up
backspacing. Global caching is possible because completions
depend *only* on the present prefix, *not* on the presently
selected node. If ContextSniffer were used, completions
would depend on the selected node and caching would likely
be impractical. Despite these improvements, the performance
of codewise-oriented completions is noticeably slower than
Leo-related completions.

Performance notes
=================

The ac.get_cached_options cuts back the prefix until it
finds a cached prefix. ac.compute_completion_list then uses
this (perhaps-way-too-long-list) as a starting point, and
computes the final completion list by calling
g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much
simpler and more robust than attempting to do "prefix AI"
based on comparing old and new prefixes. Furthermore, this
scheme is completely independent of the how completions are
actually computed. The autocompleter now caches options
lists, regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to
get_completions replace calls to
g.itemsMatchingPrefixInList. However, for short prefixes,
the list that g.g.itemsMatchingPrefixInList scans can have
thousands of items. Scanning large lists can't be helped in
any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the
completionDict does *not* define state (it is valid
everywhere) and no state variables had to be added. In
short, the new caching scheme is much better than before,
and it probably is close to optimal in most situations.

</t>
<t tx="ekr.20120229094652.15120">os.path.splitdrive.d_rule
os.path.join
</t>
<t tx="ekr.20120229094652.15121">Creating codewise/ctags data
============================

This is adapted from the thread: http://groups.google.com/group/leo-editor/browse_thread/thread/ac3f8789010c882e/ca01e7a803d2b546
"HOWTO: make Ville's autocompleter work.

1. Make sure you have exuberant ctags (not just regular ctags) installed.  It's an Ubuntu package, so it's easy to install if you're using Ubuntu.

2. All recent versions of Leo contain Ville's codewise module: leo/external/codewise.py

@pagewidth 60

Overview of the code
====================

All notes refer to methods in class AutoCompleterClass
unless otherwise noted.

- The autoComplete method is the entry point.  It will be called when autocompletion is enabled and the user types either a period or ctrl-space (


The legacy autocompleter is eval based.

 uses Leo-specific code to when editing specific .leo files: leoDocs.leo, leoPlugins.leo, etc.
       


Here are the contents of the discussion of autocompletion from the 4.9 release notes in LeoDocs.leo.  These should be folded into Leo's Users Guide: I'll do that today.

QQQQQ
 
Appearance
==========

There is little change to the legacy completer, except that
no text is highlighted in the body pane during completion.
This is calmer than before. Furthermore, there is no longer
any need for highlighting, because when the user types a
backspace the legacy completer now simply deletes a single
character instead of the highlighted text.

One minor change: the legacy completer now *does* insert
characters that do not match the start of any possible
completion. This is an experimental feature, but it might
play well with using codewise completions as a fallback to
Leo-related completions.

Function and design
===================

Both the legacy and new completer now work *exactly* the
same way, because they both use the AutoCompleterClass to
compute the list of completions.

The strict "stateless" requirement means that the
"intermediate" completions must be entered into the body
pane while completion is active. It works well as a visual
cue when using the tabbed completer: indeed, the tabbed
completer would be difficult to use without this cue.

The situation is slightly different with the qcompleter.
Adding code before the user accepts the completion might be
considered an "advanced" feature. However, it does have two
important advantages, especially when "chaining" across
periods: it indicates the status of the chaining and it
limits what must appear in the qcompleter window.

Codewise completions
====================

The codewise-oriented completions appear to work well. In
large part, this is due to adding the global "self."
completions to all class-related completions (kind ==
'class' in ac.get_codewise_completions). This looks like a
really good hack, and it eliminates the need for the
ContextSniffer class.

Performance
===========

Performance of Leo-related completions is *much* better than
before. The old code used Python's inspect module and was
horribly complex. The new code uses eval and is perfectly
straightforward.

The present codewise-related code caches completions for all
previously-seen prefixes. This dramatically speeds up
backspacing. Global caching is possible because completions
depend *only* on the present prefix, *not* on the presently
selected node. If ContextSniffer were used, completions
would depend on the selected node and caching would likely
be impractical. Despite these improvements, the performance
of codewise-oriented completions is noticeably slower than
Leo-related completions.

Performance notes
=================

The ac.get_cached_options cuts back the prefix until it
finds a cached prefix. ac.compute_completion_list then uses
this (perhaps-way-too-long-list) as a starting point, and
computes the final completion list by calling
g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much
simpler and more robust than attempting to do "prefix AI"
based on comparing old and new prefixes. Furthermore, this
scheme is completely independent of the how completions are
actually computed. The autocompleter now caches options
lists, regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to
get_completions replace calls to
g.itemsMatchingPrefixInList. However, for short prefixes,
the list that g.g.itemsMatchingPrefixInList scans can have
thousands of items. Scanning large lists can't be helped in
any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the
completionDict does *not* define state (it is valid
everywhere) and no state variables had to be added. In
short, the new caching scheme is much better than before,
and it probably is close to optimal in most situations.

QQQQQ

Part 2: New documentation

As I reread the release notes, I see that they are too code-oriented for the general reader.  What is needed are the following:

1. A discussion of Autocompletion settings in 
</t>
<t tx="ekr.20120229094652.15122">The following options specify minor user preferences: they have little or no
effect on the design or code of the autocompleter:

- @bool auto_tab_complete = False

True: Automatically extend the completed text to the longest common prefix of all completions.

- @bool autocomplete-brackets = False

True: When typing an opening bracket '(','[' or '{', immediately type the corresponding closing bracket.  To move past the closing bracket, just type it.

- @bool enable_calltips_initially = False

- @bool forbid_invalid_completions = False

True: Don't add characters during autocompletion that are not part of any computed completion.
</t>
<t tx="ekr.20120229094652.15123">Typing a period when @language python is in effect starts
autocompletion. Typing Return or Control-g (keyboard-quit) exits
autocompletion.

Autocompletion shows what may follow a period in code. (Actually
you can specify any character using the auto-complete shortcut
setting.) For example, after typing g. Leo will show a list of
all the global functions in leoGlobals.py. Autocompletion works
much like tab completion in the minibuffer. Unlike the
minibuffer, the presently selected completion appears directly in
the body pane.

A leading period brings up ‘Autocomplete Modules’. (The period
goes away.) You can also get any module by typing its name. If
more than 25 items would appear in the Autocompleter tab, Leo
shows only the valid starting characters. At this point, typing
an exclamation mark shows the complete list. Thereafter, typing
further exclamation marks toggles between full and abbreviated
modes.

If x is a list ‘x.!’ shows all its elements, and if x is a Python
dictionary, ‘x.!’ shows x.keys(). For example, ‘sys.modules.!’
Again, further exclamation marks toggles between full and
abbreviated modes.

During autocompletion, typing a question mark shows the docstring
for the object. For example: ‘g.app?’ shows the docstring for
g.app. This doesn’t work (yet) directly for Python globals, but
‘__builtin__.f?’ does. Example: ‘__builtin__.pow?’ shows the
docstring for pow.

Autocompletion works in the Find tab; you can use &lt;Tab&gt; to cycle
through the choices. The ‘Completion’ tab appears while you are
doing this; the Find tab reappears once the completion is
finished. Calltips

Calltips appear after you type an open parenthesis in code.
Calltips shows the expected arguments to a function or method.
Calltips work for any Python function or method, including
Python’s global functions. Typing Return or Control-g
(keyboard-quit) exits calltips.

Examples:

    ‘g.toUnicode(‘ gives ‘g.toUnicode(s, encoding, reportErrors=False’
    ‘c.widgetWantsFocusNow’ gives ‘c.widgetWantsFocusNow(w’
    ‘reduce(‘ gives ‘reduce(function, sequence[, initial]) -&gt; value’

The calltips appear directly in the text and the argument list is highlighted so you can just type to replace it. The calltips appear also in the status line for reference after you have started to replace the args.

Options

Both autocompletion and calltips are initially enabled or disabled by the enable_autocompleter and enable_calltips settings in leoSettings.leo. You may enable or disable these features at any time with these commands: enable-auto-completer-command, enable-calltips-command, disable-auto-completer-command and disable-calltips-command.
The minibuffer

The mini-buffer is a text area at the bottom of the body pane. You use it like the Emacs mini-buffer to invoke commands by their so-called long name. The following commands affect the minibuffer:

    full-command: (default shortcut: Alt-x) Puts the focus in the minibuffer. Type a full command name, then hit &lt;Return&gt; to execute the command. Tab completion works, but not yet for file names.

    universal-argument: (default shortcut: Alt-u) Like Emacs Ctrl-u. Adds a repeat count for later command. Ctrl-u 999 a adds 999 a’s.
    keyboard-quit: (default shortcut: Ctrl-g) Exits any minibuffer mode and puts the focus in the body pane.

For example, to print a list of all commands type Alt-X print-commands &lt;Return&gt;.

The following sections list the various commands that you can invoke from the minibuffer. Important: you may bind keystrokes to any of these commands. See Customizing Leo for full details.
</t>
<t tx="ekr.20120229094652.15125">http://groups.google.com/group/leo-editor/browse_thread/thread/b560a3b84e7ec7a8

Good news (mostly): you can set up dynamic unit tests exactly the way you want.

I was going to point you at the documentation but (how can this
possibly be?) the documentation doesn't exist!  I really could have
sworn that everyone knew about what I am about to tell you ;-)  To
quote Alan Greenspan, "I'm shocked.  Shocked."

So here goes...

Let p be the presently selected node when you hit Alt-5
(run-unit-tests).  Leo, that is, the code in
runTestExternallyHelperClass, creates dynamicUnitTest.leo by
assembling all of the following nodes from p's descendants.

- All @test nodes,
- All @suite nodes, and, **most importantly**,
- All children of all @mark-for-unit-tests nodes.

You can use @mark-for-unit-test nodes to include any "supporting data"
you want, including, say, "@common test code" to be imported as
follows::

    exec(g.findTestScript(c,'@common test code'))

Hmm.  I doubt this is really written up properly, although I know for
sure at the time I did write it up on leo-editor.  It's a very cool
pattern.

Now here is the new trick.  It *should* work, but actually does *not*
work yet.  Boo hoo. Are you ready?

- @mark-for-unit-tests
  - @settings
    - @enabled-plugins

Alas, this doesn't work because the test code runs dynamicUnitTest.py,
which runs dynamicUnitTest.leo **using the leoBridge module**.  And,
as I have just verified, the leoBridge module doesn't load *any*
plugins.  Nor does it init any other settings.

So, no matter *what* @enabled-plugins contains, your code will start
off with no plugins at all.  Thus, the following unit test will always
pass when run with Alt-5::

    @test loaded-plugins

    pc = g.app.pluginsController
    aList = pc.getLoadedPlugins()
    assert not aList,aList

However, your tests *can* load plugins if they like, provided they
don't through an exception when loaded with nullGui.  For example, the
following test passes::

    @test load backlink plugin

    pc = g.app.pluginsController
    pc.loadOnePlugin('backlink.py')
    aList = pc.getLoadedPlugins()
    assert 'leo.plugins.backlink' in aList

A similar trick could probably be used to set c.config settings from
the @settings tree, but at present your code would have to do all the
work itself: the leoBridge module does **not** initialize settings.
That is, c.config.getBool(x) returns None for all (strings) x.

I hope this gives you a sense of what is going on.  For full details,
consult leoTest.py.

It has been fun tracking this down.  I'll fix the documentation immediately. 
</t>
<t tx="ekr.20120229094652.15127">Terry:

I don't think the OP was trying to import MORE data, I think Leo is
incorrectly trying to apply MORE rules on loading a .txt file.

The File-&gt;Import command gives no indication it expects MORE data.

OTOH, the simple workaround is to use File-&gt;Open.

So perhaps it's a documentation / ui bug to clarify what File-&gt;Import
is for.


==============

Rob:
    
I would agree the documentation could be updated to reflect current
practice. The online docs (under the heading 'Importing Files Into Leo
Outlines':

The Import commands do not attempt to do perfect translations; they
merely automate the bulk of the drudgery:

   The Import to @file command creates an @file node from a file.
   The Import CWEB Files command creates an @file node from a CWEB file.
   The Import noweb Files command creates an @file node from a noweb file.
   The Import External File command imports all the nodes in a external file into the outline. Unlike the read commands, the command preserves no outline structure.
   The Import Flattened Outline command converts plain text written in MORE format to an outline.

The Import Flattened Outline command brings up a
dialog.................(more info about MORE spec)

I would say most/all of this has been deprecated as there's only one
Import command.
</t>
<t tx="ekr.20120229094652.15128">http://groups.google.com/group/leo-editor/browse_thread/thread/92ae059cc5213ad3

I bear good tidings of great joy! 

I recently received a new MacBook Pro and did a fresh upgrade to Mac
OS 10.7 (Lion). I then used the opportunity to test out installation
procedures of various software on a clean system. My main finding is
that the excellent Homebrew (mxcl.github.com/homebrew/) makes things
much easier these days.

Why Homebrew? It does not try to replace every single bit of
functionality on your Mac with their own version, like Macports or
fink. It reuses the existing libraries as far as possible. No need to
reinstall Python, for example (one of my pet gripes when people try to
install new software on their Macs, and the source of much confusion
and pain). It installs to /usr/local, the standard place to find
third-party libraries and headers, instead of the obscure /opt or /sw.
It's simple to use and to extend.

I last installed Leo on Mac OS 10.4 (Tiger) back in the Tk days, and
wondered what it looked like in Qt. All the horror stories of PyQT on
Mac discouraged me from trying this before, so I was keen to see if
Homebrew helps. Here is my installation write-up:

- Make sure you have Xcode installed
  (test it by confirming that "gcc" runs in the Terminal)

- In preparation for homebrew, the best option in my opinion is
  to delete /usr/local via::

  sudo rm -rf /usr/local

  and install any software in it via homebrew instead. If this step
  fills you with dread and you do not want to lose your beloved
  third-party software, the second-best option is to make sure you
  have write permission for the directory via::

  sudo chown -R &lt;your user name&gt;:admin /usr/local

  If you don't know your username, run "whoami". :-) This is
  useful because homebrew actually discourages you from
  installing third-party software as the superuser (the usual Mac
  apps in /Applications are also installed as the normal user,
  for that matter).

- Install Homebrew (http://mxcl.github.com/homebrew/) by running
  the following command in the Terminal::

  /usr/bin/ruby -e "$(curl -fsSL https://raw.github.com/gist/323731)"

- Run "brew update" to get the latest formulas

- Now install PyQT (yes, that's it!)::

  brew install pyqt

- Run "brew doctor" and check any further suggestions to improve
  your system.

- Add the following lines to your ~/.bash_profile
  (or ~/.profile on Leopard)::

  export PATH=/usr/local/bin:$PATH
  # This is for SIP (and PyQT) as suggested by Homebrew
  export PYTHONPATH=/usr/local/lib/python:$PYTHONPATH

- Open a new Terminal tab / window so that the above settings
  take effect, and install Leo. I downloaded the Leo-4.9-final-a.zip,
  unzipped it, and ran "python launchLeo.py" inside the Leo
  directory.

We should consider adding a Homebrew formula for Leo. This will
simplify the process even further, to simply "brew install leo". I
started on this, but wasn't sure where to put the various Leo files in
the system hierarchy. The Debian package can give some clues here, but
I haven't looked at it yet.

Now I just have to start using Leo after all these years of checking
it out... :-)

</t>
<t tx="ekr.20120229094652.15130">I want to learn about PyQt and leo's qtGui. As a first step,
I'm trying to execute a script from within a leo body::

    from PyQt4 import QtGui
    w = QtGui.QWidget()
    w.resize(250, 150)
    w.move(300, 300)
    w.setWindowTitle('Simple test')
    w.show()

Q. When I try the above, I see a window appear and then
immediately disappear. How can I keep the window visible?

A. When the script exits the sole reference to the window,
w, ceases to exist, so the window is destroyed (garbage
collected). To keep the window open, add the following code
as the last line to keep the reference alive::

    g.app.scriptsDict['my-script_w'] = w

Note that this reference will persist until the next time
the execute-script command is run.  If you want something even
more permanent, you can do something like::

    g.app.my_script_w = w
</t>
<t tx="ekr.20120229094652.15131">From Brian Theado

The other day I stumbled across Ville's code in scripts.leo which displays the
output of python's trace module in a leo outline. The output of the trace module
is not very friendly and I didn't find the result very usable. I was inspired to
write some code to translate the output so the tree of function calls is
displayed via Leo headlines. Thanks to Ville for sharing that code. I never
would have figure this out without that starting point.

Just copy (Ctrl-Shift-V) the child outline into a leo outline and hit ctrl-b on
the "call tree" node. The execution tree of the 'scroll-outline-up-line'
minibuffer command will be displayed to stdout and also as a tree of leo
headlines.
</t>
<t tx="ekr.20120229094652.15132">import trace

@language python
@others

# http://docs.python.org/library/trace.html for documentation
# on the trace module
tracer = trace.Trace(countcallers=1)

# Trace a minibuffer command.

# Any function call will work. Leo's minibuffer commands are easily discoverable
# via tab completion and the 'print-commands' command.

#tracer.runfunc(c.executeMinibufferCommand, 'goto-prev-node')
tracer.runfunc(c.executeMinibufferCommand, 'scroll-outline-up-line')

top = p.insertAsLastChild().copy()
top.h = 'trace session'
displayCalltree(top, tracer.results().callers.keys())
c.redraw()
</t>
<t tx="ekr.20120229094652.15133">def displayCalltree(p, callinfo):
   '''
   Converts the function call hierarchy in 'callinfo' into a tree of function
   calls.  The function call tree is displayed to stdout as indented text
   and is inserted as a tree of leo nodes rooted at the given position 'p'
   '''
   callers = [k[0] for k in callinfo]
   callees = [k[1] for k in callinfo]

   # The first set of children will be those that don't have any callers
   # listed in callinfo
   toplevels = list(set(callers) - set(callees))
   positions = {}
   path = []

   # Depth-first traversal of the call hierarchy represented by 'callinfo'
   # 'levels' is a stack which grows during descend and shrinks
   # during ascend.  Each element of 'levels' is a list of unprocessed
   # siblings of each other
   levels = [toplevels]
   while len(levels) &gt; 0:
       while len(levels[-1]) &gt; 0:
           # Process the first element in the 'deepest' (i.e. last) list of siblings
           cur = levels[-1][0]
           levels[-1] = levels[-1][1:]
           indent = " " * 4 * (len(levels)-1)
           if cur not in path:
               if cur in positions.keys():
                   # Function already seen, so make a clone
                   clone = positions[cur].clone()
                   clone.moveToLastChildOf(p)
                   print (indent + "%s %s ..." % cur[1:])
               else:
                   # Haven't seen this function, so insert a new headline
                   p = p.insertAsLastChild().copy()
                   p.h = "%s %s" % cur[1:]
                   print (indent + p.h)

                   # Remember the position so it can be cloned if seen again
                   positions[cur] = p

                   # Find all callees of this function and descend
                   levels.append([c[1] for c in callinfo if c[0] == cur])
                   path.append(cur)
           else:
               r = p.insertAsLastChild().copy()
               r.h = "(recursive call) %s %s" % (cur[1], cur[2])
               print(indent + r.h + "...")

       # Ascend back up one level
       path = path[0:-1]
       p = p.parent()
       levels = levels[0:-1]
</t>
<t tx="ekr.20120229094652.15134"></t>
<t tx="ekr.20120229094652.15135">http://groups.google.com/group/leo-editor/browse_thread/thread/f13fadac68eec41b/9124ba6d733ecbad
leoInspect: a hobby with a future?

http://groups.google.com/group/leo-editor/browse_thread/thread/62f0e7b84a25e0d0/39f848ad8a96bcbc
leoInspect: remarkable collapse in complexity and attempted assessment

</t>
<t tx="ekr.20120229094652.15137">http://groups.google.com/group/leo-editor/browse_thread/thread/61019e45d75a6f18/71ee770ee4421222


Once you have the 4.9 "official release" working, then further updates are simply:

(ongoing practice - keep your folder containing your leo
code - separate from your .mySettings.leo and any data
files, .leo and otherwise.)

1. archive and remove that app folder
2. download the nightly snapshot zip file
3. unzip it into the same place
4. enjoy your up-to-date Leo code. . .
</t>
<t tx="ekr.20120229094652.15138">http://groups.google.com/group/leo-editor/browse_thread/thread/5fdadfba113e12d9/fa329534654ecfec

Leo now reports bzr version numbers and dates more accurately.
</t>
<t tx="ekr.20120229094652.15139">

Note: in rev 4990, the g.app.newCommander method (formerly called
g.app.newLeoCommanderAndFrame) also returns a single value (a
Commander) rather than the tuple (c,c.frame). 
</t>
<t tx="ekr.20120229094652.15140">http://groups.google.com/group/leo-editor/browse_thread/thread/dd5907529208ee98

Revs 5037/8 contain fixes that allow the open-with command to start to
work, at least in 'subprocess.Popen' mode.

However, I think it is time for a complete rethink of how users
specify open-with settings.

===== The problems

1. The format of settings in @openwith nodes is way too wonky.  At
present, the body text of such nodes consists of a single line, which
contains a 3-tuple of elements. Let us call this line the **open-with
line**.

The entire open-with line must be a valid Python tuple.  This causes
problems for both user and implementation, as discussed more fully
below.

2. openTempFileInExternalEditor is the method that translates the
settings in @openwith nodes into code that actually open the temp file
with the desired editor.  At present, this method has to do an
**eval** of the single @openwith line, which has lots bad
consequences:

- eval is a slight security problem, although there are a gazillion
worse problems.

- The user has to quote strings, and those quotes are removed by eval,
so there is no easy way to specify quoted strings (the user has to
*doubly* quote strings.)

- There is no indication of what the parts of the open-with line mean.

3. At present, openTempFileInExternalEditor does some ridiculously-
complicated munging of the *eval'd* open-with line in order to get
produce the correct call to subprocess.Popen.  It's possible that
there is an easier way, but I haven't found it yet.

===== A proposed solution

1. We need a much more user-friendly format for @openwith nodes.  Let
us suppose that the body of @openwith nodes contains one or more lines
of the following form::

   tag: value

The possible tags will be::

- kind: &lt;a string&gt;

The value specifies the **opener logic**, that is, the method used to
launch the external editor, one of
('subprocess.Popen','os.system','os.startfile','os.spawnl','os.spawnv',
'exec')

- arg: &lt;a string&gt;

There may be many such arg lines. Each line will be a string to be
passed as an argument to the opener logic, in a format that is
compatible with the specified opener logic.

**Important**: quotes in &lt;a string&gt; will be *retained* (not eval'd),
allowing the user to specify exactly the arguments to be passed to
opener logic.

- custom: &lt;a string&gt;

Here, &lt;a string&gt; *will* be eval'd, yielding an object to be used as
the opener logic.

It's likely that either the "custom" tag or the "exec" opener value is
redundant.

===== Summary

The present scheme is wonky, confusing, inflexible and extremely
difficult to implement. It should be replaced immediately.
</t>
<t tx="ekr.20120229094652.15142">http://groups.google.com/group/leo-editor/browse_thread/thread/808ba29fec64e590

For almost 15 years Leo has been written using a limited set of
classes.  These were "big" classes, implementing major modules of
Leo.  There is nothing wrong with these classes, and they will remain
unchanged, except insofar as they will be simplified by the classes I
am about to discuss.

Recently, I have become aware that Leo's code could be considerably
simplified by adding "smallish" classes.  Indeed, I now think the
distinction between big and small classes is unhelpful.  The most
important part of the design of a class is simply whether a class
implements an understandable concept.

With this introduction, here is a short summary of Leo's new classes.
Some have not been fully implemented.  Getting them all to work is a
big part of the rewrite of Leo's config, loading and key-handling
code.

===== LoadManager

This class handles all the messy details of loading .leo files at
startup.  That's its *purpose*.

At the code level, it encapsulates almost all the code in runLeo.py,
as well as some methods in leoGlobals.py that really belong somewhere
else.  Creating a class simplifies the code to a surprising degree: 5
or 6 ivars of the class represent command-line options.  These ivars
are always available: there is no need to pass them around as
arguments.

Defining a new class means that it might be possible to reuse this
code in the leoBridge module, which would eliminate a lot of duplicate
code.

===== ModeController and ModeInfo

The ModeController class represents a collection of modes.  The
ModeInfo class represents a single mode.

Without these classes, the code in leoKeys.py is extremely hard to
understand.  In fact, the present code is a perfect example of the
problems with procedural programming: client code is burdened with
knowing way too many details about matters that it shouldn't have to
know about.  Furthermore, that data itself is hard to understand:
it's too "raw".  These classes provide "identity" for data.  The value
of repr(aModeInfo) is surprisingly large.

===== LogManager

This class represents the global log.  It hides the details of the log
from the g.app class and several other pieces of code.

At present, the interface to this class is procedural.  That is, the
present g.app methods that will be moved into this class have a
procedural rather than descriptive nature.  I'm not sure how much this
will change, but creating this class may create opportunities that
were not apparently previously.

===== KeyStroke and ShortcutInfo

I've discussed these previously.  The KeyStroke class is a wrapper for
plain strings.  It's most important attribute is its *identity*.  It
announces that its contents is a canonicalized value, not a raw user
settings string or any other kind of data associated with key
handling.

Similar remarks apply to ShortcutInfo objects.  Their identity
clarifies the code.  The former code used g.bunches.  In complex code
such as leoKeys.py, such anonymous objects really obfuscate matters.

===== EditCommandsManager

I wrote and tested this class last night.  It solves a problem that
has been annoying me ever since I created leoEditCommands.py.  The
problem is this:  without this class the classesList has to be defined
at the end of the module, after all classes have been imported.
Worse, several module-level methods were needed to manage the
classesList.

In the new scheme, each Commander creates an EditCommandsManager, and
the code that previously had to call the module-level method
leoEditCommands.x(c) now simply calls c.editCommandManager.x().  This
is much cleaner and avoids several very ugly imports.  Which brings me
to...

===== Avoiding imports of Leo files

I would like to avoid having Leo's modules import each other wherever
possible.  This would simplify Leo's startup process considerably.

At present, the ctor for the Commands class imports many modules.
This is essential to break what would otherwise be circular
dependencies among Python imports.  We can extend this pattern by
creating more classes, as was done with the EditCommandsManager class.

I'm not sure exactly how this will play out, but removing circular
imports between Leo's module seems like a worthy goal.  The leoGlobals
module is an important exception.  All of Leo's modules do::

   import leo.core.leoGlobals as g

To make this work, it is *essential* that leoGlobals.py import *no*
other Leo modules.

===== A new (limited!) use for section references

I am going to create a new section in leoGlobals.py called &lt;&lt; global
switches &gt;&gt;  It will contain code such as:

   new_load = False # True: .leo files are loaded at most once.
   if new_load: print('***** new_load')

   new_modes = False # True: use ModeController and ModeInfo classes.
   if new_modes: print('***** new_modes')

This section is useful because I can clone it.  I can then enable and
disable switches in the clone, without having to keep "@file
leoGlobals.py" visible.  Very handy.
</t>
<t tx="ekr.20120229094652.15143"></t>
<t tx="ekr.20120229094652.15144">leoSettings.leo:

table = (
        # First, leoSettings.leo in the home directories.
        join(g.app.homeDir,     settings_fn),
        join(g.app.homeLeoDir,  settings_fn),

        # Next, &lt;machine-name&gt;leoSettings.leo in the home directories.
        # join(g.app.homeDir,     machine_fn),
        # join(g.app.homeLeoDir,  machine_fn),

        # Last, leoSettings.leo in leo/config directory.
        join(g.app.globalConfigDir, settings_fn)
    )

myLeoSettings.leo:

    table = (
        # First, myLeoSettings.leo in the local directory
        join(localDir,          settings_fn),

        # Next, myLeoSettings.leo in the home directories.
        join(g.app.homeDir,     settings_fn),
        join(g.app.homeLeoDir,  settings_fn),
    
        # Next, &lt;machine-name&gt;myLeoSettings.leo in the home directories.
        join(g.app.homeDir,     machine_fn),
        join(g.app.homeLeoDir,  machine_fn),

        # Last, leoSettings.leo in leo/config directory.
        join(g.app.globalConfigDir, settings_fn),
    )
</t>
<t tx="ekr.20120229094652.15146">http://groups.google.com/group/leo-editor/browse_thread/thread/c933b28c27d3b9a7

Ref 4952 of the trunk fixes bug 87933:
"Redefining a key binding breaks menu items with same binding"

This was a difficult bug to fix--I rewrote significant parts of Leo's
code that deals with settings for key binding.

All unit tests pass, and I have been using this code happily for a few
days, but significant problems could be lurking.  Please use caution
and please report any problems immediately, especially settings-
related problems.

Besides fixing the bug, Leo computes accelerators, in menu items
dynamically when the user activates a menu.  The accelerator shows
*all* keys bound to the command associated with the menu item.

In the next few days I'll be simplifying the new code further, so if
you want more stable code please stay away from the trunk and the
nightly builds for the next several days.

Here is the checkin log:

A major reorganization of the configuration code that fixes bug 87933
Redefining a key binding breaks menu items with same binding

- Replaced g.bunches with ShortcutInfo objects, and bunchList name by
aList followed by
  assert isinstance(si,ShortcutInfo),si

  Using ShortcutInfo objects rather than g.bunch was a big win.

- Wrote and tested make_settings_dict and its helpers,
merge_settings_dicts, invert and uninvert.

- Leo computes menu texts dynamically in onAboutToShow.

- leo_update_shortcut now shows all shortcuts for a command.

- leoMenu.define_enable_dict encapsulates data used to enable/disable
commands regardless
  of where those commands appear in Leo's menu. The old code assumed
that a fixed menu
  location for all commands that could be enabled or disabled.

- Removed dynamic_menus "compile-time" constant.

- Created &lt;&lt; define global key dicts &gt;&gt; in leoApp.py.

  This is a duplicate of dicts in leoKeys.py: they will be merged
later today
  in a location to be determined.

- Added unused ShortcutName and ShortcutsDict classes.

  The ShortcutName class will go away: it's methods may become methods
of the ShortcutInfo class.
  Alternatively, the methods might stay where they are.

  The ShortcutsDict class *will* become functional: it's the only way
to eliminate the wretched
  _hash hack used in the present raw key dictionaries. Furthermore,
the ShortcutsDict class
  will probably encapsulate inverted dicts. 
  
=====

&gt; Ref 4952 of the trunk fixes bug 87933:
&gt; "Redefining a key binding breaks menu items with same binding"

&gt; This was a difficult bug to fix--I rewrote significant parts of Leo's
&gt; code that deals with settings for key binding.

I am now in the midst of some long-overdue simplification that has
been made possible with the new code:

1. Leo now (provably) no longer uses the very complex g.app.config.get/
set code for shortcuts.

2. The new k.kill_one_shortcut allows k.registerCommand to properly
override settings.  For example, File:New is no longer bound to Ctrl-N
when the following becomes active::

    @button test @key=Ctrl-N

k.kill_one_shortcut uses the invert/uninvert trick used in
merge_settings_dict.  Only this kind of elegant code has a chance of
working reliably.

3. As mentioned in another thread, k.tkbindingFromStroke is about to
make its exit.

4. I'll be making several other simplifications to the config code in
the next several days.  It is important to do it now while all the
complexities are fresh in my mind. 
</t>
<t tx="ekr.20120229094652.15147">End going to only physical line and not to the logical (wrapped) one)... 
</t>
<t tx="ekr.20120229094652.15148">http://groups.google.com/group/leo-editor/browse_thread/thread/d36d76174dcd6786

Currently I am using Leo as an outliner for the elaboration of
documents with LaTeX. For this, I work with @rst nodes and Sphinx. It
works really wonderful.

When using citations, Sphinx and RsT offer a certain syntax that, as
far as I have understood, does allow only for the generation of
"simple", Leo-self-contained citation references (inside of say a "Leo
References Section" node).

So I use a citation of the form   [CITBook001]_ inline in the text.
Somewhere else in the same Leo outline I have the corresponding
description as:

.. [CITBook001] A citation as well-known

When using LaTeX and BibTeX, I would like to use inside of Leo a kind
of LaTeX-inline-markup, that after generation of the RsT file through
Sphinx as well as after  running of "make latex", it generates a LaTeX
file containing the citation call of the form \cite{CITBook001} as
described in a file *.bib.  The only way I follow today is the later
editing by hand of the LaTeX file. This is of course not the best way.
How to convince Leo/Sphinx/RsT to generate the inline raw latex
syntax? It could be very simple, but ... I haven not been able to see
it.

Any hints? 

=====

&gt; How to convince Leo/Sphinx/RsT to generate the inline raw latex
&gt; syntax?

http://docutils.sourceforge.net/docs/ref/rst/directives.html#raw-data...

?

Cheers -Terry 

=====

I followed the recommendations of Terry. It was much easier
as I thought! Here a summary of the use of custom roles in
Leo to generate LaTeX "inline markup" from Leo:

+ @ rst-no head Defining the custom role, here applicable to html and
latex syntax
   .. role:: raw-role(raw)
      :format: html latex

+ @A document section
   This is my text including an example of inline markup for
generating :raw-role:`\LaTeX\` from Leo. For more details see
:raw-role:`\cite{rstDocumentation}`. Of course, my bib database below will
describe this citation with plenty of details.

+ @rst-no-head Including the bib database
   .. raw:: latex

      \bibliographystyle{acm}
      \bibliography{myBibliography}

It worked really fine! 
</t>
<t tx="ekr.20120229094652.15149">http://groups.google.com/group/leo-editor/browse_thread/thread/ba9eb63337467d42/a3f3750d0ce6e847

&gt; Here's a one line @button node you can add to myLeoSettings.leo
&gt;
&gt; @button set-style
&gt;    c.frame.top.leo_ui.setStyleSheet(p.b)

Cool.  I've added this to my "pre-writing" pile of things to be
included in the next set of docs.

Important:  setStyleSheet *replaces* the previous stylesheet with the
new stylesheet, so you had best set all the attributes of Leo's
default stylesheet.

As an alternative, if w is any Qt widget, w.setStyleSheet(p.b) will
set the stylesheet for that widget only: the top-level stylesheet (the
stylesheet for c.frame.top.leo_ui) remains unchanged.
</t>
<t tx="ekr.20120229094652.15151">http://groups.google.com/group/leo-editor/browse_thread/thread/b49d23010703aa61/32e1271d25ba2cfb

&gt; In short, I am now willing, on an experimental basis, to have Leo put
&gt; up a dialog when inserting an @ignore, and also when writing an
&gt; @&lt;file&gt; node containing @ignore.

&gt; In the past, I have always found read/write dialogs to be a) intrusive
&gt; and b) panic-inducing, but this may be a tolerable exception.  We
&gt; shall see.
</t>
<t tx="ekr.20120229094652.15152">groups.google.com/group/leo-editor/browse_thread/thread/5da0de4502154b2c/1b077a8bb8e65811

Some people seem to think that it is difficult to understand how Leo
handles "clone wars":  differing values for a cloned nodes that appear
in several external files.  That's not true.  The rule is::

    **The last clone that Leo reads wins.**

That is, for any cloned node C, Leo takes the value of C.h and C.b to
be the values specified by the last copy that Leo reads.

There is only one complication::

    **Leo reads the entire outline before reading any external
files.**

Thus, if C appears in x.leo, y.py and z.py, Leo will choose the value
for C in x.py or y.py, depending on which @&lt;file&gt; node appears later
in the outline.

Notes:

1. Whenever Leo detects multiple values for C when opening an outline,
Leo creates a "Recovered nodes" tree.  This tree contains all the
various values for C, nicely formatted so that it is easy to determine
where the differences are.

2. I've just refreshed my memory by looking at the code.  The relevant
methods are:

    fc.getLeoFile # Reads the outline, then calls at.readAll to read
all external files.
    at.indicateNodeChanged # Adds data to c.nodeConflictList
    cacher.reportChangedClone # Adds data to c.nodeConflictList
    fc.handleNodeConflicts # Creates "Recovered Nodes" node and its
children.

3. The present code is the simplest code that could possibly work.
There is no way Leo is going to do AI in order to implement complex
rules for which clones are "more important" than others.  Thus, if you
use cross-file clones, it is up to *you* to know these rules and
handle any resulting conflicts.  Imo, the "Recovered Nodes" feature is
a big step forward for Leo, and makes it impossible to lose data
unless you willfully refuse to examine the data. 
</t>
<t tx="ekr.20120229094652.15153">groups.google.com/group/leo-editor/browse_thread/thread/3666397da2a0d05f/758071d6d9516ab9

The right-click context menu on the tabs in the tabbed window mode (the
default) has a 'Detach' option, if there's more than one outline / tab,
and a Re-attach all option, if there's a detached outline window
out there.

Now there's also 'Horizontal tile', and 'Vertical tile', which detach
the tab and then tile its window with the window from which it was
detached.

This is very helpful for moving nodes between outlines, I was
rearranging the windows by hand and setting one to 'always on top' with
the window manager before.  Note: there's a @setting to determine
whether dragging nodes between outlines copies or moves them.

Depending on your OS / window manager, tiling / placement may be
somewhat off, and may work better with or without the window being
maximized before tiling, you'll have to experiment.

You'd think it would be straight forward for Qt to ask the
window-manager where the window is now, and then tell it to put it
somewhere specific, but apparently a lot of window-managers regard this
as none of Qt's business.

=====

&gt; Now there's also 'Horizontal tile', and 'Vertical tile', which detach
&gt; the tab and then tile its window with the window from which it was
&gt; detached.

BEHAVIOR CHANGE: to make the above new feature more useful, I've
changed what happens when you close an outline window created by
detaching a tab.  Before the outline was closed (with prompt for save
in necessary).  Now the outline's just re-attached as a tab.  This
means it's now possible to reattach just one outline, rather than
having to use the 'reattach all' option. 
</t>
<t tx="ekr.20120229094652.15157"></t>
<t tx="ekr.20120229094652.15158">After so many years of confusion the problem is now apparent:
the Windows console uses code page 437: which is just extended ascii.

chcp 65001 is equivalent to utf-8, and it would be good to use,
but at present bzr goes nuts and changes to another code page!

So for the moment I'll have to live with what is, in effect, plain ascii.
</t>
<t tx="ekr.20120229094652.15159">On Ubuntu only, the auto complete popup is system-wide modal, it should only be modal over Leo windows.

However, there does not seem to be any fix:
http://groups.google.com/group/leo-editor/browse_thread/thread/171aaf79e0bea256

All works well on Windows 7.  I do see the "system-wide" model
behavior on Ubuntu.

This appears to be a Ubuntu-specific bug.  Indeed, the popup is a
QListWidget.  Such widgets have a setWindowModality method::

    setWindowModality ( Qt::WindowModality windowModality )

The valid modalities are at: http://doc.qt.nokia.com/4.7-snapshot/qt.html#WindowModality-enum

NonModal: The window is not modal and does not block input to other
windows.

WindowModal: The window is modal to a single window hierarchy and
blocks input to its parent window, all grandparent windows, and all
siblings of its parent and grandparent windows.

ApplicationModal: The window is modal to the application and blocks
input to all windows.

None of these would appear to be a system-wide modality, and
furthermore, the default is supposed to be NonModal.

Anyway, calling setWindowModality(QtCore.Qt.NonModal) does not seem to
have much effect on Ubuntu, so I think I can safely say there is
nothing more I can do. 
</t>
<t tx="ekr.20120229094652.15162"></t>
<t tx="ekr.20120229094652.15163"></t>
<t tx="ekr.20120229094652.15164"></t>
<t tx="ekr.20120229094652.15165"></t>
<t tx="ekr.20120229094652.15166"></t>
<t tx="ekr.20120229094652.15167"></t>
<t tx="ekr.20120229094652.15168"></t>
<t tx="ekr.20120229094652.15169"></t>
<t tx="ekr.20120229094652.15170"></t>
<t tx="ekr.20120229094652.15172"></t>
<t tx="ekr.20120229094652.15173">@language rest
</t>
<t tx="ekr.20120229094652.15174"></t>
<t tx="ekr.20120229094652.15175"></t>
<t tx="ekr.20120229094652.15176"></t>
<t tx="ekr.20120229094652.19496">https://bugs.launchpad.net/leo-editor/+bug/905276
The documentation should explain how to clone multiple nodes at once.

I would suggest that right up at the top of that page be a statement

somewhat along these lines (Edward do get rid of the blah blah! 8-) :

The core Leo code is always being improved and developed,
using a rigorous unit-testing blah-blah that ensures that
the daily commits are as bug-free as possible. In fact
(insert #% or qualifier) of the time, downloading the most
recent "nightly snapshot" of the development code from our
version control system Bazaar (link to here
http://www.greygreen.org/leo/) is going to give you code
that is just as stable and much more up-to-date than the
most recent "release" available here (link to
http://sourceforge.net/projects/leo/files/OldFiles/), which
most Leonistas would at this point consider already
outdated. If you are just checking Leo out, feel free to
download and use the release version if it makes you feel
more secure, but once you've decided to work with Leo on a
regular basis, we highly recommend regularly keeping your
installation up to date with the most recent snapshot:

(assuming you keep the folder containing your leo code
separate from your .mySettings.leo and any data files,
including of course your .leo files)

  1. archive and remove that app folder
  2. download the nightly snapshot zip file
  3. unzip it into the same place
  4. enjoy your up-to-date Leo code. . .


</t>
<t tx="ekr.20120229094652.19777">- open-with hook has changed: it now uses a "d" arg.</t>
<t tx="ekr.20120229094652.19778">The d argument to the open-with event handlers is a python
dictionary whose keys are all the tags specified by the user
in the body of the @open-with node.
</t>
<t tx="ekr.20120229173025.20633">http://groups.google.com/group/leo-editor/browse_thread/thread/d21349c52dabd066

Ever find that you have a whole lot of:

.. sourcecode:: py

  rec[f['analyte']] ... rec[f['sample_type']] ...

expressions in your code, and now things have changed and you want them
all to be:

.. sourcecode:: py

  row.Analyte ... row.Sample_Type ...

basically if str variable s was::

  rec[f['analyte']]

then you want to perform:

.. sourcecode:: py

  s = "row."+s.split("'")[1].title()

on each one.  In general it would be nice to be able to use a python
expression when search and replace doesn't cut it.

The button code below creates a button, ``fac``, which, when pressed,
creates another button, with some name you choose, which, when pressed,
executes some python code to fix the selected text in the body.

You can define the code to be executed in two ways, either in its own
node:

 - insert a new node with a headline which describes the refactor
 - enter code in the node which modifies the string variable ``s``,
   which is initially set to the selected text in the body
 - press the ``fac`` button, which creates a new button named
   after this code node
 - select each offending piece of text and press the button created
   in the previous step to fix

or

 - type some code modifying ``s`` right in the body you're working on
 - press the ``fac`` button, which creates a new button named "fix"
 - select each offending piece of text and press the button created
   in the previous step to fix

Note:

 - unlike regular button nodes, changing the code after the
   button's created (first option above) doesn't change the code
   executed by the button
 - replacing selection text makes Leo reposition the insert point at
   the top of the window, this is annoying but unrelated to this code

Here's the button code:

.. sourcecode:: py

  @button fac
    from leo.plugins.mod_scripting import scriptingController

    sc = scriptingController(c)

    if c.frame.body.hasSelection():
        code = c.frame.body.getSelectedText()
        heading = 'fix'
    else:
        code = p.b
        heading = p.h

    def transform(c=c, code=code):
        s = c.frame.body.getSelectedText()
        g.es(s)
        exec code
        g.es(s)
        c.frame.body.deleteTextSelection()
        i = c.frame.body.getInsertPoint()
        c.frame.body.insert(i, s)
        p.b = c.frame.body.getAllText()
        c.frame.body.setInsertPoint(i)

    b = sc.createIconButton(
        heading,
        command = transform,
        shortcut = None,
        statusLine = 'Make filter button',
        bg = "LightBlue"
    ) </t>
<t tx="ekr.20120229173025.20635">@language python

from leo.plugins.mod_scripting import scriptingController

sc = scriptingController(c)

if c.frame.body.hasSelection():
    code = c.frame.body.getSelectedText()
    heading = 'fix'
else:
    code,heading = p.b,p.h

def transform(c=c,code=code):
    w = c.frame.body
    s = w.getSelectedText()
    g.es(s)
    exec(code)
    g.es(s)
    w.deleteTextSelection()
    i = w.getInsertPoint()
    w.insert(i,s)
    p.b = w.getAllText()
    w.setInsertPoint(i)

sc.createIconButton(
    heading,
    command = transform,
    shortcut = None,
    statusLine = 'Make filter button',
    bg = "LightBlue"
)</t>
<t tx="ekr.20120229173025.20636">http://groups.google.com/group/leo-editor/browse_thread/thread/86593fb9543afb66/b888d149d75a9c77

The following are mostly notes to myself (and to future maintainers).
Feel free to ignore.

Rev 4972 demonstrates that the KeyStroke class can indeed distinguish
between "raw" user settings and the "canonicalized" form used
throughout Leo.  Indeed, the ability to explicitly distinguish between
the two, using type checking, has already substantially clarified and
simplified the code.

BTW, this is in no way a violation of OO principles.  The code is not
dispatching on the type of objects, it is merely enforcing vital
consistency checks.  This code is complex: confusion about the types
of objects is intolerable.  Happily, the resulting clarity allows the
code to be substantially simpler than it would otherwise be, which in
turn clarifies the code further, and so on...

Part 1: This work is vital

As described below, the forthcoming work will lead to a cascade of
other simplification.  These simplifications are important for at
least three, reasons:

1. The code must be simplified so that future maintainers (including
me) will have an easier time of it.

2. The present code provides no real help in creating unit tests that
test how Leo handles keystrokes.

3. Simplifying the code will provide a more solid foundation for vim-
related bindings.

Part 2: Notes about the KeyStroke class

Objects of the KeyStroke class can be used *exactly* as a strings may
be used:

A.  KeyStroke objects may be used as dictionary keys, because they
have __hash__ methods and all the so-called rich comparison methods:
__eq__, __ne__, __ge__, __gt__, __le__ and __lt__.  Note that
KeyStroke objects may be compared with other KeyStroke objects,
strings and None.

B. At present, KeyStroke objects supports the find, lower and
startswith methods.  This simplifies the code substantially: we can
apply these methods to either strings or KeyStroke objects, so there
is no need to create different versions of the code depending on the
value of g.new_strokes.

However, having the KeyStroke class support string methods is bad
design.  Indeed, it is a symptom that the client code that uses
KeyStroke objects knows too much about the internals of KeyStroke
objects.  Instead, the KeyStroke class should have higher-level
methods that use s.find, s.lower and s.startswith internally.

You could say that the fact that code in leoKeys.py calls s.find,
s.lower and s.startswith is a symptom of non OO programming.  The
internal details of settings and strokes "pollutes" the code.  This
must be fixed.  This will likely create opportunities for further
simplifications.

Part 3: Other design changes

The present work, enabled and disabled with g.new_strokes, has been a
resounding success.  The next steps will be as follows:

Better packaging.

g.new_strokes, g.isStroke and g.isStrokeOrNone should be defined in
leoKeys.py, not leoGlobals.py.
I knew from the start that such global names were only a temporary
expedient.

Now I know where they should go. leoKeys.py, not leoConfig.py, is the
proper place to handle all the details about key bindings.  Indeed the
code in leoConfig.py simply parses user key settings into *strings*.
These raw strings must be converted to KeyStroke objects by
leoKeys.py.

As a result, the KeyStroke class (and the ShortcutInfo class?) should
be defined in leoKeys.py, not leoConfig.py.  To make this work, we'll
want to create several factory methods: k.makeKeyStroke and
k.makeShortcutInfo.

Better separation of concerns.

The Qt key input code can be hugely simplified by calling a new
k.makeKeyStrokeFromData factory method.  At present, the Qt key input
code knows *all* the details of  the format of *canonicalized*
settings. This is absolutely wretched design.

Instead, the Qt input key code should simply pass the key modifiers
and other key information to k.makeKeyStrokeFromData, in a some kind
of "easy" format.  For example, the Qt input key code would represent
the internal Qt modifiers as lists of strings like "alt", "ctrl",
"meta", "shift".  k.makeKeyStrokeFromData would then create a *user*
setting from the components, and then call k.strokeFromSetting to
complete the transformation.

As I said in another thread, the present Qt input key code is
entangled with other code.  I'll have to disentangle the code before
putting this scheme into effect.

Other classes

The easiest next step will be to integrate the presently unused
ShortcutsDict class into the code. This will eliminate the wretched
special cases for the _hash key.

Part 4: Conclusions

I have high hopes that we will see wave after wave of
simplifications.  Much of the difficult work presently scattered in a
non-OO fashion throughout leoKeys.py, leoConfig.py and leoQtGui.py
will migrate to become KeyStroke methods (or methods of other
classes).

The KeyStroke class has already made possible vital type-related
assertions.  Knowing *for sure* exactly what crucial data is and what
it means is a huge step forward.   More steps are coming.

Edward 

=====

&gt; Why not just have .s attribute in KeyStroke, that contains the string
&gt; version?

A good question.  Indeed, all Keystroke objects ks do have an s ivar.

Experience (that is, ugly code) has shown that *during* the transition
we don't want to have two versions of the code, one using stroke (a
string) and the other using ks.s.

*After* the transition, that is, once the new_strokes switch goes
away, we could, in fact, use ks.s instead of ks.  However, it's
cleaner just to use ks and not have client code know about ks.s.

More importantly, too much code manipulates stroke (or ks.s) objects.
This is a symptom that the details key handling (whether represented
as a string or as a KeyStroke) have "bled" into the areas of the
leoKeys code where they do not belong.

This is far from a theoretical problem.  A lot of code in leoKeys.py
deals with the picky details of the representation of key strokes.
This is a great violation of the Don't Repeat Yourself principle and
makes the code "sclerotic": rigid and inflexible.

I am convinced that the present work will greatly simplify what is, at
present, by far the most difficult and poorly designed part of Leo.  A
capable KeyStroke class is a very important first step.  I'll say more
about this class in another thread. 

=====

&gt; A good question.  Indeed, all Keystroke objects ks do have an s ivar.

I forgot the most important reason in my reply.  The reasons I gave
all were code-level responses, but the most important reason is that
is truly impossible to understand the key code without knowing whether
an object is a string representing a user setting or the canonicalized
version used in Leo's core, that is, a KeyStroke object.  Using ks.s
instead of ks destroys precisely the information needed to understand
the code.

Again, this is not a theoretical concern.  The key code now contains
assertions of the form::

    assert g.isStroke(stroke)
or
    assert g.isStrokeOrNone(stroke)

Getting these assertions to pass in *all* situations required several
important revisions of the code.  The code that makes the assertions
pass is "innocuous", that is, almost invisible in the mass of code,
but obviously, these small pieces of code are vital.

The present code highlights these changes: look for g.new_strokes,
especially lines marked with ####.  These markers will be cleaned away
eventually, but the asserts will remain forever.

Furthermore, the asserts suggested further simplifications.  It was a
tricky process, and it will be ongoing as I simplify the code further.

Edward 

=====

&gt; it is truly impossible to understand the key code without knowing whether an object is a string representing a user setting or the canonicalized version used in Leo's core, that is, a KeyStroke object.

There is another set of strings floating around the key-handling code,
namely Leo's emacs-like command names. I am considering defining a new
class, say k.CommandName, to wrap such names.  If I do that, I'll base
the k.KeyStroke and k.CommandName classes on a common g.TypedString
class.

I am about to convert many of Leo's key-handling dictionaries to
g.TypedDict objects.  Using TypedDicts will make it impossible to make
invalid assignments to Leo's crucial key dictionaries, especially if I
create the CommandName class.  In effect, g.TypedDict objects will
enforce the constraints given in the comments in &lt;&lt; about key dicts &gt;&gt;
in leoKeys.py.

This machinery will allow further type-related assertions.  Details
omitted, but they will be quite useful, both as sanity checks and as
documentation.  The TypedDict class enforces its own type constrains
automatically, so the crucial type checks will not unduly clutter the
code.

Edward 

=====

&gt; I am about to convert many of Leo's key-handling dictionaries to
&gt; g.TypedDict objects.  Using TypedDicts will make it impossible to make
&gt; invalid assignments to Leo's crucial key dictionaries.

This has been a great success.  I also defined the g.TypedDictOfLists
class, where the values are lists of a known type.  These classes are
useful for more than type checking:  they have unique names and a dump
method that dumps the dict in an easy-to-read format that includes the
name, and valid types for keys and values.

At present, these dicts are *not* subclasses of {}, which has its
pluses and minuses.  These are quite simple classes, so at present
only the "for key in d.keys()" idiom is supported, the "for key in d"
idiom is not supported.

Plain dicts do have their uses, but for "long-lived" dicts, and dicts
passed around between methods, I am beginning to regard plain dicts as
being as ill-advised as g.Bunches.

Leo's key dictionaries will always be complex, but basing them on the
TypedDict class is a major improvement. </t>
<t tx="ekr.20120313074006.14640">Rev 5051 contains a *major* improvement in Leo's abbreviation code.
It is simpler, and more general than before.

The downside is that you will likely have to revise your
abbreviations.  I believe the extra work will be well worthwhile.

Here are the changes:

1. Abbreviations may consist of *any* sequence of characters,
including whitespace or "special" characters. You may include
whitespace characters in definitions using the '\t' and '\n' escapes.
However, whitespace may only appear at the *end* of definitions.

2. You must take care to disambiguate abbreviations if one is a prefix
of another.

Here is an example of both points.  As always, you define
abbreviations in the body of an @global-abbreviation node or
@abbreviation node::

    nc =@nocolor\n
    nc\n=@nocolor\n
    nc\t=@nocolor\n

    ncn=@nocolor-node\n

As you can see, the definitions uses whitespace at the end
of the definition of "nc" to prevent it from being expanded
when typing "ncn".

3. The reason I call these abbreviations "instant" is that they can be
triggered on *any* keystroke, not just the end of a "word".  This
allows you to define::

    teh=the

Hurray!

4. Two rules limit scans.  They are useful and shouldn't cause
hardships.

A.  The backspace and delete characters *never* trigger substitutions.

B. The scan for definitions ends at the first newline
character. Therefore, whitespace will have effect only at
the *end* of a definition.

**Important**: these rules can cause problems when *defining*
abbreviations:  it's easy to trigger an unwanted definition.  The
solution is to use rule 4B:

I want to type::

    ncn=@nocolor-node\n

But I **cant** type this directly if nc is already defined!  The trick
is to type::

   nxcn=@nocolor-node\n

and then delete the leading x with a backspace character.

Of course, you could also turn abbrevions off while defining abbreviations...

Instant abbreviations solve the problems with Brazilian
keyboards. Just define::

    ~a=ã
    ~A=Ã
    etc.

This works regardless of keyboard, regardless of OS, etc.
You might want to define::

    ~\a=~a
    ~\A=~A

in the somewhat unlikely event that you want to type ~a rather than,
say, ~+a.  Of course, you don't need these, provided you remember to
type ~xa &lt;Right&gt;&lt;Delete&gt; :-)
</t>
<t tx="ekr.20120313074006.14643">k.remove_conflicting_definitions always gives the warning, not just when tracing.

The warning isn't the best, and it is usually duplicated, but it is much better than nothing.
</t>
<t tx="ekr.20120313074006.14648">https://bugs.launchpad.net/leo-editor/+bug/930726

Bug: If the node is not expanded already, then the position
is left on the parent, not the first child.

Function expandNodeAndGoToFirstChild() is referenced only
once in LeoPyRef.leo. This reference is in table of public
Leo commands.

The node in which expandNodeAndGoToFirstChild() is defined
also contains the definition of function
expandNodeOrGoToFirstChild(). At present these two functions
are equivalent. The comments including the header for the
node imply that they should not be equivalent and that
expandNodeAndGoToFirstChild() is not correctly implemented.
</t>
<t tx="ekr.20120313074006.14650">https://bugs.launchpad.net/leo-editor/+bug/869429
Undo and Redo delete from context menu does not redo properly

The fix was to deletenodes_rclick in contextmenu.py.
The fallback position should be c.rootPosition()

===== Original report.

Delete (node) in context_menu (right click on headline) has unexpected undo /
redo effects.

Redo after Undo often fails, but you can Undo again, without the
ReDo taking effect, which mans an extra node is created.

In essence: -1 delete,
+1 Undo (restore node),
0 ReDo (should redelete but does nothing),
+1 Undo

(again) = 1 Should = 0 (delete, undelete, redelete, undo redelete) Deleting a
node through Outline menu works differently and properly. The undo code in the
two delete methods must be different

===== Terry

The undo code in the two delete methods must be different

It's different because the context menu delete can delete multiple
nodes at once.

I wrote the context menu delete, but I don't understand the undo system
that well - it's possible it just doesn't support a redo of something
like this.
</t>
<t tx="ekr.20120313074006.14655">- Open contextmenu plugin at first use (not at startup).

- Disable contextmenu dialog for temp files.

Here is the checkin log for rev 5066:

Several changes so that the vim and xemacs plugins work well with contextmenu plugin.

- vim.py and xemacs.py load contextmenu.py if necessary the first time they open a temp file.

- contextmenu.py (edit_node_on_idle) suppresses the "conflicts dialog" if the file's path is in
  [z.get('path') for z in g.app.openWithFiles]

All expected unit tests pass, as do hand tests of the vim and xemacs plugins.

</t>
<t tx="ekr.20120313074006.14657">https://bugs.launchpad.net/leo-editor/+bug/823267

When tabs are closed with the close tab 'X' on the tab, focus
should go to whichever tab becomes visible, but it doesn't,
it goes to an arbitrary tab which may not be visible. If you
then hit Alt-X expecting to cut the highlighted node in the
visible tab, you cut a node you can't see in a different
commander.

What I did:
    
- Refactored part of g.app.closeLeoWindow into g.app.selectLeoWindow.
- Added the new_c argument to g.app.closeLeoWindow and c.close.
- Changed several event handlers in TabbedFrameFactor so that they
  call g.app.selectLeoWindow as appropriate.

@language python
</t>
<t tx="ekr.20120313074006.14663">https://bugs.launchpad.net/leo-editor/+bug/917814

Switching Log Pane tabs is not done cleanly and completely. To see this do the following:

1) Start Leo-Editor
2) Shift-Ctrl-F. This brings the Nav tab to the foreground and
   leaves the focus in the search string field of the Nav pane.
3) Click on the Log tab of the Log pane.
4) Ctrl-A. This causes the following messags to be displayed in the Log tab of the Log pane:

exception executing command
Traceback (most recent call last):
  File "/home/bob/bzrWork/trunk/leo/core/leoCommands.py", line 419, in doCommand
    val = command(event)
  File "/home/bob/bzrWork/trunk/leo/core/leoEditCommands.py", line 5755, in selectAllText
    return w.selectAllText()
  File "/home/bob/bzrWork/trunk/leo/core/leoFrame.py", line 168, in selectAllText
    def selectAllText (self,insert=None): self.widget and self.widget.selectAllText(insert)
AttributeError: 'LeoQuickSearchWidget' object has no attribute 'selectAllText'


That is, it appears that the focus is on the Log tab and the
intention is to select-all in the log tab, but Leo-Editor
tries to select-all in the Nav pane.

Strangely, doing a Ctrl-A in the Nav tab of the Log pane
seems to do nothing---no errors, no select.

-------
Ubuntu 11.10 with Fluxbox window manager
Leo Log Window
Leo 4.9.1 devel, build 4928, 2012-01-14 11:27:18
Python 2.7.2, qt version 4.7.3
linux2
setting leoID from os.getenv('USER'): 'bob'
load dir: /home/bob/bzrWork/trunk/leo/core
global config dir: /home/bob/bzrWork/trunk/leo/config
home dir: /home/bob
reading settings in /home/bob/bzrWork/trunk/leo/config/leoSettings.leo
reading settings in /home/bob/.leo/myLeoSettings.leo
reading settings in /home/bob/.leo/workbook.leo
reading: /home/bob/.leo/workbook.leo
</t>
<t tx="ekr.20120313074006.14697">Rev 5076 fixes bug 924123:
Some SyntaxError's thrown when compiling the whole source with Python 3
https://bugs.launchpad.net/leo-editor/+bug/924123

These syntax errors were minor in the sense that they had no
effect on Leo's users, but they were a significant
distribution issue because Linux packages are not to have
such errors.

Notes:

I removed the following files. Apparently, they are used nowhere in Leo. 
    
    leo/core/leo_Debugger.py
    leo/core/leo_FileList.py"
    leo/core/leo_RemoteDebugger.py
    leo/core/leo_Shell.py
    leo/core/leo_run.py

This files no longer exists:

    leosax.py
    
Fixed all reported syntax errors.

The unit test "@test syntax of all files" now checks the following files:
    
- old gui files:
    cursesGui.py, ironPythonGui.py, swing_gui.py, tkGui.py, and wxGui.py
    
- script files:
    convert_to_shadow.py, leoFindScript.py, LinixInstall.py,
    tangle_done.py, untangle_done.py
</t>
<t tx="ekr.20120313074006.14698">https://bugs.launchpad.net/leo-editor/+bug/844953

1. Open two empty files with the LEO revision 4451/trunk using the qttabs GUI and save them both.
2. Create a new node and write "Abc" in its head.
3. Select "Copy Node" from the outline menu.
4. Select "Paste Node As Clone" from the outline menu:
   Node is not inserted as clone, but inserted as a copy in the second file/tab.

Sometimes even a standard Copy-Paste action results in the node being inserted in the other file.

EKR: This a unity menu problem, not a problem with the paste commands per se.

http://qt-project.org/forums/viewthread/15366/

</t>
<t tx="ekr.20120313074006.14702">https://bugs.launchpad.net/leo-editor/+bug/501636

Leo's present @auto import code for xml files supports only ascii tags.

In particular, xmlScanner.isWordChar should allow non-ascii characters as specified in
www.w3.org/TR/2008/REC-xml-20081126/#NT-Name

NameStartChar ::= ":" | [A-Z] | "_" | [a-z] |
    [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |
    [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] |
    [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] |
    [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]

NameChar ::= NameStartChar | "-" | "." | [0-9] | #xB7 |
    [#x0300-#x036F] | [#x203F-#x2040]

The following script, presently in test.leo, may be useful:

import unicodedata as u
table = ('a','9','_',':','.',)
table2 = (
    (0xc0,0xd6),(0xd8,0xf6),(0xf8,0x2ff),(0x370,0x37d),(0x37f,0x1fff),
    (0x200c,0x200d),(0x2070,0x218f),(0x2c00,0x2fef),(0x3001,0xd7ff),
    (0xf900,0xfdcf),(0xfdf0,0xfffd),(0x10000,0xeffff),
    # Valid only after the start of a word.
    (0xb7,0xb7+1),(0x0300,0x036f),(0x203f,0x2040),
)
for ch in table:
    ch = g.u(ch)
    g.es(ch,u.category(ch))
for i,j in table2:
    g.es('*** range %xd %xd' % (i,j))
    for n in range(i,min(i+5,j)):
        if g.isPython3: ch = chr(n)
        else: ch = unichr(n)
        g.es(ch,u.category(ch))

Clearly, however, the unicode category of these characters
is not helpful. Instead, a dictionary lookup would be
appropriate.
</t>
<t tx="ekr.20120313074006.14713">https://bugs.launchpad.net/leo-editor/+bug/799695

# The fix was simply to call c.recolor_now(incremental=False)
</t>
<t tx="ekr.20120313074006.14714">https://bugs.launchpad.net/leo-editor/+bug/824087

The fix was to bind Ctrl-F4 to close-window, instead of Alt-F4.

I instantly like this new binding.
</t>
<t tx="ekr.20120313074006.14715">https://bugs.launchpad.net/leo-editor/+bug/923301

I am opening a bug for this, since I think that a Leo-Newbie might not be
able to find a work around for this issue.

The 'rst3' command just fails silently - and - does not create any output
file at all. - It took me a while to find the offending section in the body
of a large outline node, so that the 'rst3' command was able to create
an output file again.

&lt;log&gt;

D:\Users\Viktor Ransmayr\Documents&gt;leo ./BR-2012-01-28.leo

** isPython3: True
Leo 4.9.1 devel, build 4950, 2012-01-28 10:16:45
Python 3.2.2, qt version 4.8.0
Windows 6, 1, 7601, 2, Service Pack 1
reading settings in D:\Branches\leo-editor\leo\config\leoSettings.leo
reading settings in D:\Users\Viktor Ransmayr\.leo\myLeoSettings.leo
reading settings in D:\Users\Viktor Ransmayr\Documents\BR-2012-01-28.leo
wrote recent file: D:\Users\Viktor Ransmayr\.leo\.leoRecentFiles.txt
&lt;string&gt;:179: (WARNING/2) Literal block expected; none found.
Traceback (most recent call last):
  File "D:\Branches\leo-editor\leo\plugins\qtGui.py", line 8689, in eventFilter
    ret = k.masterKeyHandler(event)
  File "D:\Branches\leo-editor\leo\core\leoKeys.py", line 2897, in masterKeyHandler
    done,val = k.doMode(event,state,stroke)
  File "D:\Branches\leo-editor\leo\core\leoKeys.py", line 2973, in doMode
    val = k.callStateFunction(event) # Calls end-command.
  File "D:\Branches\leo-editor\leo\core\leoKeys.py", line 2947, in callStateFunction
    val = k.state.handler(event)
  File "D:\Branches\leo-editor\leo\core\leoKeys.py", line 2010, in fullCommand
    k.callAltXFunction(k.mb_event)
  File "D:\Branches\leo-editor\leo\core\leoKeys.py", line 2056, in callAltXFunction
    func(event)
  File "D:\Branches\leo-editor\leo\core\leoRst.py", line 472, in rst3
    self.processTopTree(self.c.p)
  File "D:\Branches\leo-editor\leo\core\leoRst.py", line 482, in processTopTree

self.processTree(p,ext=None,toString=False,justOneFile=justOneFile)
  File "D:\Branches\leo-editor\leo\core\leoRst.py", line 510, in processTree

self.write_rst_tree(p,ext,fn,toString=toString,justOneFile=justOneFile)
  File "D:\Branches\leo-editor\leo\core\leoRst.py", line 560, in write_rst_tree

self.write_files(ext,fn,callDocutils,toString,writeIntermediateFile)
  File "D:\Branches\leo-editor\leo\core\leoRst.py", line 1749, in write_files
    f.write(s)
  File "C:\Python32\lib\encodings\cp1252.py", line 19, in encode
    return codecs.charmap_encode(input,self.errors,encoding_table)[0]
UnicodeEncodeError: 'charmap' codec can't encode character '\u0142' in position
19816: character maps to &lt;undefined&gt;

&lt;/log&gt;

This has been re-produced with the latest revision of leo-trunk. - If wanted,
I can send a minimal outline that consistently produces this tracedback.
</t>
<t tx="ekr.20120313074006.14722">https://bugs.launchpad.net/leo-editor/+bug/893230

Added support for colorizing the following schemes:
gopher,mailto,news,nntp,prospero,telnet,wais

No new unit tests, but the new code does pass a hand test (which found a bug).

Changed match_ural_any, etc, and addLeoRules.
</t>
<t tx="ekr.20120313074006.14725">https://bugs.launchpad.net/leo-editor/+bug/944551
@url URL Open Hangs Leo-Editor for duration (and lesser URL problems)

- Removed "significant" calls to os.system. (It's alright to call os.system('cls'))
- Added support for unit testing to g.os_startfile, g.recursiveUNLSearch &amp; g.handleUrl

Both unit tests and hand tests pass.
</t>
<t tx="ekr.20120313074006.14738"></t>
<t tx="ekr.20120313074006.14740">https://bugs.launchpad.net/leo-editor/+bug/875323
Hoist an @chapter node leaves a non-visible node selected
</t>
<t tx="ekr.20120313074006.14765">https://bugs.launchpad.net/leo-editor/+bug/831658
@url doesn't leave Chapter

If in Chapter mode I double-click @url UNL node that is in a
different @Chapter, the body text is correct but the outline
tree does not move outside of the current @Chapter. Works
fine if I'm not in Chapter mode.
</t>
<t tx="ekr.20120313074006.14771">https://bugs.launchpad.net/leo-editor/+bug/875327
Positioning outside of hoisted outline" usually causes problems

The fix was to c.selectPosition.  This has a chance of being a general solution.
</t>
<t tx="ekr.20120313074006.14772">https://bugs.launchpad.net/leo-editor/+bug/807561
dragging a binary to Leo should create @url, not @edit

Changed helpers of dropEvent and createAtFileNode.

The isBinaryFile helper returns True if the file's extension is not known.
This isn't great, but it's safe.

The list of known text types includes:
    
1. '.css','.html','.leo','.txt'
2. All extensions in g.app.extension_dict.keys().
</t>
<t tx="ekr.20120313074006.14800">Example: typing in this rest section recolors as *Python*.
The correct coloring is restored when the entire text is recolored.

In this case, a workaround, and a performance improvement, would be to put
the ``@language python`` directive before the ``language rest``.

@language python


</t>
<t tx="ekr.20120313074006.14906">- Added scanToCursor argument to c.scanAllDirectives in c.insert/removedComments.

- Added scanToCursor argument to get_directives_dict_list in c.scanAllDirectives.

- get_directives_dict_list sets scanToCursor only for the initial (root) node.

- g.get_directives_dict scans to cursor for @language directives is scanToCursor is True.
</t>
<t tx="ekr.20120313074006.14916">Make sure all Outline:Go To... commands work with hoists

Test procedure:
Open outline headline-body-mismatch.leo (which is attached here).
Select the node with headline 0101-01-H.
Click on Outline --- Hoist.
Alt-x, goto-first-node.

A bug had occurred. There is now a mismatch between the selected node shown in the outline pane and the body shown in the body pane.
The body pane shows "01-01-B". This is the body of the first node in the outline.
The body pane should show "0101-01-B".

There are additional problems now:
1) Outline --- De-Hoist is grayed out. There is no way to de-hoist.
2) Ctrl-h does not work. It just causes the following message on the console:
error *** no item for &lt;pos 162306060 childIndex: 0 lvl: 0 key: 172612012:0 0101-01-H&gt; load,runMainLoop,eventFilter,masterKeyHandler,masterCommand,doCommand,editHeadline,editLabel
--- end error message ---
 Headline "0101-01-H" can be opened for editing by double-left-clicking it.
</t>
<t tx="ekr.20120313074006.15120">https://bugs.launchpad.net/leo-editor/+bug/952365
Leo-Editor can't write a file created from the command line

Test procedure:
    
On a command line start Leo-Editor with one command line
parameter which specifies a valid pathname for a
non-existent outline file. Ctrl+s causes error messages to
the Log pane and to the console.


Traceback (most recent call last):

  File "/home/bob/bzr/LeoLatest/leo/core/leoFileCommands.py", line 2061, in writeToFileHelper
    theActualFile.write(s)

AttributeError: 'NoneType' object has no attribute 'write'

handleWriteLeoFileException backup file does not exist! None

===== What I did

Improved error reporting and checking, but the file won't be created if
createActualFile takes an IOError.

</t>
<t tx="ekr.20120313074006.15125">Opening myLeoSettings.leo can clutter the console unworthwhile messages 
https://bugs.launchpad.net/leo-editor/+bug/951921

It's clumsy to report conflicts in k.remove_conflicting_definitions.
Instead, doOneShortcut should only report conflicts *in the same file*.
</t>
<t tx="ekr.20120313074006.15135">https://bugs.launchpad.net/leo-editor/+bug/951739
xdg-open of a file-scheme URL containing blanks

The major problem is that currently blanks are not allowed in file-scheme URL's.
The minor problem is that error messages are printed on the console.

When an attempt is made to open a file-scheme URL that
contains blanks (making it an invalid URL), an error message
like the following is printed on the console:

xdg-open: unexpected argument 'Dodge'
Try 'xdg-open --help' for more information.
--- Error message end ----

The URL that caused the above message:
file:///media/datw1/BobH/0/2002 Dodge Neon SXT/Dodge Dealers.txt

Fix to both problems:
Either single or double quotations are needed around the pathname that is passed to xdg-open.
</t>
<t tx="ekr.20120313074006.15138">@url with URL in headline
https://bugs.launchpad.net/leo-editor/+bug/951721

The fix follows the suggestions in the bug report:

1. Use the headline's url if the g.isValidUrl says it is valid.

2. Otherwise, scan down the lines of the body text looking for a valid url.

**Important**: g.isValidUrl is pretty lenient about what it considers valid. Here it is::

    def isValidUrl(url):

        '''Return true if url *looks* like a valid url.'''

        if url.startswith('#--&gt;'):
            # Allow Leo UNL's.
            return True
        else:
            parsed = urlparse(url)
            return bool(parsed.scheme
</t>
<t tx="ekr.20120313074006.15144">@language python
@language rest

Reference: https://bugs.launchpad.net/leo-editor/+bug/944555
Ctrl-left-click URL handling not as sophisticated as @url URL handling

Also, make sure bookmarks and contextmenu plguins use g.handleUrl.
</t>
<t tx="ekr.20120313074006.15151">Improved g.handleUrl as follows:
    
- Automatically strip leading "@url".
- set p if possible.
- Handle {{expresssions}} in file urls.
- Always use webbrowser to open .html and .htm files.
</t>
<t tx="ekr.20120313074006.16135">http://groups.google.com/group/leo-editor/browse_thread/thread/f7eaf4dd4e84a535

I have now pushed a way to do global search, with one line of context
(one line before, one line after).

Screenshot here:

https://plus.google.com/103097156557482112329/posts/6qSngscG38Y

Instructions (with current trunk):

- enable bigdash.py plugin
- alt-x global-search
- Enter "s somesearch" in the line editor and press enter
- Browse the hits. Click on link to navigate to the node.

Caveats:

- If the document is not in currently active tab, the navigation is
done "in the background". Correct implementation would be to activate
the tab in order to bring attention to it. 
</t>
<t tx="ekr.20120313134250.14219">The main "how to install" text should be targeted at
the lowest common denominator "man on the street" stopping
by to check out Leo.

IMO there shouldn't be any mention of Bazaar in the
mainstream "getting started with Leo", unless presented as
"keeping up to date" or "for people looking to contributed".
And until the Bazaar memory issues are resolved I think only
the latter.

Someone who's never heard of a version control system should
be much less intimidated by "unzip this here and create a
batch file" than figuring out Bazaar.

Other notes:

Since for Linux and Windows the initial hurdle for many is
getting the prerequisites going, I would make that part
OS-specific, but then have the "within-Python" stuff marked
platform-independent, leaving only the more problematic Mac
discussion as a completely separate section - in fact I'd
suggest putting a link to a completely separate page
somewhere near the top, to leave the main page with a more
positive overall tone.

Only after you've addressed the needs of "mere users" should
there be a section, or again a link to a separate page for
programmers who may be interested in helping to develop Leo,
and make it clear that Bazaar is the way to go for them (and
currently only them), and only then add a note about
Bazaar's current problems with memory usage and any
Leo-specific suggestions and workarounds, again clearly
targeted to that particular audience.

From Terry B: bzr should be recommended only for people who
want to modify the code (or are simply familiar with bzr),
and the nightly .zips should be pointed to as the way to run
from the trunk.
</t>
<t tx="ekr.20120313134250.14220">The docs on @ &lt;file&gt; varieties somewhat deprecate @nosent.

it would be useful IMO to point out that they are the only
way to write out non-sentinel files "one way" AND be able to
use outlining, clones etc.

Possibly a useful way to **output** cloned nodes safely to
multiple files, as long as **at most only one** location is
reading any given node into the .leo file. Supplement to the
"@all" method having lower priority method for avoiding
"clone wars" data loss - all this paragraph needing more
thorough thinking / testing etc before being written up.

But in the meantime at least don't imply that @nosent
doesn't have its uses.
</t>
<t tx="ekr.20120313134250.14232">The open_with plugin no longer exists. Support for the
open-with command is part of Leo's core.</t>
<t tx="ekr.20120313134250.14294">@nocolor-node

*** Important *** This was all done in Leo 4.9

http://groups.google.com/group/leo-editor/browse_thread/thread/3cd5cb06d32264d

&gt; What would work for me is if named sections in a @rst subtree
&gt; would work exactly as they work for other derived files: they
&gt; get inserted at the place where they are referenced.

- Add support for the following options:
    - expand_noweb_references:  default False for compatibility.
    - ignore_noweb definitions: default False for compatibility.

- When expand_noweb_references is True, definitions (typically clones)
  must be descendants of the referencing node (in the @rst tree)
</t>
<t tx="ekr.20120313134250.14295">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/15239f5f504cee6f

I tried it out with:

Test
.....@rst test.html
      which contains:
      This is a test (underlined)
      then the reference:
      &lt;&lt;test&gt;&gt;
...............&lt;&lt;test&gt;&gt;
                which contains: Here is some text.

In the top node Test I have:
@ @rst-options
expand_noweb_references=True
expand_noweb_recursively=True
show_headlines=False  (without this, the &lt;&lt;test&gt;&gt; headline becomes a section
heading)
@c

It sort of works:
--------------------------------------------
This is a test

&lt;&lt;test&gt;&gt;Here is some text.

Here is some text.
--------------------------------------------

The reference &lt;&lt;test&gt;&gt; does not get erased, even if the definition actually
gets inserted beside it. On the other hand, though I can suppress the
headline of the definition with the rst option, the body of the definition
gets inserted as a section anyway; definitions are not ignored by rst.

But now I can go see what happens in the code for debugging, since the
option gives a pointer into the code.

Thanks!
</t>
<t tx="ekr.20120313134250.14296"></t>
<t tx="ekr.20120313134250.14297">def code_to_rst_command (self,event=None,p=None,scriptSettingsDict=None,toString=False):

    '''Format the presently selected node as computer code.

    Settings from scriptSettingsDict override normal settings.

    On exit:
        self.source contains rst sources
        self.stringOutput contains docutils output if docutils called.
    '''

    trace = False and not g.unitTesting
    c = self.c
    if p: p = p.copy()
    else: p = c.p
    self.topNode = p.copy()
    self.topLevel = p.level()

    # **Important**: This command works as much like the rst3 command as possible.
    # Difference arise because there is no @rst node to specify a filename.
    # Instead we get the filename from scriptSettingsDict, or use 'code_to_rst.html'

    # Capture the settings, munging all settings.
    self.scriptSettingsDict = {}
    d = scriptSettingsDict
    if d:
        for key in d.keys():
            self.scriptSettingsDict[self.munge(key)] = d.get(key)

    # Init options...
    self.preprocessTree(p)
    self.init_write(p) # scanAllDirectives sets self.path and self.encoding.
    self.scanAllOptions(p) # Settings for p are valid after this call.
    callDocutils = self.getOption('call_docutils')
    writeIntermediateFile = self.getOption('write_intermediate_file')
    fn = self.getOption('output-file-name') or 'code_to_rst.html'
    junk,ext = g.os_path_splitext(fn)

    # Write the rst sources to self.sources...
    self.outputFile = StringIO()
    self.write_code_tree(p,fn)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if callDocutils or writeIntermediateFile:
        self.write_files(ext,fn,callDocutils,toString,writeIntermediateFile)
</t>
<t tx="ekr.20120313134250.14298">def write_code_body (self,p):

    trace = False
    self.p = p.copy() # for traces.
    if not p.b.strip():
        return # No need to write any more newlines.

    showDocsAsParagraphs = self.getOption('show_doc_parts_as_paragraphs')
    lines = g.splitLines(p.b)
    parts = self.split_parts(lines,showDocsAsParagraphs)
    result = []
    for kind,lines in parts:
        if trace: g.trace(kind,len(lines),p.h)
        if kind == '@rst-option': # Also handles '@rst-options'
            pass # The prepass has already handled the options.
        elif kind == '@rst-markup':
            lines.extend('\n')
            result.extend(lines)
        elif kind == '@doc':
            if showDocsAsParagraphs:
                result.extend(lines)
                result.append('\n')
            else:
                result.extend(self.write_code_block(lines))
        elif kind == 'code':
            result.extend(self.write_code_block(lines))
        else:
            g.trace('Can not happen',kind)

    # Write the lines with exactly two trailing newlines.
    s = ''.join(result).rstrip() + '\n\n'
    self.write(s)
</t>
<t tx="ekr.20120313134250.14299">def split_parts (self,lines,showDocsAsParagraphs):

    '''Split a list of body lines into a list of tuples (kind,lines).'''

    kind,parts,part_lines = 'code',[],[]
    for s in lines:
        if g.match_word(s,0,'@ @rst-markup'):
            if part_lines: parts.append((kind,part_lines[:]),)
            kind = '@rst-markup'
            n = len('@ @rst-markup')
            after = s[n:].strip()
            part_lines = g.choose(after,[after],[])
        elif s.startswith('@ @rst-option'):
            if part_lines: parts.append((kind,part_lines[:]),)
            kind,part_lines = '@rst-option',[s] # part_lines will be ignored.
        elif s.startswith('@ ') or s.startswith('@\n') or s.startswith('@doc'):
            if showDocsAsParagraphs:
                if part_lines: parts.append((kind,part_lines[:]),)
                kind = '@doc'
                # Put only what follows @ or @doc
                n = g.choose(s.startswith('@doc'),4,1)
                after = s[n:].lstrip()
                part_lines = g.choose(after,[after],[])
            else:
                part_lines.append(s) # still in code mode.
        elif g.match_word(s,0,'@c') and kind != 'code':
            if kind == '@doc' and not showDocsAsParagraphs:
                part_lines.append(s) # Show the @c as code.
            parts.append((kind,part_lines[:]),)
            kind,part_lines = 'code',[]
        else:
            part_lines.append(s)

    if part_lines:
        parts.append((kind,part_lines[:]),)

    return parts
</t>
<t tx="ekr.20120313134250.14300">def write_code_block (self,lines):

    result = ['::\n\n'] # ['[**code block**]\n\n']

    if self.getOption('number-code-lines'):
        i = 1
        for s in lines:
            result.append('    %d: %s' % (i,s))
            i += 1
    else:
        result.extend(['    %s' % (z) for z in lines])

    s = ''.join(result).rstrip()+'\n\n'
    return g.splitLines(s)
</t>
<t tx="ekr.20120313134250.14301">def write_code_headline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''


    docOnly             = self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.write_code_headline_helper(p)
</t>
<t tx="ekr.20120313134250.14302">def write_code_headline_helper (self,p):

    h = p.h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0)
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip()
    if word:
        # Never generate a section for @rst-option or @rst-options or @rst-no-head.
        if word in ('@rst-option','@rst-options','@rst-no-head','@rst-no-headlines'):
            return

        for prefix in ('@rst-ignore-node','@rst-ignore-tree','@rst-ignore'):
            if word == prefix:
                h = h [len(word):].strip()
                break

    if not h.strip(): return

    if self.getOption('show_sections'):
        self.write(self.underline(h,p))
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
</t>
<t tx="ekr.20120313134250.14303">def write_code_node (self,p):

    '''Format a node according to the options presently in effect.

    Side effect: advance p'''

    h = p.h.strip()
    self.scanAllOptions(p)

    if self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.write_code_headline(p)
        self.write_code_body(p)
        p.moveToThreadNext()
</t>
<t tx="ekr.20120313134250.14304">def write_code_tree (self,p,fn):

    '''Write p's tree as code to self.outputFile.'''

    self.scanAllOptions(p) # So we can get the next option.

    if self.getOption('generate_rst_header_comment'):
        self.write('.. rst3: filename: %s\n\n' % fn)

    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    self.topNode = p.copy() # Indicate the top of this tree.
    after = p.nodeAfterTree()
    while p and p != after:
        self.write_code_node(p) # Side effect: advances p.
</t>
<t tx="ekr.20120313134250.14305">def rst3 (self,event=None):

    '''Write all @rst nodes.'''

    self.processTopTree(self.c.p)
</t>
<t tx="ekr.20120313134250.14306">def processTopTree (self,p,justOneFile=False):

    c = self.c ; current = p.copy()

    # This strange looking code looks up and down the tree for @rst nodes.
    for p in current.self_and_parents():
        h = p.h
        if h.startswith('@rst') and not h.startswith('@rst-'):
            self.processTree(p,ext=None,toString=False,justOneFile=justOneFile)
            break
        elif h.startswith('@slides'):
            self.processTree(p,ext=None,toString=False,justOneFile=False)
            break
    else:
        self.processTree(current,ext=None,toString=False,justOneFile=justOneFile)

    g.es_print('done',color='blue')
</t>
<t tx="ekr.20120313134250.14307">def processTree(self,p,ext=None,toString=False,justOneFile=False):

    '''Process all @rst nodes in a tree.
    ext is the docutils extention: it's useful for scripts and unit tests.
    '''

    trace = False and not g.unitTesting
    if trace: g.trace(p.h)
    self.preprocessTree(p)
    found = False ; self.stringOutput = ''
    p = p.copy() ; after= p.nodeAfterTree()
    while p and p != after:
        h = p.h.strip()
        if g.match_word(h,0,"@rst"):
            fn = h[4:].strip()
            if ((fn and fn[0] != '-') or (toString and not fn)):
                if trace: g.trace('found: %s',p.h)
                found = True
                self.write_rst_tree(p,ext,fn,toString=toString,justOneFile=justOneFile)
                self.scanAllOptions(p) # Restore the top-level verbose setting.
                if toString:
                    return p.copy(),self.stringOutput
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        elif g.match(h,0,"@slides"):
            self.write_slides(p)
            found = True
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    if not found:
        g.es('No @rst or @slides nodes in selected tree',color='blue')
    return None,None
</t>
<t tx="ekr.20120313134250.14308">def write_rst_tree (self,p,ext,fn,toString=False,justOneFile=False):

    '''Convert p's tree to rst sources.
    Optionally call docutils to convert rst to output.

    On exit:
        self.source contains rst sources
        self.stringOutput contains docutils output if docutils called.
    '''

    c = self.c
    self.topNode = p.copy()
    self.topLevel = p.level()
    if toString:
        ext = ext or '.html' # 2010/08/12: Unit test found this.
    else:
        junk,ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext.startswith('.'): ext = '.' + ext

    # Init options...
    self.init_write(p) # ScanAllDirectives sets self.path and self.encoding.
    self.scanAllOptions(p) # Settings for p are valid after this call.
    callDocutils = self.getOption('call_docutils')
    writeIntermediateFile = self.getOption('write_intermediate_file')

    # Write the rst sources to self.source.
    self.outputFile = StringIO()
    self.writeTree(p,fn)
    self.source = self.outputFile.getvalue() # the rST sources.
    self.outputFile = None
    self.stringOutput = None

    if callDocutils or writeIntermediateFile:
        self.write_files(ext,fn,callDocutils,toString,writeIntermediateFile)
</t>
<t tx="ekr.20120313134250.14309">def write_slides (self,p,toString=False):

    '''Convert p's children to slides.'''

    c = self.c ; p = p.copy() ; h = p.h
    i = g.skip_id(h,1) # Skip the '@'
    kind,fn = h[:i].strip(),h[i:].strip()
    if not fn: return g.es('%s requires file name' % (kind),color='red')
    title = p and p.firstChild().h or '&lt;no slide&gt;'
    title = title.strip().capitalize()
    n_tot = p.numberOfChildren()

    n = 1
    for child in p.children():
        self.init_write(p) # ScanAllDirectives sets self.path and self.encoding.
        self.scanAllOptions(child) # Settings for child are valid after this call.
        # Compute the slide's file name.
        fn2,ext = g.os_path_splitext(fn)
        fn2 = '%s-%03d%s' % (fn2,n,ext) # Use leading zeros for :glob:.
        n += 1
        # Write the rst sources to self.source.
        self.outputFile = StringIO()
        self.writeSlideTitle(title,n-1,n_tot)
        self.writeBody(child)
        self.source = self.outputFile.getvalue() # the rST sources.
        self.outputFile,self.stringOutput = None,None
        self.write_files(ext,fn2,
            callDocutils=self.getOption('call_docutils'),
            toString=toString,
            writeIntermediateFile=self.getOption('write_intermediate_file'))
</t>
<t tx="ekr.20120313134250.14310">def writeSlideTitle (self,title,n,n_tot):

    '''Write the title, underlined with the '#' character.'''

    if n != 1:
        title = '%s (%s of %s)' % (title,n,n_tot)

    width = max(4,len(g.toEncodedString(title,
        encoding=self.encoding,reportErrors=False)))

    self.write('%s\n%s \n\n' % (title,('#'*width)))
</t>
<t tx="ekr.20120313134250.14311"></t>
<t tx="ekr.20120313134250.14312">def getDocPart (self,lines,n):

    # g.trace('n',n,repr(''.join(lines)))

    result = []
    &lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if g.match_word(s,0,'@code') or g.match_word(s,0,'@c'):
            break
        result.append(s)
    return n, result
</t>
<t tx="ekr.20120313134250.14313">if n &gt; 0:
    line = lines[n-1]
    if line.startswith('@doc'):
        s = line[4:].lstrip()
    elif line.startswith('@'):
        s = line[1:].lstrip()
    else:
        s = ''

    # New in Leo 4.4.4: remove these special tags.
    for tag in ('@rst-options','@rst-option','@rst-markup'):
        if g.match_word(s,0,tag):
            s = s[len(tag):].strip()

    if s.strip():
        result.append(s)
</t>
<t tx="ekr.20120313134250.14314">def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    # g.trace(kind,g.listToString(lines))

    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20120313134250.14315">def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()
</t>
<t tx="ekr.20120313134250.14316">def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
</t>
<t tx="ekr.20120313134250.14317">def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) &gt; 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    # g.trace('kind %s, result %s, s %s' % (
        # repr(kind),result,repr(s)))

    return result
</t>
<t tx="ekr.20120313134250.14318">def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,1,key):
                    # g.trace('removing %s' % s)
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20120313134250.14319">def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result
</t>
<t tx="ekr.20120313134250.14320">def skip_literal_block (self,lines,n):

    s = lines[n] ; result = [s] ; n += 1
    indent = g.skip_ws(s,0)

    # Skip lines until a non-blank line is found with same or less indent.
    while n &lt; len(lines):
        s = lines[n]
        indent2 = g.skip_ws(s,0)
        if s and not s.isspace() and indent2 &lt;= indent:
            break # We will rescan lines [n]
        n += 1
        result.append(s)

    # g.printList(result,tag='literal block')
    return n, result
</t>
<t tx="ekr.20120313134250.14330">def writeHeadline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''

    docOnly             = self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    ignoreNowebDefs     = self.getOption('ignore_noweb_definitions')
    showHeadlines       = self.getOption('show_headlines')
    showOrganizers      = self.getOption('show_organizer_nodes')
    showThisHeadline    = self.getOption('show_this_headline')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers or
        ignoreNowebDefs and self.isSectionDef(p) # 2011/06/10.
    ):
        return

    self.writeHeadlineHelper(p)
</t>
<t tx="ekr.20120313134250.14331">def writeHeadlineHelper (self,p):

    h = p.h
    if not self.atAutoWrite:
        h = h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0)
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip()
    if word:
        # Never generate a section for these...
        if word in (
            '@rst-option','@rst-options',
            '@rst-no-head','@rst-no-headlines'
        ):
            return

        # Remove all other headline commands from the headline.
        for command in self.headlineCommands:
            if word == command:
                h = h [len(word):].strip()
                break

        # New in Leo 4.4.4.
        if word.startswith('@'):
            if self.getOption('strip_at_file_prefixes'):
                for s in ('@auto','@file','@nosent','@thin',):
                    if g.match_word(word,0,s):
                        h = h [len(s):].strip()

    if not h.strip(): return

    if self.getOption('show_sections'):
        if self.getOption('generate_rst'):
            self.write(self.underline(h,p)) # Used by @auto-rst.
        else:
            self.write('\n%s\n\n' % h)
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
</t>
<t tx="ekr.20120313134250.14332">def writeNode (self,p):

    '''Format a node according to the options presently in effect.'''

    self.initCodeBlockString(p)
    self.scanAllOptions(p)

    if 0:
        g.trace('%24s code_mode %s' % (p.h,self.getOption('code_mode')))

    h = p.h.strip()

    if self.getOption('preformat_this_node'):
        self.http_addNodeMarker(p)
        self.writePreformat(p)
        p.moveToThreadNext()
    elif self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.writeHeadline(p)
        self.writeBody(p)
        p.moveToThreadNext()
</t>
<t tx="ekr.20120313134250.14333">def writePreformat (self,p):

    '''Write p's body text lines as if preformatted.

     ::

        line 1
        line 2 etc.
    '''

    # g.trace(p.h,g.callers())

    lines = p.b.split('\n')
    lines = [' '*4 + z for z in lines]
    lines.insert(0,'::\n')

    s = '\n'.join(lines)
    if s.strip():
        self.write('%s\n\n' % s)
</t>
<t tx="ekr.20120313134250.14334">def writeTree(self,p,fn):

    '''Write p's tree to self.outputFile.'''

    self.scanAllOptions(p)

    if self.getOption('generate_rst'):
        if self.getOption('generate_rst_header_comment'):
            self.write(self.rstComment(
                'rst3: filename: %s\n\n' % fn))

    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    after = p.nodeAfterTree()
    while p and p != after:
        self.writeNode(p) # Side effect: advances p.
</t>
<t tx="ekr.20120313134250.14335">def writeNodeToString (self,p=None,ext=None):

    '''Scan p's tree (defaults to presently selected tree) looking for @rst nodes.
    Convert the first node found to an ouput of the type specified by ext.

    The @rst may or may not be followed by a filename; the filename is *ignored*,
    and its type does not affect ext or the output generated in any way.

    ext should start with a period: .html, .tex or None (specifies rst output).

    Returns (p, s), where p is the position of the @rst node and s is the converted text.'''

    c = self.c ; current = p or c.p

    for p in current.self_and_parents():
        if p.h.startswith('@rst'):
            return self.processTree(p,ext=ext,toString=True,justOneFile=True)
    else:
        return self.processTree(current,ext=ext,toString=True,justOneFile=True)
</t>
<t tx="ekr.20120313134250.14336">def writeAtAutoFile (self,p,fileName,outputFile,trialWrite=False):

    '''Write an @auto tree containing imported rST code.
    The caller will close the output file.'''

    try:
        self.trialWrite = trialWrite
        self.atAutoWrite = True
        self.initAtAutoWrite(p,fileName,outputFile)
        self.topNode = p.copy() # Indicate the top of this tree.
        self.topLevel = p.level()
        after = p.nodeAfterTree()
        ok = self.isSafeWrite(p)
        if ok:
            p = p.firstChild() # A hack: ignore the root node.
            while p and p != after:
                self.writeNode(p) # side effect: advances p
    finally:
        self.atAutoWrite = False
    return ok
</t>
<t tx="ekr.20120313134250.14337">def initAtAutoWrite(self,p,fileName,outputFile):

    # Set up for a standard write.
    self.createDefaultOptionsDict()
    self.nodeOptionDict = {}
    self.scanAllOptions(p)
    self.init_write(p)
    self.preprocessTree(p) # Allow @ @rst-options, for example.
    # Do the overrides.
    self.outputFile = outputFile
    # Set underlining characters.
    # It makes no sense to use user-defined
    # underlining characters in @auto-rst.
    d = p.v.u.get('rst-import',{})
    underlines2 = d.get('underlines2','')
        # Do *not* set a default for overlining characters.
    if len(underlines2) &gt; 1:
        underlines2 = underlines2[0]
        g.trace('too many top-level underlines, using %s' % (
            underlines2),color='blue')
    underlines1 = d.get('underlines1','')
    # Bug fix:  2010/05/26: pad underlines with default characters.
    default_underlines = '=+*^~"\'`-:&gt;&lt;_'
    if underlines1:
        for ch in default_underlines[1:]:
            if ch not in underlines1:
                underlines1 = underlines1 + ch
    else:
        underlines1 = default_underlines
    self.atAutoWriteUnderlines   = underlines2 + underlines1
    self.underlines1 = underlines1
    self.underlines2 = underlines2
</t>
<t tx="ekr.20120313134250.14338">def isSafeWrite (self,p):

    '''Return True if node p contributes nothing but
    rst-options to the write.'''

    if self.trialWrite or not p.isAtAutoRstNode():
        return True # Trial writes are always safe.

    lines = g.splitLines(p.b)
    for z in lines:
        if z.strip() and not z.startswith('@') and not z.startswith('.. '):
            # A real line that will not be written.
            g.es('unsafe @auto-rst',color='red')
            g.es('body text will be ignored in\n',p.h)
            return False
    else:
        return True
</t>
<t tx="ekr.20120313134250.14339"></t>
<t tx="ekr.20120313134250.14341">def dumpSettings (self):

    d = self.optionsDict
    keys = sorted(d)

    g.pr('present settings...')
    for key in keys:
        g.pr('%20s %s' % (key,d.get(key)))
</t>
<t tx="ekr.20120313134250.14342">def getOption (self,name):

    # 2010/08/12: munging names here is safe because setOption munges.
    # g.trace(name,self.optionsDict.get(self.munge(name)))
    return self.optionsDict.get(self.munge(name))

def setOption (self,name,val,tag=None):

    self.optionsDict [self.munge(name)] = val
</t>
<t tx="ekr.20120313134250.14343">def initCodeBlockString(self,p):

    trace = False and not g.unitTesting
    c = self.c
    # if trace: os.system('cls')
    d = c.scanAllDirectives(p)
    language = d.get('language')
    if language is None: language = 'python'
    else: language = language.lower()
    syntax = SilverCity is not None

    if trace: g.trace('language',language,'language.title()',language.title(),p.h)

    # Note: lines that end with '\n\n' are a signal to handleCodeMode.
    s = self.getOption('code_block_string')
    if s:
        self.code_block_string = s.replace('\\n','\n')
    elif syntax and language in ('python','ruby','perl','c'):
        self.code_block_string = '**code**:\n\n.. code-block:: %s\n\n' % (
            language.title())
    else:
        self.code_block_string = '**code**:\n\n.. class:: code\n..\n\n::\n\n'
</t>
<t tx="ekr.20120313134250.14344">def preprocessTree (self,root):

    self.nodeOptionDict = {}

    # Bug fix 12/4/05: must preprocess parents too.
    for p in root.parents():
        self.preprocessNode(p)

    for p in root.self_and_subtree():
        self.preprocessNode(p)

    if 0:
        g.trace(root.h)
        for key in self.nodeOptionDict.keys():
            g.trace(key)
            g.printDict(self.nodeOptionDict.get(key))
</t>
<t tx="ekr.20120313134250.14345">def preprocessNode (self,p):

    d = self.nodeOptionDict.get(p.v)
    if d is None:
        d = self.scanNodeForOptions(p)
        self.nodeOptionDict [p.v] = d
</t>
<t tx="ekr.20120313134250.14346">def parseOptionLine (self,s):

    '''Parse a line containing name=val and return (name,value) or None.

    If no value is found, default to True.'''

    s = s.strip()
    if s.endswith(','): s = s[:-1]
    # Get name.  Names may contain '-' and '_'.
    i = g.skip_id(s,0,chars='-_')
    name = s [:i]
    if not name: return None
    j = g.skip_ws(s,i)
    if g.match(s,j,'='):
        val = s [j+1:].strip()
        # g.trace(val)
        return name,val
    else:
        # g.trace('*True')
        return name,'True'
</t>
<t tx="ekr.20120313134250.14347">def scanForOptionDocParts (self,p,s):

    '''Return a dictionary containing all options from @rst-options doc parts in p.
    Multiple @rst-options doc parts are allowed: this code aggregates all options.
    '''

    d = {} ; n = 0 ; lines = g.splitLines(s)
    while n &lt; len(lines):
        line = lines[n] ; n += 1
        if line.startswith('@'):
            i = g.skip_ws(line,1)
            for kind in ('@rst-options','@rst-option'):
                if g.match_word(line,i,kind):
                    # Allow options on the same line.
                    line = line[i+len(kind):]
                    d.update(self.scanOption(p,line))
                    # Add options until the end of the doc part.
                    while n &lt; len(lines):
                        line = lines[n] ; n += 1 ; found = False
                        for stop in ('@c','@code', '@'):
                            if g.match_word(line,0,stop):
                                found = True ; break
                        if found:
                            break
                        else:
                            d.update(self.scanOption(p,line))
                    break
    return d
</t>
<t tx="ekr.20120313134250.14348">def scanHeadlineForOptions (self,p):

    '''Return a dictionary containing the options implied by p's headline.'''

    h = p.h.strip()

    if p == self.topNode:
        return {} # Don't mess with the root node.
    elif g.match_word(h,0,'@rst-option'):
        s = h [len('@rst-option'):]
        return self.scanOption(p,s)
    elif g.match_word(h,0,'@rst-options'):
        return self.scanOptions(p,p.b)
    else:
        # Careful: can't use g.match_word because options may have '-' chars.
        i = g.skip_id(h,0,chars='@-')
        word = h[0:i]

        for option,ivar,val in (
            ('@rst',                'code_mode',False),
            ('@rst-code',           'code_mode',True),
            ('@rst-default-path',   'default_prefix',''),
            ('@rst-doc-only',       'doc_only_mode',True),
            ('@rst-head',           'show_this_headline',True),
            # ('@rst-head' ,        'show_headlines',False),
            ('@rst-ignore',         'ignore_this_tree',True),
            ('@rst-ignore-node',    'ignore_this_node',True),
            ('@rst-ignore-tree',    'ignore_this_tree',True),
            ('@rst-no-head',        'ignore_this_headline',True),
            ('@rst-preformat',      'preformat_this_node',True),
        ):
            if word == option:
                d = { ivar: val }
                # Special case: code mode and doc-only modes are linked.
                if ivar == 'code_mode':
                    d ['doc_only_mode'] = False
                elif ivar == 'doc_only_mode':
                    d ['code_mode'] = False
                # Special case: Treat a bare @rst like @rst-no-head
                if h == '@rst':
                    d ['ignore_this_headline'] = True
                # g.trace(repr(h),d)
                return d

        if h.startswith('@rst'):
            g.trace('unknown kind of @rst headline',p.h,g.callers(4))

        return {}
</t>
<t tx="ekr.20120313134250.14349">def scanNodeForOptions (self,p):

    '''Return a dictionary containing all the option-name:value entries in p.

    Such entries may arise from @rst-option or @rst-options in the headline,
    or from @ @rst-options doc parts.'''
    
    trace = False and not g.unitTesting

    h = p.h

    d = self.scanHeadlineForOptions(p)

    d2 = self.scanForOptionDocParts(p,p.b)

    # A fine point: body options over-ride headline options.
    d.update(d2)
    
    if trace and d:
        g.trace(h)
        for z in sorted(d):
            print('    %s: %s' % (z,d.get(z)))

    return d
</t>
<t tx="ekr.20120313134250.14350">def scanOption (self,p,s):

    '''Return { name:val } if s is a line of the form name=val.
    Otherwise return {}'''

    if not s.strip() or s.strip().startswith('..'): return {}

    data = self.parseOptionLine(s)

    if data:
        name,val = data
        if self.munge(name) in list(self.defaultOptionsDict.keys()):
            if   val.lower() == 'true': val = True
            elif val.lower() == 'false': val = False
            # g.trace('%24s %8s %s' % (self.munge(name),val,p.h))
            return { self.munge(name): val }
        else:
            g.es_print('ignoring unknown option: %s' % (name),color='red')
            return {}
    else:
        g.trace(repr(s))
        s2 = 'bad rst3 option in %s: %s' % (p.h,s)
        g.es_print(s2,color='red')
        return {}
</t>
<t tx="ekr.20120313134250.14351">def scanOptions (self,p,s):

    '''Return a dictionary containing all the options in s.'''

    d = {}

    for line in g.splitLines(s):
        d2 = self.scanOption(p,line)
        if d2: d.update(d2)

    return d
</t>
<t tx="ekr.20120313134250.14352"># Once an option is seen, no other related options in ancestor nodes have any effect.

def scanAllOptions(self,p):

    '''Scan position p and p's ancestors looking for options,
    setting corresponding ivars.
    '''

    self.initOptionsFromSettings() # Must be done on every node.
    self.handleSingleNodeOptions(p)
    seen = self.singleNodeOptions[:] # Suppress inheritance of single-node options.

    # g.trace('-'*20)
    for p in p.self_and_parents():
        d = self.nodeOptionDict.get(p.v,{})
        # g.trace(p.h,d)
        for key in d.keys():
            ivar = self.munge(key)
            if not ivar in seen:
                seen.append(ivar)
                val = d.get(key)
                self.setOption(key,val,p.h)

    if self.rst3_all:
        self.setOption("generate_rst", True, "rst3_all")
        self.setOption("generate_rst_header_comment",True, "rst3_all")
        self.setOption("http_server_support", True, "rst3_all")
        self.setOption("write_intermediate_file", True, "rst3_all")
</t>
<t tx="ekr.20120313134250.14353">def initOptionsFromSettings (self):

    c = self.c

    d = self.defaultOptionsDict
    keys = sorted(d)

    for key in keys:
        for getter,kind in (
            (c.config.getBool,'@bool'),
            (c.config.getString,'@string'),
            (d.get,'default'),
        ):
            val = getter(key)
            if kind == 'default' or val is not None:
                self.setOption(key,val,'initOptionsFromSettings')
                break

    # 2010/08/12: Script settings override everything else.
    d2 = self.scriptSettingsDict or {}
    for key in d2.keys():
        val = d2.get(key)
        # g.trace(key,val)
        self.setOption(key,val,'initOptionsFromSettings')

    # Special case.
    if self.getOption('http_server_support') and not mod_http:
        g.es('No http_server_support: can not import mod_http plugin',color='red')
        self.setOption('http_server_support',False)
</t>
<t tx="ekr.20120313134250.14354">def handleSingleNodeOptions (self,p):

    '''Init the settings of single-node options from the tnodeOptionsDict.

    All such options default to False.'''

    d = self.nodeOptionDict.get(p.v, {} )

    for ivar in self.singleNodeOptions:
        val = d.get(ivar,False)
        #g.trace('%24s %8s %s' % (ivar,val,p.h))
        self.setOption(ivar,val,p.h)

</t>
<t tx="ekr.20120313134250.14355">def createDefaultOptionsDict(self):

    # Important: these must be munged names.
    self.defaultOptionsDict = {
        # Http options...
        'clear_http_attributes':   False,
        'http_server_support':     False,
        'http_attributename':      'rst_http_attribute',
        'node_begin_marker':       'http-node-marker-',
        # Path options...
        'default_path': None, # New in Leo 4.4a4 # Bug fix: must be None, not ''.
        'stylesheet_name': 'default.css',
        'stylesheet_path': None, # Bug fix: must be None, not ''.
        'stylesheet_embed': True,
        'publish_argv_for_missing_stylesheets': None,
        # Global options...
        'call_docutils': True, # 2010/08/05
        'code_block_string': '',
        'number_code_lines': True,
        'underline_characters': '''#=+*^~"'`-:&gt;&lt;_''',
        'verbose':True,
        'write_intermediate_file': False, # Used only if generate_rst is True.
        'write_intermediate_extension': '.txt',
        # Mode options...
        'code_mode': False, # True: generate rst markup from @code and @doc parts.
        'doc_only_mode': False, # True: generate only from @doc parts.
        'generate_rst': True, # True: generate rst markup.  False: generate plain text.
        'generate_rst_header_comment': True,
            # True generate header comment (requires generate_rst option)
        # Formatting options that apply to both code and rst modes....
        'expand_noweb_references': False,
        'ignore_noweb_definitions': False,
        'expand_noweb_recursively': True,
        'show_headlines': True,  # Can be set by @rst-no-head headlines.
        'show_organizer_nodes': True,
        'show_options_nodes': False,
        'show_sections': True,
        'strip_at_file_prefixes': True,
        'show_doc_parts_in_rst_mode': True,
        # Formatting options that apply only to code mode.
        'show_doc_parts_as_paragraphs': False,
        'show_leo_directives': True,
        'show_markup_doc_parts': False,
        'show_options_doc_parts': False,
    }
</t>
<t tx="ekr.20120313134250.14356">def writeBody (self,p):

    trace = False and not g.unitTesting
   
    if self.getOption('ignore_noweb_definitions'):
        # 2011/06/10: Ignore section definition nodes.
        name = self.isSectionDef(p)
        if name:
            if trace: g.trace('section def: %s' % (repr(name)))
            return

    # remove trailing cruft and split into lines.
    lines = g.splitLines(p.b)

    if self.getOption('code_mode'):
        # Important: code mode is no longer documented!
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('expand_noweb_references'):
            # 2011/06/10.
            lines = self.expandSectionRefs(lines,p,seen=[])
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    # Write the lines.
    s = ''.join(lines)

    # We no longer add newlines to the start of nodes because
    # we write a blank line after all sections.
    # s = g.ensureLeadingNewlines(s,1)
    s = g.ensureTrailingNewlines(s,2)
    self.write(s)
</t>
<t tx="ekr.20120313134250.14357">def isSectionDef (self,p):
    
    return self.isSectionRef(p.h)
    
def isSectionRef (self,s):

    n1 = s.find("&lt;&lt;",0)
    n2 = s.find("&gt;&gt;",0)
    return -1 &lt; n1 &lt; n2 and s[n1+2:n2].strip()
</t>
<t tx="ekr.20120313134250.14358">def expandSectionRefs (self,lines,p,seen):
    
    trace = False and not g.unitTesting
    
    if trace: g.trace(p.h,g.callers())

    result = []
    for s in lines:
        name = self.isSectionRef(s)
        if name:
            p2 = self.findSectionDef(name,p)
            if p2:
                g.trace('expanding: %s from %s' % (name,p2.h))
                result.append(s) # Append the section reference line.
                lines2 = g.splitLines(p2.b)
                if self.getOption('expand_noweb_recursively'):
                    if name in seen:
                        pass # Prevent unbounded recursion
                    else:
                        seen.append(name)
                        result.extend(self.expandSectionRefs(lines2,p,seen))
                else:
                    result.extend(lines2)
            else:
                # Undefined reference.
                result.append(s)
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20120313134250.14359">def findSectionDef (self,name,p):
    
    for p2 in p.subtree():
        name2 = self.isSectionDef(p2)
        if name2:
            return p2
    
    return None
</t>
<t tx="ekr.20120313134250.14360">def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    trace = False and not g.unitTesting
    result = [] ; n = 0 ; code = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or (
                self.getOption('show_doc_parts_as_paragraphs') and
                self.isSpecialDocPart(s,None)
            )
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            # A fix, perhaps dubious, to a bug discussed at
            # http://groups.google.com/group/leo-editor/browse_thread/thread/c212814815c92aac
            # lines2 = [z.lstrip() for z in lines2]
            # g.trace('lines2',lines2)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        else:
            if not code: # Start the code block.
                result.append('')
                result.append(self.code_block_string)

            if trace: g.trace('code line: %s' % repr(s))
            code.append(s)
       
        # elif not code: # Start the code block.
            # result.append('')
            # result.append(self.code_block_string)
            # if trace: g.trace('code line: %s' % repr(s))
            # code.append(s)
        # else: # Continue the code block.
            # if trace: g.trace('code line: %s' % repr(s))
            # code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []

    # Munge the result so as to keep docutils happy.
    # Don't use self.rstripList: it's not the same.
    # g.trace(result)
    result2 = []
    for z in result:
        if z == '': result2.append('\n\n')
        # 2010/08/27: Fix bug 618482.
        # elif not z.rstrip(): pass
        elif z.endswith('\n\n'): result2.append(z) # Leave alone.
        else: result2.append('%s\n' % z.rstrip())

    return result2
</t>
<t tx="ekr.20120313134250.14361">def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
</t>
<t tx="ekr.20120313134250.14362">def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    # 2010/08/27: fix bug 618482.
    s = ''.join(theList).rstrip()
    return s.split('\n')
</t>
<t tx="ekr.20120313134250.14363">def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
</t>
<t tx="ekr.20120313134250.14364">def handleDocOnlyMode (self,p,lines):

    '''Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.'''

    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.h)
            self.writeHeadlineHelper(p)
    return result
</t>
<t tx="ekr.20120314095341.14215"></t>
<t tx="ekr.20120314095341.14216">There no need to disable buttons and commands with \@@button
or \@@command.
</t>
<t tx="ekr.20120314095341.15571"></t>
<t tx="ekr.20120314095341.15572"></t>
<t tx="ekr.20120314095341.15573"></t>
<t tx="ekr.20120314095341.15575"></t>
<t tx="ekr.20120315101404.14221">http://groups.google.com/group/leo-editor/browse_thread/thread/f13fadac68eec41b/9124ba6d733ecbad
leoInspect: a hobby with a future?

http://groups.google.com/group/leo-editor/browse_thread/thread/62f0e7b84a25e0d0/39f848ad8a96bcbc
leoInspect: remarkable collapse in complexity and attempted assessment

</t>
<t tx="sps.20100708203040.19008">@language python
import os
pos = c.find_h("Users Guide")[0]
c.selectPosition(pos)
c.k.simulateCommand('rst3')
&lt;&lt; html manual &gt;&gt;
&lt;&lt; pdf manual &gt;&gt;
</t>
<t tx="sps.20100708203040.19009">d = c.scanAllDirectives(p)
mandir = d.get('path') + "/html"
g.es(mandir)
os.chdir(mandir)
os.system('make html')
</t>
<t tx="sps.20100708203040.19010"># you probably need to install several packages 
# to create pdf (e.g. jadetex)
mandir = d.get('path') + "/html"
g.es(mandir)
os.chdir(mandir)
os.system('make latex')
os.chdir('_build/latex')
os.system('../../fixup.pl &lt; Leodocumentation.tex &gt; LeoDoc.tex')
os.system('make LeoDoc.pdf')
</t>
<t tx="sps.20100708213227.44914"></t>
<t tx="ville.20090705224948.5734">import os
pos = c.find_h("Users Guide")[0]
c.selectPosition(pos)
c.k.simulateCommand('rst3')
&lt;&lt; html manual &gt;&gt;
# no pdf manual creation, perhaps too "involved" for many
</t>
<t tx="ville.20090705225609.5736">mandir = g.app.leoDir + "/doc/html"
g.es(mandir)
os.chdir(mandir)
os.system('make html')
</t>
<t tx="ville.20090705225609.5738"># you probably need to install several packages 
# to create pdf (e.g. jadetex)
mandir = g.app.leoDir + "/doc/html"
g.es(mandir)
os.chdir(mandir)
os.system('make latex')
os.chdir('_build/latex')
os.system('make all-pdf')
</t>
</tnodes>
</leo_file>
