<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="33" left="706" height="1008" width="1205"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20080129151228"><vh>Startup</vh>
<v t="ekr.20080129151123"><vh>@chapters</vh></v>
<v t="ekr.20070315073704"><vh>@settings</vh>
<v t="ekr.20070315073704.1"><vh>@enabled-plugins</vh></v>
<v t="ekr.20091104114053.3903"><vh>@bool warn_about_redefined_shortcuts = False</vh></v>
<v t="ekr.20070315073704.2"><vh>vim plugin</vh>
<v t="ekr.20070315073704.3"><vh>@string vim_cmd = c:\vim\vim63\gvim --servername LEO</vh></v>
<v t="ekr.20070315073704.4"><vh>@string vim_exe = c:\vim\vim63\gvim</vh></v>
</v>
</v>
<v t="ekr.20060901144246"><vh>buttons</vh>
<v t="ekr.20060901144331"><vh>@button prev-show  @key=Alt-4</vh></v>
<v t="ekr.20060901144149.3"><vh>@button next-show  @key=Alt-5</vh></v>
<v t="ekr.20060901144149.2"><vh>@button prev-slide @key=Alt-6</vh></v>
<v t="ekr.20060901144359"><vh>@button next-slide @key=Alt-7</vh></v>
<v t="ekr.20060902092242"><vh>@button make-slide @key=Alt-0</vh></v>
</v>
</v>
<v t="ekr.20060901142356"><vh>Read me first</vh></v>
<v t="ekr.20060901144149.4" a="E"><vh>Sounds</vh>
<v t="ekr.20060901144149.5"><vh>@url http://mail.python.org/pipermail/python-list/2004-October/248738.html</vh></v>
<v t="ekr.20060901144149.6"><vh>@url c:\prog\Sounds\s1.wav</vh></v>
<v t="ekr.20060901144149.7"><vh>@url c:\prog\Sounds\s2.wav</vh></v>
</v>
<v t="ekr.20091104114348.12072"><vh>Leo Tech report</vh>
<v t="ekr.20091104114348.12073"><vh>@rst html\techReport.html</vh>
<v t="ekr.20091104114348.12089"><vh>Old</vh>
<v t="ekr.20091104114348.12074"><vh>Leo’s window, outlines &amp; clones</vh></v>
<v t="ekr.20091104114348.12075"><vh>Relations: organizer nodes, views, tasks and metadata</vh></v>
<v t="ekr.20091104114348.12076"><vh>Plugins</vh></v>
<v t="ekr.20091104114348.12077"><vh>Derived files and special nodes</vh></v>
<v t="ekr.20091104114348.12078"><vh>Markup for scripts</vh></v>
<v t="ekr.20091104114348.12079"><vh>Scripting Leo</vh></v>
<v t="ekr.20091104114348.12080"><vh>Leo’s modules and classes</vh></v>
<v t="ekr.20091104114348.12081"><vh>Predefined symbols in scripts</vh></v>
<v t="ekr.20091104114348.12082"><vh>Accessing data</vh></v>
<v t="ekr.20091104114348.12083"><vh>Traversing outlines</vh></v>
<v t="ekr.20091104114348.12084"><vh>Executing commands from scripts</vh></v>
<v t="ekr.20091104114348.12085"><vh>Bringing scripts to data</vh></v>
<v t="ekr.20091104114348.12086"><vh>Unit Testing with @test and @suite nodes</vh></v>
<v t="ekr.20091104114348.12087"><vh>Plugins and hooks</vh></v>
<v t="ekr.20091104114348.12088"><vh>Contacts</vh></v>
</v>
</v>
</v>
<v t="ekr.20060902101656" a="E"><vh>Slide shows</vh>
<v t="ekr.20060902092259"><vh>@slideshow scripting Leo</vh>
<v t="ekr.20060902092341.4" a="E"><vh>Leo's classes and objects</vh>
<v t="ekr.20091103090815.1427"><vh>c, g and p</vh></v>
<v t="ekr.20091103090815.1428"><vh>g.app</vh></v>
<v t="ekr.20091103090815.1429"><vh>commanders: c</vh></v>
<v t="ekr.20091103090815.1431"><vh>frames: c.frame, c.frame.body, etc.</vh></v>
<v t="ekr.20091103090815.1430"><vh>positions and iterators</vh></v>
<v t="ekr.20091103090815.1432"><vh>vnodes</vh></v>
</v>
<v t="ekr.20091103090815.1433"><vh>Useful methods</vh>
<v t="ekr.20060902092341.5"><vh>g.es writes to the log tab</vh></v>
<v t="ekr.20091103090815.1426"><vh>g.es can write to other tabs</vh></v>
<v t="ekr.20060902092341.6"><vh>app.windowList: the list of all open frames</vh></v>
<v t="ekr.20060902092341.7"><vh>Getting and setting headline and body text</vh></v>
<v t="ekr.20060902092341.9"><vh>Copying positions</vh></v>
<v t="ekr.20060902092341.8"><vh>Traversing outlines with generators.</vh>
<v t="ekr.20060902092341.10"><vh>c.all_positions</vh></v>
<v t="ekr.20060902092341.11"><vh>p.children_iter</vh></v>
<v t="ekr.20060902092341.12"><vh>p.parents_iter &amp; p.self_and_parents_iter</vh></v>
<v t="ekr.20060902092341.13"><vh>p.siblings_iter &amp; p.following_siblings_iter</vh></v>
<v t="ekr.20060902092341.14"><vh>p.subtree_iter &amp; p.self_and_subtree_iter</vh></v>
<v t="ekr.20060902092341.15"><vh>Testing whether a position is valid</vh></v>
</v>
<v t="ekr.20060902092341.16"><vh>Updating the screen</vh></v>
<v t="ekr.20060902092341.17"><vh>Invoking commands from scripts</vh></v>
<v t="ekr.20060902092341.18"><vh>Getting settings from @settings trees</vh></v>
<v t="ekr.20060902092341.19"><vh>Getting and setting preferences</vh></v>
<v t="ekr.20060902092341.20"><vh>Functions for finding and changing text from scripts</vh></v>
<v t="ekr.20060902092341.21"><vh>Running Leo in batch mode</vh></v>
<v t="ekr.20060902092341.22"><vh>Functions defined in leoGlobals.py</vh></v>
<v t="ekr.20060902092341.23"><vh>Redirecting output from scripts</vh></v>
<v t="ekr.20060902092341.24"><vh>Adding new Tabs to the log pane</vh></v>
<v t="ekr.20060902092341.25"><vh>Summary of the vnode and position classes</vh>
<v t="ekr.20060902092341.26"><vh>Iterators</vh></v>
<v t="ekr.20060902092341.27"><vh>Getters</vh></v>
<v t="ekr.20060902092341.28"><vh>Setters</vh></v>
</v>
<v t="ekr.20060902092341.29"><vh>Creating script buttons</vh></v>
<v t="ekr.20060902092341.30"><vh>@test and @suite nodes</vh>
<v t="ekr.20060902095933"><vh>@test nodes</vh></v>
<v t="ekr.20060902095933.1"><vh>@suite nodes</vh></v>
</v>
<v t="ekr.20060902100250"><vh>conclusion</vh></v>
</v>
</v>
<v t="ekr.20060901153101" a="E"><vh>@slideshow Introduction to Leo</vh>
<v t="ekr.20091104114348.12090"><vh>Leo is an outliner on a mission</vh></v>
<v t="ekr.20091104114348.12092"><vh>Leo is designed to handle complex data</vh></v>
<v t="ekr.20091104114348.12093"><vh>Leo is for power users</vh></v>
<v t="ekr.20091104114348.12094"><vh>Leo's power tools</vh>
<v t="ekr.20091104114348.12099"><vh>Power tool #1: Leo outlines are graphs</vh></v>
<v t="ekr.20091104114348.12100" a="E"><vh>Power tool #2: Python scripting is available everywhere</vh>
<v t="ekr.20091104114348.12102"><vh>Leo is 100% pure Python</vh></v>
<v t="ekr.20091104114348.12103"><vh>Leo's outlines and nodes are true Python objects</vh></v>
<v t="ekr.20091104114348.12104"><vh>Any node can contain a Leo script</vh></v>
<v t="ekr.20091104114348.12107" a="E"><vh>Scripts can access everything</vh>
<v t="ekr.20091104114348.12118"><vh>An example script</vh></v>
</v>
<v t="ekr.20091104114348.12105" a="E"><vh>Script buttons bring scripts to data</vh>
<v t="ekr.20091104114348.12119"><vh>@button print slideshow</vh></v>
</v>
</v>
<v t="ekr.20091104114348.12109" a="E"><vh>Power tool #3: Outline structure matters everywhere</vh>
<v t="ekr.20091104114348.12110"><vh>Leo can manage external files</vh></v>
<v t="ekr.20091104114348.12101"><vh>Outlines create scripts and external files</vh></v>
<v t="ekr.20091104114348.12111" a="E"><vh>Commands understand outline structure</vh>
<v t="ekr.20091104114348.12120"><vh>Example: organizing scripts</vh>
<v t="ekr.20091104114348.12121"><vh>@noslide myClass</vh></v>
</v>
<v t="ekr.20091104114348.12112"><vh>Example: the search command</vh></v>
<v t="ekr.20091104114348.12113"><vh>Example: @test nodes</vh></v>
</v>
<v t="ekr.20091104114348.12115"><vh>@x headlines denote typed data</vh></v>
</v>
</v>
<v t="ekr.20091104114348.12095"><vh>Summary</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20060901142356">@nocolor

This file contains several slideshows illustrating Leo's features.

You control these slides shows using four buttons in the icon bar:

- 'prev-show' (Alt-4) and 'next-show' (Alt-5) move backward and forward to the start of a slideshow.

- 'prev-slide' (Alt-6) and 'next-slide' (Alt-7) move backward and forward to slides *within* a slideshow.

Now press the 'next-show' button (or type Alt-5, or type Alt-x next-show)
to take you to the first slideshow: 'Introduction to Leo'.</t>
<t tx="ekr.20060901144149.2">c.k.simulateCommand('prev-slide-command')</t>
<t tx="ekr.20060901144149.3">c.k.simulateCommand('next-slide-show-command')</t>
<t tx="ekr.20060901144149.4">from PMIDI import * 
from time import sleep </t>
<t tx="ekr.20060901144149.5"></t>
<t tx="ekr.20060901144149.6"></t>
<t tx="ekr.20060901144149.7"></t>
<t tx="ekr.20060901144246">@color

@ A point that can cause confusion:
    
The slideshow.py plugin defines four commands whose names end in -command. It
would be possible to bind shortcuts for *these* commands in leoSettings.leo or
myLeoSettings.leo

The buttons below define commands whose names do *not* end in -command. These
button define shortcuts for these buttons using the @key syntax.</t>
<t tx="ekr.20060901144331">c.k.simulateCommand('prev-slide-show-command')</t>
<t tx="ekr.20060901144359">c.k.simulateCommand('next-slide-command')</t>
<t tx="ekr.20060901153101">@language rest
</t>
<t tx="ekr.20060902092242">c.beginUpdate()

try:
    p1 = p.copy()
    undoData = c.undoer.beforeChangeTree(p1)
    for p in c.currentPosition().self_and_subtree_iter():
        h = p.headString().strip()
        if not h.startswith('@slide'):
            p.setHeadString('@slide ' + h)
    c.undoer.afterChangeTree(p1,'make-slide',undoData)
finally:
    c.endUpdate()
</t>
<t tx="ekr.20060902092259">@nocolor

This slideshow describes the most useful functions, classes and methods in
leo.py. Keep in mind that *your scripts have complete access to all of Leo's
source code*, that is, all the code in LeoPy.leo. Your scripts can use Leo's
code in whatever ways are convenient. You are *not* limited by what you see in
this chapter.

**Important:** You can execute all the code in this slideshow. Just select the
code you want to execute and run the Execute Script command.

**Important**: Python is finicky about indentation, so you must be careful to
select the leading whitespace of the first line.

@color</t>
<t tx="ekr.20060902092341.4" rst_http_attribute="5d71002855443c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3122206e616d653d22687474702d6e6f64652d6d61726b65722d31223e710155043c2f613e71025d710328553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710455063c2f6469763e71055d71062855063c626f64793e710755073c2f626f64793e71085d71092855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710a55073c2f68746d6c3e710b4e65656555243c64697620636c6173733d2273656374696f6e222069643d226f76657276696577223e0a710c55493c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643122206e616d653d226f76657276696577223e4f766572766965773c2f613e3c2f68313e0a710d652e"># Note: Everything between '@' and '@c' is a comment.

@
Leo's source code is a collection of classes, and utility functions.
@c
</t>
<t tx="ekr.20060902092341.5" rst_http_attribute="5d71002855443c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3522206e616d653d22687474702d6e6f64652d6d61726b65722d35223e710155043c2f613e71025d71032855403c64697620636c6173733d2273656374696f6e222069643d22672d746f702d7468652d636f6d6d616e6465722d6f662d7468652d746f702d77696e646f77223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f55363c64697620636c6173733d2273656374696f6e222069643d22672d65732d77726974652d746f2d7468652d6c6f672d70616e65223e0a711055703c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643322206e616d653d22672d65732d77726974652d746f2d7468652d6c6f672d70616e65223e672e657328293a20777269746520746f20746865206c6f672070616e653c2f613e3c2f68313e0a7111652e"># The g.es method prints its arguments to the Log tab of the log pane:
c.frame.log.clearTab('Log')
g.es("Hello world")

# g.es converts non-string arguments using repr:
g.es(c)

# g.es prints multiple arguments separated by commas:
g.es("Hello","world")
</t>
<t tx="ekr.20060902092341.6" rst_http_attribute="5d71002855443c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3722206e616d653d22687474702d6e6f64652d6d61726b65722d37223e710155043c2f613e71025d71032855353c64697620636c6173733d2273656374696f6e222069643d22672d65732d77726974652d746f2d7468652d6c6f672d70616e65223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f55463c64697620636c6173733d2273656374696f6e222069643d226170702d77696e646f776c6973742d7468652d6c6973742d6f662d616c6c2d6f70656e2d6672616d6573223e0a7110558e3c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643422206e616d653d226170702d77696e646f776c6973742d7468652d6c6973742d6f662d616c6c2d6f70656e2d6672616d6573223e6170702e77696e646f774c6973743a20746865206c697374206f6620616c6c206f70656e206672616d65733c2f613e3c2f68313e0a7111652e"># g.app.windowlist is the list of the frames of all open windows.

aList = g.app.windowList # get the list of all open frames.
g.es("windows...")
for f in aList:
    print(f)
    print(f.c)
    print(f.shortFileName())
</t>
<t tx="ekr.20060902092341.7" rst_http_attribute="5d71002855443c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3922206e616d653d22687474702d6e6f64652d6d61726b65722d39223e710155043c2f613e71025d71032855453c64697620636c6173733d2273656374696f6e222069643d226170702d77696e646f776c6973742d7468652d6c6973742d6f662d616c6c2d6f70656e2d6672616d6573223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f55463c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d686561646c696e652d616e642d626f64792d74657874223e0a7110558d3c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643522206e616d653d2267657474696e672d616e642d73657474696e672d686561646c696e652d616e642d626f64792d74657874223e47657474696e6720616e642073657474696e6720686561646c696e6520616e6420626f647920746578743c2f613e3c2f68313e0a7111652e"># For any position p, p.h is the headline and p.b is the body text.
print("head:",p.h)
print("body:",p.b)

p.setBodyString(p.b) # set p's body text.
p.setHeadString(p.h) # set p's headline text.</t>
<t tx="ekr.20060902092341.8" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313122206e616d653d22687474702d6e6f64652d6d61726b65722d3131223e710155043c2f613e71025d71032855453c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d686561646c696e652d616e642d626f64792d74657874223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f552f3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e0a7110555f3c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643622206e616d653d2274726176657273696e672d6f75746c696e6573223e54726176657273696e67206f75746c696e65733c2f613e3c2f68313e0a7111652e">@
The proper way to traverse an outline is with one of Leo's generators.</t>
<t tx="ekr.20060902092341.9"># Scripts and plugins should use p.copy() to 'capture' the value of a position:

p2 = p.copy()   # Correct: p2 will not change when p changes later.
p2 = p          # Wrong.  p2 will change after this assignment.

# For example, this creates a dictionary of positions, indexed by vnode.

d = {}
for p in c.all_positions():
    d[p.v] = p.copy()

print(d.get(c.rootPosition().v))

# **Warning** This dictionary will become invalid when the outline changes!
</t>
<t tx="ekr.20060902092341.10" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313322206e616d653d22687474702d6e6f64652d6d61726b65722d3133223e710155043c2f613e71025d710328552e3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e65656565552b3c64697620636c6173733d2273656374696f6e222069643d22632d616c6c6e6f6465732d69746572223e0a710f55573c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643722206e616d653d22632d616c6c6e6f6465732d69746572223e632e616c6c4e6f6465735f697465723c2f613e3c2f68323e0a7110652e">@nocolor
The c.allNodes_iter iterator returns a list of all positions in the outline.
This script makes a list of all the nodes in an outline:
@color

    nodes = [p for p in c.allNodes_iter()]
    g.es("This outline contains %d nodes" % len(nodes))

@nocolor
Here is one way to count the nodes of an outline:
@color

    count = 0
    for p in c.allNodes_iter():
        count += 1
    g.es("This outline contains %d nodes" % count)

@nocolor
Here is a way to count the *distinct* vnodes of an outline:
@color

    positions = 0 ; tnodes = {}
    for p in c.allNodes_iter():
        positions += 1
        if not tnodes.get(p.v.t):
            tnodes[p.v.t] = p.v.t
    g.es("%8s positions" % positions)
    g.es("%8s vnodes" % len(tnodes.keys()))</t>
<t tx="ekr.20060902092341.11" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313522206e616d653d22687474702d6e6f64652d6d61726b65722d3135223e710155043c2f613e71025d710328552a3c64697620636c6173733d2273656374696f6e222069643d22632d616c6c6e6f6465732d69746572223e710455063c2f6469763e71055d710628552e3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a7112552b3c64697620636c6173733d2273656374696f6e222069643d22702d6368696c6472656e2d69746572223e0a711355573c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643822206e616d653d22702d6368696c6472656e2d69746572223e702e6368696c6472656e5f697465723c2f613e3c2f68323e0a7114652e">@nocolor
The p.children_iter iterator returns a list of all children of position p:
@color

    parent = p.parent()
    g.es("children of %s" % parent.headString(),color="purple")
    for p in parent.children_iter():
        g.es(p.headString())</t>
<t tx="ekr.20060902092341.12" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313722206e616d653d22687474702d6e6f64652d6d61726b65722d3137223e710155043c2f613e71025d710328552a3c64697620636c6173733d2273656374696f6e222069643d22702d6368696c6472656e2d69746572223e710455063c2f6469763e71055d710628552e3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a711255463c64697620636c6173733d2273656374696f6e222069643d22702d706172656e74732d697465722d616e642d702d73656c662d616e642d706172656e74732d69746572223e0a7113558d3c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643922206e616d653d22702d706172656e74732d697465722d616e642d702d73656c662d616e642d706172656e74732d69746572223e702e706172656e74735f6974657220616e6420702e73656c665f616e645f706172656e74735f697465723c2f613e3c2f68323e0a7114652e">@nocolor
The p.parents_iter iterator returns a list of all parents of position p, excluding p:
@color

    current = p.copy()
    g.es("inclusive parents of %s" % current.headString(),color="purple")
    for p in current.self_and_parents_iter():
        g.es(p.headString())

@nocolor
The p.self_and_parents_iter iterator returns a list of all parents of position p, including p:
@color

    current = p.copy()
    g.es("exclusive of %s" % current.headString(),color="purple")
    for p in current.parents_iter():
        g.es(p.headString())</t>
<t tx="ekr.20060902092341.13" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d313922206e616d653d22687474702d6e6f64652d6d61726b65722d3139223e710155043c2f613e71025d71032855453c64697620636c6173733d2273656374696f6e222069643d22702d706172656e74732d697465722d616e642d702d73656c662d616e642d706172656e74732d69746572223e710455063c2f6469763e71055d710628552e3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a711255493c64697620636c6173733d2273656374696f6e222069643d22702d7369626c696e67732d697465722d616e642d702d666f6c6c6f77696e672d7369626c696e67732d69746572223e0a711355943c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313022206e616d653d22702d7369626c696e67732d697465722d616e642d702d666f6c6c6f77696e672d7369626c696e67732d69746572223e702e7369626c696e67735f6974657220616e6420702e666f6c6c6f77696e675f7369626c696e67735f697465723c2f613e3c2f68323e0a7114652e">@nocolor
The p.siblings_iter iterator returns a list of all siblings of position p:
@color

    current = c.currentPosition()
    g.es("all siblings of %s" % current.headString(),color="purple")
    for p in current.self_and_siblings_iter():
        g.es(p.headString())

@nocolor
The p.following_siblings_iter iterator returns a list of all siblings that follow position p:
@color

    current = c.currentPosition()
    g.es("following siblings of %s" % current.headString(),color="purple")
    for p in current.following_siblings_iter():
        g.es(p.headString())</t>
<t tx="ekr.20060902092341.14" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323122206e616d653d22687474702d6e6f64652d6d61726b65722d3231223e710155043c2f613e71025d71032855483c64697620636c6173733d2273656374696f6e222069643d22702d7369626c696e67732d697465722d616e642d702d666f6c6c6f77696e672d7369626c696e67732d69746572223e710455063c2f6469763e71055d710628552e3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a711255463c64697620636c6173733d2273656374696f6e222069643d22702d737562747265652d697465722d616e642d702d73656c662d616e642d737562747265652d69746572223e0a7113558e3c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313122206e616d653d22702d737562747265652d697465722d616e642d702d73656c662d616e642d737562747265652d69746572223e702e737562747265655f6974657220616e6420702e73656c665f616e645f737562747265655f697465723c2f613e3c2f68323e0a7114652e">@nocolor
The p.subtree_iter iterator returns a list of all positions in p's subtree, excluding p:
@color

    parent = p.parent()
    g.es("inclusive subtree of %s" % parent.headString(),color="purple")
    for p in parent.self_and_subtree_iter():
        g.es(p.headString())

@nocolor
The p.self_and_subtree_iter iterator returns a list of all positions in p's subtree, including p:
@color

    parent = p.parent()
    g.es("exclusive subtree of %s" % parent.headString(),color="purple")
    for p in parent.subtree_iter():
        g.es(p.headString())</t>
<t tx="ekr.20060902092341.15" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323322206e616d653d22687474702d6e6f64652d6d61726b65722d3233223e710155043c2f613e71025d71032855453c64697620636c6173733d2273656374696f6e222069643d22702d737562747265652d697465722d616e642d702d73656c662d616e642d737562747265652d69746572223e710455063c2f6469763e71055d710628552e3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a7112553f3c64697620636c6173733d2273656374696f6e222069643d2274657374696e672d776865746865722d612d706f736974696f6e2d69732d76616c6964223e0a711355803c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313222206e616d653d2274657374696e672d776865746865722d612d706f736974696f6e2d69732d76616c6964223e54657374696e672077686574686572206120706f736974696f6e2069732076616c69643c2f613e3c2f68323e0a7114652e">@nocolor
The tests:
@color

    if p:       # Right
    if not p:   # Right

@nocolor
are the **only** correct ways to test whether a position p is valid.
In particular, the following **will not work**:
@color

    if p is None:       # Wrong
    if p is not None:   # Wrong</t>
<t tx="ekr.20060902092341.16" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323522206e616d653d22687474702d6e6f64652d6d61726b65722d3235223e710155043c2f613e71025d710328553e3c64697620636c6173733d2273656374696f6e222069643d2274657374696e672d776865746865722d612d706f736974696f6e2d69732d76616c6964223e710455063c2f6469763e71055d710628552e3c64697620636c6173733d2273656374696f6e222069643d2274726176657273696e672d6f75746c696e6573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a711255073c2f6469763e0a7113552f3c64697620636c6173733d2273656374696f6e222069643d227570646174696e672d7468652d73637265656e223e0a711455603c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313322206e616d653d227570646174696e672d7468652d73637265656e223e5570646174696e67207468652073637265656e3c2f613e3c2f68313e0a7115652e">@nocolor
You can use c.redraw_now to redraw the entire screen immediately:
@color

    c.redraw_now()

@nocolor
However, Leo's code redraws the screen using the following pattern:
@color
    
    c.beginUpdate()
    try:
        &lt;&lt; whatever &gt;&gt;
    finally:
        c.endUpdate()

@nocolor
This suppresses redraws inside &lt;&lt;whatever&gt;&gt; that would otherwise be caused by
c.endUpdate. c.endUpdate takes an optional argument:
@color

    c.endUpdate(flag)

@nocolor
redraws the screen only if flag is True. This is an important pattern. Leo uses
c.beginUpdate and c.endUpdate almost everywhere to redraw the screen, so
provided that &lt;&lt; whatever &gt;&gt; contains no calls to c.redraw_now this pattern
insures that at most one redraw occurs.</t>
<t tx="ekr.20060902092341.17" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323722206e616d653d22687474702d6e6f64652d6d61726b65722d3237223e710155043c2f613e71025d710328552e3c64697620636c6173733d2273656374696f6e222069643d227570646174696e672d7468652d73637265656e223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f553a3c64697620636c6173733d2273656374696f6e222069643d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e0a711055763c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313422206e616d653d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e496e766f6b696e6720636f6d6d616e64732066726f6d20736372697074733c2f613e3c2f68313e0a7111652e">@nocolor
Leo dispatches commands using c.doCommand,
which calls the "command1" and "command2" hook routines for the given label.
c.doCommand catches all exceptions thrown by the command:
@color

    c.doCommand(c.markHeadline,label="markheadline")

@nocolor
You can also call command handlers directly so that hooks will not be called:
@color

    c.markHeadline()

@nocolor
You can invoke minibuffer commands by name.  For example:
@color

    c.executeMinibufferCommand('open-outline')

@nocolor
c.keyHandler.funcReturn contains the value returned from the command.
In many cases, as above, this value is simply 'break'.</t>
<t tx="ekr.20060902092341.18">@nocolor
Any .leo file may contain an @settings tree, so settings may be different for each commander.
Plugins and other scripts can get the value of settings as follows:
@color

    format_headlines = c.config.getBool('rst3_format_headlines')
    g.es('format_headlines',format_headlines)

@nocolor
The c.config class has the following getters.
See the configSettings in leoCommands.py for details:

    getBool
    getColor
    getDirectory
    getFloat
    getInt
    getLanguage
    getRatio
    getShortcut
    getString

You can set any *existing* item in an @settings tree with c.config.set(p,setting,val).
For example:
@color

    for val in (False,True):
        c.config.set(p,'rst3_format_headlines',val)
        format_headlines = c.config.getBool('rst3_format_headlines')
        g.es('format_headlines',format_headlines)

@nocolor
c.config.set does not change the @settings tree; it simply changes the values returned by the getters.</t>
<t tx="ekr.20060902092341.19" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d323922206e616d653d22687474702d6e6f64652d6d61726b65722d3239223e710155043c2f613e71025d71032855393c64697620636c6173733d2273656374696f6e222069643d22696e766f6b696e672d636f6d6d616e64732d66726f6d2d73637269707473223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f553b3c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d707265666572656e636573223e0a711055783c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313522206e616d653d2267657474696e672d616e642d73657474696e672d707265666572656e636573223e47657474696e6720616e642073657474696e6720707265666572656e6365733c2f613e3c2f68313e0a7111652e">@nocolor
Each commander maintains its own preferences.
Your scripts can get the following ivars:
@color

    ivars = (
        'output_doc_flag',
        'page_width',
        'page_width',
        'tab_width',
        'tangle_batch_flag',
        'tangle_directory',
        'target_language',
        'untangle_batch_flag',
        'use_header_flag',
    )
    
    g.es("Prefs ivars...\n",color="purple")
    for ivar in ivars:
        g.es(getattr(c,ivar))

@nocolor
If your script sets c.tab_width your script may call f.setTabWidth to redraw the screen:
@color

    c.tab_width = -4    # Change this and see what happens.
    c.frame.setTabWidth(c.tab_width)</t>
<t tx="ekr.20060902092341.20" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333122206e616d653d22687474702d6e6f64652d6d61726b65722d3331223e710155043c2f613e71025d710328553a3c64697620636c6173733d2273656374696f6e222069643d2267657474696e672d616e642d73657474696e672d707265666572656e636573223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f55503c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e0a711055a23c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313622206e616d653d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e46756e6374696f6e7320666f722066696e64696e6720616e64206368616e67696e6720746578742066726f6d20736372697074733c2f613e3c2f68313e0a7111652e">@nocolor
The file leoFindScript.py contains functions for finding and changing text
from within scripts.  See leoFindScript.py in LeoPy.leo for full details.

The findall function returns a list of tuples (v,pos) describing matches in
c's entire tree:
@color

    import leoFindScript

    pattern="import leoGlobals as g"
    result = leoFindScript.findAll(c,pattern,bodyFlag=1)
    
    g.es("%-3d instances of: '%s'...\n" % (len(result),pattern),color="purple")
    
    for v,pos in result:
        body = v.bodyString()
        g.es('\n%-4d %s' % (pos,v.headString()))
        g.es(g.get_line_after(body,pos))

@nocolor
The reFindall function returns a list of tuples (v,mo,pos), where mo
is a MatchObject. The reFlags argument are flags to re.search:
@color

    import leoFindScript

    pattern="from .* import"
    result = leoFindScript.reFindAll(c,pattern,bodyFlag=1,reFlags=None)

    g.es("%-3d instances of: '%s'...\n" % (len(result),pattern),color="purple")
    for v,mo,pos in result:
        body = v.bodyString()
        g.es('\n%-4d %s' % (pos,v.headString()))
        g.es(g.get_line_after(body,pos))</t>
<t tx="ekr.20060902092341.21" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333722206e616d653d22687474702d6e6f64652d6d61726b65722d3337223e710155043c2f613e71025d71032855263c64697620636c6173733d2273656374696f6e222069643d22672d726566696e64616c6c223e710455063c2f6469763e71055d710628554f3c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d666f722d66696e64696e672d616e642d6368616e67696e672d746578742d66726f6d2d73637269707473223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a711255073c2f6469763e0a711355353c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e0a7114556c3c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964313922206e616d653d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e52756e6e696e67204c656f20696e206261746368206d6f64653c2f613e3c2f68313e0a7115652e">@nocolor
On startup, Leo looks for two arguments of the form:

    --script scriptFile

If found, Leo enters batch mode. In batch mode Leo does not show any windows.
Leo assumes the scriptFile contains a Python script and executes the contents of
that file using Leo's Execute Script command. By default, Leo sends all
output to the console window. Scripts in the scriptFile may disable or enable
this output by calling app.log.disable or app.log.enable

Scripts in the scriptFile may execute any of Leo's commands except the Edit Body
and Edit Headline commands. Those commands require interaction with the user.
For example, the following batch script reads a Leo file and prints all the
headlines in that file:
@color

    path = r"c:\prog\leoCVS\leo\test\test.leo"
   
    g.app.log.disable() # disable reading messages while opening the file
    flag,newFrame = g.openWithFileName(path,None)
    g.app.log.enable() # re-enable the log.
    
    for p in newFrame.c.allNodes_iter():
        g.es(g.toEncodedString(p.headString(),"utf-8"))</t>
<t tx="ekr.20060902092341.22" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333922206e616d653d22687474702d6e6f64652d6d61726b65722d3339223e710155043c2f613e71025d71032855343c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f553e3c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e0a7110557e3c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323022206e616d653d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e46756e6374696f6e7320646566696e656420696e206c656f476c6f62616c732e70793c2f613e3c2f68313e0a7111652e">@nocolor
leoGlobals.py contains many utility functions and constants.
The following script prints all the names defined in leoGlobals.py:
@color

    g.es("Names defined in leoGlobals.py",color="purple")
    names = g.__dict__.keys()
    names.sort()
    for name in names:
        g.es(name)</t>
<t tx="ekr.20060902092341.23" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343122206e616d653d22687474702d6e6f64652d6d61726b65722d3431223e710155043c2f613e71025d710328553d3c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f553b3c64697620636c6173733d2273656374696f6e222069643d227265646972656374696e672d6f75747075742d66726f6d2d73637269707473223e0a711055783c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323122206e616d653d227265646972656374696e672d6f75747075742d66726f6d2d73637269707473223e5265646972656374696e67206f75747075742066726f6d20736372697074733c2f613e3c2f68313e0a7111652e">@nocolor
leoGlobals.py defines 6 convenience methods for redirecting stdout and stderr:
@color

    g.redirectStderr() # Redirect stderr to the current log pane.
    g.redirectStdout() # Redirect stdout to the current log pane.
    g.restoreStderr()  # Restores stderr so it prints to the console window.
    g.restoreStdout()  # Restores stdout so it prints to the console window.
    g.stdErrIsRedirected() # Returns True if the stderr stream is redirected to the log pane.
    g.stdOutIsRedirected() # Returns True if the stdout stream is redirected to the log pane.

@nocolor
Calls need *not* be paired. Redundant calls are ignored and the last call made
controls where output for each stream goes.
**Note**: you must execute Leo in a console window to see non-redirected output from the print statement:
@color

    print "stdout isRedirected:", g.stdOutIsRedirected()
    print "stderr isRedirected:", g.stdErrIsRedirected()

    g.redirectStderr()
    print "stdout isRedirected:", g.stdOutIsRedirected()
    print "stderr isRedirected:", g.stdErrIsRedirected()

    g.redirectStdout()
    print "stdout isRedirected:", g.stdOutIsRedirected()
    print "stderr isRedirected:", g.stdErrIsRedirected()

    g.restoreStderr()
    print "stdout isRedirected:", g.stdOutIsRedirected()
    print "stderr isRedirected:", g.stdErrIsRedirected()

    g.restoreStdout()
    print "stdout isRedirected:", g.stdOutIsRedirected()
    print "stderr isRedirected:", g.stdErrIsRedirected()</t>
<t tx="ekr.20060902092341.24">@nocolor
**New in Leo 4.4a2**: Plugins and scripts can create new tabs in the log panel.
The following creates a tab named test or make it visible if it already exists:
@color
 
    c.frame.log.selectTab('Test')

@nocolor
When first created, a tab contains a text widget.
The c.frame.log class contains the following 'official' ivars:

- c.frame.log.tabName is the name of the active tab.
- c.frame.log.tabFrame is the Tk.Frame containing all the other widgets of the tab.
- c.frame.log.logCtrl is the initial Tk.Text widget.

The following line removes the initial text widget:
@color
    
    c.frame.log.logCtrl.pack_forget()

@nocolor
To make the text widget visible again:
@color

    c.frame.log.logCtrl.pack(side='top',expand=1,fill='both')

@nocolor
Plugins and scripts can pack any other widgets into c.frame.log.tabFrame.
For example, the following replaces the default text widget with a red box:
@color

    import Tkinter as Tk ; log = c.frame.log
    log.selectTab('Test')
    log.logCtrl.pack_forget()
    f = Tk.Frame(log.tabFrame,bg='red',height='1inch',width='2inch')
    f.pack(side='left',expand=0,fill='none')

@nocolor
Notes:

- g.es, g.enl, g.ecnl, g.ecnls write to the log tab specified by the optional
  tabName argument. The default for tabName is 'Log', so existing code works as
  before.

- The put and putnl methods of the tkinterLog class also take an optional
  tabName argument which defaults to 'Log'.</t>
<t tx="ekr.20060902092341.25" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343322206e616d653d22687474702d6e6f64652d6d61726b65722d3433223e710155043c2f613e71025d710328553a3c64697620636c6173733d2273656374696f6e222069643d227265646972656374696e672d6f75747075742d66726f6d2d73637269707473223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555073c2f6469763e0a710f55453c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e0a7110558c3c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323222206e616d653d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e53756d6d617279206f662074686520766e6f646520616e6420706f736974696f6e20636c61737365733c2f613e3c2f68313e0a7111652e">Most scripts will use methods of the position class to access information in an
outline. The following sections summarizes the most useful methods that your
scripts can use. For a complete list, see the leoNodes.py in of LeoPy.leo.</t>
<t tx="ekr.20060902092341.26" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343522206e616d653d22687474702d6e6f64652d6d61726b65722d3435223e710155043c2f613e71025d71032855443c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e710455063c2f6469763e71055d710628553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710755063c2f6469763e71085d71092855063c626f64793e710a55073c2f626f64793e710b5d710c2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710d55073c2f68746d6c3e710e4e6565656555253c64697620636c6173733d2273656374696f6e222069643d226974657261746f7273223e0a710f554c3c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323322206e616d653d226974657261746f7273223e4974657261746f72733c2f613e3c2f68323e0a7110652e">@nocolor
Iterators exist only in the position class:
@color

	c.allNodes_iter            # returns all positions in c's outline.
	p.children_iter            # returns all children of p.
	p.parents_iter             # returns all parents of p.
	p.self_and_parents_iter    # returns p and all parents of p.
	p.siblings_iter            # returns all siblings of p, including p.
	p.following_siblings_iter  # returns all siblings following p.
	p.subtree_iter             # returns all positions in p's subtree, excluding p.
	p.self_and_subtree_iter    # returns all positions in p's subtree, including p.</t>
<t tx="ekr.20060902092341.27" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343722206e616d653d22687474702d6e6f64652d6d61726b65722d3437223e710155043c2f613e71025d71032855243c64697620636c6173733d2273656374696f6e222069643d226974657261746f7273223e710455063c2f6469763e71055d71062855443c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a711255233c64697620636c6173733d2273656374696f6e222069643d2267657474657273223e0a711355483c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323422206e616d653d2267657474657273223e476574746572733c2f613e3c2f68323e0a7114652e">@nocolor
p.c is an 'official' ivar of the position class.  p.c is p's commander.

Here are the most useful getters of the vnode and position classes.
    
Returning strings:
@color

    p.bodyString() # the body string of p.
    p.headString() # the headline string of p.
    
@nocolor
Returning ints:
@color

    p.childIndex()
    p.numberOfChildren()
    p.level()
   
@nocolor 
Returning bools representing property bits:
@color

    p.hasChildren()
    p.isAncestorOf(v2) # True if v2 is a child, grandchild, etc. of p.
    p.isCloned()
    p.isDirty()
    p.isExpanded()
    p.isMarked()
    p.isVisible()
    p.isVisited()</t>
<t tx="ekr.20060902092341.28" rst_http_attribute="5d71002855463c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d343922206e616d653d22687474702d6e6f64652d6d61726b65722d3439223e710155043c2f613e71025d71032855223c64697620636c6173733d2273656374696f6e222069643d2267657474657273223e710455063c2f6469763e71055d71062855443c64697620636c6173733d2273656374696f6e222069643d2273756d6d6172792d6f662d7468652d766e6f64652d616e642d706f736974696f6e2d636c6173736573223e710755063c2f6469763e71085d710928553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710a55063c2f6469763e710b5d710c2855063c626f64793e710d55073c2f626f64793e710e5d710f2855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711055073c2f68746d6c3e71114e656565656555073c2f6469763e0a711255233c64697620636c6173733d2273656374696f6e222069643d2273657474657273223e0a711355483c68323e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323522206e616d653d2273657474657273223e536574746572733c2f613e3c2f68323e0a7114652e">@nocolor
Here are the most useful setters of the Commands and position classes.
The following setters of the position class regardless of whether
p is the presently selected position:
@color

    p.setBodyString(s)  # Sets the body text of p.
    p.setHeadStringOrHeadline(s)  # Sets the headline text of p.

@nocolor
Moving nodes:
@color

    p.moveAfter(v2)           # move p after v2
    p.moveToNthChildOf(v2,n)  # move p to the n'th child of v2
    p.moveToRoot(oldRoot)     # make p the root position.
                              # oldRoot must be the old root position if it exists.
                              
@nocolor
The "visited" bit may be used by commands or scripts for any purpose.
Many commands use this bits for tree traversal, so these bits do not persist:
@color

    c.clearAllVisited() # Clears all visited bits in c's tree.
    p.clearVisited()
    p.setVisited()</t>
<t tx="ekr.20060902092341.29">@nocolor
Creating a script button should be your first thought whenever you want to
automate any task. The scripting plugin, mod_scripting.py, puts two buttons
in the icon menu, a pink Run Script button and a yellow Script Button
button. The Run Script button does the same thing as the Execute Script
command. The Script Button button is the interesting one. It creates a
button, confusingly called a **script button** in the icon area. A script button
executes a script when you push it.

Suppose node N is selected. When you press the Script Button button a new
(pink) script button is created. The name of the new button is N's headline
text. The script associated with the new button is N's body text. Now whenever
you press the new button, N's script is executed on the **presently** selected
node. Script buttons are extraordinarily useful. In effect, each script button
defines an instant command! For example, sometimes my fingers get tired of
saving a file. I simply put Save in a node's headline and c.save() in
the body text. I hit the Script Button button and I get a new button called
Save that will save the outline when I press it.

Here's a more interesting example. The following script searches the present node
and its ancestors looking for an @rst node. When such a node is found the
script calls the `rst3 plugin`_ to format it. I don't have to select the actual
@rst node; I can select any of its children:
@color

    import leoPlugins
    rst3 = leoPlugins.getPluginModule('rst3')
    if rst3: # already loaded.
        controller = rst3.controllers.get(c)
        if controller:
            for p in p.self_and_parents_iter():
                if p.headString().startswith('@rst '):
                    controller.processTree(p)
                    break
    else: # Just load the plugin.
        rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
        if rst3:
            g.es('rst3 loaded')
            rst3.onCreate('tag',{'c':c})
        else:
            # Ask to be removed.
            g.app.scriptDict['removeMe'] = True

@nocolor
**Notes**:

-   The scripting plugin pre-defines the c, g and p symbols
    just as the Execute Script command does.

-   By default a script button executes the **present** body text of the node that original created the script button.
    This is very handy: you can modify a script button's script at any time without having to recreate the script button.

-   You can delete any script button by right-clicking on it.

-   On startup, the scripting plugin scans the entire .leo file and creates a script button
    for every node whose headline starts with @button scriptName.
    **Warning**: this is indeed a security risk of the kind discussed later.
    This feature can be disabled by setting atButtonNodes = True at the start of mod_scripting.py.</t>
<t tx="ekr.20060902092341.30">@test and @suite nodes are a major advance in unit testing. Such nodes
have headlines that start with @test or @suite. The file test.leo
contains many examples of @test and @suite nodes. @test and
@suite nodes are a direct outgrowth of script buttons. The unit test
script button in test.leo scans the selected outline, creating one unit test
for each test node and zero or more unit tests for each @suite node. The
unit test script then runs all the selected unit tests.</t>
<t tx="ekr.20060902095933">@nocolor
@test nodes create a single unit test from the script in its body
**without having to create a subclass of unittest.TestCase**.
For example, here is a complete unit test.  The headline is:
@color

    @test p.t == p.v.t

@nocolor
The body text is:
@color

    # NOTE: p.__getattr__ must be enabled for this test to work.
    root = c.rootPosition()
    for p in root.allNodes_iter():
        assert(p.t == p.v.t)
        
@nocolor
**That's all!** The headline marks the node as containing a unit test.
The body text contains the meat of the test.  No cruft at all!

**Notes**: The unit tests created from @test nodes define setUp and
tearDown methods. These methods ensure that the script being executed is
the presently selected node. The scripts in @test nodes can not override
the setUp and tearDown methods. In practice, this is not a problem
because the scripts in @test nodes are typically very simple. Such
scripts can use try/finally if they need to clean up after themselves.
Scripts in @test nodes often assume that descendant nodes hold test
data. Scripts in @test nodes can generally define and use sections, but
scripts may not use the @others directive if descendant nodes hold
data.
</t>
<t tx="ekr.20060902095933.1">@nocolor
@suite are an easy way to run legacy unit tests. The Unit Test
button assumes that the body text of an @suite node is a script that
creates a test suite and leaves the result in g.app.scriptDict['suite'].
test.leo several examples of @suite nodes.
Here is an @suite node that executes all doctests in Leo's sources.
The headline is:
@color

    @suite run all doctests

The body text is:
@color

    import unittest
    import leoTest
    import sys
    
    # DocTestSuite exists in Python 2.3 and above.
    if g.CheckVersion(sys.version, "2.3"):
        path = g.os_path_join(g.app.loadDir,"..","src")
        modules = leoTest.importAllModulesInPath(path)
        suite = leoTest.createUnitTestsFromDoctests(modules)                     
        if suite:
            g.app.scriptDict['suite'] = suite
    else:
        # Create an empty suite to suppress a warning.
        g.app.scriptDict['suite'] = unittest.TestSuite()
        print "Can't create unit tests from doctests"
        print "doctest.DocTestSuite requires Python 2.3 or above."

@nocolor
The real work of creating the test suites is done by
leoTest.createUnitTestsFromDoctests.

**Important**: if the suite was created successfully, the script must pass the suite
to script in the unit test script button by as follows:
@color

    g.app.scriptDict['suite'] = suite

@nocolor
@button unit test
The script in the Unit Test script button in test.leo is just:
@color

    import leoTest
    leoTest.doTests(all=False)

@nocolor
test.leo defines the leoTest module. The doTests function is the
code that supports @test and @suite nodes. **Important**: you could
customize how @test and @suite nodes work by using your own script
in the @button unit test node.</t>
<t tx="ekr.20060902100250">This is the end of the 'Scripting Leo' slide show.</t>
<t tx="ekr.20060902101656"># Use @ignore to skip slides

@language python</t>
<t tx="ekr.20070315073704"></t>
<t tx="ekr.20070315073704.1">plugins_menu.py
# plugin_manager.py
open_with.py
mod_scripting.py
rst3.py
slideshow.py
UNL.py
nav_buttons.py</t>
<t tx="ekr.20070315073704.2">For MacOS X (darwin) the following are typical defaults:

vim_cmd = /Applications/gvim.app/Contents/MacOS/gvim --servername LEO
vim_exe = /Applications/gvim.app/Contents/MacOS/gvim
</t>
<t tx="ekr.20070315073704.3"></t>
<t tx="ekr.20070315073704.4"></t>
<t tx="ekr.20080129151123"></t>
<t tx="ekr.20080129151228" str_leo_pos="2,1"></t>
<t tx="ekr.20091103090815.1426"># To create a tab named 'Test' or make it visible if it already exists:
log = c.frame.log
log.selectTab('Test')
log.clearTab('Test')

# When first created, a tab contains a Tk.Text widget.
# To write to this widget, add the tabName argument to g.es:
g.es('Test',color='blue',tabName='Test')
</t>
<t tx="ekr.20091103090815.1427">@
The Execute Script command predefines three variables, c, g and p.
    c is the commander (see below) of the outline containing the script.
    g is the leo.core.leoGlobals module, containing global functions.
    p is the position (see below) of the presently selected node in the outline.
@c

for z in (c,g,p):
    print(z)</t>
<t tx="ekr.20091103090815.1428">@
g.app is the **application object** representing the entire Leo application.
The ivars (instance variables) of g.app represent Leo's global variables.
@c

print(g.app)
</t>
<t tx="ekr.20091103090815.1429">@
A commander is a controller (in model/view/controller terminology).
Each open Leo window has its own commander.
Commanders contain data describing the window.

c.rootPosition() is the position (see below) of the outline's root node.
c.currentPosition() is the position of the outline's presently selected node.
@c

print(c.rootPosition())
print(c.currentPosition())</t>
<t tx="ekr.20091103090815.1430">@
A position represents the location of a particular node *in a tree traversal*.
Positions are the primary way to access data in Leo.

For any position p, p.v is p's outline node (vnode)
@c

print(p.v)

@
Iterators are the primary way of traversing the data in Leo outlines.
In effect, iterators return a list of positions.
@c

print('%d positions' % len(list(c.all_positions())))
print('%d unique nodes' % len(list(c.all_unique_nodes())))

</t>
<t tx="ekr.20091103090815.1431">@
Frames contains all the internal data needed to manage a Leo window.
c.frame is commander's frame.
@c

f = c.frame
print(f)

# "Official" components of c.frame:
print (f.c) # The frame's commander
print(f.log) # The log pane.
print(f.tree) # The outline pane.
print(f.body) # The body pane.
</t>
<t tx="ekr.20091103090815.1432">@
A vnode represents node in Leo's outline, including all clones of the node.
By convention, variables named v, v1 or v2 refer to vnodes.

For any position p, p.v is the vnode at that position,
p.h is the headline text and p.b is the body text.
@c

print (len(p.b),p.h)
</t>
<t tx="ekr.20091103090815.1433">@ The following slides list useful methods for scripting Leo.</t>
<t tx="ekr.20091104114053.3903"></t>
<t tx="ekr.20091104114348.12072">This is the rST version of the Tech Report handed out at EuroPython in 2005.

**Important**: Leo's tutorial is now a clearer explanation of the basics.
This tech report should be rewritten.

@nocolor
@tabwidth -4</t>
<t tx="ekr.20091104114348.12073">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

##########################################
The Essentials of Leo
##########################################

.. contents::</t>
<t tx="ekr.20091104114348.12074">Leo organizes all data into nodes containing a **headline**, an expandable page of
**body text** and a (possibly empty) subtree of **descendant nodes**. The **contents** of a
node are its headline and body text. Leo’s main window contains an **outline** pane
at the top left, a **log pane** at the top right, and a **body pane** at the bottom. The
outline pane shows headlines; the body pane shows the body text of the selected
headline. The log pane displays messages from Leo.

Small red arrows mark **cloned nodes** (clones). Clones share the same content and
descendants. All clones of the same node are equivalent, so changing the
contents of one node (call it node N) changes the contents of all clones of N.
Furthermore, inserting, deleting or changing any descendant of node N causes the
corresponding insertion, deletion or change in all other clones of N.</t>
<t tx="ekr.20091104114348.12075">Clones allow you to organize data in multiple ways within the same outline. You
do not have to choose a single ‘correct’ organization: you can organize your
data in as many ways as you like.

You can use **organizer nodes** to create explicit relations (relationships) among
the data in your outline. The headline of the organizer node is the
relationship’s name. Now make clones of nodes from other parts of the outline
that participate in the relation. Drag the newly created clones so they become
children of the organizer node. You may want to create other (non-cloned)
children of the organizer node that contain data found nowhere else in the
outline. Voilà: you have just created the set of all nodes that pertain to the
relationship. The organizer node is the relation; the terms relation,
relationship and organizer node are interchangeable.

Three kinds of relations deserve special mention. A **view** is a relation (an
organizer node) containing all nodes related to a desired view (or slice) of the
data in the outline. Similarly, a **task** is an organizer node containing all nodes
related to a task. Relations are not limited to tasks or views: the notion of
relationship is completely general. Headlines naturally describe the data in
body text. That is, nodes relate **metadata** (descriptions of data) to data.
Separating data from metadata is useful for humans. It is even more valuable for
scripts: scripts can access data and metadata without complex parsing.
</t>
<t tx="ekr.20091104114348.12076">Plugins are Python (.py) files contained in Leo’s plugins folder. Users can
write plugins to change how Leo works and to add new features without changing
Leo’s core code. We’ll discuss plugins in more detail later.
</t>
<t tx="ekr.20091104114348.12077">Leo can generate many external files called **derived files** from an outline. Leo
outlines can organize files throughout your computer’s file system. Nodes whose
headlines start with ‘@’ are special nodes. Several **special nodes** indicate the
root of a tree that generates a derived file::

    @asis filename    Creates a derived file. Ignores all markup in body text.
    @file filename    Creates a derived file. Duplicates outline structure in .leo file.
    @noref filename   Creates a derived file. Ignores all section references.
    @nosent filename  Creates a derived file without sentinels.
    @thin filename    (Recommended) Like @file, but thin derived files contain all outline structure.

Leo recognizes several other special nodes::

    @settings   Defines settings local to the .leo file.
    @url url    Double-clicking the node’s icon opens the url in Leo or in a browser.

The scripting plugin scans for the following nodes when opening an outline::

    @button         Creates a button in the **icon area** at the top of the Leo window.
    @plugin plugin  Enables a plugin if the plugin has not already been enabled.
    @script         Executes a script when opening the outline. This is a security risk: it is disabled by default.

Plugins, @button nodes and @script nodes can create other kinds of special nodes::

    @suite       Creates a suite of unit tests from script in body. Requires scripting plugin.
    @test        Creates a unit text from script in body. Requires scripting plugin.
    @rst         Outputs a tree containing markup for reStructuredText. Requires rst2 plugin.
    @run command Double clicking the node’s icon executes the command.  Requires run_nodes plugin.</t>
<t tx="ekr.20091104114348.12078">Leo’s Execute Script command **preprocesses** the script to be executed by scanning
a node N and its descendents looking for markup. **Markup** is special syntax that
controls this preprocessing. If node N contains no markup, the resulting script
is just N’s body text. Otherwise, the preprocessed script will include text from
descendent nodes as described below. The main kinds of markup are **section
references**, **directives** and **doc parts**.

1.  **Section references** have the form::

        &lt;&lt;section name&gt;&gt;

    The ``&lt;&lt;`` and ``&gt;&gt;`` must appear on the same line. Conversely, any line
    containing ``&lt;&lt;`` and ``&gt;&gt;`` is a section reference, regardless of context. However,
    section references are not recognized in doc parts. Any characters may appear
    between ``&lt;&lt;`` and ``&gt;&gt;``.
    
    Section references are functional pseudo-code: while preprocessing a script, Leo
    replaces section references by the actual text of the section’s definition.
    Sections are defined in **section definition nodes**, whose headlines start with a
    section reference and whose body text defines the section. Each section
    definition node must descend from the node containing the section reference.

2.  **Directives** start with ‘@’ in the leftmost column of body text. Directives
    specify options and control Leo’s operation. The ``@others`` directive is the
    minimal markup needed to organize scripts. ``@others`` tells Leo to insert the
    preprocessed text of all descendant nodes (except section definition nodes) at
    the spot at which the ``@others`` directive occurs. Nodes are inserted in **outline
    order**, the order in which nodes appear in the outline. **Important**: Leo adds the
    whitespace preceding the ``@others`` directive to the indentation of all
    preprocessed text.
    
    Using ``@others`` is more convenient than using section references. Use ``@others`` when
    the order of included text does not matter::
    
        class myClass:
	        @others # Include the methods of the class. Order doesn’t matter.

    Use section references when the order of included text does matter. In the following script, for example,
    &lt;&lt; imports &gt;&gt; ensures that imports come first. The ``@others`` directive then includes the body text of all other
    descendant nodes::
    
        @language python
        &lt;&lt; imports&gt;&gt;
        @others # Define classes &amp; functions in child nodes.
        main()

    Here is a list of all of Leo’s standard directives::
    
        @whitespace (or @doc)   Starts a doc part &amp; ends code part.
        @all                    Like @others, but includes all descendent nodes.
        @c, @code               Starts a code part and ends a doc part.
        @color                  Enables syntax coloring.
        @delims                 Temporarily changes comment delims.
        @nocolor, @killcolor    Disables syntax coloring.
        @comment                Sets comment delimiters in external (derived) files.
        @language languagename  Sets language for syntax coloring and comments.
        @lineending lineending  Sets ending of lines in derived files.
        @others                 Inserts body text of all descendents except definition nodes. 
        @pagewidth n            Sets page width for justifying comments in doc parts.
        @path path              Sets prefix to use in relative file names in @file nodes, etc.
        @root filename          Marks the root of a tree that creates an external file.
        @raw, @end_raw          Inhibits sections references in a range of text. (@file only.)
        @tabwidth n             Sets width of tabs (negative widths convert tabs to spaces.)
        @wrap, @nowrap          Controls wrapping of text in body pane.
    
3.  Doc parts start with the ‘@’ directive and continue until the end of the body text or until the ‘@c’ directive.
    Body text not in a doc part is in a code part. Here is an example of a doc part::

        @ This is a doc part. Doc parts may span many lines. Leo converts doc parts to comments.
        Leo reformats the doc part by justifying lines so they are no longer than the page width.
        @c

    Leo reformats doc parts by justifying the text into comment lines.
    The ``@pagewidth`` directive controls the length of these comment lines.
    The ``@language`` and ``@comment`` directives specify the comment delimiters used in doc parts.</t>
<t tx="ekr.20091104114348.12079">The ``Execute Script`` command preprocesses the selected text of the presently
selected outline node, or the entire text of the node if there is no selected
text. See the section called ``Markup for Scripts`` for a discussion of how Leo
preprocesses scripts. That section also discusses how Leo organizes scripts
using outlines. Conversely, scripts can use outlines to organize their data. To
write such scripts you must understand at least the basics of Leo’s modules and
classes...
</t>
<t tx="ekr.20091104114348.12080">Leo’s source code is organized as a collection of modules. The following
paragraphs describe five of the most important modules. See ``LeoPy.leo`` (Leo’s
full source code) for more details: scripts have full access to all of Leo’s
classes and data.

1.  The **leoGlobals** module contains utility functions.
    By convention, in Leo’s code ``g`` is always the ``leoGlobals`` module.

2.  The **leoApp** module defines a class representing the entire Leo application.
    **g.app** is the singleton object of this class: the application object.
    The instance variables (ivars) of the application object are Leo’s global variables.
 
3.  The leoCommands module defines the Commands class.
    A commander is an instance of this class.
    Commanders contain the operations that can be performed on a particular outline.
    Each open Leo outline has its own commander.
    By convention, in Leo’s code **c** is always a commander.

4.  The leoFrame module defines the base leoFrame class for objects that create and manage
    the visual appearance of Leo’s windows and panes.
    The **leoTkinterFrame** and **leoTkinterTree** modules contain subclasses of the base classes in the leoFrame module.
    A frame (an instance of the leoFrame class, or a subclass)
    contains all the internal data needed to manage a Leo window.
    **c.frame** is the frame associated with commander c.
    If **f** is a frame, **f.c** is the frame’s commander, **f.body** is the frame’s body pane,
    **f.tree** is the frame’s outline pane, and **f.log** is the frame’s log pane.

5.  The leoNodes module defines several classes that implement Leo’s fundamental data structures.
    These classes are complex.
    Happily, scripts can and should ignore these complications by accessing nodes using
    high-level methods of the position class.

A **position** (an instance of the position class) is the state of some traversal of an outline. Equivalently, a position is a particular visual place in an outline. Cloned nodes may appear many times in an outline. Non-cloned nodes may also appear in many places: consider a non-cloned descendant of a cloned node. By convention, in Leo’s source code p is a position.
</t>
<t tx="ekr.20091104114348.12081">When executing scripts Leo predefines the following three symbols:
**c** is the commander of the outline in which the script is defined,
**g** is the leoGlobals module and
**p** is the position of the selected node in c’s outline, i.e., ``c.currentPosition()``.
</t>
<t tx="ekr.20091104114348.12082">Scripts should get and set data using high-level access methods. Here are some important getters::

    g.app                The application object. Its ivars are Leo’s global variables.
    g.app.windowList     The list of all open frames.
    c.currentPosition()  The position of the selected node.
    c.rootPosition()     The position of the first node in the outline.
    p.headString()       The headline of position p.
    p.bodyString()       The body text of position p.
    p.childIndex()       The number of siblings that precede p.
    p.numberOfChildren() The number of p’s children.
    p.level()            The number of p’s ancestors.
    p.hasChildren()      True if p has children.
    p.isAncestorOf(p2)   True if p2 is a child, grandchild, etc. of p.
    p.isCloned()         True if p is a clone.
    p.isDirty()          True if p’s contents have been changed.
    p.isExpanded()       True if p has children and p’s outline is expanded.
    p.isMarked()         True if p’s headline is marked.
    p.isVisible()        True if all of p’s ancestors are expanded.

And here are some important setters::

    p.setBodyStringOrPane(s) Set body text of p to s.
    p.setHeadString(s)       Set headline of p to s.</t>
<t tx="ekr.20091104114348.12083">Scripts can visit some or all of the nodes of a Leo outline using the following iterators::

    c.allNodes_iter             # All positions in the outline, in outline order.
    p.children_iter()           # All children of p.
    p.parents_iter()            # All parents of p.
    p.siblings_iter()           # All siblings of p, including p.
    p.following_siblings_iter() # All siblings following p, not including p.

For example, the following prints all the nodes of an outline, properly indented::

    for p in c.allNodes_iter():
        print ' '*p.level(), p.headString()</t>
<t tx="ekr.20091104114348.12084">Scripts may open other Leo outlines, or execute any of Leo’s commands.  Here are some examples::

    ok,frame = g.openWithFileName(path,c)	# Opens the .leo file found at path.
    c.deleteOutline()   # Deletes the selected node.
    c.insertHeadline()  # Inserts a new node after present position.

For more examples, see ``Chapter 7: Scripting Leo with Python``, in ``Leo’s Users Guide``.</t>
<t tx="ekr.20091104114348.12085">The scripting plugin creates two buttons in the icon area at the top of the Leo
window. The ``Run Script`` button executes the script in the selected node just
like the ``Execute Script`` command. The ``Script Button`` button creates a new
button whose headline is the headline of the presently selected node, call it
node N. Pressing this button executes the script in node N with p predefined as
``c.currentPosition()`` at the time the script is executed. This clever trick
brings the script to the data in the selected outline.
</t>
<t tx="ekr.20091104114348.12086">``test.leo`` contains all of Leo’s unit tests. An ``@button node`` in test.leo
creates a blue ``Unit Test`` button in the icon area. This button is an
excellent example of bringing scripts to data. The ``Unit Test`` button executes
all the unit tests specified by ``@test`` and ``@suite`` nodes in the selected
outline. **Important**: ``@button``, ``@test`` and ``@suite`` nodes require the
scripting plugin to be enabled.

``@test`` nodes greatly simplify unit testing. The ``Unit Test`` button creates
a unit test from the body text of each ``@test`` node. In effect, the ``Unit
Test`` button automatically creates an instance of ``unittest.TestCase`` whose
run method is the body text of the @test node. There is no need to create
``TestCase`` objects explicitly!

``@suite`` nodes support legacy unit tests. When the ``Unit Test`` script button
finds an ``@suite node`` it executes the script in its body text. This script
should create a suite of unit tests and set::

    g.app.scriptDict['suite'] = suite

where suite is the created suite. The ``Unit Test`` button then runs that
created suite of unit tests.</t>
<t tx="ekr.20091104114348.12087">Plugins are Python (.py) files in Leo’s plugin subdirectory. It is easy to
create new plugins: Leo’s users have contributed dozens of plugins that extend
Leo’s capabilities in new ways. Leo imports all enabled plugins during startup.
The file pluginsManager.txt lists all enabled plugins. You can use the plugin
manager plugin to control plugins without updating ``pluginsManager.txt`` by hand.

Plugins can override any class, method or function in Leo’s core, the files in
Leo’s src subdirectory (the files derived from LeoPy.leo). Besides altering
Leo’s core, plugins can register functions called hooks that Leo calls at
various times during Leo’s execution. Events that trigger hooks include key
pressed events, screen drawing events, node selection events and many others.
When importing a plugin, Leo will call the top-level init() function if it
exists. This function should register the plugin’s hooks by calling
leoPlugins.registerHandler.

For full details about hooks and events see ``Chapter 8: Customizing Leo``, in
``Leo’s Users Guide``. The file ``leoPlugins.leo`` contains all plugins that are
presently distributed with Leo; studying these plugins is a good way of learning
to write your own plugins.</t>
<t tx="ekr.20091104114348.12088">- Leo’s home page:  google edreamleo or http://webpages.charter.net/edreamleo/front.html

- Edward K. Ream:  edreamleo@charter.net, 166 N. Prospect Ave., Madison WI 53726, (608) 231-0766</t>
<t tx="ekr.20091104114348.12089"></t>
<t tx="ekr.20091104114348.12090">Leo's mission

    To be the ultimate power tool for managing complex data
    like computer programs, books and databases.</t>
<t tx="ekr.20091104114348.12092">Leo started life as a way to understand complex computer programs.

Later, it became a data management environment that blends the best
features of relational, hierarchical and object oriented databases.
</t>
<t tx="ekr.20091104114348.12093">Newbies can use Leo outlines like a filing cabinet to organize text,
pictures and other data.

But Leo is designed for power users.

Some of the world's best programmers use Leo. Leo has a large community of
sophisticated users who continue to improve Leo.</t>
<t tx="ekr.20091104114348.12094">Leo gives you three complementary power tools:

1. Leo's outlines are graphs, not simple hierarchies.

2. Python scripting is available everywhere.

3. Outline structure matters everywhere.</t>
<t tx="ekr.20091104114348.12095">Leo's features create a unique environment for programming and for
managing data.

They are easy to use, yet Leo's community of users has been exploring their
implications for over 10 years.</t>
<t tx="ekr.20091104114348.12099">Leo outlines are Directed Acyclic Graphs (DAG's), not simple hierarchies

You can organize Leo outlines in as many was as you like. You don't have to
choose a single "right" way to view your data. You are *not* limited to a
hierarchical or relational view of data. You can create a new view of your data
at any time.

Views are normal parts of a Leo outline, not something tacked onto the outline.</t>
<t tx="ekr.20091104114348.12100">You can customize any aspect of Leo's operation with Python scripts, script
buttons or plugins. Many of Leo's core features started out this way.</t>
<t tx="ekr.20091104114348.12101">Leo uses outline structure in non-trivial ways when writing external files or
creating scripts.

Outlines structure becomes an integral part of external files and scripts.

Programs are no longer merely classes and data, they also have inherent outline
structure.</t>
<t tx="ekr.20091104114348.12102"></t>
<t tx="ekr.20091104114348.12103"></t>
<t tx="ekr.20091104114348.12104">


</t>
<t tx="ekr.20091104114348.12105">Leo scripts can easily create **script buttons** that appear in
Leo's window.  When you press one of those buttons Leo executes the
script on the presently selected node.  The catch-phrase for this is
"bringing scripts to data", and it has unlimited uses.

</t>
<t tx="ekr.20091104114348.12107">Leo scripts have full access to all nodes in a Leo outline.

Leo has a DOM (Document Object Model).

Leo scripts also have access to all of Leo's source code.</t>
<t tx="ekr.20091104114348.12109"></t>
<t tx="ekr.20091104114348.12110">Parts of Leo outlines can correspond to external files on your file system.

Saving a Leo outline updates the corresponding external files.

Conversely, changing an external file will update the Leo outline the next time
you load the outline.

Thus, a single Leo outline can naturally represent a complex projects comprising
many files.</t>
<t tx="ekr.20091104114348.12111">Most of Leo's commands can work on all of the outline, or selected parts.</t>
<t tx="ekr.20091104114348.12112">Leo's file command can search all of the outline or just selected parts.

Leo's find command can work like a normal find, or like grep.</t>
<t tx="ekr.20091104114348.12113">Leo's run-unit-test command command executes Python code in the body of an @test
node (a node with @test in the headline) as a unit test, **without** having to
set up the typical unit testing classes.

Writing the run-unit-test command was straightforward: the command has easy
access to body text without having to do any difficult parsing.

You can run a single unit test by selecting a single node; you can run a suite
of unit tests by selecting a larger part of the outline. This makes running
exactly the unit tests you want a snap. The kind of usage pattern happens
everywhere.</t>
<t tx="ekr.20091104114348.12115">Headlines naturally describe the body text of a node.

By convention, headlines that start with @x denote a node of type x.

Examples:

@button     creates a script button.
@command:   creates user-defined command.
@rst:       contains reStructuredText.
@test:      creates a unit test.
@url:       opens the url (in the headline) in a browser.

Headlines name the button, command or unit test.

Body text contain the script.

Scripts and plugins can easily create other user-defined types.</t>
<t tx="ekr.20091104114348.12118">@language python

'''Print the entire slideshow in which this node appears.'''

# Note: Leo predefines c, g and p in all Leo scripts.
#       These variables makes Leo's entire DOM available.

# Clear the console.
import os
os.system('cls')

# Print a separator with the name of this .leo file.
print('%s%s%s' % ('-'* 20, c.shortFileName(),'-'*20))

# Find the nearest ancestor @slideshow node.
for z in p.self_and_parents():
    if z.h.startswith('@slideshow'):
        break

# Print all the descendant nodes.
for z in z.self_and_subtree():
    print('%s%s' % (z.level()*' ',z.h))
</t>
<t tx="ekr.20091104114348.12119">@language python

'''Print the entire slideshow in which this node appears.'''

# Note: Leo predefines c, g and p in all Leo scripts.
#       These variables makes Leo's entire DOM available.

# Clear the console.
import os
os.system('cls')

# Print a separator with the name of this .leo file.
print('%s%s%s' % ('-'* 20, c.shortFileName(),'-'*20))

# Find the nearest ancestor @slideshow node.
for z in p.self_and_parents():
    if z.h.startswith('@slideshow'):
        break

# Print all the descendant nodes.
for z in z.self_and_subtree():
    print('%s%s' % (z.level()*' ',z.h))
</t>
<t tx="ekr.20091104114348.12120">@language python

import os

# The @others directive inserts nodes.
@others

os.system('cls')
print('beginning')
myClass().printMiddle()
print('end')</t>
<t tx="ekr.20091104114348.12121">class myClass:
    def printMiddle(self):
        print('middle')
</t>
</tnodes>
</leo_file>
