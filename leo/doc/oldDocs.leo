<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="20" left="20" height="600" width="800"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20090717084250.10556" a="E" str_leo_pos="0"><vh>Other docs</vh>
<v t="ekr.20090717084250.10557"><vh>Old preface</vh></v>
<v t="ekr.20090717084250.10558"><vh>Stories</vh>
<v t="ekr.20090717084250.10559"><vh>Introduction (iLeo, revised)</vh></v>
<v t="ekr.20090717084250.10560" rst_http_attribute="5d71002855443c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d3122206e616d653d22687474702d6e6f64652d6d61726b65722d31223e710155043c2f613e71025d710328553f3c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710455063c2f6469763e71055d71062855063c626f64793e710755073c2f626f64793e71085d71092855433c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e710a55073c2f68746d6c3e710b4e65656555243c64697620636c6173733d2273656374696f6e222069643d226f76657276696577223e0a710c55493c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d222369643122206e616d653d226f76657276696577223e4f766572766965773c2f613e3c2f68313e0a710d652e"><vh>Commonly used classes (scripting intro, revised)</vh></v>
<v t="ekr.20090717084250.10561"><vh>Intro to scripting Leo</vh></v>
<v t="ekr.20090717084250.10562"><vh>@rst-no-head preface</vh></v>
<v t="ekr.20090717084250.10563"><vh>@rst-ignore  @rst-no-head preface (old)</vh></v>
<v t="ekr.20090717084250.10564"><vh>New preface</vh></v>
</v>
<v t="ekr.20090717084250.10565"><vh>JythonShell help</vh>
<v t="ekr.20090717084250.10566"><vh>original</vh></v>
<v t="ekr.20090717084250.10567"><vh>@rst html\jythonShell.html</vh>
<v t="ekr.20090717084250.10568"><vh>@rst-no-head links</vh></v>
<v t="ekr.20090717084250.10569"><vh>Autocompleter Actions</vh></v>
<v t="ekr.20090717084250.10570"><vh>Keystrokes</vh></v>
<v t="ekr.20090717084250.10571"><vh>Alt Slash: Dynamic Abbreviations</vh></v>
<v t="ekr.20090717084250.10572"><vh>Object Introspection</vh></v>
<v t="ekr.20090717084250.10573"><vh>System access</vh></v>
<v t="ekr.20090717084250.10574"><vh>Magic Commands</vh>
<v t="ekr.20090717084250.10575"><vh>%alias anAlias</vh></v>
<v t="ekr.20090717084250.10576"><vh>%autocall</vh></v>
<v t="ekr.20090717084250.10577"><vh>%autoindent</vh></v>
<v t="ekr.20090717084250.10578"><vh>%bg</vh></v>
<v t="ekr.20090717084250.10579"><vh>%cd</vh></v>
<v t="ekr.20090717084250.10580"><vh>%clean</vh></v>
<v t="ekr.20090717084250.10581"><vh>%clear</vh></v>
<v t="ekr.20090717084250.10582"><vh>%cwd</vh></v>
<v t="ekr.20090717084250.10583"><vh>%cwd aReference</vh></v>
<v t="ekr.20090717084250.10584"><vh>%deserialize aReference</vh></v>
<v t="ekr.20090717084250.10585"><vh>%ed</vh></v>
<v t="ekr.20090717084250.10586"><vh>%edit [options] [args]</vh></v>
<v t="ekr.20090717084250.10587"><vh>%env</vh></v>
<v t="ekr.20090717084250.10588"><vh>%hist [-n] [n1] [n2]</vh></v>
<v t="ekr.20090717084250.10589"><vh>%kill n</vh></v>
<v t="ekr.20090717084250.10590"><vh>%ls</vh></v>
<v t="ekr.20090717084250.10591"><vh>%ls aReference</vh></v>
<v t="ekr.20090717084250.10592"><vh>%lsmagic</vh></v>
<v t="ekr.20090717084250.10593"><vh>%macro aMacro</vh></v>
<v t="ekr.20090717084250.10594"><vh>%magic</vh></v>
<v t="ekr.20090717084250.10595"><vh>%p</vh></v>
<v t="ekr.20090717084250.10596"><vh>%pdb</vh></v>
<v t="ekr.20090717084250.10597"><vh>%pdoc anObject</vh></v>
<v t="ekr.20090717084250.10598"><vh>%pfile obj</vh></v>
<v t="ekr.20090717084250.10599"><vh>%pinfo aReference</vh></v>
<v t="ekr.20090717084250.10600"><vh>%prun statement</vh></v>
<v t="ekr.20090717084250.10601"><vh>%ps</vh></v>
<v t="ekr.20090717084250.10602"><vh>%r</vh></v>
<v t="ekr.20090717084250.10603"><vh>%rehash and %rehashx</vh></v>
<v t="ekr.20090717084250.10604"><vh>%reset</vh></v>
<v t="ekr.20090717084250.10605"><vh>%run [-n -i -t [-N n] -d [-b n] -p [profile options]] file [args]</vh></v>
<v t="ekr.20090717084250.10606"><vh>%save filename n1:n2 n3:n4 ... n5 .. n6 ...</vh></v>
<v t="ekr.20090717084250.10607"><vh>%sc [options] varname=command</vh></v>
<v t="ekr.20090717084250.10608"><vh>%see</vh></v>
<v t="ekr.20090717084250.10609"><vh>%send n aReference</vh></v>
<v t="ekr.20090717084250.10610"><vh>%serialize aReference</vh></v>
<v t="ekr.20090717084250.10611"><vh>%swing aReference</vh></v>
<v t="ekr.20090717084250.10612"><vh>%sx aCommand</vh></v>
<v t="ekr.20090717084250.10613"><vh>%threads</vh></v>
<v t="ekr.20090717084250.10614"><vh>%unalias anAlias</vh></v>
<v t="ekr.20090717084250.10615"><vh>%url ref aUrl</vh></v>
<v t="ekr.20090717084250.10616"><vh>%wait n</vh></v>
<v t="ekr.20090717084250.10617"><vh>%who</vh></v>
<v t="ekr.20090717084250.10618"><vh>%who_ls</vh></v>
<v t="ekr.20090717084250.10619"><vh>%whos</vh></v>
<v t="ekr.20090717084250.10620"><vh>%xslt ref1 ref2 ref3</vh></v>
</v>
<v t="ekr.20090717084250.10621"><vh>A Note on JPIDs and the CWD</vh></v>
</v>
</v>
<v t="ekr.20090717084250.10622"><vh>Leo Tech report</vh>
<v t="ekr.20090717084250.10623"><vh>@rst html\techReport.html</vh>
<v t="ekr.20090717084250.10624"><vh>Leo’s window, outlines &amp; clones</vh></v>
<v t="ekr.20090717084250.10625"><vh>Relations: organizer nodes, views, tasks and metadata</vh></v>
<v t="ekr.20090717084250.10626"><vh>Plugins</vh></v>
<v t="ekr.20090717084250.10627"><vh>Derived files and special nodes</vh></v>
<v t="ekr.20090717084250.10628"><vh>Markup for scripts</vh></v>
<v t="ekr.20090717084250.10629"><vh>Scripting Leo</vh></v>
<v t="ekr.20090717084250.10630"><vh>Leo’s modules and classes</vh></v>
<v t="ekr.20090717084250.10631"><vh>Predefined symbols in scripts</vh></v>
<v t="ekr.20090717084250.10632"><vh>Accessing data</vh></v>
<v t="ekr.20090717084250.10633"><vh>Traversing outlines</vh></v>
<v t="ekr.20090717084250.10634"><vh>Executing commands from scripts</vh></v>
<v t="ekr.20090717084250.10635"><vh>Bringing scripts to data</vh></v>
<v t="ekr.20090717084250.10636"><vh>Unit Testing with @test and @suite nodes</vh></v>
<v t="ekr.20090717084250.10637"><vh>Plugins and hooks</vh></v>
<v t="ekr.20090717084250.10638"><vh>Contacts</vh></v>
</v>
</v>
<v t="ekr.20090717084250.10639"><vh>suggestions for tutorial</vh></v>
<v t="ekr.20090717084250.10640"><vh>@rst html\docModeOnlyTest.html</vh>
<v t="ekr.20090717084250.10641"><vh>@rst-no-head links</vh></v>
<v t="ekr.20090717084250.10642"><vh>leoFind.py</vh>
<v t="ekr.20090717084250.10643"><vh>&lt;&lt; Theory of operation of find/change &gt;&gt;</vh></v>
<v t="ekr.20090717084250.10644"><vh>leoFind.__init__</vh>
<v t="ekr.20090717084250.10645"><vh>&lt;&lt; compute self.title &gt;&gt;</vh></v>
<v t="ekr.20090717084250.10646"><vh>&lt;&lt; init the gui-independent ivars &gt;&gt;</vh>
<v t="ekr.20090717084250.10647"><vh>&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20090717084250.10648"><vh>Top Level Buttons</vh>
<v t="ekr.20090717084250.10649"><vh>changeAllButton</vh></v>
<v t="ekr.20090717084250.10650"><vh>changeButton</vh></v>
<v t="ekr.20090717084250.10651"><vh>changeThenFindButton</vh></v>
<v t="ekr.20090717084250.10652"><vh>findAllButton</vh></v>
<v t="ekr.20090717084250.10653"><vh>findButton</vh></v>
<v t="ekr.20090717084250.10654"><vh>setup_button</vh></v>
</v>
<v t="ekr.20090717084250.10655"><vh>Top Level Commands</vh>
<v t="ekr.20090717084250.10656"><vh>changeCommand</vh></v>
<v t="ekr.20090717084250.10657"><vh>changeThenFindCommand</vh></v>
<v t="ekr.20090717084250.10658"><vh>dismiss: defined in subclass class</vh></v>
<v t="ekr.20090717084250.10659"><vh>findNextCommand</vh></v>
<v t="ekr.20090717084250.10660"><vh>findPreviousCommand</vh></v>
<v t="ekr.20090717084250.10661"><vh>handleUserClick</vh></v>
<v t="ekr.20090717084250.10662"><vh>setup_command</vh></v>
</v>
<v t="ekr.20090717084250.10663"><vh>Find/change utils</vh>
<v t="ekr.20090717084250.10664"><vh>find.adjust_ivars</vh></v>
<v t="ekr.20090717084250.10665"><vh>batchChange (sets start of change-all group)</vh>
<v t="ekr.20090717084250.10666"><vh>&lt;&lt; change headline &gt;&gt;</vh></v>
<v t="ekr.20090717084250.10667"><vh>&lt;&lt; change body &gt;&gt;</vh></v>
</v>
<v t="ekr.20090717084250.10668"><vh>change</vh></v>
<v t="ekr.20090717084250.10669"><vh>changeAll (sets end of change-all group)</vh></v>
<v t="ekr.20090717084250.10670"><vh>changeSelection</vh>
<v t="ekr.20090717084250.10671"><vh>makeRegexSubs</vh></v>
</v>
<v t="ekr.20090717084250.10672"><vh>changeThenFind</vh></v>
<v t="ekr.20090717084250.10673"><vh>doChange...Script</vh></v>
<v t="ekr.20090717084250.10674"><vh>doFind...Script</vh></v>
<v t="ekr.20090717084250.10675"><vh>findAll</vh>
<v t="ekr.20090717084250.10676"><vh>&lt;&lt; create the found node and begin the undo group &gt;&gt;</vh></v>
<v t="ekr.20090717084250.10677"><vh>&lt;&lt; create a clone of p under the find node &gt;&gt;</vh></v>
</v>
<v t="ekr.20090717084250.10678"><vh>findNext</vh></v>
<v t="ekr.20090717084250.10679"><vh>findNextMatch</vh></v>
<v t="ekr.20090717084250.10680"><vh>resetWrap</vh></v>
<v t="ekr.20090717084250.10681"><vh>search &amp; helpers</vh>
<v t="ekr.20090717084250.10682"><vh>&lt;&lt; fail if we are passed the wrap point &gt;&gt;</vh></v>
<v t="ekr.20090717084250.10683"><vh>Search helpers...</vh>
<v t="ekr.20090717084250.10684"><vh>regexHelper</vh></v>
<v t="ekr.20090717084250.10685"><vh>backwardsHelper</vh></v>
<v t="ekr.20090717084250.10686"><vh>plainHelper</vh></v>
<v t="ekr.20090717084250.10687"><vh>matchWord</vh></v>
</v>
</v>
<v t="ekr.20090717084250.10688"><vh>selectNextPosition</vh></v>
</v>
<v t="ekr.20090717084250.10689"><vh>Initing &amp; finalizing</vh>
<v t="ekr.20090717084250.10690"><vh>checkArgs</vh></v>
<v t="ekr.20090717084250.10691"><vh>initBatchCommands</vh></v>
<v t="ekr.20090717084250.10692"><vh>initBatchText &amp; initNextText</vh></v>
<v t="ekr.20090717084250.10693"><vh>initInHeadline</vh></v>
<v t="ekr.20090717084250.10694"><vh>initInteractiveCommands</vh></v>
<v t="ekr.20090717084250.10695"><vh>printLine</vh></v>
<v t="ekr.20090717084250.10696"><vh>restore</vh></v>
<v t="ekr.20090717084250.10697"><vh>save</vh></v>
<v t="ekr.20090717084250.10698"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20090717084250.10699"><vh>Must be overridden in subclasses</vh></v>
</v>
</v>
<v t="ekr.20090717084250.10700"><vh>Test of publish_argv_for_missing_stylesheets</vh>
<v t="ekr.20090717084250.10701"><vh>@rst test.html</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20090717084250.10556">@language rest

@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c</t>
<t tx="ekr.20090717084250.10557">Leo is not your ordinary text editor, class browser, project manager or database manager,
though it resembles these programs in some respects.
Understanding what Leo is does take some work:
many people have reported an 'Aha!' experience when they first understand what Leo is all about.

Leo is built on simple foundations:
    
- Leo is an outliner. All Leo data resides in an `outline`_. Outlines can
  contain text, computer programs, web sites, pictures, or any other kind of
  data. Leo can show such information, including pictures and movies, directly
  in the outline.
  
- Using `cloned nodes`_, you can put the same information (outline node) in
  multiple places. You don't have to decide, once and for all, where the 'right'
  place to put data: you can 'file' information in as many places as you like.
  But Leo is more than just the ultimate filing cabinet. Using clones, an
  outline can, in effect, show multiple views of the data *in that outline*.
  Again, you do not have to decide, once and for all, which is the 'right' view.
  You can have as many views as you like. For example, suppose you have an
  outline that contains all of your slides (or links to them.) Using clones, any
  of your slides could appear in as many slideshows as you like.

These features allow you to organize personal information such as web links or
pictures. Other features make Leo a powerful environment for programming and web
development:
    
- Unlike most file and class browsers, Leo has a memory. Leo allows you complete
  freedom to organizer and reorganize your outline as you like. Leo remembers
  the organization and expansion state of your outline when you save it, and
  restores the outline and expansion state when you reload the outline.
    
- Leo is a virtual file system and data manager. Leo can generate files based on
  data contained in outline. Such `derived files`_ can contain anything that the
  outline contains: text, computer programs, pictures, etc.
  
- You can use outlines to organize your programs, data and scripts. Using a
  markup language based on noweb_, you can easily tell Leo how to assemble
  programs and scripts from text in a portion of an outline.
  
- Leo's import commands convert already-existing programs into Leo pre-organized
  outlines, much like class browsers do. Unlike class browsers, you are then
  free to reorganize the outline so that it is easy to understand. This is a
  great way to study other people's programs.
  
- The structure of Leo outlines is directly accessible to Python scripts.
  Scripts can directly access all nodes (headlines and body text) of an outline.
  There is no need to 'parse' data into constituent parts. Furthermore scripts
  can easily insert, delete and move nodes. For example, unit tests can create
  nodes that represent the expected result of a unit test.

- Any Leo script can easily be applied to a selected part of the outline. This
  is an incredibly powerful and flexible feature. For example, it is very easy
  to create 'text editing' scripts that automate tedious, repetitive programming
  tasks.
  
- It is easy to write `plugins`_ to alter any aspect of Leo's operation. Dozens
  of plugins already exist.
  
- Nodes naturally represent both data (body text) and its description or
  meta-data (headline). By convention, many plugins and commands look for
  headlines of the form @x. Examples include @test and @suite for unit tests,
  @url for web links, @slideshow and @slide for groups of slides, @auto for
  automatically imported files, @folder for nodes created automatically from a
  folder on the computer's file system, and many others.
  Two kinds of meta-data deserve special mention. Unit tests can easily define
  their own meta-data, such as 'before' and 'after'. These data describe the
  initial conditions of the unit tests and the expected result.
  The @rst plugin uses various kinds of @rst nodes to organize
  `reStructuredText`_ and to control how that text is organized. For full
  details, see `Chapter 14: Using the Rst3 Plugin`_.
  
- Leo coexists well with other editors such as Emacs and Vim. Leo has
  several plugins that allow you easily to switch between Emacs (or Vim) and
  Leo. Moreover, Leo allows you complete flexibility to use the key bindings you
  like.
  
Several people have asked me, "How can Leo help me with programming?".
Here is a short answer that summarizes the discussion so far:
    
- Leo's outlines allow you to see the organization of complex programs more
  clearly than with any other tool.
  
- Leo's allows you to organize programs and scripts more flexibly than with any
  other tool. In particular, noweb is a perfect match for outlines.
  
- Leo scripts are much more powerful than in other scripting environments
  because Leo scripts have easy access to headlines and data without having to
  parse data. **Outline structure is real data**: scripts can easily access the
  parents and descendants of any node. The practical benefits are almost
  endless.

- You can do things with Leo that are not possible with Emacs or Vim. In fact,
  you can do things with Leo that are not even *conceivable or expressible* with
  Emacs or Vim.

One last word. Leo has a strong and active community of users on `SourceForge`_.
Working with this community has been a constant source of joy and inspiration.
Suggestions and plugins from users continue to drive Leo in excellent new
directions. Who knows what the next plugin will bring? -- Edward K. Ream</t>
<t tx="ekr.20090717084250.10558">@nocolor-node

Who am I? Want the best tools.  Want to know everything about computers.

Who is the typical Leo user?  Me, LeoUser, Ville, Bernhard Mulder.  We have been fascinated with computers our whole lives, we know that computers are still in their infancy, we have ideas for making them better.

Why is Leo fun?  Because I get to express directly what is typically hidden--the deep structure of a program, class or method.  Because this structure is explict, the structure itself is part of what I do.  It's a situation similar to an artist that is given a new color to play with, or even a new medium of expression.

How did I discover Leo?  I created Leo because I had a hard time understanding so-called Literate Programs.  LP was supposed to make programming easier by making it possible to write truly useful documentation.  The thought was that voluminous documentation would clarify the organization of large programs.  LP had other features that were also supposed to help.  Chief among them were so-called sections.  These were like macros, functions or methods in that they could be involked by name.  However, I found that in some ways LP actually made understanding program more difficult.  I couldn't remember the documentation, and mere words did not convey the interrelationships between all the various parts of a program.</t>
<t tx="ekr.20090717084250.10559">@nocolor

New: needs work.

Leo is, among many other things, a super-duper filing cabinet. Not only can Leo
hold lots of data, but Leo allows you to file information in multiple places.
You don't have choose one "correct" way of organizing data; you can "file" the
same datum in multiple places.

These kinds of strengths make Leo ideal for the typical user of IPython who uses
IPython to run scientific experiments. Leo can hold all kinds of lab notes:
scripts, parameters to the scripts, output of experiments, notes, ideas,
whatever. Indeed, Leo offers IPython users an alternative to the command-line
way of executing scripts: Leo's nodes provide a natural way to create long-lived
scripts and their variants.

Similarly, IPython offers many features for Leo users, including clever
enhancements to the Python shell and full integration with tools such as
mathplotlib.

Several years ago the IPython community started work on what they called an
IPython Notebook. I immediately saw that Leo would *be* an excellent IPython
Notebook if Leo and IPython could be made to work together. However, the task of
integrating IPython into Leo seemed daunting: IPython's shell only *appears*
simple: it actually is a sophisticated execution environment capable of running
numerous scripts in separate processes. A little experimention seemed to
indicate that it would be a major project to make IPython work with Leo's event
loop.

This is how matters stood until March 2008. In response to a query on the
IPython newsgroup, Ville Vainio started helping me with the task of embedding
IPython into Leo. The task turned out to be far easier than I had dared hoped. I
think Ville too was pleasantly surprised. I kept raising issues, and Ville kept
saying, "It's not really a problem".

In less than two weeks we had a way for IPython to communicate intimately with
Leo, and vice versa. Leo's event loop runs simulaniously with IPython's event
without either interfering with the other. Once this initial bridge was in
place, Ville improved it in several ways. Leo's ILeo plugin is the result.

Original: still good


ILeo, or leo-ipython bridge, creates a two-way communication channel between Leo
and IPython. The level of integration is much deeper than conventional
integration in IDEs; most notably, you are able to store and manipulate **data**
in Leo nodes, in addition to mere program code - essentially making ILeo a
hierarchical spreadsheet, albeit with non-grid view of the data. The
possibilities of this are endless, and the approach can be applied in wide range
of problem domains with very little actual coding.

IPython users are accustomed to using things like %edit to produce non-trivial
functions/classes (i.e. something that they don't want to enter directly on the
interactive prompt, but creating a proper script/module involves too much
overhead). In ILeo, this task consists just going to the Leo window, creating a
node and writing the code there, and pressing alt+I (push-to-ipython).

Obviously, you can save the Leo document as usual - this is a great advantage of
ILeo over using %edit, you can save your experimental scripts all at one time,
without having to organize them into script/module files (before you really want
to, of course!)
</t>
<t tx="ekr.20090717084250.10560">@nocolor-node

Leo's source code is a collection of classes, along with utility functions in
``leoGlobals.py``. Here are the classes and objects that scripts will commonly use:

**g.app**
    The **application object** representing the entire Leo application.
    The ivars (instance variables) of ``g.app`` represent Leo's global variables.
    
**g.app.gui**
    This is a wrapper class that shields Leo's core code from gui-dependent details.
    As described below, scripts can invoke dialogs using g.app.gui convenience methods.

**commander**
    An instance of the ``Commands`` class in ``leoCommands.py``.
    Commanders represent commands for a *particular* window.
    Each open Leo window has its own commander.
    By convention, any variable named ``c`` is a commander.

**frame**
    An instance of the base ``leoFrame`` class in ``leoFrame.py``.
    Frames contains all the internal data needed to manage a Leo window.
    Given a commander ``c``, ``c.frame`` is commanders frame.
    Given a frame ``f``, ``f.c`` is the frame's commander.

**position**
    An instance of the ``position`` class in ``leoNodes.py``.
    A position object represents the location of a particular node *in a tree traversal*.
    By convention, variables named ``p``, ``p1`` or ``p2`` are positions.
    For any ``position`` ``p``, ``p.v`` is the vnode at that position and
    ``p.v.t`` is the tnode at that position.
    **Positions are the primary way to access data.**
    ``c.currentPosition`` and ``c.rootPosition`` return positions.
    From those starting point, it is possible to access the data in any node.

    **Important**:
    Positions can become *invalid* when the structure of the outline changes.
    As discussed below, plugins and scripts that store positions for use at a later time should make sure the
    position p is still valid by calling c.positionExists(p)

    **Important**:
    For compatibility with old (pre-4.2) scripts, ``c.currentVnode`` and
    ``c.rootVnode`` methods return *positions* not vnodes. Old scripts appear to
    be using vnodes; in fact they are using positions. I call such scripts
    **confused** scripts. Confused scripts work because the ``position`` class
    is designed to make them work. We'll see how this works in detail in `About
    copying positions`_.  This section is **supremely important**.

**vnode**
    An instance of the ``vnode`` class in ``leoNodes.py``.
    vnodes represent one or more outline nodes on the screen.
    Normally, scripts access vnodes via the ``position`` class described below. 
    By convention, variables named ``v``, ``v1`` or ``v2`` refer to vnodes.
    **Important**: scripts normally should use positions, not vnodes.

**tnode**
    An instance of the ``tnode`` class in ``leoNodes.py``.
    tnodes represent the actual data in a vnode, including headline and body text.
    For any vnode ``v``, ``v.t`` is v's tnode.
    Cloned vnodes v1 and v2 share the same tnode.  That is ``v1.t == v2``.
    **Important**: If ``p`` is a ``position``, ``p.v.t`` is the tnode associated with that position.
    Many positions may share the same tnode.
    
**Important**: With the exception of the p.v and v.t ivars, scripts should be
careful to use only the methods of the position, vnode and tnode classes rather
than the internal ivars of these classes. Doing so will ensure that the script
is as simple as possible and that the script will continue to work regardless of
future changes to the internals of these classes.
</t>
<t tx="ekr.20090717084250.10561">@nocolor-node

Leo is fun because (among other things) it is *really* easy to write scripts that manipulate data in Leo's outlines. It's dead easy to find nodes, to apply a
script to some or all of the nodes in a Leo outline to insert and delete nodes, to move nodes, and to change the contents of nodes. This chapter will show you
how to do all this, and more.

Working on nodes is *much* easier than working on external files. There is no need to open the file or read it; all of Leo's nodes are always available.

So the first thing to understand about scripting with Leo is that scripts can act on nodes.

The second thing to understand about scripting with Leo is that scripts can be composed *from* nodes. That is, you can use Leo's outlines structure to organize
scripts themselves. In other words, you can use the same features (@others and sections) to organize your scripts that you use to create external files. In
fact, Leo's execute-script command creates a script the same way Leo's save commands write external files. The only difference is that the created file is written to a string that is then passed to Python's exec function.

After covering these basics, this chapter will discuss two totally cool ways of using these basic features.

The first is, by far, the most clever scripting trick I have ever seen. (I can say that because I didn't invent it :-) The inventor (who goes by the name 'e'),
calls it "bringing scripts to data". Leo's scripting plugin lets you associate a script (in the outline) with a **script button** in Leo's icon button. Pressing
the button applies the script **to the presently selected outline node**. We'll see how this works in detail later. BTW, you can invoke script buttons without
using the mouse using using keyboard shortcuts or minibuffer commands.

The second scripting trick isn't so immediately spectacular, but it too can be used in clever ways. By convention, the headline of a node can tell scripts
the kind (type) of data in a node. For example, @test indicates that a node (and its descendants) contains a unit test, while @graph might indicate that a nodes represents an arbitrary directed graph.

@test is an excellent example of the power lurking behind this simple idea.  Leo's core supports @test nodes. Leo's run-unit-tests command searches the selected outline looking for @test
nodes. For each such node, the run-unit-tests command *creates* a valid unit test (subclass of UnitTest.TestCase) by (in effect) wrapping the body text of
the node in an instance of UnitTest.TestCase. (It doesn't actually work that way, but the idea is the same). So you don't have write::
    
    class myTestClass (UnitTest.TestCase): def run(): assert(pi==3) def
        shortDescription (self): return 'pi'
    
Instead you just create a node::
    
    - @test pi assert(pi=3)
    
This saves a lot of tedious typing.


Stories tell what you or I did, or thought. They are based on action, not adjectives.</t>
<t tx="ekr.20090717084250.10562">@nocolor-node

Why, oh why, would anyone be interested in Leo? After all, Emacs and Vim are 
superb text editors, and Visual Studio and Eclipse are great IDE's. How can Leo possibly compete with such strong competition? What does Leo offer that these other tools don't? 

Leo does have something unique to offer--something missing from Emacs,Vim, Visual Studio and Eclipse. Leo's users often speak of an Aha! moment when they understand what this 'something' is. 
The Aha! arises from considering programs, design and data in a new light. You might call this 'The Leo Way'. In essence, Leo shows that computer programs, designs and data are *not*, after all, mostly about text. Yes, people usually *express* programs, designs and data as text. Yes, people manipulate programs, designs and data *using* text, but *text is not the whole story*. 

In The Leo Way, text is simply a manifestation (a shadow) of something more 
fundamental. That 'something else' might be called 'organization' or 'structure' or 'views' or even 'architecture'. However, let us use the term **node** to represent the fundamental unit of structure in Leo. We'll see why in a moment. 

In architectural terms, nodes are bricks that make up a building. In computer
programming terms, nodes make up methods, classes, files and entire
applications. So the term 'node' does *not* have a fixed meaning--it is simply a
unit of organization. Any node can be built from other nodes, and any node can
be used by any other node. Leo represent nodes directly, as nodes (headlines) in
an outline. An outline node contains a headline and body text. The **outline
pane** shows all headlines; the **body pane** shows the body text of the
presently selected node.
 
**Outline structure is real data**
 
To repeat: the fundamental unit in Leo is *not* text. True, headlines and body *consist* of text, but a node is just not text, it is a true (Python) object. This means several specific things: 
 
1. Because nodes are true objects, Leo commands understand what a node is, and
   where a node fits into the entire outline. I'll say more about outline
   organization soon, but let me give an example. Every node has exactly one
   parent node, (except for top-level nodes that have no parents) and every node
   has zero or more children and zero or more siblings. A node's parent,
   children and siblings are real properties of the node, *completely
   independent* of the node's headline or body text. Furthermore, any of Leo's
   commands (or user-written scripts or plugins, the big sisters of user
   scripts.) can *easily* access the all aspects of an outline *without* having
   to parse any text whatsoever. Commands, scripts and plugins can easily do the
   following: get the root of the outline, the presently selected node in the
   outline, the parent, siblings, children or descendants of any node in the
   outline, etc., etc. Commands, scripts and plugins can easily insert, delete
   or move nodes, and can alter the headline or body text in any node. All this
   *without* parsing text.
 
2. Having nodes be true objects means that commands scripts and plugins can
   treat the headline text as *something truly different from* body text. The
   natural interpretation of headline text is as a description of the body text.
   This is important! Headlines often control Leo's commands. For example,
   headlines that start with @thin, @file, @asis, @auto, etc. serve to guide and
   control Leo's read and write commands. Headlines that start with @test,
   @suite and @mark-for-unit-tests guide Leo's unit testing commands. Moreover,
   it is easy to create new conventions for headlines that control user-written
   scripts or plugins. For example, plugins define specific meanings for
   headlines that start with @url, @rst, @bookmark, @slideshow, etc., etc. So
   the separation of headline and body text, **as true components of a node
   object**, is a very big deal.
 
3. One application of these ideas deserves special mention. Leo's scripting
   plugin provides support for @button nodes. The headline is @button
   &lt;command-name&gt;. The body text contains a script. When Leo opens a Leo
   outline, each @button node creates a command and an icon. Clicking the icon
   (or executing the command) applies the script in the @button node **to the
   presently selected outline**. That is, the script is executed in a context in
   which it is easy to get access to all aspects of the outline in which the
   script is embedded. This is a major advance in scripting. It allows you to
   'bring scripts to data', i.e., any part of an outline. In particular, it is
   very easy to create **editing scripts** that automate what would otherwise be
   boring and repetitive editing tasks.
 
**Leo outlines aren't your average outline**
 
Earlier I said that *any* node can be built from other nodes, and *any* node can be used by any other node. It takes a very special kind of outline for this to be possible. In a typical outline, such as Emacs outline mode, for example, nodes appear exactly once in the outline. This makes it impossible to 'reuse' nodes in multiple places. Leo removes that limitation: any outline node can be **cloned**, and clones can appear in as many places in an outline as you like. 
 
Cloned nodes are distinct: they must be distinct so they can be moved throughout the outline, but **cloned nodes share all their information**. That is, changing the headline or body text in a node instantly changes the headline and body text in all the other nodes cloned to it. Furthermore, similar remarks apply to the children and descendants of any node--changing any child (or other descendant) of a node, say node A, instantly makes corresponding changes to all nodes cloned to node A. 
 
Earlier I said that you can think of nodes as representing 'organization' or 
'structure' or 'views' or even 'architecture'. Clones are the crucial feature that allows this point of view. For example, we can build up multiple 'views' of data in an outline using clones as follows: 
 
- Create a 'view node' that will represent a *user-specified* view. 
 
- Clone all nodes that are to be part of the view, and move them so that each clone is a child of the view node. 
 
That's about all there is to it. The view node, and its children *is* a new view of the outline. This notion of 'view' is so important that Leo supports it directly. Leo's **chapters** are simply views created as I have just described. When you select one chapter, you only see the nodes of that chapter in Leo's outline pane. 
 
**Conclusions &amp; encouragements**
 
So Leo offers a new way to understand, organize and manipulate *any* kind of
complex data, including computer programs, *designs* of computer programs, web
sites, personal data, whatever. The Aha that I invite you to experience is this:
Outlines are more than mere eye candy. Having organization be real data creates
an entirely new dimension, literally and figuratively, in computer programming,
computer design and data organization, including web-site design, database
design, etc. Leo's commands use headline and body text in many creative ways. So
can you and your scripts. It's easy, it's fun, and it's revolutionary.

That's about it, except for some words of caution and advice: 
 
1. Leo has been under active development for over 10 years. The new world
   created by nodes is rich and varied. You won't learn it all in a day or so.
   Please be patient. Start by learning Leo's basic features as explained in the
   tutorial. You can learn more advanced features later.
 
2. Those of you who are comfortable with Emacs should feel pretty much at home
   with Leo. Leo has shamelessly stolen the best features of Emacs, including
   the minibuffer and many Emacs-like commands.
 
3. For those of you who are *not* comfortable with Emacs, please understand that
   you do *not* need to understand all of Leo's commands in order to use Leo.
   Start by ignoring the minibuffer. Later, the minibuffer can become your
   friend, but you can get the Aha! without it.
 
Edward K. Ream
July, 2007</t>
<t tx="ekr.20090717084250.10563">Leo is not your ordinary text editor, class browser, project manager or database manager,
though it resembles these programs in some respects.
Understanding what Leo is does take some work:
many people have reported an 'Aha!' experience when they first understand what Leo is all about.

Leo is built on simple foundations:
    
- Leo is an outliner. All Leo data resides in an `outline`_. Outlines can
  contain text, computer programs, web sites, pictures, or any other kind of
  data. Leo can show such information, including pictures and movies, directly
  in the outline.
  
- Using `cloned nodes`_, you can put the same information (outline node) in
  multiple places. You don't have to decide, once and for all, where the 'right'
  place to put data: you can 'file' information in as many places as you like.
  But Leo is more than just the ultimate filing cabinet. Using clones, an
  outline can, in effect, show multiple views of the data *in that outline*.
  Again, you do not have to decide, once and for all, which is the 'right' view.
  You can have as many views as you like. For example, suppose you have an
  outline that contains all of your slides (or links to them.) Using clones, any
  of your slides could appear in as many slideshows as you like.

These features allow you to organize personal information such as web links or
pictures. Other features make Leo a powerful environment for programming and web
development:
    
- Unlike most file and class browsers, Leo has a memory. Leo allows you complete
  freedom to organizer and reorganize your outline as you like. Leo remembers
  the organization and expansion state of your outline when you save it, and
  restores the outline and expansion state when you reload the outline.
    
- Leo is a virtual file system and data manager. Leo can generate files based on
  data contained in outline. Such `derived files`_ can contain anything that the
  outline contains: text, computer programs, pictures, etc.
  
- You can use outlines to organize your programs, data and scripts. Using a
  markup language based on noweb_, you can easily tell Leo how to assemble
  programs and scripts from text in a portion of an outline.
  
- Leo's import commands convert already-existing programs into Leo pre-organized
  outlines, much like class browsers do. Unlike class browsers, you are then
  free to reorganize the outline so that it is easy to understand. This is a
  great way to study other people's programs.
  
- The structure of Leo outlines is directly accessible to Python scripts.
  Scripts can directly access all nodes (headlines and body text) of an outline.
  There is no need to 'parse' data into constituent parts. Furthermore scripts
  can easily insert, delete and move nodes. For example, unit tests can create
  nodes that represent the expected result of a unit test.

- Any Leo script can easily be applied to a selected part of the outline. This
  is an incredibly powerful and flexible feature. For example, it is very easy
  to create 'text editing' scripts that automate tedious, repetitive programming
  tasks.
  
- It is easy to write `plugins`_ to alter any aspect of Leo's operation. Dozens
  of plugins already exist.
  
- Nodes naturally represent both data (body text) and its description or
  meta-data (headline). By convention, many plugins and commands look for
  headlines of the form @x. Examples include @test and @suite for unit tests,
  @url for web links, @slideshow and @slide for groups of slides, @auto for
  automatically imported files, @folder for nodes created automatically from a
  folder on the computer's file system, and many others.
  Two kinds of meta-data deserve special mention. Unit tests can easily define
  their own meta-data, such as 'before' and 'after'. These data describe the
  initial conditions of the unit tests and the expected result.
  The @rst plugin uses various kinds of @rst nodes to organize
  `reStructuredText`_ and to control how that text is organized. For full
  details, see `Chapter 14: Using the Rst3 Plugin`_.
  
- Leo coexists well with other editors such as Emacs and Vim. Leo has
  several plugins that allow you easily to switch between Emacs (or Vim) and
  Leo. Moreover, Leo allows you complete flexibility to use the key bindings you
  like.
  
Several people have asked me, "How can Leo help me with programming?".
Here is a short answer that summarizes the discussion so far:
    
- Leo's outlines allow you to see the organization of complex programs more
  clearly than with any other tool.
  
- Leo's allows you to organize programs and scripts more flexibly than with any
  other tool. In particular, noweb is a perfect match for outlines.
  
- Leo scripts are much more powerful than in other scripting environments
  because Leo scripts have easy access to headlines and data without having to
  parse data. **Outline structure is real data**: scripts can easily access the
  parents and descendants of any node. The practical benefits are almost
  endless.

- You can do things with Leo that are not possible with Emacs or Vim. In fact,
  you can do things with Leo that are not even *conceivable or expressible* with
  Emacs or Vim.

One last word. Leo has a strong and active community of users on `SourceForge`_.
Working with this community has been a constant source of joy and inspiration.
Suggestions and plugins from users continue to drive Leo in excellent new
directions. Who knows what the next plugin will bring? -- Edward K. Ream</t>
<t tx="ekr.20090717084250.10564">@nocolor-node

Leo was born in an attempt to understand a relatively obscure programming technique called Literate Programming.

Using Leo is fun.  Fun because it gives control, and because programming occurs in an expanded context.

</t>
<t tx="ekr.20090717084250.10565"></t>
<t tx="ekr.20090717084250.10566">



</t>
<t tx="ekr.20090717084250.10567">.. December 3, 2005

@ @rst-options
code_mode=False
default_path =
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = True
verbose=True
@c

###########################
Using JythonShell
###########################

This chapter describes how to use the Jython Shell created by LeoUser.

.. .. contents::</t>
<t tx="ekr.20090717084250.10568">.. rST links used in this document...</t>
<t tx="ekr.20090717084250.10569">- Up-Down Arrow moves the selection up or down.
- Tab inserts the current selection.

The completion list shows the best prefix entered after the '.'
Any other key withdraws the autocompleter.</t>
<t tx="ekr.20090717084250.10570">Enter
    Processes the current line from the prompt to the end,
    regardless of where the cursor is.

Ctrl Enter
    This keystroke has two meanings:

    1. process the current line with a ':' appended to the end of it,
       regardless of where the cursor is.
       This is the behavior if there is character data on the line.

    2. If the line is pure whitespace, then the line is interpreted as a '' string with a length of 0.</t>
<t tx="ekr.20090717084250.10571">Executing will dynamically expand a prefix to matching
words already entered within the interpreter.  For example:
cactus
cac( keystroke ) will expand cac to cactus.
This will cycle through all matches to cac within the buffer upon repeated execution.

Ctrl A 
    Moves current position to the end of the prompt.

Ctrl E
    Moves current position to the end of the line.

Ctrl K
    Removes all text from current position to end of the line.

Ctrl N
    Start typing, and then use this keystroke to search downwards only through
    the history items that match what you've typed so far. If you use this
    keystroke at a blank prompt, they just behave like normal arrow keys.

Ctrl P
    Start typing, and then use this keystroke to search upwards through only the
    history items that match what you ve typed so far. If you use this keystroke
    at a blank prompt, they just behave like normal arrow keys.

Ctrl R
    Opens a search prompt. Begin typing and the system searches your history for
    lines that contain what you ve typed so far, completing as much as it can.

Ctrl T
    Places triple quotes around the text on the current line.

Ctrl Z
    Suppresses the current output for the duration of the execution statement.
    This is useful in cases where there is a tremendous amount of output
    occurring and the user decides that he no longer wishes to see all of it. For
    gigantic outputs, this can be a shell saver.

Delete
    Removes all text from the prompt to the end of the line.

Down
    Moves the current line down one item in the history.
    By moving, this means the current line is replaced with history item.

Up
    Moves the current line up one item in the history
    By moving, this means the current line is replaced with history item.</t>
<t tx="ekr.20090717084250.10572">Typing a reference name followed by a ? will create a object view which gives
the user a variety of information about the Object in question. Example::

    a = 'meoooowwww'
    a? # Upon Enter, a panel will appear below showing Object information.</t>
<t tx="ekr.20090717084250.10573">Typing ! at the command prompt followed by the system command you wish to
execute will start the command as a process and return a JPID for the process
that can be manipulated by the magic command set.</t>
<t tx="ekr.20090717084250.10574">Entering one of the following commands will cause its
corresponding command to execute:</t>
<t tx="ekr.20090717084250.10575">``%alias`` *anAlias* defines alias name as an alias for cmd.
Afterwards, typing alias name params will execute the system command cmd params (from your
underlying operating system).
Aliases have lower precedence than magic functions and Python normal variables,
so if foo is both a Python variable and an alias, the alias can not be executed until you remove the Python using ``del foo``.</t>
<t tx="ekr.20090717084250.10576">Toggles autocalling off and on.
Autocalling is the ability to do something like::

    dir a

instead of dir( a ).</t>
<t tx="ekr.20090717084250.10577">Toggles autoindenting off and on.</t>
<t tx="ekr.20090717084250.10578">Runs a method/function in a background thread.
For example::

    %bg doit()

This executes doit in a thread.
The status of the operation can be seen by looking at the jobs object::

    jobs.status()  #Prints the status of the jobs.

Alternatively you can access the status like so::

    jobs[jobnumber].result

jobnumber is printed out when the method/function is about to execute.
The result will be the return value of the method/function or it will tell you the job isn't finished yet.</t>
<t tx="ekr.20090717084250.10579">Changes the current working directory of the Jython Shell.
``..`` signifies the parent directory.
Absolute and relative paths are allowed.</t>
<t tx="ekr.20090717084250.10580">Destroys all JPIDs.</t>
<t tx="ekr.20090717084250.10581">Clears the shell of all text and starts over with a fresh prompt.</t>
<t tx="ekr.20090717084250.10582">Shows the current working directory of the Jython Shell.</t>
<t tx="ekr.20090717084250.10583">Sets the reference to a java.io.File instance representing the current directory.</t>
<t tx="ekr.20090717084250.10584">Deserialize an Object stored on disk into the reference.</t>
<t tx="ekr.20090717084250.10585">Same as %edit.

</t>
<t tx="ekr.20090717084250.10586">Brings up the Jython Shell editor and executes the resulting code.

This command allows you to conveniently edit multi-line code right in your JythonShell session.
If called without arguments,
``%edit`` opens up an empty editor with a temporary file and will execute the contents of this file when you close it
(don t forget to save it!).
Options:

-p
    Calls the editor with the same data as the previous time it was used,
    regardless of how long ago (in your current session) it was.

-x
    Suppresses execution of the edited code upon exit.
    This is mainly useful if you are editing programs which need to be called with command line arguments,
    which you can then do using %run.

If args are given, the following possibilities exist:

- The arguments are numbers or pairs of colon-separated numbers, e.g., ``1 4:8 9``.
  These are interpreted as lines of previous input to be loaded into the editor.
  The syntax is the same of the %macro command.

- If the argument doesn't start with a number,
  it is evaluated as a variable and its contents loaded into the editor.
  You can thus edit any string which contains python code (including the result of previous edits).</t>
<t tx="ekr.20090717084250.10587">Prints all environment variables.</t>
<t tx="ekr.20090717084250.10588">Prints all or part of the history.
If given, the ``-n`` argument signifies that line numbers should not be printed out.

%hist [ -n ] 
    Prints the total history or the last 40 items in it.

%hist [ -n ] n1
    Prints the last n1 items in the history.

%hist [ -n ] n1 n2
    Prints the items from index n1 to index n2.</t>
<t tx="ekr.20090717084250.10589">Destroys JPID n.</t>
<t tx="ekr.20090717084250.10590">Shows the contents of the current working directory.</t>
<t tx="ekr.20090717084250.10591">Shows a java array of File instances.  For example::

    %ls a # a now holds a java array of File instances</t>
<t tx="ekr.20090717084250.10592">Returns the current available set of magic commands.</t>
<t tx="ekr.20090717084250.10593">Defines a macro that can be executed by using the name given.  For example::

    %macro macex 9:10 11 12:13 4

creates a macro called macex and puts line 9-10, 11 12-13 and 4 from the history into it
Hence entering macex and typing enter will cause those lines to rexecute.

To see the contents of the macro type: ``print macroname``.
To remove a macro type: ``del macroname``.</t>
<t tx="ekr.20090717084250.10594">%magic
    Prints out the description of the magic commands.

%magic %magiccommandname
    Prints the usage/description of the given magic command.</t>
<t tx="ekr.20090717084250.10595">Same as 'print'.</t>
<t tx="ekr.20090717084250.10596">%pdb
    Starts the Pdb debugger.

%pdb filename

    Runs the file under Pdb in the shell.

%pdb [on|1|off|0 ]
    Toggles automatic startup of Pdb on an exception.  Examples::

        %pdb on  --&gt; now on
        %pdb off --&gt; now off
        %pdb 1 --&gt; now on
        %pdb 0 --&gt; now off</t>
<t tx="ekr.20090717084250.10597">Prints out the doc string of the passed in object if one can be found, otherwise does nothing.

The object may be a module, a method, an object, etc.</t>
<t tx="ekr.20090717084250.10598">Attempts to locate the source file of the passed in object
and displays the contents of the source in the shell.</t>
<t tx="ekr.20090717084250.10599">An alias for the ? object viewer syntax.
If the references is valid, a widget containing info on the reference will appear.</t>
<t tx="ekr.20090717084250.10600">Executes a statement entered on the same line in the profile module.</t>
<t tx="ekr.20090717084250.10601">%ps
    Prints out all JPID's the JythonShell has collected.

%ps aReference
    Puts a java Set of Processes in the reference.  For example:

        %ps a #a now holds a Set of Processes.</t>
<t tx="ekr.20090717084250.10602">Repeats the last input.</t>
<t tx="ekr.20090717084250.10603">%rehash
    Updates the alias table with all entries in $PATH.
    This command does **not** check execute permissions or whether the contents of $PATH are truly files
    (instead of directories or something else).

%rehashx
    Updates the alias table with all executable files in $PATH.
    This command **does** explicitly check that every entry in $PATH is a file, so it is slower than %rehash.</t>
<t tx="ekr.20090717084250.10604">Resets the namespace by removing all names defined by the user.
Input/Output history remain in case you need them.</t>
<t tx="ekr.20090717084250.10605">Runs the named file inside IPython as a program. Options:

-n:
    Suppresses setting ``__name__`` to ``__main__``.
    Instead, sets ``__name__`` to the file's name without
    extension (as Python does under import).

    This allows running scripts and reloading the definitions in them without calling code protected by::

        if __name__ == __main__:

-i:
    Runs the file in JythonShell's namespace instead of an empty one.
    This is useful if you are experimenting with code written in a text editor which
    depends on variables defined interactively.

-t:
    Prints timing information at the end of the run.

-N n:
    If -t is given this option indicates how many times you want the script to run.
    ``n`` must be an integer.
    The final timing report will include total and per run results.</t>
<t tx="ekr.20090717084250.10606">This command uses the same syntax as %macro for line extraction, but instead
of creating a macro it saves the resulting string to file whose name is
given. It ensures the filename ends with a .py extension, and it asks for
confirmation before overwriting existing files.</t>
<t tx="ekr.20090717084250.10607">Runs the given command using ``command.getoutput()``
and updates the user's interactive namespace with a variable called varname
containing the value of the call.
Your command can contain shell wildcards, pipes, etc.
The ``=`` is mandatory, and the variable name must be a valid Python identifier.
Options:

-l:
    List output. Splits the output on newlines into a list before
    assigning it to the given variable. By default the output is stored as a
    single string.

-v:
    Verbose. Prints the contents of the variable.</t>
<t tx="ekr.20090717084250.10608">%see n
    Shows any output JPID n has collected.

%see n aReference
    Places any output JPID n has collected in the reference.</t>
<t tx="ekr.20090717084250.10609">Sends the reference as input to JPID n.</t>
<t tx="ekr.20090717084250.10610">Saves the object referenced by reference as a serialized Object.</t>
<t tx="ekr.20090717084250.10611">Places the reference into the editor if the reference is a JComponent subclass.
Useful for quick gazing of what a Swing component looks like.</t>
<t tx="ekr.20090717084250.10612">Runs the given command using commands.getoutput(), and returns the result formatted as a list (split on).
The output is stored in ipython's regular output cache Out[N] and in the N automatic variables.</t>
<t tx="ekr.20090717084250.10613">Shows the threads running and the state they are in.
Selecting a thread shows the thread's stack.</t>
<t tx="ekr.20090717084250.10614">Removes the given alias.</t>
<t tx="ekr.20090717084250.10615">Loads data from a url into a reference.  For example::

    %url a http://python.org

take the data at ``http://python.org`` and places it in ref.</t>
<t tx="ekr.20090717084250.10616">Suspends the JythonShell until JPID n has finished.</t>
<t tx="ekr.20090717084250.10617">Prints the list of identifiers that have been defined interactively.</t>
<t tx="ekr.20090717084250.10618">Returns a sorted list of all interactive variables.
If arguments are given, only variables of types matching these arguments are returned.
Examples::

    %who_ls
    %who_ls str int  #this prints out variables whose type is str and int</t>
<t tx="ekr.20090717084250.10619">Prints a table of identifiers that have been defined interactively.</t>
<t tx="ekr.20090717084250.10620">Transforms reference ref2 with the stylesheet in ref1 putting the result in ref3.</t>
<t tx="ekr.20090717084250.10621">JPIDs are not PIDs of the OS. They are a system by which the JythonShell can
keep track of Processes created by it, and means by which the user can
manipulate those Processes.

The CWD does not indicate what the process is working in. It is intended to
function with the Magic Commands. This system does not interoperate with
java.io.File or Jython open. To achieve interoperability the user should use the
magic command of the form::

    %cwd reference

This will place a java.io.File in the reference. The File instance is a copy of
the CWD File and will allow the user to open, write, create, close streams and
such in the JythonShell's CWD</t>
<t tx="ekr.20090717084250.10622">This is the rST version of the Tech Report handed out at EuroPython in 2005.

**Important**: Leo's tutorial is now a clearer explanation of the basics.
This tech report should be rewritten.


@tabwidth -4</t>
<t tx="ekr.20090717084250.10623">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = True
verbose=True
@c

##########################################
The Essentials of Leo
##########################################

.. .. contents::</t>
<t tx="ekr.20090717084250.10624">Leo organizes all data into nodes containing a **headline**, an expandable page of
**body text** and a (possibly empty) subtree of **descendant nodes**. The **contents** of a
node are its headline and body text. Leo’s main window contains an **outline** pane
at the top left, a **log pane** at the top right, and a **body pane** at the bottom. The
outline pane shows headlines; the body pane shows the body text of the selected
headline. The log pane displays messages from Leo.

Small red arrows mark **cloned nodes** (clones). Clones share the same content and
descendants. All clones of the same node are equivalent, so changing the
contents of one node (call it node N) changes the contents of all clones of N.
Furthermore, inserting, deleting or changing any descendant of node N causes the
corresponding insertion, deletion or change in all other clones of N.</t>
<t tx="ekr.20090717084250.10625">Clones allow you to organize data in multiple ways within the same outline. You
do not have to choose a single ‘correct’ organization: you can organize your
data in as many ways as you like.

You can use **organizer nodes** to create explicit relations (relationships) among
the data in your outline. The headline of the organizer node is the
relationship’s name. Now make clones of nodes from other parts of the outline
that participate in the relation. Drag the newly created clones so they become
children of the organizer node. You may want to create other (non-cloned)
children of the organizer node that contain data found nowhere else in the
outline. Voilà: you have just created the set of all nodes that pertain to the
relationship. The organizer node is the relation; the terms relation,
relationship and organizer node are interchangeable.

Three kinds of relations deserve special mention. A **view** is a relation (an
organizer node) containing all nodes related to a desired view (or slice) of the
data in the outline. Similarly, a **task** is an organizer node containing all nodes
related to a task. Relations are not limited to tasks or views: the notion of
relationship is completely general. Headlines naturally describe the data in
body text. That is, nodes relate **metadata** (descriptions of data) to data.
Separating data from metadata is useful for humans. It is even more valuable for
scripts: scripts can access data and metadata without complex parsing.
</t>
<t tx="ekr.20090717084250.10626">Plugins are Python (.py) files contained in Leo’s plugins folder. Users can
write plugins to change how Leo works and to add new features without changing
Leo’s core code. We’ll discuss plugins in more detail later.
</t>
<t tx="ekr.20090717084250.10627">Leo can generate many external files called **derived files** from an outline. Leo
outlines can organize files throughout your computer’s file system. Nodes whose
headlines start with ‘@’ are special nodes. Several **special nodes** indicate the
root of a tree that generates a derived file::

    @asis filename    Creates a derived file. Ignores all markup in body text.
    @file filename    Creates a derived file. Duplicates outline structure in .leo file.
    @noref filename   Creates a derived file. Ignores all section references.
    @nosent filename  Creates a derived file without sentinels.
    @thin filename    (Recommended) Like @file, but thin derived files contain all outline structure.

Leo recognizes several other special nodes::

    @settings   Defines settings local to the .leo file.
    @url url    Double-clicking the node’s icon opens the url in Leo or in a browser.

The scripting plugin scans for the following nodes when opening an outline::

    @button         Creates a button in the **icon area** at the top of the Leo window.
    @plugin plugin  Enables a plugin if the plugin has not already been enabled.
    @script         Executes a script when opening the outline. This is a security risk: it is disabled by default.

Plugins, @button nodes and @script nodes can create other kinds of special nodes::

    @suite       Creates a suite of unit tests from script in body. Requires scripting plugin.
    @test        Creates a unit text from script in body. Requires scripting plugin.
    @rst         Outputs a tree containing markup for reStructuredText. Requires rst2 plugin.
    @run command Double clicking the node’s icon executes the command.  Requires run_nodes plugin.</t>
<t tx="ekr.20090717084250.10628">Leo’s Execute Script command **preprocesses** the script to be executed by scanning
a node N and its descendants looking for markup. **Markup** is special syntax that
controls this preprocessing. If node N contains no markup, the resulting script
is just N’s body text. Otherwise, the preprocessed script will include text from
descendant nodes as described below. The main kinds of markup are **section
references**, **directives** and **doc parts**.

1.  **Section references** have the form::

        &lt;&lt;section name&gt;&gt;

    The ``&lt;&lt;`` and ``&gt;&gt;`` must appear on the same line. Conversely, any line
    containing ``&lt;&lt;`` and ``&gt;&gt;`` is a section reference, regardless of context. However,
    section references are not recognized in doc parts. Any characters may appear
    between ``&lt;&lt;`` and ``&gt;&gt;``.
    
    Section references are functional pseudo-code: while preprocessing a script, Leo
    replaces section references by the actual text of the section’s definition.
    Sections are defined in **section definition nodes**, whose headlines start with a
    section reference and whose body text defines the section. Each section
    definition node must descend from the node containing the section reference.

2.  **Directives** start with ‘@’ in the leftmost column of body text. Directives
    specify options and control Leo’s operation. The ``@others`` directive is the
    minimal markup needed to organize scripts. ``@others`` tells Leo to insert the
    preprocessed text of all descendant nodes (except section definition nodes) at
    the spot at which the ``@others`` directive occurs. Nodes are inserted in **outline
    order**, the order in which nodes appear in the outline. **Important**: Leo adds the
    whitespace preceding the ``@others`` directive to the indentation of all
    preprocessed text.
    
    Using ``@others`` is more convenient than using section references. Use ``@others`` when
    the order of included text does not matter::
    
        class myClass:
	        @others # Include the methods of the class. Order doesn’t matter.

    Use section references when the order of included text does matter. In the following script, for example,
    &lt;&lt; imports &gt;&gt; ensures that imports come first. The ``@others`` directive then includes the body text of all other
    descendant nodes::
    
        @language python
        &lt;&lt; imports&gt;&gt;
        @others # Define classes &amp; functions in child nodes.
        main()

    Here is a list of all of Leo’s standard directives::
    
        @whitespace (or @doc)   Starts a doc part &amp; ends code part.
        @all                    Like @others, but includes all descendant nodes.
        @c, @code               Starts a code part and ends a doc part.
        @color                  Enables syntax coloring.
        @delims                 Temporarily changes comment delims.
        @nocolor, @killcolor    Disables syntax coloring.
        @comment                Sets comment delimiters in external (derived) files.
        @language languagename  Sets language for syntax coloring and comments.
        @lineending lineending  Sets ending of lines in derived files.
        @others                 Inserts body text of all descendants except definition nodes. 
        @pagewidth n            Sets page width for justifying comments in doc parts.
        @path path              Sets prefix to use in relative file names in @file nodes, etc.
        @root filename          Marks the root of a tree that creates an external file.
        @raw, @end_raw          Inhibits sections references in a range of text. (@file only.)
        @tabwidth n             Sets width of tabs (negative widths convert tabs to spaces.)
        @wrap, @nowrap          Controls wrapping of text in body pane.
    
3.  Doc parts start with the ‘@’ directive and continue until the end of the body text or until the ‘@c’ directive.
    Body text not in a doc part is in a code part. Here is an example of a doc part::

        @ This is a doc part. Doc parts may span many lines. Leo converts doc parts to comments.
        Leo reformats the doc part by justifying lines so they are no longer than the page width.
        @c

    Leo reformats doc parts by justifying the text into comment lines.
    The ``@pagewidth`` directive controls the length of these comment lines.
    The ``@language`` and ``@comment`` directives specify the comment delimiters used in doc parts.</t>
<t tx="ekr.20090717084250.10629">The ``Execute Script`` command preprocesses the selected text of the presently
selected outline node, or the entire text of the node if there is no selected
text. See the section called ``Markup for Scripts`` for a discussion of how Leo
preprocesses scripts. That section also discusses how Leo organizes scripts
using outlines. Conversely, scripts can use outlines to organize their data. To
write such scripts you must understand at least the basics of Leo’s modules and
classes...
</t>
<t tx="ekr.20090717084250.10630">Leo’s source code is organized as a collection of modules. The following
paragraphs describe five of the most important modules. See ``LeoPy.leo`` (Leo’s
full source code) for more details: scripts have full access to all of Leo’s
classes and data.

1.  The **leoGlobals** module contains utility functions.
    By convention, in Leo’s code ``g`` is always the ``leoGlobals`` module.

2.  The **leoApp** module defines a class representing the entire Leo application.
    **g.app** is the singleton object of this class: the application object.
    The instance variables (ivars) of the application object are Leo’s global variables.
 
3.  The leoCommands module defines the Commands class.
    A commander is an instance of this class.
    Commanders contain the operations that can be performed on a particular outline.
    Each open Leo outline has its own commander.
    By convention, in Leo’s code **c** is always a commander.

4.  The leoFrame module defines the base leoFrame class for objects that create and manage
    the visual appearance of Leo’s windows and panes.
    The **leoTkinterFrame** and **leoTkinterTree** modules contain subclasses of the base classes in the leoFrame module.
    A frame (an instance of the leoFrame class, or a subclass)
    contains all the internal data needed to manage a Leo window.
    **c.frame** is the frame associated with commander c.
    If **f** is a frame, **f.c** is the frame’s commander, **f.body** is the frame’s body pane,
    **f.tree** is the frame’s outline pane, and **f.log** is the frame’s log pane.

5.  The leoNodes module defines several classes that implement Leo’s fundamental data structures.
    These classes are complex.
    Happily, scripts can and should ignore these complications by accessing nodes using
    high-level methods of the position class.

A **position** (an instance of the position class) is the state of some traversal of an outline. Equivalently, a position is a particular visual place in an outline. Cloned nodes may appear many times in an outline. Non-cloned nodes may also appear in many places: consider a non-cloned descendant of a cloned node. By convention, in Leo’s source code p is a position.
</t>
<t tx="ekr.20090717084250.10631">When executing scripts Leo predefines the following three symbols:
**c** is the commander of the outline in which the script is defined,
**g** is the leoGlobals module and
**p** is the position of the selected node in c’s outline, i.e., ``c.p``.
</t>
<t tx="ekr.20090717084250.10632">Scripts should get and set data using high-level access methods. Here are some important getters::

    g.app                The application object. Its ivars are Leo’s global variables.
    g.app.windowList     The list of all open frames.
    c.p                  The position of the selected node.
    c.currentPosition()  A longer name for c.p.
    c.rootPosition()     The position of the first node in the outline.
    p.h                  The headline of position p.
    p.headString()       A longer name for p.h
    p.b                  The body text of position p.
    p.bodyString()       A longer name for p.b
    p.childIndex()       The number of siblings that precede p.
    p.numberOfChildren() The number of p’s children.
    p.level()            The number of p’s ancestors.
    p.hasChildren()      True if p has children.
    p.isAncestorOf(p2)   True if p2 is a child, grandchild, etc. of p.
    p.isCloned()         True if p is a clone.
    p.isDirty()          True if p’s contents have been changed.
    p.isExpanded()       True if p has children and p’s outline is expanded.
    p.isMarked()         True if p’s headline is marked.
    p.isVisible()        True if all of p’s ancestors are expanded.

And here are some important setters::

    p.b = s     Set body text of p to s.
    p.h = s     Set headline of p to s.</t>
<t tx="ekr.20090717084250.10633">Scripts can visit some or all of the nodes of a Leo outline using the following iterators::

    c.allNodes_iter             # All positions in the outline, in outline order.
    p.children_iter()           # All children of p.
    p.parents_iter()            # All parents of p.
    p.siblings_iter()           # All siblings of p, including p.
    p.following_siblings_iter() # All siblings following p, not including p.

For example, the following prints all the nodes of an outline, properly indented::

    for p in c.allNodes_iter():
        print ' '*p.level(), p.h</t>
<t tx="ekr.20090717084250.10634">Scripts may open other Leo outlines, or execute any of Leo’s commands.  Here are some examples::

    ok,frame = g.openWithFileName(path,c)	# Opens the .leo file found at path.
    c.deleteOutline()   # Deletes the selected node.
    c.insertHeadline()  # Inserts a new node after present position.

For more examples, see ``Chapter 7: Scripting Leo with Python``, in ``Leo’s Users Guide``.</t>
<t tx="ekr.20090717084250.10635">The scripting plugin creates two buttons in the icon area at the top of the Leo
window. The ``Run Script`` button executes the script in the selected node just
like the ``Execute Script`` command. The ``Script Button`` button creates a new
button whose headline is the headline of the presently selected node, call it
node N. Pressing this button executes the script in node N with p predefined as
``c.p`` at the time the script is executed. This clever trick
brings the script to the data in the selected outline.
</t>
<t tx="ekr.20090717084250.10636">``test.leo`` contains all of Leo’s unit tests. An ``@button node`` in test.leo
creates a blue ``Unit Test`` button in the icon area. This button is an
excellent example of bringing scripts to data. The ``Unit Test`` button executes
all the unit tests specified by ``@test`` and ``@suite`` nodes in the selected
outline. **Important**: ``@button``, ``@test`` and ``@suite`` nodes require the
scripting plugin to be enabled.

``@test`` nodes greatly simplify unit testing. The ``Unit Test`` button creates
a unit test from the body text of each ``@test`` node. In effect, the ``Unit
Test`` button automatically creates an instance of ``unittest.TestCase`` whose
run method is the body text of the @test node. There is no need to create
``TestCase`` objects explicitly!

``@suite`` nodes support legacy unit tests. When the ``Unit Test`` script button
finds an ``@suite node`` it executes the script in its body text. This script
should create a suite of unit tests and set::

    g.app.scriptDict['suite'] = suite

where suite is the created suite. The ``Unit Test`` button then runs that
created suite of unit tests.</t>
<t tx="ekr.20090717084250.10637">Plugins are Python (.py) files in Leo’s plugin subdirectory. It is easy to
create new plugins: Leo’s users have contributed dozens of plugins that extend
Leo’s capabilities in new ways. Leo imports all enabled plugins during startup.
The file pluginsManager.txt lists all enabled plugins.

Plugins can override any class, method or function in Leo’s core, the files in
Leo’s core subdirectory (the files derived from LeoPy.leo). Besides altering
Leo’s core, plugins can register functions called hooks that Leo calls at
various times during Leo’s execution. Events that trigger hooks include key
pressed events, screen drawing events, node selection events and many others.
When importing a plugin, Leo will call the top-level init() function if it
exists. This function should register the plugin’s hooks by calling
leoPlugins.registerHandler.

For full details about hooks and events see ``Chapter 13: Writing Plugins``, in
``Leo’s Users Guide``. The file ``leoPlugins.leo`` contains all plugins that are
presently distributed with Leo; studying these plugins is a good way of learning
to write your own plugins.</t>
<t tx="ekr.20090717084250.10638">- Leo’s home page:  google edreamleo or http://webpages.charter.net/edreamleo/front.html

- Edward K. Ream:  edreamleo@gmail.com, 166 N. Prospect Ave., Madison WI 53726, (608) 231-0766</t>
<t tx="ekr.20090717084250.10639">@killcolor
https://sourceforge.net/forum/message.php?msg_id=3341105
By: rogererens

Here would be a nice place to insert 2 screen shots that illustrate the points
discussed: one of a very small @thin tree in Leo, and one of the contents of
the file that's derived from that node, as seen in vim or jEdit or notepad.

Also the paragraph on clones might benefit from a screen shot or two, especially
since the tutorial contains a lot of text and ideas to grasp. Pictures in between
give the opportunity to ponder on the meaning of all that for a while while
staring at them...</t>
<t tx="ekr.20090717084250.10640">@ @rst-options
code_mode=False
doc_only_mode= True
generate_rst=True
http_server_support = False
show_organizer_nodes=False
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = True
verbose=True
@c

.. August 28, 2005

# Note the use of @ @rst-markup and @ @rst-options throughout this tree to control doc_mode_only mode.

@ @rst-markup

#####################################
Documentation for leoFind.py
#####################################

@c</t>
<t tx="ekr.20090717084250.10641">.. External links...
.. _`CWEB`:     http://www-cs-faculty.stanford.edu/~knuth/cweb.html
.. _`noweb`:    http://www.eecs.harvard.edu/~nr/noweb/

.. Relative links...
.. _front:      front.html
.. _`Leo's tutorial`:       intro.html
</t>
<t tx="ekr.20090717084250.10642">@language python
@tabwidth -4
@pagewidth 80

import leo.core.leoGlobals as g
import re
import string

&lt;&lt; Theory of operation of find/change &gt;&gt;

class leoFind:

    """The base class for Leo's Find commands."""

    @others</t>
<t tx="ekr.20090717084250.10643">@ The find and change commands are tricky; there are many details that must be handled properly. This documentation describes the leo.py code. Previous versions of Leo used an inferior scheme.  The following principles govern the leoFind class:

1. Find and Change commands initialize themselves using only the state of the
   present Leo window. In particular, the Find class must not save internal
   state information from one invocation to the next. This means that when the
   user changes the nodes, or selects new text in headline or body text, those
   changes will affect the next invocation of any Find or Change command.
   Failure to follow this principle caused all kinds of problems in the Borland
   and Macintosh codes. There is one exception to this rule: we must remember
   where interactive wrapped searches start. This principle simplifies the code
   because most ivars do not persist. However, each command must ensure that the
   Leo window is left in a state suitable for restarting the incremental
   (interactive) Find and Change commands. Details of initialization are
   discussed below.

2. The Find and Change commands must not change the state of the outline or body
   pane during execution. That would cause severe flashing and slow down the
   commands a great deal. In particular, c.selectVnode and c.editPosition
   methods must not be called while looking for matches.

3. When incremental Find or Change commands succeed they must leave the Leo
   window in the proper state to execute another incremental command. We restore
   the Leo window as it was on entry whenever an incremental search fails and
   after any Find All and Change All command.

Initialization involves setting the self.c, self.p, self.in_headline, self.wrapping and self.s_ctrl ivars. Setting self.in_headline is tricky; we must be sure to retain the state of the outline pane until initialization is complete. Initializing the Find All and Change All commands is much easier because such initialization does not depend on the state of the Leo window.

Using Tk.Text widgets for both headlines and body text results in a huge simplification of the code. Indeed, the searching code does not know whether it is searching headline or body text. The search code knows only that self.s_ctrl is a Tk.Text widget that contains the text to be searched or changed and the insert and sel Tk attributes of self.search_text indicate the range of text to be searched. Searching headline and body text simultaneously is complicated. The selectNextPosition() method handles the many details involved by setting self.s_ctrl and its insert and sel attributes.
</t>
<t tx="ekr.20090717084250.10644">@ @rst-options
show_organizer_nodes=True
@c

def __init__ (self,c,title=None):

    self.c = c
    
    # Spell checkers use this class, so we can't always compute a title.
    if title:
        self.title = title
    else:
        &lt;&lt; compute self.title &gt;&gt;

    &lt;&lt; init the gui-independent ivars &gt;&gt;</t>
<t tx="ekr.20090717084250.10645">@ @rst-options
show_organizer_nodes=False
@c

if not c.mFileName:
    s = "untitled"
else:
    path,s = g.os_path_split(c.mFileName)
    
self.title = "Find/Change for %s" %  s</t>
<t tx="ekr.20090717084250.10646">self.wrapPosition = None
self.onlyPosition = None
self.find_text = ""
self.change_text = ""
self.unstick = False

@
New in 4.3:
- These are the names of leoFind ivars. (no more _flag hack).
- There are no corresponding commander ivars to keep in synch (hurray!)
- These ivars are inited (in the subclass by init) when this class is created.
- These ivars are updated (in the subclass by update_ivars) just before doing any find.
@c

&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;

self.intKeys = [
    "batch","ignore_case", "node_only",
    "pattern_match", "search_headline", "search_body",
    "suboutline_only", "mark_changes", "mark_finds", "reverse",
    "script_search","script_change","selection_only",
    "wrap", "whole_word",
]

self.newStringKeys = ["radio-find-type", "radio-search-scope"]

# To do: this should depend on language.
self.word_chars = string.letters + string.digits + '_'

# Ivars containing internal state...
self.c = None # The commander for this search.
self.clone_find_all = False
self.p = None # The position being searched.  Never saved between searches!
self.in_headline = False # True: searching headline text.
self.s_ctrl = None # The search text for this search.
self.wrapping = False # True: wrapping is enabled.
    # This is _not_ the same as self.wrap for batch searches.

@ Initializing a wrapped search is tricky.
The search() method will fail if p==wrapPosition and pos &gt;= wrapPos.
selectNextPosition() will fail if p == wrapPosition.
We set wrapPos on entry, before the first search.
We set wrapPosition in selectNextPosition after the first search fails. 
We also set wrapPosition on exit if the first search succeeds.
@c

self.wrapPosition = None # The start of wrapped searches: persists between calls.
self.onlyPosition = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.
self.errors = 0
self.selStart = self.selEnd = None # For selection-only searches.</t>
<t tx="ekr.20090717084250.10647">@ @rst-options
show_organizer_nodes=False
@c

if 1:
    self.batch = None
    self.clone_find_all = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.script_search = None
    self.script_change = None
    self.selection_only = None
    self.wrap = None
    self.whole_word = None</t>
<t tx="ekr.20090717084250.10648"></t>
<t tx="ekr.20090717084250.10649"># The user has pushed the "Change All" button from the find panel.

def changeAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_change:
        self.doChangeAllScript()
    elif self.selection_only:
        self.change()
    else:
        self.changeAll()</t>
<t tx="ekr.20090717084250.10650"># The user has pushed the "Change" button from the find panel.

def changeButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
    else:
        self.change()</t>
<t tx="ekr.20090717084250.10651"># The user has pushed the "Change Then Find" button from the find panel.

def changeThenFindButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
        if self.script_search:
            self.doFindScript()
        else:
            self.findNext()
    else:
        if self.script_search:
            self.change()
            self.doFindScript()
        else:
            self.changeThenFind()</t>
<t tx="ekr.20090717084250.10652"># The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_search:
        self.doFindAllScript()
    elif self.selection_only:
        self.findNext()
    else:
        self.findAll()</t>
<t tx="ekr.20090717084250.10653"># The user has pushed the "Find" button from the find panel.

def findButton(self):

    self.setup_button()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()</t>
<t tx="ekr.20090717084250.10654"># Initializes a search when a button is pressed in the Find panel.

def setup_button(self):
    
    c = self.c
    self.p = c.p

    c.bringToFront()
    if 0: # We _must_ retain the editing status for incremental searches!
        c.endEditing()

    self.update_ivars()
    self.adjust_ivars()</t>
<t tx="ekr.20090717084250.10655"></t>
<t tx="ekr.20090717084250.10656"># The user has selected the "Replace" menu item.

def changeCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
    else:
        self.change()</t>
<t tx="ekr.20090717084250.10657"># The user has pushed the "Change Then Find" button from the Find menu.

def changeThenFindCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
        self.doFindScript()
    else:
        self.changeThenFind()</t>
<t tx="ekr.20090717084250.10658">def dismiss (self):
    pass</t>
<t tx="ekr.20090717084250.10659"># The user has selected the "Find Next" menu item.

def findNextCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()</t>
<t tx="ekr.20090717084250.10660"># The user has selected the "Find Previous" menu item.

def findPreviousCommand(self,c):

    self.setup_command()

    self.reverse = not self.reverse

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()

    self.reverse = not self.reverse</t>
<t tx="ekr.20090717084250.10661">def handleUserClick (self,p):
    
    """Reset suboutline-only search when the user clicks a headline."""
    
    try:
        if self.c and self.suboutline_only:
            # g.trace(p)
            self.onlyPosition = p.copy()
    except: pass</t>
<t tx="ekr.20090717084250.10662"># Initializes a search when a command is invoked from the menu.

def setup_command(self):
    
    # g.trace('leoFind')

    if 0: # We _must_ retain the editing status for incremental searches!
        self.c.endEditing()

    self.update_ivars()
    self.adjust_ivars()</t>
<t tx="ekr.20090717084250.10663"></t>
<t tx="ekr.20090717084250.10664">def adjust_ivars (self):
    
    '''New in 4.3.
    
    Adjust ivars, particularly the find and change text.
    This is called just before executing a command and
    just after calling update_ivars.
    
    Plugins may replace this code as desired.'''
    
    if 0:
        # The TkFind class now removes tailing newlines.
    
        ft = self.find_text
        if not ft: return
    
        # Remove a trailing newline unless that is all there is.
        if len(ft) &gt; 1 and ft[-1] in ('\n','\r'):
            ft = ft[:-1]
            self.adjust_find_text(ft)
            if 0:
                g.es('before:',repr(self.find_text))
                g.es(' after:',repr(ft))
            self.find_text = ft
    
        return</t>
<t tx="ekr.20090717084250.10665">@ This routine performs a single batch change operation, updating the head or body string of p and leaving the result in s_ctrl.  We update the body if we are changing the body text of c.currentVnode().

s_ctrl contains the found text on entry and contains the changed text on exit.  pos and pos2 indicate the selection.  The selection will never be empty. NB: we can not assume that self.p is visible.
@c

def batchChange (self,pos1,pos2):

    c = self.c ; u = c.undoer
    p = self.p ; st = self.s_ctrl ; gui = g.app.gui
    # Replace the selection with self.change_text
    if gui.compareIndices(st,pos1, "&gt;", pos2):
        pos1,pos2=pos2,pos1
    gui.replaceSelectionRangeWithText(st,pos1,pos2,self.change_text)
    s = gui.getAllText(st)
    # Update the selection.
    insert=g.choose(self.reverse,pos1,pos1+'+'+str(len(self.change_text))+'c')
    gui.setSelectionRange(st,insert,insert)
    gui.setInsertPoint(st,insert)
    # Update the node
    if self.in_headline:
        &lt;&lt; change headline &gt;&gt;
    else:
        &lt;&lt; change body &gt;&gt;</t>
<t tx="ekr.20090717084250.10666">if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]

if s != p.h:
    
    undoData = u.beforeChangeNodeContents(p)

    p.initHeadString(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)
    
    u.afterChangeNodeContents(p,'Change Headline',undoData)</t>
<t tx="ekr.20090717084250.10667">if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]

if s != p.b:
    
    undoData = u.beforeChangeNodeContents(p)

    c.setBodyString(p,s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)
     
    u.afterChangeNodeContents(p,'Change Body',undoData)</t>
<t tx="ekr.20090717084250.10668">def change(self):

    if self.checkArgs():
        self.initInHeadline()
        self.changeSelection()</t>
<t tx="ekr.20090717084250.10669">def changeAll(self):

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.p
    st = self.s_ctrl ; gui = g.app.gui
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        while 1:
            pos1, pos2 = self.findNextMatch()
            if not pos1: break
            count += 1
            self.batchChange(pos1,pos2)
            line = gui.getLineContainingIndex(st,pos1)
            self.printLine(line,allFlag=True)
        p = c.p
        u.afterChangeGroup(p,undoType,reportFlag=True)
        g.es("changed: %d instances" % (count))
    finally:
        c.endUpdate()
        self.restore(saveData)</t>
<t tx="ekr.20090717084250.10670"># Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p ; gui = g.app.gui
    # g.trace(self.in_headline)
    t = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    oldSel = sel = gui.getTextSelection(t)
    if sel and len(sel) == 2:
        start,end = sel
        if start == end:
            sel = None
    if not sel or len(sel) != 2:
        g.es("No text selected")
        return False

    # Replace the selection in _both_ controls.
    start,end = oldSel
    change_text = self.change_text
    
    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text,groups)
    change_text = change_text.replace('\\n','\n').replace('\\t','\t')
                
    gui.replaceSelectionRangeWithText(t,          start,end,change_text)
    gui.replaceSelectionRangeWithText(self.s_ctrl,start,end,change_text)

    # Update the selection for the next match.
    gui.setSelectionRangeWithLength(t,start,len(self.change_text))
    c.widgetWantsFocus(t)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
        if self.mark_changes:
            p.setMarked()
        if self.in_headline:
            c.frame.tree.onHeadChanged(p,'Change')
        else:
            c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.
     
    return True
</t>
<t tx="ekr.20090717084250.10671">def makeRegexSubs(self,s,groups):
    
    '''Carefully substitute group[i-1] for \i strings in s.
    The group strings may contain \i strings: they are *not* substituted.'''
    
    digits = '123456789'
    result = [] ; n = len(s)
    i = j = 0 # s[i:j] is the text between \i markers.
    while j &lt; n:
        k = s.find('\\',j)
        if k == -1 or k + 1 &gt;= n:
            break
        j = k + 1 ; ch = s[j]
        if ch in digits:
            j += 1
            result.append(s[i:k]) # Append up to \i
            i = j
            gn = int(ch)-1
            if gn &lt; len(groups):
                result.append(groups[gn]) # Append groups[i-1]
            else:
                result.append('\\%s' % ch) # Append raw '\i'
    result.append(s[i:])
    return ''.join(result)</t>
<t tx="ekr.20090717084250.10672">def changeThenFind(self):

    if not self.checkArgs():
        return

    self.initInHeadline()
    if self.changeSelection():
        self.findNext(False) # don't reinitialize</t>
<t tx="ekr.20090717084250.10673">def doChangeScript (self):

    g.app.searchDict["type"] = "change"
    self.runChangeScript()

def doChangeAllScript (self):

    """The user has just pressed the Change All button with script-change box checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "changeAll"
    while 1:
        self.runChangeScript()
        if not g.app.searchDict.get("continue"):
            break

def runChangeScript (self):

    try:
        assert(self.script_change)
        exec self.change_text in {} # Use {} to get a pristine environment.
    except:
        g.es("exception executing change script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04</t>
<t tx="ekr.20090717084250.10674">def doFindScript (self):

    g.app.searchDict["type"] = "find"
    self.runFindScript()

def doFindAllScript (self):

    """The user has just pressed the Find All button with script-find radio button checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "findAll"
    while 1:
        self.runFindScript()
        if not g.app.searchDict.get("continue"):
            break

def runFindScript (self):

    try:
        exec self.find_text in {} # Use {} to get a pristine environment.
    except:
        g.es("exception executing find script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
</t>
<t tx="ekr.20090717084250.10675">def findAll(self):

    c = self.c ; t = self.s_ctrl ; u = c.undoer
    gui = g.app.gui ; undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if not pos: break
        count += 1
        line = gui.getLineContainingIndex(t,pos)
        self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            if not clones:
                &lt;&lt; create the found node and begin the undo group &gt;&gt;
            &lt;&lt; create a clone of p under the find node &gt;&gt;
    if self.clone_find_all and clones:
        c.setChanged(True)
        u.afterChangeGroup(c.p,undoType,reportFlag=True)   
    c.redraw_now()
    g.es("found: %d matches" % (count))
    self.restore(data)</t>
<t tx="ekr.20090717084250.10676">u.beforeChangeGroup(c.p,undoType)
undoData = u.beforeInsertNode(c.p)
oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
found.setHeadString('Found: ' + self.find_text)
u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])</t>
<t tx="ekr.20090717084250.10677">clones.append(self.p.v.t)
undoData = u.beforeCloneNode(self.p)
q = self.p.clone(self.p)
q.moveToLastChildOf(found)
u.afterCloneNode(q,undoType,undoData,dirtyVnodeList=[])</t>
<t tx="ekr.20090717084250.10678">def findNext(self,initFlag=True):

    c = self.c
    if not self.checkArgs():
        return

    if initFlag:
        self.initInHeadline()
        data = self.save()
        self.initInteractiveCommands()
    else:
        data = self.save()

    pos, newpos = self.findNextMatch()

    if pos:
        self.showSuccess(pos,newpos)
    else:
        if self.wrapping:
            g.es("end of wrapped search")
        else:
            g.es("not found: " + "'" + self.find_text + "'")
        self.restore(data)</t>
<t tx="ekr.20090717084250.10679"># Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    c = self.c

    if not self.search_headline and not self.search_body:
        return None, None

    if len(self.find_text) == 0:
        return None, None

    p = self.p
    while p:
        pos, newpos = self.search()
        if pos:
            if self.mark_finds:
                p.setMarked()
                c.frame.tree.drawIcon(p) # redraw only the icon.
            return pos, newpos
        elif self.errors:
            return None,None # Abort the search.
        elif self.node_only:
            return None,None # We are only searching one node.
        else:
            p = self.p = self.selectNextPosition()
    return None, None</t>
<t tx="ekr.20090717084250.10680">def resetWrap (self,event=None):

    self.wrapPosition = None
    self.onlyPosition = None</t>
<t tx="ekr.20090717084250.10681">def search (self):

    """Search s_ctrl for self.find_text under the control of the
    whole_word, ignore_case, and pattern_match ivars.
    
    Returns (pos, newpos) or (None,None)."""

    c = self.c ; p = self.p ; w = self.s_ctrl ; gui = g.app.gui
    index = gui.getInsertPoint(w)
    s = gui.getAllText(w)
    index = gui.toPythonIndex(s,w,index)
    stopindex = g.choose(self.reverse,0,len(s))
    pos,newpos = self.searchHelper(s,index,stopindex,self.find_text,
        backwards=self.reverse,nocase=self.ignore_case,
        regexp=self.pattern_match,word=self.whole_word)
    if pos == -1: return None,None
    pos    = gui.toGuiIndex(s,w,pos)
    newpos = gui.toGuiIndex(s,w,newpos)
    &lt;&lt; fail if we are passed the wrap point &gt;&gt;
    gui.setTextSelection(w,pos,newpos,insert=newpos)
    return pos, newpos</t>
<t tx="ekr.20090717084250.10682">if self.wrapping and self.wrapPos and self.wrapPosition and p == self.wrapPosition:

    if self.reverse and gui.compareIndices(w,pos, "&lt;", self.wrapPos):
        # g.trace("wrap done")
        return None, None

    if not self.reverse and gui.compareIndices(w,newpos, "&gt;", self.wrapPos):
        return None, None</t>
<t tx="ekr.20090717084250.10683">def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word,swapij=True):
    
    if swapij and backwards: i,j = j,i
        
    # g.trace(backwards,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        # g.trace('empty',i,j)
        return -1,-1
        
    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)

    return pos,newpos
</t>
<t tx="ekr.20090717084250.10684">def regexHelper (self,s,i,j,pattern,backwards,nocase):
   
    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        self.errors += 1 # Abort the search.
        return -1, -1
        
    if backwards: # Scan to the last match.
        last_mo = None
        while 1:
            mo = re_obj.search(s,i,j)
            if mo is None: break
            i = mo.end()
            last_mo = mo
        self.match_obj = mo = last_mo
    else:
        self.match_obj = mo = re_obj.search(s,i,j)
        
    if mo is None:
        return -1, -1
    else:
        k  = mo.start()
        k2 = mo.end()
        if 0:
            g.trace('i: %d, j: %d k: %d, k2: %d, s[k:k2]: %s, len(s): %d, s[-1]: %s,' % (
                i,j,k,k2,repr(s[k:k2]),len(s),repr(s[-1])))
        # g.trace('groups',mo.groups())
        return k, k2</t>
<t tx="ekr.20090717084250.10685">def backwardsHelper (self,s,i,j,pattern,nocase,word):

    if nocase:
        s = s.lower() ; pattern.lower()

    n = len(pattern)
    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            # g.trace(i,j,k)
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        # g.trace(i,j,k)
        if k == -1:
            return -1, -1
        else:
            return k,k+n</t>
<t tx="ekr.20090717084250.10686">def plainHelper (self,s,i,j,pattern,nocase,word):
    
    # g.trace(repr(s[i:i+20]))
    
    n = len(pattern)
    if nocase:
        s = s.lower() ; pattern = pattern.lower()
        pattern = pattern.replace('\\n','\n').replace('\\t','\t')

    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1: return -1, -1
            elif self.matchWord(s,k,pattern):
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            return -1, -1
        else:
            return k, k + n</t>
<t tx="ekr.20090717084250.10687">def matchWord(self,s,i,pattern):
    
    ok = g.match_word(s,i,pattern) and (
        i == 0 or 
        s[i-1] not in self.word_chars or
        s[i]   not in self.word_chars
    )

    # g.trace(ok,repr(s),i)
    return ok</t>
<t tx="ekr.20090717084250.10688"># Selects the next node to be searched.

def selectNextPosition(self):

    c = self.c ; p = self.p

    if self.selection_only:
        return None

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyPosition:
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.onlyPosition = p 

    # Start wrapped searches.
    if self.wrapping and not self.wrapPosition:
        assert(self.wrapPos != None)
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.wrapPosition = p 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        # g.trace('switching to body',g.callers(5))
        return p

    if self.reverse: p = p.threadBack()
    else:            p = p.threadNext()
    
    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not p:
            if self.wrapping:
                g.es('Wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.es('Found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not p and self.wrapping and not self.suboutline_only:
        p = c.rootPosition()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while p and p.next():
                p = p.next()
            if p: p = p.lastNode()

    # End wrapped searches.
    if self.wrapping and p and p == self.wrapPosition:
        # g.trace("ending wrapped search")
        p = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyPosition and p and
        (p == self.onlyPosition or not self.onlyPosition.isAncestorOf(p))):
        # g.trace("end outline-only")
        p = None ; self.onlyPosition = None

    # p.copy not needed because the find code never calls p.moveToX.
    # Furthermore, p might be None, so p.copy() would be wrong!
    self.p = p # used in initNextText().
    if p: # select p and set the search point within p.
        self.in_headline = self.search_headline
        self.initNextText()
    return p</t>
<t tx="ekr.20090717084250.10689"></t>
<t tx="ekr.20090717084250.10690">def checkArgs (self):

    val = True
    if not self.search_headline and not self.search_body:
        g.es("not searching headline or body")
        val = False
    if len(self.find_text) == 0:
        g.es("empty find patttern")
        val = False
    return val</t>
<t tx="ekr.20090717084250.10691"># Initializes for the Find All and Change All commands.

def initBatchCommands (self):

    c = self.c
    self.in_headline = self.search_headline # Search headlines first.
    self.errors = 0

    # Select the first node.
    if self.suboutline_only or self.node_only or self.selection_only:
        self.p = c.p
        if self.selection_only: self.selStart,self.selEnd = c.frame.body.getTextSelection()
        else:                   self.selStart,self.selEnd = None,None
    else:
        p = c.rootPosition()
        if self.reverse:
            while p and p.next():
                p = p.next()
            p = p.lastNode()
        self.p = p

    # Set the insert point.
    self.initBatchText()</t>
<t tx="ekr.20090717084250.10692"># Returns s_ctrl with "insert" point set properly for batch searches.
def initBatchText(self):
    p = self.p
    self.wrapping = False # Only interactive commands allow wrapping.
    s = g.choose(self.in_headline,p.h, p.b)
    return self.init_s_ctrl(s)

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self):
    p = self.p
    s = g.choose(self.in_headline,p.h, p.b)
    return self.init_s_ctrl(s)</t>
<t tx="ekr.20090717084250.10693"># Guesses which pane to start in for incremental searches and changes.
# This must not alter the current "insert" or "sel" marks.

def initInHeadline (self):

    c = self.c ; p = self.p

    # Do not change this without careful thought and extensive testing!
    if self.search_headline and self.search_body:
        # A temporary expedient.
        if self.reverse:
            self.in_headline = False
        else:
            # Search headline first.
            self.in_headline = (
                p == c.frame.tree.editPosition() and
                c.get_focus() != c.frame.body.bodyCtrl)
    else:
        self.in_headline = self.search_headline</t>
<t tx="ekr.20090717084250.10694"># For incremental searches

def initInteractiveCommands(self):

    c = self.c ; p = self.p ; gui = g.app.gui

    self.errors = 0
    if self.in_headline:
        c.frame.tree.setEditPosition(p)
        t = c.edit_widget(p)
        sel = None
    else:
        t = c.frame.bodyCtrl
        sel = gui.getTextSelection(t)
    pos = gui.getInsertPoint(t)
    st = self.initNextText()
    c.widgetWantsFocus(t)
    gui.setInsertPoint(st,pos)
    if sel:
        self.selStart,self.selEnd = sel
    else:
        self.selStart,self.selEnd = None,None
    self.wrapping = self.wrap
    if self.wrap and self.wrapPosition == None:
        self.wrapPos = pos
        # Do not set self.wrapPosition here: that must be done after the first search.</t>
<t tx="ekr.20090717084250.10695">def printLine (self,line,allFlag=False):

    both = self.search_body and self.search_headline
    context = self.batch # "batch" now indicates context

    if allFlag and both and context:
        g.es('-' * 20,self.p.h)
        theType = g.choose(self.in_headline,"head: ","body: ")
        g.es(theType + line)
    elif allFlag and context and not self.p.isVisited():
        # We only need to print the context once.
        g.es('-' * 20,self.p.h)
        g.es(line)
        self.p.setVisited()
    else:
        g.es(line)</t>
<t tx="ekr.20090717084250.10696"># Restores the screen after a search fails

def restore (self,data):

    c = self.c ; gui = g.app.gui
    in_headline,p,t,insert,start,end = data
    
    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectPosition(p)
    
    if not in_headline:
        # Looks good and provides clear indication of failure or termination.
        gui.setSelectionRange(t,insert,insert)
        gui.setInsertPoint(t,insert)
        gui.makeIndexVisible(t,insert)
    
    #g.trace(c.widget_name(t))
    
    if 1: # I prefer always putting the focus in the body.
        c.invalidateFocus()
        c.bodyWantsFocusNow()
    else:
        c.widgetWantsFocusNow(t)</t>
<t tx="ekr.20090717084250.10697">def save (self):

    c = self.c ; p = self.p ; gui = g.app.gui
    t = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    insert = gui.getInsertPoint(t)
    sel = gui.getSelectionRange(t)
    if len(sel) == 2:
        start,end = sel
    else:
        start,end = None,None
    return (self.in_headline,p,t,insert,start,end)</t>
<t tx="ekr.20090717084250.10698">def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p ; gui = g.app.gui
    
    c.frame.bringToFront() # Needed on the Mac
    c.beginUpdate()
    try:
        c.selectPosition(p)
    finally:
        c.endUpdate()
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    t = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    insert = g.choose(self.reverse,pos,newpos)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    # g.trace(id(t),pos,newpos)
    c.widgetWantsFocusNow(t)
    gui.setSelectionRange(t,pos,newpos,insert=insert)
    # c.widgetWantsFocusNow(t)
    gui.makeIndexVisible(t,insert)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p</t>
<t tx="ekr.20090717084250.10699">def init_s_ctrl (self,s):
    __pychecker__ = '--no-argsused'
    self.oops()

def bringToFront (self):
    self.oops()
   
# New in 4.3: allows base class to adjust controls. 
def adjust_find_text(self,s):
    __pychecker__ = '--no-argsused'
    self.oops()

def oops(self):
    print ("leoFind oops:",
        g.callers(),"should be overridden in subclass")
        
def update_ivars(self):
    self.oops()</t>
<t tx="ekr.20090717084250.10700"></t>
<t tx="ekr.20090717084250.10701">@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
write_intermediate_file = False
verbose=True
publish_argv_for_missing_stylesheets=--language=ca,--use-latex-toc,--output-encoding=utf-8,--stylesheet=custom_style.sty
@c

This is a test</t>
</tnodes>
</leo_file>
