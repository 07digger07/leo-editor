<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Chapter 21: IPython and Leo</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document">


<!-- rst3: filename: html\IPythonBridge.html -->
<!-- June, 2007 -->
<p><a class="reference" href="unitTesting.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="appendices.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section" id="chapter-21-ipython-and-leo">
<h1><a class="toc-backref" href="#id2">Chapter 21: IPython and Leo</a></h1>
<p>To use this plugin, you must run Leo from a console window. When this plugin is
enabled, Leo's start-ipython command starts <a class="reference" href="http://ipython.scipy.org/">IPython</a> in this console. Leo's
ipython plugin provides two-way communication (a bridge) between Leo and
IPython: you can run Leo scripts from IPython, and IPython scripts from Leo.</p>
<p>Remarkably, Leo and IPython run simultaneously in the same process,
yet their separate event loops do not interfere with each other.
Even more remarkably, scripts run from IPython <em>immediately</em> change Leo,
<em>exactly</em> as if the script were run from Leo.
Conversely, scripts run from Leo <em>immediately</em> affect the IPython interpreter.
Care may be needed when running such scripts while lengthy IPython scripts are running.
As the result of this truly remarkable connection between Leo and IPython,
Leo might plausibly be said to be an <a class="reference" href="http://projects.scipy.org/ipython/ipython/wiki/NoteBook">IPython Notebook</a>.</p>
<p>The bridge between Leo and IPython is powerful because it is simple. Indeed,</p>
<p>1. <strong>You can run any IPython script from Leo</strong>.
On the Leo side, as single variable:</p>
<pre class="literal-block">
ip = IPython.ipapi.get()
</pre>
<p>assigns ip to IPython's _ip variable. The ip variable allows scripts running in
Leo to do <em>anything</em> that an IPython script can do.</p>
<p>2. <strong>You can run any Leo script from IPython</strong>.
The ipython plugin injects a single object named '_leo' into the IPython namespace.
IPython scripts access Leo's c and g objects as
follows:</p>
<pre class="literal-block">
c,g = _leo.c, _leo.g
</pre>
<p>The c and g variables allow scripts running in IPython to do <em>anything</em> that a
Leo script can do.</p>
<p>This is basically everything that is required for IPython-Leo interaction.
However, you probably wont use 'c' and 'g' directly, but use a series of
convenience wrappers described in this document that make interactive work
painless and powerfull.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference" href="#chapter-21-ipython-and-leo" id="id2" name="id2">Chapter 21: IPython and Leo</a><ul>
<li><a class="reference" href="#introduction" id="id3" name="id3">Introduction</a></li>
<li><a class="reference" href="#installation" id="id4" name="id4">Installation</a></li>
<li><a class="reference" href="#accessing-ipython-from-leo" id="id5" name="id5">Accessing IPython from Leo</a><ul>
<li><a class="reference" href="#ipython-code" id="id6" name="id6">IPython code</a></li>
<li><a class="reference" href="#plain-python-code" id="id7" name="id7">Plain Python code</a></li>
</ul>
</li>
<li><a class="reference" href="#accessing-leo-nodes-from-ipython" id="id8" name="id8">Accessing Leo nodes from IPython</a><ul>
<li><a class="reference" href="#leonode" id="id9" name="id9">LeoNode</a></li>
<li><a class="reference" href="#accessing-children-with-iteration-and-dict-notation" id="id10" name="id10">Accessing children with iteration and dict notation</a></li>
</ul>
</li>
<li><a class="reference" href="#cl-definitions" id="id11" name="id11">&#64;cl definitions</a></li>
<li><a class="reference" href="#special-node-types" id="id12" name="id12">Special node types</a><ul>
<li><a class="reference" href="#ipy-startup" id="id13" name="id13">&#64;ipy-startup</a></li>
<li><a class="reference" href="#ipy-results" id="id14" name="id14">&#64;ipy-results</a></li>
<li><a class="reference" href="#ipy-root" id="id15" name="id15">&#64;ipy-root</a></li>
<li><a class="reference" href="#a-nodes" id="id16" name="id16">&#64;a nodes</a></li>
</ul>
</li>
<li><a class="reference" href="#declaring-custom-push-to-ipython-handlers" id="id17" name="id17">Declaring custom push-to-ipython handlers</a></li>
<li><a class="reference" href="#example-code-snippets" id="id18" name="id18">Example code snippets</a></li>
<li><a class="reference" href="#magic-functions" id="id19" name="id19">Magic functions</a><ul>
<li><a class="reference" href="#mb" id="id20" name="id20">%mb</a></li>
<li><a class="reference" href="#lee" id="id21" name="id21">%lee</a></li>
</ul>
</li>
<li><a class="reference" href="#acknowledgements-and-history" id="id22" name="id22">Acknowledgements and history</a></li>
</ul>
</li>
</ul>
</div>
<!-- Links -->
<!-- WARNING: image targets may not have upper case letters! -->
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id3">Introduction</a></h2>
<p>The purpose of ILeo, or leo-ipython bridge, is being a two-way communication
channel between Leo and IPython. The level of integration is much deeper than
conventional integration in IDEs; most notably, you are able to store and
manipulate <strong>data</strong> in Leo nodes, in addition to mere program code - essentially
making ILeo a hierarchical spreadsheet, albeit with non-grid view of the data.
The possibilities of this are endless, and the approach can be applied in wide
range of problem domains with very little actual coding.</p>
<p>IPython users are accustomed to using things like %edit to produce non-trivial
functions/classes (i.e. something that they don't want to enter directly on the
interactive prompt, but creating a proper script/module involves too much
overhead). In ILeo, this task consists just going to the Leo window, creating a node
and writing the code there, and pressing alt+I (push-to-ipython).</p>
<p>Obviously, you can save the Leo document as usual - this is a great advantage
of ILeo over using %edit, you can save your experimental scripts all at one
time, without having to organize them into script/module files (before you
really want to, of course!)</p>
</div>
<div class="section" id="installation">
<h2><a class="toc-backref" href="#id4">Installation</a></h2>
<p>You need at least Leo 4.4.8, and IPython 0.8.3</p>
<p>The ILeo concept is still being developed actively, so if you want to get access
to latest features you can get IPython from Launchpad by installing bzr and
doing:</p>
<pre class="literal-block">
bzr branch lp:ipython
cd ipython
python eggsetup.py develop
</pre>
<p>You need to enable the 'ipython.py' plugin in Leo:</p>
<ul class="simple">
<li>Help -&gt; Open LeoSettings.leo</li>
<li>Edit &#64;settings--&gt;Plugins--&gt;&#64;enabled-plugins, add/uncomment 'ipython.py'</li>
<li>Alternatively, you can add &#64;settings--&gt;&#64;enabled-plugins with body ipython.py to your leo document.</li>
<li>Restart Leo. Be sure that you have the console window open (start leo.py from console, or double-click leo.py on windows)</li>
<li>Press alt+shif+i OR alt-x start-ipython to launch IPython in the console that
started leo. You can start entering IPython commands normally, and Leo will keep
running at the same time.</li>
<li>Note that you can just press alt-I (push-to-ipython) - it will start IPython
if it has not been previously started. However, when you open a new leo
document, you have to execute start-ipython (alt+shift+I) again to tell
IPython that the new commands should target the new document. IPython session
will not be restarted, only the leo commander object is updated in the
existing session.</li>
</ul>
</div>
<div class="section" id="accessing-ipython-from-leo">
<h2><a class="toc-backref" href="#id5">Accessing IPython from Leo</a></h2>
<div class="section" id="ipython-code">
<h3><a class="toc-backref" href="#id6">IPython code</a></h3>
<p>Just enter IPython commands on a Leo node and press alt-I to execute
push-to-ipython in order to execute the script in IPython. 'commands' is
interpreted loosely here - you can enter function and class definitions, in
addition to the things you would usually enter at IPython prompt - calculations,
system commands etc.</p>
<p>Everything that would be legal to enter on IPython prompt is legal to execute
from ILeo.</p>
<p>Results will be shows in Leo log window for convenience, in addition to the console.</p>
<p>Suppose that a node had the following contents:</p>
<pre class="literal-block">
1+2
print &quot;hello&quot;
3+4

def f(x):
    return x.upper()

f('hello world')
</pre>
<p>If you press alt+I on that node, you will see the following in Leo log window (IPython tab):</p>
<pre class="literal-block">
In: 1+2
&lt;2&gt; 3
In: 3+4
&lt;4&gt; 7
In: f('hello world')
&lt;6&gt; 'HELLO WORLD'
</pre>
<p>(numbers like &lt;6&gt; mean IPython output history indices; the actual object can be
referenced with _6 as usual in IPython).</p>
</div>
<div class="section" id="plain-python-code">
<h3><a class="toc-backref" href="#id7">Plain Python code</a></h3>
<p>If the headline of the node ends with capital P, alt-I will not run the code
through IPython translation mechanism but use the direct python 'exec' statement
(in IPython user namespace) to execute the code. It wont be shown in IPython
history, and sometimes it is safer (and more efficient) to execute things as
plain Python statements. Large class definitions are good candidates for P
nodes.</p>
</div>
</div>
<div class="section" id="accessing-leo-nodes-from-ipython">
<h2><a class="toc-backref" href="#id8">Accessing Leo nodes from IPython</a></h2>
<p>The real fun starts when you start entering text to leo nodes, and are using
that as data (input/output) for your IPython work.</p>
<p>Accessing Leo nodes happens through the variable <strong>wb</strong> (short for &quot;WorkBook&quot;)
that exist in the IPython user namespace. Nodes that are directly accessible are
the ones that have simple names which could also be Python variable names;
'foo_1' will be accessible directly from IPython, whereas 'my scripts' will not.
If you want to access a node with arbitrary headline, add a child node '&#64;a foo'
(&#64;a stands for 'anchor'). Then, the parent of '&#64;a foo' is accessible through
'wb.foo'.</p>
<p>You can see what nodes are accessible be entering (in IPython) wb.&lt;TAB&gt;. Example:</p>
<pre class="literal-block">
[C:leo/src]|12&gt; wb.
wb.b           wb.tempfile    wb.rfile       wb.NewHeadline
wb.bar         wb.Docs        wb.strlist     wb.csvr
[C:leo/src]|12&gt; wb.tempfile
           &lt;12&gt; &lt;ipy_leo.LeoNode object at 0x044B6D90&gt;
</pre>
<p>So here, we meet the 'LeoNode' class that is your key to manipulating Leo
content from IPython!</p>
<div class="section" id="leonode">
<h3><a class="toc-backref" href="#id9">LeoNode</a></h3>
<p>Suppose that we had a node with headline 'spam' and body:</p>
<pre class="literal-block">
['12',2222+32]
</pre>
<p>we can access it from IPython (or from scripts entered into other Leo nodes!) by doing:</p>
<pre class="literal-block">
C:leo/src]|19&gt; wb.spam.v
          &lt;19&gt; ['12', 2254]
</pre>
<p>'v' attribute stands for 'value', which means the node contents will be run
through 'eval' and everything you would be able to enter into IPython prompt
will be converted to objects. This mechanism can be extended far beyond direct
evaluation (see <a class="reference" href="mailto:'&#64;cl">'&#64;cl</a> definitions').</p>
<p>'v' attribute also has a setter, i.e. you can do:</p>
<pre class="literal-block">
wb.spam.v = &quot;mystring&quot;
</pre>
<p>Which will result in the node 'spam' having the following text:</p>
<pre class="literal-block">
'mystring'
</pre>
<p>What assignment to 'v' does can be configured through generic functions
('simplegeneric' module, see ipy_leo.py for examples).</p>
<p>Besides v, you can set the body text directly through:</p>
<pre class="literal-block">
wb.spam.b = &quot;some\nstring&quot;,
</pre>
<p>headline by:</p>
<pre class="literal-block">
wb.spam.h = 'new_headline'
</pre>
<p>(obviously you must access the node through wb.new_headline from that point
onwards), and access the contents as string list (IPython SList) through
'wb.spam.l'.</p>
<p>If you do 'wb.foo.v = 12' when node named 'foo' does not exist, the node titled
'foo' will be automatically created and assigned body 12.</p>
<p>LeoNode also supports go() that focuses the node in the Leo window, and ipush()
that simulates pressing alt+I on the node (beware of the possible recursion!).</p>
<p>You can access unknownAttributes by .uA property dictionary. Unknown attributes
allow you to store arbitrary (pickleable) python objects in the Leo nodes; the
attributes are stored when you save the .leo document, and recreated when you
open the document again. The attributes are not visible anywhere, but can be
used for domain-specific metatada. Example:</p>
<pre class="literal-block">
[C:leo/src]|12&gt; wb.spam.uA['coords'] = (12,222)
[C:leo/src]|13&gt; wb.spam.uA
           &lt;13&gt; {'coords': (12, 222)}
</pre>
</div>
<div class="section" id="accessing-children-with-iteration-and-dict-notation">
<h3><a class="toc-backref" href="#id10">Accessing children with iteration and dict notation</a></h3>
<p>Sometimes, you may want to treat a node as a 'database', where the nodes
children represent elements in the database. You can create a new child node for
node 'spam', with headline 'foo bar' like this:</p>
<pre class="literal-block">
wb.spam['foo bar'] = &quot;Hello&quot;
</pre>
<p>And assign a new value for it by doing:</p>
<pre class="literal-block">
wb.spam['foo bar'].v = &quot;Hello again&quot;
</pre>
<p>Note how you can't use .v when you first create the node - i.e. the node needs
to be initialized by simple assignment, that will be interpreted as assignment
to '.v'. This is a conscious design choice.</p>
<p>If you try to do wb.spam['bar'] = 'Hello', ILeo will assign '&#64;k bar' as the
headline for the child instead, because 'bar' is a legal python name (and as
such would be incorporated in the workbook namespace). This is done to avoid
crowding the workbook namespace with extraneous items. The item will still be
accessible as wb.spam['bar']</p>
<p>LeoNodes are iterable, so to see the headlines of all the children of 'spam' do:</p>
<pre class="literal-block">
for n in wb.spam:
    print n.h
</pre>
</div>
</div>
<div class="section" id="cl-definitions">
<h2><a class="toc-backref" href="#id11">&#64;cl definitions</a></h2>
<p>If the first line in the body text is of the form <a class="reference" href="mailto:'&#64;cl">'&#64;cl</a> sometext', IPython will
evaluate 'sometext' and call the result with the rest of the body when you do
'wb.foo.v' or press alt+I on the node. An example is in place here. Suppose that we have defined a class (I
use the term class in a non-python sense here):</p>
<pre class="literal-block">
def rfile(body,node):
    &quot;&quot;&quot; &#64;cl rfile

    produces a StringIO (file like obj) of the rest of the body &quot;&quot;&quot;

    import StringIO
    return StringIO.StringIO(body)
</pre>
<p>(note that node is ignored here - but it could be used to access headline,
children etc.),</p>
<p>Now, let's say you have node 'spam' with text:</p>
<pre class="literal-block">
&#64;cl rfile
hello
world
and whatever
</pre>
<p>Now, in IPython, we can do this:</p>
<pre class="literal-block">
[C:leo/src]|22&gt; f = wb.spam.v
[C:leo/src]|23&gt; f
           &lt;23&gt; &lt;StringIO.StringIO instance at 0x04E7E490&gt;
[C:leo/src]|24&gt; f.readline()
           &lt;24&gt; u'hello\n'
[C:leo/src]|25&gt; f.readline()
           &lt;25&gt; u'world\n'
[C:leo/src]|26&gt; f.readline()
           &lt;26&gt; u'and whatever'
[C:leo/src]|27&gt; f.readline()
           &lt;27&gt; u''
</pre>
<p>You should declare new &#64;cl types to make ILeo as convenient your problem domain
as possible. For example, a &quot;&#64;cl etree&quot; could return the elementtree object for
xml content.</p>
</div>
<div class="section" id="special-node-types">
<h2><a class="toc-backref" href="#id12">Special node types</a></h2>
<div class="section" id="ipy-startup">
<h3><a class="toc-backref" href="#id13">&#64;ipy-startup</a></h3>
<p>If this node exist, the <em>direct children</em> of this will be pushed to IPython when
ILeo is started (you press alt+shift-i). Use it to push your own &#64;cl
definitions, import the modules you will be using elsewhere in the document, etc.</p>
<p>The contents of of the node itself will be ignored.</p>
</div>
<div class="section" id="ipy-results">
<h3><a class="toc-backref" href="#id14">&#64;ipy-results</a></h3>
<p>If you press alt+I on a node that has &#64;cl, it will be evaluated and the result
will be put into this node. Otherwise, it will just be displayed in log tab.</p>
</div>
<div class="section" id="ipy-root">
<h3><a class="toc-backref" href="#id15">&#64;ipy-root</a></h3>
<p>You can set up a subportion of the leo document as a &quot;sandbox&quot; for your IPython
work. Only the nodes under &#64;ipy-root will be visible through the 'wb' variable.</p>
<p>Also, when you create a new node (wb.foo.v = 'stuff'), the node foo will be created as
a child of this node.</p>
</div>
<div class="section" id="a-nodes">
<h3><a class="toc-backref" href="#id16">&#64;a nodes</a></h3>
<p>You can attach these as children of existing nodes to provide a way to access
nodes with arbitrary headlines, or to provide aliases to other nodes. If
multiple &#64;a nodes are attached as children of a node, all the names can be used
to access the same object.</p>
</div>
</div>
<div class="section" id="declaring-custom-push-to-ipython-handlers">
<h2><a class="toc-backref" href="#id17">Declaring custom push-to-ipython handlers</a></h2>
<p>Sometimes, you might want to configure what alt+I on a node does. You can do
that by creating your own push function and expose it using
ipy_leo.expose_ileo_push(f, priority). The function should check whether the
node should by handled by the function and raise IPython.ipapi.TryNext if it
will not do the handling, giving the next function in the chain a chance to see
whether it should handle the push.</p>
<p>This example would print an uppercase version of node body if the node headline ends
with U (yes, this is completely useless!):</p>
<pre class="literal-block">
def push_upcase(node):
    if not node.h.endswith('U'):
        raise TryNext
    print node.b.upper()

ipy_leo.expose_ileo_push(push_upcase, 12)
</pre>
<p>(the priority should be between 0-100, with 0 being the highest (first one to
try) - typically, you don't need to care about it and can usually omit the
argument altogether)</p>
</div>
<div class="section" id="example-code-snippets">
<h2><a class="toc-backref" href="#id18">Example code snippets</a></h2>
<p>Get list of all headlines of all the nodes in leo:</p>
<pre class="literal-block">
[node.h for node in wb]
</pre>
<p>Create node with headline 'baz', empty body:</p>
<pre class="literal-block">
wb.baz
</pre>
<p>Create 10 child nodes for baz, where i is headline and 'Hello ' + i is body:</p>
<pre class="literal-block">
for i in range(10):
    wb.baz[i] = 'Hello %d' % i
</pre>
<p>Create 5 child nodes for the current node (note the use of special _p variable,
which means &quot;current node&quot;) and moves focus to node number 5:</p>
<pre class="literal-block">
for i in range(10):
    _p[i] = 'hello %d' % d
_p[5].go()
</pre>
</div>
<div class="section" id="magic-functions">
<h2><a class="toc-backref" href="#id19">Magic functions</a></h2>
<div class="section" id="mb">
<h3><a class="toc-backref" href="#id20">%mb</a></h3>
<p>Execute leo minibuffer command. Tab completion works. Example:</p>
<pre class="literal-block">
mb open-outline
</pre>
</div>
<div class="section" id="lee">
<h3><a class="toc-backref" href="#id21">%lee</a></h3>
<p>Stands for &quot;LEo Edit&quot;. Allows you to open file(s), and even objects in Leo for editing. Examples:</p>
<pre class="literal-block">
lee *.txt
</pre>
<p>Opens all txt files in &#64;auto nodes</p>
<pre class="literal-block">
lee MyMacro
</pre>
<p>Opens the macro MyMacro for editing. Press alt-I to push the edited macro back to IPython.</p>
<pre class="literal-block">
s = 'hello word'
lee s
</pre>
<p>Opens the variable s for editing. Prell alt+I to push the new value to IPython.</p>
<pre class="literal-block">
lee hist
</pre>
<p>Opens IPython interactive history (both input and output) in Leo.</p>
</div>
</div>
<div class="section" id="acknowledgements-and-history">
<h2><a class="toc-backref" href="#id22">Acknowledgements and history</a></h2>
<p>This idea got started when I (Ville M. Vainio) saw this post by Edward Ream (the author of
Leo) on IPython developer mailing list:</p>
<blockquote>
<a class="reference" href="http://lists.ipython.scipy.org/pipermail/ipython-dev/2008-January/003551.html">http://lists.ipython.scipy.org/pipermail/ipython-dev/2008-January/003551.html</a></blockquote>
<p>I was using FreeMind as mind mapping software, and so I had an immediate use
case for Leo (which, incidentally, is superior to FreeMind as mind mapper). The
wheels started rolling, I got obsessed with the power of this concept
(everything clicked together), and Edwards excitement paralleled mine.
Everything was mind-bogglingly easy/trivial, something that is typical of all
promising technologies.</p>
<p><a class="reference" href="http://sourceforge.net/forum/forum.php?thread_id=1911662&amp;forum_id=10226">Discussions</a> on SourceForge show how the goal of close cooperation between Leo and IPython went from
vague dream to completed reality over the span of about 10 days.</p>
<hr class="docutils" />
<p><a class="reference" href="unitTesting.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="appendices.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</body>
</html>
