<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Chapter 15: Controlling Syntax Coloring</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document">


<!-- rst3: filename: html\coloring.html -->
<!-- July, 2006 -->
<p><a class="reference" href="rstplugin3.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="debuggers.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section" id="chapter-15-controlling-syntax-coloring">
<h1><a class="toc-backref" href="#id1">Chapter 15: Controlling Syntax Coloring</a></h1>
<p>This chapter discusses how to control Leo's new syntax colorer using Python
files derived from <a class="reference" href="http://www.jedit.org/">jEdit</a>'s xml language description files. It also discusses
settings related to syntax coloring.</p>
<p><strong>Important</strong>: this material is for those who want to support Leo's colorizing
code. You do <em>not</em> need to understand this chapter in order to use Leo's
colorizers.</p>
<p>The __jEdit_colorizer__.py plugin was an early prototype of the new colorizer.
This code has been retired. The threading_colorizer.py plugin uses a separate
helper thread to do the colorizing. Coding details for this plugin are discussed
in this chapter.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference" href="#chapter-15-controlling-syntax-coloring" id="id1" name="id1">Chapter 15: Controlling Syntax Coloring</a><ul>
<li><a class="reference" href="#files" id="id2" name="id2">Files</a></li>
<li><a class="reference" href="#the-colorizer-s-inner-loop" id="id3" name="id3">The colorizer's inner loop</a></li>
<li><a class="reference" href="#format-of-colorizer-control-files" id="id4" name="id4">Format of colorizer control files</a><ul>
<li><a class="reference" href="#ruleset-names" id="id5" name="id5">Ruleset names</a></li>
<li><a class="reference" href="#x-properties" id="id6" name="id6">x.properties</a></li>
<li><a class="reference" href="#attribute-dictionaries-and-x-attributesdictdict" id="id7" name="id7">Attribute dictionaries and x.attributesDictDict</a></li>
<li><a class="reference" href="#keyword-dictionaries-and-x-keywordsdictdict" id="id8" name="id8">Keyword dictionaries and x.keywordsDictDict</a></li>
<li><a class="reference" href="#rules-rules-dictionaries-and-x-rulesdictdict" id="id9" name="id9">Rules, rules dictionaries and x.rulesDictDict</a></li>
<li><a class="reference" href="#x-importdict-and-imported-versus-delegated-rulesets" id="id10" name="id10">x.importDict and imported versus delegated rulesets</a></li>
</ul>
</li>
<li><a class="reference" href="#rule-methods" id="id11" name="id11">Rule methods</a><ul>
<li><a class="reference" href="#arguments-to-rule-methods" id="id12" name="id12">Arguments to rule methods</a></li>
<li><a class="reference" href="#match-eol-span" id="id13" name="id13">match_eol_span</a></li>
<li><a class="reference" href="#match-eol-span-regexp" id="id14" name="id14">match_eol_span_regexp</a></li>
<li><a class="reference" href="#match-keywords" id="id15" name="id15">match_keywords</a></li>
<li><a class="reference" href="#match-mark-following" id="id16" name="id16">match_mark_following</a></li>
<li><a class="reference" href="#match-mark-previous" id="id17" name="id17">match_mark_previous</a></li>
<li><a class="reference" href="#match-seq" id="id18" name="id18">match_seq</a></li>
<li><a class="reference" href="#match-seq-regexp" id="id19" name="id19">match_seq_regexp</a></li>
<li><a class="reference" href="#match-span" id="id20" name="id20">match_span</a></li>
<li><a class="reference" href="#match-span-regexp" id="id21" name="id21">match_span_regexp</a></li>
<li><a class="reference" href="#match-terminate" id="id22" name="id22">match_terminate</a></li>
</ul>
</li>
<li><a class="reference" href="#syntax-coloring-settings" id="id23" name="id23">Syntax coloring settings</a></li>
<li><a class="reference" href="#the-threading-colorizer-plugin" id="id24" name="id24">The threading_colorizer plugin</a></li>
</ul>
</li>
</ul>
</div>
<!-- External links... -->
<!-- Relative links... -->
<!-- WARNING: image targets may not have upper case letters! -->
<div class="section" id="files">
<h2><a class="toc-backref" href="#id2">Files</a></h2>
<p>The <a class="reference" href="http://www.jedit.org/">jEdit</a> editor drives its syntax colorer using xml <strong>language description files.</strong>
<a class="reference" href="http://www.jedit.org/42docs/users-guide/writing-modes-part.html">jEdit's documentation</a> contain a complete description of these xml files.
Each xml file describes one <strong>colorizing mode</strong>.
A mode consists of one or more <strong>rulesets</strong>, and each ruleset consists of a list of <strong>colorizing rules</strong>.
In addition, modes, rulesets and rules may have associated <strong>properties</strong> and <strong>attributes</strong>.
Various rules may specify that the colorizer uses another ruleset (either in the same mode or another mode).</p>
<p><strong>Important</strong>: jEdit's xml language description files contain no explicit <tt class="docutils literal"><span class="pre">&lt;RULE&gt;</span></tt> elements
Rules are simply sub-elements of an enclosing <tt class="docutils literal"><span class="pre">&lt;RULES&gt;</span></tt> element.
The element indicates the kind of rule that is specified,
for example, <tt class="docutils literal"><span class="pre">&lt;SPAN&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;SEQ&gt;</span></tt>, etc.
By the term <strong>rule element</strong> we shall mean any sub-element of the <tt class="docutils literal"><span class="pre">&lt;RULES&gt;</span></tt> element.</p>
<p>Rather than using the xml language description files directly,
Leo uses Python <strong>colorer control files</strong>,
created automatically from the xml files by a script called <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt>.
These Python files contain all the information in the jEdit's xml files,
so we can (loosely) speak of modes, rulesets, rules, properties and attributes in the Python colorer control files.
Later sections of this documentation will make this loose correspondence exact.</p>
<p><strong>Important</strong>: throughout this documentation,
<strong>x.py</strong> will refer to the Python colorer for language <tt class="docutils literal"><span class="pre">x</span></tt>,
and <strong>x.xml</strong> will refer to the corresponding xml language-description file.</p>
<p>Using Python colorer control files has the following advantages:</p>
<ul class="simple">
<li>Running <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt> need only be done when x.xml changes,
and the speed of the xml parser in jEdit2Py does not affect the speed of Leo's colorizer in any way.
Moreover, the <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt> script can contain debugging traces and checks.</li>
<li>Colorer control files are valid .py files, so all of Python's import optimizations work as usual.
In particular, all the data in colorer control files is immediately accessible to Leo's colorer.</li>
<li>Colorer control files are easier for humans to understand and modify than the equivalent xml file.
Furthermore, it is easy to insert debugging information into Python colorer control files.</li>
<li>It is easy to modify the Python colorer control files 'by hand' without changing the corresponding xml file.
In particular, it would be easy to define entirely new kinds of pattern-matching rules in Python merely
by creating functions in a colorer control file.</li>
</ul>
</div>
<div class="section" id="the-colorizer-s-inner-loop">
<h2><a class="toc-backref" href="#id3">The colorizer's inner loop</a></h2>
<p>When Leo's syntax colorer sees the <tt class="docutils literal"><span class="pre">'&#64;language</span> <span class="pre">x'</span></tt> directive,
it will import <tt class="docutils literal"><span class="pre">x.py</span></tt> from Leo's <tt class="docutils literal"><span class="pre">modes</span></tt> folder.
The colorer can then access any module-level object <tt class="docutils literal"><span class="pre">obj</span></tt> in <tt class="docutils literal"><span class="pre">x.py</span></tt> as <tt class="docutils literal"><span class="pre">x.obj</span></tt>.</p>
<p>Colorizer control files contain <strong>rules functions</strong> corresponding to rule elements in x.xml.
The colorizer can call these functions as if they were members of the colorizer class by
passing 'self' as the first argument of these functions.
I call these rules <em>functions</em> to distinguish them from the corresponding
<strong>rules methods</strong> which are actual methods of the colorizer class.
Rules <em>functions</em> merely call corresponding rules <em>methods</em>.
Indeed, rules functions are simply a way of binding values to keyword arguments of rules methods.
These keywords arguments correspond to the xml attributes of rule elements in x.xml.</p>
<p>The colorizer calls rules functions until one matches, at which point a range of text gets colored and the process repeats.
The inner loop of the colorizer is this code:</p>
<pre class="literal-block">
for f in self.rulesDict.get(s[i],[]):
    n = f(self,s,i)
    if n &gt; 0:
        i += n ; break
    else: i += 1
</pre>
<ul class="simple">
<li>rulesDict is a dictionary whose keys are rulesets and whose values are ruleset dictionaries.
Ruleset dictionaries have keys that are single characters and whose values are
the list of rules that can start with that character.</li>
<li>s is the full text to be colorized.</li>
<li>i is the position within s is to be colorized.</li>
</ul>
<p>Rules methods (and functions) return n &gt; 0 if they match, and n == 0 if they fail.</p>
</div>
<div class="section" id="format-of-colorizer-control-files">
<h2><a class="toc-backref" href="#id4">Format of colorizer control files</a></h2>
<p>The following sections describe the top-level data in <tt class="docutils literal"><span class="pre">x.py</span></tt>.</p>
<div class="section" id="ruleset-names">
<h3><a class="toc-backref" href="#id5">Ruleset names</a></h3>
<p>A <strong>ruleset name</strong> is a Python string having the form <tt class="docutils literal"><span class="pre">'x_setname'</span></tt>,
where <tt class="docutils literal"><span class="pre">setname</span></tt> is the value of the <tt class="docutils literal"><span class="pre">SET</span></tt> attribute of the <tt class="docutils literal"><span class="pre">&lt;RULES&gt;</span></tt> element in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.
For example, the ruleset name of the ruleset whose <tt class="docutils literal"><span class="pre">SET</span></tt> attribute is <tt class="docutils literal"><span class="pre">JAVASCRIPT</span></tt> in <tt class="docutils literal"><span class="pre">php.xml</span></tt> is
<tt class="docutils literal"><span class="pre">'php_JAVASCRIPT'</span></tt>.
<strong>Important</strong>: by convention, the ruleset name of the default <tt class="docutils literal"><span class="pre">&lt;RULES&gt;</span></tt> element is <tt class="docutils literal"><span class="pre">'x_main'</span></tt>;
note that default <tt class="docutils literal"><span class="pre">&lt;RULES&gt;</span></tt> element have no <tt class="docutils literal"><span class="pre">SET</span></tt> attributes.</p>
<p>The colorizer uses ruleset names to gain access to all data structures in <tt class="docutils literal"><span class="pre">x.py</span></tt>.
To anticipate a bit, ruleset names are keys into two standard dictionaries,
<tt class="docutils literal"><span class="pre">x.rulesDict</span></tt> and <tt class="docutils literal"><span class="pre">x.keywordsDictDict</span></tt>,
from which the colorizer can get all other information in <tt class="docutils literal"><span class="pre">x.py</span></tt>:</p>
<pre class="literal-block">
# The rules list for the 'JAVASCRIPT' ruleset in php.xml.
rules = x.rulesDict('php_JAVASCRIPT')

# The keywords dict for the 'JAVASCRIPT' ruleset in php.xml.
keywordsDict = x.keywordsDictDict('php_JAVASCRIPT')
</pre>
<p>In fact, ruleset names (and <tt class="docutils literal"><span class="pre">x.rulesDict</span></tt> and <tt class="docutils literal"><span class="pre">x.keywordsDictDict</span></tt>)
are the <strong>only</strong> names that the colorizer needs to know in order to access all information in <tt class="docutils literal"><span class="pre">x.py</span></tt>.</p>
</div>
<div class="section" id="x-properties">
<h3><a class="toc-backref" href="#id6">x.properties</a></h3>
<p><strong>x.properties</strong> is a Python dictionary corresponding to the &lt;PROPS&gt; element in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.
Keys are property names; values are strings, namely the contents of <tt class="docutils literal"><span class="pre">&lt;PROPERTY&gt;</span></tt> elements in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.
<tt class="docutils literal"><span class="pre">x.properties</span></tt> contains properties for the entire mode.
That is, only modes have <tt class="docutils literal"><span class="pre">&lt;PROPS&gt;</span></tt> elements.
For example, here is <tt class="docutils literal"><span class="pre">x.properties</span></tt> in <tt class="docutils literal"><span class="pre">php.py</span></tt>:</p>
<pre class="literal-block">
# properties for mode php.xml
properties = {
    &quot;commentEnd&quot;: &quot;--&gt;&quot;,
    &quot;commentStart&quot;: &quot;&lt;!--&quot;,
    &quot;indentCloseBrackets&quot;: &quot;}&quot;,
    &quot;indentOpenBrackets&quot;: &quot;{&quot;,
    &quot;lineUpClosingBracket&quot;: &quot;true&quot;,
}
</pre>
</div>
<div class="section" id="attribute-dictionaries-and-x-attributesdictdict">
<h3><a class="toc-backref" href="#id7">Attribute dictionaries and x.attributesDictDict</a></h3>
<p><tt class="docutils literal"><span class="pre">x.py</span></tt> contains a <strong>attribute dictionary</strong> for each ruleset in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.
Keys are attribute names, values strings representing the values of the attributes.
This dictionary is empty if a ruleset contains no attributes.
The valid keys are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">'default'</span></tt>: the default token type.  <tt class="docutils literal"><span class="pre">'null'</span></tt> is the default.</li>
<li><tt class="docutils literal"><span class="pre">'digit_re'</span></tt>: a regular expression.
Words matching this regular expression are colored with the <tt class="docutils literal"><span class="pre">digit</span></tt> token type.</li>
<li><tt class="docutils literal"><span class="pre">'ignore_case'</span></tt>: <tt class="docutils literal"><span class="pre">'true'</span></tt> or <tt class="docutils literal"><span class="pre">'false'</span></tt>.  Default is <tt class="docutils literal"><span class="pre">'true'</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">`highlight_digits'</span></tt>: <tt class="docutils literal"><span class="pre">'true'</span></tt> or <tt class="docutils literal"><span class="pre">'false'</span></tt>.  Default is <tt class="docutils literal"><span class="pre">'true'</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">'no_word_sep'</span></tt>: A list of characters treated as 'alphabetic' characters when matching keywords.</li>
</ul>
<p>For example, here is one attribute dictionary in php.py:</p>
<pre class="literal-block">
# Attributes dict for php_javascript ruleset.
php_javascript_attributes_dict = {
    &quot;default&quot;: &quot;MARKUP&quot;,
    &quot;digit_re&quot;: &quot;&quot;,
    &quot;highlight_digits&quot;: &quot;true&quot;,
    &quot;ignore_case&quot;: &quot;true&quot;,
    &quot;no_word_sep&quot;: &quot;&quot;,
}
</pre>
<p><tt class="docutils literal"><span class="pre">x.py</span></tt> also contains <strong>x.attributesDictDict</strong>.
Keys are ruleset names, values are attribute dictionaries.
Here is <tt class="docutils literal"><span class="pre">attributesDictDict</span></tt> for php.py:</p>
<pre class="literal-block">
# Dictionary of attributes dictionaries for php mode.
attributesDictDict = {
    &quot;php_javascript&quot;: php_javascript_attributes_dict,
    &quot;php_javascript_php&quot;: php_javascript_php_attributes_dict,
    &quot;php_main&quot;: php_main_attributes_dict,
    &quot;php_php&quot;: php_php_attributes_dict,
    &quot;php_php_literal&quot;: php_php_literal_attributes_dict,
    &quot;php_phpdoc&quot;: php_phpdoc_attributes_dict,
    &quot;php_tags&quot;: php_tags_attributes_dict,
    &quot;php_tags_literal&quot;: php_tags_literal_attributes_dict,
}
</pre>
<p><strong>Note</strong>:
The <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt> script creates 'friendly' names for attribute dictionaries <em>solely</em> as an aid for people reading the code.
Leo's colorer uses only the name <tt class="docutils literal"><span class="pre">x.attributeDictDict</span></tt>;
Leo's colorer never uses the actual names of attribute dictionaries.</p>
</div>
<div class="section" id="keyword-dictionaries-and-x-keywordsdictdict">
<h3><a class="toc-backref" href="#id8">Keyword dictionaries and x.keywordsDictDict</a></h3>
<p><tt class="docutils literal"><span class="pre">x.py</span></tt> contains a <strong>keyword dictionary</strong> for each ruleset in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.
<tt class="docutils literal"><span class="pre">x.py</span></tt> contains an empty keywords dictionary if a ruleset contains no <tt class="docutils literal"><span class="pre">&lt;KEYWORDS&gt;</span></tt> element.</p>
<p>Keys are strings representing keywords of the language describe by the mode.
Values are strings representing syntactic categories,
i.e. a <tt class="docutils literal"><span class="pre">TYPE</span></tt> attribute valid in <tt class="docutils literal"><span class="pre">x.xml</span></tt>, namely:
<tt class="docutils literal"><span class="pre">COMMENT1</span></tt>, <tt class="docutils literal"><span class="pre">COMMENT2</span></tt>, <tt class="docutils literal"><span class="pre">COMMENT3</span></tt>, <tt class="docutils literal"><span class="pre">COMMENT4</span></tt>,
<tt class="docutils literal"><span class="pre">FUNCTION</span></tt>,
<tt class="docutils literal"><span class="pre">KEYWORD1</span></tt>, <tt class="docutils literal"><span class="pre">KEYWORD2</span></tt>, <tt class="docutils literal"><span class="pre">KEYWORD3</span></tt>, <tt class="docutils literal"><span class="pre">KEYWORD4</span></tt>,
<tt class="docutils literal"><span class="pre">LABEL</span></tt>, <tt class="docutils literal"><span class="pre">LITERAL1</span></tt>, <tt class="docutils literal"><span class="pre">LITERAL2</span></tt>, <tt class="docutils literal"><span class="pre">LITERAL3</span></tt>, <tt class="docutils literal"><span class="pre">LITERAL4</span></tt>,
<tt class="docutils literal"><span class="pre">MARKUP</span></tt>, <tt class="docutils literal"><span class="pre">NULL</span></tt> and <tt class="docutils literal"><span class="pre">OPERATOR</span></tt>.</p>
<p>For example, here (parts of) some keyword dictionaries in php.py:</p>
<pre class="literal-block">
# Keywords dict for mode php::PHP
php_PHP_keywords_dict = {
    &quot;COM_invoke&quot;: &quot;keyword2&quot;,
    &quot;COM_load&quot;: &quot;keyword2&quot;,
    &quot;__CLASS__&quot;: &quot;keyword3&quot;,
    ...
    &quot;abs&quot;: &quot;keyword2&quot;,
    &quot;abstract&quot;: &quot;keyword1&quot;,
    &quot;accept_connect&quot;: &quot;keyword2&quot;,
    ...
}

# Keywords dict for mode php::JAVASCRIPT_PHP
php_JAVASCRIPT_PHP_keywords_dict = {}

# Keywords dict for mode php::PHPDOC
php_PHPDOC_keywords_dict = {
    &quot;&#64;abstract&quot;: &quot;label&quot;,
    &quot;&#64;access&quot;: &quot;label&quot;,
    &quot;&#64;author&quot;: &quot;label&quot;,
    ...
    &quot;&#64;var&quot;: &quot;label&quot;,
    &quot;&#64;version&quot;: &quot;label&quot;,
}
</pre>
<p><tt class="docutils literal"><span class="pre">x.py</span></tt> also contains <strong>x.keywordsDictDict</strong>.
Keys are ruleset names, values are keywords dictionaries.
Here is <tt class="docutils literal"><span class="pre">keywordsDictDict</span></tt> for php.py:</p>
<pre class="literal-block">
# Dictionary of keywords dictionaries for php mode.
keywordsDictDict = {
    &quot;php_javascript&quot;: php_javascript_keywords_dict,
    &quot;php_javascript_php&quot;: php_javascript_php_keywords_dict,
    &quot;php_main&quot;: php_main_keywords_dict,
    &quot;php_php&quot;: php_php_keywords_dict,
    &quot;php_php_literal&quot;: php_php_literal_keywords_dict,
    &quot;php_phpdoc&quot;: php_phpdoc_keywords_dict,
    &quot;php_tags&quot;: php_tags_keywords_dict,
    &quot;php_tags_literal&quot;: php_tags_literal_keywords_dict,
}
</pre>
<p>The colorizer can get the keywords dictionary for a ruleset as follows:</p>
<pre class="literal-block">
keywordsDict = x.keywordsDictDict(rulesetName)
</pre>
<p><strong>Note</strong>:
The <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt> script creates 'friendly' names for keyword dictionaries <em>solely</em> as an aid for people reading the code.
Leo's colorer uses only the name <tt class="docutils literal"><span class="pre">x.keywordsDictDict</span></tt>;
Leo's colorer never uses the actual names of keywords dictionaries such as <tt class="docutils literal"><span class="pre">php_PHPDOC_keywords_dict</span></tt>.</p>
</div>
<div class="section" id="rules-rules-dictionaries-and-x-rulesdictdict">
<h3><a class="toc-backref" href="#id9">Rules, rules dictionaries and x.rulesDictDict</a></h3>
<p><tt class="docutils literal"><span class="pre">x.py</span></tt> contains one <strong>rule function</strong> for every rule in every ruleset (<tt class="docutils literal"><span class="pre">&lt;RULES&gt;</span></tt> element) in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.
These rules have names <tt class="docutils literal"><span class="pre">rule1</span></tt> through  <tt class="docutils literal"><span class="pre">ruleN</span></tt>,
where <tt class="docutils literal"><span class="pre">N</span></tt> is the total number of rules in all rulesets in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.</p>
<p>Each rules <em>function</em> merely calls a rules <em>method</em> in Leo's colorizer.
Which method gets called depends on the corresponding element in <cite>x.xml</cite>.
For example, the first rule in php.xml is:</p>
<pre class="literal-block">
&lt;SPAN TYPE=&quot;MARKUP&quot; DELEGATE=&quot;PHP&quot;&gt;
            &lt;BEGIN&gt;&amp;lt;?php&lt;/BEGIN&gt;
            &lt;END&gt;?&amp;gt;&lt;/END&gt;
    &lt;/SPAN&gt;
</pre>
<p>and the corresponding rule function is:</p>
<pre class="literal-block">
def php_rule0(colorer, s, i):
    return colorer.match_span(s, i, kind=&quot;markup&quot;, begin=&quot;&lt;?php&quot;, end=&quot;?&gt;&quot;,
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate=&quot;PHP&quot;,exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
</pre>
<p><tt class="docutils literal"><span class="pre">php_rule0</span></tt> calls <tt class="docutils literal"><span class="pre">colorer.match_span</span></tt> because the corresponding xml rule is a <tt class="docutils literal"><span class="pre">&lt;SPAN&gt;</span></tt> element.</p>
<p>For each ruleset, <tt class="docutils literal"><span class="pre">x.py</span></tt> also contains a <strong>rules dictionary</strong>,
a Python dictionary whose keys are characters and whose values are all lists
of rules functions that that can match the key.
For example:</p>
<pre class="literal-block">
# Rules dict for phpdoc ruleset.
rulesDict8 = {
    &quot;*&quot;: [rule64,],
    &quot;0&quot;: [rule70,],
    &quot;1&quot;: [rule70,],
    &quot;2&quot;: [rule70,],
    &quot;3&quot;: [rule70,],
    &quot;4&quot;: [rule70,],
    &quot;5&quot;: [rule70,],
    &quot;6&quot;: [rule70,],
    &quot;7&quot;: [rule70,],
    &quot;8&quot;: [rule70,],
    &quot;9&quot;: [rule70,],
    &quot;&lt;&quot;: [rule65,rule66,rule67,rule68,rule69,],
    &quot;&#64;&quot;: [rule70,],
    &quot;A&quot;: [rule70,],
    &quot;B&quot;: [rule70,],
    ...
    &quot;X&quot;: [rule70,],
    &quot;Y&quot;: [rule70,],
    &quot;Z&quot;: [rule70,],
    &quot;_&quot;: [rule70,],
    &quot;a&quot;: [rule70,],
    &quot;b&quot;: [rule70,],
   ...
    &quot;x&quot;: [rule70,],
    &quot;y&quot;: [rule70,],
    &quot;z&quot;: [rule70,],
    &quot;{&quot;: [rule63,],
}
</pre>
<p><strong>Note</strong>: The order of rules in each rules list is important;
it should be the same as rules element in <tt class="docutils literal"><span class="pre">x.xml</span></tt>.</p>
<p>Finally, <tt class="docutils literal"><span class="pre">x.py</span></tt> contains <strong>x.rulesDictDict</strong>.
Keys are ruleset names, values are rules dictionaries.
The colorer can get the rules list for character ch as follows:</p>
<pre class="literal-block">
self.rulesDict = x.rulesDictDict.get(rulesetName) # When a mode is inited.
...
rules = self.rulesDict.get(ch,[]) # In the main loop.
</pre>
<p>For example, here is the rules dictionary for php.py:</p>
<pre class="literal-block">
# x.rulesDictDict for php mode.
rulesDictDict = {
    &quot;php_javascript&quot;: rulesDict6,
    &quot;php_javascript_php&quot;: rulesDict7,
    &quot;php_main&quot;: rulesDict1,
    &quot;php_php&quot;: rulesDict4,
    &quot;php_php_literal&quot;: rulesDict5,
    &quot;php_phpdoc&quot;: rulesDict8,
    &quot;php_tags&quot;: rulesDict2,
    &quot;php_tags_literal&quot;: rulesDict3,
}
</pre>
<p><strong>Note</strong>:
The <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt> script creates 'friendly' names for rules lists <em>solely</em> as an aid for people reading the code.
Leo's colorer uses only the name <tt class="docutils literal"><span class="pre">x.rulesDictDict</span></tt>;
Leo's colorer never uses the actual names of rules lists such as <tt class="docutils literal"><span class="pre">rulesDict8</span></tt>,
and Leo's colorer never uses the actual names of rules functions such as <tt class="docutils literal"><span class="pre">rule64</span></tt>.</p>
</div>
<div class="section" id="x-importdict-and-imported-versus-delegated-rulesets">
<h3><a class="toc-backref" href="#id10">x.importDict and imported versus delegated rulesets</a></h3>
<p><tt class="docutils literal"><span class="pre">x.importDict</span></tt> is a Python dictionary.
Keys are ruleset names; values are a list of ruleset names.
For example:</p>
<pre class="literal-block">
# Import dict for php mode.
importDict = {
    &quot;php_javascript_php&quot;: [&quot;javascript::main&quot;],
}
</pre>
<p>For any ruleset <tt class="docutils literal"><span class="pre">R</span></tt> whose ruleset name is <tt class="docutils literal"><span class="pre">N</span></tt>, <tt class="docutils literal"><span class="pre">x.importDict.get(N)</span></tt>
is the list of rulesets names whose rulesets appear in
a <tt class="docutils literal"><span class="pre">DELEGATE</span></tt> attribute of an <tt class="docutils literal"><span class="pre">&lt;IMPORT&gt;</span></tt> rule element in <tt class="docutils literal"><span class="pre">R's</span></tt> ruleset.
Such <strong>imported</strong> ruleset are copied to the end of the <tt class="docutils literal"><span class="pre">R's</span></tt> rules list.
Leo's colorizer does this copying only once, when loading ruleset <tt class="docutils literal"><span class="pre">R</span></tt> for the first time.</p>
<p><strong>Note 1</strong>: Loading imported rulesets must be done at 'run time'.
It should definitely not be done by <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt> at 'compile time';
that would require running <tt class="docutils literal"><span class="pre">jEdit2Py</span></tt> on <em>all</em> .xml files whenever any such file changed.</p>
<p><strong>Note 2</strong>:  Multiple <tt class="docutils literal"><span class="pre">&lt;IMPORT&gt;</span></tt> rule elements in a single ruleset are allowed:
delegated rules are copied to the end of <tt class="docutils literal"><span class="pre">N's</span></tt> rules list in the order they appear in the ruleset.</p>
<p><strong>Note 3</strong>: The <tt class="docutils literal"><span class="pre">DELEGATE</span></tt> attribute of <tt class="docutils literal"><span class="pre">&lt;IMPORT&gt;</span></tt> elements is, in fact,
completely separate from the <tt class="docutils literal"><span class="pre">DELEGATE</span></tt> attributes of other rules as
discussed in <a class="reference" href="#arguments-to-rule-methods">Arguments to rule methods</a>.
Indeed, the <tt class="docutils literal"><span class="pre">DELEGATE</span></tt> attribute of <tt class="docutils literal"><span class="pre">&lt;IMPORT&gt;</span></tt> elements creates entries in
<tt class="docutils literal"><span class="pre">x.importDict</span></tt>, which in turn causes the colorizer to append the rules of the imported ruleset
to the end of the present rules list.
In contrast, the <tt class="docutils literal"><span class="pre">DELEGATE</span></tt> attributes of other rules sets the <tt class="docutils literal"><span class="pre">delegate</span></tt> argument to rules methods,
which in tern causes the colorizer to recursively color the matched text with the <strong>delegated</strong> ruleset.
In short:</p>
<ul class="simple">
<li>The rules of <strong>imported</strong> rulesets are appended to the end of another rules list;
the rules of <strong>delegated</strong> rulesets never are.</li>
<li><strong>Imported</strong> ruleset names appear as the values of items in <tt class="docutils literal"><span class="pre">x.importDict</span></tt>;
<strong>delegated</strong> ruleset names appear as <tt class="docutils literal"><span class="pre">delegate</span></tt> arguments to rule methods.</li>
</ul>
</div>
</div>
<div class="section" id="rule-methods">
<h2><a class="toc-backref" href="#id11">Rule methods</a></h2>
<p>This section describes each rules method in Leo's new colorizer.
Rules methods are called by rules functions in colorizer control file;
they correspond directly to rules elements in jEdit's language description files.
In fact, this documentation is a 'refactoring' of <a class="reference" href="http://www.jedit.org/42docs/users-guide/writing-modes-part.html">jEdit's documentation</a>.</p>
<p>All rule methods attempt to match a pattern at a particular spot in a string.
These methods all return True if the match succeeds.</p>
<div class="section" id="arguments-to-rule-methods">
<h3><a class="toc-backref" href="#id12">Arguments to rule methods</a></h3>
<p>All rule methods take three required arguments and zero or more optional keyword arguments.</p>
<p>Here is a list of the required arguments and their meaning:</p>
<ul class="simple">
<li><strong>self</strong>: An instance of Leo's colorizer.</li>
<li><strong>s</strong>: The string in which matches may be found.</li>
<li><strong>i</strong>: The location within the string at which the rule method looks for a match.</li>
</ul>
<p>Here is a list of all optional keyword arguments and their meaning:</p>
<ul class="simple">
<li><strong>at_line_start</strong>:
If <tt class="docutils literal"><span class="pre">True</span></tt>, a match will succeed only if <tt class="docutils literal"><span class="pre">i</span></tt> is at the start of a line.</li>
<li><strong>at_whitespace_end</strong>:
If <tt class="docutils literal"><span class="pre">True</span></tt>, the match will succeed only if <tt class="docutils literal"><span class="pre">i</span></tt> is at the first non-whitespace text in a line.</li>
<li><strong>at_word_start</strong>:
If <tt class="docutils literal"><span class="pre">True</span></tt>, the match will succeed only if <tt class="docutils literal"><span class="pre">i</span></tt> is at the beginning of a word.</li>
<li><strong>delegate</strong>:
If non-empty, the value of this argument is a <a class="reference" href="#ruleset-names">ruleset name</a>.
If the match succeeds, the matched text will be colored recursively with the indicate ruleset.</li>
<li><strong>exclude_match</strong>:
If <tt class="docutils literal"><span class="pre">True</span></tt>, the actual text that matched will not be colored.
The meaning of this argument varies slightly depending on whether one or two sequences are matched.
See the individual rule methods for details.</li>
<li><strong>kind</strong>: A string representing a class of tokens, i.e., one of:
<tt class="docutils literal"><span class="pre">'comment1'</span></tt>, <tt class="docutils literal"><span class="pre">'comment2'</span></tt>, <tt class="docutils literal"><span class="pre">'comment3'</span></tt>, <tt class="docutils literal"><span class="pre">'comment4'</span></tt>, <tt class="docutils literal"><span class="pre">'function'</span></tt>,
<tt class="docutils literal"><span class="pre">'keyword1'</span></tt>, <tt class="docutils literal"><span class="pre">'keyword2'</span></tt>, <tt class="docutils literal"><span class="pre">'keyword3'</span></tt>, <tt class="docutils literal"><span class="pre">'keyword4'</span></tt>,
<tt class="docutils literal"><span class="pre">'label'</span></tt>, <tt class="docutils literal"><span class="pre">'literal1'</span></tt>, <tt class="docutils literal"><span class="pre">'literal2'</span></tt>, <tt class="docutils literal"><span class="pre">'literal3'</span></tt>, <tt class="docutils literal"><span class="pre">'literal4'</span></tt>,
<tt class="docutils literal"><span class="pre">'markup'</span></tt>, <tt class="docutils literal"><span class="pre">'null'</span></tt> and <tt class="docutils literal"><span class="pre">'operator'</span></tt>.</li>
<li><strong>no_escape</strong>:
If <tt class="docutils literal"><span class="pre">True</span></tt>, the ruleset's escape character will have no effect before the <tt class="docutils literal"><span class="pre">end</span></tt> argument to <tt class="docutils literal"><span class="pre">match_span</span></tt>.
Otherwise, the presence of the escape character will cause that occurrence of the end string to be ignored.</li>
<li><strong>no_line_break</strong>:
If <tt class="docutils literal"><span class="pre">True</span></tt>, the match will not succeed across line breaks.</li>
<li><strong>no_word_break</strong>:
If <tt class="docutils literal"><span class="pre">True</span></tt>, the match will not cross word breaks.</li>
</ul>
<p>New in Leo 4.4.1 final: the regular expression rule matchers no longer get a <tt class="docutils literal"><span class="pre">hash_char</span></tt> argument
because such matchers are called only if the present search pattern starts with <tt class="docutils literal"><span class="pre">hash_char</span></tt>.</p>
</div>
<div class="section" id="match-eol-span">
<h3><a class="toc-backref" href="#id13">match_eol_span</a></h3>
<pre class="literal-block">
def match_eol_span (self,s,i,kind,begin,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    delegate = '',
    exclude_match = False):
</pre>
<p><tt class="docutils literal"><span class="pre">match_eol_span</span></tt> succeeds if <tt class="docutils literal"><span class="pre">s[i:].startswith(begin)</span></tt> and
the <tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt> and <tt class="docutils literal"><span class="pre">at_word_start</span></tt> conditions are all satisfied.</p>
<p>If successful, <tt class="docutils literal"><span class="pre">match_eol_span</span></tt> highlights from i to the end of the line
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>.
If the <tt class="docutils literal"><span class="pre">exclude_match</span></tt> argument is <tt class="docutils literal"><span class="pre">True</span></tt>, only the text before the matched text will be colored.
The <tt class="docutils literal"><span class="pre">delegate</span></tt> argument, if present, specifies the ruleset to color the colored text.</p>
</div>
<div class="section" id="match-eol-span-regexp">
<h3><a class="toc-backref" href="#id14">match_eol_span_regexp</a></h3>
<pre class="literal-block">
def match_eol_span_regexp (self,s,i,kind,regex,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    delegate = '',
    exclude_match = False):
</pre>
<p><tt class="docutils literal"><span class="pre">match_eol_span_exp</span></tt> succeeds if:</p>
<ol class="arabic simple">
<li>The regular expression <tt class="docutils literal"><span class="pre">regex</span></tt> matches at <tt class="docutils literal"><span class="pre">s[i:]</span></tt>, and</li>
<li>The <tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt> and <tt class="docutils literal"><span class="pre">at_word_start</span></tt> conditions are all satisfied.</li>
</ol>
<p>If successful, <tt class="docutils literal"><span class="pre">match_eol_span_regexp</span></tt>  highlights from i to the end of the line.
If the <tt class="docutils literal"><span class="pre">exclude_match</span></tt> argument is <tt class="docutils literal"><span class="pre">True</span></tt>, only the text before the matched text will be colored.
The <tt class="docutils literal"><span class="pre">delegate</span></tt> argument, if present, specifies the ruleset to color the colored text.</p>
</div>
<div class="section" id="match-keywords">
<h3><a class="toc-backref" href="#id15">match_keywords</a></h3>
<pre class="literal-block">
def match_keywords (self,s,i):
</pre>
<p><tt class="docutils literal"><span class="pre">match_keywords</span></tt> succeeds if <tt class="docutils literal"><span class="pre">s[i:]</span></tt> starts with an identifier contained in the mode's keywords dictionary <tt class="docutils literal"><span class="pre">d</span></tt>.</p>
<p>If successful, <tt class="docutils literal"><span class="pre">match_keywords</span></tt> colors the keyword.
<tt class="docutils literal"><span class="pre">match_keywords</span></tt> does not take a <tt class="docutils literal"><span class="pre">kind</span></tt> keyword argument.
Instead, the keyword is colored as specified by <tt class="docutils literal"><span class="pre">d.get(theKeyword)</span></tt>.</p>
</div>
<div class="section" id="match-mark-following">
<h3><a class="toc-backref" href="#id16">match_mark_following</a></h3>
<pre class="literal-block">
def match_mark_following (self,s,i,kind,pattern,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    exclude_match = False):
</pre>
<p>match_mark_following succeeds if s[i:].startswith(pattern), and
the <tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt> and <tt class="docutils literal"><span class="pre">at_word_start</span></tt> conditions are all satisfied.</p>
<p>If successful, <tt class="docutils literal"><span class="pre">match_mark_following</span></tt> colors from <tt class="docutils literal"><span class="pre">i</span></tt> to the start of the next token
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>.
If the <tt class="docutils literal"><span class="pre">exclude_match</span></tt> argument is <tt class="docutils literal"><span class="pre">True</span></tt>, only the text after the matched text will be colored.</p>
</div>
<div class="section" id="match-mark-previous">
<h3><a class="toc-backref" href="#id17">match_mark_previous</a></h3>
<pre class="literal-block">
def match_mark_previous (self,s,i,kind,pattern,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    exclude_match = False):
</pre>
<p><tt class="docutils literal"><span class="pre">match_mark_previous</span></tt> succeeds if s[i:].startswith(pattern),and
the <tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt> and <tt class="docutils literal"><span class="pre">at_word_start</span></tt> conditions are all satisfied.</p>
<p>If successful, <tt class="docutils literal"><span class="pre">match_mark_previous</span></tt> colors from the end of the previous token to <tt class="docutils literal"><span class="pre">i</span></tt>
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>.
If the <tt class="docutils literal"><span class="pre">exclude_match</span></tt> argument is <tt class="docutils literal"><span class="pre">True</span></tt>, only the text before the matched text will be colored.</p>
</div>
<div class="section" id="match-seq">
<h3><a class="toc-backref" href="#id18">match_seq</a></h3>
<pre class="literal-block">
def match_seq (self,s,i,kind,seq,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    delegate = ''):
</pre>
<p><tt class="docutils literal"><span class="pre">match_seq</span></tt> succeeds if <tt class="docutils literal"><span class="pre">s[i:].startswith(seq)</span></tt> and
the <tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt> and <tt class="docutils literal"><span class="pre">at_word_start</span></tt> conditions are all satisfied.</p>
<p>If successful, <tt class="docutils literal"><span class="pre">match_seq</span></tt> highlights from <tt class="docutils literal"><span class="pre">i</span></tt> to the end of the sequence
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>.
The <tt class="docutils literal"><span class="pre">delegate</span></tt> argument, if present, specifies the ruleset to color the colored text.</p>
</div>
<div class="section" id="match-seq-regexp">
<h3><a class="toc-backref" href="#id19">match_seq_regexp</a></h3>
<pre class="literal-block">
def match_seq_regexp (self,s,i,kind,regex,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    delegate = ''):
</pre>
<p><tt class="docutils literal"><span class="pre">match_seq</span></tt> succeeds if:</p>
<ol class="arabic simple">
<li>The regular expression <tt class="docutils literal"><span class="pre">regex</span></tt> matches at <tt class="docutils literal"><span class="pre">s[i:]</span></tt>, and</li>
<li>The <tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt> and <tt class="docutils literal"><span class="pre">at_word_start</span></tt> conditions are all satisfied.</li>
</ol>
<p>If successful, <tt class="docutils literal"><span class="pre">match_seq_regexp</span></tt> highlights from <tt class="docutils literal"><span class="pre">i</span></tt> to the end of the sequence
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>.
The <tt class="docutils literal"><span class="pre">delegate</span></tt> argument, if present, specifies the ruleset to color the colored text.</p>
</div>
<div class="section" id="match-span">
<h3><a class="toc-backref" href="#id20">match_span</a></h3>
<pre class="literal-block">
def match_span (self,s,i,kind,begin,end,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    exclude_match = False,
    delegate = ''
    no_escape = False,
    no_line_break = False,
    no_word_break = False):
</pre>
<p><tt class="docutils literal"><span class="pre">match_span</span></tt> succeeds if there is an index <tt class="docutils literal"><span class="pre">j</span> <span class="pre">&gt;</span> <span class="pre">i</span></tt> such that
<tt class="docutils literal"><span class="pre">s[:i].startswith(begin)</span></tt> and <tt class="docutils literal"><span class="pre">s[i:j].endswith(end)</span></tt> and the
<tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt>, <tt class="docutils literal"><span class="pre">at_word_start</span></tt>,
<tt class="docutils literal"><span class="pre">no_escape</span></tt>, <tt class="docutils literal"><span class="pre">no_line_break</span></tt> and <tt class="docutils literal"><span class="pre">no_word_break</span></tt> conditions are all satisfied.</p>
<p>If successful, <tt class="docutils literal"><span class="pre">match_span</span></tt> highlights from <tt class="docutils literal"><span class="pre">s[i:j</span></tt>
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>;
but if the <tt class="docutils literal"><span class="pre">exclude_match</span></tt> argument is <tt class="docutils literal"><span class="pre">True</span></tt>, the <tt class="docutils literal"><span class="pre">begin</span></tt> and <tt class="docutils literal"><span class="pre">end</span></tt> text are not colored.
The <tt class="docutils literal"><span class="pre">delegate</span></tt> argument, if present, specifies the ruleset to color the colored text.</p>
</div>
<div class="section" id="match-span-regexp">
<h3><a class="toc-backref" href="#id21">match_span_regexp</a></h3>
<pre class="literal-block">
def match_span (self,s,i,kind,regex,end,
    at_line_start = False,
    at_whitespace_end = False,
    at_word_start = False,
    exclude_match = False,
    delegate = ''
    no_escape = False,
    no_line_break = False,
    no_word_break = False):
</pre>
<p><tt class="docutils literal"><span class="pre">match_span_regex</span></tt> succeeds if:</p>
<ol class="arabic simple">
<li>The regular expression <tt class="docutils literal"><span class="pre">regex</span></tt> matches at <tt class="docutils literal"><span class="pre">s[i:]</span></tt>,</li>
<li>There is an index <tt class="docutils literal"><span class="pre">j</span> <span class="pre">&gt;</span> <span class="pre">i</span></tt> such that <tt class="docutils literal"><span class="pre">s[i:j].endswith(end)</span></tt>,</li>
<li>The <tt class="docutils literal"><span class="pre">at_line_start</span></tt>, <tt class="docutils literal"><span class="pre">at_whitespace_end</span></tt>, <tt class="docutils literal"><span class="pre">at_word_start</span></tt>,
<tt class="docutils literal"><span class="pre">no_escape</span></tt>, <tt class="docutils literal"><span class="pre">no_line_break</span></tt> and <tt class="docutils literal"><span class="pre">no_word_break</span></tt> conditions are all satisfied.</li>
</ol>
<p>If successful, <tt class="docutils literal"><span class="pre">match_span</span></tt> colors <tt class="docutils literal"><span class="pre">s[i:j]</span></tt>,
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>;
but if the <tt class="docutils literal"><span class="pre">exclude_match</span></tt> argument is <tt class="docutils literal"><span class="pre">True</span></tt>, the <tt class="docutils literal"><span class="pre">begin</span></tt> and <tt class="docutils literal"><span class="pre">end</span></tt> text are not colored.
The <tt class="docutils literal"><span class="pre">delegate</span></tt> argument, if present, specifies the ruleset to color the colored text.</p>
</div>
<div class="section" id="match-terminate">
<h3><a class="toc-backref" href="#id22">match_terminate</a></h3>
<pre class="literal-block">
def match_terminate (self,s,i,kind,at_char):
</pre>
<p><tt class="docutils literal"><span class="pre">match_terminate</span></tt> succeeds if <tt class="docutils literal"><span class="pre">s[i:]</span></tt> contains at least <tt class="docutils literal"><span class="pre">at_char</span></tt> more characters.</p>
<p>If successful, <tt class="docutils literal"><span class="pre">match_terminate</span></tt> colors <tt class="docutils literal"><span class="pre">at_char</span></tt> characters
with the color specified by <tt class="docutils literal"><span class="pre">kind</span></tt>.</p>
</div>
</div>
<div class="section" id="syntax-coloring-settings">
<h2><a class="toc-backref" href="#id23">Syntax coloring settings</a></h2>
<p>This section discusses only those settings that affect syntax coloring.
See <a class="reference" href="customizing.html">Chapter 8</a> for a general discussion of Leo's settings.</p>
<p>Both the old colorizer (in Leo's core) and the new colorizer (the threading_colorizer plugin)
now support &#64;font settings for colorizing options.
The settings for the old colorizer are:</p>
<pre class="literal-block">
comment_font, cweb_section_name_font, directive_font,
doc_part_font, keyword_font, leo_keyword_font, section_name_font,
section_name_brackets_font, string_font, undefined_section_name_font,
latexBackground_font, and latex_background_font.
</pre>
<p>The settings for the new colorizer are all of the above (except keyword_font) plus the following:</p>
<pre class="literal-block">
comment1, comment2_font, comment3_font, comment4_font, function_font,
keyword1_font, keyword2_font, keyword3_font, keyword4_font, label_font,
literal1_font, literal2_font, literal3_font, literal4_font, markup_font,
null_font, and operator_font.
</pre>
<p>To specify a font, say for keyword_font, to be used as the default font for <strong>all</strong> languages,
put the following in the body text of an &#64;font node in leoSettings.leo:</p>
<pre class="literal-block">
# keyword_font_family = None
keyword_font_size = 16
keyword_font_slant = roman
    # roman, italic
keyword_font_weight = bold
    # normal, bold
</pre>
<p>Comments are allowed and undefined settings are set to reasonable defaults.
At present, comments can not follow a setting: comments must start a line.</p>
<p>You can specify per-language settings by preceding the settings names by a prefix x.
Such settings affect only colorizing for language x (i.e., all the modes in modes/x.py when using the new colorizer).
For example, to specify a font for php (only), put the following in the body text of an &#64;font node in leoSettings.leo:</p>
<pre class="literal-block">
# php_keyword_font_family = None
php_keyword_font_size = 16
php_keyword_font_slant = roman
    # roman, italic
php_keyword_font_weight = bold
    # normal, bold
</pre>
</div>
<div class="section" id="the-threading-colorizer-plugin">
<h2><a class="toc-backref" href="#id24">The threading_colorizer plugin</a></h2>
<p>This section contains code-level notes for the threading colorizer. You do not
need to understand this material in order to use the threading colorizer.</p>
<p>The threading_colorizer plugin uses a separate <strong>helper thread</strong> to compute the
ranges of text that should be colored. <strong>The helper thread must not contain any
calls to Tk</strong>. Tk is not thread safe--calling Tk in the helper thread will cause
hard crashes in the Tk dll. However, the code in the helper thread is gui
independent. The <strong>main thread</strong> contains all of Leo's code except for a helper
thread. The main thread contains all calls to Tk, all entry points to the
colorizer, and idleHandler, an idle-time handler.</p>
<p>Only one helper thread is ever active at any one time. If a keystroke occurs
while the helper thread is active, the colorizer code in the main thread sets
the killFlag ivar and calls join to wait for the helper thread to terminate. The
helper thread will terminate promptly because it looks at killFlag each time
through its main loop. Using a separate helper thread allows the main thread to
continue working while the helper thread computes. This allows Tk (in the main
thread) to respond to events. This in turn allows the colorizer code in the main
thread to kill the helper thread if it is still working.</p>
<p>The helper thread runs to completion before the main thread
uses any of its results. Thus, no thread locking is needed, an important
simplification. Once the helper thread completes, the main thread computes the
tags to be sent to Tk, and actually sends those tags. When the user is typing
rapidly, the colorizer will ignore the results of all helper threads except the
last.</p>
<p>After the helper thread generates the list of all requested
tags, the main thread uses a kind of sort-merge algorithm to compare the
existing tags (obtained from Tk) with the requested tags. In many cases, the
lists are the same and colorizer issues <em>no</em> calls to Tk. This is a sensational
optimization.  It absolutely minimizes the load on Tk.</p>
<p>When the 'interruptible' argument to the colorizer is False,
no threading is used and the main thread completely colors the entire text. This
must be done when multiple body editors are present.</p>
<hr class="docutils" />
<p><a class="reference" href="rstplugin3.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="debuggers.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</body>
</html>
