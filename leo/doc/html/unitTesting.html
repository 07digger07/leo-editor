<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Chapter 20: Unit testing with Leo</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document">


<!-- rst3: filename: html\unitTesting.html -->
<!-- June, 2007 -->
<p><a class="reference" href="leoBridge.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="IPythonBridge.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section" id="chapter-20-unit-testing-with-leo">
<h1><a class="toc-backref" href="#id1">Chapter 20: Unit testing with Leo</a></h1>
<p>This chapter describes how you can execute Python unit test from within Leo outlines.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference" href="#chapter-20-unit-testing-with-leo" id="id1" name="id1">Chapter 20: Unit testing with Leo</a><ul>
<li><a class="reference" href="#overview" id="id2" name="id2">Overview</a></li>
<li><a class="reference" href="#using-test-nodes" id="id3" name="id3">Using &#64;test nodes</a></li>
<li><a class="reference" href="#using-suite-nodes" id="id4" name="id4">Using &#64;suite nodes</a></li>
<li><a class="reference" href="#how-the-unit-test-commands-work" id="id5" name="id5">How the unit test commands work</a></li>
</ul>
</li>
</ul>
</div>
<!-- Links -->
<!-- WARNING: image targets may not have upper case letters! -->
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id2">Overview</a></h2>
<p>Leo's <strong>unit test commands</strong> run the unit tests
created by &#64;test and &#64;suite nodes. run-unit-tests and run-unit-tests-locally
run all unit tests in the presently selected part of the Leo outline;
run-all-unit-tests and run-all-unit-tests-locally run all unit
tests in the entire Leo outline.</p>
<p><strong>You must be running Leo from a console to see the output the unit tests</strong>. Leo's
unit test commands run all the unit tests using the standard unittest text test
runner, and the output of the unit tests appears in the console.</p>
<p>test/unitTest.leo contains many examples of using &#64;test and &#64;suite nodes.</p>
</div>
<div class="section" id="using-test-nodes">
<h2><a class="toc-backref" href="#id3">Using &#64;test nodes</a></h2>
<p><strong>&#64;test nodes</strong> are nodes whose headlines start with &#64;test. The unit test
commands convert the body text of &#64;test nodes into a unit test automatically.
That is, Leo's unit test commands automatically create a unittest.TestCase
instances which run the body text of the &#64;test node. For example, let us
consider one of Leo's actual unit tests. The headline is:</p>
<pre class="literal-block">
&#64;test consistency of back/next links
</pre>
<p>The body text is:</p>
<pre class="literal-block">
if g.unitTesting:
    c,p = g.getTestVars() # Optional: prevents pychecker warnings.
    for p in c.allNodes_iter():
        back = p.back()
        next = p.next()
        if back: assert(back.getNext() == p)
        if next: assert(next.getBack() == p)
</pre>
<p>When either of Leo's unit test commands finds this &#64;test node the command will
run a unit test equivalent to the following:</p>
<pre class="literal-block">
import leo.core.leoGlobals as g

class aTestCase (unittest.TestCase):
    def shortDescription():
        return '&#64;test consistency of back/next links'
    def runTest():
        c,p = g.getTestVars()
        for p in c.allNodes_iter():
            back = p.back()
            next = p.next()
            if back: assert(back.getNext() == p)
            if next: assert(next.getBack() == p)
</pre>
<p>As you can see, using &#64;test nodes saves a lot of typing:</p>
<ul class="simple">
<li>You don't have to define a subclass of unittest.TestCase.</li>
<li>Within your unit test, the c, g and p variables are predefined, just like in Leo scripts.</li>
<li>The entire headline of the &#64;test node becomes the short description of the unit test.</li>
</ul>
<p><strong>Important note</strong>: notice that the first line of the body text is a <strong>guard line</strong>:</p>
<pre class="literal-block">
if g.unitTesting:
</pre>
<p>This guard line is needed because this particular &#64;test node is contained in the
file leoNodes.py. &#64;test nodes that appear outside of Python source files do not
need guard lines. The guard line prevents the unit testing code from being
executed when Python imports the leoNodes module; the g.unitTesting variable is
True only while running unit tests.</p>
<p>Note: Leo predefines the c, g, and p variables in &#64;test and &#64;suite nodes,
just like in other scripts.  Thus, the line:</p>
<pre class="literal-block">
c,p = g.getTestVars()
</pre>
<p>is not needed.  However, it prevents pychecker warnings that c and p are undefined.</p>
</div>
<div class="section" id="using-suite-nodes">
<h2><a class="toc-backref" href="#id4">Using &#64;suite nodes</a></h2>
<p><strong>&#64;suite nodes</strong> are nodes whose headlines start with &#64;suite. &#64;suite nodes allow
you to create and run custom subclasses of unittest.TestCase.</p>
<p>Leo's test commands assume that the body of an suite node is a script that
creates a suite of tests and places that suite in g.app.scriptDict['suite'].
Something like this:</p>
<pre class="literal-block">
if g.unitTesting:
    __pychecker__ = '--no-reimport' # Prevents pychecker complaint.
    import unittest
    c,p = g.getTestVars() # Optional.
    suite = unittest.makeSuite(unittest.TestCase)
    &lt;&lt; add one or more tests (instances of unittest.TestCase) to suite &gt;&gt;
    g.app.scriptDict['suite'] = suite
</pre>
<p><strong>Note</strong>: as in &#64;test nodes, the guard line, 'if unitTesting:', is needed only if the
&#64;suite node appears in a Python source file.</p>
<p>Leo's test commands first execute the script and then run suite in
g.app.scriptDict.get('suite') using the standard unittest text runner.</p>
<p>You can organize the script in an &#64;suite nodes just as usual using &#64;others,
section references, etc. For example:</p>
<pre class="literal-block">
if g.unitTesting:
    __pychecker__ = '--no-reimport'
    import unittest
    c,p = g.getTestVars() # Optional.
    # children define test1,test2..., subclasses of unittest.TestCase.
    &#64;others
    suite = unittest.makeSuite(unittest.TestCase)
    for test in (test1,test2,test3,test4):
        suite.addTest(test)
    g.app.scriptDict['suite'] = suite
</pre>
</div>
<div class="section" id="how-the-unit-test-commands-work">
<h2><a class="toc-backref" href="#id5">How the unit test commands work</a></h2>
<p>The run-all-unit-tests-locally and run-unit-tests-locally commands run unit
tests in the process that is running Leo. These commands <em>can</em> change the
outline containing the unit tests.</p>
<p>The run-all-unit-tests and run-unit-tests commands run all tests in a separate
process, so unit tests can never have any side effects. These commands never
changes the outline from which the tests were run. These commands do the
following:</p>
<ol class="arabic simple">
<li>Copy all &#64;test, &#64;suite and &#64;unit-tests nodes (including their descendants) to the
file test/dynamicUnitTest.leo.</li>
<li>Run test/leoDynamicTest.py in a separate process.<ul>
<li>leoDynamicTest.py opens dynamicUnitTest.leo with the leoBridge module.
Thus, all unit tests get run with the nullGui in effect.</li>
<li>After opening dynamicUnitTest.leo, leoDynamicTest.py runs all unit tests
by executing the leoTest.doTests function.</li>
<li>The leoTests.doTests function searches for &#64;test and &#64;suite nodes and
processes them generally as described above. The details are a bit
different from as described, but they usually don't matter. If you <em>really</em>
care, see the source code for leoTests.doTests.</li>
</ul>
</li>
</ol>
<hr class="docutils" />
<p><a class="reference" href="leoBridge.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="IPythonBridge.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</body>
</html>
