<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Chapter 23: Eliminating sentinel lines with &#64;shadow</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document">


<!-- rst3: filename: html\atShadow.html -->
<!-- July 31, 2008 -->
<p><a class="reference" href="vimBindings.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="appendices.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section" id="chapter-23-eliminating-sentinel-lines-with-shadow">
<h1><a class="toc-backref" href="#id1">Chapter 23: Eliminating sentinel lines with &#64;shadow</a></h1>
<p>This chapter describes an important new feature that debuted in Leo 4.5 b2: &#64;shadow trees.
These trees combine the benefits of &#64;auto, &#64;thin, &#64;file and &#64;nosent trees:</p>
<ul class="simple">
<li>The (public) files created by &#64;shadow trees contain no sentinels, but</li>
<li>Leo is able to update &#64;shadow trees in the Leo outline based on changes made
to public files outside of Leo.</li>
</ul>
<p>&#64;shadow trees are often useful for studying or editing source files from projects that don't use Leo.
In such situations, it is convenient to import the &#64;shadow tree from the (public) sources.
As discussed below, Leo can import &#64;shadow trees automatically,
using the same algorithms used by &#64;auto_ trees.</p>
<p>The crucial ideas and algorithms underlying &#64;shadow trees are the invention of Bernhard Mulder.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference" href="#chapter-23-eliminating-sentinel-lines-with-shadow" id="id1" name="id1">Chapter 23: Eliminating sentinel lines with &#64;shadow</a><ul>
<li><a class="reference" href="#overview" id="id2" name="id2">Overview</a></li>
<li><a class="reference" href="#importing-public-files" id="id3" name="id3">Importing public files</a></li>
<li><a class="reference" href="#what-the-update-algorithm-does" id="id4" name="id4">What the update algorithm does</a></li>
<li><a class="reference" href="#aha-boundary-cases-don-t-matter" id="id5" name="id5">Aha: boundary cases don't matter</a></li>
</ul>
</li>
</ul>
</div>
<!-- Links -->
<!-- WARNING: image targets may not have upper case letters! -->
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id2">Overview</a></h2>
<p>&#64;file and &#64;thin nodes create derived files containing comments called sentinels.
These sentinel lines allow Leo to recreate the outlines structure of &#64;file and &#64;thin trees.
Alas, many people and organizations find these added sentinel lines unacceptable.
&#64;nosent nodes create derived files without sentinels, but at a cost:
Leo can not update &#64;nosent trees when the corresponding derived file is changed outside of Leo.</p>
<p>&#64;shadow trees provide a way around this dilemma.
When Leo saves an &#64;shadow tree, it saves two copies of the tree:
a <strong>public</strong> file without sentinels, and a <strong>private</strong> file containing sentinels.
(Leo writes the private file to a subfolder of the folder containing the public file:
by default this folder is called .leo_shadow.)
Using Bernhard Mulder's brilliant <strong>update algorithm</strong>,
Leo is able to update &#64;shadow trees in the Leo outline based <em>solely</em> on changes to public files.</p>
<p>That's <em>almost</em> all there is to it.  The following sections discuss important details:</p>
<ul class="simple">
<li>How to import &#64;shadow trees initially.</li>
<li>How &#64;shadow works its magic.</li>
<li>Why the update algorithm is sound.</li>
</ul>
</div>
<div class="section" id="importing-public-files">
<h2><a class="toc-backref" href="#id3">Importing public files</a></h2>
<p>When reading an &#64;shadow tree,
Leo will import the tree from the public file if the private file does not exist.
The import is done exactly as is done for <a class="reference" href="directives.html#auto-trees">&#64;auto trees</a>.</p>
<p><strong>Important</strong>: just as for &#64;auto, the following exceptions apply:</p>
<ol class="arabic simple">
<li>Leo will never read (import) or write an &#64;shadow tree if
the root &#64;shadow tree is under the influence of an &#64;ignore directive.</li>
<li>Saving a .leo file does not save &#64;shadow nodes if:
a) they haven't been changed or,
b) they do not contain a <strong>significant</strong> amount of information. An &#64;shadow tree
contains a significant amount of information if it has  children or if the
root node contains more than 10 characters, excluding Leo directives.</li>
</ol>
</div>
<div class="section" id="what-the-update-algorithm-does">
<h2><a class="toc-backref" href="#id4">What the update algorithm does</a></h2>
<p>Suppose our &#64;shadow tree is &#64;shadow a.py.
When Leo writes this tree it creates a public file, a.py,
and a private file, .leo_shadow/xa.p (or just xa.p for short).
Public files might can committed to a source code control system such as cvs or bzr.
Private files should <em>not</em> be known to cvs or bzr.</p>
<p>Now suppose a.py has been changed outside of Leo, say as the result of a bzr merge.
The corresponding private file, xa.p, will <em>not</em> have been changed.
(Private files should <em>never</em> change outside of Leo.</p>
<p>When Leo reads the <em>new</em> (and possibly updated) public file it does the following:</p>
<ol class="arabic simple">
<li>Recreates the <em>old</em> public file by removing sentinels from the (unchanged!) <em>private</em> file.</li>
<li>Creates a set of diffs between the old and new <em>public</em> files.</li>
<li>Uses the diffs to create a new version of the <em>private</em> file.</li>
<li>Creates the &#64;shadow tree using  the new <em>private</em> file.</li>
</ol>
<p>Step 3 is the clever part.
To see all the details of how the algorithm works,
please study the x.propagate_changed_lines method in leoShadow.py.
This code is heavily commented.</p>
</div>
<div class="section" id="aha-boundary-cases-don-t-matter">
<h2><a class="toc-backref" href="#id5">Aha: boundary cases don't matter</a></h2>
<p>There is one boundary case that the update algorithm can not resolve.
If a line is inserted at the boundary between nodes,
the updated algorithm can not determine whether the line should be inserted
at the end of one node of the start of the next node.</p>
<p>Happily, the inability of the update algorithm to distinguish between
these two cases <strong>does not matter</strong>, for three very important reasons:</p>
<ol class="arabic simple">
<li>No matter which choice is made, the <em>public</em> file that results is the same.
<strong>The choice doesn't matter</strong>, so the update algorithm is completely and
absolutely safe.</li>
<li>Leo reports any nodes that were changed as the result of the update
algorithm. In essence, these reports are exactly the same as the reports Leo
makes when &#64;file or &#64;thin trees were changed as the result of changes made
externally to Leo. It is as easy for the user to review changes to &#64;shadow
trees as it is to review changes to &#64;thin or &#64;file trees.</li>
<li>Suppose the user moves a line from the end of one node to the beginning of
the following node, or vice versa. Once the user saves the file, the
<em>private</em> file records the location of the moved line. The next time the user
reads the &#64;shadow file, the line will <em>not</em> be subject to the update
algorithm because the line has not been changed externally. The location of
the line (on the boundary) will be completely determined and it will never
need to be moved across the boundary.</li>
</ol>
<p>Understanding these three reasons finally convinced me that &#64;shadow could be made to work reliably.</p>
<hr class="docutils" />
<p><a class="reference" href="vimBindings.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="appendices.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</body>
</html>
