<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" />
<title>Chapter 23: Eliminating sentinel lines with &#64;shadow</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document" id="chapter-23-eliminating-sentinel-lines-with-shadow">
<h1 class="title">Chapter 23: Eliminating sentinel lines with &#64;shadow</h1>

<!-- rst3: filename: html\atShadow.html -->
<p>This chapter describes an important new feature that debuted in Leo 4.5 b2: &#64;shadow trees.
These trees combine the benefits of &#64;auto, &#64;thin, &#64;file and &#64;nosent trees:</p>
<ul class="simple">
<li>The (public) files created by &#64;shadow trees contain no sentinels, but</li>
<li>Leo is able to update &#64;shadow trees in the Leo outline based on changes made
to public files outside of Leo.</li>
</ul>
<p>&#64;shadow trees are often useful for studying or editing source files from projects that don't use Leo.
In such situations, it is convenient to import the &#64;shadow tree from the (public) sources.
As discussed below, Leo can import &#64;shadow trees automatically,
using the same algorithms used by <a class="reference external" href="directives.html#auto">&#64;auto trees</a>.</p>
<p>The crucial ideas and algorithms underlying &#64;shadow trees are the invention of Bernhard Mulder.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id1">Overview</a></li>
<li><a class="reference internal" href="#creating-shadow-trees" id="id2">Creating &#64;shadow trees</a></li>
<li><a class="reference internal" href="#what-the-update-algorithm-does" id="id3">What the update algorithm does</a></li>
<li><a class="reference internal" href="#aha-boundary-cases-don-t-matter" id="id4">Aha: boundary cases don't matter</a></li>
</ul>
</div>
<!-- Links -->
<div class="section" id="overview">
<h1><a class="toc-backref" href="#id1">Overview</a></h1>
<p>Using &#64;shadow trees is the best choice when you want to have the full power of
Leo's outlines, but wish to retain the source files in their original format,
without Leo sentinels (markup) in comments in the source file.</p>
<p>Leo's &#64;file and &#64;thin trees create derived files containing comments called sentinels.
These sentinel lines allow Leo to recreate the outlines structure of &#64;file and &#64;thin trees.
Alas, many people and organizations find these added sentinel lines unacceptable.
&#64;nosent nodes create derived files without sentinels, but at a cost:
Leo can not update &#64;nosent trees when the corresponding derived file is changed outside of Leo.</p>
<p>&#64;shadow trees provide a way around this dilemma.
When Leo saves an &#64;shadow tree, it saves two copies of the tree:
a <strong>public</strong> file without sentinels, and a <strong>private</strong> file containing sentinels.
Using Bernhard Mulder's brilliant <strong>update algorithm</strong>,
Leo is able to update &#64;shadow trees in the Leo outline based <em>solely</em> on changes to public files.</p>
<p>Leo writes private files to a subfolder of the folder containing the public file:
by default this folder is called .leo_shadow.
You can change the name of this folder using the &#64;string shadow_subdir setting.
Note that private files need not be known to source code control systems such as bzr or cvs.</p>
<p>That's <em>almost</em> all there is to it.  The following sections discuss important details:</p>
<ul class="simple">
<li>How to create &#64;shadow trees.</li>
<li>How &#64;shadow works.</li>
<li>Why the update algorithm is sound.</li>
</ul>
</div>
<div class="section" id="creating-shadow-trees">
<h1><a class="toc-backref" href="#id2">Creating &#64;shadow trees</a></h1>
<p>The first step in creating an &#64;shadow tree is to create a node whose headline is
&#64;shadow <em>&lt;filename&gt;</em>. This is always safe, even if <em>&lt;filename&gt;</em> already
exists: Leo writes the &#64;shadow tree to the public and private files only if the
&#64;shadow tree contains a <strong>significant</strong> amount of information. An &#64;shadow tree
contains a significant amount of information if it has children or if the &#64;shadow node
node contains more than 10 characters, excluding Leo directives.</p>
<p>Thus, you can create an &#64;shadow node and save your outline, regardless of whether the original file exists.
The next time Leo reads the &#64;shadow node, Leo will <strong>create</strong> the entire &#64;shadow tree
using the same logic as for <a class="reference external" href="directives.html#auto">&#64;auto trees</a>.
You can cause Leo to read the &#64;shadow node in two ways:
1) by closing and reloading the Leo outline or
2) by selecting the &#64;shadow node and executing the <a class="reference external" href="File:Read/Write:Read">File:Read/Write:Read</a> &#64;shadow Node command.</p>
<p><strong>Important</strong>: Leo imports the private file into the &#64;shadow tree only if
a) the public file exists and b) the private file does <em>not</em> exist.
Thus, Leo will import code into each &#64;shadow node at most once.
After the first import, updates are made using the update algorithm.</p>
<p><strong>Note</strong>: just as for &#64;auto, Leo will never read (import) or write an &#64;shadow tree if
the &#64;shadow node is under the influence of an &#64;ignore directive.</p>
</div>
<div class="section" id="what-the-update-algorithm-does">
<h1><a class="toc-backref" href="#id3">What the update algorithm does</a></h1>
<p>Suppose our &#64;shadow tree is &#64;shadow a.py. When Leo writes this tree it creates a
public file, a.py, and a private file, .leo_shadow/xa.p (or just xa.p for
short). Public files might can committed to a source code control system such as
cvs or bzr. Private files should <em>not</em> be known to cvs or bzr.</p>
<p>Now suppose a.py has been changed outside of Leo, say as the result of a bzr
merge. The corresponding private file, xa.p, will <em>not</em> have been changed.
(Private files should <em>never</em> change outside of Leo.</p>
<p>When Leo reads the <em>new</em> (and possibly updated) public file it does the
following:</p>
<ol class="arabic simple">
<li>Recreates the <em>old</em> public file by removing sentinels from the (unchanged!) <em>private</em> file.</li>
<li>Creates a set of diffs between the old and new <em>public</em> files.</li>
<li>Uses the diffs to create a new version of the <em>private</em> file.</li>
<li>Creates the &#64;shadow tree using  the new <em>private</em> file.</li>
</ol>
<p><strong>Important</strong>: The update algorithm never changes sentinels. This means that the
update algorithm never inserts or deletes nodes. The user is responsible for
creating nodes to hold new lines, or for deleting nodes that become empty as the
result of deleting lines.</p>
<p>Step 3 is the clever part. To see all the details of how the algorithm works,
please study the x.propagate_changed_lines method in leoShadow.py. This code is
heavily commented.</p>
</div>
<div class="section" id="aha-boundary-cases-don-t-matter">
<h1><a class="toc-backref" href="#id4">Aha: boundary cases don't matter</a></h1>
<p>There is one boundary case that the update algorithm can not resolve.
If a line is inserted at the boundary between nodes,
the updated algorithm can not determine whether the line should be inserted
at the end of one node of the start of the next node.</p>
<p>Happily, the inability of the update algorithm to distinguish between
these two cases <strong>does not matter</strong>, for three very important reasons:</p>
<ol class="arabic simple">
<li>No matter which choice is made, the <em>public</em> file that results is the same.
<strong>The choice doesn't matter</strong>, so the update algorithm is completely and
absolutely safe.</li>
<li>Leo reports any nodes that were changed as the result of the update
algorithm. In essence, these reports are exactly the same as the reports Leo
makes when &#64;file or &#64;thin trees were changed as the result of changes made
externally to Leo. It is as easy for the user to review changes to &#64;shadow
trees as it is to review changes to &#64;thin or &#64;file trees.</li>
<li>Suppose the user moves a line from the end of one node to the beginning of
the following node, or vice versa. Once the user saves the file, the
<em>private</em> file records the location of the moved line. The next time the user
reads the &#64;shadow file, the line will <em>not</em> be subject to the update
algorithm because the line has not been changed externally. The location of
the line (on the boundary) will be completely determined and it will never
need to be moved across the boundary.</li>
</ol>
<p>Understanding these three reasons finally convinced me that &#64;shadow could be made to work reliably.</p>
</div>
</div>
</body>
</html>
