<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Chapter 13: Writing Plugins</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document">


<!-- rst3: filename: html\writingPlugins.html -->
<!-- June 8, 2006 -->
<p><a class="reference" href="plugins.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="rstplugin3.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section" id="chapter-13-writing-plugins">
<h1><a class="toc-backref" href="#id1">Chapter 13: Writing Plugins</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference" href="#chapter-13-writing-plugins" id="id1" name="id1">Chapter 13: Writing Plugins</a><ul>
<li><a class="reference" href="#overview" id="id2" name="id2">Overview</a></li>
<li><a class="reference" href="#support-for-unit-testing" id="id3" name="id3">Support for unit testing</a></li>
<li><a class="reference" href="#turning-script-buttons-into-plugins" id="id4" name="id4">Turning script buttons into plugins</a></li>
<li><a class="reference" href="#important-security-warnings" id="id5" name="id5">Important security warnings</a></li>
</ul>
</li>
</ul>
</div>
<!-- External links... -->
<!-- Relative links... -->
<!-- WARNING: image targets may not have upper case letters! -->
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id2">Overview</a></h2>
<p>A <strong>plugin</strong> is a Python file that appears in Leo's plugin directory. Plugins
modify how Leo works. With plugins you can give Leo new commands, modify how
existing commands work, or change any other aspect of Leo's look and feel.
<tt class="docutils literal"><span class="pre">leoPlugins.leo</span></tt> contains all of Leo's official plugins. Studying this file is
a good way to learn how to write plugins.</p>
<p>You <strong>enable</strong> plugins using &#64;enabled-plugins nodes in leoSettings.leo or
myLeoSettings.leo. For more details, see the &#64;enabled-plugins node in
leoSettings.leo. Leo imports all enabled plugins at startup time. Plugins become
<strong>active</strong> if importing the plugin was successful.</p>
<p>Writing plugins is quite similar to writing any other Leo script.  See
<a class="reference" href="scripting.html">Chapter 7: Scripting Leo with Python</a>. In particular:</p>
<ol class="arabic simple">
<li>Plugins can use any of Leo's source code simply by importing any module
defined in leoPy.leo.</li>
<li>Plugins can register event handlers just like any other Leo script. For full
details, see the section called <a class="reference" href="scripting.html#event-handlers">event handlers</a> in Leo's scripting chapter.</li>
</ol>
<p>The rest of this chapters discusses topics related specifically to plugins.</p>
</div>
<div class="section" id="support-for-unit-testing">
<h2><a class="toc-backref" href="#id3">Support for unit testing</a></h2>
<p>The plugins test suite creates a new convention: if a plugin has a function at
the outer (module) level called <tt class="docutils literal"><span class="pre">unitTest</span></tt>, Leo will call that function when
doing unit testing for plugins. So it would be good if writers of plugins would
create such a <tt class="docutils literal"><span class="pre">unitTest</span> <span class="pre">function</span></tt>. To indicate a failure the <tt class="docutils literal"><span class="pre">unitTest</span></tt> just
throws an exception. Leo's plugins test suite takes care of the rest.</p>
</div>
<div class="section" id="turning-script-buttons-into-plugins">
<h2><a class="toc-backref" href="#id4">Turning script buttons into plugins</a></h2>
<p>This section provides step-by-step instructions for turning a script button into a plugin.
The plugin will define a minibuffer command that does the same thing as pressing the button.</p>
<p>We shall start with a script button whose script is:</p>
<pre class="literal-block">
g.es_print('c: %s' % (c.fileName()),color='red')
g.es_print('p: %s' % (p.h),color='red')
</pre>
<p>Not very exciting, but it uses the predefined <tt class="docutils literal"><span class="pre">c</span></tt> and <tt class="docutils literal"><span class="pre">p</span></tt> constants.
Our plugin will create a minibuffer command called print-cp.</p>
<p>Here are the step-by-step instructions:</p>
<ol class="arabic simple">
<li>Open leoPlugins.leo and use the Copy Node command to copy the tree at:</li>
</ol>
<p>Plugins--&gt; Templates: these show recommended ways of defining plugins.--&gt;Template for Tk plugin with per-commander controller class</p>
<ol class="arabic" start="2">
<li><p class="first">Paste the tree somewhere else and rename it to &#64;thin print_cp.py.
I copied the tree to:</p>
<pre class="literal-block">
Plugins--&gt;Example code--&gt;&#64;thin print_cp.py
</pre>
</li>
<li><p class="first">Update the docstring, the __version__ constant and the &lt;&lt; imports &gt;&gt; section.
Note that unlike when using script buttons, you must have the following imports:</p>
<pre class="literal-block">
import leo.core.leoGlobals as g
import leo.core.leoPlugins as leoPlugins
</pre>
</li>
<li><p class="first">Because this plugin doesn't require any gui interface, we simplify the <tt class="docutils literal"><span class="pre">init</span></tt> function:</p>
<pre class="literal-block">
def init ():
    leoPlugins.registerHandler('after-create-leo-frame',onCreate)
    return True
</pre>
<p>The init function registers the onCreate hook and
returns True to indicate that it loaded properly.</p>
</li>
<li><p class="first">Leave the <tt class="docutils literal"><span class="pre">onCreate</span></tt> function unchanged.
It creates a per-commander instance of the pluginController class.
This class exists mainly to bind self.c properly to a commander.</p>
</li>
<li><p class="first">Change the constructor (__init__ method) of the pluginController class to this:</p>
<pre class="literal-block">
def __init__ (self,c):
    self.c = c
    c.k.registerCommand('print-cp',shortcut=None,func=self.print_cp)
    script = &quot;c.k.simulateCommand('print-cp')&quot;
    g.app.gui.makeScriptButton(c,script=script,buttonText='Print c &amp; p',bg='red')
</pre>
<p>This registers the print_cp <em>method</em> of the pluginController class as the print-cp minibuffer command,
and creates a script button with the following script:</p>
<pre class="literal-block">
c.k.simulateCommand('print-cp')
</pre>
</li>
<li><p class="first">Define the print_cp method as follows:</p>
<pre class="literal-block">
def print_cp (self,event=None):
    c = self.c ; p = c.p
    g.es_print('c: %s' % (c.fileName()),color='red')
    g.es_print('p: %s' % (p.h),color='red')
</pre>
<p>The print_cp method must have the event argument as shown because it implements a minibuffer command.
The print_cp method gets the proper commander from the <tt class="docutils literal"><span class="pre">c</span></tt> ivar (instance variable) and computes
the current position <tt class="docutils literal"><span class="pre">p</span></tt> as shown.</p>
</li>
<li><p class="first">Enable the print_cp plugin by putting the following in an &#64;enabled-plugins node:</p>
<pre class="literal-block">
print_cp.py
</pre>
</li>
<li><p class="first">Test the plugin by restarting Leo (I just start test.leo).
You can test the plugin by pressing the 'Print c&amp;p' button
or by typing &lt;Alt-x&gt; print-cp &lt;Return&gt;.</p>
</li>
</ol>
<p>That's all.  You can find the completed version of the print_cp plugin in leoPlugins.leo,
or leoPluginsRef.leo if you are using cvs.</p>
</div>
<div class="section" id="important-security-warnings">
<h2><a class="toc-backref" href="#id5">Important security warnings</a></h2>
<p>Naively using plugins can expose you and your .leo files to malicious attacks.
The fundamental principles are:</p>
<pre class="literal-block">
Scripts and plugins must never blindly execute code from untrusted sources.
</pre>
<p>and:</p>
<pre class="literal-block">
.leo files obtained from other people may potentially contain hostile code.
</pre>
<p>Stephen Schaefer summarizes the danger this way:</p>
<pre class="literal-block">
I foresee a future in which the majority of leo projects come from
marginally trusted sources...a world of leo documents sent hither and yon -
resumes, project proposals, textbooks, magazines, contracts - and as a race
of Pandora's, we cannot resist wanting to see &quot;What's in the box?&quot; And are
we going to fire up a text editor to make a detailed examination of the
ASCII XML? Never! We're going to double click on the cute leo file icon, and
leo will fire up in all its raging glory. Just like Word (and its macros) or
Excel (and its macros).
</pre>
<p>In other words:</p>
<pre class="literal-block">
When we share &quot;our&quot; .leo files we can NOT assume that
we know what is in our &quot;own&quot; documents!
</pre>
<p>Not all environments are untrustworthy. Code in a commercial cvs repository is
probably trustworthy: employees might be terminated for posting malicious code.
Still, the potential for abuse exists anywhere.</p>
<p>In Python it is very easy to write a script that will blindly execute other scripts:</p>
<pre class="literal-block">
# Warning: extremely dangerous code

# Execute the body text of all nodes that start with `&#64;script`.
def onLoadFile():
    for p in c.allNodes_iter():
        h = p.h.lower()
        if g.match_word(h,0,&quot;&#64;script&quot;):
            s = p.b
            if s and len(s) &gt; 0:
                try: # SECURITY BREACH: s may be malicious!
                    exec(s + '\n')
                except:
                    es_exception()
</pre>
<p>Executing this kind of code is typically an intolerable security risk.
<strong>Important</strong>: rexec provides <em>no protection whatever</em>.
Leo is a repository of source code, so any text operation is potentially malicious.
For example, consider the following script, which is valid in rexec mode:</p>
<pre class="literal-block">
badNode = c.p
for p in c.allNodes_iter():
    &lt;&lt; change `rexec` to `exec` in p's body &gt;&gt;
&lt;&lt; delete badNode &gt;&gt;
&lt;&lt; clear the undo stack &gt;&gt;
</pre>
<p>This script will introduce a security hole the .leo file without doing anything
prohibited by rexec, and without leaving any traces of the perpetrating script
behind. The damage will become permanent <em>outside</em> this script when the user
saves the .leo file.</p>
<hr class="docutils" />
<p><a class="reference" href="plugins.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="rstplugin3.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</body>
</html>
