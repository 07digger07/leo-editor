<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" />
<title>Chapter 19: Embedding Leo with the leoBridge module</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document" id="chapter-19-embedding-leo-with-the-leobridge-module">
<h1 class="title">Chapter 19: Embedding Leo with the leoBridge module</h1>

<!-- rst3: filename: html\leoBridge.html -->
<p>The leoBridge module allows complete access to all aspects of Leo from programs
running independently of Leo. Let us call such a program a <strong>host</strong> program.
Using the leoBridge module, host programs can get access to:</p>
<ul class="simple">
<li>all of Leo's source code,</li>
<li>the contents of any .leo file,</li>
<li>the commander of any .leo file.</li>
</ul>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#the-basics" id="id1">The basics</a></li>
<li><a class="reference internal" href="#running-leobridge-from-within-leo" id="id2">Running leoBridge from within Leo</a></li>
</ul>
</div>
<!-- Links -->
<div class="section" id="the-basics">
<h1><a class="toc-backref" href="#id1">The basics</a></h1>
<p>Host programs use the leoBridge module as follows:</p>
<pre class="literal-block">
import leo.core.leoBridge as leoBridge
controller = leoBridge.controller(gui='nullGui')
g = controller.globals()
c = controller.openLeoFile(path)
</pre>
<p>Let us look at these statements in detail.  The statements:</p>
<pre class="literal-block">
import leo.core.leoBridge as leoBridge
controller = leoBridge.controller(gui='nullGui')
</pre>
<p>import the leoBridge module and create a <strong>bridge controller</strong>. In effect, these
statements embed an invisible copy Leo into the host program. This embedded
copy of Leo uses a null gui, which simulates all aspects of Leo's normal gui
code without creating any screen objects.</p>
<p>The statement:</p>
<pre class="literal-block">
g = controller.globals()
</pre>
<p>provides access to Leo's leoGlobals module, and properly inits globals such as
g.app, g.app.gui, etc. <em>Host programs should not import leoGlobals directly</em>,
because doing so would not init the g.app object properly.</p>
<p>The statement:</p>
<pre class="literal-block">
c = controller.openLeoFile(path)
</pre>
<p>invisibly opens the .leo file given by the path argument. This call returns a
completely standard Leo commander, properly inited. This is the big payoff from
the leoBridge module: the host program gets instant access to c.config.getBool,
etc. Do you see how sweet this is?</p>
<p>For example, the following script runs leo/test/leoBridgeTest.py outside of Leo.
leoBridgeTest.py uses the leoBridge module to run all unit tests in leo/test/unitTest.leo:</p>
<pre class="literal-block">
import os,sys

path = g.os_path_abspath(
    g.os_path_join(
        g.app.loadDir,'..','test','leoBridgeTest.py'))

os.system('%s %s' % (sys.executable,path))
</pre>
<p>The file leo/test/test.leo contains the source code for leoBridgeTest.py.
Here it is, stripped of its sentinel lines:</p>
<pre class="literal-block">
'''A program to run unit tests with the leoBridge module.'''

import leo.core.leoBridge as leoBridge
import leo.core.leoTest as leoTest

def main ():
    tag = 'leoTestBridge'

    # Setting verbose=True prints messages that would be sent to the log pane.
    bridge = leoBridge.controller(gui='nullGui',verbose=False)
    if bridge.isOpen():
        g = bridge.globals()
        path = g.os_path_abspath(g.os_path_join(
            g.app.loadDir,'..','test','unitTest.leo'))
        c = bridge.openLeoFile(path)
        g.es('%s %s' % (tag,c.shortFileName()))
        runUnitTests(c,g)

    print tag,'done'

def runUnitTests (c,g):
    nodeName = 'All unit tests' # The tests to run.
    try:
        u = leoTest.testUtils(c)
        p = u.findNodeAnywhere(nodeName)
        if p:
            g.es('running unit tests in %s...' % nodeName)
            c.selectPosition(p)
            c.debugCommands.runUnitTests()
            g.es('unit tests complete')
        else:
            g.es('node not found:' % nodeName)
    except Exception:
        g.es('unexpected exception')
        g.es_exception()
        raise

if __name__ == '__main__':
    main()
</pre>
</div>
<div class="section" id="running-leobridge-from-within-leo">
<h1><a class="toc-backref" href="#id2">Running leoBridge from within Leo</a></h1>
<p>This following is adapted from Terry Brown's entry in Leo's wiki.</p>
<p>You can not just run leoBridge from Leo, because the leoBridge module is design
to run a separate copy of Leo. However, it is possible to run leoBridge from a
subprocess. That turned out to be more, um, interesting than anticipated, so I'm
recording the results here.</p>
<p>The idea is that script A running in Leo (i.e. in a regular GUI Leo session)
calls script B through subprocess.Popen(), script B uses LeoBridge to do
something (parse unloaded Leo files), and returns the result to script A.
Passing the result back via the clipboard seemed like a possibility, but
XWindows / tcl/tk clipboard madness being what it is, that didn't seem to work.</p>
<p>First trick, calling script B from script A:</p>
<pre class="literal-block">
import subprocess
p = subprocess.Popen(('python',
    path_to_script_B,
    parameter_for_script_B,),
    stdout=subprocess.PIPE,
    env={'PYTHONPATH': g.app.loadDir,'USER': g.app.leoID},
)
p.wait()
</pre>
<p>Setting PYTHONPATH in the environment seemed like the easiest way to let
script B find leoBridge.py (which it needs to import).  But by setting the
env parameter you limit script B's environment to be <strong>only</strong> PYTHONPATH,
which causes leoBridge to fail because, in unix at least, it depends
on USER in the environment.  So you need to pass that through too.</p>
<p>Now, because passing stuff back on the clipboard seems unreliable, at least
in XWindows, script B passes results back to script A via stdout (print),
but there's some Leo initialization chatter you want to avoid.  So put a
sentinel, 'START_CLIPBOARD', in the output, and collect it like this:</p>
<pre class="literal-block">
response = p.stdout.readlines()
while response and 'START_CLIPBOARD' not in response[0]:
    del response[0]
del response[0]  # delete the sentinel as well
response = ''.join(response)
</pre>
<p>This is the basic mechanism.  What I <em>actually</em> wanted to do was have script
B generate a branch of nodes and pass that back to script A for insertion in
the tree script A is running in.  That's relatively easy if you use:</p>
<pre class="literal-block">
c.setCurrentPosition(pos_of_branch_to_return)
c.copyOutline()
print '&lt;!-- START_CLIPBOARD --&gt;'
print g.app.gui.getTextFromClipboard()
print '&lt;!-- END_CLIPBOARD --&gt;'
</pre>
<p>at the end of script B, and back in script A, after you've rebuilt
<cite>response</cite> as shown above, just:</p>
<pre class="literal-block">
g.app.gui.replaceClipboardWith(response)
c.pasteOutline()
</pre>
</div>
</div>
</body>
</html>
