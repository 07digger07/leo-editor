<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Chapter 7: Scripting Leo with Python</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document">


<!-- rst3: filename: html\scripting.html -->
<p><a class="reference" href="design.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="customizing.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section" id="chapter-7-scripting-leo-with-python">
<h1><a class="toc-backref" href="#id1">Chapter 7: Scripting Leo with Python</a></h1>
<p>This chapter is a tutorial describing how to write Python scripts that get and
modify data contained in Leo outlines. Scripts use Leo's, <strong>vnode</strong>, <strong>tnode</strong>
and <strong>position</strong> classes to access data in Leo outlines. The combination of a
vnode v and its tnode v.t represents a node's data. Leo needs both vnodes and
tnodes to represent clones efficiently. Indeed, a tnode represents all data
shared by cloned nodes. When Leo clones a vnode v, Leo creates a new,
independent vnode v2 and sets v2.t == v.t. Thus, cloning a node does not
duplicate any information in descendant trees, but descendants of a cloned node
appear more than once on the screen (when all nodes are expanded). Positions
represent a node at a particular place on the screen. Equivalently, a position
indicates a particular place in a tree traversal. Iterators of the position
class define various kinds of tree traversals.</p>
<p>Leo's execute-script command predefines several symbols.  This makes it easy to
access the data in Leo outlines and the Leo's own source code. g is predefined
to the leoGlobals module. Scripts commonly use utility functions such as g.es,
g.trace, etc. The g.app object represents Leo itself. The instance vars (ivars)
of g.app are Leo's global variables and constants. The execute-script command
predefines c to be the commander (see below) of the Leo outline in which the
script is contained. Whenever possible, scripts should use the high-level
methods of the commander to insert, delete or clone nodes. Finally, the
execute-script commands predefines p to be the presently selected position.</p>
<p>This chapter describes only some of Leo's functions, classes and methods.
However, your scripts have complete access to all of Leo's source code, that
is, all the code in <tt class="docutils literal"><span class="pre">LeoPy.leo</span></tt>. You are not limited by what you see in this
chapter.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference" href="#chapter-7-scripting-leo-with-python" id="id1" name="id1">Chapter 7: Scripting Leo with Python</a><ul>
<li><a class="reference" href="#commonly-used-classes" id="id2" name="id2">Commonly used classes</a></li>
<li><a class="reference" href="#predefined-objects" id="id3" name="id3">Predefined objects</a></li>
<li><a class="reference" href="#g-es-writes-to-the-log-pane" id="id4" name="id4">g.es writes to the log pane</a></li>
<li><a class="reference" href="#app-windowlist-the-list-of-all-open-frames" id="id5" name="id5">app.windowList: the list of all open frames</a></li>
<li><a class="reference" href="#getting-and-setting-headline-and-body-text" id="id6" name="id6">Getting and setting headline and body text</a></li>
<li><a class="reference" href="#ensuring-that-positions-are-valid" id="id7" name="id7">Ensuring that positions are valid</a></li>
<li><a class="reference" href="#about-copying-positions" id="id8" name="id8">About copying positions</a></li>
<li><a class="reference" href="#traversing-outlines" id="id9" name="id9">Traversing outlines</a><ul>
<li><a class="reference" href="#c-allnodes-iter" id="id10" name="id10">c.allNodes_iter</a></li>
<li><a class="reference" href="#p-children-iter" id="id11" name="id11">p.children_iter</a></li>
<li><a class="reference" href="#p-parents-iter-p-self-and-parents-iter" id="id12" name="id12">p.parents_iter &amp; p.self_and_parents_iter</a></li>
<li><a class="reference" href="#p-siblings-iter-p-following-siblings-iter" id="id13" name="id13">p.siblings_iter &amp; p.following_siblings_iter</a></li>
<li><a class="reference" href="#p-subtree-iter-p-self-and-subtree-iter" id="id14" name="id14">p.subtree_iter &amp; p.self_and_subtree_iter</a></li>
<li><a class="reference" href="#testing-whether-a-position-is-valid" id="id15" name="id15">Testing whether a position is valid</a></li>
<li><a class="reference" href="#visiting-each-node-once" id="id16" name="id16">Visiting each node once</a></li>
</ul>
</li>
<li><a class="reference" href="#updating-the-screen" id="id17" name="id17">Updating the screen</a></li>
<li><a class="reference" href="#invoking-commands-from-scripts" id="id18" name="id18">Invoking commands from scripts</a></li>
<li><a class="reference" href="#getting-settings-from-settings-trees" id="id19" name="id19">Getting settings from &#64;settings trees</a></li>
<li><a class="reference" href="#getting-and-setting-preferences" id="id20" name="id20">Getting and setting preferences</a></li>
<li><a class="reference" href="#functions-for-finding-and-changing-text-from-scripts" id="id21" name="id21">Functions for finding and changing text from scripts</a></li>
<li><a class="reference" href="#functions-defined-in-leoglobals-py" id="id22" name="id22">Functions defined in leoGlobals.py</a></li>
<li><a class="reference" href="#event-handlers" id="id23" name="id23">Event handlers</a><ul>
<li><a class="reference" href="#enabling-idle-time-event-handlers" id="id24" name="id24">Enabling idle time event handlers</a></li>
</ul>
</li>
<li><a class="reference" href="#how-to-make-operations-undoable" id="id25" name="id25">How to make operations undoable</a></li>
<li><a class="reference" href="#redirecting-output-from-scripts" id="id26" name="id26">Redirecting output from scripts</a></li>
<li><a class="reference" href="#writing-to-different-log-tabs" id="id27" name="id27">Writing to different log tabs</a></li>
<li><a class="reference" href="#invoking-dialogs-using-the-g-app-gui-class" id="id28" name="id28">Invoking dialogs using the g.app.gui class</a></li>
<li><a class="reference" href="#inserting-and-deleting-icons" id="id29" name="id29">Inserting and deleting icons</a></li>
<li><a class="reference" href="#customizing-panes-with-different-widgets" id="id30" name="id30">Customizing panes with different widgets</a><ul>
<li><a class="reference" href="#official-ivars" id="id31" name="id31">Official ivars</a></li>
<li><a class="reference" href="#common-operations-on-tk-text-widgets" id="id32" name="id32">Common operations on Tk.Text widgets</a></li>
<li><a class="reference" href="#customizing-the-log-pane" id="id33" name="id33">Customizing the log pane</a></li>
<li><a class="reference" href="#customizing-the-body-pane" id="id34" name="id34">Customizing the body pane</a></li>
<li><a class="reference" href="#customizing-the-outine-pane" id="id35" name="id35">Customizing the outine pane</a></li>
</ul>
</li>
<li><a class="reference" href="#working-with-directives-and-paths" id="id36" name="id36">Working with directives and paths</a></li>
<li><a class="reference" href="#summary-of-the-vnode-and-position-classes" id="id37" name="id37">Summary of the vnode and position classes</a><ul>
<li><a class="reference" href="#iterators" id="id38" name="id38">Iterators</a></li>
<li><a class="reference" href="#getters" id="id39" name="id39">Getters</a></li>
<li><a class="reference" href="#setters" id="id40" name="id40">Setters</a></li>
</ul>
</li>
<li><a class="reference" href="#creating-script-buttons" id="id41" name="id41">Creating script buttons</a></li>
<li><a class="reference" href="#running-leo-in-batch-mode" id="id42" name="id42">Running Leo in batch mode</a></li>
<li><a class="reference" href="#getting-interactive-input-from-scripts" id="id43" name="id43">Getting interactive input from scripts</a></li>
</ul>
</li>
</ul>
</div>
<!-- Links used in this document. -->
<!-- WARNING: image targets may not have upper case letters! -->
<div class="section" id="commonly-used-classes">
<h2><a class="toc-backref" href="#id2">Commonly used classes</a></h2>
<p>Leo's source code is a collection of classes, along with utility functions in
<tt class="docutils literal"><span class="pre">leoGlobals.py</span></tt>. Here are the classes and objects that scripts will commonly use:</p>
<dl class="docutils">
<dt><strong>g.app</strong></dt>
<dd>The <strong>application object</strong> representing the entire Leo application.
The ivars (instance variables) of <tt class="docutils literal"><span class="pre">g.app</span></tt> represent Leo's global variables.</dd>
<dt><strong>g.app.gui</strong></dt>
<dd>This is a wrapper class that shields Leo's core code from gui-dependent details.
As described below, scripts can invoke dialogs using g.app.gui convenience methods.</dd>
<dt><strong>commander</strong></dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">Commands</span></tt> class in <tt class="docutils literal"><span class="pre">leoCommands.py</span></tt>.
Commanders represent commands for a <em>particular</em> window.
Each open Leo window has its own commander.
By convention, any variable named <tt class="docutils literal"><span class="pre">c</span></tt> is a commander.</dd>
<dt><strong>frame</strong></dt>
<dd>An instance of the base <tt class="docutils literal"><span class="pre">leoFrame</span></tt> class in <tt class="docutils literal"><span class="pre">leoFrame.py</span></tt>.
Frames contains all the internal data needed to manage a Leo window.
Given a commander <tt class="docutils literal"><span class="pre">c</span></tt>, <tt class="docutils literal"><span class="pre">c.frame</span></tt> is commanders frame.
Given a frame <tt class="docutils literal"><span class="pre">f</span></tt>, <tt class="docutils literal"><span class="pre">f.c</span></tt> is the frame's commander.</dd>
<dt><strong>position</strong></dt>
<dd><p class="first">An instance of the <tt class="docutils literal"><span class="pre">position</span></tt> class in <tt class="docutils literal"><span class="pre">leoNodes.py</span></tt>.
A position object represents the location of a particular node <em>in a tree traversal</em>.
By convention, variables named <tt class="docutils literal"><span class="pre">p</span></tt>, <tt class="docutils literal"><span class="pre">p1</span></tt> or <tt class="docutils literal"><span class="pre">p2</span></tt> are positions.
For any <tt class="docutils literal"><span class="pre">position</span></tt> <tt class="docutils literal"><span class="pre">p</span></tt>, <tt class="docutils literal"><span class="pre">p.v</span></tt> is the vnode at that position and
<tt class="docutils literal"><span class="pre">p.v.t</span></tt> is the tnode at that position.
<strong>Positions are the primary way to access data.</strong>
<tt class="docutils literal"><span class="pre">c.currentPosition</span></tt> and <tt class="docutils literal"><span class="pre">c.rootPosition</span></tt> return positions.
From those starting point, it is possible to access the data in any node.</p>
<p><strong>Important</strong>:
Positions can become <em>invalid</em> when the structure of the outline changes.
As discussed below, plugins and scripts that store positions for use at a later time should make sure the
position p is still valid by calling c.positionExists(p)</p>
<p class="last"><strong>Important</strong>:
For compatibility with old (pre-4.2) scripts, <tt class="docutils literal"><span class="pre">c.currentVnode</span></tt> and
<tt class="docutils literal"><span class="pre">c.rootVnode</span></tt> methods return <em>positions</em> not vnodes. Old scripts appear to
be using vnodes; in fact they are using positions. I call such scripts
<strong>confused</strong> scripts. Confused scripts work because the <tt class="docutils literal"><span class="pre">position</span></tt> class
is designed to make them work. We'll see how this works in detail in <a class="reference" href="#about-copying-positions">About
copying positions</a>.  This section is <strong>supremely important</strong>.</p>
</dd>
<dt><strong>vnode</strong></dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">vnode</span></tt> class in <tt class="docutils literal"><span class="pre">leoNodes.py</span></tt>.
vnodes represent one or more outline nodes on the screen.
Normally, scripts access vnodes via the <tt class="docutils literal"><span class="pre">position</span></tt> class described below.
By convention, variables named <tt class="docutils literal"><span class="pre">v</span></tt>, <tt class="docutils literal"><span class="pre">v1</span></tt> or <tt class="docutils literal"><span class="pre">v2</span></tt> refer to vnodes.
<strong>Important</strong>: scripts normally should use positions, not vnodes.</dd>
<dt><strong>tnode</strong></dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">tnode</span></tt> class in <tt class="docutils literal"><span class="pre">leoNodes.py</span></tt>.
tnodes represent the actual data in a vnode, including headline and body text.
For any vnode <tt class="docutils literal"><span class="pre">v</span></tt>, <tt class="docutils literal"><span class="pre">v.t</span></tt> is v's tnode.
Cloned vnodes v1 and v2 share the same tnode.  That is <tt class="docutils literal"><span class="pre">v1.t</span> <span class="pre">==</span> <span class="pre">v2</span></tt>.
<strong>Important</strong>: If <tt class="docutils literal"><span class="pre">p</span></tt> is a <tt class="docutils literal"><span class="pre">position</span></tt>, <tt class="docutils literal"><span class="pre">p.v.t</span></tt> is the tnode associated with that position.
Many positions may share the same tnode.</dd>
</dl>
<p><strong>Important</strong>: With the exception of the p.v and v.t ivars, scripts should be
careful to use only the methods of the position, vnode and tnode classes rather
than the internal ivars of these classes. Doing so will ensure that the script
is as simple as possible and that the script will continue to work regardless of
future changes to the internals of these classes.</p>
</div>
<div class="section" id="predefined-objects">
<h2><a class="toc-backref" href="#id3">Predefined objects</a></h2>
<p>Leo's <tt class="docutils literal"><span class="pre">Execute</span> <span class="pre">Script</span></tt> command predefines <tt class="docutils literal"><span class="pre">c</span></tt> to be the commander of the
outline containing the script. <tt class="docutils literal"><span class="pre">g</span></tt> and <tt class="docutils literal"><span class="pre">p</span></tt> are predefined as follows:</p>
<pre class="literal-block">
import leo.core.leoGlobals as g
p = c.currentPosition()
</pre>
<p>These definitions provide an easy way to access or change any
information in a Leo outline. For example, as discussed below, the following
script will print every headline in the Leo outline in which the script occurs.</p>
<blockquote>
<dl class="docutils">
<dt>for p in c.allNodes_iter():</dt>
<dd>print p.h</dd>
</dl>
</blockquote>
</div>
<div class="section" id="g-es-writes-to-the-log-pane">
<h2><a class="toc-backref" href="#id4">g.es writes to the log pane</a></h2>
<p>The g.es method prints its arguments to the Log tab of the log pane:</p>
<pre class="literal-block">
g.es(&quot;Hello world&quot;)
</pre>
<p>g.es converts non-string arguments using repr:</p>
<pre class="literal-block">
g.es(c)
</pre>
<p>g.es prints multiple arguments separated by commas:</p>
<pre class="literal-block">
g.es(&quot;Hello&quot;,&quot;world&quot;)
</pre>
<p>To create a tab named 'Test' or make it visible if it already exists:</p>
<pre class="literal-block">
c.frame.log.selectTab('Test')
</pre>
<p>When first created, a tab contains a Tk.Text widget.
To write to this widget, add the tabName argument to g.es:</p>
<pre class="literal-block">
g.es('Test',color='blue',tabName='Test')
</pre>
</div>
<div class="section" id="app-windowlist-the-list-of-all-open-frames">
<h2><a class="toc-backref" href="#id5">app.windowList: the list of all open frames</a></h2>
<p>The windowlist attribute of the application instance contains the list of the
frames of all open windows. The commands ivar of the frame gives the commander
for that frame:</p>
<pre class="literal-block">
windows = g.app.windowList # get the list of all open frames.
g.es(&quot;windows...&quot;)
for f in windows:
    c = f.c # c is f's commander
    g.es(f)
    g.es(f.shortFileName())
    g.es(c)
    g.es(c.rootPosition())
</pre>
</div>
<div class="section" id="getting-and-setting-headline-and-body-text">
<h2><a class="toc-backref" href="#id6">Getting and setting headline and body text</a></h2>
<p>Here is how to access the data of a Leo window:</p>
<pre class="literal-block">
g.es(p) # p is already defined.
p = c.currentPosition() # get the current position.
g.es(p)
g.es(&quot;head:&quot;,p.h)
g.es(&quot;body:&quot;,p.b)
</pre>
<p>Here is how to access data at position <tt class="docutils literal"><span class="pre">p</span></tt>.
<strong>Note</strong>: these methods work whether or not <tt class="docutils literal"><span class="pre">p</span></tt> is the current position:</p>
<pre class="literal-block">
body = p.b # get the body text.
head = p.h # get the headline text.
p.b = body # set body text of p to body.
p.h = head # set headline text of p to head.
</pre>
<p><strong>Note</strong>: Sometimes you want to use text that <em>looks</em> like a section reference, but isn't.
In such cases, you can use g.angleBrackets.  For example:</p>
<pre class="literal-block">
g.es(g.angleBrackets('abc'))
</pre>
</div>
<div class="section" id="ensuring-that-positions-are-valid">
<h2><a class="toc-backref" href="#id7">Ensuring that positions are valid</a></h2>
<p>Positions become invalid when the user deletes or moves the node to which the position refers.
Plugins and scripts that store positions for use at a later time should make sure the
position p is still valid by calling c.positionExists(p).</p>
<p>The following code will find a position p2 describing the same node as p:</p>
<pre class="literal-block">
if not c.positionExists(p):
    for p2 in c.allNodes_iter():
        if p2.v == p.v:
            # found
            c.selectPosition(p2)
    else:
        print 'position no longer exists'
</pre>
</div>
<div class="section" id="about-copying-positions">
<h2><a class="toc-backref" href="#id8">About copying positions</a></h2>
<p>Understanding this section is <em>essential</em>.
By default, all iterators discussed below use a <em>single</em> position to move
through the outline. This is a vital optimization; otherwise Leo would generate
one or more position object for each node of a tree traversal. However, it means
that it is <em>useless</em> to try to capture a position with:</p>
<pre class="literal-block">
p2 = p  # Wrong.  p2 will change after this assignment.
</pre>
<p>Instead, scripts and plugins should use <tt class="docutils literal"><span class="pre">p.copy()</span></tt> to 'capture' the value of a position:</p>
<pre class="literal-block">
p2 = p.copy()   # Correct: p2 will not change when p changes later.
</pre>
<p>Another way to solve this problem is to set <tt class="docutils literal"><span class="pre">copy=True</span></tt> when using an iterator:</p>
<pre class="literal-block">
d = {}
for p in c.allNodes_iter(copy=True):
    d[p.v.t] = p
</pre>
<p>This creates a dictionary of (unchanging!) positions, indexed via tnode.
<strong>Warning</strong> The positions in this dictionary will become invalid when the
outline's structure changes. It would be wrong to save a dictionary like this
for use between commands.</p>
<p>Setting the <tt class="docutils literal"><span class="pre">copy=True</span></tt> argument to iterators is an acceptable strategy for
infrequently used scripts; it is not acceptable for heavily used code in Leo's
core: it would create huge numbers of positions that would immediately be
candidates for garbage collection.</p>
<p><strong>Important</strong>: 'Confused' scripts work because the <tt class="docutils literal"><span class="pre">position</span></tt> methods that
simulate the old <tt class="docutils literal"><span class="pre">vnode</span></tt> methods automatically create copies of positions when
'moving' through an outline. Thus, confused scripts generate many more positions
than would the equivalent script that uses <tt class="docutils literal"><span class="pre">position</span></tt> iterators. Such is the
price of compatibility.</p>
</div>
<div class="section" id="traversing-outlines">
<h2><a class="toc-backref" href="#id9">Traversing outlines</a></h2>
<p>The proper way to traverse an outline is with an iterator.
Iterators are defined only by the position class;
vnodes can not have iterators because vnodes may appear in multiple places in an outline.</p>
<div class="section" id="c-allnodes-iter">
<h3><a class="toc-backref" href="#id10">c.allNodes_iter</a></h3>
<p>The <tt class="docutils literal"><span class="pre">c.allNodes_iter</span></tt> iterator returns a list of all positions in the outline.
This script makes a list of all the nodes in an outline:</p>
<pre class="literal-block">
nodes = [p for p in c.allNodes_iter()]
g.es(&quot;This outline contains %d nodes&quot; % len(nodes))
</pre>
<p>Here is one way to count the nodes of an outline:</p>
<pre class="literal-block">
count = 0
for p in c.allNodes_iter():
    count += 1
g.es(&quot;This outline contains %d nodes&quot; % count)
</pre>
<p>Here is a way to count the <em>distinct</em> vnodes of an outline:</p>
<pre class="literal-block">
positions = 0 ; tnodes = {}
for p in c.allNodes_iter():
    positions += 1
    if not tnodes.get(p.v.t):
        tnodes[p.v.t] = p.v.t
g.es(&quot;%8s positions&quot; % positions)
g.es(&quot;%8s vnodes&quot; % len(tnodes.keys()))
</pre>
</div>
<div class="section" id="p-children-iter">
<h3><a class="toc-backref" href="#id11">p.children_iter</a></h3>
<p>The <tt class="docutils literal"><span class="pre">p.children_iter</span></tt> iterator returns a list of all children of position <tt class="docutils literal"><span class="pre">p</span></tt>:</p>
<pre class="literal-block">
parent = p.parent()
g.es(&quot;children of %s&quot; % parent.h,color=&quot;purple&quot;)
for p in parent.children_iter():
    g.es(p.h)
</pre>
</div>
<div class="section" id="p-parents-iter-p-self-and-parents-iter">
<h3><a class="toc-backref" href="#id12">p.parents_iter &amp; p.self_and_parents_iter</a></h3>
<p>The <tt class="docutils literal"><span class="pre">p.parents_iter</span></tt> iterator returns a list of all parents of position <tt class="docutils literal"><span class="pre">p</span></tt>, excluding <tt class="docutils literal"><span class="pre">p</span></tt>:</p>
<pre class="literal-block">
current = p.copy()
g.es(&quot;exclusive of %s&quot; % current.h,color=&quot;purple&quot;)
for p in current.parents_iter():
    g.es(p.h)
</pre>
<p>The <tt class="docutils literal"><span class="pre">p.self_and_parents_iter</span></tt> iterator returns a list of all parents of position <tt class="docutils literal"><span class="pre">p</span></tt>, including <tt class="docutils literal"><span class="pre">p</span></tt>:</p>
<pre class="literal-block">
current = p.copy()
g.es(&quot;inclusive parents of %s&quot; % current.h,color=&quot;purple&quot;)
for p in current.self_and_parents_iter():
    g.es(p.h)
</pre>
</div>
<div class="section" id="p-siblings-iter-p-following-siblings-iter">
<h3><a class="toc-backref" href="#id13">p.siblings_iter &amp; p.following_siblings_iter</a></h3>
<p>The <tt class="docutils literal"><span class="pre">p.siblings_iter</span></tt> iterator returns a list of all siblings of position <tt class="docutils literal"><span class="pre">p</span></tt>:</p>
<pre class="literal-block">
current = c.currentPosition()
g.es(&quot;all siblings of %s&quot; % current.h,color=&quot;purple&quot;)
for p in current.self_and_siblings_iter():
    g.es(p.h)
</pre>
<p>The <tt class="docutils literal"><span class="pre">p.following_siblings_iter</span></tt> iterator returns a list of all siblings that follow position <tt class="docutils literal"><span class="pre">p</span></tt>:</p>
<pre class="literal-block">
current = c.currentPosition()
g.es(&quot;following siblings of %s&quot; % current.h,color=&quot;purple&quot;)
for p in current.following_siblings_iter():
    g.es(p.h)
</pre>
</div>
<div class="section" id="p-subtree-iter-p-self-and-subtree-iter">
<h3><a class="toc-backref" href="#id14">p.subtree_iter &amp; p.self_and_subtree_iter</a></h3>
<p>The p.subtree_iter iterator returns a list of all positions in <tt class="docutils literal"><span class="pre">p</span></tt>'s subtree, excluding <tt class="docutils literal"><span class="pre">p</span></tt>:</p>
<pre class="literal-block">
parent = p.parent()
g.es(&quot;exclusive subtree of %s&quot; % parent.h,color=&quot;purple&quot;)
for p in parent.subtree_iter():
    g.es(p.h)
</pre>
<p>The p.self_and_subtree_iter iterator returns a list of all positions in <tt class="docutils literal"><span class="pre">p</span></tt>'s subtree, including <tt class="docutils literal"><span class="pre">p</span></tt>:</p>
<pre class="literal-block">
parent = p.parent()
g.es(&quot;inclusive subtree of %s&quot; % parent.h,color=&quot;purple&quot;)
for p in parent.self_and_subtree_iter():
    g.es(p.h)
</pre>
</div>
<div class="section" id="testing-whether-a-position-is-valid">
<h3><a class="toc-backref" href="#id15">Testing whether a position is valid</a></h3>
<p>The tests:</p>
<pre class="literal-block">
if p:       # Right
if not p:   # Right
</pre>
<p>are the <strong>only</strong> correct ways to test whether a position <tt class="docutils literal"><span class="pre">p</span></tt> is valid.
In particular, the following <strong>will not work</strong>:</p>
<pre class="literal-block">
if p is None:       # Wrong
if p is not None:   # Wrong
</pre>
</div>
<div class="section" id="visiting-each-node-once">
<h3><a class="toc-backref" href="#id16">Visiting each node once</a></h3>
<p><strong>Joined nodes</strong> represent the same data. Joined nodes are vnodes v1 and v2 such
that v1.t == v2.t. Joined vnodes are distinct (v1 != v2) if the vnodes are
clones of each other. Joined nodes are in fact the same node (v1 == v2) if they
are descendants of clone nodes. In particular, we can say that p1.v is joined to
p2.v if p1.v.t == p2.v.t regardless of whether p1.v == p2.v. Thus a script can
process nodes exactly once if it ignores nodes joined to previously visited
nodes. A later section will provide an example of this common scripting pattern.</p>
<p>The following script illustrates a common idiom. It prints each headline of an
outline, eliminating duplications that would happen as the result of cloned
trees:</p>
<pre class="literal-block">
d = {}
for p in c.allNodes_iter():
    if p.v.t not in d:
        print p.h
        d[p.v.t] = p.v.t
</pre>
<p>As mentioned in the introduction, joined nodes share the same tnode. Thus, when
we visit a position p we print p.h only if p.v.t is not already in
the dictionary. We then enter p.v.t in the dictionary to prevent printing the
headlines of any future node joined to p.v.</p>
</div>
</div>
<div class="section" id="updating-the-screen">
<h2><a class="toc-backref" href="#id17">Updating the screen</a></h2>
<p>You can use <tt class="docutils literal"><span class="pre">c.redraw_now</span></tt> to redraw the entire screen immediately:</p>
<pre class="literal-block">
c.redraw_now()
</pre>
<p>However, it is usually better to <em>request</em> a redraw to be done later as follows:</p>
<pre class="literal-block">
c.redraw()
</pre>
<p>Leo actually redraws the screen in c.outerUpdate, provided that a redraw has been requested.
Leo will call c.outerUpdate at the end of each script, event handler and Leo command.</p>
<p>The old (deprecated) way to redraw the screen was with the following pattern:</p>
<pre class="literal-block">
c.beginUpdate()
try:
    &lt;&lt; whatever &gt;&gt;
finally:
    c.endUpdate()
</pre>
<p>This pattern is no longer useful: as of Leo 4.5 b2,
c.beginUpdate() does nothing,
c.endUpdate() is equivalent to c.redraw(),
and c.endUpdate(False) does nothing.</p>
</div>
<div class="section" id="invoking-commands-from-scripts">
<h2><a class="toc-backref" href="#id18">Invoking commands from scripts</a></h2>
<p>Leo dispatches commands using c.doCommand,
which calls the &quot;command1&quot; and &quot;command2&quot; hook routines for the given label.
c.doCommand catches all exceptions thrown by the command:</p>
<pre class="literal-block">
c.doCommand(c.markHeadline,label=&quot;markheadline&quot;)
</pre>
<p>You can also call command handlers directly so that hooks will not be called:</p>
<pre class="literal-block">
c.markHeadline()
</pre>
<p>You can invoke minibuffer commands by name.  For example:</p>
<pre class="literal-block">
c.executeMinibufferCommand('open-outline')
</pre>
<p>c.keyHandler.funcReturn contains the value returned from the command.
In many cases, as above, this value is simply 'break'.</p>
</div>
<div class="section" id="getting-settings-from-settings-trees">
<h2><a class="toc-backref" href="#id19">Getting settings from &#64;settings trees</a></h2>
<p>Any .leo file may contain an <tt class="docutils literal"><span class="pre">&#64;settings</span></tt> tree, so settings may be different for each commander.
Plugins and other scripts can get the value of settings as follows:</p>
<pre class="literal-block">
format_headlines = c.config.getBool('rst3_format_headlines')
g.es('format_headlines',format_headlines)
</pre>
<p>The <tt class="docutils literal"><span class="pre">c.config</span></tt> class has the following getters.
See the <tt class="docutils literal"><span class="pre">configSettings</span></tt> in <tt class="docutils literal"><span class="pre">leoCommands.py</span></tt> for details:</p>
<pre class="literal-block">
c.config.getBool(settingName,default=None)
c.config.getColor(settingName)
c.config.getDirectory(settingName)
c.config.getFloat(settingName)
c.config.getInt(settingName)
c.config.getLanguage(settingName)
c.config.getRatio(settingName)
c.config.getShortcut(settingName)
c.config.getString(settingName)
</pre>
<p>These methods return None if no setting exists.
The getBool 'default' argument to getBool gives the value to be returned if the setting does not exist.</p>
<p>You can set any <em>existing</em> item in an <tt class="docutils literal"><span class="pre">&#64;settings</span></tt> tree with <tt class="docutils literal"><span class="pre">c.config.set(p,setting,val)</span></tt>.
For example:</p>
<pre class="literal-block">
for val in (False,True):
    c.config.set(p,'rst3_format_headlines',val)
    format_headlines = c.config.getBool('rst3_format_headlines')
    g.es('format_headlines',format_headlines)
</pre>
<p><tt class="docutils literal"><span class="pre">c.config.set</span></tt> does not change the <tt class="docutils literal"><span class="pre">&#64;settings</span></tt> tree; it simply changes the values returned by the getters.</p>
</div>
<div class="section" id="getting-and-setting-preferences">
<h2><a class="toc-backref" href="#id20">Getting and setting preferences</a></h2>
<p>Each commander maintains its own preferences.
Your scripts can get the following ivars:</p>
<pre class="literal-block">
ivars = (
    'output_doc_flag',
    'page_width',
    'page_width',
    'tab_width',
    'tangle_batch_flag',
    'tangle_directory',
    'target_language',
    'untangle_batch_flag',
    'use_header_flag',
)

g.es(&quot;Prefs ivars...\n&quot;,color=&quot;purple&quot;)
for ivar in ivars:
    g.es(getattr(c,ivar))
</pre>
<p>If your script sets <tt class="docutils literal"><span class="pre">c.tab_width</span></tt> your script may call <tt class="docutils literal"><span class="pre">f.setTabWidth</span></tt> to redraw the screen:</p>
<pre class="literal-block">
c.tab_width = -4    # Change this and see what happens.
c.frame.setTabWidth(c.tab_width)
</pre>
</div>
<div class="section" id="functions-for-finding-and-changing-text-from-scripts">
<h2><a class="toc-backref" href="#id21">Functions for finding and changing text from scripts</a></h2>
<p>The file <tt class="docutils literal"><span class="pre">leoFindScript.py</span></tt> contains functions for finding and changing text
from within scripts.  See <tt class="docutils literal"><span class="pre">leoFindScript.py</span></tt> in <tt class="docutils literal"><span class="pre">LeoPy.leo</span></tt> for full details.</p>
<p>The findall function returns a list of tuples <tt class="docutils literal"><span class="pre">(v,pos)</span></tt> describing matches in
<tt class="docutils literal"><span class="pre">c</span></tt>'s entire tree:</p>
<pre class="literal-block">
import leo.scripts.leoFindScript as leoFindScript

pattern=&quot;import leo.core.leoGlobals as g&quot;
result = leoFindScript.findAll(c,pattern,bodyFlag=1)

g.es(&quot;%-3d instances of: '%s'...\n&quot; % (len(result),pattern),color=&quot;purple&quot;)

for v,pos in result:
    body = v.b
    g.es('\n%-4d %s' % (pos,v.h))
    g.es(g.get_line_after(body,pos))
</pre>
<p>The <tt class="docutils literal"><span class="pre">reFindall</span></tt> function returns a list of tuples <tt class="docutils literal"><span class="pre">(v,mo,pos)</span></tt>, where <tt class="docutils literal"><span class="pre">mo</span></tt>
is a <tt class="docutils literal"><span class="pre">MatchObject</span></tt>. The <tt class="docutils literal"><span class="pre">reFlags</span></tt> argument are flags to <tt class="docutils literal"><span class="pre">re.search</span></tt>:</p>
<pre class="literal-block">
import leo.scripts.leoFindScript as leoFindScript

pattern=&quot;from .* import&quot;
result = leoFindScript.reFindAll(c,pattern,bodyFlag=1,reFlags=None)

g.es(&quot;%-3d instances of: '%s'...\n&quot; % (len(result),pattern),color=&quot;purple&quot;)
for v,mo,pos in result:
    body = v.b
    g.es('\n%-4d %s' % (pos,v.h))
    g.es(g.get_line_after(body,pos))
</pre>
</div>
<div class="section" id="functions-defined-in-leoglobals-py">
<h2><a class="toc-backref" href="#id22">Functions defined in leoGlobals.py</a></h2>
<p><tt class="docutils literal"><span class="pre">leoGlobals.py</span></tt> contains many utility functions and constants.
The following script prints all the names defined in <tt class="docutils literal"><span class="pre">leoGlobals.py</span></tt>:</p>
<pre class="literal-block">
g.es(&quot;Names defined in leoGlobals.py&quot;,color=&quot;purple&quot;)
names = g.__dict__.keys()
names.sort()
for name in names:
    g.es(name)
</pre>
</div>
<div class="section" id="event-handlers">
<h2><a class="toc-backref" href="#id23">Event handlers</a></h2>
<p>Plugins and other scripts can register event handlers (also known as hooks) with code such as:</p>
<pre class="literal-block">
leoPlugins.registerHandler(&quot;after-create-leo-frame&quot;,onCreate)
leoPlugins.registerHandler(&quot;idle&quot;, on_idle)
leoPlugins.registerHandler((&quot;start2&quot;,&quot;open2&quot;,&quot;command2&quot;), create_open_with_menu)
</pre>
<p>As shown above, a plugin may register one or more event handlers with a single call to
<tt class="docutils literal"><span class="pre">leoPlugins.registerHandler</span></tt>. Once a hook is registered, Leo will call the
registered function' at the named <strong>hook time</strong>. For example:</p>
<pre class="literal-block">
leoPlugins.registerHandler(&quot;idle&quot;, on_idle)
</pre>
<p>causes Leo to call <tt class="docutils literal"><span class="pre">on_idle</span></tt> at &quot;idle&quot; time.</p>
<p>Event handlers must have the following signature:</p>
<pre class="literal-block">
def myHook (tag, keywords):
    whatever
</pre>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">tag</span></tt> is the name of the hook (a string).</li>
<li><tt class="docutils literal"><span class="pre">keywords</span></tt> is a Python dictionary containing additional information.
The following section describes the contents of the <tt class="docutils literal"><span class="pre">keywords</span></tt> dictionary in detail.</li>
</ul>
<p><strong>Important</strong>: hooks should get the proper commander this way:</p>
<pre class="literal-block">
c = keywords.get('c')
</pre>
<p>The following table tells about each event handler: its name, when it is called,
and the additional arguments passed to the hook in the <tt class="docutils literal"><span class="pre">keywords</span></tt> dictionary.
For some kind of hooks, Leo will skip its own normal processing if the hook
returns anything <em>other</em> than None. The table indicates such hooks with 'yes' in
the 'Stop?' column.</p>
<p><strong>Important</strong>: Ever since Leo 4.2, the <tt class="docutils literal"><span class="pre">v</span></tt>, <tt class="docutils literal"><span class="pre">old_v</span></tt> and <tt class="docutils literal"><span class="pre">new_v</span></tt> keys in
the keyword dictionary contain <em>positions</em>, not vnodes. These keys are
deprecated. The <tt class="docutils literal"><span class="pre">new_c</span></tt> key is also deprecated. Plugins should use the <tt class="docutils literal"><span class="pre">c</span></tt> key instead.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="7%" />
<col width="30%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Event name (tag argument)</th>
<th class="head">Stop?</th>
<th class="head">When called</th>
<th class="head">Keys in keywords dict</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>'after-auto'</td>
<td>&nbsp;</td>
<td>after each &#64;auto file loaded</td>
<td>c,p (note 14)</td>
</tr>
<tr><td>'after-create-leo-frame'</td>
<td>&nbsp;</td>
<td>after creating any frame</td>
<td>c</td>
</tr>
<tr><td>'after-redraw-outline'</td>
<td>&nbsp;</td>
<td>end of tree.redraw</td>
<td>c (note 6)</td>
</tr>
<tr><td>'before-create-leo-frame'</td>
<td>&nbsp;</td>
<td>before frame.finishCreate</td>
<td>c</td>
</tr>
<tr><td>'bodyclick1'</td>
<td>yes</td>
<td>before normal click in body</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'bodyclick2'</td>
<td>&nbsp;</td>
<td>after normal click in body</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'bodydclick1'</td>
<td>yes</td>
<td>before double click in body</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'bodydclick2'</td>
<td>&nbsp;</td>
<td>after  double click in body</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'bodykey1'</td>
<td>yes</td>
<td>before body keystrokes</td>
<td>c,p,v,ch,oldSel,undoType</td>
</tr>
<tr><td>'bodykey2'</td>
<td>&nbsp;</td>
<td>after  body keystrokes</td>
<td>c,p,v,ch,oldSel,undoType</td>
</tr>
<tr><td>'bodyrclick1'</td>
<td>yes</td>
<td>before right click in body</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'bodyrclick2'</td>
<td>&nbsp;</td>
<td>after  right click in body</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'boxclick1'</td>
<td>yes</td>
<td>before click in +- box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'boxclick2'</td>
<td>&nbsp;</td>
<td>after  click in +- box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'clear-all-marks'</td>
<td>&nbsp;</td>
<td>after clear-all-marks command</td>
<td>c,p,v</td>
</tr>
<tr><td>'clear-mark'</td>
<td>&nbsp;</td>
<td>when mark is set</td>
<td>c,p,v</td>
</tr>
<tr><td>'close-frame'</td>
<td>&nbsp;</td>
<td>in app.closeLeoWindow</td>
<td>c</td>
</tr>
<tr><td>'color-optional-markup'</td>
<td>yes *</td>
<td>(note 7)</td>
<td>colorer,p,v,s,i,j,colortag (note 7)</td>
</tr>
<tr><td>'command1'</td>
<td>yes</td>
<td>before each command</td>
<td>c,p,v,label (note 2)</td>
</tr>
<tr><td>'command2'</td>
<td>&nbsp;</td>
<td>after  each command</td>
<td>c,p,v,label (note 2)</td>
</tr>
<tr><td>'create-optional-menus'</td>
<td>&nbsp;</td>
<td>(note 8)</td>
<td>c (note 8)</td>
</tr>
<tr><td>'create-popup-menu-items'</td>
<td>&nbsp;</td>
<td>in tree.OnPopup</td>
<td>c,p,v,event (new)</td>
</tr>
<tr><td>'destroy-all-global-windows'</td>
<td>&nbsp;</td>
<td>(note 12)</td>
<td>None</td>
</tr>
<tr><td>'draw-outline-box'</td>
<td>yes</td>
<td>when drawing +- box</td>
<td>tree,p,v,x,y</td>
</tr>
<tr><td>'draw-outline-icon'</td>
<td>yes</td>
<td>when drawing icon</td>
<td>tree,p,v,x,y</td>
</tr>
<tr><td>'draw-outline-node'</td>
<td>yes</td>
<td>when drawing node</td>
<td>tree,p,v,x,y</td>
</tr>
<tr><td>'draw-outline-text-box'</td>
<td>yes</td>
<td>when drawing headline</td>
<td>tree,p,v,x,y</td>
</tr>
<tr><td>'drag1'</td>
<td>yes</td>
<td>before start of drag</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'drag2'</td>
<td>&nbsp;</td>
<td>after  start of drag</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'dragging1'</td>
<td>yes</td>
<td>before continuing to drag</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'dragging2'</td>
<td>&nbsp;</td>
<td>after  continuing to drag</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'enable-popup-menu-items'</td>
<td>&nbsp;</td>
<td>in tree.OnPopup</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'end1'</td>
<td>&nbsp;</td>
<td>start of app.quit()</td>
<td>None</td>
</tr>
<tr><td>'enddrag1'</td>
<td>yes</td>
<td>before end of drag</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'enddrag2'</td>
<td>&nbsp;</td>
<td>after  end of drag</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'headclick1'</td>
<td>yes</td>
<td>before normal click in headline</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'headclick2'</td>
<td>&nbsp;</td>
<td>after  normal click in headline</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'headrclick1'</td>
<td>yes</td>
<td>before right click in headline</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'headrclick2'</td>
<td>&nbsp;</td>
<td>after  right click in headline</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'headkey1'</td>
<td>yes</td>
<td>before headline keystrokes</td>
<td>c,p,v,ch (note 13)</td>
</tr>
<tr><td>'headkey2'</td>
<td>&nbsp;</td>
<td>after  headline keystrokes</td>
<td>c,p,v,ch (note 13)</td>
</tr>
<tr><td>'hoist-changed'</td>
<td>&nbsp;</td>
<td>whenever the hoist stack changes</td>
<td>c</td>
</tr>
<tr><td>'hypercclick1'</td>
<td>yes</td>
<td>before control click in hyperlink</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'hypercclick2'</td>
<td>&nbsp;</td>
<td>after  control click in hyperlink</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'hyperenter1'</td>
<td>yes</td>
<td>before entering hyperlink</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'hyperenter2'</td>
<td>&nbsp;</td>
<td>after  entering hyperlink</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'hyperleave1'</td>
<td>yes</td>
<td>before leaving  hyperlink</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'hyperleave2'</td>
<td>&nbsp;</td>
<td>after  leaving  hyperlink</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'iconclick1'</td>
<td>yes</td>
<td>before single click in icon box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'iconclick2'</td>
<td>&nbsp;</td>
<td>after  single click in icon box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'iconrclick1'</td>
<td>yes</td>
<td>before right click in icon box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'iconrclick2'</td>
<td>&nbsp;</td>
<td>after  right click in icon box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'icondclick1'</td>
<td>yes</td>
<td>before double click in icon box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'icondclick2'</td>
<td>&nbsp;</td>
<td>after  double click in icon box</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'idle'</td>
<td>&nbsp;</td>
<td>periodically (at idle time)</td>
<td>c</td>
</tr>
<tr><td>'init-color-markup'</td>
<td>&nbsp;</td>
<td>(note 7)</td>
<td>colorer,p,v (note 7)</td>
</tr>
<tr><td>'menu1'</td>
<td>yes</td>
<td>before creating menus</td>
<td>c,p,v (note 3)</td>
</tr>
<tr><td>'menu2'</td>
<td>yes</td>
<td>during creating menus</td>
<td>c,p,v (note 3)</td>
</tr>
<tr><td>'menu-update'</td>
<td>yes</td>
<td>before updating menus</td>
<td>c,p,v</td>
</tr>
<tr><td>'new'</td>
<td>&nbsp;</td>
<td>start of New command</td>
<td>c,old_c,new_c (note 9)</td>
</tr>
<tr><td>'open1'</td>
<td>yes</td>
<td>before opening any file</td>
<td>c,old_c,new_c,fileName (note 4)</td>
</tr>
<tr><td>'open2'</td>
<td>&nbsp;</td>
<td>after  opening any file</td>
<td>c,old_c,new_c,fileName (note 4)</td>
</tr>
<tr><td>'openwith1'</td>
<td>yes</td>
<td>before Open With command</td>
<td>c,p,v,openType,arg,ext</td>
</tr>
<tr><td>'openwith2'</td>
<td>&nbsp;</td>
<td>after  Open With command</td>
<td>c,p,v,openType,arg,ext</td>
</tr>
<tr><td>'recentfiles1'</td>
<td>yes</td>
<td>before Recent Files command</td>
<td>c,p,v,fileName,closeFlag</td>
</tr>
<tr><td>'recentfiles2'</td>
<td>&nbsp;</td>
<td>after  Recent Files command</td>
<td>c,p,v,fileName,closeFlag</td>
</tr>
<tr><td>'redraw-entire-outline'</td>
<td>yes</td>
<td>start of tree.redraw</td>
<td>c (note 6)</td>
</tr>
<tr><td>'save1'</td>
<td>yes</td>
<td>before any Save command</td>
<td>c,p,v,fileName</td>
</tr>
<tr><td>'save2'</td>
<td>&nbsp;</td>
<td>after  any Save command</td>
<td>c,p,v,fileName</td>
</tr>
<tr><td>'scan-directives'</td>
<td>&nbsp;</td>
<td>in scanDirectives</td>
<td>c,p,v,s,old_dict,dict,pluginsList (note 10)</td>
</tr>
<tr><td>'select1'</td>
<td>yes</td>
<td>before selecting a position</td>
<td>c,new_p,old_p,new_v,new_v</td>
</tr>
<tr><td>'select2'</td>
<td>&nbsp;</td>
<td>after  selecting a position</td>
<td>c,new_p,old_p,new_v,old_v</td>
</tr>
<tr><td>'select3'</td>
<td>&nbsp;</td>
<td>after  selecting a position</td>
<td>c,new_p,old_p,new_v,old_v</td>
</tr>
<tr><td>'set-mark'</td>
<td>&nbsp;</td>
<td>when a mark is set</td>
<td>c,p,v</td>
</tr>
<tr><td>'show-popup-menu'</td>
<td>&nbsp;</td>
<td>in tree.OnPopup</td>
<td>c,p,v,event</td>
</tr>
<tr><td>'start1'</td>
<td>&nbsp;</td>
<td>after app.finishCreate()</td>
<td>None</td>
</tr>
<tr><td>'start2'</td>
<td>&nbsp;</td>
<td>after opening first Leo window</td>
<td>c,p,v,fileName</td>
</tr>
<tr><td>'unselect1'</td>
<td>yes</td>
<td>before unselecting a vnode</td>
<td>c,new_p,old_p,new_v,old_v</td>
</tr>
<tr><td>'unselect2'</td>
<td>&nbsp;</td>
<td>after  unselecting a vnode</td>
<td>c,new_p,old_p,old_v,old_v</td>
</tr>
<tr><td>'&#64;url1'</td>
<td>yes</td>
<td>before double-click &#64;url node</td>
<td>c,p,v,url (note 5)</td>
</tr>
<tr><td>'&#64;url2'</td>
<td>&nbsp;</td>
<td>after  double-click &#64;url node</td>
<td>c,p,v(note 5)</td>
</tr>
</tbody>
</table>
<p><strong>Notes</strong>:</p>
<ol class="arabic">
<li><p class="first">'activate' and 'deactivate' hooks have been removed because they do not work as expected.</p>
</li>
<li><p class="first">'commands' hooks: The label entry in the keywords dict contains the
'canonicalized' form of the command, that is, the lowercase name of the command
with all non-alphabetic characters removed.
Commands hooks now set the label for undo and redo commands 'undo' and 'redo'
rather than 'cantundo' and 'cantredo'.</p>
</li>
<li><p class="first">'menu1' hook: Setting <tt class="docutils literal"><span class="pre">g.app.realMenuNameDict</span></tt> in this hook is an easy way of
translating menu names to other languages. <strong>Note</strong>: the 'new' names created this
way affect only the actual spelling of the menu items, they do <em>not</em> affect how
you specify shortcuts settings, nor do they affect the 'official'
command names passed in <tt class="docutils literal"><span class="pre">g.app.commandName</span></tt>. For example:</p>
<pre class="literal-block">
app().realMenuNameDict['Open...'] = 'Ouvre'.
</pre>
</li>
<li><p class="first">'open1' and 'open2' hooks: These are called with a keywords dict containing the following entries:</p>
<ul class="simple">
<li>c:          The commander of the newly opened window.</li>
<li>old_c:      The commander of the previously open window.</li>
<li>new_c:      (deprecated: use 'c' instead) The commander of the newly opened window.</li>
<li>fileName:   The name of the file being opened.</li>
</ul>
<p>You can use <tt class="docutils literal"><span class="pre">old_c.currentPosition()</span></tt> and <tt class="docutils literal"><span class="pre">c.currentPosition()</span></tt> to get the current
position in the old and new windows.
Leo calls the 'open1' and 'open2' hooks only if the file is not already open. Leo
will also call the 'open1' and 'open2' hooks if: a) a file is opened using the
Recent Files menu and b) the file is not already open.</p>
</li>
<li><p class="first">'&#64;url1' and '&#64;url2' hooks are only executed if the 'icondclick1' hook returns None.</p>
</li>
<li><p class="first">These hooks are useful for testing.</p>
</li>
<li><p class="first">These hooks allow plugins to parse and handle markup within doc parts,
comments and Python <tt class="docutils literal"><span class="pre">'''</span></tt> strings. Note that these hooks are <em>not</em> called in
Python <tt class="docutils literal"><span class="pre">'''</span></tt> strings. See the color_markup plugin for a complete example of how to
use these hooks.</p>
</li>
<li><p class="first">Leo calls the 'create-optional-menus' hook when creating menus. This hook need
only create new menus in the correct order, without worrying about the placement
of the menus in the menu bar. See the plugins_menu and scripts_menu plugins for
examples of how to use this hook.</p>
</li>
<li><p class="first">The <tt class="docutils literal"><span class="pre">New</span></tt> command calls 'new'.
The 'new_c' key is deprecated.  Use the 'c' key instead.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">g.scanDirectives</span></tt> calls 'scan-directives' hook.
<tt class="docutils literal"><span class="pre">g.scanDirectives</span></tt> returns a dictionary, say d.
d.get('pluginsList') is an a list of tuples <tt class="docutils literal"><span class="pre">(d,v,s,k)</span></tt> where:</p>
<ul class="simple">
<li>d is the spelling of the &#64;directive, without the leading &#64;.</li>
<li>v is the vnode containing the directive, _not_ the original vnode.</li>
<li>s[k:] is a string containing whatever follows the &#64;directive.
k has already been moved past any whitespace that follows the &#64;directive.</li>
</ul>
<p>See the add_directives plugins directive for a complete example of how to use
the 'scan-directives' hook.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">g.app.closeLeoWindow</span></tt> calls the 'close-frame' hook just before
removing the window from <tt class="docutils literal"><span class="pre">g.app.windowList</span></tt>. The hook code may remove the window
from <tt class="docutils literal"><span class="pre">app.windowList</span></tt> to prevent <tt class="docutils literal"><span class="pre">g.app.closeLeoWindow</span></tt> from destroying the window.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">g.app.destroyAllGlobalWindows</span></tt> calls the 'destroy-all-global-windows' hook.
This hook gives plugins the chance to clean up after themselves when Leo shuts down.</p>
</li>
<li><p class="first">New in Leo 4.4: Leo calls the 'headkey1' and 'headkey2' hooks only when the user completes
the editing of a headline, and ch is always 'r', regardless of platform.</p>
</li>
<li><p class="first">p is the new node (position) containing <a class="reference" href="mailto:'&#64;auto">'&#64;auto</a> filename.ext'</p>
</li>
</ol>
<div class="section" id="enabling-idle-time-event-handlers">
<h3><a class="toc-backref" href="#id24">Enabling idle time event handlers</a></h3>
<p>Two methods in leoGlobals.py allow scripts and plugins to enable and disable 'idle' events.
<strong>g.enableIdleTimeHook(idleTimeDelay=100)</strong> enables the &quot;idle&quot; hook.
Afterwards, Leo will call the &quot;idle&quot; hook approximately every idleTimeDelay milliseconds.
Leo will continue to call the &quot;idle&quot; hook periodically until disableIdleTimeHook is called.
<strong>g.disableIdleTimeHook()</strong> disables the &quot;idle&quot; hook.</p>
</div>
</div>
<div class="section" id="how-to-make-operations-undoable">
<h2><a class="toc-backref" href="#id25">How to make operations undoable</a></h2>
<p>Plugins and scripts should call <tt class="docutils literal"><span class="pre">u.beforeX</span></tt> and <tt class="docutils literal"><span class="pre">u.afterX</span></tt> methods ato
describe the operation that is being performed. <strong>Note</strong>: <tt class="docutils literal"><span class="pre">u</span></tt> is shorthand for
<tt class="docutils literal"><span class="pre">c.undoer</span></tt>. Most <tt class="docutils literal"><span class="pre">u.beforeX</span></tt> methods return <tt class="docutils literal"><span class="pre">undoData</span></tt> that the client
code merely passes to the corresponding <tt class="docutils literal"><span class="pre">u.afterX</span></tt> method. This data contains
the 'before' snapshot. The <tt class="docutils literal"><span class="pre">u.afterX</span></tt> methods then create a bead containing
both the 'before' and 'after' snapshots.</p>
<p><tt class="docutils literal"><span class="pre">u.beforeChangeGroup</span></tt> and <tt class="docutils literal"><span class="pre">u.afterChangeGroup</span></tt> allow multiple calls to
<tt class="docutils literal"><span class="pre">u.beforeX</span></tt> and <tt class="docutils literal"><span class="pre">u.afterX</span></tt> methods to be treated as a single undoable entry.
See the code for the <tt class="docutils literal"><span class="pre">Change</span> <span class="pre">All</span></tt>, <tt class="docutils literal"><span class="pre">Sort</span></tt>, <tt class="docutils literal"><span class="pre">Promote</span></tt> and <tt class="docutils literal"><span class="pre">Demote</span></tt>
commands for examples. The <tt class="docutils literal"><span class="pre">u.beforeChangeGroup</span></tt> and <tt class="docutils literal"><span class="pre">u.afterChangeGroup</span></tt>
methods substantially reduce the number of <tt class="docutils literal"><span class="pre">u.beforeX</span></tt> and <tt class="docutils literal"><span class="pre">afterX</span></tt> methods
needed.</p>
<p>Plugins and scripts may define their own <tt class="docutils literal"><span class="pre">u.beforeX</span></tt> and <tt class="docutils literal"><span class="pre">afterX</span></tt> methods. Indeed,
<tt class="docutils literal"><span class="pre">u.afterX</span></tt> merely needs to set the <tt class="docutils literal"><span class="pre">bunch.undoHelper</span></tt> and
<tt class="docutils literal"><span class="pre">bunch.redoHelper</span></tt> ivars to the methods used to undo and redo the operation.
See the code for the various <tt class="docutils literal"><span class="pre">u.beforeX</span></tt> and <tt class="docutils literal"><span class="pre">afterX</span></tt> methods for guidance.</p>
<p><tt class="docutils literal"><span class="pre">p.setDirty</span></tt> and <tt class="docutils literal"><span class="pre">p.setAllAncestorAtFileNodesDirty</span></tt> now return a
<tt class="docutils literal"><span class="pre">dirtyVnodeList</span></tt> that all vnodes that became dirty as the result of an
operation. More than one list may be generated: client code is responsible for
merging lists using the pattern <tt class="docutils literal"><span class="pre">dirtyVnodeList.extend(dirtyVnodeList2)</span></tt></p>
<p>See the section <tt class="docutils literal"><span class="pre">&lt;&lt;</span> <span class="pre">How</span> <span class="pre">Leo</span> <span class="pre">implements</span> <span class="pre">unlimited</span> <span class="pre">undo</span> <span class="pre">&gt;&gt;</span></tt> in <tt class="docutils literal"><span class="pre">leoUndo.py</span></tt>
for more details. In general, the best way to see how to implement undo is to
see how Leo's core calls the <tt class="docutils literal"><span class="pre">u.beforeX</span></tt> and <tt class="docutils literal"><span class="pre">afterX</span></tt> methods.</p>
</div>
<div class="section" id="redirecting-output-from-scripts">
<h2><a class="toc-backref" href="#id26">Redirecting output from scripts</a></h2>
<p><tt class="docutils literal"><span class="pre">leoGlobals.py</span></tt> defines 6 convenience methods for redirecting stdout and stderr:</p>
<pre class="literal-block">
g.redirectStderr() # Redirect stderr to the current log pane.
g.redirectStdout() # Redirect stdout to the current log pane.
g.restoreStderr()  # Restores stderr so it prints to the console window.
g.restoreStdout()  # Restores stdout so it prints to the console window.
g.stdErrIsRedirected() # Returns True if the stderr stream is redirected to the log pane.
g.stdOutIsRedirected() # Returns True if the stdout stream is redirected to the log pane.
</pre>
<p>Calls need <em>not</em> be paired. Redundant calls are ignored and the last call made
controls where output for each stream goes.
<strong>Note</strong>: you must execute Leo in a console window to see non-redirected output from the print statement:</p>
<pre class="literal-block">
print &quot;stdout isRedirected:&quot;, g.stdOutIsRedirected()
print &quot;stderr isRedirected:&quot;, g.stdErrIsRedirected()

g.redirectStderr()
print &quot;stdout isRedirected:&quot;, g.stdOutIsRedirected()
print &quot;stderr isRedirected:&quot;, g.stdErrIsRedirected()

g.redirectStdout()
print &quot;stdout isRedirected:&quot;, g.stdOutIsRedirected()
print &quot;stderr isRedirected:&quot;, g.stdErrIsRedirected()

g.restoreStderr()
print &quot;stdout isRedirected:&quot;, g.stdOutIsRedirected()
print &quot;stderr isRedirected:&quot;, g.stdErrIsRedirected()

g.restoreStdout()
print &quot;stdout isRedirected:&quot;, g.stdOutIsRedirected()
print &quot;stderr isRedirected:&quot;, g.stdErrIsRedirected()
</pre>
</div>
<div class="section" id="writing-to-different-log-tabs">
<h2><a class="toc-backref" href="#id27">Writing to different log tabs</a></h2>
<p>Plugins and scripts can create new tabs in the log panel.
The following creates a tab named test or make it visible if it already exists:</p>
<pre class="literal-block">
c.frame.log.selectTab('Test')
</pre>
<p>g.es, g.enl, g.ecnl, g.ecnls write to the log tab specified by the optional
tabName argument. The default for tabName is 'Log'. The put and putnl methods of
the tkinterLog class also take an optional tabName argument which defaults to
'Log'.</p>
<p>Plugins and scripts may call the
c.frame.canvas.createCanvas method to create a log tab containing a Tk.Canvas
widget. Here is an example script:</p>
<pre class="literal-block">
log = c.frame.log ; tag = 'my-canvas'
w = log.canvasDict.get(tag)
if not w:
    w = log.createCanvas(tag)
    w.configure(bg='yellow')
log.selectTab(tag)
</pre>
</div>
<div class="section" id="invoking-dialogs-using-the-g-app-gui-class">
<h2><a class="toc-backref" href="#id28">Invoking dialogs using the g.app.gui class</a></h2>
<p>Scripts can invoke various dialogs using the following methods of the g.app.gui object.
Here is a partial list. You can use typing completion(default bindings: Alt-1 and Alt-2) to get the full list!</p>
<pre class="literal-block">
g.app.gui.runAskOkCancelNumberDialog(c,title,message)
g.app.gui.runAskOkCancelStringDialog(c,title,message)
g.app.gui.runAskOkDialog(c,title,message=None,text='Ok')
g.app.gui.runAskYesNoCancelDialog(c,title,message=None,
    yesMessage='Yes',noMessage='No',defaultButton='Yes')
g.app.gui.runAskYesNoDialog(c,title,message=None)
</pre>
<p>The values returned are in ('ok','yes','no','cancel'), as indicated by the
method names. Some dialogs also return strings or numbers, again as indicated by
their names.</p>
<p>Scripts can run File Open and Save dialogs with these methods:</p>
<pre class="literal-block">
g.app.gui.runOpenFileDialog(title,filetypes,defaultextension,multiple=False)
g.app.gui.runSaveFileDialog(initialfile,title,filetypes,defaultextension)
</pre>
<p>For details about how to use these file dialogs, look for examples in Leo's own
source code. The runOpenFileDialog returns a list of file names.</p>
</div>
<div class="section" id="inserting-and-deleting-icons">
<h2><a class="toc-backref" href="#id29">Inserting and deleting icons</a></h2>
<p>You can add an icon to the presently selected node with
c.editCommands.insertIconFromFile(path). path is an absolute path or a path
relative to the leo/Icons folder. A relative path is recommended if you plan to
use the icons on machines with different directory structures.</p>
<p>For example:</p>
<pre class="literal-block">
path = 'rt_arrow_disabled.gif'
c.editCommands.insertIconFromFile(path)
</pre>
<p>Scripts can delete icons from the presently selected node using the following methods:</p>
<pre class="literal-block">
c.editCommands.deleteFirstIcon()
c.editCommands.deleteLastIcon()
c.editCommands.deleteNodeIcons()
</pre>
</div>
<div class="section" id="customizing-panes-with-different-widgets">
<h2><a class="toc-backref" href="#id30">Customizing panes with different widgets</a></h2>
<p>Tk/Tkinter make it easy to customize the contents of any of Leo's panes. The
following sections will discuss the 'official' ivars that make it possible for
scripts to access and alter the contents of panes. The next three sections will
give examples of modifying each pane.</p>
<div class="section" id="official-ivars">
<h3><a class="toc-backref" href="#id31">Official ivars</a></h3>
<p>The c.frame.log class contains the following 'official' ivars:</p>
<pre class="literal-block">
g.es('tabName',c.frame.log.tabName)     # The name of the active tab.
g.es('tabFrame',c.frame.log.tabFrame)   # The Tk.Frame containing all the other widgets of the tab.
g.es('logCtrl',c.frame.log.logCtrl)     # Tk.Text widget containing the log text.
</pre>
<p>The following ivars provide access to the body pane:</p>
<pre class="literal-block">
g.es('bodyFrame',c.frame.body.frame)    # The Tk.Frame widget containing the c.frame.body.bodyCtrl
</pre>
<p>The following ivars provide access to the outline pane:</p>
<pre class="literal-block">
g.es('canvas',c.frame.tree.canvas) # The Tk.Canvas on which Leo's outline is drawn.
</pre>
<p>Tkinter provides a way of determining the enclosing widget of any widget.
The body text is enclosed in a Pmw.PanedWidget to support multiple editors.</p>
<blockquote>
w = c.frame.body.bodyCtrl
parent = w.pack_info().get('in')
g.es('bodyCtrl.parent',parent) # The Tk.Frame containing the body text.</blockquote>
</div>
<div class="section" id="common-operations-on-tk-text-widgets">
<h3><a class="toc-backref" href="#id32">Common operations on Tk.Text widgets</a></h3>
<p>The following is no substitute for a full discussion of programming the Tk.Text
widget: it can do lots.</p>
<p>To clear the log:</p>
<pre class="literal-block">
w = c.frame.log.logCtrl
w.delete('1.0','end')
</pre>
<p>To write a line to the end of the log:</p>
<pre class="literal-block">
w = c.frame.log.logCtrl
w.insert('end','This is a test\n')
</pre>
<p>To get the entire contents of the log:</p>
<pre class="literal-block">
w = c.frame.log.logCtrl
g.es(w.get('1.0','end')+'\n')
</pre>
</div>
<div class="section" id="customizing-the-log-pane">
<h3><a class="toc-backref" href="#id33">Customizing the log pane</a></h3>
<p>The following line removes the initial text widget:</p>
<pre class="literal-block">
c.frame.log.logCtrl.pack_forget()
</pre>
<p>To make the text widget visible again:</p>
<pre class="literal-block">
c.frame.log.logCtrl.pack(side='top',expand=1,fill='both')
</pre>
<p>Plugins and scripts can pack any other widgets into c.frame.log.tabFrame.
For example, the following replaces the default text widget with a red box:</p>
<pre class="literal-block">
import Tkinter as Tk

# Remove the old contents.
w = c.frame.log.logCtrl
parent =  w.pack_info().get('in')
w.pack_forget()

# Replace with a red frame.
f = c.frame.newLog = Tk.Frame(parent,background='red')
f.pack(side='left',expand=1,fill='both')
</pre>
<p>And the following will restore the original pane:</p>
<pre class="literal-block">
c.frame.newLog.pack_forget()
w = c.frame.log.logCtrl
w.pack(side='left',expand=1,fill='both')
</pre>
</div>
<div class="section" id="customizing-the-body-pane">
<h3><a class="toc-backref" href="#id34">Customizing the body pane</a></h3>
<p>Warning: you will find it hard to execute scripts after removing the body pane,
so you had best make the following two scripts into script buttons before
executing them :-)</p>
<p>Plugins and scripts can pack any other widgets into c.frame.log.tabFrame.
For example, the following replaces the default text widget with a red box:</p>
<pre class="literal-block">
import Tkinter as Tk

w = c.frame.body.bodyCtrl
parent =  w.pack_info().get('in')
w.pack_forget()

f = c.frame.newBody = Tk.Frame(parent,background='red')
f.pack(side='left',expand=1,fill='both')
</pre>
<p>To restore:</p>
<pre class="literal-block">
c.frame.newBody.pack_forget()
w = c.frame.body.bodyCtrl
w.pack(side='left',expand=1,fill='both')
</pre>
</div>
<div class="section" id="customizing-the-outine-pane">
<h3><a class="toc-backref" href="#id35">Customizing the outine pane</a></h3>
<p>The following replaces the outline pane with a red frame:</p>
<pre class="literal-block">
import Tkinter as Tk

w = c.frame.tree.canvas
parent =  w.pack_info().get('in')
w.pack_forget()

f = c.frame.newTree = Tk.Frame(parent,background='red')
f.pack(side='left',expand=1,fill='both')
</pre>
<p>And this script restores the outline:</p>
<pre class="literal-block">
c.frame.newTree.pack_forget()
c.frame.tree.canvas.pack(side='left',expand=1,fill='both')
</pre>
</div>
</div>
<div class="section" id="working-with-directives-and-paths">
<h2><a class="toc-backref" href="#id36">Working with directives and paths</a></h2>
<p>Scripts can easily determine what directives are in effect at a particular
position in an outline. c.scanAllDirectives(p) returns a Python dictionary whose
keys are directive names and whose values are the value in effect at position p.
For example:</p>
<pre class="literal-block">
d = c.scanAllDirectives(p)
g.es(g.dictToString(d))
</pre>
<p>In particular, d.get('path') returns the full, absolute path created by all
&#64;path directives that are in ancestors of node p. If p is any kind of &#64;file node
(including &#64;thin, &#64;auto, &#64;nosent, &#64;shadow, etc.), the following script will
print the full path to the created file:</p>
<pre class="literal-block">
path = d.get('path')
name = p.anyAtFileNodeName()
if name:
   name = g.os_path_finalize_join(path,name)
   g.es(name)
</pre>
</div>
<div class="section" id="summary-of-the-vnode-and-position-classes">
<h2><a class="toc-backref" href="#id37">Summary of the vnode and position classes</a></h2>
<p>Most scripts will use methods of the position class to access information in an
outline. The following sections summarizes the most useful methods that your
scripts can use. For a complete list, see the <tt class="docutils literal"><span class="pre">leoNodes.py</span></tt> in of <tt class="docutils literal"><span class="pre">LeoPy.leo</span></tt>.</p>
<div class="section" id="iterators">
<h3><a class="toc-backref" href="#id38">Iterators</a></h3>
<p>Iterators exist only in the position class:</p>
<pre class="literal-block">
c.allNodes_iter            # returns all positions in c's outline.
p.children_iter            # returns all children of p.
p.parents_iter             # returns all parents of p.
p.self_and_parents_iter    # returns p and all parents of p.
p.siblings_iter            # returns all siblings of p, including p.
p.following_siblings_iter  # returns all siblings following p.
p.subtree_iter             # returns all positions in p's subtree, excluding p.
p.self_and_subtree_iter    # returns all positions in p's subtree, including p.
</pre>
</div>
<div class="section" id="getters">
<h3><a class="toc-backref" href="#id39">Getters</a></h3>
<p>Here are the most useful getters of the <tt class="docutils literal"><span class="pre">vnode</span></tt> and <tt class="docutils literal"><span class="pre">position</span></tt> classes.</p>
<p>Returning strings:</p>
<pre class="literal-block">
p.b # the body string of p.
p.h # the headline string of p. A property.
</pre>
<p>Returning ints:</p>
<pre class="literal-block">
p.childIndex()
p.numberOfChildren()
p.level()
</pre>
<p>Returning bools representing property bits:</p>
<pre class="literal-block">
p.hasChildren()
p.isAncestorOf(v2) # True if v2 is a child, grandchild, etc. of p.
p.isCloned()
p.isDirty()
p.isExpanded()
p.isMarked()
p.isVisible()
p.isVisited()
</pre>
</div>
<div class="section" id="setters">
<h3><a class="toc-backref" href="#id40">Setters</a></h3>
<p>Here are the most useful setters of the <tt class="docutils literal"><span class="pre">Commands</span></tt> and <tt class="docutils literal"><span class="pre">position</span></tt> classes.
The following setters of the <tt class="docutils literal"><span class="pre">position</span></tt> class regardless of whether
<tt class="docutils literal"><span class="pre">p</span></tt> is the presently selected position:</p>
<pre class="literal-block">
c.setBodyString(p,s)  # Sets the body text of p.
c.setHeadString(p,s)  # Sets the headline text of p.
</pre>
<p>Moving nodes:</p>
<pre class="literal-block">
p.moveAfter(v2)           # move p after v2
p.moveToNthChildOf(v2,n)  # move p to the n'th child of v2
p.moveToRoot(oldRoot)     # make p the root position.
                          # oldRoot must be the old root position if it exists.
</pre>
<p>The &quot;visited&quot; bit may be used by commands or scripts for any purpose.
Many commands use this bits for tree traversal, so these bits do not persist:</p>
<pre class="literal-block">
c.clearAllVisited() # Clears all visited bits in c's tree.
p.clearVisited()
p.setVisited()
</pre>
</div>
</div>
<div class="section" id="creating-script-buttons">
<h2><a class="toc-backref" href="#id41">Creating script buttons</a></h2>
<p>Creating a script button should be your first thought whenever you want to
automate any task. The scripting plugin, <tt class="docutils literal"><span class="pre">mod_scripting.py</span></tt>, puts two buttons
in the icon menu, a pink <tt class="docutils literal"><span class="pre">Run</span> <span class="pre">Script</span></tt> button and a yellow <tt class="docutils literal"><span class="pre">Script</span> <span class="pre">Button</span></tt>
button. The <tt class="docutils literal"><span class="pre">Run</span> <span class="pre">Script</span></tt> button does the same thing as the <tt class="docutils literal"><span class="pre">Execute</span> <span class="pre">Script</span></tt>
command. The <tt class="docutils literal"><span class="pre">Script</span> <span class="pre">Button</span></tt> button is the interesting one. It creates a
button, confusingly called a <strong>script button</strong> in the icon area. A script button
executes a script when you push it.</p>
<p>Suppose node N is selected. When you press the <tt class="docutils literal"><span class="pre">Script</span> <span class="pre">Button</span></tt> button a new
(pink) script button is created. The name of the new button is N's headline
text. The script associated with the new button is N's body text. Now whenever
you press the new button, N's script is executed on the <strong>presently</strong> selected
node. Script buttons are extraordinarily useful. In effect, each script button
defines an instant command! For example, sometimes my fingers get tired of
saving a file. I simply put <tt class="docutils literal"><span class="pre">Save</span></tt> in a node's headline and <tt class="docutils literal"><span class="pre">c.save()</span></tt> in
the body text. I hit the <tt class="docutils literal"><span class="pre">Script</span> <span class="pre">Button</span></tt> button and I get a new button called
<tt class="docutils literal"><span class="pre">Save</span></tt> that will save the outline when I press it.</p>
<p>Here's a more interesting example. The following script searches the present node
and its ancestors looking for an <tt class="docutils literal"><span class="pre">&#64;rst</span></tt> node. When such a node is found the
script calls the <a class="reference" href="rstplugin3.html">rst3 plugin</a> to format it. I don't have to select the actual
<tt class="docutils literal"><span class="pre">&#64;rst</span></tt> node; I can select any of its children:</p>
<pre class="literal-block">
import leo.core.leoPlugins as leoPlugins
rst3 = leoPlugins.getPluginModule('rst3')
if rst3: # already loaded.
    controller = rst3.controllers.get(c)
    if controller:
        for p in p.self_and_parents_iter():
            if p.h.startswith('&#64;rst '):
                controller.processTree(p)
                break
else: # Just load the plugin.
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True
</pre>
<p><strong>Notes</strong>:</p>
<ul class="simple">
<li>The scripting plugin pre-defines the <tt class="docutils literal"><span class="pre">c</span></tt>, <tt class="docutils literal"><span class="pre">g</span></tt> and <tt class="docutils literal"><span class="pre">p</span></tt> symbols
just as the <tt class="docutils literal"><span class="pre">Execute</span> <span class="pre">Script</span></tt> command does.</li>
<li>By default a script button executes the <strong>present</strong> body text of the node that original created the script button.
This is very handy: you can modify a script button's script at any time without having to recreate the script button.</li>
<li>You can delete any script button by right-clicking on it.</li>
<li>On startup, the scripting plugin scans the entire .leo file and creates a script button
for every node whose headline starts with <tt class="docutils literal"><span class="pre">&#64;button</span> <span class="pre">scriptName</span></tt>.
<strong>Warning</strong>: this is indeed a security risk of the kind discussed later.
This feature can be disabled by setting <tt class="docutils literal"><span class="pre">atButtonNodes</span> <span class="pre">=</span> <span class="pre">True</span></tt> at the start of <tt class="docutils literal"><span class="pre">mod_scripting.py</span></tt>.</li>
</ul>
</div>
<div class="section" id="running-leo-in-batch-mode">
<h2><a class="toc-backref" href="#id42">Running Leo in batch mode</a></h2>
<p>On startup, Leo looks for two arguments of the form:</p>
<pre class="literal-block">
--script scriptFile
</pre>
<p>If found, Leo enters batch mode. In batch mode Leo does not show any windows.
Leo assumes the scriptFile contains a Python script and executes the contents of
that file using Leo's <tt class="docutils literal"><span class="pre">Execute</span> <span class="pre">Script</span></tt> command. By default, Leo sends all
output to the console window. Scripts in the scriptFile may disable or enable
this output by calling <tt class="docutils literal"><span class="pre">app.log.disable</span></tt> or <tt class="docutils literal"><span class="pre">app.log.enable</span></tt></p>
<p>Scripts in the scriptFile may execute any of Leo's commands except the <tt class="docutils literal"><span class="pre">Edit</span> <span class="pre">Body</span></tt>
and <tt class="docutils literal"><span class="pre">Edit</span> <span class="pre">Headline</span></tt> commands. Those commands require interaction with the user.
For example, the following batch script reads a Leo file and prints all the
headlines in that file:</p>
<pre class="literal-block">
path = r&quot;c:\prog\leoCVS\leo\test\test.leo&quot;

g.app.log.disable() # disable reading messages while opening the file
flag,newFrame = g.openWithFileName(path,None)
g.app.log.enable() # re-enable the log.

for p in newFrame.c.allNodes_iter():
    g.es(g.toEncodedString(p.h,&quot;utf-8&quot;))
</pre>
</div>
<div class="section" id="getting-interactive-input-from-scripts">
<h2><a class="toc-backref" href="#id43">Getting interactive input from scripts</a></h2>
<p>The following code can be run from a script to get input from the user using the minibuffer:</p>
<pre class="literal-block">
def getInput (event=None):

   stateName = 'get-input'
   k = c.k
   state = k.getState(stateName)

   if state == 0:
       k.setLabelBlue('Input: ',protect=True)
       k.getArg(event,stateName,1,getInput)
   else:
       k.clearState()
       g.es_print('input:',k.arg)

getInput()
</pre>
<p>Let's look at this in detail.  The lines:</p>
<pre class="literal-block">
stateName = 'get-input'
k = c.k
state = k.getState(stateName)
</pre>
<p>define a state <em>name</em>, 'get-input', unique to this code.
k.getState returns the present state (an int) associated with this state.</p>
<p>When getInput() is first called, the state returned by k.getState will be 0,
so the following lines are executed:</p>
<pre class="literal-block">
if state == 0:
    k.setLabelBlue('Input: ',protect=True)
    k.getArg(event,stateName,1,getInput)
</pre>
<p>These lines put a protected label in the minibuffer:
the user can't delete the label by backspacing.
getArg, and the rest of Leo's key handling code, take care of the extremely
complex details of handling key strokes in states.
The call to getArg never returns.
Instead, when the user has finished entering the input by typing &lt;Return&gt;
getArg calls getInput so that k.getState will return state 1, the value
passed as the third argument to k.getArg.
The following lines handle state 1:</p>
<pre class="literal-block">
else:
    k.clearState()
    g.es_print('input:',k.arg)
</pre>
<p>k.arg is the value returned by k.getArg.
This example code just prints the value of k.arg and clears the input state.</p>
<hr class="docutils" />
<p><a class="reference" href="design.html"><img alt="back" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="customizing.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</body>
</html>
