<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>What's New in Leo 4.4.4</title>
<style type="text/css">

/*ORIGINAL GOODGER + changes; up to line 224 it's standard reST stylesheet
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006/10/19 13:23:15 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

/* EKR 10/19/06 */
/* some browsers require imported rules to precede all rulesets */
@import url(leo_rst.css);
@import url(silver_city.css);

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;}
  /*background-color: #eeeeee }*/
  /*for some reason i can't overide in an import*/

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

/*for some reason, the following isn't being overridden by the imports
at the end of this style sheet so I've commented it out*/
/*tt {
  background-color: #eeeeee }*/

ul.auto-toc {
  list-style-type: none }
  
hr { /* EKR */
  width: 100%;
  height: 1pt;
  color: gray;
}



</style>
</head>
<body>
<div class="document">


<!-- rst3: filename: html\new-4-4-4.html -->
<p><a class="reference" href="new-4-4-5.html"><img alt="prev" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="new-4-4-3.html"><img alt="next" src="arrow_rt.gif" /></a></p>
<div class="section" id="what-s-new-in-leo-4-4-4">
<h1><a class="toc-backref" href="#id1">What's New in Leo 4.4.4</a></h1>
<p>Leo 4.4.4 contains many important features originally planned for later releases.
The highlights of Leo 4.4.4:</p>
<ul>
<li><p class="first"><strong>The Great Graph Aha</strong>:
A Leo outline doesn't have to <em>be</em> an arbitrary graph in order to <em>represent</em> an arbitrary graph.</p>
<p>That is, simple scripts allow Leo outlines to represent arbitrary
directed graphs. There is no need for a separate 'graph world'. The graphed.py
plugin is a direct result of this Aha. It allows you to create general graphs
from Leo outlines.</p>
</li>
<li><p class="first">Support for <strong>&#64;auto nodes</strong>.  Such nodes allow people to collaborate using Leo
without inserting Leo sentinels in the files Leo generates.</p>
</li>
<li><p class="first"><strong>&#64;menus trees</strong> in settings files create all of Leo's menus.  It is now dead
easy to make Leo's menus look the way you want.</p>
</li>
<li><p class="first"><strong>&#64;buttons trees</strong> in settings files create common &#64;button nodes created in all
Leo outlines.</p>
</li>
<li><p class="first">A new, faster, <strong>colorizer plugin</strong> replaces the __jEdit_colorizer__ plugin.</p>
</li>
<li><p class="first">New commands for <strong>resolving cvs conflicts</strong>.</p>
</li>
<li><p class="first">Leo's core is now compatible with jython.</p>
</li>
</ul>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference" href="#what-s-new-in-leo-4-4-4" id="id1" name="id1">What's New in Leo 4.4.4</a><ul>
<li><a class="reference" href="#the-great-graph-aha" id="id2" name="id2">The Great Graph Aha</a></li>
<li><a class="reference" href="#added-support-for-auto-files" id="id3" name="id3">Added support for &#64;auto files</a><ul>
<li><a class="reference" href="#what-auto-does" id="id4" name="id4">What &#64;auto does</a></li>
<li><a class="reference" href="#perfect-import-checks" id="id5" name="id5">Perfect import checks</a></li>
<li><a class="reference" href="#commands-related-to-auto" id="id6" name="id6">Commands related to &#64;auto</a></li>
<li><a class="reference" href="#extending-the-code-adding-new-parsers" id="id7" name="id7">Extending the code: adding new parsers</a></li>
</ul>
</li>
<li><a class="reference" href="#new-commands-for-resolving-cvs-conflicts" id="id8" name="id8">New commands for resolving cvs conflicts</a></li>
<li><a class="reference" href="#new-kinds-of-settings-trees" id="id9" name="id9">New kinds of settings trees</a><ul>
<li><a class="reference" href="#buttons-trees" id="id10" name="id10">&#64;buttons trees</a></li>
<li><a class="reference" href="#menus-trees" id="id11" name="id11">&#64;menus trees</a></li>
</ul>
</li>
<li><a class="reference" href="#new-plugins" id="id12" name="id12">New plugins</a></li>
<li><a class="reference" href="#leo-s-core-is-now-compatible-with-jython" id="id13" name="id13">Leo's core is now compatible with jython</a></li>
<li><a class="reference" href="#improved-prototype-for-icons-in-headlines" id="id14" name="id14">Improved prototype for icons in headlines</a></li>
<li><a class="reference" href="#minor-improvements" id="id15" name="id15">Minor improvements</a></li>
<li><a class="reference" href="#summary-of-new-commands" id="id16" name="id16">Summary of new commands</a></li>
</ul>
</li>
</ul>
</div>
<!-- Links used in this document. -->
<!-- WARNING: image targets may not have upper case letters! -->
<div class="section" id="the-great-graph-aha">
<h2><a class="toc-backref" href="#id2">The Great Graph Aha</a></h2>
<p>The Great Graph Aha is:</p>
<p>A Leo outline doesn't have to <em>be</em> an arbitrary graph in order to <em>represent</em> an arbitrary graph.</p>
<p>So the graph world is unnecessary because we can use Leo nodes and trees as data
to other graphing packages.** That is, Python scripts can build arbitrary graphs
using Leo's existing nodes and trees. And Python scripts can manipulate those
graphs. And Python scripts could do the reverse: manipulate the Leo outline by
traversing general graphs. So there is no need to complicate Leo's fundamental
data structures. Hurray! Instead, we build on the strengths of already existing
graphing packages.</p>
<p>The Great Graph Aha created the opportunity for immediate action:</p>
<ol class="arabic">
<li><p class="first">test.leo contains the essential scripts to implement graphs in Leo files.
These short, simple, self-contained, easily modifiable scripts make possible
everything ever envisaged by the (now-defunct) graph world project:</p>
<pre class="literal-block">
leo2graph: convert a normal Leo tree to a NetworkX graph.
at-graph2graph: convert an &#64;graph tree to a NetworkX graph.
at-networkx2graph: convert an &#64;networkx tree to a NetworkX graph
at-networkx2at-graph: create an &#64;graph tree from an &#64;networkx tree.
</pre>
</li>
</ol>
<p>2. The graphed plugin allows users to manipulate parts of Leo outlines as if
they were general graphs. It is still early days for this exciting plugin.</p>
</div>
<div class="section" id="added-support-for-auto-files">
<h2><a class="toc-backref" href="#id3">Added support for &#64;auto files</a></h2>
<div class="section" id="what-auto-does">
<h3><a class="toc-backref" href="#id4">What &#64;auto does</a></h3>
<p>&#64;auto trees allows people to use Leo in collaborative environments without using
sentinels in the files Leo generates. In contrast to &#64;nosent, &#64;auto trees can
change when the corresponding file changes outside of Leo.</p>
<p>Leo will automatically recreate (import) all &#64;auto trees when reading a .leo
file, and will write all dirty &#64;auto trees when saving a .leo file. There are
two exceptions to this statement:</p>
<p>1. Leo will never read (import) or write an &#64;auto tree if
the root &#64;auto tree is under the influence of an &#64;ignore directive.</p>
<p>2. Saving a .leo file does not save &#64;auto nodes if a) they haven't been changed
or b) they do not contain a <strong>significant</strong> amount of informtion. An &#64;auto tree
contains a significant amount of information if it has  children or if the
root node contains more than 10 characters.</p>
<p>Leo creates &#64;auto trees by parsing the corresponding derived file. Parsers
create descendant nodes of the &#64;auto tree: one node for each class, method and
function in the derived file.</p>
<p>Parsers presently exist for C, elisp, Java, Pascal, PHP and Python. Leo
determines the language using the file's extension. If no parser exists for a
language, the entire body ofAn &#64;auto tree contains a significant amount of information if it has any children or if the root node contains more than 10 non-blank lines. the derived file is copied to the body of the &#64;auto
node.</p>
<p>Leo does not write the contents of &#64;auto trees to .leo files. In this respect,
&#64;auto trees work much like &#64;thin trees. &#64;auto trees whose root node is under the
scope of an &#64;ignore directive <em>will</em> be written to the .leo, just like &#64;thin
trees.</p>
</div>
<div class="section" id="perfect-import-checks">
<h3><a class="toc-backref" href="#id5">Perfect import checks</a></h3>
<p>Leo performs several checks to ensure that the result of importing an external
file will be equivlant to the file that writing the &#64;auto tree would produce.</p>
<p>These checks can produces <strong>errors</strong> or <strong>warnings</strong>. Errors indicate a
potentially serious problem. Leo inserts an &#64;ignore directive in the &#64;auto tree
if any error is found. This &#64;ignore directive prevents the &#64;auto tree from
modifying the external file. If you &#64;ignore directive, a later write of the
&#64;auto tree will attempt to fix the problems that gave rise to the errors. There
are no guarantees however.</p>
<p><strong>Strict languages</strong> are languages like Python for which leading whitespace is
especially significant. Before importing a file for a strict language, Leo
<strong>regularizes</strong> the leading whitespace of all lines of the original source file.
That is, Leo converts blanks to tabs or tabs to blanks depending on the value of
the &#64;tabwidth directive in effect for the &#64;auto node. Leo cannot guarantee to
reproduce the original source file exactly if problems are discovered while
regularizing leading whitespace.</p>
<p>After importing a file, Leo verifies that writing the &#64;auto node would create
the same file as the original file. For strict languages, the comparison must be
exact, or nearly so. For non-strict languages, differences in leading whitespace
generate warnings, not errors.</p>
<p>File comparison mismatches can arise for several reasons:</p>
<ol class="arabic simple">
<li>Bugs in the import parsers. Please report any suspected bugs immediately.</li>
<li>Underindented lines in classes, methods or functions in strict languages. An
<strong>underindented line</strong> is a line that is indented less then the starting line
of the class, method or function in which it appears. Leo outlines can not
represent such lines exactly: every line of node implicitly has at least the
indentation of any unindented line of the node.</li>
</ol>
<p>Leo will issue a warning (not an error) for underindented Python comment lines.
Such lines can not change the meaning of Python programs.</p>
</div>
<div class="section" id="commands-related-to-auto">
<h3><a class="toc-backref" href="#id6">Commands related to &#64;auto</a></h3>
<p>Three new commands in the <a class="reference" href="File:Read/Write">File:Read/Write</a> menu allow you to manually read and
write &#64;auto nodes from the presently selected outline. As always, an &#64;ignore
directive in the &#64;auto node or its ancestors will suppress any of these
commands:</p>
<ul class="simple">
<li>The Read &#64;auto Nodes (read-at-auto-nodes) command reads all &#64;auto nodes in the
presently selected outline. An &#64;ignore directive will suppress this import.</li>
<li>The Write &#64;auto Nodes (write-at-auto-nodes) command writes all &#64;auto nodes. An
&#64;ignore directive will suppress this import. Caution: the write will occur even
if Leo has not previously read the &#64;auto node.</li>
<li>The Write Dirty &#64;auto Nodes (write-dirty-at-auto-nodes) is the same as the
write-at-auto-nodes command, except that only changed &#64;auto trees are written.</li>
</ul>
<p>Most users will rarely use these explicit commands, because reading and writing
.leo files handles &#64;auto nodes well enough. However, you can use the
read-at-auto-nodes command to update &#64;auto nodes without having to reload the
.leo file.</p>
</div>
<div class="section" id="extending-the-code-adding-new-parsers">
<h3><a class="toc-backref" href="#id7">Extending the code: adding new parsers</a></h3>
<p>All present parsers are short overrides of a powerful base parser class. Thus,
it would be simple to add support for other languages. See the node</p>
<p>&#64;thin leoImport.py--&gt;Import--&gt;Scanners for createOutline</p>
<p>in leoPy.leo to see how easy it is to create new parsers.</p>
</div>
</div>
<div class="section" id="new-commands-for-resolving-cvs-conflicts">
<h2><a class="toc-backref" href="#id8">New commands for resolving cvs conflicts</a></h2>
<p>The so-called resolve-cvs-conflict project has resolved itself into small,
easily understood commands.</p>
<p>The <strong>read-file-into-node</strong> command prompts for a filename, and creates an node
whose headline is &#64;read-file-into-node &lt;filename&gt; and whose body text is the
entire contents of the file.</p>
<p>The <strong>write-file-from-node</strong> command writes the body text of the selected not to a file.
If the headline of the presently selected node starts with &#64;read-file-into-node
the command use the filename that follows in the headline. Otherwise, the
command prompts for a filename.</p>
<p>When a cvs conflict occurs, the user will:</p>
<ul class="simple">
<li>read the file into a node using the read-file-into-node command,</li>
<li>fix the conflict, as with any other editor, and</li>
<li>write the file with the write-file-from-node command.</li>
</ul>
<p>Any file can be fixed in this way, including derived files and .leo files. The
only complication is that the user must not change sentinel lines. Two new
commands check the contents of a node: The <strong>check-derived-file</strong> and
<strong>check-leo-file</strong> commands tell whether a trial read of the presently selected
node can be done successfully. The check-derived-file command assumes the body
text is a derived file; the check-leo-file command assumes the body text is an
entire .leo file.</p>
<p>The <strong>compare-leo-outlines</strong> command prompts for another (presubably similar)
.leo file that will be compared with the presently selected outline file (main
window). It then creates clones of all inserted, deleted and changed nodes.</p>
</div>
<div class="section" id="new-kinds-of-settings-trees">
<h2><a class="toc-backref" href="#id9">New kinds of settings trees</a></h2>
<div class="section" id="buttons-trees">
<h3><a class="toc-backref" href="#id10">&#64;buttons trees</a></h3>
<p>All &#64;buttons tree in a settings file defines global buttons that are created in
the icon area of all .leo files. You define &#64;button nodes in the &#64;buttons tree
as usual.</p>
</div>
<div class="section" id="menus-trees">
<h3><a class="toc-backref" href="#id11">&#64;menus trees</a></h3>
<p>Leo creates its menus from the &#64;menu and &#64;item nodes in the &#64;menus tree. Within
&#64;menus trees, &#64;menu nodes create menus and &#64;item nodes create menu items.</p>
<p>The menu name always follows &#64;menu. If the menu name is 'Plugins', Leo will
create the Plugins menu and populate the menu by calling the
'create-optional-menus' hook. This creates the Plugins menu as usual. Nested
&#64;menu nodes define submenus.</p>
<p>The command name follows &#64;item. If the body text of an &#64;item node exists, this
body text is the menu name. Otherwise, the menu name is the command name.
However, if the command name starts with a '*', hyphens are removed from the
menu name. Menu names and command names may contain a single ampersand (&amp;). If
present, the following character is underlined in the name. If the command name
in an &#64;item node is just a hyphen (-), the item represents a menu separator.</p>
</div>
</div>
<div class="section" id="new-plugins">
<h2><a class="toc-backref" href="#id12">New plugins</a></h2>
<ul class="simple">
<li>The graphed plugin allows users to manipulate parts of Leo outlines as if they
were general graphs. It is still early days for this exciting plugin.</li>
<li>The threading_colorizer plugin replaces the __jEdit_colorizer__ plugin. This
plugin features an elegant new algorithm that has much better performance and
eliminates almost all flash.</li>
</ul>
</div>
<div class="section" id="leo-s-core-is-now-compatible-with-jython">
<h2><a class="toc-backref" href="#id13">Leo's core is now compatible with jython</a></h2>
<p>Essentially all of Leo's startup code now runs with jython 2.2 and the (unfinished!) swing gui.</p>
</div>
<div class="section" id="improved-prototype-for-icons-in-headlines">
<h2><a class="toc-backref" href="#id14">Improved prototype for icons in headlines</a></h2>
<p>The prototype in test.leo now will use PIL (Python Imaging Library) if
available, so many more kinds of icons can be used. Buttons now exist to add
icons to do the following:</p>
<ul class="simple">
<li>Add any icon to any node.</li>
<li>Delete all icons from a single node or the entire tree.</li>
<li>Print the icon files associated with a node.</li>
<li>Print the sizes of icons in a directory.</li>
</ul>
<p>Fixed a bug in the icon handling in the outline widget that caused
duplicate icons not to be drawn properly.</p>
</div>
<div class="section" id="minor-improvements">
<h2><a class="toc-backref" href="#id15">Minor improvements</a></h2>
<ul>
<li><p class="first">See the release notes for a list of bugs fixed in Leo 4.4.4.</p>
</li>
<li><p class="first">Added the 'clear-all-marks' hook.</p>
</li>
<li><p class="first">Added button font setting. See the node: &quot;&#64;settings--&gt;Fonts--&gt;&#64;font button font&quot; in leoSettings.leo.</p>
</li>
<li><p class="first">Plugins and scripts may call the c.frame.canvas.createCanvas method to create a
log tab containing a Tk.Canvas widget. Here is an example script:</p>
<pre class="literal-block">
log = c.frame.log ; tag = 'my-canvas'
w = log.canvasDict.get(tag)
if not w:
    w = log.createCanvas(tag)
    w.configure(bg='yellow')
log.selectTab(tag)
</pre>
</li>
<li><p class="first">Improved the yank and yank-pop commands and added &#64;bool add_ws_to_kill_ring setting.</p>
</li>
<li><p class="first">Improved the debug command: it now adds the following code to the beginning of debug scripts:</p>
<pre class="literal-block">
class G:
    def es(s,c=None):
      pass
g = G()
</pre>
</li>
<li><p class="first">Added the &#64;bool rst3 strip_at_file_prefixes setting.</p>
</li>
<li><p class="first">Added the g.app.inBridge ivar.</p>
</li>
<li><p class="first">Added &#64;bool big_outline_pane setting. False (legacy): Top pane contains outline and log panes.
True: Top pane contains only the outline pane.  Bottom pane contains body and log panes.</p>
</li>
</ul>
</div>
<div class="section" id="summary-of-new-commands">
<h2><a class="toc-backref" href="#id16">Summary of new commands</a></h2>
<pre class="literal-block">
check-derived-file
check-leo-file
compare-leo-outlines
insert-child
read-at-auto-nodes
read-file-into-node
write-at-auto-nodes
write-dirty-at-auto-nodes
write-file-from-node
</pre>
<hr class="docutils" />
<p><a class="reference" href="new-4-4-5.html"><img alt="prev" src="arrow_lt.gif" /></a> <a class="reference" href="front.html"><img alt="leo" src="leo.gif" /></a> <a class="reference" href="new-4-4-3.html"><img alt="next" src="arrow_rt.gif" /></a></p>
</div>
</div>
</div>
</body>
</html>
