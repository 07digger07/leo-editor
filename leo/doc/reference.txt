.. @+leo-ver=5-thin
.. @+node:ekr.20131008041326.16089: * @file reference.txt
.. @@language rest
.. @@tabwidth -4

.. @+at @rst-options
..  call_docutils=False
..  code_mode=False
..  generate_rst=True
..  http_server_support = False
..  show_organizer_nodes=True
..  show_headlines=True
..  show_leo_directives=True
..  stylesheet_path=..\doc
..  write_intermediate_file = True
..  verbose=True
.. @@c

.. @+all
.. @+node:ekr.20131008041326.16090: ** @rst html/reference.html
#####################
Leo's Reference Guide
#####################
   
.. contents::
    :depth: 3
.. @+node:ekr.20131005214621.16130: *3* Directives Reference
This is a reference for all of Leo's directives.

This sections assumes you are *thoroughly* familiar with `Leo's tutorial`_.

.. @+node:ekr.20050828160132: *4* @rst-no-head links
.. Leo's homdownload and slides.. Links to other chapters
.. _front:                      index.html
.. _`Leo's tutorial`:           intro.html
.. _`Leo and reStructuredText`: rstplugin3.html
.. _`History of Leo`:           history.html
.. _`Using Chapters`:           outlines.html#using-chapters

.. For reasons unknown, images must appear in the _images folder on the web site.
.. .. |leoAtFileMainNode| image:: screen-shots/leo-qt-at-file-main-node.JPG
.. .. |leoAtFileFirstChild| image:: screen-shots/leo-qt-at-file-first-child.JPG
.. .. |leoAtFileNamedChild| image:: screen-shots/leo-qt-at-file-named-child.JPG
.. @+node:ekr.20100806170836.4392: *4* Part 1: \@<file> directives
.. index::
    pair: @<file>; Reference

This section discusses the \@<file> directives. These directives create or
import external files.

**Important**: Newcomers to Leo should create external files with \@auto or
\@file. Use \@auto if your external files must not contain sentinel lines. Use
\@file otherwise. In particular, \@file is **highly recommended** when sharing
external files in a collaborative environment.

**Note**: All these directive must appear in headlines.

The following table summarizes the various ways of creating external files.

+---------+------------+------------------+-----------------+
|         | Sentinels  | Sections and     | File data stored|
| Kind    | in external| @others expanded | in .leo file?   |
|         | file?      | on write?        |                 |
+---------+------------+------------------+-----------------+
| @asis   | no         | no               | yes             |
+---------+------------+------------------+-----------------+
| @auto   | no         | yes              | no              |
+---------+------------+------------------+-----------------+
| @edit   | no         | no               | no              |
+---------+------------+------------------+-----------------+
| @nosent | no         | yes              | yes             |
+---------+------------+------------------+-----------------+
| @shadow | Note 1     | yes              | no              |
+---------+------------+------------------+-----------------+
| @file   | yes        | yes              |                 |
| @thin   |            |                  | no              |
| Note 2  |            |                  |                 |
+---------+------------+------------------+-----------------+

**Note 1**: \@shadow nodes create two files, a **public** file without sentinels
and a **private** file with sentinels.

**Note 2**: \@file and \@thin nodes are synonyms.

Within @path and @<file> paths, {{exp}} gets evaluated with the following
symbols known: c, g, p, os and sys.  For example::

    @file {{os.path.abspath(os.curdir)}}/abc.py

refers to the file abc.py in (absolute path of) the current directory.

.. @+node:ekr.20100806170836.4393: *5* \@asis <path>
.. index::
    pair: @asis; Reference

The \@asis directive creates an external file without sentinels and without any
expansions.

Use this directive only when you must have complete control over every character
of the external file. When writing \@asis nodes, writes the body text of all
nodes in outline order. Leo writes the body text *as is*, without recognizing
section definitions, without expanding section references, and without treating
directives specially in any way. In particular, Leo copies all directives,
including \@ or \@c directives, to the external file as text.

.. index::
    pair: @@ convention in @asis trees; Reference

**The @@ convention**: Within \@asis trees only, if a headline starts with \@@,
Leo writes everything in the headline following the \@@ just before the
corresponding body text.

Files created from \@asis trees contain *nothing* not contained in body text (or
\@@ headlines). In particular, if body text does not end in a newline, the first
line from the next node will concatenated to the last line of the preceding
node.

Within \@asis trees, Leo writes no sentinels to the external file, so Leo can not update the outline
using changes to the external file. When reading .leo files, Leo does *not* read
external files created from \@asis nodes. Instead, all data in an \@asis tree is
stored in the .leo file.

Within \@asis trees, Leo recognizes the \@ignore directive only in the
*ancestors* of \@asis nodes. This allows you to use the \@ignore directive to
prevent Leo from writing \@asis trees.

**Note**: \@file-asis and \@silent are deprecated synonyms for \@asis.
.. @+node:ekr.20100806170836.4396: *5* \@auto <path>
.. index::
    pair: @auto; Reference

The \@auto directive imports an external file into a tree of nodes. Using \@auto
is *highly recommended* when using external files that must not contain Leo
sentinels.

\@auto trees allow people to use Leo in collaborative environments without using
sentinels in external files. Even without sentinels, \@auto trees can change
when the corresponding external file changes outside of Leo.

.. index::
    pair: Importer; Reference

When reading \@auto nodes, Leo creates the \@auto tree using **importers**,
parsers that create an outline with nodes for each class, method and function in
the external file. Some importers create other kinds of nodes as well.

Importers presently exist for C, elisp, HTML, .ini files, Java, Javascript, Pascal, PHP,
Python and xml. Leo determines the language using the file's extension. If no
parser exists for a language, Leo copies the entire body of the external file
into the \@auto node.

.. index::
    pair: Organizer tag; Reference

**Note**: the \@data import_xml_tags setting specifies the **organizer tags**
that cause the HTML and XML importers to create outline nodes. By default, the
**organizer tags** are html, body, head, and div.

When writing \@auto nodes, Leo writes the external file without sentinels. This
allows you to use Leo in collaborative environments without disturbing colleagues.

When importing files into \@auto trees, Leo performs several checks to ensure
that writing the imported file will produce exactly the same file. These checks
can produces **errors** or **warnings**. Errors indicate a potentially serious
problem. Leo inserts an \@ignore directive in the \@auto tree if any error is
found. This prevents the \@auto tree from modifying the external file.

.. index::
    pair: Strict language; Reference

Before importing a file, Leo **regularizes** the leading whitespace of all
lines of the original source file. That is, Leo converts blanks to tabs or
tabs to blanks depending on the value of the \@tabwidth directive in effect
for the \@auto node. Leo also checks that the indentation of any non-blank
line is a multiple of the indentation specified by the \@tabwidth directive.
**Strict languages** are languages such as Python for which leading
whitespace must be preserved exactly as it appears in the original source
file. Problems during regularizing whitespace generate errors for strict
languages and warnings for non-strict languages.

After importing a file, Leo verifies that writing the \@auto node would create
the same file as the original file. Such file comparison mismatches
generate errors unless the problem involves only leading whitespace for
non-strict languages. Whenever a mismatch occurs the first non-matching line is
printed.

File comparison mismatches can arise for several reasons:

1. Bugs in the import parsers. Please report any such bugs immediately.

2. Underindented lines in classes, methods or function.

.. index::
    pair: Underindented line; Reference

An **underindented line** is a line of body text that is indented less then the
starting line of the class, method or function in which it appears. Leo outlines
can not represent such lines exactly: every line in an external file will have
at least the indentation of any unindented line of the corresponding node in the
outline. Leo will issue a warning (not an error) for underindented Python
comment lines. Such lines can not change the meaning of Python programs.
.. @+node:ekr.20100806170836.4395: *5* \@edit <path>
.. index::
    pair: @edit; Reference

The \@edit directive imports an external file into a single node.

When reading \@edit nodes, Leo reads the entire file into the \@edit node. Lines
that look like sentinels will be read just as they are.

When writing \@edit nodes, \@edit nodes must not have children and section
references and @others are not allowed.
.. @+node:ekr.20100806170836.4403: *5* \@file <path> (aka @thin)
.. index::
    pair: @file; Reference
    pair: @thin; Reference

The \@file directive creates an external file containing sentinels. When writing
\@file trees, Leo expands section references and \@all and \@others directives.

When reading external files created by \@file, the sentinels allow Leo to
recreate all aspects of the outline. In particular, Leo can update the
outline based on changes made to the file by another editor. 

**Important**: \@file is the recommended way to create and edit most files. In
particular, using \@file nodes is **highly recommended** when sharing external
files in a collaborative environment.

The \@thin directive is a synonym for \@file.

Prior to Leo 4.7, \@file worked differently from \@thin. This should not be
a problem: Leo 4.7 can read all external files written by Leo 4.6.
.. @+node:ekr.20100806170836.4399: *5* \@nosent <path>
.. index::
    pair: @nosent; Reference

The \@nosent <filename> creates an external file without sentinel lines.

When writing an \@nosent tree, Leo expands section references, \@all and
\@others directives, but Leo writes no sentinels to the external file.
Thus, Leo can not update \@nosent trees from changes made to the external
file. However, \@nosent trees do have their uses: unlike \@auto trees,
cloned nodes *are* valid in \@nosent trees.

When reading an \@nosent node, Leo does *not* read the external file.
Instead, all the data in the \@nosent tree is stored in the .leo file.

**Note**: \@auto or \@shadow are usually better choices than \@nosent for
creating external files without sentinels.

**Note**: The \@bool force_newlines_in_at_nosent_bodies setting controls whether
Leo writes a trailing newline if non-empty body text does not end in a newline.
The default is True.
.. @+node:ekr.20100806170836.4402: *5* \@shadow <path>
.. index::
    pair: @shadow; Reference
    pair: Private file; Reference
    pair: Public file; Reference

The \@shadow directive creates *two* external files, a **public** file without
sentinels, and a **private** file containing sentinels.

When reading an \@shadow node, Leo uses a brilliant algorithm devised by
Bernhard Mulder that compares the public and private files, and then updates the
outline based on changes to the *public* file. In this way, \@shadow provides
many of the benefits of \@file trees without writing sentinels in the (public)
external file.

Leo can do an initial import of \@shadow trees by parsing the corresponding
public file, exactly as is done for \@auto nodes.
.. @+node:ekr.20100806170836.4411: *4* Part 2: \@all and \@others
These control how Leo places text when writing external files.
They are two of the most important directives in Leo.

.. glossary::
    :sorted:

.. index::
    pair: @all; Reference

\@all

    Copies *all* descendant nodes to the external file. Use \@all to place
    unrelated data in an external file.

    The \@all directive is valid only in the body of \@file trees.

    Within the range of an \@all directive, Leo ignores the \@others directive
    and section references, so Leo will not complain about orphan nodes.

.. index::
    pair: @others; Reference

\@others

    Writes the body text of all unnamed descendant into the external file, in
    outline order.

    Whitespace appearing before \@others directive adds to the indentation of
    all nodes added by the \@others directive.

    A single node may contain only one \@others directive, but descendant nodes
    may have other \@others directives.
.. @+node:ekr.20100806170836.4398: *4* Part 3: Syntax coloring directives
The \@color, \@killcolor, \@nocolor and \@nocolor-node directives control how
Leo colors text in the body pane.

.. index::
    pair: Ambiguous node; Reference

These directives typically affect the node in which they appear and all
descendant nodes. Exception: an **ambiguous node**, a node containing both
\@color and \@nocolor directives, has no effect on how Leo colors text in
descendant nodes.

.. glossary::
    :sorted:

.. index::
    pair: @color; Reference

\@color

    Enables syntax coloring until the next \@nocolor directive.

.. index::
    pair: @killcolor; Reference

\@killcolor

    Disables syntax coloring in a node, overriding all \@color, \@nocolor or
    \@nocolor-node directives in the same node.

.. index::
    pair: @nocolor; Reference

\@nocolor

    Disables syntax coloring until the next \@nocolor directive.

.. index::
    pair: @nocolor-node; Reference

\@nocolor-node

    Disables coloring for only the node containing it. The \@nocolor-node
    directive overrides the \@color and \@nocolor directives within the same
    node.
.. @+node:ekr.20100806170836.4408: *4* Part 4: Dangerous directives
These directives alter how Leo represents data in external files. They are
**dangerous**--mistakes in using these sentinels can make it impossible for Leo
to read the resulting external file. Use them with care!

Nevertheless, these sentinels can be useful in special situations.

.. glossary::
    :sorted:

.. index::
    pair: @comment; Reference

\@comment <1, 2 or three comment delims>

    Sets the comment delimiters in \@file and \@shadow files.
    **Important**: Use \@comment for unusual situations only. In most cases, you
    should use the \@language directive to set comment delimiters.

    The \@comment directive may be followed by one, two or three delimiters,
    separated by whitespace. If one delimiter is given, it sets the delimiter
    used by single-line comments. If two delimiters are given, they set the
    block comment delimiter. If three delimiters are given, the first sets the
    single-line-comment delimiter, and the others set the block-comment
    delimiters.

    Within these delimiters, underscores represent a significant space, and
    double underscores represent a newline. Examples::

        @comment REM_
        @comment __=pod__ __=cut__

    The second line sets PerlPod comment delimiters.

    **Warning**: the \@comment and \@delims directives **must not** appear in
    the same node. Doing so may create a file that Leo can not read.

    **Note**: \@language and \@comment may appear in the same node, provided
    that \@comment appears *after* the \@language directive: \@comment overrides
    \@language.

    The \@comment directive must precede the first section name or \@c
    directive.

.. index::
    pair: @delims; Reference

\@delims <1 or 2 comment delims>

    Sets comment delimiters in external files containing sentinel lines.

    The \@delims directive requires one or two delimiters, separated by
    whitespace. If one delimiter is present it sets the single-line-comment
    delimiter. If two delimiters are present they set block comment delimiters.

    This directive is often used to place Javascript text inside XML or HTML
    files. Like this::

        @delims /* */
        Javascript stuff
        @delims <-- -->
        HTML stuff

    **Warning**: you **must** change back to previous delimiters using another
    \@delims directive. Failure to change back to the previous delimiters will
    thoroughly corrupt the external file as far as compilers, HTML renderers,
    etc. are concerned. Leo does not do this automatically at the end of a node.

    **Warning**: the \@comment and \@delims directives **must not** appear in
    the same node. Doing so may create a file that Leo can not read.

    **Note**: The \@delims directive can not be used to change the comment
    strings at the start of the external file, that is, the comment strings for
    the \@+leo sentinel and the initial \@+body and \@+node sentinels.

.. index::
    pair: @raw; Reference
    pair: @end_raw; Reference

\@raw and \@end_raw

    \@raw starts a section of "raw" text that ends *only* with the \@end_raw directive
    or the end of the body text containing the \@raw directive. Within this
    range, Leo ignores all section references and directives, and Leo generates
    no additional leading whitespace.
.. @+node:ekr.20100804133903.7262: *4* Part 5: All other directives
This section is a reference guide for all other Leo directives, organized
alphabetically.

Unless otherwise noted, all directives listed are valid only in body text,
and they must start at the leftmost column of the node.

.. glossary::
     :sorted:

.. index::
    pair: @; Reference
.. index::
    pair: @doc; Reference
.. index::
    pair: Doc part; Reference

\@ and \@doc

    These directives start a doc part. \@doc is a synonym for \@. Doc parts
    continue until an \@c directive or the end of the body text. For example::

        @ This is a comment in a doc part.
        Doc parts can span multiple lines.
        The next line ends the doc part
        @c

    When writing external files, Leo writes doc parts as comments.

    Leo does not recognize \@ or \@doc in \@asis trees or when the \@all or
    \@delims directives are in effect.

.. index::
    pair: @c; Reference
.. index::
    pair: @code; Reference

\@c and \@code

    Ends any doc part and starts a code part.

    \@code is a deprecated synonym for \@c.

    Leo does not recognize this directive in \@asis trees or when the
    \@all or \@raw directives are in effect.

.. index::
    pair: @chapter; Reference
.. index::
    pair: @chapters; Reference

\@chapter and \@chapters

    An \@chapter tree represents a chapter. All @chapter nodes should be
    contained in an \@chapters node.

    These directives are too complex to describe here. For full details, see
    `Using Chapters`_.

    These directives must appear in the node's headline.

.. index::
    pair: @encoding; Reference

\@encoding <encoding>

    Specifies the Unicode encoding for an external file. For example::

        @encoding iso-8859-1

    When reading external files, the encoding given must match the encoding
    actually used in the external file or "byte hash" will result.

.. index::
    pair: @first; Reference

\@first <text>

    Places lines at the very start of an external file, before any Leo
    sentinels. \@first lines must be the very first lines in an \@<file> node.
    More then one \@first lines may appear.

    This creates two first lines, a shebang line and a Python encoding line::

        @first #! /usr/bin/env python
        @first # -*- coding: utf-8 -*-

    Here is a perl example::

        @first #!/bin/sh -- # perl, to stop looping
        @first eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
        @first     if 0;

\@ignore

    Tells Leo to ignore the subtree in which it appears.

    In the body text of most top-level @<file> nodes, the \@ignore directive
    causes Leo not to write the tree. However, Leo ignores \@ignore directives
    in \@asis trees.

    Plugins and other parts of Leo sometimes @ignore for their own purposes. For
    example, Leo's unit testing commands will ignore trees containing @ignore.
    In such cases, the \@ignore directive may appear in the headline or body
    text.

.. index::
    pair: @language; Reference

\@language <language name>

    Specifies the language in effect, including comment delimiters.
    If no \@language directive is in effect, Leo uses the defaults specified
    by the \@string target-language setting.

    A node may contain at most one \@language directive.

    The valid language names are: actionscript, ada, autohotkey, batch, c, config,
    cpp, csharp, css, cweb, elisp, forth, fortran, fortran90, haskell, haxe,
    html, ini, java, javascript, kshell, latex, lua, noweb, pascal, perl,
    perlpod, php, plain, plsql, python, rapidq, rebol, rest, rst, ruby, shell,
    tcltk, tex, unknown, unknown_language, vim, vimoutline, xml, xslt.

    **Note**: Shell files have comments that start with #.

    Case is ignored in the language names. For example, the following are
    equivalent::

        @language html
        @language HTML

    The \@language directive also controls syntax coloring. For language x, the
    file leo/modes/x.py describes how to colorize the language. To see the
    languages presently supported, look in the leo/modes directory. There are
    over 100 such languages.

.. index::
    pair: @last; Reference

\@last <text>

    Places lines at the very end of external files.

    This directive must occur at the very end of top-level \@<file> nodes. More
    than one \@last directive may exist. For example::

        @first <?php
        ...
        @last ?>

    Leo does not recognize \@last directive in \@asis trees.

.. index::
    pair: @lineending; Reference

\@lineending cr/lf/nl/crlf

    Sets the line endings for external files.
    This directive overrides the \@string output_newline setting.

    The valid forms of the @lineending directive are:

    ========================   ======================================================
    \@lineending nl            The default, Linux.
    ------------------------   ------------------------------------------------------
    \@lineending cr            Mac
    ------------------------   ------------------------------------------------------
    \@lineending crlf          Windows
    ------------------------   ------------------------------------------------------
    \@lineending lf            Same as 'nl', not recommended
    ------------------------   ------------------------------------------------------
    \@lineending platform      Same as platform value for output_newline setting.
    ========================   ======================================================

.. index::
    pair: @nowrap; Reference

\@nowrap

    Disables line wrapping the Leo's body pane.

    Only the first \@wrap or \@nowrap directive in a node has any effect.

    \@nowrap may appear in either headlines or body text.

..  If \@others occurs multiple times in the same node, all non-section nodes
..  appear at the location of the first instance of the \@others directive; the
..  remainder are remembered as sentinels but have no other content.

.. index::
    pair: @pagewidth; Reference

\@pagewidth <n>

   Sets the page width used to break doc parts into lines.
   <n> should be a positive integer.  For example::

      @pagewidth 100

  The \@pagewidth directive overrides the \@int page_width setting.

.. index::
    pair: @path; Reference
.. index::
    pair: Absolute path; Reference
.. index::
    pair: Path prefix; Reference

\@path <path>

   Sets the **path prefix** for relative filenames for all \@<file> tree.

   This directive may appear in headlines or body text, and may
   appear in top-level \@<file> nodes.

   The path is an **absolute path** if it begins with c:\\ or /,
   otherwise the path is a **relative** paths.

   Multiple \@path directives may contribute to the path prefix.
   Absolute paths overrides any ancestor \@path directives.
   Relative paths add to the path prefix.

   If no \@path directives are in effect, the default path prefix is
   the directory containing the .leo file.

   Within @path and @<file> paths, {{exp}} gets evaluated with the following
   symbols known: c, g, p, os and sys.  For example::

       @file {{os.path.abspath(os.curdir)}}/abc.py

   refers to the file abc.py in (absolute path of) the current directory.

.. index::
    pair: @tabwidth; Reference
.. index::
    pair: Negative tab width; Reference

\@tabwidth <n>

  Sets the width of tabs.
  Negative tab widths cause Leo to convert tabs to spaces.

.. index::
    pair: @wrap; Reference

\@wrap

    Enables line wrapping in Leo's body pane.

    Only the first \@wrap or \@nowrap directive in a node has any effect.

    \@wrap may appear in either headlines or body text.
.. @+node:ekr.20131008041326.16177: *3* History of Leo
This section discusses the most important milestones in history of Leo.

.. @+node:ekr.20050901102147: *4* @rst-no-head links
.. Relative links...
.. _`Scripting Leo with Python`:        scripting.html
.. _`Customizing Leo`:                  customizing.html
.. _`Theory of Operation`:              theory.html
.. _`Controlling Syntax Coloring`:      coloring.html
.. _`Debugging with Leo`:               debuggers.html
.. _`Using ZODB with Leo`:              zodb.html
.. _`Leo and Emacs`:                    emacs.html
.. _`Embedding Leo with the leoBridge Module`: leoBridge.html
.. _`Unit testing with Leo`:            unitTesting.html
.. _`ILeo - the IPython bridge`:        IPythonBridge.html
.. _`the IPython bridge`:               IPythonBridge.html
.. _`Using @shadow`:                    atShadow.html
.. _`What's New`:                       what-is-new.html

.. Absolute links..
.. _OPML:   http://en.wikipedia.org/wiki/OPML
.. @+node:ekr.20050902105852: *4* Beginnings
Leo grew out of my efforts to use Donald Knuth's "CWEB system of Structured
documentation." I had known of literate programming since the mid 1980's, but I
never understood how to make it work for me. In November 1995 I started thinking
about programming in earnest. Over the holidays I mused about making programs
more understandable. In January 1996 the fog of confusion suddenly cleared. I
summarized my thinking with the phrase, **web are outlines in disguise**. I
suspected that outline views were the key to programming, but many details
remained obscure.
.. @+node:ekr.20050902105852.1: *4* Breakthrough
March 5, 1996, is the most important date in Leo's history. While returning from
a day of skiing, I discussed my thoughts with Rebecca. During that conversation
I realized that I could use the MORE outliner as a prototype for a "programming
outliner." I immediately started work on my first outlined program. It quickly
became apparent that outlines work: all my old problems with programming
vanished. The @others directive dates from this day. I realized that MORE's
outlines could form the basis for Leo's screen design. Rather than opening body
text within the outline, as MORE does, I decided to use a separate body pane.

I hacked a translator called M2C which allowed me to use MORE to write
real code. I would write code in MORE, copy the text to the clipboard in
MORE format, then run M2C, which would convert the outline into C code.
This process was useful, if clumsy. I called the language used in the outline
SWEB, for simplified CWEB. Much later Leo started supporting the noweb
language.
.. @+node:ekr.20050902105852.2: *4* Apple and YellowBox
Throughout 1996 I created a version of Leo on the Macintosh in plain C and the
native Mac Toolbox. This was a poor choice; I wasted a huge amount of time
programming with these primitive tools. However, this effort convinced me that
Leo was a great way to program.

Late in 1997 I wrote a Print command to typeset an outline. Printing (Weaving)
is supposedly a key feature of literate programming. Imagine my surprise when I
realized that such a "beautiful" program listing was almost unintelligible; all
the structure inherent in the outline was lost! I saw clearly that typesetting,
no matter how well done, is no substitute for explicit structure.

In 1998 I created a version of Leo using Apple's YellowBox environment. Alas,
Apple broke its promises to Apple developers. I had to start again.
.. @+node:ekr.20050902105852.3: *4* Borland C++
I rewrote Leo for Borland C++ starting in May 1999. Borland C++ was much better
than CodeWarrior C, but it was still C++. This version of Leo was the first
version to use xml as the format of .leo files. The last version of Borland Leo,
3.12 Final went out the door July 17, 2003.
.. @+node:ekr.20050902105852.4: *4* Discovering Python
I attended the Python conference in early 2001. In May of 2000 I began work on
an wxWindows version of Leo. This did not work out, but something good did come
from this effort. I spent a lot of time adding Python scripting to the wxWindows
code and I became familiar with Python and its internals.

I really started to 'get' Python in September 2001. I wrote the white papers at
about this time. Python solved *all* my programming problems. I rewrote Leo in
Python in about two months! For the first time in my career I was no longer
anxious while programming; it simply isn't possible to create bad bugs in
Python. The Python version of Leo was the first officially OpenSoftware version of
Leo. The first functional version of Leo in Python was 0.05 alpha, December 17,
2001.
.. @+node:ekr.20050902105852.5: *4* SourceForge
I registered the Leo project on SourceForge on March 10, 2003. It is certainly
no accident that Leo started a new life shortly thereafter. Prior to SourceForge
my interest in Leo had been waning.
.. @+node:ekr.20050902105852.6: *4* Allowing sentinel lines in external files
In the summer of 2001 I began to consider using sentinel lines in external files.
Previously I had thought that outline structure must be 'protected' by remaining
inside .leo files. Accepting the possibility that sentinels might be corrupted
opened vast new design possibilities. In retrospect, problems with sentinel
almost never happen, but that wasn't obvious at the time! The result of this
design was known at first as Leo2. That terminology is extinct. I think of
this version as the first version to support @file and automatic tangling
and untangling.
.. @+node:ekr.20050902105852.7: *4* Untangling @file is easy!
The biggest surprise in Leo's history was the realization it is **much** easier
to untangle files derived from @file. Indeed, the old tangle code created all
sorts of problems that just disappear when using @file. The new Python version
of Leo became fully operational in early 2002. It was probably about this time
that I chose noweb as Leo's preferred markup language. My decision not to
support noweb's escape sequences made Leo's read code much more robust.
.. @+node:ekr.20050902105852.8: *4* Leo 3.x: Continuous improvement
I spent 2002 taking advantages of Python's tremendous power and safety.
Many improvements were at last easy enough to do:

- Nested @others directives appeared in 3.2.
- Unicode support started in 3.3.
- @first and @last appeared in 3.7
- @asis and @nosent appeared in 3.8.
- Incremental syntax coloring and incremental undo appeared in 3.9.
- Paul Paterson created Leo's plugin architecture sometime during this period.
  Plugins have been a driving force in Leo's development because people can
  change how Leo works without altering Leo's core.
- 3.12 fixed a huge memory leak.
- 3.12 Final, the last 3.x version, appeared July 17, 2003.
.. @+node:ekr.20050902105852.9: *4* Leo 4.0: Eliminating error 'recovery'
In late 2002 and throughout 2003 I worked on an entirely new file format.
4.0 final went out the door October 17, 2003 after almost a year intense
design work trying to improve error recovery scheme used while reading
external files. In the summer of 2003 I realized that orphan and @ignore'd
nodes must be prohibited in @file trees. With this restriction, Leo
could finally recreate @file trees in outlines using **only** the
information in external files. This made the read code much more robust, and
eliminated all the previous unworkable error recovery schemes. At last Leo
was on a completely firm foundation.
.. @+node:ekr.20050902105852.10: *4* Leo 4.1: The debut of gnx's
Leo first used gnx's (global node indices) as a foolproof way of associating
nodes in .leo files with nodes in external files. At the time, there was
still intense discussions about protecting the logical consistency of
outlines. \@thin was later to solve all those problems, but nobody knew
that then.
.. @+node:ekr.20050902105852.11: *4* Leo 4.2: Complete at last
Leo 4.2 Final went out the door September 20, 2004.
This surely is one of the most significant dates in Leo's history:

-   This marked the end worries about consistency of outlines and external files:
    Leo recreates all essential information from thin external files,
    so *there is nothing left in the .leo file to get out of synch*.

- Thin external files use gnx's extensively. This simplifies the file format and
    makes thin external files more cvs friendly.

-   A sensational scripting plugin showed how to create script buttons.
    This has lead to improvements in the Execute Script command and
    other significant improvements in Unit testing.

-   As if this were not enough, 4.2 marked the 'great divide' in Leo's internal
    data structures. Before 4.2, Leo every node in the outline had its own
    vnode. This was a big performance problem: clone operations had to
    traverse the entire outline! 4.2 represents clones by sharing subtrees.
    Changing Leo's fundamental data structures while retaining compatibility
    with old scripts was engineering work of which the entire Leo community can
    be proud. `Scripting Leo with Python`_ tells how the position
    class makes this happen.
    This was a cooperative effort. Kent Tenney and Bernhard Mulder made
    absolutely crucial contributions. Kent pointed out that it is a tnode,
    not a vnode that must form the root of the shared data. Bernhard showed
    that iterators are the way to avoid creating huge numbers of positions.

Leo 4.2 marked so many significant changes. I often find it hard to remember
what life with Leo was like before it.
.. @+node:ekr.20050902105852.12: *4* Leo 4.3 Settings
Leo 4.3 corrected many problems with leoConfig.txt. Instead, Leo gets
settings from one or more leoSettings.leo files. This version also
introduced a way to changed settings using a settings dialog.  However,
the settings dialog proved not to be useful (worse, it inhibited design) and
the settings dialog was retired in Leo 4.4.
.. @+node:ekr.20060629083935: *4* Leo 4.4 The minibuffer and key bindings
Leo 4.4 was a year-long effort to incorporate an Emacs-style minibuffer and
related commands into Leo. Thinking in terms of minibuffer commands frees my
thinking. Leo 4.4 also featured many improvements in how keys are bound to
commands, including per-pane bindings and user-defined key-binding modes.

Development on long-delayed projects accelerated after 4.4 final went out the door.
Recent projects include:

- Controlling syntax coloring with jEdit's xml language-description files.
- Support for debugging scripts using external debuggers.
- Modifying Leo's vnodes and tnodes so that Leo's data can be used with ZODB.
- Using pymacs to write Leo scripts within Emacs.
- Using the leoBridge module to embed Leo support in other programs.
- Using Leo to run unit tests.

.. @+node:ekr.20080315115427.568: *4* Leo 4.4.x Improvements
This series of releases featured **hundreds** of improvements.  The highlights were truly significant:

- Added the leoBridge module. See `Embedding Leo with the leoBridge Module`_.

- Added support for @enabled-plugins and @openwith (formerly @open-with) nodes in settings files.

- Added support for ZODB. See `Using ZODB with Leo`_.

- Added leoPymacs module. See `Leo and Emacs`_.

- Added perfect import of external files with @auto nodes.

- Used the sax parser to .leo files. This allows the format of .leo files to be
  expanded easily.

- Added support for myLeoSettings.leo.

- Supported multiple editors in body pane.

- Added the jEdit_colorizer plugin. See `Controlling Syntax Coloring`_.

- Many other new plugins.

For a complete list, see the `What's New`_ chapter.
.. @+node:ekr.20101025080245.6085: *4* Leo 4.5 @shadow files
Added support for @shadow files. This was a major breakthrough.
See the `Using @shadow`_ chapter for full details.
.. @+node:ekr.20101025080245.6086: *4* Leo 4.6 Caching, Qt and more
This version of Leo featured more significant improvements:

- Added support for the Qt gui.  This was a major project that
  significantly improves the look and feel of Leo.

- A file-caching scheme produced spectacular improvements in the
  speed of loading Leo outlines.

- Added support for @auto-rst nodes. These import reStructuredText (rST) files
  so that the files can be "round-tripped" without introducing extraneous
  changes. This makes Leo a superb environment for using rST.

- Added support for @edit nodes.
.. @+node:ekr.20101025080245.6087: *4* Leo 4.7 The one node world and Python 3k
Leo 4.7 accomplishes something I long thought to be impossible: the unification
of vnodes and tnodes. tnodes no longer exist: vnodes contain all data. The Aha
that made this possible is that iterators and positions allow a single node to
appear in more than one place in a tree traversal.

This is one of the most significant developments in Leo's history. At last the
endless confusion between vnodes and tnodes is gone. At the most fundamental
level, Leo's data structures are as simple as possible. This makes them as
general and as powerful as possible!

This version successfully produced a common code base that can run on both
Python 2.x and Python 3.x.
.. @+node:ekr.20101025080245.6089: *4* Leo 4.8 Simple sentinels & better data recovery
Leo 4.8 simplified Leo's sentinels as much as possible.
Leo's sentinel lines look very much like Emacs org-mode comment lines,
except for the addition of gnx's.

This version also produced a fundamentally important addition to Leo's error
recovery. Leo now shows "Resurrected" and "Recovered" nodes when loading an
outline. These nodes protect against data loss, and also implicitly warn when
unusual data-changing events occur. Creating this scheme is likely the final
chapter in the epic saga of error recovery in Leo.
.. @+node:ekr.20131008041326.16253: *4* Leo 4.9 Qt, autocompleter, vr pane
.. _`PyQt`: http://www.riverbankcomputing.com/software/pyqt/intro

Leo 4.9 featured the completed transition to the `PyQt`_ application
framework, the introduction of the viewrendered pane, and
autocompletion.
.. @+node:ekr.20050902100834: *4* @rst-ignore-tree Details
This following information may be of interest to historians. It is not of
general enough interest to put in Leo's Users Guide on the web. I am including
this mass of detail here to indicate the complexities that were involved in
designing Leo's simple-looking mechanisms.
.. @+node:EKR.20040524104904.247: *5* Versions
In May of 1999 I began work on the Borland version of Leo for Windows.  The
Borland Delphi classes were a pleasure to use and free of bugs.  I redesigned
Leo's file format for the Windows version of Leo; the Yellow Box file format is
a binary format that requires the Yellow Box runtime.  Fortunately, I choose to
use XML for Leo's file format.  I have Marc-Antoine Parent to thank for this
decision; he urged me to use XML and patiently explained how to use XML
properly.  However, there are two significant problems with the Borland version
of Leo.  First, it works only on Windows.  Second, it can never be Open
software, because it uses Borland's Delphi classes and a commercial syntax
coloring component. 

In October of 2001 I began work on the leo.py, an Open Software version of
leo.py, a version of Leo written in Python and Tk.  At last I have found the
proper platform for Leo.  leo.py naturally supports scripting in Python.  The
combination of Python and Tk is incredibly powerful, very easy to use, and truly
cross platform.  I rewrote Leo in Python in about two months!  For the first
time in my career I no longer am anxious while programming; it simply isn't
possible to create bad bugs in Python.

Tk was officially retired in June 2011.
.. @+node:EKR.20040524104904.248: *5* Designing @file trees
The following sections give a pseudo-chronological list of the major Aha's
involved in creating Leo2. These Aha's form the real design and theory of
operation of Leo. See the "Diary", "Notes" and "Letters to Speed Ream" sections
in LeoDocs.leo for a more accurate and less tidy history of Leo2.

I am writing these notes for several reasons. First, the initial design and
coding of Leo2, spanning a period of about 8 weeks, was some of the most
creative and rewarding work I have ever done. The result is elegant and simple.
I'm proud of it. Second, much of the design work is not reflected in the code,
because improved design often eliminated code entirely. The final code is so
elegant that it obscures the hard work that created it. Third, you must
understand this design in order to understand the implementation of @file trees
and their external files. Someday someone else may take charge of Leo. That
person should know what really makes Leo2 work.
.. @+node:EKR.20040524104904.249: *6* Deciding to do Leo2
In the summer of 2001 I began work on a project that for a long time I had
considered impossible. I had long considered that "private" file formats such as
.leo files were the only way to represent an outline properly and safely. I'm
not sure exactly what changed my mind, but I finally was willing to consider
that information embedded in external files might be useful. This meant accepting
the possibility that sentinel lines might be corrupted. This was a crucial first
step. If we can trust the user not to corrupt sentinel lines than we can embed
almost any kind of information into a external file.

There were several motivations for this work. I wanted to eliminate the need for
explicit Tangle and Untangle commands. I thought of this as "Untangle on
Read/Tangle on Write." If tangling and untangling could be made automatic it
would save the user a lot of work. I also wanted to make external files the
primary sources files. .leo files might be made much smaller external files
contained the primary source information. This hope turned out to be false.

The result of this design work was something I originally called Leo2, though I
now usually prefer to talk about @file trees. Initially most design issues were
unresolved or unknown. I resolved to attempt a robust error-recovery scheme, not
knowing in advance what that might involve. I also wanted to solve what I
thought of as the "cross-file clone" problem: clones that point from a .leo
outline into a external file. With Leo1 cross-file clones do not exist;
everything is in the same .leo file. It was clear that Leo2 would have to change
some aspects of clones, but all details were fuzzy.
.. @+node:EKR.20040524104904.250: *6* A prototype
The next step was also crucial. I started to use Leo1 as a prototype to design
what the new body pane would look like to the user. In retrospect, using Leo1 as
a prototype for Leo2 was just as inspired as using MORE as a prototype for Leo1.
Both prototypes marked the true beginning of their respective projects. The Leo2
prototype was a mockup in Python of the code for reading and writing derived
files. The file LeoDocs.leo contain these first prototype nodes.

Writing the prototype got me thinking about improving noweb. With my experience
with Leo1, I was able to create a new markup language that took advantage of
outline structure. I called the new language "simplified noweb", though that
terminology is obsolete. I created @file nodes to distinguish between the old
and new ways of creating external files. In Leo1, the @code directive is simply
an abbreviation for a section definition line. Simplified noweb used @c as an
abbreviation for @code. More importantly, simplified noweb used @c to separate
doc parts from code parts without necessarily specifying a section name. It
quickly became apparent that most nodes could be unnamed. All I needed was the
@others directive to specify the location for all such unnamed nodes.

From the start, simplified noweb was a joy to use. Indeed, the @others directive
could replace all section definition lines. Furthermore, I could make @doc
directive optional if the body pane started in "code mode". But this meant that
plain body text could become a program! This was an amazing discovery. These
Aha's got me excited about Leo2. This was important, as it motivated me to do a
lot of difficult design work.
.. @+node:EKR.20040524104904.251: *6* User interaction
In spite of this excitement, I was uneasy. After much "daydreaming" I realized
that I was afraid that reading and writing external files would be interrupted by
a long series of alerts. I saw that designing the "user interaction" during
reading and writing would be very important. The next Aha was that I could
replace a long series of alerts with messages to the log window, followed by a
single "summary" alert. Much later I saw how to eliminate alerts entirely.

At this time I thought there would be two kinds of "errors" while reading
external files. Warnings would alert the user that something non-serious had
happened. True errors would alert the user that data might have been lost.
Indeed, if Leo2 saves orphan and ignored nodes in a .leo file under an @file
node, then read errors could endanger such nodes. Much later I saw that a robust
error recovery scheme demands that @file nodes not contain orphan and @ignored
nodes. (More on this subject later.) But if orphan and @ignored nodes are moved
out of @file trees, there are no read errors that can cause data loss! So the
distinction between warnings and errors finally went away.
.. @+node:EKR.20040524104904.252: *6* The write code
I next turned my attention to writing @file nodes. A huge Aha: I realized that
sentinel lines must contain both a leading and a trailing newline. The general
principle is this: the write code must contain absolutely no "conditional"
logic, because otherwise the read code could not figure out whether the
condition should be true or false. So external files contain blank lines between
sentinel lines. These "extra" newlines are very useful, because the read
(untangle) code can now easily determine exactly where every blank, tab and
newline of the external file came from. It would be hard to overstate how
important this simplifying principle was in practice.

Much later, with urging from a customer, I realized that the write code could
safely remove "extra" newlines between sentinels with a caching scheme in the
low level atFile::os() routine. This scheme does not alter the body of the write
code in any way: in effect, sentinels still contain leading and trailing
"logical" newlines. The read code had to be modified to handle "missing" leading
newlines, but this can always be done assuming that sentinels still contain
logical leading and trailing newlines!

At about this time I designed a clever way of having the write code tell the
read code which newlines were inserted in doc parts. (The whole point of doc
parts is to have the write code format long comments by splitting long lines.)
To quote from my diary:

"We can use the following convention to determine where putDocPart has inserted
line breaks: A line in a doc part is followed by an inserted newline if and only
if the newline is preceded by whitespace. This is a really elegant convention,
and is essentially invisible to the user. Tangle outputs words until the line
would become too long, and then it inserts a newline. To preserve all
whitespace, tangle always includes the whitespace that terminates a word on the
same line as the word itself. Therefore, split lines always end in whitespace.
To make this convention work, tangle only has to delete the trailing whitespace
of all lines that are followed by a 'real' newline."
.. @+node:EKR.20040524104904.253: *6* The read code
After the write code was working I turned my attention to the read (untangle)
code. Leo's Untangle command is the most complex and difficult code I have ever
written. Imagine my surprise when I realized that the Leo2 read code is
essentially trivial! Indeed, the Leo2 untangle code is like an assembler. The
read code scans lines of a external files looking for "opcodes", that is,
sentinel lines, and executes some simple code for each separate opcode. The
heart of this code is the scanText routine in atFile.cpp.

The read code was written and debugged in less than two days! It is the most
elegant code I have ever written. While perfecting the read code I realized that
sentinel lines should show the complete nesting structure found in the outline,
even if this information seems redundant. For example, I was tempted to use a
single sentinel to represent an @other directive, but finally abandoned this
plan in favor of the @+other and @-other sentinels.

This redundancy greatly simplified the read code and made the structure of
external files absolutely clear. Moreover, it turned out that we need, in
general, all the information created by the present sentinel lines. In short,
sentinels are as simple as they can be, and no simpler.

The atFile::createNthChild method is a very important: it ensures that nodes
will be correctly inserted into the outline. createNthChild must be bullet-proof
if the Read code is to be robust. Note that the write code outputs @node
sentinels, that is, section definitions, in the order in which sections are
referenced in the outline, not the order in which sections appear in the
outline. So createNthChild must insert the n'th node of parent p properly even
if p contains fewer than n-1 children! The write code ensures that section
references are properly nested: @node sentinels are enclosed in @node sentinels
for all their ancestors in the @file tree. createNthChild creates dummy siblings
as needed, then replaces the dummy siblings later when their actual definitions,
that is, @node sentinels, are encountered.

At this point the fundamental read/write code was complete. I found three minor
bugs in the code over the next week or so, but it was clear that the read/write
code formed a rock-solid base from which to continue design and implementation.
This was an entirely unexpected surprise.
.. @+node:EKR.20040524104904.254: *6* The load/save code
At this point I could read and write external files "by hand", using temporary
Read and Write commands. The next step was to integrate the reading and writing
of external files with the loading and saving of .leo files. From time to time I
made minor changes to the drivers for the read/write code to accommodate the
Load and Save code, but at no time did I significantly alter the read or write
code itself.

The user interaction of the Load and Save commands drove the design and
implementation of the load/store code. The most important questions were: "what
do we tell the user?", and "what does the user do with the information?" It
turns out that the user can't make any complex decision during error recovery
because the user doesn't have nearly enough information to make an informed
choice. In turn, this means that certain kinds of error recovery schemes are out
of the question...
.. @+node:EKR.20040524104904.255: *6* Attributes, mirroring and dummy nodes
I now turned my attention to "attributes" of nodes. Most attributes, like user
marks, are non-essential. However, clone information is essential; we must never
lose clone links. At this time I had a preliminary design for cross-file clones
that involved a two part "pointer" consisting of a full path name and an
immutable clone index within the external file. Eventually such pointers
completely disappeared, but the immutable clone indices remain.

My first thought was that it would be good to store all attributes in @node
sentinels in the external file, but experience showed that would be irritating.
Indeed, one wants Leo2 to rewrite external files only if something essential has
changed. For example, one doesn't want to rewrite the external file just because
a different node as been selected.

At this point I had another Aha: we can use the .leo file to store all
non-essential attributes. For example, this means that the .leo file, not the
external files, will change if we select a new node. In effect, the .leo file
mirrors the external file. The only reason to store nodes in the .leo file under
an @file node is to carry these attributes, so Leo2 wrote dummy nodes that do
not reference body text. Much later I saw that dummy nodes were dangerous and
that .leo files should contain all information found in external files.
.. @+node:EKR.20040524104904.256: *6* Clones
The concept of mirroring created a huge breakthrough with cross-file clones:
Here is an excerpt of an email i sent to my brother Speed:

"I realized this morning that since a .leo file contains dummy vnodes for all
nodes in a external file, those dummy nodes can carry clone info! I changed one
line to make sure that the write code always writes clone info in dummy vnodes
and voila! Cross-file clones worked!"

All of Leo1's clone code could be used completely unchanged. Everything "just
works".
.. @+node:EKR.20040524104904.257: *6* Error recovery, at last
At first I thought we could make sure that the .leo file always correctly
mirrors all external file, but disastrous experience showed that is a completely
false hope. Indeed, backup .leo files will almost never mirror external file
correctly. So it became urgent to find a completely fool-proof error recovery
scheme.

I had known for quite a while that error recovery should work "as if" the
mirroring nodes were deleted, then recreated afresh. Several failed attempts at
an error recovery scheme convinced me that error recovery would actually have to
delete all dummy nodes and then do a complete reread. This is what Leo2 does.

But erasing dummy nodes would destroy any orphan and ignored nodes--by
definition such nodes appear nowhere in the external file. Therefore, I had to
enforce the rule that @file nodes should contain no such nodes. Here is an email
I wrote to my brother, Speed Ream discussing what turned out to be the
penultimate error recovery scheme:

"The error recovery saga continues. After much pondering and some trial coding I
have changed my mind about orphans and @ignored nodes. They simply should never
appear as descendants of @file nodes. Fortunately, this simplifies all aspects
of Leo2. Leo2 will issue a warning (not an error) if an orphan or @ignored node
appears as the descendant of an @file node when a .leo file is being saved. If
any warnings occur while writing the external file, Leo2 will write the
"offending" @file tree to the .leo file instead of the external file. This has
several advantages:

1. The user gets warned about orphan nodes. These are useful warnings! Orphan
nodes arise from missing @others directives or missing section references.

2. The user doesn't have to change anything immediately in order to save an
outline. This is very important. Besides warnings about orphans, Leo2 will also
warn about undefined or unreferenced sections. User's shouldn't have to fix
these warnings to do a Save!

3. No errors or alerts will occur during Reading or Writing, so the user's
anxiety level goes way down. At worst, some informational message will be sent
to the log. The user will never have to make important decisions during Loads or
Saves. [At last the dubious distinction between errors and warnings disappears.]

4. Error recovery can be bullet-proof. Simple code will guarantee that after any
read operation the structure of an @file node will match the structure of the
external file. Also, sentinels in external files will now account for all children
of an @file node. There are no more "missing nodes" that must be filled in using
the .leo file. Finally, error recovery will never change the @file tree in any
way: no more "recovered nodes" nodes.

5. The present read code can be used almost unchanged. The only addition is the
posting of a warning if the structure of the .leo file does not match the
structure of the external file. We need a warning because non-essential attribute
of nodes (like user marks) may be altered."

This ends the original history of Leo2. In fact, it took quite a while before
Leo recovered properly from all errors. I finally saw that .leo files should
duplicate all information in external files. This allows a .leo file to be used a
single backup file and allows maximal error recovery in all situations. It took
several months to stamp out several subtle bugs involving clones that caused
spurious read errors. Such errors undermine confidence in Leo and can cause
disastrous reversions. See my diary entries for January 2002 in leo.py for
details.
.. @+node:ekr.20131008041326.16178: *3* Theory of operation
This sections discusses how Leo's code works, paying particular attention
to topics that have caused difficulties in design or implementation. This
chapter will be of use primarily to those wanting to change Leo's code.

.. @+node:ekr.20050901102300: *4* @rst-no-head links
.. _`History of Leo`:   history.html
.. _`White Papers`:     whitepapers.html
.. @+node:ekr.20120319065417.6092: *4* Autocompletion
.. @+node:ekr.20120229094652.15115: *5* UI notes
Both the legacy and new completer now work *exactly* the same way, because
they both use the AutoCompleterClass to compute the list of completions.

The strict "stateless" requirement means that the "intermediate"
completions must be entered into the body pane while completion is active.
It works well as a visual cue when using the tabbed completer: indeed, the
tabbed completer would be difficult to use without this cue.

The situation is slightly different with the qcompleter. Adding code before
the user accepts the completion might be considered an "advanced" feature.
However, it does have two important advantages, especially when "chaining"
across periods: it indicates the status of the chaining and it limits what
must appear in the qcompleter window.
.. @+node:ekr.20120229094652.15117: *5* Appearance
There is little change to the legacy completer, except that no text is
highlighted in the body pane during completion. This is calmer than before.
Furthermore, there is no longer any need for highlighting, because when the
user types a backspace the legacy completer now simply deletes a single
character instead of the highlighted text.

One minor change: the legacy completer now *does* insert characters that do
not match the start of any possible completion. This is an experimental
feature, but it might play well with using codewise completions as a
fallback to Leo-related completions.

.. @+node:ekr.20120229094652.15119: *5* Performance
Performance of Leo-related completions is *much* better than before. The
old code used Python's inspect module and was horribly complex. The new
code uses eval and is perfectly straightforward.

The present codewise-related code caches completions for all
previously-seen prefixes. This dramatically speeds up backspacing. Global
caching is possible because completions depend *only* on the present
prefix, *not* on the presently selected node. If ContextSniffer were used,
completions would depend on the selected node and caching would likely be
impractical. Despite these improvements, the performance of
codewise-oriented completions is noticeably slower than Leo-related
completions.

The ac.get_cached_options cuts back the prefix until it finds a cached
prefix. ac.compute_completion_list then uses this
(perhaps-way-too-long-list) as a starting point, and computes the final
completion list by calling g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much simpler and more
robust than attempting to do "prefix AI" based on comparing old and new
prefixes. Furthermore, this scheme is completely independent of the how
completions are actually computed. The autocompleter now caches options
lists, regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to get_completions
replace calls to g.itemsMatchingPrefixInList. However, for short prefixes,
the list that g.g.itemsMatchingPrefixInList scans can have thousands of
items. Scanning large lists can't be helped in any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the completionDict
does *not* define state (it is valid everywhere) and no state variables had
to be added. In short, the new caching scheme is much better than before,
and it probably is close to optimal in most situations.
.. @+node:EKR.20040524104904.265: *4* Clones
New in Leo 4.7. All clones of a node **are the same node**. This is the
so-called **one-node** world. In this world, vnodes represent data, generators
and positions represent the location of the data in an outline.  This is a much
simpler world than all previous data representations.

In Leo versions 4.2 to 4.6 clones were represented by sharing **tnodes**. Cloned
vnodes shared the same tnode. This shared tnode represented the entire shared
subtree of both clones. Thus, the _firstChild link had to reside in
*tnodes*, not *vnodes*.

Prior to Leo version 4.2, Leo duplicated all the descendants of vnode v when
cloning v. This created many complications that were removed in the shared tnode
world. In particular, in the shared tnode scheme a vnode v is cloned if and only
if len(v.vnodeList) > 1.
.. @+node:EKR.20040524104904.264: *4* Drawing and events
Leo must redraw the outline pane when commands are executed and as the result of mouse and keyboard events.
The main challenges are eliminating flicker and handling events properly.
These topics are interrelated.

**Eliminating flicker**. Leo must update the outline pane with minimum flicker.
Various versions of Leo have approached this problem in different ways. The
drawing code in leo.py is robust, flexible, relatively simple and should work in
almost any conceivable environment. Leo assumes that all code that changes the
outline pane will be enclosed in matching calls to the c.beginUpdate and
c.endUpdate methods of the Commands class. c.beginUpdate() inhibits drawing
until the matching c.endUpdate(). These calls may be nested; only the outermost
call to c.endUpdate() calls c.redraw() to force a redraw of the outline pane.

Code may call c.endUpdate(flag) instead of c.endUpdate(). Leo redraws
the screen only if flag is true. This allows code to suppress redrawing entirely
when needed. For example, here is how the idle_body_key event handler in
leoTree.py conditionally redraws the outline pane::

	redraw_flag = false
  	c.beginUpdate()
	val = v.computeIcon()
	if val != v.iconVal:
		v.iconVal = val
		redraw_flag = true
	c.endUpdate(redraw_flag) # redraw only if necessary

The leoTree class redraws all icons automatically when c.redraw() is called.
This is a major simplification compared to previous versions of Leo. The entire
machinery of drawing icons in the vnode class has been eliminated. The
v.computeIcon method tells what the icon should be. The v.iconVal ivar
tells what the present icon is. The event handler simply compares these two
values and sets redraw_flag if they don't match.

**Handling events.** Besides redrawing the screen, Leo must handle events or
commands that change the text in the outline or body panes.

The leoTree class contains all the event handlers for the body and outline
panes. The actual work is done in the idle_head_key and idle_body_key methods.
These routines are surprisingly complex; they must handle all the tasks
mentioned above, as well as others. The idle_head_key and idle_body_key methods
should not be called outside the leoTree class. However, it often happens that
code that handles user commands must simulate an event. That is, the code needs
to indicate that headline or body text has changed so that the screen may be
redrawn properly. The leoTree class defines the following simplified event
handlers: onBodyChanged, onBodyWillChange, onBodyKey, onHeadChanged and
onHeadlineKey. Commanders and subcommanders call these event handlers to
indicate that a command has changed, or will change, the headline or body text.
Calling event handlers rather than c.beginUpdate and c.endUpdate ensures that
the outline pane is redrawn only when needed.
.. @+node:EKR.20040524104904.266: *4* Find and change commands
The find and change commands are tricky; there are many details that must be
handled properly. The following principles govern the LeoFind class:

1.  Find and Change commands initialize themselves using only the state of the
    present Leo window. In particular, the Find class must not save internal
    state information from one invocation to the next. This means that when the
    user changes the nodes, or selects new text in headline or body text, those
    changes will affect the next invocation of any Find or Change command.
    Failure to follow this principle caused all kinds of problems in the Borland
    and Macintosh codes. There is one exception to this rule: we must remember
    where interactive wrapped searches start. This principle simplifies the code
    because most ivars do not persist. However, each command must ensure that
    the Leo window is left in a state suitable for restarting the incremental
    (interactive) Find and Change commands. Details of initialization are
    discussed below.

2.  The Find and Change commands must not change the state of the outline or body
    pane during execution. That would cause severe flashing and slow down the
    commands a great deal. In particular, the c.selectPosition and c.editPosition
    methods must not be called while looking for matches.

3.  When incremental Find or Change commands succeed they must leave the Leo
    window in the proper state to execute another incremental command. We
    restore the Leo window as it was on entry whenever an incremental search
    fails and after any Find All and Replace All command. Initialization involves
    setting the self.c, self.v, self.in_headline, self.wrapping and
    self.s_text ivars.

Setting self.in_headline is tricky; we must be sure to retain the state of the
outline pane until initialization is complete. Initializing the Find All and
Replace All commands is much easier because such initialization does not depend
on the state of the Leo window. Using the same kind of text widget for both
headlines and body text results in a huge simplification of the code.

Indeed, the searching code does not know whether it is searching headline or
body text. The search code knows only that self.s_text is a text widget that
contains the text to be searched or changed and the insert and sel attributes
of self.search_text indicate the range of text to be searched. Searching
headline and body text simultaneously is complicated. The selectNextVnode()
method handles the many details involved by setting self.s_text and its insert
and sel attributes.
.. @+node:ekr.20110611085637.5019: *4* Key handling
The following three sections deal with different aspects of how Leo handle's
keystrokes that the user types. This is the most complex code in Leo.
.. @+node:ekr.20110611085637.5014: *5* Key domains
Leo's key-handling code has almost nothing to do with supporting multiple guis.
Rather, the key-handling code is complex because it must deal with the following
four fundamentally different problem domains.
.. @+node:ekr.20110611085637.5015: *6* Domain 1: Parsing user bindings in @keys, @mode and @shortcut nodes
In this domain, complexity arises from allowing the user a variety of
*equivalent* ways of specifying bindings. Furthermore, this domain allows the
user to specify modes and per-pane bindings. Thus, all these complexities are
unavoidable.
.. @+node:ekr.20110611085637.5016: *6* Domain 2: Maintaining and using binding tables
The result of parsing user bindings are a set of binding tables. These tables
are complex, but we need not go into details here because only one method,
k.masterKeyHandler (and its helper, getPaneBinding) uses the tables.

The only thing we have to remember about the binding tables is that bindings are
expressed in terms of so-called **strokes**.  Strokes are the "official" form of
every user binding.  The essential property of a stroke is that it contains
*all* the information required to handle the stroke: Leo can unambiguously
determine exactly what a stroke means and what bindings are in effect for a
stroke.  If necessary, Leo can correctly insert the proper character
*corresponding* to the stroke into any text widget. 

This correspondence (association) between the stroke and the actual
character to be inserted into text widgets is crucial.  This
correspondence is created in the next domain.

Anticipating a bit, for any incoming key event, event.stroke is the
stroke, and event.char is the character (if any) that *might*
(depending on bindings) be inserted into text widgets.

**New in Leo 4.9**: k.stroke2char calculates the to-be-inserted char from
any stroke.
.. @+node:ekr.20110611085637.5017: *6* Domain 3: Translating incoming key events into standard events
The eventFilter method in qtGui.py creates leoKeyEvent objects.  Turning "raw"
Qt key events into leoKeyEvents is unavoidably complicated because eventFilter
(and its allies) **must** carefully compute the stroke corresponding to the raw
key event.  There is no way around this requirement if Leo's binding machinery
in domain 2 is to work.  This code has been stable for a long time. 
.. @+node:ekr.20110611085637.5018: *6* Domain 4: Printing key bindings in a human-readable format
It's important not to forget this domain: there are some situations in which we
want to represent '\b','\r','\n' and '\t' as 'BackSpace','Linefeed','Return' and
'Tab'.
.. @+node:ekr.20060602142732: *5* Key bindings
There are two kinds of bindings, gui bindings and pane bindings.

**Gui bindings** are the actual binding as seen by  whatever gui is in effect.
Leo binds every key that has a binding to k.masterKeyHander.

At present Leo makes gui bindings in several places, all equivalent.
Bindings are made to callbacks, all of which have this form::

     def callback(event=None,k=k,stroke=stroke):
        return k.masterKeyHandler(event,stroke)

As a result, changing gui bindings actually has no effect whatever.
It would be clearer to have a single place to make these bindings...

In any case, the purpose of these callbacks is to capture the value of 'stroke' so
that it can be passed to k.masterKeyHandler.
This relieves k.masterKeyHandler of the impossible task of computing the stroke from the event.

**Important**:  No function argument is ever passed to k.masterKeyHandler from these callbacks,
because k.masterKeyHandler binds keys to command handlers as described next.

**Pane bindings** are bindings represented by various Python dictionaries in the
keyHandlerClass (see below). k.masterKeyHandler and its helpers use these
dictionaries to call the proper command or mode handler. This logic is hairy,
but it is completely separate from the gui binding logic.

Here are the dictionaries that k.masterKeyHandler uses:

- c.commandsDict:
  Keys are minibuffer command names; values are functions f.

- k.inverseCommandsDict:
  Keys are f.__name__l values are emacs command names.

- k.bindingsDict:
  Keys are shortcuts; values are *lists* of g.bunch(func,name,warningGiven).

- k.masterBindingsDict:
  Keys are pane names: 'all','text',etc. or mode names.
  Values are dicts:  keys are strokes; values are g.Bunch(commandName,func,pane,stroke).

- k.modeWidgetsDict:
  Keys are mode names; values are lists of widgets to which bindings have been made.

- k.settingsNameDict:
  Keys are lowercase settings; values are 'real' Tk key specifiers.
  Important: this table has no inverse.

- inverseBindingDict:
  This is *not* an ivar; it is computed by k.computeInverseBindingDict().
  Keys are emacs command names; values are *lists* of shortcuts.
.. @+node:ekr.20110609120520.16494: *5* Handling key events
.. @+node:ekr.20120313134250.15733: *6* All events are key events
All event objects passed around Leo are *key* event objects. Taking a look at
the eventFilter method, we see clearly see that *only* key events ever get
passed to Leo's core. All other events are handled by Qt-specific event
handlers.

As can be seen, these non-key events *can* be passed to Leo, but only as the
event arg in g.doHook (!) At present, no plugin ever calls k.masterKeyHandler.
The only call to k.masterKeyHandler in qtGui.py is the expected call in
eventFilter.

There are other calls to k.masterKeyHandler in Leo's core, but we can prove (by
induction, if you will), that all events passed to k.masterKeyHandler are proper
leoKeyEvent objects.
.. @+node:ekr.20120313134250.15734: *6* c.check_event
The essential invariant is that the events passed to Leo's core methods really
are leoKeyEvent objects created by qtGui.py.  Rather than asserting this
invariant, the code will contains calls to c.check_event in essential places. 
c.check_event is a "relaxed" place to do as much error checking is needed.  In
particular, running the unit tests calls c.check_event many times. 

c.check_event is a happy "accident".  It turns out to be the essential
consistency check that continually verifies that the Qt event methods are
delivering the expected keys to k.masterKeyHandler. 
.. @+node:ekr.20120315101404.14218: *5* About the KeyStroke class
The KeyStroke class distinguish between "raw" user settings
and the "canonicalized" form used throughout Leo. Indeed,
the ability to explicitly distinguish between the two, using
type checking, substantially clarifies and simplifies the
code.

The KeyStroke class makes possible vital type-related
assertions. Knowing *for sure* exactly what crucial data is
and what it means is a huge step forward.

Objects of the KeyStroke class can be used *exactly* as a
strings may be used:

A. KeyStroke objects may be used as dictionary keys, because
they have __hash__ methods and all the so-called rich
comparison methods: __eq__, __ne__, __ge__, __gt__, __le__
and __lt__. Note that KeyStroke objects may be compared with
other KeyStroke objects, strings and None.

B. At present, KeyStroke objects supports the find, lower
and startswith methods. This simplifies the code
substantially: we can apply these methods to either strings
or KeyStroke objects, so there is no need to create
different versions of the code depending on the value of
g.new_strokes.

However, having the KeyStroke class support string methods
is bad design. Indeed, it is a symptom that the client code
that uses KeyStroke objects knows too much about the
internals of KeyStroke objects. Instead, the KeyStroke class
should have higher-level methods that use s.find, s.lower
and s.startswith internally.

You could say that the fact that code in leoKeys.py calls
s.find, s.lower and s.startswith is a symptom of non OO
programming. The internal details of settings and strokes
"pollutes" the code. This must be fixed. This will likely
create opportunities for further simplifications.

> Why not just have .s attribute in KeyStroke, that contains
the string version?

It is truly impossible to understand the key code without
knowing whether an object is a string representing a user
setting or the canonicalized version used in Leo's core,
that is, a KeyStroke object. Using ks.s instead of ks
destroys precisely the information needed to understand the
code.

Again, this is not a theoretical concern. The key code now
contains assertions of the form::

    assert g.isStroke(stroke)

or::

    assert g.isStrokeOrNone(stroke)

Getting these assertions to pass in *all* situations
required several important revisions of the code. The code
that makes the assertions pass is "innocuous", that is,
almost invisible in the mass of code, but obviously, these
small pieces of code are vital.

This is in no way a violation of OO principles. The code is
not dispatching on the type of objects, it is merely
enforcing vital consistency checks. This code is complex:
confusion about the types of objects is intolerable.
Happily, the resulting clarity allows the code to be
substantially simpler than it would otherwise be, which in
turn clarifies the code further, and so on...
.. @+node:ekr.20120315101404.14219: *5* Simplifying the Qt input code
The Qt key input code can be greatly simplified by calling a
new k.makeKeyStrokeFromData factory method. At present, the
Qt key input code knows *all* the details of the format of
*canonicalized* settings. This is absolutely wretched
design.

Instead, the Qt input key code should simply pass the key
modifiers and other key information to
k.makeKeyStrokeFromData, in a some kind of "easy" format.
For example, the Qt input key code would represent the
internal Qt modifiers as lists of strings like "alt",
"ctrl", "meta", "shift". k.makeKeyStrokeFromData would then
create a *user* setting from the components, and then call
k.strokeFromSetting to complete the transformation.
.. @+node:ekr.20120315101404.14220: *5* Typed dicts
Leo's key dictionaries will always be complex, but basing
them on the TypedDict class is a major improvement.

The g.TypedDict and g.TypedDictOfLists classes are useful
for more than type checking: they have unique names and a
dump method that dumps the dict in an easy-to-read format
that includes the name, and valid types for keys and values.

Plain dicts do have their uses, but for "long-lived" dicts,
and dicts passed around between methods, plain dicts are as
ill-advised as g.Bunches.

.. @+node:EKR.20040524104904.263: *4* Nodes
The vnode class is Leo's fundamental model class. A **vnode** represents the
data represented by headlines. As of Leo 4.7, all clones of a node are in fact
**exactly the same node**.

The vnode contains **all** data associated with a node. A vnode contains
headline text, body text, and **user attributes**, uA's for short.

Because Leo has unlimited Undo commands, Leo deletes vnodes only when a window
closes. Leo deletes nodes indirectly using destroy methods. Several classes,
including the vnode, leoFrame and leoTree classes, have destroy methods. destroy
methods merely clear links so that Python's reference counting mechanisms will
eventually delete vnodes and other data when a window closes.

Leo's XML file format uses **tx** and **t** attributes to associate <v> elements
with <t> elements. <v> elements represent nodes. <t> elements represent the body
text of nodes. This is a (somewhat dubious) space optimization. The values of tx
and t attributes are **gnx's** (global node indices). These indices do not
change once a node has created.
.. @+node:EKR.20040524104904.262: *4* Overview
All versions of Leo are organized as a collection of classes. The general
organization of Leo has remained remarkably stable throughout all versions of
Leo, although the names of classes are different in different versions.
Smalltalk's Model/View/Controller terminology is a good way think about Leo's
classes. **Model classes** represent the fundamental data. The vnode
class is Leo's primary model class.

**View classes** draw the screen. The main view classes are leoFrame.py and
leoTree.py. The colorizer class in leoColor.py handles syntax coloring in the
body pane. Leo's view classes know about data stored in the vnode class. Most
events (keystrokes and mouse actions) in the outline and body pane are handled
in the leoTree class. The leoFrame class also creates the Leo window, including
menus, and dispatches the appropriate members of the controller classes in
response to menu commands.

**Controller classes** (aka commanders) control the application. In Leo,
controllers mostly handle menu commands. Commanders create subcommanders to
handle complex commands. The atFile class reads and writes files derived from
\@file trees. The LeoFind class handles the Find and Change commands. The
leoImportCommands class handles the Import and Export commands, and the undoer
class handles the Undo command. Other classes could be considered controller
classes.

Each Leo window has its own commander and subcommanders. Subcommanders are not
subclasses of their commander. Instead, subcommanders know the commander that
created them, and call that commander as needed. Commanders and subcommanders
call the model and view classes as needed. For example, the Commands class
handles outline commands. To move a headline, the commander for the window calls
a vnode move routine to alter the data, then calls the view class to redraw the
screen based on the new data.

A singleton instance of the **LeoApp** class represents the application itself.
All code uses the app() global function to gain access to this singleton member.
The ivars of the LeoApp object are the equivalent of Leo's global variables.
leo.py uses no global Python variables, except the gApp variable returned by
app(). leoGlobals.py defines all application constants. Naturally, most
constants are local to the class that uses them.

Several classes combine aspects of model, view and controller. For example, the
**LeoPrefs** class represents user preferences (model), the Preference Panel
(view) and the Preferences menu command (controller). Similarly, the **LeoFind**
class represents find settings, the Find/Change dialog, and the Find/Change
commands.

We use the following convention throughout this documentation. Any variable
named c is a commander, i.e., an instance of the Commands class in
leoCommands.py. Variables named v are vnodes. These classes are defined in
leoNodes.py.
.. @+node:EKR.20040524104904.268: *4* Unicode
Leo uses unicode objects in vnodes to denote headline and body text.
Note that unicode strings have no encoding; only plain strings have encodings.
This means that once an (encoded) plain string has been converted to a unicode
string it doesn't matter how the unicode string was created. This is the key
that makes Leo's new code robust: internally Leo never has to worry about
encodings. Encoding matter only when encoded strings are converted to and from
Unicode. This happens when Leo reads or writes files.

Python expressions that mix unicode strings u and plain strings s, like one of these::

	u + s
	u == s
	u[5] == s[2:]

are promoted to unicode objects using the "system encoding". This encoding
should never be changed, but we can't assume that we know what it is, so for
safety we should assume the most restrictive encoding, namely "ascii". With this
assumption, Leo's code can't throw an exception during these promotions provided
that: 

- Leo converts all text to unicode when Leo reads files or gets text from
  text widgets.

- All string literals in Leo's code have only ascii characters.
.. @+node:EKR.20040524104904.269: *4* Unlimited undo
Unlimited undo is straightforward; it merely requires that all commands that
affect the outline or body text must be undoable. In other words, everything
that affects the outline or body text must be remembered. We may think of all
the actions that may be Undone or Redone as a string of beads (undo nodes).

Undoing an operation moves backwards to the next bead; redoing an operation moves
forwards to the next bead. A bead pointer points to the present bead. The bead
pointer points in front of the first bead when Undo is disabled. The bead
pointer points at the last bead when Redo is disabled. An undo node is a Python
dictionary containing all information needed to undo or redo the operation. The
Undo command uses the present bead to undo the action, then moves the bead
pointer backwards.

The Redo command uses the bead after the present bead to redo the action, then
moves the bead pointer forwards. All undoable operations call setUndoParams() to
create a new bead. The list of beads does not branch; all undoable operations
(except the Undo and Redo commands themselves) delete any beads following the
newly created bead. I did not invent this model of unlimited undo.
I first came across it in the documentation for Apple's Yellow Box classes.
.. @+node:ekr.20120229094652.15141: *4* Leo's load process
Leo reads local files twice. The first load discovers the
settings to be used in the second load. This ensures that
proper settings are *available* during the second load.

Ctors init settings "early", before calling the ctors for
subsidiary objects. This ensures that proper settings are
*in effect* for the subsidiary ctors.

After creating all subsidiary objects, c.__init__ simply
calls c.finishCreate! Creating Commands objects is now
completely self-contained. In particular, c.__init__ now
creates the fully-inited gui frame. This is a revolution in
Leo's startup code! c.__init__ no longer needs a frame
argument, a surprisingly important conceptual
simplification.

The old code inited Leo windows in several *places*
(c.__init__, the end of g.app.newLeoCommanderAndFrame and
the end of g.openWithFileName) and in several *phases*,
(g.app.newCommanderAndFrame, g.openWithFileName and
c.finishCreate.)

The new code has c.__init__ do *all* the work, in one place,
and in one phase. This is supremely important for future
maintainers. The old code was difficult for me to understand
yesterday, even after a full week of study. The new code is
a simple as could possibly be imagined. This is a gigantic
step forward for Leo.
.. @+node:ekr.20050901084134: *3* Why I like Python
I wrote this soon after discovering Python in 2001. The conclusions are
still valid today.
    
I've known for a while that Python was interesting; I attended a Python
conference last year and added Python support to Leo. But last week I got that
Python is something truly remarkable. I wanted to convert Leo from wxWindows to
wxPython, so I began work on c2py, a Python script that would help convert from
C++ syntax to Python. While doing so, I had an Aha experience. Python is more
than an incremental improvement over Smalltalk or C++ or objective-C; it is
"something completely different". The rest of this post tries to explain this
difference.


.. @+node:ekr.20050901092232.2: *4* Clarity
What struck me first as I converted C++ code to Python is how much less blah,
blah, blah there is in Python. No braces, no stupid semicolons and most
importantly, *no declarations*. No more pointless distinctions between
const, char \*, char const \*, char \* and wxString.
No more wondering whether a variable should be signed, unsigned, short or long.

Declarations add clutter, declarations are never obviously right and
declarations don't prevent memory allocation tragedies. Declarations also hinder
prototyping. In C++, if I change the type of something I must change all related
declarations; this can be a huge and dangerous task. With Python, I can change
the type of an object without changing the code at all! It's no accident that
Leo's new log pane was created first in Python.

Functions returning tuples are a "minor" feature with a huge impact on code
clarity. No more passing pointers to data, no more defining (and allocating and
deallocating) temporary structs to hold multiple values.

.. _`pylint`: http://www.logilab.org/857

Python can't check declarations because there aren't any. However, there is a
really nifty tool called `pylint`_ that does many of the checks typically done
by compilers.
.. @+node:ekr.20050901092232.3: *4* Power
Python is much more powerful than C++, not because Python has more features, but
because Python needs *less* features. Some examples:

-   Python does everything that the C++ Standard Template Library (STL) does,
    without any of the blah, blah, blah needed by STL.
    No fuss, no muss, no code bloat.

-   Python's slicing mechanism is very powerful and applies to any sequence (string, list or tuple).
    Python's string library does more with far less functions because slices replace many functions
    typically found in other string libraries.

-   Writing dict = {} creates a dictionary (hash table).
    Hash tables can contain anything, including lists and other hash tables.

-   Python's special functions,  __init__, __del__, __repr__, __cmp__, etc.
    are an elegant way to handle any special need that might arise.
.. @+node:ekr.20050901092232.4: *4* Safety
Before using Python I never fully realized how difficult and dangerous memory allocation is in C++.
Try doing::

        aList[i:j] = list(aString)

in C.  You will write about 20 lines of C code.
Any error in this code will create a memory allocation crash or leak.

Python is fundamentally safe. C++ is fundamentally unsafe. When I am using
Python I am free from worry and anxiety. When I am using C++ I must be
constantly "on guard." A momentary lapse can create a hard-to-find pointer bug.
With Python, almost nothing serious can ever go wrong, so I can work late at
night, or after a beer. The Python debugger is always available. If an exception
occurs, the debugger/interpreter tells me just what went wrong. I don't have to
plan a debugging strategy! Finally, Python recovers from exceptions, so Leo can
keep right on going even after a crash!
.. @+node:ekr.20050901092232.5: *4* Speed
Python has almost all the speed of C. Other interpretive environments such as
icon and Smalltalk have clarity, power and safety similar to Python. What makes
Python unique is its seamless way of making C code look like Python code.
Python executes at essentially the speed of C code because most Python modules
are written in C. The overhead in calling such modules is negligible. Moreover,
if code is too slow, one can always create a C module to do the job.

In fact, Python encourages optimization by moving to higher levels of
expression. For example, Leo's Open command reads an XML file. If this command
is too slow I can use Python's XML parser module. This will speed up Leo while
at the same time raising the level of the code.
.. @+node:ekr.20050901092232.6: *4* Conclusions
Little of Python is completely new. What stands out is the superb engineering
judgment evident in Python's design. Python is extremely powerful, yet small,
simple and elegant. Python allows me to express my intentions clearly and at the
highest possible level.

The only hope of making Leo all it can be is to use the best possible tools. I
believe Python will allow me to add, at long last, the new features that Leo
should have.

Edward K. Ream, October 25, 2001.  P.S., September, 2005:

Four years of experience have only added to my admiration for Python. Leo could
not possibly be what it is today without Python.
.. @-all
.. @-leo
